// ---------------------------------------------------------------------------

#include <vcl.h>
#include "ConstantsANWIN.h"
#include "TSNIncludes.h"
#include "GroupLinePressureUnit.h"
#pragma hdrstop

// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "GroupUnit"
#pragma link "RzButton"
#pragma link "frxClass"
#pragma link "frxCross"
#pragma link "AdvGrid"
#pragma link "AdvObj"
#pragma link "AdvUtil"
#pragma link "BaseGrid"
#pragma resource "*.dfm"
TGroupTableLinePressure *GroupTableLinePressure;

// ---------------------------------------------------------------------------
__fastcall TGroupTableLinePressure::TGroupTableLinePressure(TComponent* Owner)
	: TGroupTable(Owner, PROLinePressure::ObjVector) {
}

// ---------------------------------------------------------------------------
vector<int>__fastcall TGroupTableLinePressure::SetDefaultValTable(void) {
	int DefValueTable[] = {
		SVT_PRO_STATUS		, SVT_PRO_NAME		, SVT_PRESSURE,
		SVT_LO_PRESS_LIMIT	, SVT_HI_PRESS_LIMIT, SVT_HIHI_PRESS_LIMIT};

	vector<int>ValVector;
	for (unsigned i = 0; i < GRID_COLUMNS; i++) {
		int ValKey = SVT_BLANK;
		if (i < NELEMENTS(DefValueTable)) {
			ValKey = DefValueTable[i];
		}
		ValVector.push_back(ValKey);
	}
	return ValVector;

}

// ---------------------------------------------------------------------------
vector<int>__fastcall TGroupTableLinePressure::SetAlarmValTable(void) {
	int AlarmValueTable[] = {
		SVT_PRO_STATUS, SVT_PRO_NAME, SVT_LO_PRESS_LIMIT, SVT_HI_PRESS_LIMIT, SVT_HIHI_PRESS_LIMIT};

	vector<int>ValVector;
	for (unsigned i = 0; i < GRID_COLUMNS; i++) {
		int ValKey = SVT_BLANK;
		if (i < NELEMENTS(AlarmValueTable)) {
			ValKey = AlarmValueTable[i];
		}
		ValVector.push_back(ValKey);
	}
	return ValVector;

}

// ---------------------------------------------------------------------------
vector<int>__fastcall TGroupTableLinePressure::SetSensorValTable(void) {
	const int SensorValueTable[] = {
		SVT_PRO_STATUS, SVT_PRO_NAME, SVT_PRESSURE, SVT_LP_ENABLE_TEXT,
		SVT_LP_GAIN,SVT_LP_OFFSET};

	vector<int>ValVector;
	for (unsigned i = 0; i < GRID_COLUMNS; i++) {
		int ValKey = SVT_BLANK;
		if (i < NELEMENTS(SensorValueTable)) {
			ValKey = SensorValueTable[i];
		}
		ValVector.push_back(ValKey);
	}
	return ValVector;

}

// ---------------------------------------------------------------------------
PROXRefObject* __fastcall TGroupTableLinePressure::NewPartSum(void) {
	PROXRefObject *tmpTemp = (PROXRefObject*) new PROLinePressureSum(CurrentTable, false);
	return tmpTemp;
}

