//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.41A/W32              05/Jun/2007  08:51:09 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\S2Prog\TXU\src\TXU_ RTOSInit.c                   /
//    Command line    =  "D:\S2Prog\TXU\src\TXU_ RTOSInit.c" --fpu None -D   /
//                       OS_LIBMODE_DT -D CPU_S3C2410 -D OS_RAMVECT=0 -D     /
//                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D                 /
//                       __ARM_LIBRARY__ -D WATCHDOG=0 -lA                   /
//                       D:\S2Prog\TXU\TargetDebug\List\ -o                  /
//                       D:\S2Prog\TXU\TargetDebug\Obj\ -s2 --no_cse         /
//                       --no_unroll --no_inline --no_code_motion --no_tbaa  /
//                       --no_clustering --no_scheduling --debug --cpu_mode  /
//                       arm --endian little --cpu ARM920T --stack_align 4   /
//                       --interwork -e --enable_multibytes --dlib_config    /
//                       "C:\Program Files\IAR Systems\Embedded Workbench    /
//                       4.0\ARM\LIB\dl4tpainl8f.h" -I                       /
//                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\    /
//                       -I D:\S2Prog\TXU\GUI\WIDGET\ -I                     /
//                       D:\S2Prog\TXU\CONFIG\ -I D:\S2Prog\TXU\INC\ -I      /
//                       D:\S2Prog\TXU\..\SHARED\INC\ -I                     /
//                       D:\S2Prog\TXU\..\SHARED\SRC\ -I                     /
//                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.108\ -I         /
//                       "C:\Program Files\IAR Systems\Embedded Workbench    /
//                       4.0\ARM\INC\"                                       /
//    List file       =  D:\S2Prog\TXU\TargetDebug\List\TXU_ RTOSInit.s79    /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME `TXU_ RTOSInit`

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        EXTERN ??divu32_a

        PUBWEAK `?*?DATA_ID`
??DataTable0 EQU 0
??DataTable1 EQU 0
??DataTable2 EQU 0
??DataTable3 EQU 0
        MULTWEAK ??HandleUARTInterrupt??rA
        MULTWEAK ??OS_COM_ClearTxActive??rA
        MULTWEAK ??OS_COM_Init??rT
        MULTWEAK ??OS_COM_Send1??rT
        MULTWEAK ??OS_ConvertCycles2us??rT
        MULTWEAK ??OS_Error??rA
        MULTWEAK ??OS_GetTime_Cycles??rT
        MULTWEAK ??OS_Idle??rT
        MULTWEAK ??OS_InitHW??rT
        MULTWEAK ??OS_SignalEvent??rA
        MULTWEAK ??OS_SwitchFromInt??rA
        MULTWEAK ??OS_TickHandler??rA
        MULTWEAK ??OS_irq_handler??rT
        MULTWEAK ??rA??divu32_a
        MULTWEAK ??swi_handler??rT
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC ADCCon
        PUBLIC ADChannel
        PUBLIC ADIntCnt
        PUBLIC CurrentTime
        PUBLIC DefaultIrqCnt
        PUBLIC FastTime
        PUBLIC InTimerFlag
        PUBLIC Inc1CntDown
        PUBLIC Inc1CntUp
        PUBLIC Inc2CntDown
        PUBLIC Inc2CntUp
        PUBLIC IrqCnt
        PUBLIC IsDown
        PUBLIC KbdIntCnt
        PUBWEAK LastErrAddress
        PUBWEAK LastOSError
        PUBLIC OS_COM_Init
        FUNCTION OS_COM_Init,0203H
        PUBLIC OS_COM_Send1
        FUNCTION OS_COM_Send1,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC OS_ConvertCycles2us
        FUNCTION OS_ConvertCycles2us,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC OS_GetTime_Cycles
        FUNCTION OS_GetTime_Cycles,0203H
        PUBLIC OS_Idle
        FUNCTION OS_Idle,0203H
        PUBLIC OS_InitHW
        FUNCTION OS_InitHW,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC OS_irq_handler
        FUNCTION OS_irq_handler,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC RunningTime
        PUBLIC TCCnt
        PUBLIC TXUADData
        PUBLIC TouchKeyPressed
        PUBLIC data_handler
        FUNCTION data_handler,080203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC fiq_handler
        FUNCTION fiq_handler,0203H
        PUBLIC prefetch_handler
        FUNCTION prefetch_handler,080203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC swi_handler
        FUNCTION swi_handler,0203H
        PUBLIC undef_handler
        FUNCTION undef_handler,080203H
        LOCFRAME CSTACK, 8, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
        
        CFI Common cfiCommon2 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 SameValue
        CFI CPSR SPSR
        CFI R14 Undefined
        CFI SPSR Undefined
        CFI ?RET add(R14, literal(-4))
        CFI EndCommon cfiCommon2
        
HandleUARTInterrupt SYMBOL "HandleUARTInterrupt"
OS_COM_ClearTxActive SYMBOL "OS_COM_ClearTxActive"
OS_Error            SYMBOL "OS_Error"
OS_SignalEvent      SYMBOL "OS_SignalEvent"
OS_SwitchFromInt    SYMBOL "OS_SwitchFromInt"
OS_TickHandler      SYMBOL "OS_TickHandler"
??HandleUARTInterrupt??rA SYMBOL "??rA", HandleUARTInterrupt
??OS_COM_ClearTxActive??rA SYMBOL "??rA", OS_COM_ClearTxActive
OS_COM_Init         SYMBOL "OS_COM_Init"
??OS_COM_Init??rT   SYMBOL "??rT", OS_COM_Init
OS_COM_Send1        SYMBOL "OS_COM_Send1"
??OS_COM_Send1??rT  SYMBOL "??rT", OS_COM_Send1
OS_ConvertCycles2us SYMBOL "OS_ConvertCycles2us"
??OS_ConvertCycles2us??rT SYMBOL "??rT", OS_ConvertCycles2us
??OS_Error??rA      SYMBOL "??rA", OS_Error
OS_GetTime_Cycles   SYMBOL "OS_GetTime_Cycles"
??OS_GetTime_Cycles??rT SYMBOL "??rT", OS_GetTime_Cycles
OS_Idle             SYMBOL "OS_Idle"
??OS_Idle??rT       SYMBOL "??rT", OS_Idle
OS_InitHW           SYMBOL "OS_InitHW"
??OS_InitHW??rT     SYMBOL "??rT", OS_InitHW
??OS_SignalEvent??rA SYMBOL "??rA", OS_SignalEvent
??OS_SwitchFromInt??rA SYMBOL "??rA", OS_SwitchFromInt
??OS_TickHandler??rA SYMBOL "??rA", OS_TickHandler
OS_irq_handler      SYMBOL "OS_irq_handler"
??OS_irq_handler??rT SYMBOL "??rT", OS_irq_handler
swi_handler         SYMBOL "swi_handler"
??swi_handler??rT   SYMBOL "??rT", swi_handler

        EXTERN CurrentDeviceId
        EXTERN GlobalDeviceHWId
        EXTERN HandleUARTInterrupt
        FUNCTION HandleUARTInterrupt,0202H
        EXTERN OS_COM_ClearTxActive
        FUNCTION OS_COM_ClearTxActive,0202H
        EXTERN OS_Counters
        EXTERN OS_Error
        FUNCTION OS_Error,0202H
        EXTERN OS_InInt
        EXTERN OS_Pending
        EXTERN OS_SignalEvent
        FUNCTION OS_SignalEvent,0202H
        EXTERN OS_SwitchFromInt
        FUNCTION OS_SwitchFromInt,0202H
        EXTERN OS_TickHandler
        FUNCTION OS_TickHandler,0202H
        EXTERN OS_Time
        EXTERN ReadTouchKey

// D:\S2Prog\TXU\src\TXU_ RTOSInit.c
//    1 /*********************************************************************
//    2 *                SEGGER MICROCONTROLLER SYSTEME GmbH                 *
//    3 *        Solutions for real time microcontroller applications        *
//    4 **********************************************************************
//    5 
//    6 File        : RTOSInit.c
//    7 Purpose     : Initializes and handles the hardware for embOS as far
//    8 				as required by embOS.
//    9 				Feel free to modify this file acc. to your
//   10 				target system.
//   11 ---------------------------END-OF-HEADER------------------------------
//   12 */
//   13 
//   14 /*
//   15 	Please note:
//   16 	We do automatic release tests for embOS. These tests are done with the
//   17 	CPU_KS32C50100. You will find drivers for additional CPUs, which are used
//   18 	by our customers. These drivers have also been   tested at least one time,
//   19 	but they are not part of our periodic automatic release tests. Therefore
//   20 	it might happen, that you encounter a problem with these additional drivers.
//   21 */
//   22 
//   23 #include "RTOS.H"
//   24 #include "2410addr.h"
//   25 #include "2410lib.h"
//   26 #include "ANPRO10Const.h"
//   27 #include "TSNConstants.h"
//   28 #include "Def.h"
//   29 #include "FixedVariables.h"

        ASEGN DATA_AN:DATA:NOROOT,031fff010H
// unsigned int volatile __data LastOSError
LastOSError:
        DS8 4

        ASEGN DATA_AN:DATA:NOROOT,031fff048H
// unsigned int volatile __data LastErrAddress
LastErrAddress:
        DS8 4
//   30 #include <time.h>
//   31 
//   32 extern short CurrentDeviceId;
//   33 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   34 U16  TXUADData[8];
TXUADData:
        DS8 16

        RSEG DATA_Z:DATA:SORT:NOROOT(0)
//   35 U8    ADChannel = 0 ;
ADChannel:
        DS8 1
//   36 

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   37 U16   Inc1CntUp   =0;
Inc1CntUp:
        DS8 2

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   38 U16   Inc1CntDown =0;
Inc1CntDown:
        DS8 2

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   39 U16   Inc2CntUp   =0;
Inc2CntUp:
        DS8 2

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   40 U16   Inc2CntDown =0;
Inc2CntDown:
        DS8 2
//   41 
//   42 
//   43 typedef struct {
//   44 	unsigned EnableStart:1;
//   45 	unsigned ReadStart:1;
//   46 	unsigned StdBM:1;
//   47 	unsigned SelMux:3;
//   48 	unsigned PrScVl:8;
//   49 	unsigned PrScEn:1;
//   50 	unsigned ECFlg:1;
//   51 	//unsigned Dummy:16;
//   52 }ADCConStruct;
//   53 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   54 unsigned KbdIntCnt = 0;
KbdIntCnt:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   55 unsigned ADIntCnt = 0;
ADIntCnt:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(0)
//   56 unsigned char TouchKeyPressed = 0;					//status for the touch key
TouchKeyPressed:
        DS8 1

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   57 ADCConStruct *ADCCon = (ADCConStruct*)&rADCCON;
ADCCon:
        DS8 4
        REQUIRE `?<Initializer for ADCCon>`

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??OS_InitHW??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE OS_InitHW
//   58 
//   59 extern void HandleUARTInterrupt(int Port);
//   60 //#ifndef ANBOOTLOADER
//   61 extern OS_TASK *ReadTouchKey;								/* Task control blocks */
//   62 //#endif
//   63 
//   64 
//   65 void OS_USER_irq_func(void);
//   66 
//   67 /*
//   68 **********************************************************************
//   69 *
//   70 *                    Configuration
//   71 *
//   72 **********************************************************************
//   73 */
//   74 
//   75 /* Select UART for embOSView, set baudrate,
//   76 	 define clock frequency for CPU used
//   77 
//   78 	 If you do not want (or can not due to hardware limitations) to dedicate
//   79 	 a UART to embOSView, please define OS_UART to -1
//   80 */
//   81 
//   82 #ifndef CPU_S3C2410
//   83 //#error "This file is for S3C2410 CPU"
//   84 #endif
//   85 
//   86 
//   87 /*********************************************************************
//   88 *
//   89 *         Non HW dependent configuration defaults
//   90 *
//   91 **********************************************************************
//   92 */
//   93 
//   94 #ifndef OS_TICK_FREQ
//   95 	#define OS_TICK_FREQ 1000
//   96 #endif
//   97 
//   98 #ifndef USE_CACHE
//   99 	#define USE_CACHE 1   /* 0: No chache */
//  100 #endif
//  101 
//  102 
//  103 
//  104 #ifndef OS_BAUDRATE
//  105 	#define OS_BAUDRATE 38400
//  106 #endif
//  107 
//  108 #ifndef OS_RAMVECT
//  109 	#define OS_RAMVECT 0
//  110 #endif
//  111 
//  112 
//  113 
//  114 #define TIMER_PRESCALE0  1              /* prescaler for timer frequency */
//  115 #define TIMER_PRESCALE1  5            /* prescaler for timer frequency */
//  116 #define TIMER_RELOAD       (OS_FSYS/8/(TIMER_PRESCALE0+1)/OS_TICK_FREQ)
//  117 #define TIMER0_START  ( ( 1 << 3 ) | 1 ) // Reload and start
//  118 #define TIMER0_UPDATE ( ( 1 << 1 ) )
//  119 
//  120 
//  121 #define TIMER2_START  ( ( 0 << 15 ) | (1 << 12 )) // One shot and start
//  122 #define TIMER2_UPDATE ( ( 1 << 13 ) )
//  123 #define TIMER3_START  ( ( 0 << 19 ) | (1 << 16 )) // One shot and start
//  124 #define TIMER3_UPDATE ( ( 1 << 17 ) )
//  125 
//  126 /*
//  127 **********************************************************************
//  128 *
//  129 *                    OS_InitHW
//  130 *
//  131 **********************************************************************
//  132 
//  133 Initialize the hardware required for the OS to run. This will work
//  134 on any target hardware, but may have to be tailored a little
//  135 (regarding the clock frequency). Of course the same holds true
//  136 if for some reason you choose to use an other timer.
//  137 */
//  138 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function OS_InitHW
        ARM
//  139 void OS_InitHW(void) {
OS_InitHW:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  140 	rINTMSK    = 0xffffffff;	 // Mask timer interrupt
        MOV      R0,#+8
        ORR      R0,R0,#0x4A000000
        MVN      R1,#+0
        STR      R1,[R0, #+0]
//  141 	rINTSUBMSK = 0x7ff;
        MOV      R0,#+28
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+255
        ORR      R1,R1,#0x700
        STR      R1,[R0, #+0]
//  142 	rSUBSRCPND = 0;
        MOV      R0,#+24
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+0
        STR      R1,[R0, #+0]
//  143 
//  144 
//  145 
//  146 
//  147 #if OS_RAMVECT
//  148 	{
//  149 		unsigned int vec;
//  150 		unsigned int *vector;
//  151 		extern void OS_IRQ_SERVICE(void);
//  152 		OS_DI();
//  153 		vector = (unsigned int*) 0x18;
//  154 		vec = (((unsigned int)&OS_IRQ_SERVICE - (unsigned int)vector - 8) >> 2);
//  155 		vec |= 0xea000000; /* add opcode for B instruction */
//  156 		*vector = vec;
//  157 		OS_EI();
//  158 	}
//  159 #endif
//  160 
//  161 
//  162 
//  163 	rTCFG0  = TIMER_PRESCALE0 | ( TIMER_PRESCALE1 << 8 ) | ( 0 << 16 );
        MOV      R0,#+1358954496
        MOV      R1,#+1
        ORR      R1,R1,#0x500
        STR      R1,[R0, #+0]
//  164 	rTCNTB0 = TIMER_RELOAD;
        MOV      R0,#+12
        ORR      R0,R0,#0x51000000
        MOV      R1,#+242
        ORR      R1,R1,#0x2B00
        STR      R1,[R0, #+0]
//  165 	rTCNTB2 = 0xFFFF;
        MOV      R0,#+36
        ORR      R0,R0,#0x51000000
        MOV      R1,#+255
        ORR      R1,R1,#0xFF00
        STR      R1,[R0, #+0]
//  166 	rTCMPB2 = 0xFFFF;
        MOV      R0,#+40
        ORR      R0,R0,#0x51000000
        MOV      R1,#+255
        ORR      R1,R1,#0xFF00
        STR      R1,[R0, #+0]
//  167 	rTCNTB3 = 0xFFFF;
        MOV      R0,#+48
        ORR      R0,R0,#0x51000000
        MOV      R1,#+255
        ORR      R1,R1,#0xFF00
        STR      R1,[R0, #+0]
//  168 	rTCMPB3 = 0xFFFF;
        MOV      R0,#+52
        ORR      R0,R0,#0x51000000
        MOV      R1,#+255
        ORR      R1,R1,#0xFF00
        STR      R1,[R0, #+0]
//  169 	//rTCMPB0 = TIMER_RELOAD;
//  170 	switch ( CurrentDeviceId ) {
        LDR      R0,??OS_InitHW_0  ;; CurrentDeviceId
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+32
        BEQ      ??OS_InitHW_1
        CMP      R0,#+48
        BEQ      ??OS_InitHW_2
        B        ??OS_InitHW_3
//  171 		case DEVICE_TCU:	// TCU
//  172 			rTCON   = TIMER0_UPDATE | TIMER2_UPDATE | TIMER3_UPDATE;
??OS_InitHW_1:
        MOV      R0,#+8
        ORR      R0,R0,#0x51000000
        MOV      R1,#+2
        ORR      R1,R1,#0x22000
        STR      R1,[R0, #+0]
//  173 			rTCON   = TIMER0_START | TIMER2_START | TIMER3_START;	// Start timer 0,2,3.  0 shall be in reload mode
        MOV      R0,#+8
        ORR      R0,R0,#0x51000000
        MOV      R1,#+9
        ORR      R1,R1,#0x11000
        STR      R1,[R0, #+0]
        B        ??OS_InitHW_3
//  174 			break;
//  175 		case DEVICE_TDU:	// TDU
//  176 			rTCON   = TIMER0_UPDATE;
??OS_InitHW_2:
        MOV      R0,#+8
        ORR      R0,R0,#0x51000000
        MOV      R1,#+2
        STR      R1,[R0, #+0]
//  177 			rTCON   = TIMER0_START;	// Start timer 0 in reload mode
        MOV      R0,#+8
        ORR      R0,R0,#0x51000000
        MOV      R1,#+9
        STR      R1,[R0, #+0]
//  178 			break;
//  179 	}
//  180 
//  181 
//  182 	rINTPND = 0x00000000;	 /* Clear pending interrupts */
??OS_InitHW_3:
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+0
        STR      R1,[R0, #+0]
//  183 
//  184 
//  185 	//*((unsigned*)0x1c) = (unsigned)OS_fiq_handler;                   //Timer0 FIQ interrupt
//  186 
//  187 	//*((unsigned*)0x1c) |= 0xea000000; /* add opcode for B instruction */
//  188 	rINTMOD = 0x00000000;
        MOV      R0,#+4
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+0
        STR      R1,[R0, #+0]
//  189 	//rINTMOD |= BIT_TIMER0;
//  190 	rINTMSK &= ~(BIT_TIMER0);	// Mask timer interrupt
        MOV      R0,#+8
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+8
        ORR      R1,R1,#0x4A000000
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x400
        STR      R1,[R0, #+0]
//  191 
//  192 	// Start con to embOSView
//  193 	OS_COM_Init();
        BL       OS_COM_Init
//  194 	// start AD for touchscreen //AStmark ADU/TCU must be checked for int setup AD/touch
//  195 	//rADCDLY=(50000);	// ADC Start or Interval Delay
//  196 	rADCDLY= 50000;	// ADC Start or Interval Delay
        MOV      R0,#+8
        ORR      R0,R0,#0x58000000
        MOV      R1,#+80
        ORR      R1,R1,#0xC300
        STR      R1,[R0, #+0]
//  197 	// Enable Prescaler,Prescaler,AIN5/7 fix,Normal,Disable read start,No operation
//  198 	rADCTSC = (0<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(0<<2)|3;//Original
        MOV      R0,#+4
        ORR      R0,R0,#0x58000000
        MOV      R1,#+211
        STR      R1,[R0, #+0]
//  199 	rADCCON = (1<<14)|(255<<6)|(0<<3)|(0<<2)|(0<<1)|(1); // Was befor rADCTSC
        MOV      R0,#+1476395008
        MOV      R1,#+193
        ORR      R1,R1,#0x7F00
        STR      R1,[R0, #+0]
//  200 
//  201 
//  202 	// Down,YM:GND,YP:AIN5,XM:Hi-z,XP:AIN7,XP pullup En,Normal,Waiting for interrupt mode
//  203 	//pISR_ADC=(unsigned)Adc_or_TsAuto;
//  204 	rINTMSK &= ~(BIT_ADC);
        MOV      R0,#+8
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+8
        ORR      R1,R1,#0x4A000000
        LDR      R1,[R1, #+0]
        LSLS     R1,R1,#+1
        LSRS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  205 	switch ( GlobalDeviceHWId ) {
        LDR      R0,??OS_InitHW_0+0x4  ;; GlobalDeviceHWId
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??OS_InitHW_4
        CMP      R0,#+1
        BEQ      ??OS_InitHW_4
        CMP      R0,#+2
        BEQ      ??OS_InitHW_5
        CMP      R0,#+3
        BNE      ??OS_InitHW_6
//  206 		case TDU_R1:
//  207 		case TDU_R2:
//  208 			rINTSUBMSK &= ~(BIT_SUB_TC | BIT_SUB_ADC);
??OS_InitHW_5:
        MOV      R0,#+28
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+28
        ORR      R1,R1,#0x4A000000
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x600
        STR      R1,[R0, #+0]
        B        ??OS_InitHW_6
//  209 			break;
//  210 		case TCU_R1:
//  211 		case TCU_R2:
//  212 			rINTSUBMSK &= ~BIT_SUB_ADC;
??OS_InitHW_4:
        MOV      R0,#+28
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+28
        ORR      R1,R1,#0x4A000000
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x400
        STR      R1,[R0, #+0]
//  213 	}
//  214 
//  215 	rINTMSK &= ~(BIT_EINT4_7 | BIT_EINT8_23);
??OS_InitHW_6:
        MOV      R0,#+8
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+8
        ORR      R1,R1,#0x4A000000
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x30
        STR      R1,[R0, #+0]
//  216 	rEINTMASK &=  ~(BIT_SUB_EINT5 | BIT_SUB_EINT6 | BIT_SUB_EINT7 | BIT_SUB_EINT8 );
        MOV      R0,#+164
        ORR      R0,R0,#0x56000000
        MOV      R1,#+164
        ORR      R1,R1,#0x56000000
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x1E0
        STR      R1,[R0, #+0]
//  217 
//  218 }
        POP      {LR}
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??OS_InitHW_0:
        DC32     CurrentDeviceId
        DC32     GlobalDeviceHWId
        CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??OS_Idle??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE OS_Idle
//  219 
//  220 
//  221 
//  222 /*
//  223 **********************************************************************
//  224 *
//  225 *                     Idle task  (OS_Idle)
//  226 *
//  227 **********************************************************************
//  228 
//  229  Please note:
//  230  This is basically the "core" of the idle task.
//  231  This core loop can be changed, but:
//  232  The idle task does not have a stack of its own, therefor no
//  233  functionality should be implemented that relies on the stack
//  234  to be preserved. However, a simple program loop can be programmed
//  235  (like toggeling an output or incrementing a counter)
//  236 */
//  237 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function OS_Idle
        ARM
//  238 void OS_Idle(void) {	 // Idle task: No task is ready to exec
//  239 	while ( 1 ) {
OS_Idle:
??OS_Idle_0:
        B        ??OS_Idle_0
        CFI EndBlock cfiBlock3
//  240 	}
//  241 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??OS_GetTime_Cycles??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE OS_GetTime_Cycles
//  242 
//  243 /*
//  244 **********************************************************************
//  245 *
//  246 *                    Get time [cycles]
//  247 *
//  248 **********************************************************************
//  249 
//  250 	This routine is required for task-info via embOS Viewer.
//  251 	It returns the system time in clock cycles.
//  252 */
//  253 
//  254 #define HW_TIMER rTCNTB0
//  255 #define HW_TIMER_INTERRUPT_PENDING() (rINTPND & BIT_TIMER0)
//  256 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function OS_GetTime_Cycles
        ARM
//  257 OS_U32 OS_GetTime_Cycles(void) {
//  258 	unsigned int t_cnt = TIMER_RELOAD - HW_TIMER;
OS_GetTime_Cycles:
        MOV      R2,#+242
        ORR      R2,R2,#0x2B00
        MOV      R3,#+12
        ORR      R3,R3,#0x51000000
        LDR      R3,[R3, #+0]
        SUBS     R2,R2,R3
        MOVS     R0,R2
//  259 	OS_U32 time = OS_Time;
        LDR      R2,??OS_GetTime_Cycles_0  ;; OS_Time
        LDR      R2,[R2, #+0]
        MOVS     R1,R2
//  260 	if ( HW_TIMER_INTERRUPT_PENDING() ) {
        MOV      R2,#+16
        ORR      R2,R2,#0x4A000000
        LDR      R2,[R2, #+0]
        TST      R2,#0x400
        BEQ      ??OS_GetTime_Cycles_1
//  261 		t_cnt = TIMER_RELOAD - HW_TIMER;
        MOV      R2,#+242
        ORR      R2,R2,#0x2B00
        MOV      R3,#+12
        ORR      R3,R3,#0x51000000
        LDR      R3,[R3, #+0]
        SUBS     R2,R2,R3
        MOVS     R0,R2
//  262 		time++;
        ADDS     R1,R1,#+1
//  263 	}
//  264 	return(OS_FSYS/TIMER_PRESCALE0/OS_TICK_FREQ)*time  + t_cnt;
??OS_GetTime_Cycles_1:
        MOV      R2,#+176128
        ORR      R2,R2,#0xF20
        MLA      R0,R2,R1,R0
        BX       LR               ;; return
        DATA
??OS_GetTime_Cycles_0:
        DC32     OS_Time
        CFI EndBlock cfiBlock5
//  265 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??OS_ConvertCycles2us??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE OS_ConvertCycles2us
//  266 
//  267 
//  268 /*
//  269 **********************************************************************
//  270 *
//  271 *                    OS_ConvertCycles2us
//  272 *
//  273 **********************************************************************
//  274 
//  275 Purpose:
//  276 	 Convert Cycles into micro seconds. (For profiling only)
//  277 
//  278 	 If you have a clock frequency which is not a multiple of 1 MHz,
//  279 	 you may have to modify this routine in order to get proper
//  280 	 diagonstics.
//  281 Please note:
//  282 	 This routine is required for profiling only.
//  283 	 It does not affect operation of the OS.
//  284 */
//  285 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function OS_ConvertCycles2us
        ARM
//  286 OS_U32 OS_ConvertCycles2us(OS_U32 Cycles) {
OS_ConvertCycles2us:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  287 	Cycles *= TIMER_PRESCALE0;				/* eliminate effect of prescaler */
//  288 	return(Cycles/(OS_FSYS/1000000));
        MOV      R1,#+180
        _BLF     ??divu32_a,??rA??divu32_a
        MOVS     R0,R1
        POP      {LR}
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock7
//  289 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??OS_COM_Init??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE OS_COM_Init
//  290 
//  291 /*********************************************************************
//  292 *
//  293 *          Communication (UART)
//  294 *
//  295 **********************************************************************
//  296 */
//  297 
//  298 #if (OS_UART!=-1)
//  299 	#if (OS_UART==1)
//  300 		#define INTOFF_UART      INTOFF_UART1
//  301 		#define UART_PENDING     BIT_UART1
//  302 		#define UART_SUBMASK     (BIT_SUB_TXD1 | BIT_SUB_RXD1)
//  303 		#define UART_SUB_RX      BIT_SUB_RXD1
//  304 		#define UART_SUB_TX      BIT_SUB_TXD1
//  305 		#define UART_STATUS      rUTRSTAT1
//  306 		#define UART_RXBUF       rURXH1
//  307 		#define UART_TXBUF       rUTXH1
//  308 		#define UART_LINECON     rULCON1
//  309 		#define UART_CONTROL     rUCON1
//  310 		#define UART_BAUD        rUBRDIV1
//  311 	#elif (OS_UART==0)
//  312 		#define INTOFF_UART      INTOFF_UART0
//  313 		#define UART_PENDING     BIT_UART0
//  314 		#define UART_SUBMASK     (BIT_SUB_TXD0 | BIT_SUB_RXD0)
//  315 		#define UART_SUB_RX      BIT_SUB_RXD0
//  316 		#define UART_SUB_TX      BIT_SUB_TXD0
//  317 		#define UART_STATUS      rUTRSTAT0
//  318 		#define UART_RXBUF       rURXH0
//  319 		#define UART_TXBUF       rUTXH0
//  320 		#define UART_LINECON     rULCON0
//  321 		#define UART_CONTROL     rUCON0
//  322 		#define UART_BAUD        rUBRDIV0
//  323 	#endif
//  324 
//  325 void OS_COM_Init(void) {
//  326 	UART_CONTROL = 0x00;
//  327 	UART_LINECON = 0x03;
//  328 	UART_CONTROL = 0x85; // RxTimeout and Interrupt request or polling mode
//  329 	UART_BAUD = (OS_FSYS/4)/(16*OS_BAUDRATE)-1 ;
//  330 	rINTMSK    &= ~UART_PENDING;
//  331 	rINTSUBMSK &= ~UART_SUBMASK;
//  332 }
//  333 
//  334 void OS_ISR_rx(void) {
//  335 	unsigned UartStatus = UART_STATUS;
//  336 	if ( UartStatus & 0x01 ) {
//  337 		unsigned char RxBuf = UART_RXBUF;
//  338 		OS_OnRx(RxBuf);
//  339 		//UART_TXBUF = RxBuf;
//  340 	}
//  341 }
//  342 
//  343 void OS_ISR_tx(void) {
//  344 	OS_OnTx();
//  345 }
//  346 
//  347 void OS_COM_Send1(OS_U8 c) {
//  348 	UART_TXBUF = c;
//  349 }
//  350 
//  351 #else  /* UART handlers not defined, using dummys */
//  352 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function OS_COM_Init
        ARM
//  353 void OS_COM_Init(void) {}
OS_COM_Init:
        BX       LR               ;; return
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??OS_COM_Send1??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE OS_COM_Send1

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function OS_COM_Send1
        ARM
//  354 void OS_COM_Send1(OS_U8 c) {
OS_COM_Send1:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOVS     R4,R0
//  355 	OS_USEPARA(c);
//  356 	OS_COM_ClearTxActive();	 /* let OS know that transmitter is not busy */
        _BLF     OS_COM_ClearTxActive,??OS_COM_ClearTxActive??rA
//  357 }
        POP      {R4,LR}
        CFI R4 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??swi_handler??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE swi_handler
//  358 
//  359 #endif
//  360 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function swi_handler
        ARM
//  361 __swi __arm int swi_handler(int a, int b)
//  362 {
swi_handler:
        MOVS     R2,R0
//  363 #ifdef S2TXU
//  364 	//LastErrAddress = 123;
//  365 	//asm ("SUBS R2,lr,#8");
//  366 	//asm ("STR  R2,[R0, #+0]");
//  367 	//LastOSError = 0xf1;
//  368 	return 0;
        MOV      R0,#+0
        MOVS     PC,LR            ;; return
        CFI EndBlock cfiBlock13
//  369 	//asm ("MOVS pc, lr");
//  370 #endif
//  371 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon2
        CFI Function undef_handler
        ARM
//  372 __irq __arm void undef_handler(void)
//  373 {
undef_handler:
        PUSH     {R0,R1}
        CFI R1 Frame(CFA, -4)
        CFI R0 Frame(CFA, -8)
        CFI CFA R13+8
//  374 #ifdef S2TXU
//  375 	LastErrAddress = 123;
        LDR      R0,??DataTable4  ;; 0x31fff048
        MOV      R1,#+123
        STR      R1,[R0, #+0]
//  376 	asm ("SUBS R2,lr,#0");
        SUBS R2,lr,#0    
//  377 	asm ("STR  R2,[R0, #+0]");
        STR  R2,[R0, #+0] 
//  378 	LastOSError    = 0xf2;
        LDR      R0,??DataTable5  ;; 0x31fff010
        MOV      R1,#+242
        STR      R1,[R0, #+0]
//  379   while(1);
??undef_handler_0:
        B        ??undef_handler_0
        CFI EndBlock cfiBlock14
//  380 	//asm ("MOVS pc, lr");
//  381 #endif
//  382 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon2
        CFI Function prefetch_handler
        ARM
//  383 __irq __arm void prefetch_handler(void)
//  384 {
prefetch_handler:
        PUSH     {R0,R1}
        CFI R1 Frame(CFA, -4)
        CFI R0 Frame(CFA, -8)
        CFI CFA R13+8
//  385 #ifdef S2TXU
//  386 	LastErrAddress = 123;
        LDR      R0,??DataTable4  ;; 0x31fff048
        MOV      R1,#+123
        STR      R1,[R0, #+0]
//  387 	asm ("SUBS R2,lr,#4");
        SUBS R2,lr,#4    
//  388 	asm ("STR  R2,[R0, #+0]");
        STR  R2,[R0, #+0] 
//  389 	LastOSError    = 0xf3;
        LDR      R0,??DataTable5  ;; 0x31fff010
        MOV      R1,#+243
        STR      R1,[R0, #+0]
//  390 	while (1);
??prefetch_handler_0:
        B        ??prefetch_handler_0
        CFI EndBlock cfiBlock15
//  391 	//	asm ("SUBS pc,lr,#4");
//  392 #endif
//  393 }
//  394 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon2
        CFI Function data_handler
        ARM
//  395 __irq __arm void data_handler(void)
//  396 {
data_handler:
        PUSH     {R0,R1}
        CFI R1 Frame(CFA, -4)
        CFI R0 Frame(CFA, -8)
        CFI CFA R13+8
//  397 #ifdef S2TXU
//  398 	LastErrAddress = 123;
        LDR      R0,??DataTable4  ;; 0x31fff048
        MOV      R1,#+123
        STR      R1,[R0, #+0]
//  399 	asm ("SUBS R2,lr,#8");
        SUBS R2,lr,#8    
//  400 	asm ("STR  R2,[R0, #+0]");
        STR  R2,[R0, #+0] 
//  401 
//  402 	LastOSError = 0xf4;
        LDR      R0,??DataTable5  ;; 0x31fff010
        MOV      R1,#+244
        STR      R1,[R0, #+0]
//  403 	//while (1);
//  404 	asm ("SUBS pc,lr,#8");
        SUBS pc,lr,#8    
//  405 	//asm ("ADDS pc,lr,#0");
//  406 #endif
//  407 }
        POP      {R0,R1}
        CFI R0 SameValue
        CFI R1 SameValue
        CFI CFA R13+0
        SUBS     PC,LR,#+4        ;; return
        CFI EndBlock cfiBlock16

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable4:
        DC32     0x31fff048

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     0x31fff010
//  408 
//  409 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon2
        CFI Function fiq_handler
        ARM
//  410 __irq __arm void fiq_handler(void)
//  411 {
//  412 }
fiq_handler:
        SUBS     PC,LR,#+4        ;; return
        CFI EndBlock cfiBlock17

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??OS_irq_handler??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock18
        REQUIRE OS_irq_handler
//  413 
//  414 
//  415 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//  416 volatile  time_t FastTime   =0;
FastTime:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//  417 volatile  time_t CurrentTime=0;
CurrentTime:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//  418 volatile  time_t RunningTime=0;
RunningTime:
        DS8 4
//  419 
//  420 
//  421 /*
//  422 **********************************************************************
//  423 *
//  424 *                    OS_irq_handler
//  425 *
//  426 **********************************************************************
//  427 
//  428 Purpose:
//  429 	 Detect reason for IRQ and call correspondig service routine.
//  430 
//  431 Please note:
//  432 	 If you allow nesting, bits in __INTPND must be cleared before
//  433 	 calling OS_EnterNestableInterrupt.
//  434 */
//  435 #define rTEST     (*(volatile unsigned *)(0x30000040))

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//  436 volatile int IrqCnt = 0;
IrqCnt:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//  437 volatile int DefaultIrqCnt = 0;
DefaultIrqCnt:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//  438 volatile int InTimerFlag = 0;
InTimerFlag:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//  439 volatile int IsDown      = 0;
IsDown:
        DS8 4

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//  440 volatile int TCCnt           = 0;
TCCnt:
        DS8 4
//  441 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon1
        CFI Function OS_irq_handler
        ARM
//  442 void OS_irq_handler(void) {
OS_irq_handler:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  443 	unsigned IntSource;
//  444 	unsigned IntOffset;
//  445 	OS_EnterInterrupt();
        LDR      R0,??OS_irq_handler_1  ;; OS_InInt
        LDR      R1,??OS_irq_handler_1  ;; OS_InInt
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+0]
        LDR      R0,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDR      R1,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+0]
        LDR      R0,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDR      R1,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+0]
//  446 	IntSource    = rINTPND;
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R0,[R0, #+0]
        MOVS     R4,R0
//  447 	IntOffset    = rINTOFFSET;
        MOV      R0,#+20
        ORR      R0,R0,#0x4A000000
        LDR      R0,[R0, #+0]
        MOVS     R5,R0
//  448 
//  449 	//OS_USER_irq_func();
//  450 
//  451 	IrqCnt++;
        LDR      R0,??OS_irq_handler_1+0xC  ;; IrqCnt
        LDR      R1,??OS_irq_handler_1+0xC  ;; IrqCnt
        LDR      R1,[R1, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  452 	switch ( IntOffset ) {
        MOVS     R0,R5
        CMP      R0,#+31
        BHI      ??OS_irq_handler_2
        ADR      R1,??OS_irq_handler_0
        MOV      R0,R0, LSL #+1
        LDRH     R1,[R1, R0]
        ADD      PC,PC,R1, LSL #+2
        DATA
??OS_irq_handler_0:
        DC16     +547,+560,+573,+586
        DC16     +114,+114,+599,+599
        DC16     +599,+599,+54,+599
        DC16     +599,+599,+599,+41
        DC16     +599,+599,+599,+599
        DC16     +599,+599,+599,+28
        DC16     +599,+599,+599,+599
        DC16     +15,+599,+599,+314
        ARM
//  453 #if (OS_UART != 0)
//  454 		case INTOFF_UART0:
//  455 			ClearPending(BIT_UART0);
??OS_irq_handler_3:
        MOV      R0,#+1241513984
        MOV      R1,#+268435456
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+268435456
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R6,[R0, #+0]
//  456 			HandleUARTInterrupt(0);
        MOV      R0,#+0
        _BLF     HandleUARTInterrupt,??HandleUARTInterrupt??rA
        B        ??OS_irq_handler_4
//  457 			//OS_LeaveInterrupt();
//  458 			//return;
//  459 			break;
//  460 #endif
//  461 #if (OS_UART != 1)
//  462 		case INTOFF_UART1:
//  463 			ClearPending(BIT_UART1);
??OS_irq_handler_5:
        MOV      R0,#+1241513984
        MOV      R1,#+8388608
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+8388608
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R6,[R0, #+0]
//  464 			HandleUARTInterrupt(1);
        MOV      R0,#+1
        _BLF     HandleUARTInterrupt,??HandleUARTInterrupt??rA
        B        ??OS_irq_handler_4
//  465 			//OS_LeaveInterrupt();
//  466 			//return;
//  467 			break;
//  468 #endif
//  469 		case INTOFF_UART2:
//  470 			ClearPending(BIT_UART2);
??OS_irq_handler_6:
        MOV      R0,#+1241513984
        MOV      R1,#+32768
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+32768
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R6,[R0, #+0]
//  471 			HandleUARTInterrupt(2);
        MOV      R0,#+2
        _BLF     HandleUARTInterrupt,??HandleUARTInterrupt??rA
        B        ??OS_irq_handler_4
//  472 			//OS_LeaveInterrupt();
//  473 			//return;
//  474 			break;
//  475 #if ((OS_UART == 0) || (OS_UART == 1))
//  476 		case INTOFF_UART:				// UART for embOSView
//  477 			ClearPending(UART_PENDING);
//  478 			{
//  479 				unsigned IntSubSource = rSUBSRCPND;
//  480 				unsigned InsSubMask   = rINTSUBMSK;
//  481 				if ( IntSubSource & UART_SUB_RX ) {
//  482 					rSUBSRCPND = UART_SUB_RX;
//  483 					OS_ISR_rx();
//  484 				}
//  485 				if ( IntSubSource & UART_SUB_TX ) {
//  486 					rSUBSRCPND = UART_SUB_TX;
//  487 					OS_ISR_tx();
//  488 				}
//  489 			}
//  490 			// OS_LeaveInterruptNoSwitch();
//  491 			// return;
//  492 			OS_LeaveInterrupt();
//  493 			return;
//  494 #endif
//  495 		case INTOFF_TIMER0:				// Timer for OS
//  496 			// Clear interrupt controller service pending bit.
//  497 			ClearPending(BIT_TIMER0);
??OS_irq_handler_7:
        MOV      R0,#+1241513984
        MOV      R1,#+1024
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+1024
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R0,[R0, #+0]
//  498 			if ( FastTime++ >= 1000 ) {
        LDR      R1,??OS_irq_handler_1+0x10  ;; FastTime
        LDR      R1,[R1, #+0]
        LDR      R2,??OS_irq_handler_1+0x10  ;; FastTime
        ADDS     R3,R1,#+1
        STR      R3,[R2, #+0]
        CMP      R1,#+1000
        BLT      ??OS_irq_handler_8
//  499 				FastTime = 0;
        LDR      R0,??OS_irq_handler_1+0x10  ;; FastTime
        MOV      R1,#+0
        STR      R1,[R0, #+0]
//  500 				CurrentTime++;
        LDR      R0,??OS_irq_handler_1+0x14  ;; CurrentTime
        LDR      R1,??OS_irq_handler_1+0x14  ;; CurrentTime
        LDR      R1,[R1, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  501 				RunningTime++;
        LDR      R0,??OS_irq_handler_1+0x18  ;; RunningTime
        LDR      R1,??OS_irq_handler_1+0x18  ;; RunningTime
        LDR      R1,[R1, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  502 			}
//  503 			OS_TickHandler();
??OS_irq_handler_8:
        _BLF     OS_TickHandler,??OS_TickHandler??rA
//  504 			OS_LeaveInterrupt();
        LDR      R0,??OS_irq_handler_1  ;; OS_InInt
        LDRB     R0,[R0, #+0]
        LDR      R1,??OS_irq_handler_1  ;; OS_InInt
        SUBS     R2,R0,#+1
        STRB     R2,[R1, #+0]
        CMP      R0,#+0
        BNE      ??OS_irq_handler_9
        MOV      R0,#+152
        _BLF     OS_Error,??OS_Error??rA
??OS_irq_handler_9:
        LDR      R0,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDR      R1,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+0]
        LDR      R0,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE      ??OS_irq_handler_10
        LDR      R0,??OS_irq_handler_1+0x1C  ;; OS_Pending
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??OS_irq_handler_10
        _BLF     OS_SwitchFromInt,??OS_SwitchFromInt??rA
??OS_irq_handler_10:
        LDR      R0,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDR      R1,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+0]
//  505 			return;
        B        ??OS_irq_handler_11
//  506 		case INTOFF_4_7:
//  507 		case INTOFF_8_23:
//  508 			{
//  509 				U32 BitOffset;
//  510 				U32 IntRequest = rEINTPEND;
??OS_irq_handler_12:
        MOV      R2,#+168
        ORR      R2,R2,#0x56000000
        LDR      R2,[R2, #+0]
        MOVS     R1,R2
//  511 				rEINTPEND = IntRequest;
        MOV      R2,#+168
        ORR      R2,R2,#0x56000000
        STR      R1,[R2, #+0]
//  512 
//  513 				for ( BitOffset=4; BitOffset <= 23; BitOffset++ ) {
        MOV      R2,#+4
        MOVS     R0,R2
??OS_irq_handler_13:
        CMP      R0,#+24
        BCS      ??OS_irq_handler_14
//  514 					U32 BitMask = (1 << BitOffset) & IntRequest;
        MOV      R3,#+1
        ANDS     R3,R1,R3, LSL R0
        MOVS     R2,R3
//  515 					if ( BitMask ) {
        CMP      R2,#+0
        BEQ      ??OS_irq_handler_15
//  516 						switch ( BitOffset ) {
        MOVS     R3,R0
        CMP      R3,#+5
        BEQ      ??OS_irq_handler_16
        CMP      R3,#+6
        BEQ      ??OS_irq_handler_17
        CMP      R3,#+7
        BEQ      ??OS_irq_handler_18
        CMP      R3,#+8
        BEQ      ??OS_irq_handler_19
        B        ??OS_irq_handler_15
//  517 							case INTOFF_SILENCE:
//  518 								// For external silence
//  519 								break;
//  520 							case INTOFF_IC1_UP  :
//  521 								rTCON   &= ~TIMER2_START;	// Stop timer 2
??OS_irq_handler_16:
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        BICS     R6,R6,#0x1000
        STR      R6,[R3, #+0]
//  522 								Inc1CntUp = 0xffff - rTCNTO2;
        LDR      R3,??OS_irq_handler_1+0x20  ;; Inc1CntUp
        MOV      R6,#+255
        ORR      R6,R6,#0xFF00
        MOV      R7,#+44
        ORR      R7,R7,#0x51000000
        LDR      R7,[R7, #+0]
        SUBS     R6,R6,R7
        STRH     R6,[R3, #+0]
//  523 								rTCNTO2   = 0;
        MOV      R3,#+44
        ORR      R3,R3,#0x51000000
        MOV      R6,#+0
        STR      R6,[R3, #+0]
//  524 								rTCON   |= TIMER2_UPDATE;
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        ORRS     R6,R6,#0x2000
        STR      R6,[R3, #+0]
//  525 								rTCON   &= ~TIMER2_UPDATE;
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        BICS     R6,R6,#0x2000
        STR      R6,[R3, #+0]
//  526 								rTCON   |= TIMER2_START;	// Start timer 2
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        ORRS     R6,R6,#0x1000
        STR      R6,[R3, #+0]
        B        ??OS_irq_handler_15
//  527 								break;
//  528 							case INTOFF_IC1_DOWN:
//  529 								rTCON   &= ~TIMER2_START;	// Stop timer 2
??OS_irq_handler_17:
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        BICS     R6,R6,#0x1000
        STR      R6,[R3, #+0]
//  530 								Inc1CntDown = 0xffff - rTCNTO2;
        LDR      R3,??OS_irq_handler_1+0x24  ;; Inc1CntDown
        MOV      R6,#+255
        ORR      R6,R6,#0xFF00
        MOV      R7,#+44
        ORR      R7,R7,#0x51000000
        LDR      R7,[R7, #+0]
        SUBS     R6,R6,R7
        STRH     R6,[R3, #+0]
//  531 								rTCNTO2 = 0;
        MOV      R3,#+44
        ORR      R3,R3,#0x51000000
        MOV      R6,#+0
        STR      R6,[R3, #+0]
//  532 								rTCON   |= TIMER2_UPDATE;
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        ORRS     R6,R6,#0x2000
        STR      R6,[R3, #+0]
//  533 								rTCON   &= ~TIMER2_UPDATE;
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        BICS     R6,R6,#0x2000
        STR      R6,[R3, #+0]
//  534 								rTCON   |= TIMER2_START;	// Start timer 2
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        ORRS     R6,R6,#0x1000
        STR      R6,[R3, #+0]
        B        ??OS_irq_handler_15
//  535 								break;
//  536 							case INTOFF_IC2_UP  :
//  537 								rTCON   &= ~TIMER3_START;	// Stop timer 3
??OS_irq_handler_18:
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        BICS     R6,R6,#0x10000
        STR      R6,[R3, #+0]
//  538 								Inc2CntUp = 0xffff - rTCNTO3;
        LDR      R3,??OS_irq_handler_1+0x28  ;; Inc2CntUp
        MOV      R6,#+255
        ORR      R6,R6,#0xFF00
        MOV      R7,#+56
        ORR      R7,R7,#0x51000000
        LDR      R7,[R7, #+0]
        SUBS     R6,R6,R7
        STRH     R6,[R3, #+0]
//  539 								rTCNTO3   = 0;
        MOV      R3,#+56
        ORR      R3,R3,#0x51000000
        MOV      R6,#+0
        STR      R6,[R3, #+0]
//  540 								rTCON   |= TIMER3_UPDATE;
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        ORRS     R6,R6,#0x20000
        STR      R6,[R3, #+0]
//  541 								rTCON   &= ~TIMER3_UPDATE;
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        BICS     R6,R6,#0x20000
        STR      R6,[R3, #+0]
//  542 								rTCON   |= TIMER3_START;	// Start timer 3
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        ORRS     R6,R6,#0x10000
        STR      R6,[R3, #+0]
        B        ??OS_irq_handler_15
//  543 								break;
//  544 							case INTOFF_IC2_DOWN:
//  545 								rTCON   &= ~TIMER3_START;	// Stop timer 3
??OS_irq_handler_19:
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        BICS     R6,R6,#0x10000
        STR      R6,[R3, #+0]
//  546 								Inc2CntDown = 0xffff - rTCNTO3;
        LDR      R3,??OS_irq_handler_1+0x2C  ;; Inc2CntDown
        MOV      R6,#+255
        ORR      R6,R6,#0xFF00
        MOV      R7,#+56
        ORR      R7,R7,#0x51000000
        LDR      R7,[R7, #+0]
        SUBS     R6,R6,R7
        STRH     R6,[R3, #+0]
//  547 								rTCNTO3 = 0;
        MOV      R3,#+56
        ORR      R3,R3,#0x51000000
        MOV      R6,#+0
        STR      R6,[R3, #+0]
//  548 								rTCON   |= TIMER3_UPDATE;
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        ORRS     R6,R6,#0x20000
        STR      R6,[R3, #+0]
//  549 								rTCON   &= ~TIMER3_UPDATE;
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        BICS     R6,R6,#0x20000
        STR      R6,[R3, #+0]
//  550 								rTCON   |= TIMER3_START;	// Start timer 3
        MOV      R3,#+8
        ORR      R3,R3,#0x51000000
        MOV      R6,#+8
        ORR      R6,R6,#0x51000000
        LDR      R6,[R6, #+0]
        ORRS     R6,R6,#0x10000
        STR      R6,[R3, #+0]
//  551 								break;
//  552 
//  553 						}
//  554 					}
//  555 				}
??OS_irq_handler_15:
        ADDS     R0,R0,#+1
        B        ??OS_irq_handler_13
//  556 				ClearPending(IntSource);
??OS_irq_handler_14:
        MOV      R2,#+1241513984
        STR      R4,[R2, #+0]
        MOV      R2,#+16
        ORR      R2,R2,#0x4A000000
        STR      R4,[R2, #+0]
        MOV      R2,#+16
        ORR      R2,R2,#0x4A000000
        LDR      R2,[R2, #+0]
        B        ??OS_irq_handler_4
//  557 			}
//  558 			break;
//  559 		case INTOFF_ADC:			//ADC / Touchscreen //AStmark This is not completed for ADC!!!
//  560 			ClearPending(BIT_ADC);
??OS_irq_handler_20:
        MOV      R0,#+1241513984
        MOV      R1,#-2147483648
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#-2147483648
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R0,[R0, #+0]
//  561 			{
//  562 				unsigned IntSubSource = rSUBSRCPND;
        MOV      R1,#+24
        ORR      R1,R1,#0x4A000000
        LDR      R1,[R1, #+0]
        MOVS     R6,R1
//  563 
//  564 				if ( IntSubSource &  BIT_SUB_TC ) {			 // TC(Touch screen Control) Interrupt
        TST      R6,#0x200
        BEQ      ??OS_irq_handler_21
//  565 					ADIntCnt = 0;
        LDR      R0,??OS_irq_handler_1+0x30  ;; ADIntCnt
        MOV      R1,#+0
        STR      R1,[R0, #+0]
//  566 					rSUBSRCPND = BIT_SUB_TC;
        MOV      R0,#+24
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+512
        STR      R1,[R0, #+0]
//  567 					if ( rADCTSC & 0x100 ) {
        MOV      R0,#+4
        ORR      R0,R0,#0x58000000
        LDR      R0,[R0, #+0]
        TST      R0,#0x100
        BEQ      ??OS_irq_handler_22
//  568 						//TouchKeyPressed = 0 ;	//key up
//  569 						//OS_RetriggerTimer(&TouchTimeOutTimer);
//  570 						rADCTSC &= 0xff;	// Set stylus down interrupt
        MOV      R0,#+4
        ORR      R0,R0,#0x58000000
        MOV      R1,#+4
        ORR      R1,R1,#0x58000000
        LDR      R1,[R1, #+0]
        ANDS     R1,R1,#0xFF
        STR      R1,[R0, #+0]
//  571 						if ( ReadTouchKey ) {
        LDR      R0,??OS_irq_handler_1+0x34  ;; ReadTouchKey
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??OS_irq_handler_21
//  572 							OS_SignalEvent(TOUCH_SCREEN_UP,ReadTouchKey);
        LDR      R0,??OS_irq_handler_1+0x34  ;; ReadTouchKey
        LDR      R1,[R0, #+0]
        MOV      R0,#+1
        _BLF     OS_SignalEvent,??OS_SignalEvent??rA
        B        ??OS_irq_handler_21
//  573 						}
//  574 					} else {
//  575 						//rADCTSC &= 0xff;	// Set stylus down interrupt
//  576 						// <Auto X-Position and Y-Position Read>
//  577 						rADCTSC=(0<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(1<<3)|(1<<2)|(0);
??OS_irq_handler_22:
        MOV      R0,#+4
        ORR      R0,R0,#0x58000000
        MOV      R1,#+220
        STR      R1,[R0, #+0]
//  578 						// Stylus Down,Don't care,Don't care,Don't care,Don't care,XP pullup Dis,Auto,No operation
//  579 
//  580 						rADCCON |= 0x1;	// Start Auto conversion
        MOV      R0,#+1476395008
        MOV      R1,#+1476395008
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x1
        STR      R1,[R0, #+0]
//  581 
//  582 						while ( rADCCON & 0x1 );		 //check if Enable_start is low
??OS_irq_handler_23:
        MOV      R0,#+1476395008
        LDR      R0,[R0, #+0]
        TST      R0,#0x1
        BNE      ??OS_irq_handler_23
//  583 						while ( !(0x8000 & rADCCON) ); // Check ECFLG
??OS_irq_handler_24:
        MOV      R0,#+1476395008
        LDR      R0,[R0, #+0]
        TST      R0,#0x8000
        BEQ      ??OS_irq_handler_24
//  584 
//  585 						TXUADData[7] = (0x3ff & rADCDAT0) ;	// Catch the possition
        LDR      R0,??OS_irq_handler_1+0x38  ;; TXUADData + 14
        MOV      R1,#+12
        ORR      R1,R1,#0x58000000
        LDR      R1,[R1, #+0]
        LSLS     R1,R1,#+22
        LSRS     R1,R1,#+22
        STRH     R1,[R0, #+0]
//  586 						TXUADData[5] = (0x3ff & rADCDAT1) ;
        LDR      R0,??OS_irq_handler_1+0x3C  ;; TXUADData + 10
        MOV      R1,#+16
        ORR      R1,R1,#0x58000000
        LDR      R1,[R1, #+0]
        LSLS     R1,R1,#+22
        LSRS     R1,R1,#+22
        STRH     R1,[R0, #+0]
//  587 						rADCTSC=(1<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(0<<2)|(1<<1) | 1;
        MOV      R0,#+4
        ORR      R0,R0,#0x58000000
        MOV      R1,#+211
        ORR      R1,R1,#0x100
        STR      R1,[R0, #+0]
//  588 						// Stylus Up,Don't care,Don't care,Don't care,Don't care,XP pullup En,Normal,Waiting mode
//  589 						rADCCON |= 0x1;															// Start Auto conversion
        MOV      R0,#+1476395008
        MOV      R1,#+1476395008
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0x1
        STR      R1,[R0, #+0]
//  590 
//  591 						if ( ReadTouchKey ) {
        LDR      R0,??OS_irq_handler_1+0x34  ;; ReadTouchKey
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??OS_irq_handler_25
//  592 							OS_SignalEvent(TOUCH_SCREEN_DOWN,ReadTouchKey);
        LDR      R0,??OS_irq_handler_1+0x34  ;; ReadTouchKey
        LDR      R1,[R0, #+0]
        MOV      R0,#+2
        _BLF     OS_SignalEvent,??OS_SignalEvent??rA
//  593 						}
//  594 						KbdIntCnt++;
??OS_irq_handler_25:
        LDR      R0,??OS_irq_handler_1+0x40  ;; KbdIntCnt
        LDR      R1,??OS_irq_handler_1+0x40  ;; KbdIntCnt
        LDR      R1,[R1, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  595 						TCCnt = 5;
        LDR      R0,??OS_irq_handler_1+0x44  ;; TCCnt
        MOV      R1,#+5
        STR      R1,[R0, #+0]
//  596 						OS_LeaveInterruptNoSwitch();
        LDR      R0,??OS_irq_handler_1  ;; OS_InInt
        LDRB     R0,[R0, #+0]
        LDR      R1,??OS_irq_handler_1  ;; OS_InInt
        SUBS     R2,R0,#+1
        STRB     R2,[R1, #+0]
        CMP      R0,#+0
        BNE      ??OS_irq_handler_26
        MOV      R0,#+152
        _BLF     OS_Error,??OS_Error??rA
??OS_irq_handler_26:
        LDR      R0,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDR      R1,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+0]
        LDR      R0,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDR      R1,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+0]
//  597 						return;
        B        ??OS_irq_handler_11
//  598 					}
//  599 				}
//  600 				if ( IntSubSource &  BIT_SUB_ADC ) {	// AD converter
??OS_irq_handler_21:
        TST      R6,#0x400
        BEQ      ??OS_irq_handler_4
//  601 					rSUBSRCPND = BIT_SUB_ADC;
        MOV      R0,#+24
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+1024
        STR      R1,[R0, #+0]
//  602 					U16 ADVal  = rADCDAT0;
        MOV      R0,#+12
        ORR      R0,R0,#0x58000000
        LDR      R0,[R0, #+0]
        MOVS     R7,R0
//  603 					// Is not normal ADC?
//  604 					if ( ADVal & 0x4000 ) {
        TST      R7,#0x4000
        BEQ      ??OS_irq_handler_27
//  605 						TCCnt = 5;
        LDR      R0,??OS_irq_handler_1+0x44  ;; TCCnt
        MOV      R1,#+5
        STR      R1,[R0, #+0]
//  606 						TXUADData[7] = (0x3ff & ADVal) ;	// Catch the possition
        LDR      R0,??OS_irq_handler_1+0x38  ;; TXUADData + 14
        LSLS     R1,R7,#+22
        LSRS     R1,R1,#+22
        STRH     R1,[R0, #+0]
//  607 						TXUADData[5] = (0x3ff & rADCDAT1) ;
        LDR      R0,??OS_irq_handler_1+0x3C  ;; TXUADData + 10
        MOV      R1,#+16
        ORR      R1,R1,#0x58000000
        LDR      R1,[R1, #+0]
        LSLS     R1,R1,#+22
        LSRS     R1,R1,#+22
        STRH     R1,[R0, #+0]
//  608 						// Stylus up = 1
//  609 						if ( ADVal & 0x8000 ) {
        TST      R7,#0x8000
        BEQ      ??OS_irq_handler_28
//  610 							if ( IsDown ) {
        LDR      R0,??OS_irq_handler_1+0x48  ;; IsDown
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??OS_irq_handler_4
//  611 								IsDown = 0;
        LDR      R0,??OS_irq_handler_1+0x48  ;; IsDown
        MOV      R1,#+0
        STR      R1,[R0, #+0]
//  612 								if ( ReadTouchKey ) {
        LDR      R0,??OS_irq_handler_1+0x34  ;; ReadTouchKey
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??OS_irq_handler_4
//  613 									OS_SignalEvent(TOUCH_SCREEN_UP,ReadTouchKey);
        LDR      R0,??OS_irq_handler_1+0x34  ;; ReadTouchKey
        LDR      R1,[R0, #+0]
        MOV      R0,#+1
        _BLF     OS_SignalEvent,??OS_SignalEvent??rA
        B        ??OS_irq_handler_4
//  614 								}
//  615 							}
//  616 						} else {
//  617 							if ( !IsDown ) {
??OS_irq_handler_28:
        LDR      R0,??OS_irq_handler_1+0x48  ;; IsDown
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??OS_irq_handler_4
//  618 								IsDown = 1;
        LDR      R0,??OS_irq_handler_1+0x48  ;; IsDown
        MOV      R1,#+1
        STR      R1,[R0, #+0]
//  619 								if ( ReadTouchKey ) {
        LDR      R0,??OS_irq_handler_1+0x34  ;; ReadTouchKey
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??OS_irq_handler_4
//  620 									OS_SignalEvent(TOUCH_SCREEN_DOWN,ReadTouchKey);
        LDR      R0,??OS_irq_handler_1+0x34  ;; ReadTouchKey
        LDR      R1,[R0, #+0]
        MOV      R0,#+2
        _BLF     OS_SignalEvent,??OS_SignalEvent??rA
        B        ??OS_irq_handler_4
//  621 								}
//  622 							}
//  623 						}
//  624 						// rADCTSC=(1<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(0<<2)|(1<<1) | 1;
//  625 						// Stylus Up,Don't care,Don't care,Don't care,Don't care,XP pullup En,Normal,Waiting mode
//  626 						//rADCCON |= 0x1;															// Start Auto conversion
//  627 					} else {
//  628 						if (TCCnt) {
??OS_irq_handler_27:
        LDR      R0,??OS_irq_handler_1+0x44  ;; TCCnt
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??OS_irq_handler_29
//  629 							TCCnt--;
        LDR      R0,??OS_irq_handler_1+0x44  ;; TCCnt
        LDR      R1,??OS_irq_handler_1+0x44  ;; TCCnt
        LDR      R1,[R1, #+0]
        SUBS     R1,R1,#+1
        STR      R1,[R0, #+0]
        B        ??OS_irq_handler_4
//  630 						} else {
//  631 							TXUADData[ADChannel] = (ADVal & 0x3ff);
??OS_irq_handler_29:
        LDR      R0,??OS_irq_handler_1+0x4C  ;; ADChannel
        LDRB     R0,[R0, #+0]
        MOV      R1,#+2
        LDR      R2,??OS_irq_handler_1+0x50  ;; TXUADData
        MLA      R0,R1,R0,R2
        LSLS     R1,R7,#+22
        LSRS     R1,R1,#+22
        STRH     R1,[R0, #+0]
//  632 							if ( ++ADChannel == 5 ) {											// skip touchscreen
        LDR      R0,??OS_irq_handler_1+0x4C  ;; ADChannel
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR      R1,??OS_irq_handler_1+0x4C  ;; ADChannel
        STRB     R0,[R1, #+0]
        ANDS     R0,R0,#0xFF      ;; Zero extend
        CMP      R0,#+5
        BNE      ??OS_irq_handler_30
//  633 								ADChannel++;															// go to channel 6
        LDR      R0,??OS_irq_handler_1+0x4C  ;; ADChannel
        LDR      R1,??OS_irq_handler_1+0x4C  ;; ADChannel
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+0]
        B        ??OS_irq_handler_31
//  634 							} else if ( ADChannel > 6 ) {									// finished one round
??OS_irq_handler_30:
        LDR      R0,??OS_irq_handler_1+0x4C  ;; ADChannel
        LDRB     R0,[R0, #+0]
        CMP      R0,#+7
        BCC      ??OS_irq_handler_31
//  635 								ADChannel = 0;
        LDR      R0,??OS_irq_handler_1+0x4C  ;; ADChannel
        MOV      R1,#+0
        STRB     R1,[R0, #+0]
//  636 							}
//  637 							ADCCon->SelMux  = ADChannel;
??OS_irq_handler_31:
        LDR      R0,??OS_irq_handler_1+0x54  ;; ADCCon
        LDR      R0,[R0, #+0]
        LDR      R1,??OS_irq_handler_1+0x54  ;; ADCCon
        LDR      R1,[R1, #+0]
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x38
        LDR      R2,??OS_irq_handler_1+0x4C  ;; ADChannel
        LDRB     R2,[R2, #+0]
        MOV      R3,#+56
        ANDS     R2,R3,R2, LSL #+3
        ORRS     R1,R2,R1
        STR      R1,[R0, #+0]
        B        ??OS_irq_handler_4
//  638 						}
//  639 					}
//  640 				}
//  641 			}
//  642 			//break;
//  643 			break;
//  644 		case INTOFF_UART_A:
//  645 			ClearPending(BIT_EINT0);
??OS_irq_handler_32:
        MOV      R0,#+1241513984
        MOV      R1,#+1
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+1
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R6,[R0, #+0]
//  646 			HandleUARTInterrupt(3);
        MOV      R0,#+3
        _BLF     HandleUARTInterrupt,??HandleUARTInterrupt??rA
        B        ??OS_irq_handler_4
//  647 			break;
//  648 		case INTOFF_UART_B:
//  649 			ClearPending(BIT_EINT1);
??OS_irq_handler_33:
        MOV      R0,#+1241513984
        MOV      R1,#+2
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+2
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R6,[R0, #+0]
//  650 			HandleUARTInterrupt(4);
        MOV      R0,#+4
        _BLF     HandleUARTInterrupt,??HandleUARTInterrupt??rA
        B        ??OS_irq_handler_4
//  651 			break;
//  652 		case INTOFF_UART_C:
//  653 			ClearPending(BIT_EINT2);
??OS_irq_handler_34:
        MOV      R0,#+1241513984
        MOV      R1,#+4
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+4
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R6,[R0, #+0]
//  654 			HandleUARTInterrupt(5);
        MOV      R0,#+5
        _BLF     HandleUARTInterrupt,??HandleUARTInterrupt??rA
        B        ??OS_irq_handler_4
//  655 			break;
//  656 		case INTOFF_UART_D:
//  657 			ClearPending(BIT_EINT3);
??OS_irq_handler_35:
        MOV      R0,#+1241513984
        MOV      R1,#+8
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        MOV      R1,#+8
        STR      R1,[R0, #+0]
        MOV      R0,#+16
        ORR      R0,R0,#0x4A000000
        LDR      R6,[R0, #+0]
//  658 			HandleUARTInterrupt(6);
        MOV      R0,#+6
        _BLF     HandleUARTInterrupt,??HandleUARTInterrupt??rA
        B        ??OS_irq_handler_4
//  659 			break;
//  660 		default:
//  661 			DefaultIrqCnt++;
??OS_irq_handler_2:
        LDR      R0,??OS_irq_handler_1+0x58  ;; DefaultIrqCnt
        LDR      R1,??OS_irq_handler_1+0x58  ;; DefaultIrqCnt
        LDR      R1,[R1, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
//  662 			OS_LeaveInterrupt();
        LDR      R0,??OS_irq_handler_1  ;; OS_InInt
        LDRB     R0,[R0, #+0]
        LDR      R1,??OS_irq_handler_1  ;; OS_InInt
        SUBS     R2,R0,#+1
        STRB     R2,[R1, #+0]
        CMP      R0,#+0
        BNE      ??OS_irq_handler_36
        MOV      R0,#+152
        _BLF     OS_Error,??OS_Error??rA
??OS_irq_handler_36:
        LDR      R0,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDR      R1,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+0]
        LDR      R0,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE      ??OS_irq_handler_37
        LDR      R0,??OS_irq_handler_1+0x1C  ;; OS_Pending
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??OS_irq_handler_37
        _BLF     OS_SwitchFromInt,??OS_SwitchFromInt??rA
??OS_irq_handler_37:
        LDR      R0,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDR      R1,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+0]
//  663 			return;
        B        ??OS_irq_handler_11
//  664 
//  665 	}
//  666 	OS_LeaveInterruptNoSwitch();
??OS_irq_handler_4:
        LDR      R0,??OS_irq_handler_1  ;; OS_InInt
        LDRB     R0,[R0, #+0]
        LDR      R1,??OS_irq_handler_1  ;; OS_InInt
        SUBS     R2,R0,#+1
        STRB     R2,[R1, #+0]
        CMP      R0,#+0
        BNE      ??OS_irq_handler_38
        MOV      R0,#+152
        _BLF     OS_Error,??OS_Error??rA
??OS_irq_handler_38:
        LDR      R0,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDR      R1,??OS_irq_handler_1+0x8  ;; OS_Counters + 1
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+0]
        LDR      R0,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDR      R1,??OS_irq_handler_1+0x4  ;; OS_Counters
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+0]
//  667 }
??OS_irq_handler_11:
        POP      {R4-R7,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??OS_irq_handler_1:
        DC32     OS_InInt
        DC32     OS_Counters
        DC32     OS_Counters + 1
        DC32     IrqCnt
        DC32     FastTime
        DC32     CurrentTime
        DC32     RunningTime
        DC32     OS_Pending
        DC32     Inc1CntUp
        DC32     Inc1CntDown
        DC32     Inc2CntUp
        DC32     Inc2CntDown
        DC32     ADIntCnt
        DC32     ReadTouchKey
        DC32     TXUADData + 14
        DC32     TXUADData + 10
        DC32     KbdIntCnt
        DC32     TCCnt
        DC32     IsDown
        DC32     ADChannel
        DC32     TXUADData
        DC32     ADCCon
        DC32     DefaultIrqCnt
        CFI EndBlock cfiBlock19

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon1
        CFI NoFunction
        ARM
??rA??divu32_a:
        LDR      R12,??Subroutine8_0  ;; ??divu32_a
        MOV      PC,R12
        DATA
??Subroutine8_0:
        DC32     ??divu32_a
        CFI EndBlock cfiBlock20

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI NoFunction
        ARM
??OS_COM_ClearTxActive??rA:
        LDR      R12,??Subroutine9_0  ;; OS_COM_ClearTxActive
        BX       R12
        DATA
??Subroutine9_0:
        DC32     OS_COM_ClearTxActive
        CFI EndBlock cfiBlock21

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon1
        CFI NoFunction
        ARM
??HandleUARTInterrupt??rA:
        LDR      R12,??Subroutine10_0  ;; HandleUARTInterrupt
        BX       R12
        DATA
??Subroutine10_0:
        DC32     HandleUARTInterrupt
        CFI EndBlock cfiBlock22

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon1
        CFI NoFunction
        ARM
??OS_TickHandler??rA:
        LDR      R12,??Subroutine11_0  ;; OS_TickHandler
        BX       R12
        DATA
??Subroutine11_0:
        DC32     OS_TickHandler
        CFI EndBlock cfiBlock23

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon1
        CFI NoFunction
        ARM
??OS_Error??rA:
        LDR      R12,??Subroutine12_0  ;; OS_Error
        BX       R12
        DATA
??Subroutine12_0:
        DC32     OS_Error
        CFI EndBlock cfiBlock24

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI NoFunction
        ARM
??OS_SwitchFromInt??rA:
        LDR      R12,??Subroutine13_0  ;; OS_SwitchFromInt
        BX       R12
        DATA
??Subroutine13_0:
        DC32     OS_SwitchFromInt
        CFI EndBlock cfiBlock25

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon1
        CFI NoFunction
        ARM
??OS_SignalEvent??rA:
        LDR      R12,??Subroutine14_0  ;; OS_SignalEvent
        BX       R12
        DATA
??Subroutine14_0:
        DC32     OS_SignalEvent
        CFI EndBlock cfiBlock26

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for ADCCon>`:
        DATA
        DC32 58000000H

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        END
//  668 
//  669 
// 
// 3 884 bytes in segment CODE
//     8 bytes in segment DATA_AN
//     4 bytes in segment DATA_I
//     4 bytes in segment DATA_ID
//    66 bytes in segment DATA_Z
//    24 bytes in segment INITTAB
// 
// 3 768 bytes of CODE  memory (+ 140 bytes shared)
//     4 bytes of CONST memory
//    70 bytes of DATA  memory (+   8 bytes shared)
//
//Errors: none
//Warnings: none
