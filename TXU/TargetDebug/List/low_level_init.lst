##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               19/Jan/2017  10:13:09 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\CStartup\low_level_init.c              #
#    Command line    =  D:\S2Prog\TXU\CStartup\low_level_init.c --fpu None   #
#                       -D OS_LIBMODE_DP -D OS_RAMVECT=0 -D CPU_S3C2410 -D   #
#                       OS_UART=1 -D ANBOOTLOADER -D __ARM_LIBRARY__ -lCN    #
#                       D:\S2Prog\TXU\TargetDebug\List\ -o                   #
#                       D:\S2Prog\TXU\TargetDebug\Obj\ -s2 --no_cse          #
#                       --no_unroll --no_inline --no_code_motion --no_tbaa   #
#                       --no_clustering --no_scheduling --debug --cpu_mode   #
#                       arm --endian little --cpu ARM920T --stack_align 4    #
#                       --interwork -e --dlib_config "C:\Program Files       #
#                       (x86)\IAR Systems\Embedded Workbench                 #
#                       4.0\arm\LIB\dl4tpainl8f.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\MINILZO.108\ -I          #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\INC\"                              #
#    List file       =  D:\S2Prog\TXU\TargetDebug\List\low_level_init.lst    #
#    Object file     =  D:\S2Prog\TXU\TargetDebug\Obj\low_level_init.r79     #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\CStartup\low_level_init.c
      1          /**************************************************
      2           *
      3           * This module contains the function `__low_level_init', a function
      4           * that is called before the `main' function of the program.  Normally
      5           * low-level initializations - such as setting the prefered interrupt
      6           * level or setting the watchdog - can be performed here.
      7           *
      8           * Note that this function is called before the data segments are
      9           * initialized, this means that this function cannot rely on the
     10           * values of global or static variables.
     11           *
     12           * When this function returns zero, the startup code will inhibit the
     13           * initialization of the data segments. The result is faster startup,
     14           * the drawback is that neither global nor static data will be
     15           * initialized.
     16           *
     17           * Copyright 1999-2004 IAR Systems. All rights reserved.
     18           *
     19           * $Revision: 8621 $
     20           *
     21           **************************************************/
     22          
     23          #include "def.h"
     24          #include "2410addr.h"
     25          
     26          #ifdef __cplusplus
     27          extern "C" {
     28          #endif
     29          	extern void Timer_Start(int divider);
     30          
     31          #pragma language=extended
     32          
     33          	__interwork int __low_level_init(void);
     34          

   \                                 In segment CODE, align 4, keep-with-next
     35          	__interwork int __low_level_init(void)
     36          	{
     37          		/*==================================*/
     38          		/*  Initialize hardware.            */
     39          		/*==================================*/
     40          
     41          		/*==================================*/
     42          		/* Choose if segment initialization */
     43          		/* should be done or not.           */
     44          		/* Return: 0 to omit seg_init       */
     45          		/*         1 to run seg_init        */
     46          		/*==================================*/
     47          		//return 1;
     48          #if (WATCHDOG == 1)
     49          	#ifdef ANBOOTLOADER
     50          		rWTCON  = 0x00008000;			// Disable the watchdog
     51          	#else
     52          	//rWTCON  = 0x00008000;			// Disable the watchdog
     53          	Timer_Start(3);
     54          	#endif
     55          #else
     56          		rWTCON  = 0x00008000;			// Disable the watchdog
   \                     __low_level_init:
   \   00000000   5304A0E3           MOV      R0,#+1392508928
   \   00000004   801CA0E3           MOV      R1,#+32768
   \   00000008   001080E5           STR      R1,[R0, #+0]
     57          #endif
     58          
     59          		rBWSCON = 0x22d44444;			// Set SDRAM width to 32 bit for bank 6 and 7	, 8 bit and 1 waitstate for 1 to 4, 16 bit, 1 wait state, Using nBE on bank 5
   \   0000000C   4804A0E3           MOV      R0,#+1207959552
   \   00000010   84109FE5           LDR      R1,??__low_level_init_0  ;; 0x22d44444
   \   00000014   001080E5           STR      R1,[R0, #+0]
     60          
     61          /*
     62           Bank 5, set to Ethernet
     63           */
     64          	//rBANKCON5 =  0x0700;
     65          	rBANKCON5 =  0x7ff0;      // hkim. slowest speed at the moment
   \   00000018   1800A0E3           MOV      R0,#+24
   \   0000001C   480480E3           ORR      R0,R0,#0x48000000
   \   00000020   F010A0E3           MOV      R1,#+240
   \   00000024   7F1C81E3           ORR      R1,R1,#0x7F00
   \   00000028   001080E5           STR      R1,[R0, #+0]
     66          /*
     67           Bank 6, set to SDRAM
     68           RAS to CAS delay; 0 = 2 clk, 1 = 3 clk, 2 = 4 clk
     69           Column address no; 0 = 8 bit, 1 = 9 bit, 2 = 10 bit
     70           */
     71          		rBANKCON6 =  (3<<15) |(0<<2) |(1);
   \   0000002C   1C00A0E3           MOV      R0,#+28
   \   00000030   480480E3           ORR      R0,R0,#0x48000000
   \   00000034   0110A0E3           MOV      R1,#+1
   \   00000038   601B81E3           ORR      R1,R1,#0x18000
   \   0000003C   001080E5           STR      R1,[R0, #+0]
     72          /*
     73           Bank 7, set to SDRAM
     74           RAS to CAS delay; 0 = 2 clk, 1 = 3 clk, 2 = 4 clk
     75           Column address no; 0 = 8 bit, 1 = 9 bit, 2 = 10 bit
     76           */
     77          		rBANKCON7 =  (3<<15) |(0<<2) |(1);
   \   00000040   2000A0E3           MOV      R0,#+32
   \   00000044   480480E3           ORR      R0,R0,#0x48000000
   \   00000048   0110A0E3           MOV      R1,#+1
   \   0000004C   601B81E3           ORR      R1,R1,#0x18000
   \   00000050   001080E5           STR      R1,[R0, #+0]
     78          /*
     79          	rREFRESH =  (1<<23)  Enable refresh
     80          			|(0<<22)  0 = autorefresh, 1 = Self refresh
     81          			|(0<<20)  RAS pre charge time; 0=2 clk, 1=3clk, 2=4clk
     82          			|(0<<18)  RC min time; 0=4clk, 1=5 clk, 2=6clk, 3=7clk
     83          			|(0)       Refresh cnt; 2^11+1 -(90x15.6)
     84          */
     85          		rREFRESH =  (1<<23) |(0<<22) |(0<<20) |(0<<18) |(0);
   \   00000054   2400A0E3           MOV      R0,#+36
   \   00000058   480480E3           ORR      R0,R0,#0x48000000
   \   0000005C   8018A0E3           MOV      R1,#+8388608
   \   00000060   001080E5           STR      R1,[R0, #+0]
     86          #ifdef ANBOOTLOADER
     87          		rMRSRB6  =  (2<<4) ; // CAS latency; 0=1clk, 2=2clk, 3=3clk (USE 2!!)
   \   00000064   2C00A0E3           MOV      R0,#+44
   \   00000068   480480E3           ORR      R0,R0,#0x48000000
   \   0000006C   2010A0E3           MOV      R1,#+32
   \   00000070   001080E5           STR      R1,[R0, #+0]
     88          		rMRSRB7  =  (2<<4) ; // CAS latency; 0=1clk, 2=2clk, 3=3clk (USE 2!!)
   \   00000074   3000A0E3           MOV      R0,#+48
   \   00000078   480480E3           ORR      R0,R0,#0x48000000
   \   0000007C   2010A0E3           MOV      R1,#+32
   \   00000080   001080E5           STR      R1,[R0, #+0]
     89          #endif
     90          		rINTMSK  = BIT_ALLMSK;
   \   00000084   0800A0E3           MOV      R0,#+8
   \   00000088   4A0480E3           ORR      R0,R0,#0x4A000000
   \   0000008C   0010E0E3           MVN      R1,#+0
   \   00000090   001080E5           STR      R1,[R0, #+0]
     91                          return 1;
   \   00000094   0100A0E3           MOV      R0,#+1
   \   00000098   1EFF2FE1           BX       LR               ;; return
   \                     ??__low_level_init_0:
   \   0000009C   4444D422           DC32     0x22d44444
     92          	}
     93          
     94          #pragma language=default
     95          
     96          #ifdef __cplusplus
     97          }
     98          #endif
     99          
    100          

   Maximum stack usage in bytes:

     Function         CSTACK
     --------         ------
     __low_level_init     0


   Segment part sizes:

     Function/Label   Bytes
     --------------   -----
     __low_level_init  160
      Others             4

 
 164 bytes in segment CODE
 
 160 bytes of CODE memory (+ 4 bytes shared)

Errors: none
Warnings: none
