//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32              03/Nov/2007  13:00:13 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\S2Prog\Shared\Src\ModbusPro.cpp                  /
//    Command line    =  D:\S2Prog\Shared\Src\ModbusPro.cpp --fpu None -D    /
//                       OS_LIBMODE_R -D CPU_S3C2410 -D OS_RAMVECT=0 -D      /
//                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D                 /
//                       __ARM_LIBRARY__ -D WATCHDOG=1 -lCN                  /
//                       D:\S2Prog\TXU\TargetDebug\List\ -lA                 /
//                       D:\S2Prog\TXU\TargetDebug\List\ -o                  /
//                       D:\S2Prog\TXU\TargetDebug\Obj\ -s2 --no_cse         /
//                       --no_unroll --no_inline --no_code_motion --no_tbaa  /
//                       --no_clustering --no_scheduling --debug --cpu_mode  /
//                       arm --endian little --cpu ARM920T --stack_align 4   /
//                       --interwork -e --enable_multibytes --eec++          /
//                       --dlib_config "C:\Program Files\IAR                 /
//                       Systems\Embedded Workbench                          /
//                       4.0\ARM\LIB\dl4tpainl8f.h" -I                       /
//                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\    /
//                       -I D:\S2Prog\TXU\GUI\WIDGET\ -I                     /
//                       D:\S2Prog\TXU\CONFIG\ -I D:\S2Prog\TXU\INC\ -I      /
//                       D:\S2Prog\TXU\..\SHARED\INC\ -I                     /
//                       D:\S2Prog\TXU\..\SHARED\SRC\ -I                     /
//                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.108\ -I         /
//                       "C:\Program Files\IAR Systems\Embedded Workbench    /
//                       4.0\ARM\INC\"                                       /
//    List file       =  D:\S2Prog\TXU\TargetDebug\List\ModbusPro.s79        /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME ModbusPro

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        EXTERN ?call_ctors

        PUBWEAK `?*?DATA_ID`
        PUBLIC ??CalcCRC
        FUNCTION ??CalcCRC,0203H
        LOCFRAME CSTACK, 16, STACK
        MULTWEAK ??CalcCRC??rT
        PUBLIC ??FastCalcCRC
        FUNCTION ??FastCalcCRC,0203H
        LOCFRAME CSTACK, 8, STACK
        MULTWEAK ??FastCalcCRC??rT
        PUBLIC ??Get_Multiple
        FUNCTION ??Get_Multiple,0203H
        LOCFRAME CSTACK, 1084, STACK
        MULTWEAK ??Get_Multiple??rT
        PUBLIC ??Get_Single
        FUNCTION ??Get_Single,0203H
        LOCFRAME CSTACK, 52, STACK
        MULTWEAK ??Get_Single??rT
        PUBLIC ??Initiate
        FUNCTION ??Initiate,0203H
        MULTWEAK ??Initiate??rT
        PUBLIC ??ModbusPro
        FUNCTION ??ModbusPro,0203H
        LOCFRAME CSTACK, 8, STACK
        MULTWEAK ??ModbusPro??rT
        PUBLIC ??Modbus_Response
        FUNCTION ??Modbus_Response,0203H
        LOCFRAME CSTACK, 1068, STACK
        MULTWEAK ??Modbus_Response??rT
        PUBLIC ??Preset_Response
        FUNCTION ??Preset_Response,0203H
        LOCFRAME CSTACK, 1064, STACK
        MULTWEAK ??Preset_Response??rT
        PUBLIC ??ReceiveStatus
        FUNCTION ??ReceiveStatus,0203H
        MULTWEAK ??ReceiveStatus??rT
        PUBLIC ??Receive_Response
        FUNCTION ??Receive_Response,0203H
        LOCFRAME CSTACK, 32, STACK
        MULTWEAK ??Receive_Response??rT
        PUBLIC ??Send_Query
        FUNCTION ??Send_Query,0203H
        LOCFRAME CSTACK, 28, STACK
        MULTWEAK ??Send_Query??rT
        PUBLIC ??Set_Multiple
        FUNCTION ??Set_Multiple,0203H
        LOCFRAME CSTACK, 308, STACK
        MULTWEAK ??Set_Multiple??rT
        PUBLIC ??Set_Single
        FUNCTION ??Set_Single,0203H
        LOCFRAME CSTACK, 56, STACK
        MULTWEAK ??Set_Single??rT
        PUBLIC ??WriteMultipleCoils
        FUNCTION ??WriteMultipleCoils,0203H
        LOCFRAME CSTACK, 308, STACK
        MULTWEAK ??WriteMultipleCoils??rT
        PUBLIC ??WriteMultipleRegisters
        FUNCTION ??WriteMultipleRegisters,0203H
        LOCFRAME CSTACK, 308, STACK
        MULTWEAK ??WriteMultipleRegisters??rT
        FUNCTION ??__sti__routine,010203H
        MULTWEAK ??memcpy??rA
        PUBLIC `??new ModbusPro`
        FUNCTION `??new ModbusPro`,0203H
        LOCFRAME CSTACK, 4, STACK
        MULTWEAK `??new ModbusPro??rT`
        MULTWEAK `??operator new??rA`
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        

memcpy              SYMBOL "memcpy"

??CalcCRC??rT       SYMBOL "??rT", ??CalcCRC

??FastCalcCRC??rT   SYMBOL "??rT", ??FastCalcCRC

??Get_Multiple??rT  SYMBOL "??rT", ??Get_Multiple

??Get_Single??rT    SYMBOL "??rT", ??Get_Single

??Initiate??rT      SYMBOL "??rT", ??Initiate

??ModbusPro??rT     SYMBOL "??rT", ??ModbusPro

??Modbus_Response??rT SYMBOL "??rT", ??Modbus_Response

??Preset_Response??rT SYMBOL "??rT", ??Preset_Response

??ReceiveStatus??rT SYMBOL "??rT", ??ReceiveStatus

??Receive_Response??rT SYMBOL "??rT", ??Receive_Response

??Send_Query??rT    SYMBOL "??rT", ??Send_Query

??Set_Multiple??rT  SYMBOL "??rT", ??Set_Multiple

??Set_Single??rT    SYMBOL "??rT", ??Set_Single

??WriteMultipleCoils??rT SYMBOL "??rT", ??WriteMultipleCoils

??WriteMultipleRegisters??rT SYMBOL "??rT", ??WriteMultipleRegisters
??memcpy??rA        SYMBOL "??rA", memcpy

`??new ModbusPro??rT` SYMBOL "??rT", `??new ModbusPro`
`??operator new??rA` SYMBOL "??rA", `??operator new`

        EXTERN `??operator new`
        FUNCTION `??operator new`,010202H
        EXTERN GUI_Font13_1
        EXTERN GUI_Font16_1
        EXTERN GUI_Font24_1
        EXTERN memcpy
        FUNCTION memcpy,010202H

// D:\S2Prog\Shared\Src\ModbusPro.cpp
//    1 #include "TSNIncludes.h"

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
// static GUI_FONT const __data TDU_FONT_ST
TDU_FONT_ST:
        DS8 32

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
// static GUI_FONT const __data TDU_FONT_PW
TDU_FONT_PW:
        DS8 32

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
// static GUI_FONT const __data TDU_FONT_HW
TDU_FONT_HW:
        DS8 32

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
// static GUI_FONT const __data TDU_FONT_BU
TDU_FONT_BU:
        DS8 32

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
// static GUI_FONT const __data TDU_FONT_HEADING
TDU_FONT_HEADING:
        DS8 32

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
// static GUI_FONT const __data TDU_FONT_BIG
TDU_FONT_BIG:
        DS8 32

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
`??new ModbusPro??rT`:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE `??new ModbusPro`

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function `??new ModbusPro`
        ARM
// __??Code32?? __code __interwork __atpcs ModbusPro &ModbusPro::new ModbusPro()
`??new ModbusPro`:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        MOV      R0,#+1
        _BLF     `??operator new`,`??operator new??rA`
        CMP      R0,#+0
        BEQ      `??new ModbusPro_1`
        BL       ??ModbusPro
        B        `??new ModbusPro_2`
`??new ModbusPro_1`:
        MOV      R0,#+0
`??new ModbusPro_2`:
        POP      {LR}
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??__sti__routine??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE ??__sti__routine

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function ??__sti__routine
        ARM
// static __??Code32?? __intrinsic __code __interwork __atpcs void __sti__routine()
??__sti__routine:
        LDR      R0,??__sti__routine_1  ;; TDU_FONT_ST
        LDR      R1,??__sti__routine_1+0x4  ;; GUI_Font13_1
        MOV      R3,#+32
??__sti__routine_2:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??__sti__routine_2
        LDR      R0,??__sti__routine_1+0x8  ;; TDU_FONT_PW
        LDR      R1,??__sti__routine_1+0xC  ;; GUI_Font16_1
        MOV      R3,#+32
??__sti__routine_3:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??__sti__routine_3
        LDR      R0,??__sti__routine_1+0x10  ;; TDU_FONT_HW
        LDR      R1,??__sti__routine_1+0xC  ;; GUI_Font16_1
        MOV      R3,#+32
??__sti__routine_4:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??__sti__routine_4
        LDR      R0,??__sti__routine_1+0x14  ;; TDU_FONT_BU
        LDR      R1,??__sti__routine_1+0x4  ;; GUI_Font13_1
        MOV      R3,#+32
??__sti__routine_5:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??__sti__routine_5
        LDR      R0,??__sti__routine_1+0x18  ;; TDU_FONT_HEADING
        LDR      R1,??__sti__routine_1+0x4  ;; GUI_Font13_1
        MOV      R3,#+32
??__sti__routine_6:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??__sti__routine_6
        LDR      R0,??__sti__routine_1+0x1C  ;; TDU_FONT_BIG
        LDR      R1,??__sti__routine_1+0x20  ;; GUI_Font24_1
        MOV      R3,#+32
??__sti__routine_7:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??__sti__routine_7
        BX       LR               ;; return
        DATA
??__sti__routine_1:
        DC32     TDU_FONT_ST
        DC32     GUI_Font13_1
        DC32     TDU_FONT_PW
        DC32     GUI_Font16_1
        DC32     TDU_FONT_HW
        DC32     TDU_FONT_BU
        DC32     TDU_FONT_HEADING
        DC32     TDU_FONT_BIG
        DC32     GUI_Font24_1
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??ModbusPro??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE ??ModbusPro
//    2 #pragma hdrstop
//    3 #ifdef BORLAND
//    4 	#pragma package(smart_init)
//    5 #endif
//    6 
//    7 #include "ModbusConst.h"
//    8 
//    9 #ifdef WIN32
//   10 	#include "WinUart.h"
//   11 #else
//   12 	#include "SC2410Uart.h"
//   13 	#include "ST16554Uart.h"
//   14 #endif
//   15 
//   16 //---------------------------------------------------------------------------
//   17 /***********************************************************************
//   18 
//   19 	 Note: All functions used for sending or receiving data via
//   20 			 modbus return these return values.
//   21 
//   22 
//   23 	Returns:	string_length if OK
//   24 			0 if failed
//   25 			Less than 0 for exception errors
//   26 
//   27 ***********************************************************************/
//   28 
//   29 
//   30 ///////////////////////////////////////////////////////////////////////
//   31 //
//   32 //  ModbusPro object routines
//   33 //
//   34 ///////////////////////////////////////////////////////////////////////
//   35 
//   36 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function ??ModbusPro
        ARM
//   37 ModbusPro::ModbusPro()
//   38 {
??ModbusPro:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOVS     R4,R0
//   39 	Initiate();
        MOVS     R0,R4
        BL       ??Initiate
//   40 }
        MOVS     R0,R4
        POP      {R4,LR}
        CFI R4 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??Initiate??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE ??Initiate
//   41 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function ??Initiate
        ARM
//   42 void ModbusPro::Initiate(void)
//   43 {
//   44 }
??Initiate:
        BX       LR               ;; return
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??ReceiveStatus??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE ??ReceiveStatus
//   45 
//   46 
//   47 ///////////////////////////////////////////////////////////////////////////////////////
//   48 
//   49 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function ??ReceiveStatus
        ARM
//   50 void ModbusPro::ReceiveStatus(TSNUart *Port)
//   51 {
//   52 }
??ReceiveStatus:
        BX       LR               ;; return
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??FastCalcCRC??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE ??FastCalcCRC
//   53 
//   54 
//   55 /* Table of CRC values for high-order byte */

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   56 static U8 auchCRCHi[] = {
auchCRCHi:
        DS8 256
        REQUIRE `?<Initializer for auchCRCHi>`
//   57 	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
//   58 	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
//   59 	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
//   60 	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
//   61 	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
//   62 	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
//   63 	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
//   64 	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
//   65 	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
//   66 	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
//   67 	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
//   68 	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
//   69 	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
//   70 	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
//   71 	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
//   72 	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
//   73 	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
//   74 	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
//   75 	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
//   76 	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
//   77 	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
//   78 	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
//   79 	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
//   80 	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
//   81 	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
//   82 	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
//   83 } ;
//   84 
//   85 /* Table of CRC values for low-order byte */

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   86 static U8 auchCRCLo[] = {
auchCRCLo:
        DS8 256
        REQUIRE `?<Initializer for auchCRCLo>`
//   87 	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
//   88 	0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
//   89 	0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
//   90 	0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
//   91 	0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
//   92 	0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
//   93 	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
//   94 	0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
//   95 	0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
//   96 	0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
//   97 	0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
//   98 	0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
//   99 	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
//  100 	0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
//  101 	0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
//  102 	0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
//  103 	0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
//  104 	0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
//  105 	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
//  106 	0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
//  107 	0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
//  108 	0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
//  109 	0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
//  110 	0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
//  111 	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
//  112 	0x43, 0x83, 0x41, 0x81, 0x80, 0x40
//  113 } ;
//  114 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function ??FastCalcCRC
        ARM
//  115 unsigned ModbusPro::FastCalcCRC(U8 *puchMsg, unsigned usDataLen)
//  116 {
??FastCalcCRC:
        PUSH     {R4,R5}
        CFI R5 Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOVS     R2,R0
//  117 	U8 uchCRCHi = 0xFF ;	/* high CRC byte initialized 	*/
        MOV      R4,#+255
        MOVS     R0,R4
//  118 	U8 uchCRCLo = 0xFF ;	/* low CRC byte  initialized  	*/
        MOV      R4,#+255
        MOVS     R12,R4
//  119 	unsigned uIndex ;				/* will index into CRC   lookup */
//  120 	/* table              			*/
//  121 	while ( usDataLen-- ) {			 /* pass through message buffer  */
??FastCalcCRC_1:
        MOVS     R4,R1
        SUBS     R1,R4,#+1
        CMP      R4,#+0
        BEQ      ??FastCalcCRC_2
//  122 		uIndex   = uchCRCHi ^ *puchMsg++ ;	/* calculate the CRC  */
        MOVS     R4,R0
        ANDS     R4,R4,#0xFF      ;; Zero extend
        LDRB     R5,[R2, #+0]
        EORS     R4,R5,R4
        MOVS     R3,R4
        ADDS     R2,R2,#+1
//  123 		uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ;
        LDR      R4,??FastCalcCRC_3  ;; auchCRCHi
        LDRB     R4,[R3, +R4]
        EORS     R4,R4,R12
        MOVS     R0,R4
//  124 		uchCRCLo = auchCRCLo[uIndex] ;
        LDR      R4,??FastCalcCRC_3+0x4  ;; auchCRCLo
        LDRB     R4,[R3, +R4]
        MOVS     R12,R4
        B        ??FastCalcCRC_1
//  125 	}
//  126 	return((uchCRCHi << 8) | uchCRCLo) ;
??FastCalcCRC_2:
        ANDS     R0,R0,#0xFF      ;; Zero extend
        ORRS     R0,R12,R0, LSL #+8
        POP      {R4,R5}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??FastCalcCRC_3:
        DC32     auchCRCHi
        DC32     auchCRCLo
        CFI EndBlock cfiBlock11
//  127 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??CalcCRC??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE ??CalcCRC
//  128 
//  129 
//  130 
//  131 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function ??CalcCRC
        ARM
//  132 unsigned ModbusPro::CalcCRC(unsigned char *buf,int start,int cnt)
//  133 {
??CalcCRC:
        PUSH     {R4-R7}
        CFI R7 Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        MOVS     R3,R0
//  134 	int     i,j;
//  135 	unsigned    temp,temp2,flag;
//  136 
//  137 	temp=0xFFFF;
        MOV      R7,#+255
        ORR      R7,R7,#0xFF00
        MOVS     R0,R7
//  138 
//  139 	for ( i=start; i<cnt; i++ ) {
        MOVS     R6,R1
??CalcCRC_1:
        CMP      R6,R2
        BGE      ??CalcCRC_2
//  140 		temp=temp ^ buf[i];
        LDRB     R7,[R6, +R3]
        EORS     R0,R7,R0
//  141 
//  142 		for ( j=1; j<=8; j++ ) {
        MOV      R7,#+1
        MOVS     R5,R7
??CalcCRC_3:
        CMP      R5,#+9
        BGE      ??CalcCRC_4
//  143 			flag=temp & 0x0001;
        ANDS     R7,R0,#0x1
        MOVS     R4,R7
//  144 			temp=temp >> 1;
        LSRS     R0,R0,#+1
//  145 			if ( flag )	temp=temp ^ 0xA001;
        CMP      R4,#+0
        BEQ      ??CalcCRC_5
        MOV      R7,#+1
        ORR      R7,R7,#0xA000
        EORS     R0,R7,R0
//  146 		}
??CalcCRC_5:
        ADDS     R5,R5,#+1
        B        ??CalcCRC_3
//  147 	}
??CalcCRC_4:
        ADDS     R6,R6,#+1
        B        ??CalcCRC_1
//  148 
//  149 	/* Reverse byte order. */
//  150 
//  151 	temp2=temp >> 8;
??CalcCRC_2:
        LSRS     R7,R0,#+8
        MOVS     R12,R7
//  152 	temp=(temp << 8) | temp2;
        ORRS     R0,R12,R0, LSL #+8
//  153 	temp &= 0xFFFF;
        LSLS     R0,R0,#+16
        LSRS     R0,R0,#+16
//  154 
//  155 	return(temp);
        POP      {R4-R7}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock13
//  156 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??Send_Query??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock14
        REQUIRE ??Send_Query
//  157 
//  158 
//  159 
//  160 
//  161 
//  162 
//  163 /***********************************************************************
//  164 
//  165 Function to send a query out to a modbus slave.
//  166 
//  167 A checksum is added to the end of a packet.
//  168 Please note that the packet array must be at least 3 fields longer than
//  169 string_length.
//  170 
//  171 ************************************************************************/
//  172 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI Function ??Send_Query
        ARM
//  173 bool ModbusPro::Send_Query(TSNUart *Port, U8 *Query, size_t Length )
//  174 {
??Send_Query:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R8,R2
//  175 	bool Status;
//  176 	unsigned TmpCRC   = FastCalcCRC( Query, Length );
        MOVS     R1,R8
        MOVS     R0,R5
        BL       ??FastCalcCRC
        MOVS     R7,R0
//  177 	Query[ Length++ ] = TmpCRC >> 8;
        LSRS     R0,R7,#+8
        STRB     R0,[R8, +R5]
        ADDS     R8,R8,#+1
//  178 	Query[ Length++ ] = TmpCRC & 0x00FF;
        STRB     R7,[R8, +R5]
        ADDS     R8,R8,#+1
//  179 	//Query[ Length++ ] = 0;
//  180 	//Query[ Length++ ] = 0; // The last 0 is added by the Uart handle
//  181 	Status = Port->Send(Query,(int)Length,0x1,true);
        LDR      R0,[R4, #+184]
        ADDS     R12,R0,#+4
        MOV      R0,#+1
        PUSH     {R0}
        CFI CFA R13+28
        MOV      R3,#+1
        MOVS     R2,R8
        MOVS     R1,R5
        MOVS     R0,R4
        LDR      R12,[R12, #+0]
        MOV      LR,PC
        BX       R12
        ADD      SP,SP,#+4        ;; stack cleaning
        CFI CFA R13+24
        MOVS     R6,R0
//  182 	return( Status );
        MOVS     R0,R6
        POP      {R4-R8,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock15
//  183 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??Receive_Response??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock16
        REQUIRE ??Receive_Response
//  184 
//  185 
//  186 /***********************************************************************
//  187 
//  188 	receive_response( array_for_data )
//  189 
//  190 	 Function to monitor for the reply from the modbus slave.
//  191 	 This function blocks for timeout seconds if there is no reply.
//  192 
//  193 	 Returns:	Total number of characters received.
//  194 ***********************************************************************/
//  195 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI Function ??Receive_Response
        ARM
//  196 int ModbusPro::Receive_Response( TSNUart *Port, U8 *received_string, int Delay1, int Delay2 )
//  197 {
??Receive_Response:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        SUB      SP,SP,#+4
        CFI CFA R13+32
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  198 
//  199 	bool dataAvailable = false;
        MOV      R0,#+0
        MOVS     R8,R0
//  200 	int bytes_received = 0;
        MOV      R0,#+0
        MOVS     R9,R0
//  201 	volatile int Cnt=0;
        MOV      R1,#+0
        STR      R1,[SP, #+0]
//  202 	/* wait for a response */
//  203 	dataAvailable = Port->Receive(&received_string[ bytes_received ],sizeof(U8),Delay1);
        LDR      R0,[R4, #+184]
        ADDS     R12,R0,#+8
        MOVS     R3,R6
        MOV      R2,#+1
        ADDS     R1,R9,R5
        MOVS     R0,R4
        LDR      R12,[R12, #+0]
        MOV      LR,PC
        BX       R12
        MOVS     R8,R0
//  204 	while ( dataAvailable ) {
??Receive_Response_1:
        CMP      R8,#+0
        BEQ      ??Receive_Response_2
//  205 		dataAvailable = Port->Receive(&received_string[++bytes_received ],sizeof(U8),Delay2);
        LDR      R0,[R4, #+184]
        ADDS     R12,R0,#+8
        ADDS     R9,R9,#+1
        MOVS     R3,R7
        MOV      R2,#+1
        ADDS     R1,R9,R5
        MOVS     R0,R4
        LDR      R12,[R12, #+0]
        MOV      LR,PC
        BX       R12
        MOVS     R8,R0
//  206 		Cnt++;
        LDR      R1,[SP, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[SP, #+0]
        B        ??Receive_Response_1
//  207 	}
//  208 
//  209 	return( bytes_received );
??Receive_Response_2:
        MOVS     R0,R9
        ADD      SP,SP,#+4        ;; stack cleaning
        CFI CFA R13+28
        POP      {R4-R9,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock17
//  210 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??Modbus_Response??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock18
        REQUIRE ??Modbus_Response
//  211 
//  212 
//  213 /*********************************************************************
//  214 
//  215 	modbus_response( response_data_array, query_array )
//  216 
//  217 	 Function to the correct response is returned and that the checksum
//  218 	 is correct.
//  219 
//  220 	 Returns:	string_length if OK
//  221 		0 if failed
//  222 		Less than 0 for exception errors
//  223 
//  224 	Note: All functions used for sending or receiving data via
//  225 			modbus return these return values.
//  226 
//  227 **********************************************************************/
//  228 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon1
        CFI Function ??Modbus_Response
        ARM
//  229 int ModbusPro::Modbus_Response(TSNUart *Port, U8 *ReplyPtr, U8 *query, int QueryLength, int Delay1, int Delay2)
//  230 {
??Modbus_Response:
        PUSH     {R2,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
        SUB      SP,SP,#+4
        CFI CFA R13+44
        SUB      SP,SP,#+1024
        CFI CFA R13+1068
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R3
        LDR      R7,[SP, #+1068]
        LDR      R8,[SP, #+1072]
//  231 	QueryLength+=3;
        ADDS     R6,R6,#+3
//  232 	U8 tmpData[MAX_RESPONSE_LENGTH];
//  233 	//memset(tmpData,0xff,MAX_QUERY_LENGTH);
//  234 
//  235 	int AnswerSize = Receive_Response(Port,  tmpData, Delay1, Delay2 );
        MOVS     R3,R8
        MOVS     R2,R7
        ADD      R1,SP,#+4
        MOVS     R0,R4
        BL       ??Receive_Response
        MOVS     R9,R0
//  236 	if ( AnswerSize ) {
        CMP      R9,#+0
        BEQ      ??Modbus_Response_1
//  237 		switch ( Port->HWProtocol ) {
        LDR      R0,[R4, #+124]
        MOV      R1,#+75
        ORR      R1,R1,#0x1F00
        CMP      R0,R1
        BNE      ??Modbus_Response_2
//  238 			case C_UART_HWPRO_485 :
//  239 				break;
//  240 			case C_UART_HWPRO_232 :
//  241 				QueryLength = 0;
??Modbus_Response_3:
        MOV      R0,#+0
        MOVS     R6,R0
//  242 				break;
//  243 		}
//  244 		AnswerSize -= QueryLength;
??Modbus_Response_2:
        SUBS     R9,R9,R6
//  245 		if ( AnswerSize > 0 ) {
        CMP      R9,#+1
        BLT      ??Modbus_Response_4
//  246 			memcpy(ReplyPtr,&tmpData[QueryLength],AnswerSize);
        MOVS     R2,R9
        ADD      R0,SP,#+4
        ADDS     R1,R6,R0
        MOVS     R0,R5
        _BLF     memcpy,??memcpy??rA
//  247 
//  248 			U16 crc_calc = FastCalcCRC( ReplyPtr, AnswerSize - 2 );
        SUBS     R1,R9,#+2
        MOVS     R0,R5
        BL       ??FastCalcCRC
        STRH     R0,[SP, #+2]
//  249 
//  250 			U8 recv_crc_hi = (U8) ReplyPtr[ AnswerSize - 2 ];
        ADDS     R1,R9,R5
        LDRB     R1,[R1, #-2]
        STRB     R1,[SP, #+0]
//  251 			U8 recv_crc_lo = (U8) ReplyPtr[ AnswerSize - 1 ];
        ADDS     R0,R9,R5
        LDRB     R0,[R0, #-1]
        MOVS     R10,R0
//  252 
//  253 			U16 crc_received  = ( recv_crc_hi << 8) | recv_crc_lo;
        LDRB     R0,[SP, #+0]
        MOVS     R1,R10
        ORRS     R0,R1,R0, LSL #+8
        MOVS     R11,R0
//  254 
//  255 
//  256 			/*********** check CRC of response ************/
//  257 
//  258 			if ( crc_calc != crc_received ) {
        LDRH     R0,[SP, #+2]
        MOV      R11,R11, LSL #+16
        MOVS     R11,R11, LSR #+16
        CMP      R0,R11
        BEQ      ??Modbus_Response_5
//  259 
//  260 				AnswerSize = 0;
        MOV      R0,#+0
        MOVS     R9,R0
        B        ??Modbus_Response_5
//  261 
//  262 			}
//  263 		} else {
//  264 			AnswerSize = 0;
??Modbus_Response_4:
        MOV      R0,#+0
        MOVS     R9,R0
//  265 		}
//  266 
//  267 
//  268 
//  269 		/********** check for exception response *****/
//  270 
//  271 		if ( AnswerSize && ReplyPtr[ 1 ] != query [ 1 ] ) {
??Modbus_Response_5:
        CMP      R9,#+0
        BEQ      ??Modbus_Response_1
        LDRB     R0,[R5, #+1]
        LDR      R1,[SP, #+1028]
        LDRB     R1,[R1, #+1]
        CMP      R0,R1
        BEQ      ??Modbus_Response_1
//  272 			AnswerSize = 0 - ReplyPtr[ 2 ];
        LDRB     R0,[R5, #+2]
        RSBS     R0,R0,#+0
        MOVS     R9,R0
//  273 		}
//  274 	}
//  275 	return( AnswerSize );
??Modbus_Response_1:
        MOVS     R0,R9
        ADD      SP,SP,#+8        ;; stack cleaning
        CFI CFA R13+1060
        ADD      SP,SP,#+1024
        CFI CFA R13+36
        POP      {R4-R11,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock19
//  276 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??Preset_Response??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock20
        REQUIRE ??Preset_Response
//  277 
//  278 
//  279 /***********************************************************************
//  280 
//  281 	preset_response
//  282 
//  283 	Gets the raw data from the input stream.
//  284 
//  285 ***********************************************************************/
//  286 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI Function ??Preset_Response
        ARM
//  287 int ModbusPro::Preset_Response(TSNUart *Port, U8 *query,int QueryLength,int Delay1, int Delay2, U8 *Reply)
//  288 {
??Preset_Response:
        PUSH     {R4-R10,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        SUB      SP,SP,#+1024
        CFI CFA R13+1056
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
        LDR      R8,[SP, #+1056]
        LDR      R9,[SP, #+1060]
//  289 	int ResponseLength;
//  290 	if ( Reply ) {
        CMP      R9,#+0
        BEQ      ??Preset_Response_1
//  291 		ResponseLength = Modbus_Response( Port, Reply, query, QueryLength, Delay1,Delay2);
        MOVS     R0,R8
        PUSH     {R0}
        CFI CFA R13+1060
        MOVS     R0,R7
        PUSH     {R0}
        CFI CFA R13+1064
        MOVS     R3,R6
        MOVS     R2,R5
        MOVS     R1,R9
        MOVS     R0,R4
        BL       ??Modbus_Response
        ADD      SP,SP,#+8        ;; stack cleaning
        CFI CFA R13+1056
        MOVS     R10,R0
        B        ??Preset_Response_2
//  292 	} else {
//  293 		U8 DataBuf[MAX_RESPONSE_LENGTH];
//  294 		ResponseLength = Modbus_Response( Port, DataBuf, query, QueryLength,Delay1,Delay2);
??Preset_Response_1:
        MOVS     R0,R8
        PUSH     {R0}
        CFI CFA R13+1060
        MOVS     R0,R7
        PUSH     {R0}
        CFI CFA R13+1064
        MOVS     R3,R6
        MOVS     R2,R5
        ADD      R1,SP,#+8
        MOVS     R0,R4
        BL       ??Modbus_Response
        ADD      SP,SP,#+8        ;; stack cleaning
        CFI CFA R13+1056
        MOVS     R10,R0
//  295 	}
//  296 	return( ResponseLength );
??Preset_Response_2:
        MOVS     R0,R10
        ADD      SP,SP,#+1024     ;; stack cleaning
        CFI CFA R13+32
        POP      {R4-R10,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock21
//  297 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon0
        CFI NoFunction
        THUMB
??Set_Single??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock22
        REQUIRE ??Set_Single
//  298 
//  299 
//  300 
//  301 
//  302 
//  303 
//  304 /*************************************************************************
//  305 
//  306 	set_single
//  307 
//  308 	sends a value to a register in a slave.
//  309 
//  310 **************************************************************************/
//  311 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon1
        CFI Function ??Set_Single
        ARM
//  312 int ModbusPro::Set_Single(TSNUart *Port, unsigned Function, unsigned SlaveAddress, unsigned Address, unsigned Value, int Delay1, int Delay2)
//  313 {
??Set_Single:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+12
        CFI CFA R13+48
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
        LDR      R8,[SP, #+48]
        LDR      R9,[SP, #+52]
        LDR      R10,[SP, #+56]
//  314 
//  315 	int status;
//  316 	//SlaveAddress--;
//  317 	// Not that the Packet contains 3 times 0x0 to make space for CRC
//  318 	U8 Packet[REQUEST_QUERY_SIZE+CHECKSUM_SIZE+1]={
        STRB     R6,[SP, #+0]
        STRB     R5,[SP, #+1]
        LSRS     R1,R7,#+8
        STRB     R1,[SP, #+2]
        STRB     R7,[SP, #+3]
        LSRS     R1,R8,#+8
        STRB     R1,[SP, #+4]
        STRB     R8,[SP, #+5]
//  319 		SlaveAddress,
//  320 		Function,
//  321 		Address >> 8,
//  322 		Address & 0xFF,
//  323 		Value >> 8,
//  324 		Value & 0xff ,
//  325 	};
//  326 
//  327 	if ( Send_Query(Port, Packet, REQUEST_QUERY_SIZE ) ) {
        MOV      R2,#+6
        MOVS     R1,SP
        MOVS     R0,R4
        BL       ??Send_Query
        CMP      R0,#+0
        BEQ      ??Set_Single_1
//  328 		status = Preset_Response(Port, Packet,REQUEST_QUERY_SIZE,Delay1,Delay2 );
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+52
        MOVS     R0,R10
        PUSH     {R0}
        CFI CFA R13+56
        MOVS     R3,R9
        MOV      R2,#+6
        ADD      R1,SP,#+8
        MOVS     R0,R4
        BL       ??Preset_Response
        ADD      SP,SP,#+8        ;; stack cleaning
        CFI CFA R13+48
        MOVS     R11,R0
        B        ??Set_Single_2
//  329 	} else {
//  330 		status = PORT_FAILURE;
??Set_Single_1:
        MVN      R0,#+10
        MOVS     R11,R0
//  331 	}
//  332 
//  333 	return( status );
??Set_Single_2:
        MOVS     R0,R11
        ADD      SP,SP,#+12       ;; stack cleaning
        CFI CFA R13+36
        POP      {R4-R11,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock23
//  334 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??Set_Multiple??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock24
        REQUIRE ??Set_Multiple
//  335 
//  336 
//  337 /*************************************************************************
//  338 
//  339 	set_multiple
//  340 
//  341 	sends a value to a register in a slave.
//  342 
//  343 **************************************************************************/
//  344 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI Function ??Set_Multiple
        ARM
//  345 int ModbusPro::Set_Multiple(TSNUart *Port, unsigned Function, unsigned SlaveAddress, unsigned Address, unsigned NumberOfRegisters, unsigned Size, U16 Value[], int Delay1, int Delay2)
//  346 {
??Set_Multiple:
        PUSH     {R1,R2,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+44
        SUB      SP,SP,#+256
        CFI CFA R13+300
        MOVS     R4,R0
        MOVS     R11,R3
        LDR      R5,[SP, #+300]
        LDR      R6,[SP, #+308]
        LDR      R7,[SP, #+312]
        LDR      R8,[SP, #+316]
//  347 	if ( Address > 0 ) Address--;
        CMP      R11,#+0
        BEQ      ??Set_Multiple_1
        SUBS     R11,R11,#+1
//  348 
//  349 	int status;
//  350 
//  351 
//  352 	// Not that the Packet contains 3 times 0x0 to make space for CRC
//  353 	U8 Packet[MAX_QUERY_LENGTH]={
??Set_Multiple_1:
        LDR      R1,[SP, #+260]
        STRB     R1,[SP, #+0]
        LDR      R1,[SP, #+256]
        STRB     R1,[SP, #+1]
        LSRS     R1,R11,#+8
        STRB     R1,[SP, #+2]
        STRB     R11,[SP, #+3]
        LSRS     R1,R5,#+8
        STRB     R1,[SP, #+4]
        STRB     R5,[SP, #+5]
        MOVS     R1,R5
        MOV      R2,#+2
        MULS     R1,R2,R1
        STRB     R1,[SP, #+6]
//  354 		SlaveAddress,
//  355 		Function,
//  356 		Address >> 8,
//  357 		Address & 0x00FF,
//  358 		NumberOfRegisters >> 8,
//  359 		NumberOfRegisters & 0x00FF,
//  360 		NumberOfRegisters*2,
//  361 	};
//  362 
//  363 	int Length = REQUEST_MULTIPLE_SIZE;
        MOV      R0,#+7
        MOVS     R10,R0
//  364 	for ( unsigned i=0; i < NumberOfRegisters; i++ ) {
        MOV      R1,#+0
        MOVS     R0,R1
??Set_Multiple_2:
        CMP      R0,R5
        BCS      ??Set_Multiple_3
//  365 		Packet[Length++] = Value[i] >> 8;
        MOVS     R1,SP
        MOV      R2,#+2
        MLA      R3,R2,R0,R6
        LDRH     R2,[R3, #+0]
        LSRS     R2,R2,#+8
        STRB     R2,[R10, +R1]
        ADDS     R10,R10,#+1
//  366 		Packet[Length++] = Value[i] & 0x00FF;
        MOVS     R1,SP
        MOV      R2,#+2
        MLA      R3,R2,R0,R6
        LDRH     R2,[R3, #+0]
        STRB     R2,[R10, +R1]
        ADDS     R10,R10,#+1
//  367 	}
        ADDS     R0,R0,#+1
        B        ??Set_Multiple_2
//  368 	if ( Send_Query(Port, Packet, Length ) ) {
??Set_Multiple_3:
        MOVS     R2,R10
        MOVS     R1,SP
        MOVS     R0,R4
        BL       ??Send_Query
        CMP      R0,#+0
        BEQ      ??Set_Multiple_4
//  369 		status = Preset_Response(Port, Packet, Length,Delay1,Delay2);
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+304
        MOVS     R0,R8
        PUSH     {R0}
        CFI CFA R13+308
        MOVS     R3,R7
        MOVS     R2,R10
        ADD      R1,SP,#+8
        MOVS     R0,R4
        BL       ??Preset_Response
        ADD      SP,SP,#+8        ;; stack cleaning
        CFI CFA R13+300
        MOVS     R9,R0
        B        ??Set_Multiple_5
//  370 	} else {
//  371 		status = PORT_FAILURE;
??Set_Multiple_4:
        MVN      R0,#+10
        MOVS     R9,R0
//  372 	}
//  373 
//  374 	return( status );
??Set_Multiple_5:
        MOVS     R0,R9
        ADD      SP,SP,#+264      ;; stack cleaning
        CFI CFA R13+36
        POP      {R4-R11,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock25
//  375 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon0
        CFI NoFunction
        THUMB
??WriteMultipleCoils??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock26
        REQUIRE ??WriteMultipleCoils

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock27 Using cfiCommon1
        CFI Function ??WriteMultipleCoils
        ARM
//  376 int ModbusPro::WriteMultipleCoils(TSNUart *Port, unsigned SlaveAddress, unsigned Address, unsigned NumberOfCoils, U8 Value[], int Delay1, int Delay2)
//  377 {
??WriteMultipleCoils:
        PUSH     {R0,R1,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+44
        SUB      SP,SP,#+256
        CFI CFA R13+300
        MOVS     R4,R2
        MOVS     R5,R3
        LDR      R6,[SP, #+300]
        LDR      R7,[SP, #+304]
        LDR      R8,[SP, #+308]
//  378 	if ( Address > 0 ) Address--;
        CMP      R4,#+0
        BEQ      ??WriteMultipleCoils_1
        SUBS     R4,R4,#+1
//  379 
//  380 	int Status;
//  381 
//  382 	unsigned NumberOfBytes= NumberOfCoils/8;
??WriteMultipleCoils_1:
        LSRS     R0,R5,#+3
        MOVS     R10,R0
//  383 	if ( NumberOfCoils % 8) {
        ANDS     R0,R5,#0x7       ;; Zero extend
        CMP      R0,#+0
        BEQ      ??WriteMultipleCoils_2
//  384 		NumberOfBytes++;
        ADDS     R10,R10,#+1
//  385 	}
//  386 	// Not that the Packet contains 3 times 0x0 to make space for CRC
//  387 	U8 Packet[MAX_QUERY_LENGTH]={
//  388 		SlaveAddress,
//  389 		MBUS_CMD_WRITE_MULTIPLE_COILS,
//  390 		Address >> 8,
//  391 		Address & 0x00FF,
//  392 		NumberOfCoils >> 8,
//  393 		NumberOfCoils & 0x00FF,
//  394 		NumberOfBytes
//  395 	};
??WriteMultipleCoils_2:
        MOVS     R0,SP
        LDR      R1,??WriteMultipleCoils_3  ;; `?<Constant {(unsigned char __data)'\\000', (uns`
        MOV      R3,#+256
??WriteMultipleCoils_4:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??WriteMultipleCoils_4
        LDR      R1,[SP, #+260]
        STRB     R1,[SP, #+0]
        LSRS     R1,R4,#+8
        STRB     R1,[SP, #+2]
        STRB     R4,[SP, #+3]
        LSRS     R1,R5,#+8
        STRB     R1,[SP, #+4]
        STRB     R5,[SP, #+5]
        STRB     R10,[SP, #+6]
//  396 	memcpy(&Packet[REQUEST_MULTIPLE_SIZE],Value,NumberOfBytes);
        MOVS     R2,R10
        MOVS     R1,R6
        ADD      R0,SP,#+7
        _BLF     memcpy,??memcpy??rA
//  397 	int Length = REQUEST_MULTIPLE_SIZE+NumberOfBytes;
        ADDS     R0,R10,#+7
        MOVS     R11,R0
//  398 	if ( Send_Query(Port, Packet, Length ) ) {
        MOVS     R2,R11
        MOVS     R1,SP
        LDR      R0,[SP, #+256]
        BL       ??Send_Query
        CMP      R0,#+0
        BEQ      ??WriteMultipleCoils_5
//  399 		Status = Preset_Response(Port, Packet, Length,Delay1,Delay2);
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+304
        MOVS     R0,R8
        PUSH     {R0}
        CFI CFA R13+308
        MOVS     R3,R7
        MOVS     R2,R11
        ADD      R1,SP,#+8
        LDR      R0,[SP, #+264]
        BL       ??Preset_Response
        ADD      SP,SP,#+8        ;; stack cleaning
        CFI CFA R13+300
        MOVS     R9,R0
        B        ??WriteMultipleCoils_6
//  400 	} else {
//  401 		Status = PORT_FAILURE;
??WriteMultipleCoils_5:
        MVN      R0,#+10
        MOVS     R9,R0
//  402 	}
//  403 
//  404 	return( Status );
??WriteMultipleCoils_6:
        MOVS     R0,R9
        ADD      SP,SP,#+264      ;; stack cleaning
        CFI CFA R13+36
        POP      {R4-R11,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??WriteMultipleCoils_3:
        DC32     `?<Constant {(unsigned char __data)'\\000', (uns`
        CFI EndBlock cfiBlock27
//  405 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock28 Using cfiCommon0
        CFI NoFunction
        THUMB
??WriteMultipleRegisters??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock28
        REQUIRE ??WriteMultipleRegisters
//  406 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock29 Using cfiCommon1
        CFI Function ??WriteMultipleRegisters
        ARM
//  407 int ModbusPro::WriteMultipleRegisters(TSNUart *Port, unsigned SlaveAddress, unsigned Address, unsigned NumberOfRegisters, U8 Value[], int Delay1, int Delay2)
//  408 {
??WriteMultipleRegisters:
        PUSH     {R0,R1,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+44
        SUB      SP,SP,#+256
        CFI CFA R13+300
        MOVS     R4,R2
        MOVS     R5,R3
        LDR      R6,[SP, #+300]
        LDR      R7,[SP, #+304]
        LDR      R8,[SP, #+308]
//  409 	if ( Address > 0 ) Address--;
        CMP      R4,#+0
        BEQ      ??WriteMultipleRegisters_1
        SUBS     R4,R4,#+1
//  410 	int Status;
//  411 
//  412 	unsigned Size = NumberOfRegisters*2;
??WriteMultipleRegisters_1:
        MOV      R0,#+2
        MULS     R1,R0,R5
        MOVS     R10,R1
//  413 	// Not that the Packet contains 3 times 0x0 to make space for CRC
//  414 	U8 Packet[MAX_QUERY_LENGTH]={
//  415 		SlaveAddress,
//  416 		MBUS_CMD_WRITE_MULTIPLE_REGISTERS,
//  417 		Address >> 8,
//  418 		Address & 0x00FF,
//  419 		NumberOfRegisters >> 8,
//  420 		NumberOfRegisters & 0x00FF,
//  421 		Size,
//  422 	};
        MOVS     R0,SP
        LDR      R1,??WriteMultipleRegisters_2  ;; `?<Constant {(unsigned char __data)'\\000', (uns_1`
        MOV      R3,#+256
??WriteMultipleRegisters_3:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??WriteMultipleRegisters_3
        LDR      R1,[SP, #+260]
        STRB     R1,[SP, #+0]
        LSRS     R1,R4,#+8
        STRB     R1,[SP, #+2]
        STRB     R4,[SP, #+3]
        LSRS     R1,R5,#+8
        STRB     R1,[SP, #+4]
        STRB     R5,[SP, #+5]
        STRB     R10,[SP, #+6]
//  423 	memcpy(&Packet[REQUEST_MULTIPLE_SIZE],Value,Size);
        MOVS     R2,R10
        MOVS     R1,R6
        ADD      R0,SP,#+7
        _BLF     memcpy,??memcpy??rA
//  424 	int Length = REQUEST_MULTIPLE_SIZE+Size;
        ADDS     R0,R10,#+7
        MOVS     R11,R0
//  425 	if ( Send_Query(Port, Packet, Length ) ) {
        MOVS     R2,R11
        MOVS     R1,SP
        LDR      R0,[SP, #+256]
        BL       ??Send_Query
        CMP      R0,#+0
        BEQ      ??WriteMultipleRegisters_4
//  426 		Status = Preset_Response(Port, Packet, Length,Delay1,Delay2);
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+304
        MOVS     R0,R8
        PUSH     {R0}
        CFI CFA R13+308
        MOVS     R3,R7
        MOVS     R2,R11
        ADD      R1,SP,#+8
        LDR      R0,[SP, #+264]
        BL       ??Preset_Response
        ADD      SP,SP,#+8        ;; stack cleaning
        CFI CFA R13+300
        MOVS     R9,R0
        B        ??WriteMultipleRegisters_5
//  427 	} else {
//  428 		Status = PORT_FAILURE;
??WriteMultipleRegisters_4:
        MVN      R0,#+10
        MOVS     R9,R0
//  429 	}
//  430 
//  431 	return( Status );
??WriteMultipleRegisters_5:
        MOVS     R0,R9
        ADD      SP,SP,#+264      ;; stack cleaning
        CFI CFA R13+36
        POP      {R4-R11,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??WriteMultipleRegisters_2:
        DC32     `?<Constant {(unsigned char __data)'\\000', (uns_1`
        CFI EndBlock cfiBlock29
//  432 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock30 Using cfiCommon0
        CFI NoFunction
        THUMB
??Get_Single??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock30
        REQUIRE ??Get_Single
//  433 
//  434 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock31 Using cfiCommon1
        CFI Function ??Get_Single
        ARM
//  435 int ModbusPro::Get_Single(TSNUart *Port, unsigned Function, unsigned SlaveAddress, unsigned Address, unsigned NumberOfPoints, U8 *ReplyPtr, int Delay1, int Delay2)
//  436 {
??Get_Single:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
        LDR      R8,[SP, #+36]
        LDR      R9,[SP, #+40]
        LDR      R10,[SP, #+44]
        LDR      R11,[SP, #+48]
//  437 	return Get_Multiple(Port,Function,SlaveAddress,Address,1,ReplyPtr,Delay1,Delay2);
        MOVS     R0,R11
        PUSH     {R0}
        CFI CFA R13+40
        MOVS     R0,R10
        PUSH     {R0}
        CFI CFA R13+44
        MOVS     R0,R9
        PUSH     {R0}
        CFI CFA R13+48
        MOV      R0,#+1
        PUSH     {R0}
        CFI CFA R13+52
        MOVS     R3,R7
        MOVS     R2,R6
        MOVS     R1,R5
        MOVS     R0,R4
        BL       ??Get_Multiple
        ADD      SP,SP,#+16       ;; stack cleaning
        CFI CFA R13+36
        POP      {R4-R11,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock31
//  438 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock32 Using cfiCommon0
        CFI NoFunction
        THUMB
??Get_Multiple??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock32
        REQUIRE ??Get_Multiple
//  439 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock33 Using cfiCommon1
        CFI Function ??Get_Multiple
        ARM
//  440 int ModbusPro::Get_Multiple(TSNUart *Port, unsigned Function, unsigned SlaveAddress, unsigned Address, unsigned NumberOfPoints, U8 *ReplyPtr,int Delay1, int Delay2)
//  441 {
??Get_Multiple:
        PUSH     {R1,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
        SUB      SP,SP,#+12
        CFI CFA R13+52
        SUB      SP,SP,#+1024
        CFI CFA R13+1076
        MOVS     R4,R0
        MOVS     R5,R2
        MOVS     R6,R3
        LDR      R7,[SP, #+1076]
        LDR      R8,[SP, #+1080]
        LDR      R9,[SP, #+1084]
        LDR      R10,[SP, #+1088]
//  442 
//  443 	// Not that the Packet contains 3 times 0x0 to make space for CRC
//  444 	if ( Address > 0 ) --Address;
        CMP      R6,#+0
        BEQ      ??Get_Multiple_1
        SUBS     R6,R6,#+1
//  445 	U8 Packet[REQUEST_QUERY_SIZE+CHECKSUM_SIZE+1]={
??Get_Multiple_1:
        STRB     R5,[SP, #+0]
        LDR      R1,[SP, #+1036]
        STRB     R1,[SP, #+1]
        LSRS     R1,R6,#+8
        STRB     R1,[SP, #+2]
        STRB     R6,[SP, #+3]
        LSRS     R1,R7,#+8
        STRB     R1,[SP, #+4]
        STRB     R7,[SP, #+5]
//  446 		SlaveAddress,
//  447 		Function,
//  448 		Address >> 8,
//  449 		Address & 0xFF,
//  450 		NumberOfPoints >> 8,
//  451 		NumberOfPoints & 0xff ,
//  452 	};
//  453 
//  454 	int Status;
//  455 	if ( Send_Query(Port, Packet, REQUEST_QUERY_SIZE ) ) {
        MOV      R2,#+6
        MOVS     R1,SP
        MOVS     R0,R4
        BL       ??Send_Query
        CMP      R0,#+0
        BEQ      ??Get_Multiple_2
//  456 		U8 tmpReplyData[MAX_RESPONSE_LENGTH];
//  457 		Status = Preset_Response(Port, Packet,REQUEST_QUERY_SIZE ,Delay1,Delay2,tmpReplyData );
        ADD      R0,SP,#+12
        PUSH     {R0}
        CFI CFA R13+1080
        MOVS     R0,R10
        PUSH     {R0}
        CFI CFA R13+1084
        MOVS     R3,R9
        MOV      R2,#+6
        ADD      R1,SP,#+8
        MOVS     R0,R4
        BL       ??Preset_Response
        ADD      SP,SP,#+8        ;; stack cleaning
        CFI CFA R13+1076
        MOVS     R11,R0
//  458 		if ( Status >= 6 && tmpReplyData[MODBUS_INDEX_SLAVE_ADDRESS] == (U8)SlaveAddress ) {
        CMP      R11,#+6
        BLT      ??Get_Multiple_3
        LDRB     R0,[SP, #+12]
        MOVS     R1,R5
        ANDS     R1,R1,#0xFF      ;; Zero extend
        CMP      R0,R1
        BNE      ??Get_Multiple_3
//  459 			switch ( tmpReplyData[MODBUS_INDEX_COMMAND] ) {
        LDRB     R0,[SP, #+13]
        CMP      R0,#+1
        BEQ      ??Get_Multiple_4
        CMP      R0,#+4
        BEQ      ??Get_Multiple_5
        B        ??Get_Multiple_3
//  460 				case MBUS_CMD_READ_COIL_STATUS:
//  461 					memcpy(ReplyPtr,&tmpReplyData[MODBUS_INDEX_DATA_START],tmpReplyData[MODBUS_INDEX_BYTE_CNT]);
??Get_Multiple_4:
        LDRB     R2,[SP, #+14]
        ADD      R1,SP,#+15
        MOVS     R0,R8
        _BLF     memcpy,??memcpy??rA
        B        ??Get_Multiple_3
//  462 					break;
//  463 				case MBUS_CMD_READ_INPUT_REGISTER:
//  464 					memcpy(ReplyPtr,&tmpReplyData[MODBUS_INDEX_DATA_START],tmpReplyData[MODBUS_INDEX_BYTE_CNT]);
??Get_Multiple_5:
        LDRB     R2,[SP, #+14]
        ADD      R1,SP,#+15
        MOVS     R0,R8
        _BLF     memcpy,??memcpy??rA
        B        ??Get_Multiple_3
//  465 					break;
//  466 				default:
//  467 					break;
//  468 			}
//  469 		}
//  470 	} else {
//  471 		Status = PORT_FAILURE;
??Get_Multiple_2:
        MVN      R0,#+10
        MOVS     R11,R0
//  472 	}
//  473 	return( Status );
??Get_Multiple_3:
        MOVS     R0,R11
        ADD      SP,SP,#+1040     ;; stack cleaning
        CFI CFA R13+36
        POP      {R4-R11,LR}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock33
//  474 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock34 Using cfiCommon1
        CFI NoFunction
        ARM
`??operator new??rA`:
        LDR      R12,??Subroutine17_0  ;; `??operator new`
        BX       R12
        DATA
??Subroutine17_0:
        DC32     `??operator new`
        CFI EndBlock cfiBlock34

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock35 Using cfiCommon1
        CFI NoFunction
        ARM
??memcpy??rA:
        LDR      R12,??Subroutine18_0  ;; memcpy
        BX       R12
        DATA
??Subroutine18_0:
        DC32     memcpy
        CFI EndBlock cfiBlock35

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for auchCRCHi>`:
        DATA
        DC8 0, 193, 129, 64, 1, 192, 128, 65, 1, 192, 128, 65, 0, 193, 129, 64
        DC8 1, 192, 128, 65, 0, 193, 129, 64, 0, 193, 129, 64, 1, 192, 128, 65
        DC8 1, 192, 128, 65, 0, 193, 129, 64, 0, 193, 129, 64, 1, 192, 128, 65
        DC8 0, 193, 129, 64, 1, 192, 128, 65, 1, 192, 128, 65, 0, 193, 129, 64
        DC8 1, 192, 128, 65, 0, 193, 129, 64, 0, 193, 129, 64, 1, 192, 128, 65
        DC8 0, 193, 129, 64, 1, 192, 128, 65, 1, 192, 128, 65, 0, 193, 129, 64
        DC8 0, 193, 129, 64, 1, 192, 128, 65, 1, 192, 128, 65, 0, 193, 129, 64
        DC8 1, 192, 128, 65, 0, 193, 129, 64, 0, 193, 129, 64, 1, 192, 128, 65
        DC8 1, 192, 128, 65, 0, 193, 129, 64, 0, 193, 129, 64, 1, 192, 128, 65
        DC8 0, 193, 129, 64, 1, 192, 128, 65, 1, 192, 128, 65, 0, 193, 129, 64
        DC8 0, 193, 129, 64, 1, 192, 128, 65, 1, 192, 128, 65, 0, 193, 129, 64
        DC8 1, 192, 128, 65, 0, 193, 129, 64, 0, 193, 129, 64, 1, 192, 128, 65
        DC8 0, 193, 129, 64, 1, 192, 128, 65, 1, 192, 128, 65, 0, 193, 129, 64
        DC8 1, 192, 128, 65, 0, 193, 129, 64, 0, 193, 129, 64, 1, 192, 128, 65
        DC8 1, 192, 128, 65, 0, 193, 129, 64, 0, 193, 129, 64, 1, 192, 128, 65
        DC8 0, 193, 129, 64, 1, 192, 128, 65, 1, 192, 128, 65, 0, 193, 129, 64

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for auchCRCLo>`:
        DATA
        DC8 0, 192, 193, 1, 195, 3, 2, 194, 198, 6, 7, 199, 5, 197, 196, 4, 204
        DC8 12, 13, 205, 15, 207, 206, 14, 10, 202, 203, 11, 201, 9, 8, 200
        DC8 216, 24, 25, 217, 27, 219, 218, 26, 30, 222, 223, 31, 221, 29, 28
        DC8 220, 20, 212, 213, 21, 215, 23, 22, 214, 210, 18, 19, 211, 17, 209
        DC8 208, 16, 240, 48, 49, 241, 51, 243, 242, 50, 54, 246, 247, 55, 245
        DC8 53, 52, 244, 60, 252, 253, 61, 255, 63, 62, 254, 250, 58, 59, 251
        DC8 57, 249, 248, 56, 40, 232, 233, 41, 235, 43, 42, 234, 238, 46, 47
        DC8 239, 45, 237, 236, 44, 228, 36, 37, 229, 39, 231, 230, 38, 34, 226
        DC8 227, 35, 225, 33, 32, 224, 160, 96, 97, 161, 99, 163, 162, 98, 102
        DC8 166, 167, 103, 165, 101, 100, 164, 108, 172, 173, 109, 175, 111
        DC8 110, 174, 170, 106, 107, 171, 105, 169, 168, 104, 120, 184, 185
        DC8 121, 187, 123, 122, 186, 190, 126, 127, 191, 125, 189, 188, 124
        DC8 180, 116, 117, 181, 119, 183, 182, 118, 114, 178, 179, 115, 177
        DC8 113, 112, 176, 80, 144, 145, 81, 147, 83, 82, 146, 150, 86, 87, 151
        DC8 85, 149, 148, 84, 156, 92, 93, 157, 95, 159, 158, 94, 90, 154, 155
        DC8 91, 153, 89, 88, 152, 136, 72, 73, 137, 75, 139, 138, 74, 78, 142
        DC8 143, 79, 141, 77, 76, 140, 68, 132, 133, 69, 135, 71, 70, 134, 130
        DC8 66, 67, 131, 65, 129, 128, 64

        RSEG DIFUNCT:CODE:ROOT(2)
        REQUIRE ?call_ctors
        DC32    ??__sti__routine

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant {(unsigned char __data)'\\000', (uns`:
        DATA
        DC8 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant {(unsigned char __data)'\\000', (uns_1`:
        DATA
        DC8 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        END
//  475 
//  476 
// 
// 2 656 bytes in segment CODE
//   512 bytes in segment DATA_C
//   512 bytes in segment DATA_I
//   512 bytes in segment DATA_ID
//   192 bytes in segment DATA_Z
//     4 bytes in segment DIFUNCT
//    24 bytes in segment INITTAB
// 
// 2 568 bytes of CODE  memory (+ 116 bytes shared)
// 1 024 bytes of CONST memory
//   704 bytes of DATA  memory
//
//Errors: none
//Warnings: none
