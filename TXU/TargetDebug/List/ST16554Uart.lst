##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               19/Jan/2017  10:13:08 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\src\ST16554Uart.cpp                    #
#    Command line    =  D:\S2Prog\TXU\src\ST16554Uart.cpp --fpu None -D      #
#                       OS_LIBMODE_DP -D OS_RAMVECT=0 -D CPU_S3C2410 -D      #
#                       OS_UART=1 -D ANBOOTLOADER -D __ARM_LIBRARY__ -lCN    #
#                       D:\S2Prog\TXU\TargetDebug\List\ -o                   #
#                       D:\S2Prog\TXU\TargetDebug\Obj\ -s2 --no_cse          #
#                       --no_unroll --no_inline --no_code_motion --no_tbaa   #
#                       --no_clustering --no_scheduling --debug --cpu_mode   #
#                       arm --endian little --cpu ARM920T --stack_align 4    #
#                       --interwork -e --eec++ --dlib_config "C:\Program     #
#                       Files (x86)\IAR Systems\Embedded Workbench           #
#                       4.0\arm\LIB\dl4tpainl8f.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\MINILZO.108\ -I          #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\INC\"                              #
#    List file       =  D:\S2Prog\TXU\TargetDebug\List\ST16554Uart.lst       #
#    Object file     =  D:\S2Prog\TXU\TargetDebug\Obj\ST16554Uart.r79        #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\src\ST16554Uart.cpp
      1          #include <string.h>
      2          #include <ctype.h>

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __intrinsic __code __interwork __atpcs void *malloc(size_t)
   \                     malloc:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0400B0E1           MOVS     R0,R4
   \   0000000C   ........           _BLF     __data_malloc,??__data_malloc??rA
   \   00000010   1040BDE8           POP      {R4,LR}
   \   00000014   1EFF2FE1           BX       LR               ;; return
      3          #include <stdlib.h>
      4          
      5          #include "def.h"
      6          
      7          #include "2410addr.h"
      8          #include "2410lib.h"
      9          #include "2410slib.h"
     10          #include "rtos.h"
     11          #include "TSNDefines.h"
     12          #include "TSNConstants.h"
     13          #include "ANSIString.h"
     14          #include "TSNConfigString.h"
     15          #include "TsnUart.h"
     16          #include "ST16554Uart.h"
     17          #ifndef MIN
     18          #define MIN(a, b) (((a) < (b)) ? (a) : (b))
     19          #endif
     20          
     21          

   \                                 In segment CODE, align 4, keep-with-next
     22          ST165540Uart::ST165540Uart(int PortNum,unsigned BdRate,unsigned WrdLength,unsigned StpBits,char Prty, unsigned BufSize, int Dev, int HWProt,int SWProt, bool IsMstr,int MaxTimeChar,bool Relax, int LogP, int LogE):
   \                     ??ST165540Uart:
   \   00000000   FE4F2DE9           PUSH     {R1-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040B0E1           MOVS     R4,R0
   \   0000000C   48509DE5           LDR      R5,[SP, #+72]
   \   00000010   54609DE5           LDR      R6,[SP, #+84]
   \   00000014   5870DDE5           LDRB     R7,[SP, #+88]
   \   00000018   5C809DE5           LDR      R8,[SP, #+92]
   \   0000001C   6090DDE5           LDRB     R9,[SP, #+96]
   \   00000020   64A09DE5           LDR      R10,[SP, #+100]
   \   00000024   68B09DE5           LDR      R11,[SP, #+104]
     23          TSNUart(PortNum,BdRate,WrdLength, StpBits, Prty, BufSize, Dev, HWProt,SWProt, IsMstr,MaxTimeChar, Relax, LogP, LogE),
     24          FIFOInstalled(Unknown)
     25          {
   \   00000028   0B00B0E1           MOVS     R0,R11
   \   0000002C   01002DE9           PUSH     {R0}
   \   00000030   0A00B0E1           MOVS     R0,R10
   \   00000034   01002DE9           PUSH     {R0}
   \   00000038   0900B0E1           MOVS     R0,R9
   \   0000003C   01002DE9           PUSH     {R0}
   \   00000040   0800B0E1           MOVS     R0,R8
   \   00000044   01002DE9           PUSH     {R0}
   \   00000048   0700B0E1           MOVS     R0,R7
   \   0000004C   01002DE9           PUSH     {R0}
   \   00000050   0600B0E1           MOVS     R0,R6
   \   00000054   01002DE9           PUSH     {R0}
   \   00000058   68009DE5           LDR      R0,[SP, #+104]
   \   0000005C   01002DE9           PUSH     {R0}
   \   00000060   68009DE5           LDR      R0,[SP, #+104]
   \   00000064   01002DE9           PUSH     {R0}
   \   00000068   0500B0E1           MOVS     R0,R5
   \   0000006C   01002DE9           PUSH     {R0}
   \   00000070   6800DDE5           LDRB     R0,[SP, #+104]
   \   00000074   01002DE9           PUSH     {R0}
   \   00000078   68009DE5           LDR      R0,[SP, #+104]
   \   0000007C   01002DE9           PUSH     {R0}
   \   00000080   44309DE5           LDR      R3,[SP, #+68]
   \   00000084   40209DE5           LDR      R2,[SP, #+64]
   \   00000088   3C109DE5           LDR      R1,[SP, #+60]
   \   0000008C   0400B0E1           MOVS     R0,R4
   \   00000090   ........           _BLF     ??TSNUart,??TSNUart??rA
   \   00000094   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   00000098   80019FE5           LDR      R0,??ST165540Uart_1  ;; ??__vtbl
   \   0000009C   E40084E5           STR      R0,[R4, #+228]
   \   000000A0   0000A0E3           MOV      R0,#+0
   \   000000A4   E800C4E5           STRB     R0,[R4, #+232]
     26          	LastTxTime = 0;
   \   000000A8   0000A0E3           MOV      R0,#+0
   \   000000AC   F00084E5           STR      R0,[R4, #+240]
     27          	OS_CREATERSEMA(&TxSema);
   \   000000B0   740094E2           ADDS     R0,R4,#+116
   \   000000B4   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
     28          
     29          	Channels[PortNumber] = this;
   \   000000B8   880094E5           LDR      R0,[R4, #+136]
   \   000000BC   0410A0E3           MOV      R1,#+4
   \   000000C0   5C219FE5           LDR      R2,??ST165540Uart_1+0x4  ;; ??Channels
   \   000000C4   912020E0           MLA      R0,R1,R0,R2
   \   000000C8   004080E5           STR      R4,[R0, #+0]
     30          
     31          	RxBufPtr=(U8*)malloc(BufSize);
   \   000000CC   0500B0E1           MOVS     R0,R5
   \   000000D0   ........           _BLF     malloc,??malloc??rA
   \   000000D4   280084E5           STR      R0,[R4, #+40]
     32          	OS_CreateMB(&RxBuf,1,BufSize,(char*)RxBufPtr);
   \   000000D8   283094E5           LDR      R3,[R4, #+40]
   \   000000DC   0520B0E1           MOVS     R2,R5
   \   000000E0   0110A0E3           MOV      R1,#+1
   \   000000E4   0400B0E1           MOVS     R0,R4
   \   000000E8   ........           _BLF     OS_CreateMB,??OS_CreateMB??rA
     33          
     34          	U8 *BasePtr[] = {rEXT_UART0,rEXT_UART1,rEXT_UART2,rEXT_UART3};
   \   000000EC   0D00B0E1           MOVS     R0,SP
   \   000000F0   30119FE5           LDR      R1,??ST165540Uart_1+0x8  ;; `?<Constant {(unsigned char *)134217728, (unsig`
   \   000000F4   002091E5           LDR      R2,[R1, #0]
   \   000000F8   002080E5           STR      R2,[R0, #+0]
   \   000000FC   042091E5           LDR      R2,[R1, #+4]
   \   00000100   042080E5           STR      R2,[R0, #+4]
   \   00000104   082091E5           LDR      R2,[R1, #+8]
   \   00000108   082080E5           STR      R2,[R0, #+8]
   \   0000010C   0C2091E5           LDR      R2,[R1, #+12]
   \   00000110   0C2080E5           STR      R2,[R0, #+12]
     35          	UartBase = BasePtr[PortNumber-FIRST_ST16554_PORT];
   \   00000114   880094E5           LDR      R0,[R4, #+136]
   \   00000118   0410A0E3           MOV      R1,#+4
   \   0000011C   0D20B0E1           MOVS     R2,SP
   \   00000120   912020E0           MLA      R0,R1,R0,R2
   \   00000124   0C0010E5           LDR      R0,[R0, #-12]
   \   00000128   EC0084E5           STR      R0,[R4, #+236]
     36          
     37          
     38          	switch ( toupper(Parity) ) {
   \   0000012C   C800D4E5           LDRB     R0,[R4, #+200]
   \   00000130   ........           _BLF     toupper,??toupper??rA
   \   00000134   450050E3           CMP      R0,#+69
   \   00000138   0200000A           BEQ      ??ST165540Uart_2
   \   0000013C   4F0050E3           CMP      R0,#+79
   \   00000140   0300000A           BEQ      ??ST165540Uart_3
   \   00000144   050000EA           B        ??ST165540Uart_4
     39          	case 'E':
     40          		ParityValue = 0x18;
   \                     ??ST165540Uart_2:
   \   00000148   1800A0E3           MOV      R0,#+24
   \   0000014C   C900C4E5           STRB     R0,[R4, #+201]
   \   00000150   040000EA           B        ??ST165540Uart_5
     41          		break;
     42          	case 'O':
     43          		ParityValue = 0x08;
   \                     ??ST165540Uart_3:
   \   00000154   0800A0E3           MOV      R0,#+8
   \   00000158   C900C4E5           STRB     R0,[R4, #+201]
   \   0000015C   010000EA           B        ??ST165540Uart_5
     44          		break;
     45          	default:
     46          	case 'N':
     47          		ParityValue = 0x00;
   \                     ??ST165540Uart_4:
   \   00000160   0000A0E3           MOV      R0,#+0
   \   00000164   C900C4E5           STRB     R0,[R4, #+201]
     48          		break;
     49          	}
     50          	UartBase[IER] = 0;
   \                     ??ST165540Uart_5:
   \   00000168   EC0094E5           LDR      R0,[R4, #+236]
   \   0000016C   0010A0E3           MOV      R1,#+0
   \   00000170   0110C0E5           STRB     R1,[R0, #+1]
     51          	UartBase[LCR] = 0x80;
   \   00000174   EC0094E5           LDR      R0,[R4, #+236]
   \   00000178   8010A0E3           MOV      R1,#+128
   \   0000017C   0310C0E5           STRB     R1,[R0, #+3]
     52          	UartBase[DLL] = (XTAL_UART / 16 / BaudRate ) & 0xff;
   \   00000180   EC2094E5           LDR      R2,[R4, #+236]
   \   00000184   E10BA0E3           MOV      R0,#+230400
   \   00000188   B41094E5           LDR      R1,[R4, #+180]
   \   0000018C   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000190   0010C2E5           STRB     R1,[R2, #+0]
     53          	UartBase[DLM] = ((XTAL_UART  / 16 / BaudRate )>> 8) & 0xff;
   \   00000194   EC2094E5           LDR      R2,[R4, #+236]
   \   00000198   E10BA0E3           MOV      R0,#+230400
   \   0000019C   B41094E5           LDR      R1,[R4, #+180]
   \   000001A0   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   000001A4   2104B0E1           LSRS     R0,R1,#+8
   \   000001A8   0100C2E5           STRB     R0,[R2, #+1]
     54          	UartBase[LCR] = (WordLength-5) + ((StopBits-1) << 2) + ParityValue;
   \   000001AC   EC0094E5           LDR      R0,[R4, #+236]
   \   000001B0   B81094E5           LDR      R1,[R4, #+184]
   \   000001B4   BC2094E5           LDR      R2,[R4, #+188]
   \   000001B8   021191E0           ADDS     R1,R1,R2, LSL #+2
   \   000001BC   C920D4E5           LDRB     R2,[R4, #+201]
   \   000001C0   011092E0           ADDS     R1,R2,R1
   \   000001C4   F71091E2           ADDS     R1,R1,#+247
   \   000001C8   0310C0E5           STRB     R1,[R0, #+3]
     55          	switch ( SWProt ) {
   \   000001CC   0600B0E1           MOVS     R0,R6
   \   000001D0   5810A0E3           MOV      R1,#+88
   \   000001D4   7C1D81E3           ORR      R1,R1,#0x1F00
   \   000001D8   010050E1           CMP      R0,R1
   \   000001DC   0300001A           BNE      ??ST165540Uart_6
     56          	case C_UART_SWPRO_MODBUS:
     57          		EnableFIFO(0);
   \                     ??ST165540Uart_7:
   \   000001E0   0010A0E3           MOV      R1,#+0
   \   000001E4   0400B0E1           MOVS     R0,R4
   \   000001E8   ........           BL       ??EnableFIFO
   \   000001EC   020000EA           B        ??ST165540Uart_8
     58          		break;
     59          	default:
     60          		EnableFIFO(8);
   \                     ??ST165540Uart_6:
   \   000001F0   0810A0E3           MOV      R1,#+8
   \   000001F4   0400B0E1           MOVS     R0,R4
   \   000001F8   ........           BL       ??EnableFIFO
     61          		break;
     62          	}
     63          	EnableInt();
   \                     ??ST165540Uart_8:
   \   000001FC   E41094E5           LDR      R1,[R4, #+228]
   \   00000200   0400B0E1           MOVS     R0,R4
   \   00000204   001091E5           LDR      R1,[R1, #+0]
   \   00000208   0FE0A0E1           MOV      LR,PC
   \   0000020C   11FF2FE1           BX       R1
     64          
     65          }
   \   00000210   0400B0E1           MOVS     R0,R4
   \   00000214   1CD08DE2           ADD      SP,SP,#+28       ;; stack cleaning
   \   00000218   F04FBDE8           POP      {R4-R11,LR}
   \   0000021C   1EFF2FE1           BX       LR               ;; return
   \                     ??ST165540Uart_1:
   \   00000220   ........           DC32     ??__vtbl
   \   00000224   ........           DC32     ??Channels
   \   00000228   ........           DC32     `?<Constant {(unsigned char *)134217728, (unsig`
     66          

   \                                 In segment CODE, align 4, keep-with-next
     67          void ST165540Uart::EnableInt(void)
     68          {
     69          	switch ( PortNumber-FIRST_ST16554_PORT ) {
   \                     ??EnableInt:
   \   00000000   881090E5           LDR      R1,[R0, #+136]
   \   00000004   031051E2           SUBS     R1,R1,#+3
   \   00000008   000051E3           CMP      R1,#+0
   \   0000000C   0600000A           BEQ      ??EnableInt_1
   \   00000010   010051E3           CMP      R1,#+1
   \   00000014   0C00000A           BEQ      ??EnableInt_2
   \   00000018   020051E3           CMP      R1,#+2
   \   0000001C   1200000A           BEQ      ??EnableInt_3
   \   00000020   030051E3           CMP      R1,#+3
   \   00000024   1800000A           BEQ      ??EnableInt_4
   \   00000028   1E0000EA           B        ??EnableInt_5
     70          	case 0:
     71          		rINTMSK    &= ~BIT_EINT0;
   \                     ??EnableInt_1:
   \   0000002C   0810A0E3           MOV      R1,#+8
   \   00000030   4A1481E3           ORR      R1,R1,#0x4A000000
   \   00000034   0820A0E3           MOV      R2,#+8
   \   00000038   4A2482E3           ORR      R2,R2,#0x4A000000
   \   0000003C   002092E5           LDR      R2,[R2, #+0]
   \   00000040   0120D2E3           BICS     R2,R2,#0x1
   \   00000044   002081E5           STR      R2,[R1, #+0]
   \   00000048   160000EA           B        ??EnableInt_5
     72          		break;
     73          	case 1:
     74          		rINTMSK    &= ~BIT_EINT1;
   \                     ??EnableInt_2:
   \   0000004C   0810A0E3           MOV      R1,#+8
   \   00000050   4A1481E3           ORR      R1,R1,#0x4A000000
   \   00000054   0820A0E3           MOV      R2,#+8
   \   00000058   4A2482E3           ORR      R2,R2,#0x4A000000
   \   0000005C   002092E5           LDR      R2,[R2, #+0]
   \   00000060   0220D2E3           BICS     R2,R2,#0x2
   \   00000064   002081E5           STR      R2,[R1, #+0]
   \   00000068   0E0000EA           B        ??EnableInt_5
     75          		break;
     76          	case 2:
     77          		rINTMSK    &= ~BIT_EINT2;
   \                     ??EnableInt_3:
   \   0000006C   0810A0E3           MOV      R1,#+8
   \   00000070   4A1481E3           ORR      R1,R1,#0x4A000000
   \   00000074   0820A0E3           MOV      R2,#+8
   \   00000078   4A2482E3           ORR      R2,R2,#0x4A000000
   \   0000007C   002092E5           LDR      R2,[R2, #+0]
   \   00000080   0420D2E3           BICS     R2,R2,#0x4
   \   00000084   002081E5           STR      R2,[R1, #+0]
   \   00000088   060000EA           B        ??EnableInt_5
     78          		break;
     79          	case 3:
     80          		rINTMSK    &= ~BIT_EINT3;
   \                     ??EnableInt_4:
   \   0000008C   0810A0E3           MOV      R1,#+8
   \   00000090   4A1481E3           ORR      R1,R1,#0x4A000000
   \   00000094   0820A0E3           MOV      R2,#+8
   \   00000098   4A2482E3           ORR      R2,R2,#0x4A000000
   \   0000009C   002092E5           LDR      R2,[R2, #+0]
   \   000000A0   0820D2E3           BICS     R2,R2,#0x8
   \   000000A4   002081E5           STR      R2,[R1, #+0]
     81          		break;
     82          	default:
     83          		break;
     84          	}
     85          	UartBase[MCR] = MCR_OUT2;	// Enable interrupt
   \                     ??EnableInt_5:
   \   000000A8   EC1090E5           LDR      R1,[R0, #+236]
   \   000000AC   0820A0E3           MOV      R2,#+8
   \   000000B0   0420C1E5           STRB     R2,[R1, #+4]
     86          	UartBase[IER] = IER_TBE | IER_RXRDY;
   \   000000B4   EC1090E5           LDR      R1,[R0, #+236]
   \   000000B8   0320A0E3           MOV      R2,#+3
   \   000000BC   0120C1E5           STRB     R2,[R1, #+1]
     87          }
   \   000000C0   1EFF2FE1           BX       LR               ;; return
     88          
     89          /******************************************************************************
     90          *
     91          *   Tsn16550PhysicalHasFIFO
     92          */
     93          
     94          

   \                                 In segment CODE, align 4, keep-with-next
     95          FIFOStatus ST165540Uart::PhysicalHasFIFO(void)
     96          {
   \                     ??PhysicalHasFIFO:
   \   00000000   0010B0E1           MOVS     R1,R0
     97          	if ( (UartBase[FCR] & 0x30) == 0 ) {
   \   00000004   EC0091E5           LDR      R0,[R1, #+236]
   \   00000008   0200D0E5           LDRB     R0,[R0, #+2]
   \   0000000C   300010E3           TST      R0,#0x30
   \   00000010   1200001A           BNE      ??PhysicalHasFIFO_1
     98          		if ( (UartBase[FCR] & 0xC0) == 0xC0 )
   \   00000014   EC0091E5           LDR      R0,[R1, #+236]
   \   00000018   0200D0E5           LDRB     R0,[R0, #+2]
   \   0000001C   C00010E2           ANDS     R0,R0,#0xC0
   \   00000020   C00050E3           CMP      R0,#+192
   \   00000024   0100001A           BNE      ??PhysicalHasFIFO_2
     99          			return(FIFOPresent);
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   0C0000EA           B        ??PhysicalHasFIFO_3
    100          		/* FIFO not enabeled allready, so we can continue */
    101          		UartBase[FCR] = 0x01;
   \                     ??PhysicalHasFIFO_2:
   \   00000030   EC0091E5           LDR      R0,[R1, #+236]
   \   00000034   0120A0E3           MOV      R2,#+1
   \   00000038   0220C0E5           STRB     R2,[R0, #+2]
    102          		if ( (UartBase[FCR]  & 0xC0) == 0xC0 )
   \   0000003C   EC0091E5           LDR      R0,[R1, #+236]
   \   00000040   0200D0E5           LDRB     R0,[R0, #+2]
   \   00000044   C00010E2           ANDS     R0,R0,#0xC0
   \   00000048   C00050E3           CMP      R0,#+192
   \   0000004C   0100001A           BNE      ??PhysicalHasFIFO_4
    103          			return(FIFOPresent);
   \   00000050   0100A0E3           MOV      R0,#+1
   \   00000054   020000EA           B        ??PhysicalHasFIFO_3
    104          		else
    105          			return(FIFONotPresent);
   \                     ??PhysicalHasFIFO_4:
   \   00000058   0200A0E3           MOV      R0,#+2
   \   0000005C   000000EA           B        ??PhysicalHasFIFO_3
    106          	} else return(FIFONotPresent);
   \                     ??PhysicalHasFIFO_1:
   \   00000060   0200A0E3           MOV      R0,#+2
   \                     ??PhysicalHasFIFO_3:
   \   00000064   1EFF2FE1           BX       LR               ;; return
    107          }
    108          
    109          /******************************************************************************
    110          *
    111          *   PhysicalHasFIFO
    112          */
    113          
    114          
    115          /******************************************************************************
    116          *
    117          *   HasFIFO
    118          */
    119          

   \                                 In segment CODE, align 4, keep-with-next
    120          bool  ST165540Uart::HasFIFO(void)
    121          {
   \                     ??HasFIFO:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    122          	if ( FIFOInstalled == Unknown )
   \   00000008   E800D4E5           LDRB     R0,[R4, #+232]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0200001A           BNE      ??HasFIFO_1
    123          		FIFOInstalled = PhysicalHasFIFO();
   \   00000014   0400B0E1           MOVS     R0,R4
   \   00000018   ........           BL       ??PhysicalHasFIFO
   \   0000001C   E800C4E5           STRB     R0,[R4, #+232]
    124          	return(FIFOInstalled == FIFOPresent);
   \                     ??HasFIFO_1:
   \   00000020   E800D4E5           LDRB     R0,[R4, #+232]
   \   00000024   010050E3           CMP      R0,#+1
   \   00000028   0100001A           BNE      ??HasFIFO_2
   \   0000002C   0100A0E3           MOV      R0,#+1
   \   00000030   000000EA           B        ??HasFIFO_3
   \                     ??HasFIFO_2:
   \   00000034   0000A0E3           MOV      R0,#+0
   \                     ??HasFIFO_3:
   \   00000038   1040BDE8           POP      {R4,LR}
   \   0000003C   1EFF2FE1           BX       LR               ;; return
    125          }
    126          
    127          
    128          /******************************************************************************
    129          *
    130          *   EnableFIFO
    131          */
    132          

   \                                 In segment CODE, align 4, keep-with-next
    133          void ST165540Uart::EnableFIFO(int Trigger)
    134          {
   \                     ??EnableFIFO:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
    135          	if ( HasFIFO() )
   \   0000000C   0400B0E1           MOVS     R0,R4
   \   00000010   ........           BL       ??HasFIFO
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1C00000A           BEQ      ??EnableFIFO_2
    136          		switch ( Trigger ) {
   \   0000001C   0500B0E1           MOVS     R0,R5
   \   00000020   0E0050E3           CMP      R0,#+14
   \   00000024   1900008A           BHI      ??EnableFIFO_2
   \   00000028   011F8FE2           ADR      R1,??EnableFIFO_1
   \   0000002C   0010D1E7           LDRB     R1,[R1, R0]
   \   00000030   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??EnableFIFO_1:
   \   00000034   03071616           DC8      +3,+7,+22,+22
   \   00000038   0B161616           DC8      +11,+22,+22,+22
   \   0000003C   0F161616           DC8      +15,+22,+22,+22
   \   00000040   16161300           DC8      +22,+22,+19,+0
    137          		case  0: UartBase[FCR]= 0x00; break;
   \                     ??EnableFIFO_3:
   \   00000044   EC0094E5           LDR      R0,[R4, #+236]
   \   00000048   0010A0E3           MOV      R1,#+0
   \   0000004C   0210C0E5           STRB     R1,[R0, #+2]
   \   00000050   0E0000EA           B        ??EnableFIFO_2
    138          		case  1: UartBase[FCR]= 0x01; break;
   \                     ??EnableFIFO_4:
   \   00000054   EC0094E5           LDR      R0,[R4, #+236]
   \   00000058   0110A0E3           MOV      R1,#+1
   \   0000005C   0210C0E5           STRB     R1,[R0, #+2]
   \   00000060   0A0000EA           B        ??EnableFIFO_2
    139          		case  4: UartBase[FCR]= 0x41; break;
   \                     ??EnableFIFO_5:
   \   00000064   EC0094E5           LDR      R0,[R4, #+236]
   \   00000068   4110A0E3           MOV      R1,#+65
   \   0000006C   0210C0E5           STRB     R1,[R0, #+2]
   \   00000070   060000EA           B        ??EnableFIFO_2
    140          		case  8: UartBase[FCR]= 0x81; break;
   \                     ??EnableFIFO_6:
   \   00000074   EC0094E5           LDR      R0,[R4, #+236]
   \   00000078   8110A0E3           MOV      R1,#+129
   \   0000007C   0210C0E5           STRB     R1,[R0, #+2]
   \   00000080   020000EA           B        ??EnableFIFO_2
    141          		case 14: UartBase[FCR]= 0xC1; break;
   \                     ??EnableFIFO_7:
   \   00000084   EC0094E5           LDR      R0,[R4, #+236]
   \   00000088   C110A0E3           MOV      R1,#+193
   \   0000008C   0210C0E5           STRB     R1,[R0, #+2]
    142          		default:
    143          			/* Do nothing. Should give a message! */
    144          			break;
    145          		}
    146          	else if ( Trigger != 0 ) {
    147          
    148          	}
    149          
    150          	if ( Trigger == 0 ) {
   \                     ??EnableFIFO_2:
   \   00000090   000055E3           CMP      R5,#+0
   \   00000094   0200001A           BNE      ??EnableFIFO_8
    151          		TxFIFOSize = 1;
   \   00000098   0100A0E3           MOV      R0,#+1
   \   0000009C   200084E5           STR      R0,[R4, #+32]
   \   000000A0   010000EA           B        ??EnableFIFO_9
    152          	} else {
    153          		TxFIFOSize = 16;
   \                     ??EnableFIFO_8:
   \   000000A4   1000A0E3           MOV      R0,#+16
   \   000000A8   200084E5           STR      R0,[R4, #+32]
    154          	}
    155          	//TxFIFOSize = 16-TxTrigger;
    156          
    157          	RxFIFOSize = Trigger;
   \                     ??EnableFIFO_9:
   \   000000AC   245084E5           STR      R5,[R4, #+36]
    158          }
   \   000000B0   3040BDE8           POP      {R4,R5,LR}
   \   000000B4   1EFF2FE1           BX       LR               ;; return
    159          
    160          
    161          
    162          /*******************************************************************************
    163          *
    164          * 16550IntWr - handle a transmitter interrupt
    165          *
    166          * This routine handles write interrupts from the UART. It reads a character
    167          * and puts it in the transmit holding register of the device for transfer.
    168          *
    169          * If there are no more characters to transmit, transmission is disabled by
    170          * clearing the transmit interrupt enable bit in the IER(int enable register).
    171          *
    172          * RETURNS: N/A
    173          *
    174          */
    175          

   \                                 In segment CODE, align 4, keep-with-next
    176          void ST165540Uart::Transmit(void)
    177          {
   \                     ??Transmit:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    178          	bool SomeDataSent=false;
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   0050B0E1           MOVS     R5,R0
    179          	if ( TxDataPtr ) {
   \   00000010   2C0094E5           LDR      R0,[R4, #+44]
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1600000A           BEQ      ??Transmit_1
    180          		for ( int i=0; i < TxFIFOSize && TxDataPos < TxDataSize; i++ ) {
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0100B0E1           MOVS     R0,R1
   \                     ??Transmit_2:
   \   00000024   201094E5           LDR      R1,[R4, #+32]
   \   00000028   010050E1           CMP      R0,R1
   \   0000002C   110000AA           BGE      ??Transmit_1
   \   00000030   441094E5           LDR      R1,[R4, #+68]
   \   00000034   302094E5           LDR      R2,[R4, #+48]
   \   00000038   020051E1           CMP      R1,R2
   \   0000003C   0D0000AA           BGE      ??Transmit_1
    181          			UartBase[TXB] = TxDataPtr[TxDataPos++];
   \   00000040   441094E5           LDR      R1,[R4, #+68]
   \   00000044   012091E2           ADDS     R2,R1,#+1
   \   00000048   442084E5           STR      R2,[R4, #+68]
   \   0000004C   EC2094E5           LDR      R2,[R4, #+236]
   \   00000050   2C3094E5           LDR      R3,[R4, #+44]
   \   00000054   0310D1E7           LDRB     R1,[R1, +R3]
   \   00000058   0010C2E5           STRB     R1,[R2, #+0]
    182          			TxByteCnt++;
   \   0000005C   D81094E5           LDR      R1,[R4, #+216]
   \   00000060   011091E2           ADDS     R1,R1,#+1
   \   00000064   D81084E5           STR      R1,[R4, #+216]
    183          			SomeDataSent = true;
   \   00000068   0110A0E3           MOV      R1,#+1
   \   0000006C   0150B0E1           MOVS     R5,R1
    184          		}
   \   00000070   010090E2           ADDS     R0,R0,#+1
   \   00000074   EAFFFFEA           B        ??Transmit_2
    185          	}
    186          	if ( !SomeDataSent ) {
   \                     ??Transmit_1:
   \   00000078   000055E3           CMP      R5,#+0
   \   0000007C   1400001A           BNE      ??Transmit_3
    187          		switch ( SWProtocol ) {
   \   00000080   AC0094E5           LDR      R0,[R4, #+172]
   \   00000084   5710A0E3           MOV      R1,#+87
   \   00000088   7C1D81E3           ORR      R1,R1,#0x1F00
   \   0000008C   010050E1           CMP      R0,R1
   \   00000090   0400001A           BNE      ??Transmit_4
    188          		case C_UART_SWPRO_ANPRO10:
    189          			// Turn off the RS485 if nothing to send on this interrupt
    190          			UartBase[MCR] = MCR_OUT2;
   \                     ??Transmit_5:
   \   00000094   EC0094E5           LDR      R0,[R4, #+236]
   \   00000098   0810A0E3           MOV      R1,#+8
   \   0000009C   0410C0E5           STRB     R1,[R0, #+4]
    191          			ProtocolState = pNew_Sync;
   \   000000A0   0400A0E3           MOV      R0,#+4
   \   000000A4   4800C4E5           STRB     R0,[R4, #+72]
    192          			break;
    193          		default:
    194          			break;
    195          		}
    196          		if ( TxTaskPtr && EventMask ) {
   \                     ??Transmit_4:
   \   000000A8   400094E5           LDR      R0,[R4, #+64]
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0700000A           BEQ      ??Transmit_3
   \   000000B4   3C00D4E5           LDRB     R0,[R4, #+60]
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   0400000A           BEQ      ??Transmit_3
    197          			OS_SignalEvent(EventMask,(TSN_TASK*)TxTaskPtr);
   \   000000C0   401094E5           LDR      R1,[R4, #+64]
   \   000000C4   3C00D4E5           LDRB     R0,[R4, #+60]
   \   000000C8   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
    198          			TxTaskPtr = NULL;
   \   000000CC   0000A0E3           MOV      R0,#+0
   \   000000D0   400084E5           STR      R0,[R4, #+64]
    199          		}
    200          	}
    201          }
   \                     ??Transmit_3:
   \   000000D4   3040BDE8           POP      {R4,R5,LR}
   \   000000D8   1EFF2FE1           BX       LR               ;; return
    202          
    203          /*******************************************************************************
    204          *
    205          * 16550IntRd - handle a  receiver interrupt
    206          *
    207          * This routine handles read interrupts from the UART.
    208          *
    209          * RETURNS: N/A
    210          *
    211          */
    212          

   \                                 In segment CODE, align 4, keep-with-next
    213          void ST165540Uart::Receive(void){
   \                     ??Receive_1:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
    214          	/* read character from Receive Holding Reg.                 */
    215          	/* I will allways read rx register and push it on the stack */
    216          	do {
    217          		U8 RxData = UartBase[RXB];
   \                     ??Receive_2:
   \   0000000C   EC1094E5           LDR      R1,[R4, #+236]
   \   00000010   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000014   0010CDE5           STRB     R1,[SP, #+0]
    218          		OS_PutMailCond1(&RxBuf,(char*)&RxData);
   \   00000018   0D10B0E1           MOVS     R1,SP
   \   0000001C   0400B0E1           MOVS     R0,R4
   \   00000020   ........           _BLF     OS_PutMailCond1,??OS_PutMailCond1??rA
    219          		RxByteCnt++;
   \   00000024   D40094E5           LDR      R0,[R4, #+212]
   \   00000028   010090E2           ADDS     R0,R0,#+1
   \   0000002C   D40084E5           STR      R0,[R4, #+212]
    220          	} while ( UartBase[LSR] & LSR_RXRDY );
   \   00000030   EC0094E5           LDR      R0,[R4, #+236]
   \   00000034   0500D0E5           LDRB     R0,[R0, #+5]
   \   00000038   010010E3           TST      R0,#0x1
   \   0000003C   F2FFFF1A           BNE      ??Receive_2
    221          	LastRxTime      = (int)OS_Time;
   \   00000040   ........           LDR      R0,??DataTable1  ;; OS_Time
   \   00000044   000090E5           LDR      R0,[R0, #+0]
   \   00000048   4C0084E5           STR      R0,[R4, #+76]
    222          }
   \   0000004C   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000050   1040BDE8           POP      {R4,LR}
   \   00000054   1EFF2FE1           BX       LR               ;; return
    223          /*******************************************************************************
    224          *
    225          * 16550Int - handle a receiver/transmitter interrupt
    226          *
    227          * This routine handles four sources of interrupts from the UART. They are
    228          * prioritized in the following order by the Interrupt Identification Register:
    229          * Receiver Line Status, Received Data Ready, Transmit Holding Register Empty
    230          * and Modem Status.
    231          *
    232          * If there is another character to be transmitted, it sends it.  If
    233          * not, or if a device has never been created for this channel, just
    234          * disable the interrupt.
    235          * When a modem status interrupt occurs, the transmit interrupt is enabled if
    236          * the CTS signal is TRUE.
    237          *
    238          * RETURNS: N/A
    239          */
    240          

   \                                 In segment CODE, align 4, keep-with-next
    241          void ST165540Uart::HandleInterrupt(void){
   \                     ??HandleInterrupt:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
    242          
    243          	volatile U8 interruptID = UartBase[IIR];
   \   0000000C   EC1094E5           LDR      R1,[R4, #+236]
   \   00000010   0210D1E5           LDRB     R1,[R1, #+2]
   \   00000014   0010CDE5           STRB     R1,[SP, #+0]
    244          
    245          	do {
    246          		interruptID &= IIR_MASK;
   \                     ??HandleInterrupt_2:
   \   00000018   0010DDE5           LDRB     R1,[SP, #+0]
   \   0000001C   0F1011E2           ANDS     R1,R1,#0xF
   \   00000020   0010CDE5           STRB     R1,[SP, #+0]
    247          		switch ( interruptID ) {
   \   00000024   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000028   0C0050E3           CMP      R0,#+12
   \   0000002C   2500008A           BHI      ??HandleInterrupt_3
   \   00000030   011F8FE2           ADR      R1,??HandleInterrupt_1
   \   00000034   0010D1E7           LDRB     R1,[R1, R0]
   \   00000038   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??HandleInterrupt_1:
   \   0000003C   15220E22           DC8      +21,+34,+14,+34
   \   00000040   07220322           DC8      +7,+34,+3,+34
   \   00000044   22222222           DC8      +34,+34,+34,+34
   \   00000048   07000000           DC8      +7,+0,+0,+0
    248          		case IIR_SEOB:
    249          			{
    250          				U8 LineStatus = UartBase[LSR];
   \                     ??HandleInterrupt_4:
   \   0000004C   EC1094E5           LDR      R1,[R4, #+236]
   \   00000050   0510D1E5           LDRB     R1,[R1, #+5]
   \   00000054   0100B0E1           MOVS     R0,R1
   \   00000058   1A0000EA           B        ??HandleInterrupt_3
    251          			}
    252          			break;
    253          		case IIR_TOUT:
    254          		case IIR_RBRF:
    255          			Receive();
   \                     ??HandleInterrupt_5:
   \   0000005C   E40094E5           LDR      R0,[R4, #+228]
   \   00000060   0C1090E2           ADDS     R1,R0,#+12
   \   00000064   0400B0E1           MOVS     R0,R4
   \   00000068   001091E5           LDR      R1,[R1, #+0]
   \   0000006C   0FE0A0E1           MOV      LR,PC
   \   00000070   11FF2FE1           BX       R1
   \   00000074   130000EA           B        ??HandleInterrupt_3
    256          			break;
    257          		case IIR_THRE:
    258          			Transmit();
   \                     ??HandleInterrupt_6:
   \   00000078   E40094E5           LDR      R0,[R4, #+228]
   \   0000007C   1C1090E2           ADDS     R1,R0,#+28
   \   00000080   0400B0E1           MOVS     R0,R4
   \   00000084   001091E5           LDR      R1,[R1, #+0]
   \   00000088   0FE0A0E1           MOV      LR,PC
   \   0000008C   11FF2FE1           BX       R1
   \   00000090   0C0000EA           B        ??HandleInterrupt_3
    259          			break;
    260          		case IIR_MSTAT:{	 /* Should never come her but anyway be a little prepared for the future */
    261          				/* modem status register */
    262          				U8 msr = UartBase[MSR];
   \                     ??HandleInterrupt_7:
   \   00000094   EC1094E5           LDR      R1,[R4, #+236]
   \   00000098   0610D1E5           LDRB     R1,[R1, #+6]
   \   0000009C   0100B0E1           MOVS     R0,R1
    263          
    264          				/* if CTS is asserted by modem, enable tx interrupt */
    265          
    266          				if ( (msr & MSR_CTS) && (msr & MSR_DCTS) ) {
   \   000000A0   111010E2           ANDS     R1,R0,#0x11
   \   000000A4   110051E3           CMP      R1,#+17
   \   000000A8   0300001A           BNE      ??HandleInterrupt_8
    267          					UartBase[IER] = IER_TBE | IER_RXRDY | IER_MSI;
   \   000000AC   EC1094E5           LDR      R1,[R4, #+236]
   \   000000B0   0B20A0E3           MOV      R2,#+11
   \   000000B4   0120C1E5           STRB     R2,[R1, #+1]
   \   000000B8   020000EA           B        ??HandleInterrupt_3
    268          				} else {
    269          					UartBase[IER] = IER_RXRDY | IER_MSI;
   \                     ??HandleInterrupt_8:
   \   000000BC   EC1094E5           LDR      R1,[R4, #+236]
   \   000000C0   0920A0E3           MOV      R2,#+9
   \   000000C4   0120C1E5           STRB     R2,[R1, #+1]
    270          				}
    271          			}
    272          			break;
    273          		}
    274          		interruptID = UartBase[IIR];
   \                     ??HandleInterrupt_3:
   \   000000C8   EC1094E5           LDR      R1,[R4, #+236]
   \   000000CC   0210D1E5           LDRB     R1,[R1, #+2]
   \   000000D0   0010CDE5           STRB     R1,[SP, #+0]
    275          	} while ( ( interruptID & 0x01 ) == 0 );
   \   000000D4   0000DDE5           LDRB     R0,[SP, #+0]
   \   000000D8   010010E3           TST      R0,#0x1
   \   000000DC   CDFFFF0A           BEQ      ??HandleInterrupt_2
    276          }
   \   000000E0   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000E4   1040BDE8           POP      {R4,LR}
   \   000000E8   1EFF2FE1           BX       LR               ;; return
    277          

   \                                 In segment CODE, align 4, keep-with-next
    278          void ST165540Uart::ActivateTx(void)
    279          {
   \                     ??ActivateTx:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    280          	// Turn on the RS485 if nothing to send on this interrupt
    281          	UartBase[MCR] = MCR_OUT2 | MCR_RTS;
   \   00000008   EC0094E5           LDR      R0,[R4, #+236]
   \   0000000C   0A10A0E3           MOV      R1,#+10
   \   00000010   0410C0E5           STRB     R1,[R0, #+4]
    282          	ProtocolState = pInTx;
   \   00000014   0200A0E3           MOV      R0,#+2
   \   00000018   4800C4E5           STRB     R0,[R4, #+72]
    283          	switch ( SWProtocol ) {
   \   0000001C   AC0094E5           LDR      R0,[R4, #+172]
   \   00000020   5710A0E3           MOV      R1,#+87
   \   00000024   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000028   010050E1           CMP      R0,R1
   \   0000002C   0500001A           BNE      ??ActivateTx_1
    284          	case C_UART_SWPRO_ANPRO10:
    285          		TxDataPtr[TxDataSize++] = 0x0;
   \                     ??ActivateTx_2:
   \   00000030   300094E5           LDR      R0,[R4, #+48]
   \   00000034   011090E2           ADDS     R1,R0,#+1
   \   00000038   301084E5           STR      R1,[R4, #+48]
   \   0000003C   2C1094E5           LDR      R1,[R4, #+44]
   \   00000040   0020A0E3           MOV      R2,#+0
   \   00000044   0120C0E7           STRB     R2,[R0, +R1]
    286          		break;
    287          	default:
    288          		break;
    289          	}
    290          	LastTxTime   = OS_Time;
   \                     ??ActivateTx_1:
   \   00000048   ........           LDR      R0,??DataTable1  ;; OS_Time
   \   0000004C   000090E5           LDR      R0,[R0, #+0]
   \   00000050   F00084E5           STR      R0,[R4, #+240]
    291          	OS_Delay(RS485_ON_DELAY+2);
   \   00000054   0400A0E3           MOV      R0,#+4
   \   00000058   ........           _BLF     OS_Delay,??OS_Delay??rA
    292          	UartBase[TXB] = TxDataPtr[TxDataPos++];
   \   0000005C   440094E5           LDR      R0,[R4, #+68]
   \   00000060   011090E2           ADDS     R1,R0,#+1
   \   00000064   441084E5           STR      R1,[R4, #+68]
   \   00000068   EC1094E5           LDR      R1,[R4, #+236]
   \   0000006C   2C2094E5           LDR      R2,[R4, #+44]
   \   00000070   0200D0E7           LDRB     R0,[R0, +R2]
   \   00000074   0000C1E5           STRB     R0,[R1, #+0]
    293          }
   \   00000078   1040BDE8           POP      {R4,LR}
   \   0000007C   1EFF2FE1           BX       LR               ;; return
    294          

   \                                 In segment CODE, align 4, keep-with-next
    295          void ST165540Uart::DeactivateTx(void)
    296          {
    297          	// Turn off the RS485
    298              if ( HWProtocol == C_UART_HWPRO_485 ){
   \                     ??DeactivateTx:
   \   00000000   A81090E5           LDR      R1,[R0, #+168]
   \   00000004   4C20A0E3           MOV      R2,#+76
   \   00000008   7C2D82E3           ORR      R2,R2,#0x1F00
   \   0000000C   020051E1           CMP      R1,R2
   \   00000010   0200001A           BNE      ??DeactivateTx_1
    299                  UartBase[MCR] = MCR_OUT2;
   \   00000014   EC1090E5           LDR      R1,[R0, #+236]
   \   00000018   0820A0E3           MOV      R2,#+8
   \   0000001C   0420C1E5           STRB     R2,[R1, #+4]
    300              }
    301          }
   \                     ??DeactivateTx_1:
   \   00000020   1EFF2FE1           BX       LR               ;; return
    302          

   \                                 In segment CODE, align 4, keep-with-next
    303          bool ST165540Uart::Send(U8* MyData, int Size,char EventMsk, bool Wait)
    304          {
   \                     ??Send:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
   \   00000010   0370B0E1           MOVS     R7,R3
   \   00000014   2480DDE5           LDRB     R8,[SP, #+36]
    305          	bool TxOk = false;
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   0090B0E1           MOVS     R9,R0
    306          	if ( Size ) {
   \   00000020   000056E3           CMP      R6,#+0
   \   00000024   6B00000A           BEQ      ??Send_1
    307          		OS_Use(&TxSema);
   \   00000028   740094E2           ADDS     R0,R4,#+116
   \   0000002C   ........           _BLF     OS_Use,??OS_Use??rA
    308          		TxDataPtr   = MyData;
   \   00000030   2C5084E5           STR      R5,[R4, #+44]
    309          		TxDataSize  = Size;
   \   00000034   306084E5           STR      R6,[R4, #+48]
    310          		TxDataPos   = 0;
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   440084E5           STR      R0,[R4, #+68]
    311          
    312          		EventMask = EventMsk;
   \   00000040   3C70C4E5           STRB     R7,[R4, #+60]
    313          		if ( EventMsk ) {
   \   00000044   000057E3           CMP      R7,#+0
   \   00000048   0300000A           BEQ      ??Send_2
    314          			TxTaskPtr = OS_GetpCurrentTask();
   \   0000004C   94019FE5           LDR      R0,??Send_3      ;; OS_pCurrentTask
   \   00000050   000090E5           LDR      R0,[R0, #+0]
   \   00000054   400084E5           STR      R0,[R4, #+64]
   \   00000058   010000EA           B        ??Send_4
    315          		} else {
    316          			TxTaskPtr = NULL;
   \                     ??Send_2:
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   400084E5           STR      R0,[R4, #+64]
    317          		}
    318          		int Delay = (13000*TxDataSize)/BaudRate+RS485_EXTRA_DELAY;
   \                     ??Send_4:
   \   00000064   300094E5           LDR      R0,[R4, #+48]
   \   00000068   C810A0E3           MOV      R1,#+200
   \   0000006C   C81D81E3           ORR      R1,R1,#0x3200
   \   00000070   910010E0           MULS     R0,R1,R0
   \   00000074   B41094E5           LDR      R1,[R4, #+180]
   \   00000078   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   0000007C   020091E2           ADDS     R0,R1,#+2
   \   00000080   00B0B0E1           MOVS     R11,R0
    319          		switch ( SWProtocol ) {
   \   00000084   AC0094E5           LDR      R0,[R4, #+172]
   \   00000088   5710A0E3           MOV      R1,#+87
   \   0000008C   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000090   010050E1           CMP      R0,R1
   \   00000094   2000001A           BNE      ??Send_5
    320          		case C_UART_SWPRO_ANPRO10:
    321          			if ( IsMaster ) {
   \                     ??Send_6:
   \   00000098   3400D4E5           LDRB     R0,[R4, #+52]
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   1200000A           BEQ      ??Send_7
    322          				// Asume we have to force the tx if TxRequest = true!
    323          				if ( TxRequest || ProtocolState == pNew_Sync ) {
   \   000000A4   4900D4E5           LDRB     R0,[R4, #+73]
   \   000000A8   000050E3           CMP      R0,#+0
   \   000000AC   0200001A           BNE      ??Send_8
   \   000000B0   4800D4E5           LDRB     R0,[R4, #+72]
   \   000000B4   040050E3           CMP      R0,#+4
   \   000000B8   0800001A           BNE      ??Send_9
    324          					TxRequest = false;
   \                     ??Send_8:
   \   000000BC   0000A0E3           MOV      R0,#+0
   \   000000C0   4900C4E5           STRB     R0,[R4, #+73]
    325          					ActivateTx();
   \   000000C4   E40094E5           LDR      R0,[R4, #+228]
   \   000000C8   141090E2           ADDS     R1,R0,#+20
   \   000000CC   0400B0E1           MOVS     R0,R4
   \   000000D0   001091E5           LDR      R1,[R1, #+0]
   \   000000D4   0FE0A0E1           MOV      LR,PC
   \   000000D8   11FF2FE1           BX       R1
   \   000000DC   140000EA           B        ??Send_10
    326          				} else {
    327          					Delay += RS485_DELAY;
   \                     ??Send_9:
   \   000000E0   C8B09BE2           ADDS     R11,R11,#+200
    328          					TxRequest = true;
   \   000000E4   0100A0E3           MOV      R0,#+1
   \   000000E8   4900C4E5           STRB     R0,[R4, #+73]
   \   000000EC   100000EA           B        ??Send_10
    329          				}
    330          			} else {
    331          				TxRequest  = true;
   \                     ??Send_7:
   \   000000F0   0100A0E3           MOV      R0,#+1
   \   000000F4   4900C4E5           STRB     R0,[R4, #+73]
    332          				if ( LastRxTime < 10 ) {
   \   000000F8   4C0094E5           LDR      R0,[R4, #+76]
   \   000000FC   0A0050E3           CMP      R0,#+10
   \   00000100   030000AA           BGE      ??Send_11
    333          					Delay     += RS485_DELAY; // Abort Tx if not completed within this time
   \   00000104   C8B09BE2           ADDS     R11,R11,#+200
    334          					ActivateIfTxRequest();
   \   00000108   0400B0E1           MOVS     R0,R4
   \   0000010C   ........           _BLF     ??ActivateIfTxRequest,??ActivateIfTxRequest??rA
   \   00000110   070000EA           B        ??Send_10
    335          				} else {
    336          					Delay     += RS485_DELAY+1000; // Abort Tx if not completed within this time
   \                     ??Send_11:
   \   00000114   4BBE9BE2           ADDS     R11,R11,#+1200
   \   00000118   050000EA           B        ??Send_10
    337          				}
    338          			}
    339          			break;
    340          		default:
    341          			ActivateTx();
   \                     ??Send_5:
   \   0000011C   E40094E5           LDR      R0,[R4, #+228]
   \   00000120   141090E2           ADDS     R1,R0,#+20
   \   00000124   0400B0E1           MOVS     R0,R4
   \   00000128   001091E5           LDR      R1,[R1, #+0]
   \   0000012C   0FE0A0E1           MOV      LR,PC
   \   00000130   11FF2FE1           BX       R1
    342          			break;
    343          		}
    344          
    345          		char Status=0;
   \                     ??Send_10:
   \   00000134   0000A0E3           MOV      R0,#+0
   \   00000138   00A0B0E1           MOVS     R10,R0
    346          		if ( Wait && EventMsk ) {
   \   0000013C   000058E3           CMP      R8,#+0
   \   00000140   0700000A           BEQ      ??Send_12
   \   00000144   000057E3           CMP      R7,#+0
   \   00000148   0500000A           BEQ      ??Send_12
    347          			Status = OS_WaitEventTimed(EventMsk,Delay);
   \   0000014C   0B10B0E1           MOVS     R1,R11
   \   00000150   0700B0E1           MOVS     R0,R7
   \   00000154   ........           _BLF     OS_WaitEventTimed,??OS_WaitEventTimed??rA
   \   00000158   00A0B0E1           MOVS     R10,R0
    348          			TxTaskPtr = NULL;
   \   0000015C   0000A0E3           MOV      R0,#+0
   \   00000160   400084E5           STR      R0,[R4, #+64]
    349          		}
    350          		switch ( SWProtocol ) {
   \                     ??Send_12:
   \   00000164   AC0094E5           LDR      R0,[R4, #+172]
   \   00000168   5710A0E3           MOV      R1,#+87
   \   0000016C   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000170   010050E1           CMP      R0,R1
   \   00000174   0600001A           BNE      ??Send_13
    351          		case C_UART_SWPRO_ANPRO10:
    352          			ClearRxBuffer();
   \                     ??Send_14:
   \   00000178   E40094E5           LDR      R0,[R4, #+228]
   \   0000017C   101090E2           ADDS     R1,R0,#+16
   \   00000180   0400B0E1           MOVS     R0,R4
   \   00000184   001091E5           LDR      R1,[R1, #+0]
   \   00000188   0FE0A0E1           MOV      LR,PC
   \   0000018C   11FF2FE1           BX       R1
   \   00000190   090000EA           B        ??Send_15
    353          			break;
    354          		default:
    355          			OS_Delay(2);
   \                     ??Send_13:
   \   00000194   0200A0E3           MOV      R0,#+2
   \   00000198   ........           _BLF     OS_Delay,??OS_Delay??rA
    356                      DeactivateTx();
   \   0000019C   E40094E5           LDR      R0,[R4, #+228]
   \   000001A0   181090E2           ADDS     R1,R0,#+24
   \   000001A4   0400B0E1           MOVS     R0,R4
   \   000001A8   001091E5           LDR      R1,[R1, #+0]
   \   000001AC   0FE0A0E1           MOV      LR,PC
   \   000001B0   11FF2FE1           BX       R1
    357          			ProtocolState = pNew_Sync;
   \   000001B4   0400A0E3           MOV      R0,#+4
   \   000001B8   4800C4E5           STRB     R0,[R4, #+72]
    358          			break;
    359          		}
    360          		OS_Unuse(&TxSema);
   \                     ??Send_15:
   \   000001BC   740094E2           ADDS     R0,R4,#+116
   \   000001C0   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    361          		TxOk = ( Status == EventMsk);
   \   000001C4   07005AE1           CMP      R10,R7
   \   000001C8   0100001A           BNE      ??Send_16
   \   000001CC   0190A0E3           MOV      R9,#+1
   \   000001D0   000000EA           B        ??Send_17
   \                     ??Send_16:
   \   000001D4   0090A0E3           MOV      R9,#+0
    362          	}
    363          
    364          	return(TxOk);
   \                     ??Send_17:
   \                     ??Send_1:
   \   000001D8   0900B0E1           MOVS     R0,R9
   \   000001DC   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000001E0   F04FBDE8           POP      {R4-R11,LR}
   \   000001E4   1EFF2FE1           BX       LR               ;; return
   \                     ??Send_3:
   \   000001E8   ........           DC32     OS_pCurrentTask
    365          }
    366          
    367          
    368          

   \                                 In segment CODE, align 4, keep-with-next
    369          bool ST165540Uart::Receive(U8* MyData, int Size, int TimeOut)
    370          {
   \                     ??Receive:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
   \   00000010   0370B0E1           MOVS     R7,R3
    371          	int Cnt = 0;
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   0080B0E1           MOVS     R8,R0
    372          	bool ReceivedData=true;
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   0090B0E1           MOVS     R9,R0
    373          
    374          	while ( ReceivedData && Cnt < Size ) {
   \                     ??Receive_3:
   \   00000024   FF9019E2           ANDS     R9,R9,#0xFF      ;; Zero extend
   \   00000028   000059E3           CMP      R9,#+0
   \   0000002C   0C00000A           BEQ      ??Receive_4
   \   00000030   060058E1           CMP      R8,R6
   \   00000034   0A0000AA           BGE      ??Receive_4
    375          		ReceivedData = !OS_GetMailTimed(&RxBuf,(char*)&MyData[Cnt++],TimeOut);
   \   00000038   0720B0E1           MOVS     R2,R7
   \   0000003C   051098E0           ADDS     R1,R8,R5
   \   00000040   0400B0E1           MOVS     R0,R4
   \   00000044   ........           _BLF     OS_GetMailTimed,??OS_GetMailTimed??rA
   \   00000048   018098E2           ADDS     R8,R8,#+1
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   0100001A           BNE      ??Receive_5
   \   00000054   0190A0E3           MOV      R9,#+1
   \   00000058   000000EA           B        ??Receive_6
   \                     ??Receive_5:
   \   0000005C   0090A0E3           MOV      R9,#+0
   \                     ??Receive_6:
   \   00000060   EFFFFFEA           B        ??Receive_3
    376          	}
    377          	return(ReceivedData);
   \                     ??Receive_4:
   \   00000064   0900B0E1           MOVS     R0,R9
   \   00000068   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000006C   F043BDE8           POP      {R4-R9,LR}
   \   00000070   1EFF2FE1           BX       LR               ;; return
    378          }
    379          

   \                                 In segment CODE, align 4, keep-with-next
    380          void ST165540Uart::ClearRxBuffer(void)
    381          {
   \                     ??ClearRxBuffer:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    382          	OS_ClearMB(&RxBuf);
   \   00000008   0400B0E1           MOVS     R0,R4
   \   0000000C   ........           _BLF     OS_ClearMB,??OS_ClearMB??rA
    383          	//for(int i=0; i < 8; i++){
    384          	//	U8 RxData = UartBase[RXB];
    385          	//}
    386          }
   \   00000010   1040BDE8           POP      {R4,LR}
   \   00000014   1EFF2FE1           BX       LR               ;; return
    387          

   \                                 In segment CODE, align 4, keep-with-next
    388          bool ST165540Uart::HasMore(void)
    389          {
   \                     ??HasMore:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    390          	int RxBytesInBuf = OS_GetMessageCnt(&RxBuf);
   \   00000008   0400B0E1           MOVS     R0,R4
   \   0000000C   ........           _BLF     OS_GetMessageCnt,??OS_GetMessageCnt??rA
   \   00000010   0050B0E1           MOVS     R5,R0
    391          	return(bool(RxBytesInBuf));
   \   00000014   000055E3           CMP      R5,#+0
   \   00000018   0100000A           BEQ      ??HasMore_1
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   000000EA           B        ??HasMore_2
   \                     ??HasMore_1:
   \   00000024   0000A0E3           MOV      R0,#+0
   \                     ??HasMore_2:
   \   00000028   3040BDE8           POP      {R4,R5,LR}
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    392          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {(unsigned char *)134217728, (unsig`:
   \   00000000   000000080000       DC32 8000000H, 10000000H, 18000000H, 20000000H
   \              001000000018
   \              00000020    

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs ST165540Uart &ST165540Uart::new ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
   \                     `??new ST165540Uart`:
   \   00000000   FF4F2DE9           PUSH     {R0-R11,LR}
   \   00000004   3C409DE5           LDR      R4,[SP, #+60]
   \   00000008   40509DE5           LDR      R5,[SP, #+64]
   \   0000000C   44609DE5           LDR      R6,[SP, #+68]
   \   00000010   4870DDE5           LDRB     R7,[SP, #+72]
   \   00000014   4C809DE5           LDR      R8,[SP, #+76]
   \   00000018   5090DDE5           LDRB     R9,[SP, #+80]
   \   0000001C   54A09DE5           LDR      R10,[SP, #+84]
   \   00000020   58B09DE5           LDR      R11,[SP, #+88]
   \   00000024   F400A0E3           MOV      R0,#+244
   \   00000028   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   1300000A           BEQ      `??new ST165540Uart_1`
   \   00000034   00082DE9           PUSH     {R11}
   \   00000038   00042DE9           PUSH     {R10}
   \   0000003C   00022DE9           PUSH     {R9}
   \   00000040   00012DE9           PUSH     {R8}
   \   00000044   80002DE9           PUSH     {R7}
   \   00000048   40002DE9           PUSH     {R6}
   \   0000004C   20002DE9           PUSH     {R5}
   \   00000050   10002DE9           PUSH     {R4}
   \   00000054   58109DE5           LDR      R1,[SP, #+88]
   \   00000058   02002DE9           PUSH     {R1}
   \   0000005C   5810DDE5           LDRB     R1,[SP, #+88]
   \   00000060   02002DE9           PUSH     {R1}
   \   00000064   34109DE5           LDR      R1,[SP, #+52]
   \   00000068   02002DE9           PUSH     {R1}
   \   0000006C   34309DE5           LDR      R3,[SP, #+52]
   \   00000070   30209DE5           LDR      R2,[SP, #+48]
   \   00000074   2C109DE5           LDR      R1,[SP, #+44]
   \   00000078   ........           BL       ??ST165540Uart
   \   0000007C   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   00000080   000000EA           B        `??new ST165540Uart_2`
   \                     `??new ST165540Uart_1`:
   \   00000084   0000A0E3           MOV      R0,#+0
   \                     `??new ST165540Uart_2`:
   \   00000088   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   0000008C   F04FBDE8           POP      {R4-R11,LR}
   \   00000090   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     OS_Time
    393          

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     ST165540Uart::ActivateTx()         8
     ST165540Uart::ClearRxBuffer()      8
     ST165540Uart::DeactivateTx()       0
     ST165540Uart::EnableFIFO(int)     12
     ST165540Uart::EnableInt()          0
     ST165540Uart::HandleInterrupt()
                                       12
     ST165540Uart::HasFIFO()            8
     ST165540Uart::HasMore()           12
     ST165540Uart::PhysicalHasFIFO()
                                        0
     ST165540Uart::Receive()           12
     ST165540Uart::Receive(unsigned char *, int, int)
                                       28
     ST165540Uart::ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                      108
     ST165540Uart::Send(unsigned char *, int, char, bool)
                                       36
     ST165540Uart::Transmit()          12
     ST165540Uart::new ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                       96
     malloc                             8


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     malloc                           24
     ST165540Uart::ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                     556
     ST165540Uart::EnableInt()       196
     ST165540Uart::PhysicalHasFIFO()
                                     104
     ST165540Uart::HasFIFO()          64
     ST165540Uart::EnableFIFO(int)   184
     ST165540Uart::Transmit()        220
     ST165540Uart::Receive()          88
     ST165540Uart::HandleInterrupt()
                                     236
     ST165540Uart::ActivateTx()      128
     ST165540Uart::DeactivateTx()     36
     ST165540Uart::Send(unsigned char *, int, char, bool)
                                     492
     ST165540Uart::Receive(unsigned char *, int, int)
                                     116
     ST165540Uart::ClearRxBuffer()    24
     ST165540Uart::HasMore()          48
     ?<Constant {(unsigned char *)134217728, (unsig
                                      16
     ST165540Uart::new ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                     148
     ??DataTable1                      4
      Others                         316

 
 2 944 bytes in segment CODE
    56 bytes in segment DATA_C
 
 2 644 bytes of CODE  memory (+ 300 bytes shared)
    56 bytes of CONST memory

Errors: none
Warnings: 1
