##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               19/Jan/2017  10:13:09 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\src\SC2410Uart.cpp                     #
#    Command line    =  D:\S2Prog\TXU\src\SC2410Uart.cpp --fpu None -D       #
#                       OS_LIBMODE_DP -D OS_RAMVECT=0 -D CPU_S3C2410 -D      #
#                       OS_UART=1 -D ANBOOTLOADER -D __ARM_LIBRARY__ -lCN    #
#                       D:\S2Prog\TXU\TargetDebug\List\ -o                   #
#                       D:\S2Prog\TXU\TargetDebug\Obj\ -s2 --no_cse          #
#                       --no_unroll --no_inline --no_code_motion --no_tbaa   #
#                       --no_clustering --no_scheduling --debug --cpu_mode   #
#                       arm --endian little --cpu ARM920T --stack_align 4    #
#                       --interwork -e --eec++ --dlib_config "C:\Program     #
#                       Files (x86)\IAR Systems\Embedded Workbench           #
#                       4.0\arm\LIB\dl4tpainl8f.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\MINILZO.108\ -I          #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\INC\"                              #
#    List file       =  D:\S2Prog\TXU\TargetDebug\List\SC2410Uart.lst        #
#    Object file     =  D:\S2Prog\TXU\TargetDebug\Obj\SC2410Uart.r79         #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\src\SC2410Uart.cpp
      1          #include <string.h>
      2          #include <ctype.h>

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __intrinsic __code __interwork __atpcs void *malloc(size_t)
   \                     malloc:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0400B0E1           MOVS     R0,R4
   \   0000000C   ........           _BLF     __data_malloc,??__data_malloc??rA
   \   00000010   1040BDE8           POP      {R4,LR}
   \   00000014   1EFF2FE1           BX       LR               ;; return
      3          #include <stdlib.h>
      4          
      5          #include "def.h"
      6          #include "2410addr.h"
      7          #include "2410lib.h"
      8          #include "2410slib.h"
      9          #include "rtos.h"
     10          //#include "ANPro10Inc.h"
     11          #include "TSNDefines.h"
     12          #include "TSNConstants.h"
     13          #include "ANSIString.h"
     14          #include "TSNConfigString.h"
     15          #include "TsnUart.h"
     16          #include "SC2410Uart.h"
     17          
     18          
     19          extern int OS_FSys;
     20          

   \                                 In segment CODE, align 4, keep-with-next
     21          SC2410Uart::SC2410Uart(int PortNum,unsigned BdRate,unsigned WrdLength,unsigned StpBits,char Prty, unsigned BufSize, int Dev, int HWProt,int SWProt, bool IsMstr,int MaxTimeChar,bool Relax, int LogP, int LogE):
   \                     ??SC2410Uart:
   \   00000000   FE4F2DE9           PUSH     {R1-R11,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   38509DE5           LDR      R5,[SP, #+56]
   \   0000000C   44609DE5           LDR      R6,[SP, #+68]
   \   00000010   4870DDE5           LDRB     R7,[SP, #+72]
   \   00000014   4C809DE5           LDR      R8,[SP, #+76]
   \   00000018   5090DDE5           LDRB     R9,[SP, #+80]
   \   0000001C   54A09DE5           LDR      R10,[SP, #+84]
   \   00000020   58B09DE5           LDR      R11,[SP, #+88]
     22          TSNUart(PortNum,BdRate,WrdLength, StpBits, Prty, BufSize, Dev, HWProt,SWProt, IsMstr,MaxTimeChar, Relax, LogP, LogE)
     23          {
   \   00000024   0B00B0E1           MOVS     R0,R11
   \   00000028   01002DE9           PUSH     {R0}
   \   0000002C   0A00B0E1           MOVS     R0,R10
   \   00000030   01002DE9           PUSH     {R0}
   \   00000034   0900B0E1           MOVS     R0,R9
   \   00000038   01002DE9           PUSH     {R0}
   \   0000003C   0800B0E1           MOVS     R0,R8
   \   00000040   01002DE9           PUSH     {R0}
   \   00000044   0700B0E1           MOVS     R0,R7
   \   00000048   01002DE9           PUSH     {R0}
   \   0000004C   0600B0E1           MOVS     R0,R6
   \   00000050   01002DE9           PUSH     {R0}
   \   00000054   58009DE5           LDR      R0,[SP, #+88]
   \   00000058   01002DE9           PUSH     {R0}
   \   0000005C   58009DE5           LDR      R0,[SP, #+88]
   \   00000060   01002DE9           PUSH     {R0}
   \   00000064   0500B0E1           MOVS     R0,R5
   \   00000068   01002DE9           PUSH     {R0}
   \   0000006C   5800DDE5           LDRB     R0,[SP, #+88]
   \   00000070   01002DE9           PUSH     {R0}
   \   00000074   58009DE5           LDR      R0,[SP, #+88]
   \   00000078   01002DE9           PUSH     {R0}
   \   0000007C   34309DE5           LDR      R3,[SP, #+52]
   \   00000080   30209DE5           LDR      R2,[SP, #+48]
   \   00000084   2C109DE5           LDR      R1,[SP, #+44]
   \   00000088   0400B0E1           MOVS     R0,R4
   \   0000008C   ........           _BLF     ??TSNUart,??TSNUart??rA
   \   00000090   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   00000094   60029FE5           LDR      R0,??SC2410Uart_1  ;; ??__vtbl
   \   00000098   E40084E5           STR      R0,[R4, #+228]
     24          	OS_CREATERSEMA(&TxSema);
   \   0000009C   740094E2           ADDS     R0,R4,#+116
   \   000000A0   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
     25          	Channels[PortNumber] = this;
   \   000000A4   880094E5           LDR      R0,[R4, #+136]
   \   000000A8   0410A0E3           MOV      R1,#+4
   \   000000AC   4C229FE5           LDR      R2,??SC2410Uart_1+0x4  ;; ??Channels
   \   000000B0   912020E0           MLA      R0,R1,R0,R2
   \   000000B4   004080E5           STR      R4,[R0, #+0]
     26          
     27          	RxBufPtr=(U8*)malloc(BufSize);
   \   000000B8   0500B0E1           MOVS     R0,R5
   \   000000BC   ........           _BLF     malloc,??malloc??rA
   \   000000C0   280084E5           STR      R0,[R4, #+40]
     28          	OS_CreateMB(&RxBuf,1,BufSize,(char*)RxBufPtr);
   \   000000C4   283094E5           LDR      R3,[R4, #+40]
   \   000000C8   0520B0E1           MOVS     R2,R5
   \   000000CC   0110A0E3           MOV      R1,#+1
   \   000000D0   0400B0E1           MOVS     R0,R4
   \   000000D4   ........           _BLF     OS_CreateMB,??OS_CreateMB??rA
     29          
     30          	switch ( PortNumber ) {
   \   000000D8   880094E5           LDR      R0,[R4, #+136]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   0400000A           BEQ      ??SC2410Uart_2
   \   000000E4   010050E3           CMP      R0,#+1
   \   000000E8   0900000A           BEQ      ??SC2410Uart_3
   \   000000EC   020050E3           CMP      R0,#+2
   \   000000F0   0E00000A           BEQ      ??SC2410Uart_4
   \   000000F4   130000EA           B        ??SC2410Uart_5
     31          	case 0:
     32          		BitSubRx  = BIT_SUB_RXD0;
   \                     ??SC2410Uart_2:
   \   000000F8   0100A0E3           MOV      R0,#+1
   \   000000FC   E80084E5           STR      R0,[R4, #+232]
     33          		BitSubTx  = BIT_SUB_TXD0;
   \   00000100   0200A0E3           MOV      R0,#+2
   \   00000104   EC0084E5           STR      R0,[R4, #+236]
     34          		BitSubErr = BIT_SUB_ERR0;
   \   00000108   0400A0E3           MOV      R0,#+4
   \   0000010C   F00084E5           STR      R0,[R4, #+240]
   \   00000110   0C0000EA           B        ??SC2410Uart_5
     35          		break;
     36          	case 1:
     37          		BitSubRx  = BIT_SUB_RXD1;
   \                     ??SC2410Uart_3:
   \   00000114   0800A0E3           MOV      R0,#+8
   \   00000118   E80084E5           STR      R0,[R4, #+232]
     38          		BitSubTx  = BIT_SUB_TXD1;
   \   0000011C   1000A0E3           MOV      R0,#+16
   \   00000120   EC0084E5           STR      R0,[R4, #+236]
     39          		BitSubErr = BIT_SUB_ERR1;
   \   00000124   2000A0E3           MOV      R0,#+32
   \   00000128   F00084E5           STR      R0,[R4, #+240]
   \   0000012C   050000EA           B        ??SC2410Uart_5
     40          		break;
     41          	case 2:
     42          		BitSubRx  = BIT_SUB_RXD2;
   \                     ??SC2410Uart_4:
   \   00000130   4000A0E3           MOV      R0,#+64
   \   00000134   E80084E5           STR      R0,[R4, #+232]
     43          		BitSubTx  = BIT_SUB_TXD2;
   \   00000138   8000A0E3           MOV      R0,#+128
   \   0000013C   EC0084E5           STR      R0,[R4, #+236]
     44          		BitSubErr = BIT_SUB_ERR2;
   \   00000140   400FA0E3           MOV      R0,#+256
   \   00000144   F00084E5           STR      R0,[R4, #+240]
     45          		break;
     46          	}
     47          	{
     48          		unsigned PortOffset = 0x4000*PortNumber;
   \                     ??SC2410Uart_5:
   \   00000148   881094E5           LDR      R1,[R4, #+136]
   \   0000014C   402CA0E3           MOV      R2,#+16384
   \   00000150   920111E0           MULS     R1,R2,R1
   \   00000154   0100B0E1           MOVS     R0,R1
     49          		rTxReg          =(unsigned char*)(ADDR_UTXH0   + PortOffset);
   \   00000158   2010A0E3           MOV      R1,#+32
   \   0000015C   501481E3           ORR      R1,R1,#0x50000000
   \   00000160   001091E0           ADDS     R1,R1,R0
   \   00000164   001184E5           STR      R1,[R4, #+256]
     50          		rRxReg          =(unsigned char*)(ADDR_URXH0   + PortOffset);
   \   00000168   2410A0E3           MOV      R1,#+36
   \   0000016C   501481E3           ORR      R1,R1,#0x50000000
   \   00000170   001091E0           ADDS     R1,R1,R0
   \   00000174   FC1084E5           STR      R1,[R4, #+252]
     51          		rLineControl    =(unsigned*)(ADDR_ULCON0  + PortOffset);
   \   00000178   501490E2           ADDS     R1,R0,#+1342177280
   \   0000017C   041184E5           STR      R1,[R4, #+260]
     52          		rUartControl    =(unsigned*)(ADDR_UCON0   + PortOffset);
   \   00000180   451290E2           ADDS     R1,R0,#+1342177284
   \   00000184   081184E5           STR      R1,[R4, #+264]
     53          		rFIFOControl    =(unsigned*)(ADDR_UFCON0  + PortOffset);
   \   00000188   851290E2           ADDS     R1,R0,#+1342177288
   \   0000018C   0C1184E5           STR      R1,[R4, #+268]
     54          		rModemControl   =(unsigned*)(ADDR_UMCON0  + PortOffset);
   \   00000190   C51290E2           ADDS     R1,R0,#+1342177292
   \   00000194   101184E5           STR      R1,[R4, #+272]
     55          		rTxRxStatus     =(unsigned*)(ADDR_UTRSTAT0+ PortOffset);
   \   00000198   1010A0E3           MOV      R1,#+16
   \   0000019C   501481E3           ORR      R1,R1,#0x50000000
   \   000001A0   001091E0           ADDS     R1,R1,R0
   \   000001A4   141184E5           STR      R1,[R4, #+276]
     56          		rRxErrorStatus  =(unsigned*)(ADDR_UERSTAT0+ PortOffset);
   \   000001A8   1410A0E3           MOV      R1,#+20
   \   000001AC   501481E3           ORR      R1,R1,#0x50000000
   \   000001B0   001091E0           ADDS     R1,R1,R0
   \   000001B4   181184E5           STR      R1,[R4, #+280]
     57          		rFIFOStatus     =(unsigned*)(ADDR_UFSTAT0 + PortOffset);
   \   000001B8   1810A0E3           MOV      R1,#+24
   \   000001BC   501481E3           ORR      R1,R1,#0x50000000
   \   000001C0   001091E0           ADDS     R1,R1,R0
   \   000001C4   241184E5           STR      R1,[R4, #+292]
     58          		rModemStatus    =(unsigned*)(ADDR_UMSTAT0 + PortOffset);
   \   000001C8   1C10A0E3           MOV      R1,#+28
   \   000001CC   501481E3           ORR      R1,R1,#0x50000000
   \   000001D0   001091E0           ADDS     R1,R1,R0
   \   000001D4   1C1184E5           STR      R1,[R4, #+284]
     59          		rBaudRateDivisor=(unsigned*)(ADDR_UBRDIV0 + PortOffset);
   \   000001D8   2810A0E3           MOV      R1,#+40
   \   000001DC   501481E3           ORR      R1,R1,#0x50000000
   \   000001E0   000091E0           ADDS     R0,R1,R0
   \   000001E4   200184E5           STR      R0,[R4, #+288]
     60          	}
     61          
     62          	switch ( toupper(Parity) ) {
   \   000001E8   C800D4E5           LDRB     R0,[R4, #+200]
   \   000001EC   ........           _BLF     toupper,??toupper??rA
   \   000001F0   450050E3           CMP      R0,#+69
   \   000001F4   0200000A           BEQ      ??SC2410Uart_6
   \   000001F8   4F0050E3           CMP      R0,#+79
   \   000001FC   0300000A           BEQ      ??SC2410Uart_7
   \   00000200   050000EA           B        ??SC2410Uart_8
     63          	case 'E':
     64          		ParityValue = 0x07;
   \                     ??SC2410Uart_6:
   \   00000204   0700A0E3           MOV      R0,#+7
   \   00000208   C900C4E5           STRB     R0,[R4, #+201]
   \   0000020C   040000EA           B        ??SC2410Uart_9
     65          		break;
     66          	case 'O':
     67          		ParityValue = 0x04;
   \                     ??SC2410Uart_7:
   \   00000210   0400A0E3           MOV      R0,#+4
   \   00000214   C900C4E5           STRB     R0,[R4, #+201]
   \   00000218   010000EA           B        ??SC2410Uart_9
     68          		break;
     69          	default:
     70          	case 'N':
     71          		ParityValue = 0x00;
   \                     ??SC2410Uart_8:
   \   0000021C   0000A0E3           MOV      R0,#+0
   \   00000220   C900C4E5           STRB     R0,[R4, #+201]
     72          		break;
     73          	}
     74          	*rUartControl = 0x85;	// Rx timeout enable
   \                     ??SC2410Uart_9:
   \   00000224   080194E5           LDR      R0,[R4, #+264]
   \   00000228   8510A0E3           MOV      R1,#+133
   \   0000022C   001080E5           STR      R1,[R0, #+0]
     75          	*rLineControl =  (ParityValue<<3) | (WordLength-5) | (StopBits-1);
   \   00000230   040194E5           LDR      R0,[R4, #+260]
   \   00000234   C910D4E5           LDRB     R1,[R4, #+201]
   \   00000238   B82094E5           LDR      R2,[R4, #+184]
   \   0000023C   052052E2           SUBS     R2,R2,#+5
   \   00000240   811192E1           ORRS     R1,R2,R1, LSL #+3
   \   00000244   BC2094E5           LDR      R2,[R4, #+188]
   \   00000248   012052E2           SUBS     R2,R2,#+1
   \   0000024C   011092E1           ORRS     R1,R2,R1
   \   00000250   001080E5           STR      R1,[R0, #+0]
     76          	*rBaudRateDivisor = (OS_FSys/4)/(16*BaudRate)-1;
   \   00000254   202194E5           LDR      R2,[R4, #+288]
   \   00000258   A4009FE5           LDR      R0,??SC2410Uart_1+0x8  ;; OS_FSys
   \   0000025C   000090E5           LDR      R0,[R0, #+0]
   \   00000260   0410A0E3           MOV      R1,#+4
   \   00000264   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000268   0100B0E1           MOVS     R0,R1
   \   0000026C   B41094E5           LDR      R1,[R4, #+180]
   \   00000270   1030A0E3           MOV      R3,#+16
   \   00000274   930111E0           MULS     R1,R3,R1
   \   00000278   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   0000027C   010051E2           SUBS     R0,R1,#+1
   \   00000280   000082E5           STR      R0,[R2, #+0]
     77          	if ( HWProtocol == C_UART_HWPRO_485 ) {
   \   00000284   A80094E5           LDR      R0,[R4, #+168]
   \   00000288   4C10A0E3           MOV      R1,#+76
   \   0000028C   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000290   010050E1           CMP      R0,R1
   \   00000294   0600001A           BNE      ??SC2410Uart_10
     78          		// Turn off the RS485 if nothing to send on this interrupt
     79          		rGPHDAT &= ~2;
   \   00000298   7400A0E3           MOV      R0,#+116
   \   0000029C   560480E3           ORR      R0,R0,#0x56000000
   \   000002A0   7410A0E3           MOV      R1,#+116
   \   000002A4   561481E3           ORR      R1,R1,#0x56000000
   \   000002A8   001091E5           LDR      R1,[R1, #+0]
   \   000002AC   0210D1E3           BICS     R1,R1,#0x2
   \   000002B0   001080E5           STR      R1,[R0, #+0]
     80          	}
     81          	switch(SWProt){
   \                     ??SC2410Uart_10:
   \   000002B4   0600B0E1           MOVS     R0,R6
   \   000002B8   5810A0E3           MOV      R1,#+88
   \   000002BC   7C1D81E3           ORR      R1,R1,#0x1F00
   \   000002C0   010050E1           CMP      R0,R1
   \   000002C4   0300000A           BEQ      ??SC2410Uart_11
     82          	case C_UART_SWPRO_MODBUS:
     83          		//EnableFIFO(0,0);
     84          		break;
     85          	default:
     86          		EnableFIFO(0,12);
   \                     ??SC2410Uart_12:
   \   000002C8   0C20A0E3           MOV      R2,#+12
   \   000002CC   0010A0E3           MOV      R1,#+0
   \   000002D0   0400B0E1           MOVS     R0,R4
   \   000002D4   ........           BL       ??EnableFIFO
     87          		break;
     88          	}
     89          
     90          	EnableInt();
   \                     ??SC2410Uart_11:
   \   000002D8   E41094E5           LDR      R1,[R4, #+228]
   \   000002DC   0400B0E1           MOVS     R0,R4
   \   000002E0   001091E5           LDR      R1,[R1, #+0]
   \   000002E4   0FE0A0E1           MOV      LR,PC
   \   000002E8   11FF2FE1           BX       R1
     91          }
   \   000002EC   0400B0E1           MOVS     R0,R4
   \   000002F0   0CD08DE2           ADD      SP,SP,#+12       ;; stack cleaning
   \   000002F4   F04FBDE8           POP      {R4-R11,LR}
   \   000002F8   1EFF2FE1           BX       LR               ;; return
   \                     ??SC2410Uart_1:
   \   000002FC   ........           DC32     ??__vtbl
   \   00000300   ........           DC32     ??Channels
   \   00000304   ........           DC32     OS_FSys
     92          

   \                                 In segment CODE, align 4, keep-with-next
     93          void SC2410Uart::EnableInt(void)
     94          {
     95          	switch ( PortNumber ) {
   \                     ??EnableInt:
   \   00000000   881090E5           LDR      R1,[R0, #+136]
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0400000A           BEQ      ??EnableInt_1
   \   0000000C   010051E3           CMP      R1,#+1
   \   00000010   1100000A           BEQ      ??EnableInt_2
   \   00000014   020051E3           CMP      R1,#+2
   \   00000018   1E00000A           BEQ      ??EnableInt_3
   \   0000001C   2B0000EA           B        ??EnableInt_4
     96          	case 0:
     97          		rINTMSK    &= ~BIT_UART0;
   \                     ??EnableInt_1:
   \   00000020   0810A0E3           MOV      R1,#+8
   \   00000024   4A1481E3           ORR      R1,R1,#0x4A000000
   \   00000028   0820A0E3           MOV      R2,#+8
   \   0000002C   4A2482E3           ORR      R2,R2,#0x4A000000
   \   00000030   002092E5           LDR      R2,[R2, #+0]
   \   00000034   4025D2E3           BICS     R2,R2,#0x10000000
   \   00000038   002081E5           STR      R2,[R1, #+0]
     98          		rINTSUBMSK &= ~(BIT_SUB_TXD0 | BIT_SUB_RXD0);
   \   0000003C   1C10A0E3           MOV      R1,#+28
   \   00000040   4A1481E3           ORR      R1,R1,#0x4A000000
   \   00000044   1C20A0E3           MOV      R2,#+28
   \   00000048   4A2482E3           ORR      R2,R2,#0x4A000000
   \   0000004C   002092E5           LDR      R2,[R2, #+0]
   \   00000050   0320D2E3           BICS     R2,R2,#0x3
   \   00000054   002081E5           STR      R2,[R1, #+0]
   \   00000058   1C0000EA           B        ??EnableInt_4
     99          		break;
    100          	case 1:
    101          		rINTMSK    &= ~BIT_UART1;
   \                     ??EnableInt_2:
   \   0000005C   0810A0E3           MOV      R1,#+8
   \   00000060   4A1481E3           ORR      R1,R1,#0x4A000000
   \   00000064   0820A0E3           MOV      R2,#+8
   \   00000068   4A2482E3           ORR      R2,R2,#0x4A000000
   \   0000006C   002092E5           LDR      R2,[R2, #+0]
   \   00000070   8028D2E3           BICS     R2,R2,#0x800000
   \   00000074   002081E5           STR      R2,[R1, #+0]
    102          		rINTSUBMSK &= ~(BIT_SUB_TXD1 | BIT_SUB_RXD1);
   \   00000078   1C10A0E3           MOV      R1,#+28
   \   0000007C   4A1481E3           ORR      R1,R1,#0x4A000000
   \   00000080   1C20A0E3           MOV      R2,#+28
   \   00000084   4A2482E3           ORR      R2,R2,#0x4A000000
   \   00000088   002092E5           LDR      R2,[R2, #+0]
   \   0000008C   1820D2E3           BICS     R2,R2,#0x18
   \   00000090   002081E5           STR      R2,[R1, #+0]
   \   00000094   0D0000EA           B        ??EnableInt_4
    103          		break;
    104          	case 2:
    105          		rINTMSK    &= ~BIT_UART2;
   \                     ??EnableInt_3:
   \   00000098   0810A0E3           MOV      R1,#+8
   \   0000009C   4A1481E3           ORR      R1,R1,#0x4A000000
   \   000000A0   0820A0E3           MOV      R2,#+8
   \   000000A4   4A2482E3           ORR      R2,R2,#0x4A000000
   \   000000A8   002092E5           LDR      R2,[R2, #+0]
   \   000000AC   802CD2E3           BICS     R2,R2,#0x8000
   \   000000B0   002081E5           STR      R2,[R1, #+0]
    106          		rINTSUBMSK &= ~(BIT_SUB_TXD2 | BIT_SUB_RXD2);
   \   000000B4   1C10A0E3           MOV      R1,#+28
   \   000000B8   4A1481E3           ORR      R1,R1,#0x4A000000
   \   000000BC   1C20A0E3           MOV      R2,#+28
   \   000000C0   4A2482E3           ORR      R2,R2,#0x4A000000
   \   000000C4   002092E5           LDR      R2,[R2, #+0]
   \   000000C8   C020D2E3           BICS     R2,R2,#0xC0
   \   000000CC   002081E5           STR      R2,[R1, #+0]
    107          		break;
    108          	default:
    109          		break;
    110          
    111          	}
    112          }
   \                     ??EnableInt_4:
   \   000000D0   1EFF2FE1           BX       LR               ;; return
    113          
    114          
    115          /******************************************************************************
    116          *
    117          *   EnableFIFO
    118          */
    119          

   \                                 In segment CODE, align 4, keep-with-next
    120          void SC2410Uart::EnableFIFO(int TxTrigger, int RxTrigger)
    121          {
   \                     ??EnableFIFO:
   \   00000000   30002DE9           PUSH     {R4,R5}
    122          	unsigned RxTmpTrigger=0,TxTmpTrigger=0;
   \   00000004   0040A0E3           MOV      R4,#+0
   \   00000008   0430B0E1           MOVS     R3,R4
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   04C0B0E1           MOVS     R12,R4
    123          	switch ( TxTrigger ) {
   \   00000014   0140B0E1           MOVS     R4,R1
   \   00000018   040054E3           CMP      R4,#+4
   \   0000001C   0600000A           BEQ      ??EnableFIFO_1
   \   00000020   080054E3           CMP      R4,#+8
   \   00000024   0700000A           BEQ      ??EnableFIFO_2
   \   00000028   0C0054E3           CMP      R4,#+12
   \   0000002C   0800000A           BEQ      ??EnableFIFO_3
    124          	default:
    125          	case  0: TxTmpTrigger= 0x00; break;
   \                     ??EnableFIFO_4:
   \   00000030   0040A0E3           MOV      R4,#+0
   \   00000034   04C0B0E1           MOVS     R12,R4
   \   00000038   070000EA           B        ??EnableFIFO_5
    126          	case  4: TxTmpTrigger= 0x01; break;
   \                     ??EnableFIFO_1:
   \   0000003C   0140A0E3           MOV      R4,#+1
   \   00000040   04C0B0E1           MOVS     R12,R4
   \   00000044   040000EA           B        ??EnableFIFO_5
    127          	case  8: TxTmpTrigger= 0x02; break;
   \                     ??EnableFIFO_2:
   \   00000048   0240A0E3           MOV      R4,#+2
   \   0000004C   04C0B0E1           MOVS     R12,R4
   \   00000050   010000EA           B        ??EnableFIFO_5
    128          	case 12: TxTmpTrigger= 0x03; break;
   \                     ??EnableFIFO_3:
   \   00000054   0340A0E3           MOV      R4,#+3
   \   00000058   04C0B0E1           MOVS     R12,R4
    129          	}
    130          	switch ( RxTrigger ) {
   \                     ??EnableFIFO_5:
   \   0000005C   0240B0E1           MOVS     R4,R2
   \   00000060   080054E3           CMP      R4,#+8
   \   00000064   0600000A           BEQ      ??EnableFIFO_6
   \   00000068   0C0054E3           CMP      R4,#+12
   \   0000006C   0700000A           BEQ      ??EnableFIFO_7
   \   00000070   100054E3           CMP      R4,#+16
   \   00000074   0800000A           BEQ      ??EnableFIFO_8
    131          	default:
    132          	case  4: RxTmpTrigger= 0x00; break;
   \                     ??EnableFIFO_9:
   \   00000078   0040A0E3           MOV      R4,#+0
   \   0000007C   0430B0E1           MOVS     R3,R4
   \   00000080   070000EA           B        ??EnableFIFO_10
    133          	case  8: RxTmpTrigger= 0x01; break;
   \                     ??EnableFIFO_6:
   \   00000084   0140A0E3           MOV      R4,#+1
   \   00000088   0430B0E1           MOVS     R3,R4
   \   0000008C   040000EA           B        ??EnableFIFO_10
    134          	case 12: RxTmpTrigger= 0x02; break;
   \                     ??EnableFIFO_7:
   \   00000090   0240A0E3           MOV      R4,#+2
   \   00000094   0430B0E1           MOVS     R3,R4
   \   00000098   010000EA           B        ??EnableFIFO_10
    135          	case 16: RxTmpTrigger= 0x03; break;
   \                     ??EnableFIFO_8:
   \   0000009C   0340A0E3           MOV      R4,#+3
   \   000000A0   0430B0E1           MOVS     R3,R4
    136          	}
    137          	*rFIFOControl = (TxTmpTrigger << 6) | (RxTmpTrigger << 4 ) | 1;
   \                     ??EnableFIFO_10:
   \   000000A4   0C4190E5           LDR      R4,[R0, #+268]
   \   000000A8   0352B0E1           LSLS     R5,R3,#+4
   \   000000AC   0C5395E1           ORRS     R5,R5,R12, LSL #+6
   \   000000B0   015095E3           ORRS     R5,R5,#0x1
   \   000000B4   005084E5           STR      R5,[R4, #+0]
    138          
    139          	TxFIFOSize = 16-TxTrigger;
   \   000000B8   104071E2           RSBS     R4,R1,#+16
   \   000000BC   204080E5           STR      R4,[R0, #+32]
    140          	RxFIFOSize = RxTrigger;
   \   000000C0   242080E5           STR      R2,[R0, #+36]
    141          }
   \   000000C4   3000BDE8           POP      {R4,R5}
   \   000000C8   1EFF2FE1           BX       LR               ;; return
    142          
    143          
    144          
    145          /*******************************************************************************
    146          *
    147          * IntWr - handle a transmitter interrupt
    148          *
    149          * This routine handles write interrupts from the UART. It reads a character
    150          * and puts it in the transmit holding register of the device for transfer.
    151          *
    152          * If there are no more characters to transmit, transmission is disabled by
    153          * clearing the transmit interrupt enable bit in the IER(int enable register).
    154          *
    155          * RETURNS: N/A
    156          *
    157          */
    158          

   \                                 In segment CODE, align 4, keep-with-next
    159          void SC2410Uart::Transmit(void)
    160          {
   \                     ??Transmit:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    161          
    162          	bool SomeDataSent = false;
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   0050B0E1           MOVS     R5,R0
    163          	if ( TxDataPtr ) {
   \   00000010   2C0094E5           LDR      R0,[R4, #+44]
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1600000A           BEQ      ??Transmit_1
    164          		for ( int i=0; i < TxFIFOSize && TxDataPos < TxDataSize; i++ ) {
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0100B0E1           MOVS     R0,R1
   \                     ??Transmit_2:
   \   00000024   201094E5           LDR      R1,[R4, #+32]
   \   00000028   010050E1           CMP      R0,R1
   \   0000002C   110000AA           BGE      ??Transmit_1
   \   00000030   441094E5           LDR      R1,[R4, #+68]
   \   00000034   302094E5           LDR      R2,[R4, #+48]
   \   00000038   020051E1           CMP      R1,R2
   \   0000003C   0D0000AA           BGE      ??Transmit_1
    165          			*rTxReg = TxDataPtr[TxDataPos++];
   \   00000040   441094E5           LDR      R1,[R4, #+68]
   \   00000044   012091E2           ADDS     R2,R1,#+1
   \   00000048   442084E5           STR      R2,[R4, #+68]
   \   0000004C   002194E5           LDR      R2,[R4, #+256]
   \   00000050   2C3094E5           LDR      R3,[R4, #+44]
   \   00000054   0310D1E7           LDRB     R1,[R1, +R3]
   \   00000058   0010C2E5           STRB     R1,[R2, #+0]
    166          			TxByteCnt++;
   \   0000005C   D81094E5           LDR      R1,[R4, #+216]
   \   00000060   011091E2           ADDS     R1,R1,#+1
   \   00000064   D81084E5           STR      R1,[R4, #+216]
    167          			SomeDataSent = true;
   \   00000068   0110A0E3           MOV      R1,#+1
   \   0000006C   0150B0E1           MOVS     R5,R1
    168          		}
   \   00000070   010090E2           ADDS     R0,R0,#+1
   \   00000074   EAFFFFEA           B        ??Transmit_2
    169          	}
    170          	if ( !SomeDataSent ) {
   \                     ??Transmit_1:
   \   00000078   000055E3           CMP      R5,#+0
   \   0000007C   1D00001A           BNE      ??Transmit_3
    171          		if ( HWProtocol == C_UART_HWPRO_485 ) {
   \   00000080   A80094E5           LDR      R0,[R4, #+168]
   \   00000084   4C10A0E3           MOV      R1,#+76
   \   00000088   7C1D81E3           ORR      R1,R1,#0x1F00
   \   0000008C   010050E1           CMP      R0,R1
   \   00000090   0D00001A           BNE      ??Transmit_4
    172          			switch (SWProtocol) {
   \   00000094   AC0094E5           LDR      R0,[R4, #+172]
   \   00000098   5710A0E3           MOV      R1,#+87
   \   0000009C   7C1D81E3           ORR      R1,R1,#0x1F00
   \   000000A0   010050E1           CMP      R0,R1
   \   000000A4   0800001A           BNE      ??Transmit_4
    173          			case C_UART_SWPRO_ANPRO10:
    174          				// Turn off the RS485 if nothing to send on this interrupt
    175          				rGPHDAT &= ~2;
   \                     ??Transmit_5:
   \   000000A8   7400A0E3           MOV      R0,#+116
   \   000000AC   560480E3           ORR      R0,R0,#0x56000000
   \   000000B0   7410A0E3           MOV      R1,#+116
   \   000000B4   561481E3           ORR      R1,R1,#0x56000000
   \   000000B8   001091E5           LDR      R1,[R1, #+0]
   \   000000BC   0210D1E3           BICS     R1,R1,#0x2
   \   000000C0   001080E5           STR      R1,[R0, #+0]
    176          				ProtocolState = pNew_Sync;
   \   000000C4   0400A0E3           MOV      R0,#+4
   \   000000C8   4800C4E5           STRB     R0,[R4, #+72]
    177          				break;
    178          			default:
    179          				break;
    180          			}
    181          		}
    182          		if ( TxTaskPtr ) {
   \                     ??Transmit_4:
   \   000000CC   400094E5           LDR      R0,[R4, #+64]
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   0700000A           BEQ      ??Transmit_3
    183          			if ( EventMask ) {
   \   000000D8   3C00D4E5           LDRB     R0,[R4, #+60]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   0200000A           BEQ      ??Transmit_6
    184          				OS_SignalEvent(EventMask,(TSN_TASK*)TxTaskPtr);
   \   000000E4   401094E5           LDR      R1,[R4, #+64]
   \   000000E8   3C00D4E5           LDRB     R0,[R4, #+60]
   \   000000EC   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
    185          			}
    186          			TxTaskPtr = NULL;
   \                     ??Transmit_6:
   \   000000F0   0000A0E3           MOV      R0,#+0
   \   000000F4   400084E5           STR      R0,[R4, #+64]
    187          		}
    188          	}
    189          }
   \                     ??Transmit_3:
   \   000000F8   3040BDE8           POP      {R4,R5,LR}
   \   000000FC   1EFF2FE1           BX       LR               ;; return
    190          
    191          /*******************************************************************************
    192          *
    193          * Tsn16550IntRd - handle a  receiver interrupt
    194          *
    195          * This routine handles read interrupts from the UART.
    196          *
    197          * RETURNS: N/A
    198          *
    199          */
    200          

   \                                 In segment CODE, align 4, keep-with-next
    201          void SC2410Uart::Receive(void){
   \                     ??Receive_1:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040B0E1           MOVS     R4,R0
    202          	/* read character from Receive Holding Reg.                 */
    203          	/* I will allways read rx register and push it on the stack */
    204          	if ( RxFIFOSize > 1 ) {
   \   0000000C   240094E5           LDR      R0,[R4, #+36]
   \   00000010   020050E3           CMP      R0,#+2
   \   00000014   1A0000BA           BLT      ??Receive_2
    205          		if ( *rFIFOStatus & 0x100 ) {
   \   00000018   240194E5           LDR      R0,[R4, #+292]
   \   0000001C   000090E5           LDR      R0,[R0, #+0]
   \   00000020   400F10E3           TST      R0,#0x100
   \   00000024   0500000A           BEQ      ??Receive_3
    206          			*rFIFOControl |= 0x2;
   \   00000028   0C0194E5           LDR      R0,[R4, #+268]
   \   0000002C   0C1194E5           LDR      R1,[R4, #+268]
   \   00000030   001091E5           LDR      R1,[R1, #+0]
   \   00000034   021091E3           ORRS     R1,R1,#0x2
   \   00000038   001080E5           STR      R1,[R0, #+0]
   \   0000003C   170000EA           B        ??Receive_4
    207          		} else {
    208          			int Cnt = *rFIFOStatus & 0x0F;
   \                     ??Receive_3:
   \   00000040   240194E5           LDR      R0,[R4, #+292]
   \   00000044   000090E5           LDR      R0,[R0, #+0]
   \   00000048   0F0010E2           ANDS     R0,R0,#0xF
   \   0000004C   0050B0E1           MOVS     R5,R0
    209          			while ( Cnt >0 ) {
   \                     ??Receive_5:
   \   00000050   010055E3           CMP      R5,#+1
   \   00000054   110000BA           BLT      ??Receive_4
    210          				char RxData = *rRxReg;
   \   00000058   FC1094E5           LDR      R1,[R4, #+252]
   \   0000005C   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000060   0110CDE5           STRB     R1,[SP, #+1]
    211          				OS_PutMailCond1(&RxBuf,&RxData);
   \   00000064   01108DE2           ADD      R1,SP,#+1
   \   00000068   0400B0E1           MOVS     R0,R4
   \   0000006C   ........           _BLF     OS_PutMailCond1,??OS_PutMailCond1??rA
    212          				RxByteCnt++;
   \   00000070   D40094E5           LDR      R0,[R4, #+212]
   \   00000074   010090E2           ADDS     R0,R0,#+1
   \   00000078   D40084E5           STR      R0,[R4, #+212]
    213          				Cnt--;
   \   0000007C   015055E2           SUBS     R5,R5,#+1
   \   00000080   F2FFFFEA           B        ??Receive_5
    214          			}
    215          		}
    216          	} else {
    217          		char RxData = *rRxReg;
   \                     ??Receive_2:
   \   00000084   FC1094E5           LDR      R1,[R4, #+252]
   \   00000088   0010D1E5           LDRB     R1,[R1, #+0]
   \   0000008C   0010CDE5           STRB     R1,[SP, #+0]
    218          		char Status = OS_PutMailCond1(&RxBuf,&RxData);
   \   00000090   0D10B0E1           MOVS     R1,SP
   \   00000094   0400B0E1           MOVS     R0,R4
   \   00000098   ........           _BLF     OS_PutMailCond1,??OS_PutMailCond1??rA
   \   0000009C   0050B0E1           MOVS     R5,R0
    219          	}
    220          	LastRxTime      = (int)OS_Time;
   \                     ??Receive_4:
   \   000000A0   10009FE5           LDR      R0,??Receive_6   ;; OS_Time
   \   000000A4   000090E5           LDR      R0,[R0, #+0]
   \   000000A8   4C0084E5           STR      R0,[R4, #+76]
    221          }
   \   000000AC   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000B0   3040BDE8           POP      {R4,R5,LR}
   \   000000B4   1EFF2FE1           BX       LR               ;; return
   \                     ??Receive_6:
   \   000000B8   ........           DC32     OS_Time
    222          
    223          
    224          /*******************************************************************************
    225          *
    226          * Tsn16550Int - handle a receiver/transmitter interrupt
    227          *
    228          * This routine handles four sources of interrupts from the UART. They are
    229          * prioritized in the following order by the Interrupt Identification Register:
    230          * Receiver Line Status, Received Data Ready, Transmit Holding Register Empty
    231          * and Modem Status.
    232          *
    233          * If there is another character to be transmitted, it sends it.  If
    234          * not, or if a device has never been created for this channel, just
    235          * disable the interrupt.
    236          * When a modem status interrupt occurs, the transmit interrupt is enabled if
    237          * the CTS signal is TRUE.
    238          *
    239          * RETURNS: N/A
    240          */
    241          

   \                                 In segment CODE, align 4, keep-with-next
    242          void SC2410Uart::HandleInterrupt(void)
    243          {
   \                     ??HandleInterrupt:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    244          	unsigned IntSubSource = rSUBSRCPND;
   \   00000008   1800A0E3           MOV      R0,#+24
   \   0000000C   4A0480E3           ORR      R0,R0,#0x4A000000
   \   00000010   000090E5           LDR      R0,[R0, #+0]
   \   00000014   0050B0E1           MOVS     R5,R0
    245          	unsigned InsSubMask   = rINTSUBMSK;
   \   00000018   1C00A0E3           MOV      R0,#+28
   \   0000001C   4A0480E3           ORR      R0,R0,#0x4A000000
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   0060B0E1           MOVS     R6,R0
    246          
    247          	if ( IntSubSource & BitSubErr ) {
   \   00000028   F00094E5           LDR      R0,[R4, #+240]
   \   0000002C   050010E1           TST      R0,R5
   \   00000030   0300000A           BEQ      ??HandleInterrupt_1
    248          		// Do nothing for now
    249          		rSUBSRCPND = BitSubErr;
   \   00000034   1800A0E3           MOV      R0,#+24
   \   00000038   4A0480E3           ORR      R0,R0,#0x4A000000
   \   0000003C   F01094E5           LDR      R1,[R4, #+240]
   \   00000040   001080E5           STR      R1,[R0, #+0]
    250          	}
    251          	if ( IntSubSource & BitSubRx ) {
   \                     ??HandleInterrupt_1:
   \   00000044   E80094E5           LDR      R0,[R4, #+232]
   \   00000048   050010E1           TST      R0,R5
   \   0000004C   0900000A           BEQ      ??HandleInterrupt_2
    252          		// rUTXH1 = rURXH1;
    253          		Receive();
   \   00000050   E40094E5           LDR      R0,[R4, #+228]
   \   00000054   0C1090E2           ADDS     R1,R0,#+12
   \   00000058   0400B0E1           MOVS     R0,R4
   \   0000005C   001091E5           LDR      R1,[R1, #+0]
   \   00000060   0FE0A0E1           MOV      LR,PC
   \   00000064   11FF2FE1           BX       R1
    254          		rSUBSRCPND = BitSubRx;
   \   00000068   1800A0E3           MOV      R0,#+24
   \   0000006C   4A0480E3           ORR      R0,R0,#0x4A000000
   \   00000070   E81094E5           LDR      R1,[R4, #+232]
   \   00000074   001080E5           STR      R1,[R0, #+0]
    255          	}
    256          	if ( IntSubSource & BitSubTx ) {
   \                     ??HandleInterrupt_2:
   \   00000078   EC0094E5           LDR      R0,[R4, #+236]
   \   0000007C   050010E1           TST      R0,R5
   \   00000080   0900000A           BEQ      ??HandleInterrupt_3
    257          		Transmit();
   \   00000084   E40094E5           LDR      R0,[R4, #+228]
   \   00000088   1C1090E2           ADDS     R1,R0,#+28
   \   0000008C   0400B0E1           MOVS     R0,R4
   \   00000090   001091E5           LDR      R1,[R1, #+0]
   \   00000094   0FE0A0E1           MOV      LR,PC
   \   00000098   11FF2FE1           BX       R1
    258          		rSUBSRCPND = BitSubTx;
   \   0000009C   1800A0E3           MOV      R0,#+24
   \   000000A0   4A0480E3           ORR      R0,R0,#0x4A000000
   \   000000A4   EC1094E5           LDR      R1,[R4, #+236]
   \   000000A8   001080E5           STR      R1,[R0, #+0]
    259          	}
    260          }
   \                     ??HandleInterrupt_3:
   \   000000AC   7040BDE8           POP      {R4-R6,LR}
   \   000000B0   1EFF2FE1           BX       LR               ;; return
    261          

   \                                 In segment CODE, align 4, keep-with-next
    262          void SC2410Uart::ActivateTx(void)
    263          {
   \                     ??ActivateTx:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    264          	rGPHDAT  |= 2;
   \   00000008   7400A0E3           MOV      R0,#+116
   \   0000000C   560480E3           ORR      R0,R0,#0x56000000
   \   00000010   7410A0E3           MOV      R1,#+116
   \   00000014   561481E3           ORR      R1,R1,#0x56000000
   \   00000018   001091E5           LDR      R1,[R1, #+0]
   \   0000001C   021091E3           ORRS     R1,R1,#0x2
   \   00000020   001080E5           STR      R1,[R0, #+0]
    265          	switch (SWProtocol) {
   \   00000024   AC0094E5           LDR      R0,[R4, #+172]
   \   00000028   5710A0E3           MOV      R1,#+87
   \   0000002C   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000030   010050E1           CMP      R0,R1
   \   00000034   0500001A           BNE      ??ActivateTx_1
    266          	case C_UART_SWPRO_ANPRO10:
    267          		TxDataPtr[TxDataSize++] = 0x0;
   \                     ??ActivateTx_2:
   \   00000038   300094E5           LDR      R0,[R4, #+48]
   \   0000003C   011090E2           ADDS     R1,R0,#+1
   \   00000040   301084E5           STR      R1,[R4, #+48]
   \   00000044   2C1094E5           LDR      R1,[R4, #+44]
   \   00000048   0020A0E3           MOV      R2,#+0
   \   0000004C   0120C0E7           STRB     R2,[R0, +R1]
    268          		break;
    269          	default:
    270          		break;
    271          	}
    272          	ProtocolState = pInTx;
   \                     ??ActivateTx_1:
   \   00000050   0200A0E3           MOV      R0,#+2
   \   00000054   4800C4E5           STRB     R0,[R4, #+72]
    273          	OS_Delay(RS485_ON_DELAY);
   \   00000058   0200A0E3           MOV      R0,#+2
   \   0000005C   ........           _BLF     OS_Delay,??OS_Delay??rA
    274          	*rTxReg = TxDataPtr[TxDataPos++];
   \   00000060   440094E5           LDR      R0,[R4, #+68]
   \   00000064   011090E2           ADDS     R1,R0,#+1
   \   00000068   441084E5           STR      R1,[R4, #+68]
   \   0000006C   001194E5           LDR      R1,[R4, #+256]
   \   00000070   2C2094E5           LDR      R2,[R4, #+44]
   \   00000074   0200D0E7           LDRB     R0,[R0, +R2]
   \   00000078   0000C1E5           STRB     R0,[R1, #+0]
    275          }
   \   0000007C   1040BDE8           POP      {R4,LR}
   \   00000080   1EFF2FE1           BX       LR               ;; return
    276          

   \                                 In segment CODE, align 4, keep-with-next
    277          void SC2410Uart::DeactivateTx(void)
    278          {
    279          	// Turn off the RS485
    280              if ( HWProtocol == C_UART_HWPRO_485 ){
   \                     ??DeactivateTx:
   \   00000000   A81090E5           LDR      R1,[R0, #+168]
   \   00000004   4C20A0E3           MOV      R2,#+76
   \   00000008   7C2D82E3           ORR      R2,R2,#0x1F00
   \   0000000C   020051E1           CMP      R1,R2
   \   00000010   0600001A           BNE      ??DeactivateTx_1
    281                  rGPHDAT &= ~2;
   \   00000014   7410A0E3           MOV      R1,#+116
   \   00000018   561481E3           ORR      R1,R1,#0x56000000
   \   0000001C   7420A0E3           MOV      R2,#+116
   \   00000020   562482E3           ORR      R2,R2,#0x56000000
   \   00000024   002092E5           LDR      R2,[R2, #+0]
   \   00000028   0220D2E3           BICS     R2,R2,#0x2
   \   0000002C   002081E5           STR      R2,[R1, #+0]
    282              }
    283          }
   \                     ??DeactivateTx_1:
   \   00000030   1EFF2FE1           BX       LR               ;; return
    284          
    285          

   \                                 In segment CODE, align 4, keep-with-next
    286          bool SC2410Uart::Send(U8* MyData, int Size, char EventMsk, bool Wait)
    287          {
   \                     ??Send:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
   \   00000010   0370B0E1           MOVS     R7,R3
   \   00000014   2480DDE5           LDRB     R8,[SP, #+36]
    288          	bool TxOk = false;
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   0090B0E1           MOVS     R9,R0
    289          	if ( !Size ) return true;
   \   00000020   000056E3           CMP      R6,#+0
   \   00000024   0100001A           BNE      ??Send_1
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   7E0000EA           B        ??Send_2
    290          	OS_Use(&TxSema);
   \                     ??Send_1:
   \   00000030   740094E2           ADDS     R0,R4,#+116
   \   00000034   ........           _BLF     OS_Use,??OS_Use??rA
    291          	TxDataPtr   = MyData;
   \   00000038   2C5084E5           STR      R5,[R4, #+44]
    292          	TxDataSize  = Size;
   \   0000003C   306084E5           STR      R6,[R4, #+48]
    293          	TxDataPos   = 0;
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   440084E5           STR      R0,[R4, #+68]
    294          
    295          	if ( Size ) {
   \   00000048   000056E3           CMP      R6,#+0
   \   0000004C   7400000A           BEQ      ??Send_3
    296          		EventMask = EventMsk;
   \   00000050   3C70C4E5           STRB     R7,[R4, #+60]
    297          		if ( EventMsk ) {
   \   00000054   000057E3           CMP      R7,#+0
   \   00000058   0300000A           BEQ      ??Send_4
    298          			TxTaskPtr = OS_GetpCurrentTask();
   \   0000005C   D0019FE5           LDR      R0,??Send_5      ;; OS_pCurrentTask
   \   00000060   000090E5           LDR      R0,[R0, #+0]
   \   00000064   400084E5           STR      R0,[R4, #+64]
   \   00000068   010000EA           B        ??Send_6
    299          		} else {
    300          			TxTaskPtr = NULL;
   \                     ??Send_4:
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   400084E5           STR      R0,[R4, #+64]
    301          		}
    302          		int Delay=(13000*TxDataSize)/BaudRate+RS485_EXTRA_DELAY;
   \                     ??Send_6:
   \   00000074   300094E5           LDR      R0,[R4, #+48]
   \   00000078   C810A0E3           MOV      R1,#+200
   \   0000007C   C81D81E3           ORR      R1,R1,#0x3200
   \   00000080   910010E0           MULS     R0,R1,R0
   \   00000084   B41094E5           LDR      R1,[R4, #+180]
   \   00000088   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   0000008C   020091E2           ADDS     R0,R1,#+2
   \   00000090   00A0B0E1           MOVS     R10,R0
    303          		switch ( HWProtocol ) {
   \   00000094   A80094E5           LDR      R0,[R4, #+168]
   \   00000098   4B10A0E3           MOV      R1,#+75
   \   0000009C   7C1D81E3           ORR      R1,R1,#0x1F00
   \   000000A0   010050E1           CMP      R0,R1
   \   000000A4   2F00000A           BEQ      ??Send_7
   \   000000A8   4C10A0E3           MOV      R1,#+76
   \   000000AC   7C1D81E3           ORR      R1,R1,#0x1F00
   \   000000B0   010050E1           CMP      R0,R1
   \   000000B4   3200001A           BNE      ??Send_8
    304          		case C_UART_HWPRO_485 :
    305          			switch (SWProtocol) {
   \                     ??Send_9:
   \   000000B8   AC0094E5           LDR      R0,[R4, #+172]
   \   000000BC   5710A0E3           MOV      R1,#+87
   \   000000C0   7C1D81E3           ORR      R1,R1,#0x1F00
   \   000000C4   010050E1           CMP      R0,R1
   \   000000C8   1F00001A           BNE      ??Send_10
    306          			case C_UART_SWPRO_ANPRO10:
    307          				if ( IsMaster ) {
   \                     ??Send_11:
   \   000000CC   3400D4E5           LDRB     R0,[R4, #+52]
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   1100000A           BEQ      ??Send_12
    308          					// Asume we have to force the tx if TxRequest = true!
    309          					if ( TxRequest || ProtocolState == pNew_Sync ) {
   \   000000D8   4900D4E5           LDRB     R0,[R4, #+73]
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   0200001A           BNE      ??Send_13
   \   000000E4   4800D4E5           LDRB     R0,[R4, #+72]
   \   000000E8   040050E3           CMP      R0,#+4
   \   000000EC   0800001A           BNE      ??Send_14
    310          						TxRequest = false;
   \                     ??Send_13:
   \   000000F0   0000A0E3           MOV      R0,#+0
   \   000000F4   4900C4E5           STRB     R0,[R4, #+73]
    311           						ActivateTx();
   \   000000F8   E40094E5           LDR      R0,[R4, #+228]
   \   000000FC   141090E2           ADDS     R1,R0,#+20
   \   00000100   0400B0E1           MOVS     R0,R4
   \   00000104   001091E5           LDR      R1,[R1, #+0]
   \   00000108   0FE0A0E1           MOV      LR,PC
   \   0000010C   11FF2FE1           BX       R1
   \   00000110   1B0000EA           B        ??Send_8
    312          					} else {
    313          						TxRequest = true;
   \                     ??Send_14:
   \   00000114   0100A0E3           MOV      R0,#+1
   \   00000118   4900C4E5           STRB     R0,[R4, #+73]
   \   0000011C   180000EA           B        ??Send_8
    314          					}
    315          				} else {
    316          					TxRequest  = true;
   \                     ??Send_12:
   \   00000120   0100A0E3           MOV      R0,#+1
   \   00000124   4900C4E5           STRB     R0,[R4, #+73]
    317          					if (LastRxTime < 10 ) {
   \   00000128   4C0094E5           LDR      R0,[R4, #+76]
   \   0000012C   0A0050E3           CMP      R0,#+10
   \   00000130   030000AA           BGE      ??Send_15
    318          						Delay     += RS485_DELAY; // Abort Tx if not completed within this time
   \   00000134   C8A09AE2           ADDS     R10,R10,#+200
    319          						ActivateIfTxRequest();
   \   00000138   0400B0E1           MOVS     R0,R4
   \   0000013C   ........           _BLF     ??ActivateIfTxRequest,??ActivateIfTxRequest??rA
   \   00000140   0F0000EA           B        ??Send_8
    320          					} else {
    321          						Delay     += RS485_DELAY+1000; // Abort Tx if not completed within this time
   \                     ??Send_15:
   \   00000144   4BAE9AE2           ADDS     R10,R10,#+1200
   \   00000148   0D0000EA           B        ??Send_8
    322          					}
    323          				}
    324          				break;
    325          			default:
    326          				ActivateTx();
   \                     ??Send_10:
   \   0000014C   E40094E5           LDR      R0,[R4, #+228]
   \   00000150   141090E2           ADDS     R1,R0,#+20
   \   00000154   0400B0E1           MOVS     R0,R4
   \   00000158   001091E5           LDR      R1,[R1, #+0]
   \   0000015C   0FE0A0E1           MOV      LR,PC
   \   00000160   11FF2FE1           BX       R1
   \   00000164   060000EA           B        ??Send_8
    327          				break;
    328          			}
    329          			break;
    330          		case C_UART_HWPRO_232 :
    331          			*rTxReg = TxDataPtr[TxDataPos++];
   \                     ??Send_7:
   \   00000168   440094E5           LDR      R0,[R4, #+68]
   \   0000016C   011090E2           ADDS     R1,R0,#+1
   \   00000170   441084E5           STR      R1,[R4, #+68]
   \   00000174   001194E5           LDR      R1,[R4, #+256]
   \   00000178   2C2094E5           LDR      R2,[R4, #+44]
   \   0000017C   0200D0E7           LDRB     R0,[R0, +R2]
   \   00000180   0000C1E5           STRB     R0,[R1, #+0]
    332          			break;
    333          
    334          		}
    335          		if ( Wait && EventMsk ) {
   \                     ??Send_8:
   \   00000184   000058E3           CMP      R8,#+0
   \   00000188   0D00000A           BEQ      ??Send_16
   \   0000018C   000057E3           CMP      R7,#+0
   \   00000190   0B00000A           BEQ      ??Send_16
    336          			char Status = OS_WaitEventTimed(EventMsk,Delay);
   \   00000194   0A10B0E1           MOVS     R1,R10
   \   00000198   0700B0E1           MOVS     R0,R7
   \   0000019C   ........           _BLF     OS_WaitEventTimed,??OS_WaitEventTimed??rA
   \   000001A0   00B0B0E1           MOVS     R11,R0
    337          			TxTaskPtr = NULL;
   \   000001A4   0000A0E3           MOV      R0,#+0
   \   000001A8   400084E5           STR      R0,[R4, #+64]
    338          			TxOk =(Status==EventMsk);
   \   000001AC   07005BE1           CMP      R11,R7
   \   000001B0   0100001A           BNE      ??Send_17
   \   000001B4   0190A0E3           MOV      R9,#+1
   \   000001B8   000000EA           B        ??Send_18
   \                     ??Send_17:
   \   000001BC   0090A0E3           MOV      R9,#+0
   \                     ??Send_18:
   \   000001C0   010000EA           B        ??Send_19
    339          		} else {
    340          			TxOk = true;
   \                     ??Send_16:
   \   000001C4   0100A0E3           MOV      R0,#+1
   \   000001C8   0090B0E1           MOVS     R9,R0
    341          		}
    342          		if ( HWProtocol == C_UART_HWPRO_485 ) {
   \                     ??Send_19:
   \   000001CC   A80094E5           LDR      R0,[R4, #+168]
   \   000001D0   4C10A0E3           MOV      R1,#+76
   \   000001D4   7C1D81E3           ORR      R1,R1,#0x1F00
   \   000001D8   010050E1           CMP      R0,R1
   \   000001DC   0E00001A           BNE      ??Send_20
    343          			switch (SWProtocol) {
   \   000001E0   AC0094E5           LDR      R0,[R4, #+172]
   \   000001E4   5710A0E3           MOV      R1,#+87
   \   000001E8   7C1D81E3           ORR      R1,R1,#0x1F00
   \   000001EC   010050E1           CMP      R0,R1
   \   000001F0   0900000A           BEQ      ??Send_20
    344          			case C_UART_SWPRO_ANPRO10:
    345          				break;
    346          			default:
    347          				OS_Delay(2);
   \                     ??Send_21:
   \   000001F4   0200A0E3           MOV      R0,#+2
   \   000001F8   ........           _BLF     OS_Delay,??OS_Delay??rA
    348                          DeactivateTx();
   \   000001FC   E40094E5           LDR      R0,[R4, #+228]
   \   00000200   181090E2           ADDS     R1,R0,#+24
   \   00000204   0400B0E1           MOVS     R0,R4
   \   00000208   001091E5           LDR      R1,[R1, #+0]
   \   0000020C   0FE0A0E1           MOV      LR,PC
   \   00000210   11FF2FE1           BX       R1
    349          				ProtocolState = pNew_Sync;
   \   00000214   0400A0E3           MOV      R0,#+4
   \   00000218   4800C4E5           STRB     R0,[R4, #+72]
    350          				break;
    351          			}
    352          		}
    353          		OS_Unuse(&TxSema);
   \                     ??Send_20:
   \   0000021C   740094E2           ADDS     R0,R4,#+116
   \   00000220   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    354          	}
    355          	return(TxOk);
   \                     ??Send_3:
   \   00000224   0900B0E1           MOVS     R0,R9
   \   00000228   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \                     ??Send_2:
   \   0000022C   F04FBDE8           POP      {R4-R11,LR}
   \   00000230   1EFF2FE1           BX       LR               ;; return
   \                     ??Send_5:
   \   00000234   ........           DC32     OS_pCurrentTask
    356          }
    357          
    358          

   \                                 In segment CODE, align 4, keep-with-next
    359          bool SC2410Uart::Receive(U8* MyData, int Size, int TimeOut)
    360          {
   \                     ??Receive:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
   \   00000010   0370B0E1           MOVS     R7,R3
    361          	int Cnt = 0;
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   0080B0E1           MOVS     R8,R0
    362          	bool ReceivedData=true;
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   0090B0E1           MOVS     R9,R0
    363          
    364          	do {
    365          		ReceivedData = !OS_GetMailTimed(&RxBuf,(char*)&MyData[Cnt++],TimeOut);
   \                     ??Receive_7:
   \   00000024   0720B0E1           MOVS     R2,R7
   \   00000028   051098E0           ADDS     R1,R8,R5
   \   0000002C   0400B0E1           MOVS     R0,R4
   \   00000030   ........           _BLF     OS_GetMailTimed,??OS_GetMailTimed??rA
   \   00000034   018098E2           ADDS     R8,R8,#+1
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0100001A           BNE      ??Receive_8
   \   00000040   0190A0E3           MOV      R9,#+1
   \   00000044   000000EA           B        ??Receive_9
   \                     ??Receive_8:
   \   00000048   0090A0E3           MOV      R9,#+0
    366          	}while ( ReceivedData && Cnt < Size );
   \                     ??Receive_9:
   \   0000004C   FF9019E2           ANDS     R9,R9,#0xFF      ;; Zero extend
   \   00000050   000059E3           CMP      R9,#+0
   \   00000054   0100000A           BEQ      ??Receive_10
   \   00000058   060058E1           CMP      R8,R6
   \   0000005C   F0FFFFBA           BLT      ??Receive_7
    367          	return(ReceivedData);
   \                     ??Receive_10:
   \   00000060   0900B0E1           MOVS     R0,R9
   \   00000064   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000068   F043BDE8           POP      {R4-R9,LR}
   \   0000006C   1EFF2FE1           BX       LR               ;; return
    368          }
    369          
    370          

   \                                 In segment CODE, align 4, keep-with-next
    371          void SC2410Uart::ClearRxBuffer(void)
    372          {
   \                     ??ClearRxBuffer:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    373          	OS_ClearMB(&RxBuf);
   \   00000008   0400B0E1           MOVS     R0,R4
   \   0000000C   ........           _BLF     OS_ClearMB,??OS_ClearMB??rA
    374          }
   \   00000010   1040BDE8           POP      {R4,LR}
   \   00000014   1EFF2FE1           BX       LR               ;; return
    375          

   \                                 In segment CODE, align 4, keep-with-next
    376          bool SC2410Uart::HasMore(void)
    377          {
   \                     ??HasMore:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    378          	int RxBytesInBuf = OS_GetMessageCnt(&RxBuf);
   \   00000008   0400B0E1           MOVS     R0,R4
   \   0000000C   ........           _BLF     OS_GetMessageCnt,??OS_GetMessageCnt??rA
   \   00000010   0050B0E1           MOVS     R5,R0
    379          	return(bool(RxBytesInBuf));
   \   00000014   000055E3           CMP      R5,#+0
   \   00000018   0100000A           BEQ      ??HasMore_1
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   000000EA           B        ??HasMore_2
   \                     ??HasMore_1:
   \   00000024   0000A0E3           MOV      R0,#+0
   \                     ??HasMore_2:
   \   00000028   3040BDE8           POP      {R4,R5,LR}
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    380          }

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs SC2410Uart &SC2410Uart::new SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
   \                     `??new SC2410Uart`:
   \   00000000   FF4F2DE9           PUSH     {R0-R11,LR}
   \   00000004   3C409DE5           LDR      R4,[SP, #+60]
   \   00000008   40509DE5           LDR      R5,[SP, #+64]
   \   0000000C   44609DE5           LDR      R6,[SP, #+68]
   \   00000010   4870DDE5           LDRB     R7,[SP, #+72]
   \   00000014   4C809DE5           LDR      R8,[SP, #+76]
   \   00000018   5090DDE5           LDRB     R9,[SP, #+80]
   \   0000001C   54A09DE5           LDR      R10,[SP, #+84]
   \   00000020   58B09DE5           LDR      R11,[SP, #+88]
   \   00000024   4A0FA0E3           MOV      R0,#+296
   \   00000028   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   1300000A           BEQ      `??new SC2410Uart_1`
   \   00000034   00082DE9           PUSH     {R11}
   \   00000038   00042DE9           PUSH     {R10}
   \   0000003C   00022DE9           PUSH     {R9}
   \   00000040   00012DE9           PUSH     {R8}
   \   00000044   80002DE9           PUSH     {R7}
   \   00000048   40002DE9           PUSH     {R6}
   \   0000004C   20002DE9           PUSH     {R5}
   \   00000050   10002DE9           PUSH     {R4}
   \   00000054   58109DE5           LDR      R1,[SP, #+88]
   \   00000058   02002DE9           PUSH     {R1}
   \   0000005C   5810DDE5           LDRB     R1,[SP, #+88]
   \   00000060   02002DE9           PUSH     {R1}
   \   00000064   34109DE5           LDR      R1,[SP, #+52]
   \   00000068   02002DE9           PUSH     {R1}
   \   0000006C   34309DE5           LDR      R3,[SP, #+52]
   \   00000070   30209DE5           LDR      R2,[SP, #+48]
   \   00000074   2C109DE5           LDR      R1,[SP, #+44]
   \   00000078   ........           BL       ??SC2410Uart
   \   0000007C   2CD08DE2           ADD      SP,SP,#+44       ;; stack cleaning
   \   00000080   000000EA           B        `??new SC2410Uart_2`
   \                     `??new SC2410Uart_1`:
   \   00000084   0000A0E3           MOV      R0,#+0
   \                     `??new SC2410Uart_2`:
   \   00000088   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   0000008C   F04FBDE8           POP      {R4-R11,LR}
   \   00000090   1EFF2FE1           BX       LR               ;; return

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     SC2410Uart::ActivateTx()           8
     SC2410Uart::ClearRxBuffer()        8
     SC2410Uart::DeactivateTx()         0
     SC2410Uart::EnableFIFO(int, int)
                                        8
     SC2410Uart::EnableInt()            0
     SC2410Uart::HandleInterrupt()     16
     SC2410Uart::HasMore()             12
     SC2410Uart::Receive()             16
     SC2410Uart::Receive(unsigned char *, int, int)
                                       28
     SC2410Uart::SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                       92
     SC2410Uart::Send(unsigned char *, int, char, bool)
                                       36
     SC2410Uart::Transmit()            12
     SC2410Uart::new SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                       96
     malloc                             8


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     malloc                           24
     SC2410Uart::SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                     776
     SC2410Uart::EnableInt()         212
     SC2410Uart::EnableFIFO(int, int)
                                     204
     SC2410Uart::Transmit()          256
     SC2410Uart::Receive()           188
     SC2410Uart::HandleInterrupt()   180
     SC2410Uart::ActivateTx()        132
     SC2410Uart::DeactivateTx()       52
     SC2410Uart::Send(unsigned char *, int, char, bool)
                                     568
     SC2410Uart::Receive(unsigned char *, int, int)
                                     112
     SC2410Uart::ClearRxBuffer()      24
     SC2410Uart::HasMore()            48
     SC2410Uart::new SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                     148
      Others                         320

 
 3 204 bytes in segment CODE
    40 bytes in segment DATA_C
 
 2 900 bytes of CODE  memory (+ 304 bytes shared)
    40 bytes of CONST memory

Errors: none
Warnings: none
