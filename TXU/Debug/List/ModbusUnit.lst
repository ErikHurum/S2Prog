##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:14:30 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\Shared\Src\ModbusUnit.cpp                  #
#    Command line    =  D:\S2Prog\Shared\Src\ModbusUnit.cpp --fpu None -D    #
#                       OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D      #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -z9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --eec++           #
#                       --dlib_config "C:\Program Files (x86)\IAR            #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl4tpainl8n.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\ModbusUnit.lst              #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\ModbusUnit.r79               #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\Shared\Src\ModbusUnit.cpp
      1          #include "TSNIncludes.h"

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs string::string(string const &)
   \                     ??string:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000018   1C009FE5           LDR      R0,??string_1    ;; ??npos
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   003090E5           LDR      R3,[R0, #+0]
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           _BLF     ??assign,??assign??rA
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   3040BDE8           POP      {R4,R5,LR}
   \   00000038   1EFF2FE1           BX       LR               ;; return
   \                     ??string_1:
   \   0000003C   ........           DC32     ??npos

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree_algobase<allocator<void>>::_Genptr _Tree_algobase<allocator<void>>::_DecP(_Tree_algobase<allocator<void>>::_Genptr)
   \                     ??_DecP:
   \   00000000   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   08009015           LDRNE    R0,[R0, #+8]
   \   0000000C   1EFF2F11           BXNE     LR
   \   00000010   001090E5           LDR      R1,[R0, #+0]
   \   00000014   0D20D1E5           LDRB     R2,[R1, #+13]
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   0700001A           BNE      ??_DecP_1
   \   00000020   000000EA           B        ??_DecP_2
   \                     ??_DecP_3:
   \   00000024   0010A0E1           MOV      R1,R0
   \                     ??_DecP_2:
   \   00000028   080091E5           LDR      R0,[R1, #+8]
   \   0000002C   0D20D0E5           LDRB     R2,[R0, #+13]
   \   00000030   000052E3           CMP      R2,#+0
   \   00000034   FAFFFF0A           BEQ      ??_DecP_3
   \   00000038   0100A0E1           MOV      R0,R1
   \   0000003C   1EFF2FE1           BX       LR
   \                     ??_DecP_1:
   \   00000040   041090E5           LDR      R1,[R0, #+4]
   \   00000044   0D20D1E5           LDRB     R2,[R1, #+13]
   \   00000048   000052E3           CMP      R2,#+0
   \   0000004C   1EFF2F11           BXNE     LR
   \   00000050   002091E5           LDR      R2,[R1, #+0]
   \   00000054   020050E1           CMP      R0,R2
   \   00000058   0100A0E1           MOV      R0,R1
   \   0000005C   F7FFFF0A           BEQ      ??_DecP_1
   \   00000060   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree_algobase<allocator<void>>::_Genptr _Tree_algobase<allocator<void>>::_IncP(_Tree_algobase<allocator<void>>::_Genptr)
   \                     ??_IncP:
   \   00000000   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   1EFF2F11           BXNE     LR
   \   0000000C   081090E5           LDR      R1,[R0, #+8]
   \   00000010   0D20D1E5           LDRB     R2,[R1, #+13]
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   0700001A           BNE      ??_IncP_1
   \   0000001C   000000EA           B        ??_IncP_2
   \                     ??_IncP_3:
   \   00000020   0010A0E1           MOV      R1,R0
   \                     ??_IncP_2:
   \   00000024   000091E5           LDR      R0,[R1, #+0]
   \   00000028   0D20D0E5           LDRB     R2,[R0, #+13]
   \   0000002C   000052E3           CMP      R2,#+0
   \   00000030   FAFFFF0A           BEQ      ??_IncP_3
   \   00000034   060000EA           B        ??_IncP_4
   \                     ??_IncP_5:
   \   00000038   0100A0E1           MOV      R0,R1
   \                     ??_IncP_1:
   \   0000003C   041090E5           LDR      R1,[R0, #+4]
   \   00000040   0D20D1E5           LDRB     R2,[R1, #+13]
   \   00000044   000052E3           CMP      R2,#+0
   \   00000048   08209105           LDREQ    R2,[R1, #+8]
   \   0000004C   02005001           CMPEQ    R0,R2
   \   00000050   F8FFFF0A           BEQ      ??_IncP_5
   \                     ??_IncP_4:
   \   00000054   0100A0E1           MOV      R0,R1
   \   00000058   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree_algobase<allocator<void>>::_Clear()
   \                     ??_Clear:
   \   00000000   040080E5           STR      R0,[R0, #+4]
   \   00000004   000080E5           STR      R0,[R0, #+0]
   \   00000008   080080E5           STR      R0,[R0, #+8]
   \   0000000C   0110A0E3           MOV      R1,#+1
   \   00000010   0D10C0E5           STRB     R1,[R0, #+13]
   \   00000014   0C10C0E5           STRB     R1,[R0, #+12]
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   101080E5           STR      R1,[R0, #+16]
   \   00000020   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree_algobase<allocator<void>>::_Rrotate(_Tree_algobase<allocator<void>>::_Genptr)
   \                     ??_Rrotate:
   \   00000000   002091E5           LDR      R2,[R1, #+0]
   \   00000004   083092E5           LDR      R3,[R2, #+8]
   \   00000008   003081E5           STR      R3,[R1, #+0]
   \   0000000C   083092E5           LDR      R3,[R2, #+8]
   \   00000010   0DC0D3E5           LDRB     R12,[R3, #+13]
   \   00000014   00005CE3           CMP      R12,#+0
   \   00000018   04108305           STREQ    R1,[R3, #+4]
   \   0000001C   043091E5           LDR      R3,[R1, #+4]
   \   00000020   043082E5           STR      R3,[R2, #+4]
   \   00000024   043090E5           LDR      R3,[R0, #+4]
   \   00000028   030051E1           CMP      R1,R3
   \   0000002C   04208005           STREQ    R2,[R0, #+4]
   \   00000030   0400000A           BEQ      ??_Rrotate_1
   \   00000034   040091E5           LDR      R0,[R1, #+4]
   \   00000038   083090E5           LDR      R3,[R0, #+8]
   \   0000003C   030051E1           CMP      R1,R3
   \   00000040   08208005           STREQ    R2,[R0, #+8]
   \   00000044   00208015           STRNE    R2,[R0, #+0]
   \                     ??_Rrotate_1:
   \   00000048   081082E5           STR      R1,[R2, #+8]
   \   0000004C   042081E5           STR      R2,[R1, #+4]
   \   00000050   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree_algobase<allocator<void>>::_Lrotate(_Tree_algobase<allocator<void>>::_Genptr)
   \                     ??_Lrotate:
   \   00000000   082091E5           LDR      R2,[R1, #+8]
   \   00000004   003092E5           LDR      R3,[R2, #+0]
   \   00000008   083081E5           STR      R3,[R1, #+8]
   \   0000000C   003092E5           LDR      R3,[R2, #+0]
   \   00000010   0DC0D3E5           LDRB     R12,[R3, #+13]
   \   00000014   00005CE3           CMP      R12,#+0
   \   00000018   04108305           STREQ    R1,[R3, #+4]
   \   0000001C   043091E5           LDR      R3,[R1, #+4]
   \   00000020   043082E5           STR      R3,[R2, #+4]
   \   00000024   043090E5           LDR      R3,[R0, #+4]
   \   00000028   030051E1           CMP      R1,R3
   \   0000002C   04208005           STREQ    R2,[R0, #+4]
   \   00000030   0400000A           BEQ      ??_Lrotate_1
   \   00000034   040091E5           LDR      R0,[R1, #+4]
   \   00000038   003090E5           LDR      R3,[R0, #+0]
   \   0000003C   030051E1           CMP      R1,R3
   \   00000040   00208005           STREQ    R2,[R0, #+0]
   \   00000044   08208015           STRNE    R2,[R0, #+8]
   \                     ??_Lrotate_1:
   \   00000048   001082E5           STR      R1,[R2, #+0]
   \   0000004C   042081E5           STR      R2,[R1, #+4]
   \   00000050   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree_algobase<allocator<void>>::_Insert(bool, _Tree_algobase<allocator<void>>::_Genptr, _Tree_algobase<allocator<void>>::_Genptr)
   \                     ??_Insert:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   100094E5           LDR      R0,[R4, #+16]
   \   0000000C   0350A0E1           MOV      R5,R3
   \   00000010   010080E2           ADD      R0,R0,#+1
   \   00000014   100084E5           STR      R0,[R4, #+16]
   \   00000018   040052E1           CMP      R2,R4
   \   0000001C   0300001A           BNE      ??_Insert_8
   \   00000020   045084E5           STR      R5,[R4, #+4]
   \   00000024   005084E5           STR      R5,[R4, #+0]
   \                     ??_Insert_9:
   \   00000028   085084E5           STR      R5,[R4, #+8]
   \   0000002C   130000EA           B        ??_Insert_10
   \                     ??_Insert_8:
   \   00000030   000051E3           CMP      R1,#+0
   \   00000034   0500000A           BEQ      ??_Insert_11
   \   00000038   005082E5           STR      R5,[R2, #+0]
   \   0000003C   000094E5           LDR      R0,[R4, #+0]
   \   00000040   000052E1           CMP      R2,R0
   \   00000044   0D00001A           BNE      ??_Insert_10
   \   00000048   005084E5           STR      R5,[R4, #+0]
   \   0000004C   0B0000EA           B        ??_Insert_10
   \                     ??_Insert_11:
   \   00000050   085082E5           STR      R5,[R2, #+8]
   \   00000054   080094E5           LDR      R0,[R4, #+8]
   \   00000058   000052E1           CMP      R2,R0
   \   0000005C   0700001A           BNE      ??_Insert_10
   \   00000060   F0FFFFEA           B        ??_Insert_9
   \                     ??_Insert_12:
   \   00000064   0C70C0E5           STRB     R7,[R0, #+12]
   \   00000068   0C70C2E5           STRB     R7,[R2, #+12]
   \   0000006C   040095E5           LDR      R0,[R5, #+4]
   \   00000070   040090E5           LDR      R0,[R0, #+4]
   \   00000074   0C60C0E5           STRB     R6,[R0, #+12]
   \   00000078   040095E5           LDR      R0,[R5, #+4]
   \   0000007C   045090E5           LDR      R5,[R0, #+4]
   \                     ??_Insert_10:
   \   00000080   0170A0E3           MOV      R7,#+1
   \   00000084   040095E5           LDR      R0,[R5, #+4]
   \   00000088   0C10D0E5           LDRB     R1,[R0, #+12]
   \   0000008C   000051E3           CMP      R1,#+0
   \   00000090   2F00001A           BNE      ??_Insert_13
   \   00000094   041090E5           LDR      R1,[R0, #+4]
   \   00000098   0060A0E3           MOV      R6,#+0
   \   0000009C   001091E5           LDR      R1,[R1, #+0]
   \   000000A0   010050E1           CMP      R0,R1
   \   000000A4   041090E5           LDR      R1,[R0, #+4]
   \   000000A8   1400001A           BNE      ??_Insert_14
   \   000000AC   082091E5           LDR      R2,[R1, #+8]
   \   000000B0   0C10D2E5           LDRB     R1,[R2, #+12]
   \   000000B4   000051E3           CMP      R1,#+0
   \   000000B8   E9FFFF0A           BEQ      ??_Insert_12
   \   000000BC   081090E5           LDR      R1,[R0, #+8]
   \   000000C0   010055E1           CMP      R5,R1
   \   000000C4   0300001A           BNE      ??_Insert_15
   \   000000C8   0050A0E1           MOV      R5,R0
   \   000000CC   0510A0E1           MOV      R1,R5
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           _BLF     ??_Lrotate,??_Lrotate??rA
   \                     ??_Insert_15:
   \   000000D8   040095E5           LDR      R0,[R5, #+4]
   \   000000DC   0C70C0E5           STRB     R7,[R0, #+12]
   \   000000E0   040095E5           LDR      R0,[R5, #+4]
   \   000000E4   040090E5           LDR      R0,[R0, #+4]
   \   000000E8   0C60C0E5           STRB     R6,[R0, #+12]
   \   000000EC   040095E5           LDR      R0,[R5, #+4]
   \   000000F0   041090E5           LDR      R1,[R0, #+4]
   \   000000F4   0400A0E1           MOV      R0,R4
   \   000000F8   ........           _BLF     ??_Rrotate,??_Rrotate??rA
   \   000000FC   DFFFFFEA           B        ??_Insert_10
   \                     ??_Insert_14:
   \   00000100   002091E5           LDR      R2,[R1, #+0]
   \   00000104   0C10D2E5           LDRB     R1,[R2, #+12]
   \   00000108   000051E3           CMP      R1,#+0
   \   0000010C   D4FFFF0A           BEQ      ??_Insert_12
   \   00000110   001090E5           LDR      R1,[R0, #+0]
   \   00000114   010055E1           CMP      R5,R1
   \   00000118   0300001A           BNE      ??_Insert_16
   \   0000011C   0050A0E1           MOV      R5,R0
   \   00000120   0510A0E1           MOV      R1,R5
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           _BLF     ??_Rrotate,??_Rrotate??rA
   \                     ??_Insert_16:
   \   0000012C   040095E5           LDR      R0,[R5, #+4]
   \   00000130   0C70C0E5           STRB     R7,[R0, #+12]
   \   00000134   040095E5           LDR      R0,[R5, #+4]
   \   00000138   040090E5           LDR      R0,[R0, #+4]
   \   0000013C   0C60C0E5           STRB     R6,[R0, #+12]
   \   00000140   040095E5           LDR      R0,[R5, #+4]
   \   00000144   041090E5           LDR      R1,[R0, #+4]
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           _BLF     ??_Lrotate,??_Lrotate??rA
   \   00000150   CAFFFFEA           B        ??_Insert_10
   \                     ??_Insert_13:
   \   00000154   040094E5           LDR      R0,[R4, #+4]
   \   00000158   0C70C0E5           STRB     R7,[R0, #+12]
   \   0000015C   F040BDE8           POP      {R4-R7,LR}
   \   00000160   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Pairib _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::insert(PRogramObjectBase *)
   \                     ??insert:
   \   00000000   F34C2DE9           PUSH     {R0,R1,R4-R7,R10,R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   040095E5           LDR      R0,[R5, #+4]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   05B0A0E1           MOV      R11,R5
   \   00000018   0170A0E3           MOV      R7,#+1
   \                     ??insert_7:
   \   0000001C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0700001A           BNE      ??insert_8
   \   00000028   101090E5           LDR      R1,[R0, #+16]
   \   0000002C   00B0A0E1           MOV      R11,R0
   \   00000030   010056E1           CMP      R6,R1
   \   00000034   00009035           LDRCC    R0,[R0, #+0]
   \   00000038   0170A033           MOVCC    R7,#+1
   \   0000003C   08009025           LDRCS    R0,[R0, #+8]
   \   00000040   0070A023           MOVCS    R7,#+0
   \   00000044   F4FFFFEA           B        ??insert_7
   \                     ??insert_8:
   \   00000048   0B00A0E1           MOV      R0,R11
   \   0000004C   01A0A0E3           MOV      R10,#+1
   \   00000050   000057E3           CMP      R7,#+0
   \   00000054   0B00000A           BEQ      ??insert_9
   \   00000058   001095E5           LDR      R1,[R5, #+0]
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   0700001A           BNE      ??insert_10
   \   00000064   0630A0E1           MOV      R3,R6
   \   00000068   0B20A0E1           MOV      R2,R11
   \   0000006C   0110A0E3           MOV      R1,#+1
   \                     ??insert_11:
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           _BLF     ??_Insert_4,??_Insert??rA
   \   00000078   00008DE5           STR      R0,[SP, #+0]
   \   0000007C   04A0CDE5           STRB     R10,[SP, #+4]
   \   00000080   0A0000EA           B        ??insert_12
   \                     ??insert_10:
   \   00000084   ........           _BLF     ??_DecP,??_DecP??rA
   \                     ??insert_9:
   \   00000088   101090E5           LDR      R1,[R0, #+16]
   \   0000008C   060051E1           CMP      R1,R6
   \   00000090   0300002A           BCS      ??insert_13
   \   00000094   0630A0E1           MOV      R3,R6
   \   00000098   0B20A0E1           MOV      R2,R11
   \   0000009C   0710A0E1           MOV      R1,R7
   \   000000A0   F2FFFFEA           B        ??insert_11
   \                     ??insert_13:
   \   000000A4   00008DE5           STR      R0,[SP, #+0]
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0410CDE5           STRB     R1,[SP, #+4]
   \                     ??insert_12:
   \   000000B0   0D00A0E1           MOV      R0,SP
   \   000000B4   030090E8           LDM      R0,{R0,R1}
   \   000000B8   030084E8           STM      R4,{R0,R1}
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   F64CBDE8           POP      {R1,R2,R4-R7,R10,R11,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Pairib _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::insert(unsigned int)
   \                     ??insert_1:
   \   00000000   F3432DE9           PUSH     {R0,R1,R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0160A0E1           MOV      R6,R1
   \   0000000C   040096E5           LDR      R0,[R6, #+4]
   \   00000010   0270A0E1           MOV      R7,R2
   \   00000014   0680A0E1           MOV      R8,R6
   \   00000018   0190A0E3           MOV      R9,#+1
   \                     ??insert_14:
   \   0000001C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0700001A           BNE      ??insert_15
   \   00000028   101090E5           LDR      R1,[R0, #+16]
   \   0000002C   0080A0E1           MOV      R8,R0
   \   00000030   010057E1           CMP      R7,R1
   \   00000034   00009035           LDRCC    R0,[R0, #+0]
   \   00000038   0190A033           MOVCC    R9,#+1
   \   0000003C   08009025           LDRCS    R0,[R0, #+8]
   \   00000040   0090A023           MOVCS    R9,#+0
   \   00000044   F4FFFFEA           B        ??insert_14
   \                     ??insert_15:
   \   00000048   0800A0E1           MOV      R0,R8
   \   0000004C   0150A0E3           MOV      R5,#+1
   \   00000050   000059E3           CMP      R9,#+0
   \   00000054   0B00000A           BEQ      ??insert_16
   \   00000058   001096E5           LDR      R1,[R6, #+0]
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   0700001A           BNE      ??insert_17
   \   00000064   0730A0E1           MOV      R3,R7
   \   00000068   0820A0E1           MOV      R2,R8
   \   0000006C   0110A0E3           MOV      R1,#+1
   \                     ??insert_18:
   \   00000070   0600A0E1           MOV      R0,R6
   \   00000074   ........           _BLF     ??_Insert_1,??_Insert??rA_1
   \   00000078   00008DE5           STR      R0,[SP, #+0]
   \   0000007C   0450CDE5           STRB     R5,[SP, #+4]
   \   00000080   0A0000EA           B        ??insert_19
   \                     ??insert_17:
   \   00000084   ........           _BLF     ??_DecP,??_DecP??rA
   \                     ??insert_16:
   \   00000088   101090E5           LDR      R1,[R0, #+16]
   \   0000008C   070051E1           CMP      R1,R7
   \   00000090   0300002A           BCS      ??insert_20
   \   00000094   0730A0E1           MOV      R3,R7
   \   00000098   0820A0E1           MOV      R2,R8
   \   0000009C   0910A0E1           MOV      R1,R9
   \   000000A0   F2FFFFEA           B        ??insert_18
   \                     ??insert_20:
   \   000000A4   00008DE5           STR      R0,[SP, #+0]
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0410CDE5           STRB     R1,[SP, #+4]
   \                     ??insert_19:
   \   000000B0   0D00A0E1           MOV      R0,SP
   \   000000B4   030090E8           LDM      R0,{R0,R1}
   \   000000B8   030084E8           STM      R4,{R0,R1}
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   F643BDE8           POP      {R1,R2,R4-R9,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Pairib _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::insert(PRogramObject *)
   \                     ??insert_2:
   \   00000000   F34C2DE9           PUSH     {R0,R1,R4-R7,R10,R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   040095E5           LDR      R0,[R5, #+4]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   05B0A0E1           MOV      R11,R5
   \   00000018   0170A0E3           MOV      R7,#+1
   \                     ??insert_21:
   \   0000001C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0700001A           BNE      ??insert_22
   \   00000028   101090E5           LDR      R1,[R0, #+16]
   \   0000002C   00B0A0E1           MOV      R11,R0
   \   00000030   010056E1           CMP      R6,R1
   \   00000034   00009035           LDRCC    R0,[R0, #+0]
   \   00000038   0170A033           MOVCC    R7,#+1
   \   0000003C   08009025           LDRCS    R0,[R0, #+8]
   \   00000040   0070A023           MOVCS    R7,#+0
   \   00000044   F4FFFFEA           B        ??insert_21
   \                     ??insert_22:
   \   00000048   0B00A0E1           MOV      R0,R11
   \   0000004C   01A0A0E3           MOV      R10,#+1
   \   00000050   000057E3           CMP      R7,#+0
   \   00000054   0B00000A           BEQ      ??insert_23
   \   00000058   001095E5           LDR      R1,[R5, #+0]
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   0700001A           BNE      ??insert_24
   \   00000064   0630A0E1           MOV      R3,R6
   \   00000068   0B20A0E1           MOV      R2,R11
   \   0000006C   0110A0E3           MOV      R1,#+1
   \                     ??insert_25:
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           _BLF     ??_Insert_5,??_Insert??rA_2
   \   00000078   00008DE5           STR      R0,[SP, #+0]
   \   0000007C   04A0CDE5           STRB     R10,[SP, #+4]
   \   00000080   0A0000EA           B        ??insert_26
   \                     ??insert_24:
   \   00000084   ........           _BLF     ??_DecP,??_DecP??rA
   \                     ??insert_23:
   \   00000088   101090E5           LDR      R1,[R0, #+16]
   \   0000008C   060051E1           CMP      R1,R6
   \   00000090   0300002A           BCS      ??insert_27
   \   00000094   0630A0E1           MOV      R3,R6
   \   00000098   0B20A0E1           MOV      R2,R11
   \   0000009C   0710A0E1           MOV      R1,R7
   \   000000A0   F2FFFFEA           B        ??insert_25
   \                     ??insert_27:
   \   000000A4   00008DE5           STR      R0,[SP, #+0]
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0410CDE5           STRB     R1,[SP, #+4]
   \                     ??insert_26:
   \   000000B0   0D00A0E1           MOV      R0,SP
   \   000000B4   030090E8           LDM      R0,{R0,R1}
   \   000000B8   030084E8           STM      R4,{R0,R1}
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   F64CBDE8           POP      {R1,R2,R4-R7,R10,R11,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Pairib _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::insert(pair<unsigned int const, ModbusUnit *> const &)
   \                     ??insert_3:
   \   00000000   F3432DE9           PUSH     {R0,R1,R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0160A0E1           MOV      R6,R1
   \   0000000C   040096E5           LDR      R0,[R6, #+4]
   \   00000010   0270A0E1           MOV      R7,R2
   \   00000014   0680A0E1           MOV      R8,R6
   \   00000018   0190A0E3           MOV      R9,#+1
   \                     ??insert_28:
   \   0000001C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0800001A           BNE      ??insert_29
   \   00000028   001097E5           LDR      R1,[R7, #+0]
   \   0000002C   102090E5           LDR      R2,[R0, #+16]
   \   00000030   0080A0E1           MOV      R8,R0
   \   00000034   020051E1           CMP      R1,R2
   \   00000038   00009035           LDRCC    R0,[R0, #+0]
   \   0000003C   0190A033           MOVCC    R9,#+1
   \   00000040   08009025           LDRCS    R0,[R0, #+8]
   \   00000044   0090A023           MOVCS    R9,#+0
   \   00000048   F3FFFFEA           B        ??insert_28
   \                     ??insert_29:
   \   0000004C   0800A0E1           MOV      R0,R8
   \   00000050   0150A0E3           MOV      R5,#+1
   \   00000054   000059E3           CMP      R9,#+0
   \   00000058   0B00000A           BEQ      ??insert_30
   \   0000005C   001096E5           LDR      R1,[R6, #+0]
   \   00000060   010050E1           CMP      R0,R1
   \   00000064   0700001A           BNE      ??insert_31
   \   00000068   0730A0E1           MOV      R3,R7
   \   0000006C   0820A0E1           MOV      R2,R8
   \   00000070   0110A0E3           MOV      R1,#+1
   \                     ??insert_32:
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   ........           _BLF     ??_Insert_2,??_Insert??rA_3
   \   0000007C   00008DE5           STR      R0,[SP, #+0]
   \   00000080   0450CDE5           STRB     R5,[SP, #+4]
   \   00000084   0B0000EA           B        ??insert_33
   \                     ??insert_31:
   \   00000088   ........           _BLF     ??_DecP,??_DecP??rA
   \                     ??insert_30:
   \   0000008C   101090E5           LDR      R1,[R0, #+16]
   \   00000090   002097E5           LDR      R2,[R7, #+0]
   \   00000094   020051E1           CMP      R1,R2
   \   00000098   0300002A           BCS      ??insert_34
   \   0000009C   0730A0E1           MOV      R3,R7
   \   000000A0   0820A0E1           MOV      R2,R8
   \   000000A4   0910A0E1           MOV      R1,R9
   \   000000A8   F1FFFFEA           B        ??insert_32
   \                     ??insert_34:
   \   000000AC   00008DE5           STR      R0,[SP, #+0]
   \   000000B0   0010A0E3           MOV      R1,#+0
   \   000000B4   0410CDE5           STRB     R1,[SP, #+4]
   \                     ??insert_33:
   \   000000B8   0D00A0E1           MOV      R0,SP
   \   000000BC   030090E8           LDM      R0,{R0,R1}
   \   000000C0   030084E8           STM      R4,{R0,R1}
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   F643BDE8           POP      {R1,R2,R4-R9,LR}
   \   000000CC   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Pairib _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::insert(int)
   \                     ??insert_4:
   \   00000000   F3432DE9           PUSH     {R0,R1,R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0160A0E1           MOV      R6,R1
   \   0000000C   040096E5           LDR      R0,[R6, #+4]
   \   00000010   0270A0E1           MOV      R7,R2
   \   00000014   0680A0E1           MOV      R8,R6
   \   00000018   0190A0E3           MOV      R9,#+1
   \                     ??insert_35:
   \   0000001C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0700001A           BNE      ??insert_36
   \   00000028   101090E5           LDR      R1,[R0, #+16]
   \   0000002C   0080A0E1           MOV      R8,R0
   \   00000030   010057E1           CMP      R7,R1
   \   00000034   000090B5           LDRLT    R0,[R0, #+0]
   \   00000038   0190A0B3           MOVLT    R9,#+1
   \   0000003C   080090A5           LDRGE    R0,[R0, #+8]
   \   00000040   0090A0A3           MOVGE    R9,#+0
   \   00000044   F4FFFFEA           B        ??insert_35
   \                     ??insert_36:
   \   00000048   0800A0E1           MOV      R0,R8
   \   0000004C   0150A0E3           MOV      R5,#+1
   \   00000050   000059E3           CMP      R9,#+0
   \   00000054   0B00000A           BEQ      ??insert_37
   \   00000058   001096E5           LDR      R1,[R6, #+0]
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   0700001A           BNE      ??insert_38
   \   00000064   0730A0E1           MOV      R3,R7
   \   00000068   0820A0E1           MOV      R2,R8
   \   0000006C   0110A0E3           MOV      R1,#+1
   \                     ??insert_39:
   \   00000070   0600A0E1           MOV      R0,R6
   \   00000074   ........           _BLF     ??_Insert_7,??_Insert??rA_4
   \   00000078   00008DE5           STR      R0,[SP, #+0]
   \   0000007C   0450CDE5           STRB     R5,[SP, #+4]
   \   00000080   0A0000EA           B        ??insert_40
   \                     ??insert_38:
   \   00000084   ........           _BLF     ??_DecP,??_DecP??rA
   \                     ??insert_37:
   \   00000088   101090E5           LDR      R1,[R0, #+16]
   \   0000008C   070051E1           CMP      R1,R7
   \   00000090   030000AA           BGE      ??insert_41
   \   00000094   0730A0E1           MOV      R3,R7
   \   00000098   0820A0E1           MOV      R2,R8
   \   0000009C   0910A0E1           MOV      R1,R9
   \   000000A0   F2FFFFEA           B        ??insert_39
   \                     ??insert_41:
   \   000000A4   00008DE5           STR      R0,[SP, #+0]
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0410CDE5           STRB     R1,[SP, #+4]
   \                     ??insert_40:
   \   000000B0   0D00A0E1           MOV      R0,SP
   \   000000B4   030090E8           LDM      R0,{R0,R1}
   \   000000B8   030084E8           STM      R4,{R0,R1}
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   F643BDE8           POP      {R1,R2,R4-R9,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::_Pairib _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::insert(AlarmBasic *)
   \                     ??insert_5:
   \   00000000   F34C2DE9           PUSH     {R0,R1,R4-R7,R10,R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   040095E5           LDR      R0,[R5, #+4]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   05B0A0E1           MOV      R11,R5
   \   00000018   0170A0E3           MOV      R7,#+1
   \                     ??insert_42:
   \   0000001C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0700001A           BNE      ??insert_43
   \   00000028   101090E5           LDR      R1,[R0, #+16]
   \   0000002C   00B0A0E1           MOV      R11,R0
   \   00000030   010056E1           CMP      R6,R1
   \   00000034   00009035           LDRCC    R0,[R0, #+0]
   \   00000038   0170A033           MOVCC    R7,#+1
   \   0000003C   08009025           LDRCS    R0,[R0, #+8]
   \   00000040   0070A023           MOVCS    R7,#+0
   \   00000044   F4FFFFEA           B        ??insert_42
   \                     ??insert_43:
   \   00000048   0B00A0E1           MOV      R0,R11
   \   0000004C   01A0A0E3           MOV      R10,#+1
   \   00000050   000057E3           CMP      R7,#+0
   \   00000054   0B00000A           BEQ      ??insert_44
   \   00000058   001095E5           LDR      R1,[R5, #+0]
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   0700001A           BNE      ??insert_45
   \   00000064   0630A0E1           MOV      R3,R6
   \   00000068   0B20A0E1           MOV      R2,R11
   \   0000006C   0110A0E3           MOV      R1,#+1
   \                     ??insert_46:
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           _BLF     ??_Insert_3,??_Insert??rA_5
   \   00000078   00008DE5           STR      R0,[SP, #+0]
   \   0000007C   04A0CDE5           STRB     R10,[SP, #+4]
   \   00000080   0A0000EA           B        ??insert_47
   \                     ??insert_45:
   \   00000084   ........           _BLF     ??_DecP,??_DecP??rA
   \                     ??insert_44:
   \   00000088   101090E5           LDR      R1,[R0, #+16]
   \   0000008C   060051E1           CMP      R1,R6
   \   00000090   0300002A           BCS      ??insert_48
   \   00000094   0630A0E1           MOV      R3,R6
   \   00000098   0B20A0E1           MOV      R2,R11
   \   0000009C   0710A0E1           MOV      R1,R7
   \   000000A0   F2FFFFEA           B        ??insert_46
   \                     ??insert_48:
   \   000000A4   00008DE5           STR      R0,[SP, #+0]
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0410CDE5           STRB     R1,[SP, #+4]
   \                     ??insert_47:
   \   000000B0   0D00A0E1           MOV      R0,SP
   \   000000B4   030090E8           LDM      R0,{R0,R1}
   \   000000B8   030084E8           STM      R4,{R0,R1}
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   F64CBDE8           POP      {R1,R2,R4-R7,R10,R11,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Pairib _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::insert(AnalogInput *)
   \                     ??insert_6:
   \   00000000   F34C2DE9           PUSH     {R0,R1,R4-R7,R10,R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   040095E5           LDR      R0,[R5, #+4]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   05B0A0E1           MOV      R11,R5
   \   00000018   0170A0E3           MOV      R7,#+1
   \                     ??insert_49:
   \   0000001C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0700001A           BNE      ??insert_50
   \   00000028   101090E5           LDR      R1,[R0, #+16]
   \   0000002C   00B0A0E1           MOV      R11,R0
   \   00000030   010056E1           CMP      R6,R1
   \   00000034   00009035           LDRCC    R0,[R0, #+0]
   \   00000038   0170A033           MOVCC    R7,#+1
   \   0000003C   08009025           LDRCS    R0,[R0, #+8]
   \   00000040   0070A023           MOVCS    R7,#+0
   \   00000044   F4FFFFEA           B        ??insert_49
   \                     ??insert_50:
   \   00000048   0B00A0E1           MOV      R0,R11
   \   0000004C   01A0A0E3           MOV      R10,#+1
   \   00000050   000057E3           CMP      R7,#+0
   \   00000054   0B00000A           BEQ      ??insert_51
   \   00000058   001095E5           LDR      R1,[R5, #+0]
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   0700001A           BNE      ??insert_52
   \   00000064   0630A0E1           MOV      R3,R6
   \   00000068   0B20A0E1           MOV      R2,R11
   \   0000006C   0110A0E3           MOV      R1,#+1
   \                     ??insert_53:
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           _BLF     ??_Insert_6,??_Insert??rA_6
   \   00000078   00008DE5           STR      R0,[SP, #+0]
   \   0000007C   04A0CDE5           STRB     R10,[SP, #+4]
   \   00000080   0A0000EA           B        ??insert_54
   \                     ??insert_52:
   \   00000084   ........           _BLF     ??_DecP,??_DecP??rA
   \                     ??insert_51:
   \   00000088   101090E5           LDR      R1,[R0, #+16]
   \   0000008C   060051E1           CMP      R1,R6
   \   00000090   0300002A           BCS      ??insert_55
   \   00000094   0630A0E1           MOV      R3,R6
   \   00000098   0B20A0E1           MOV      R2,R11
   \   0000009C   0710A0E1           MOV      R1,R7
   \   000000A0   F2FFFFEA           B        ??insert_53
   \                     ??insert_55:
   \   000000A4   00008DE5           STR      R0,[SP, #+0]
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0410CDE5           STRB     R1,[SP, #+4]
   \                     ??insert_54:
   \   000000B0   0D00A0E1           MOV      R0,SP
   \   000000B4   030090E8           LDM      R0,{R0,R1}
   \   000000B8   030084E8           STM      R4,{R0,R1}
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   F64CBDE8           POP      {R1,R2,R4-R7,R10,R11,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::clear()
   \                     ??clear:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   041094E5           LDR      R1,[R4, #+4]
   \   0000000C   ........           _BLF     ??_Erase_2,??_Erase??rA
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000018   1040BDE8           POP      {R4,LR}
   \   0000001C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::iterator _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::find(unsigned int)
   \                     ??find:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   ........           _BLF     ??_Lbound,??_Lbound??rA
   \   00000010   040050E1           CMP      R0,R4
   \   00000014   0300000A           BEQ      ??find_1
   \   00000018   101090E5           LDR      R1,[R0, #+16]
   \   0000001C   010055E1           CMP      R5,R1
   \   00000020   0040A021           MOVCS    R4,R0
   \   00000024   0400A0E1           MOV      R0,R4
   \                     ??find_1:
   \   00000028   3040BDE8           POP      {R4,R5,LR}
   \   0000002C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Copy(_Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>> const &)
   \                     ??_Copy:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   \   00000008   041095E5           LDR      R1,[R5, #+4]
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0420A0E1           MOV      R2,R4
   \   00000014   ........           _BLF     ??_Copy_1,??_Copy??rA
   \   00000018   040084E5           STR      R0,[R4, #+4]
   \   0000001C   100095E5           LDR      R0,[R5, #+16]
   \   00000020   100084E5           STR      R0,[R4, #+16]
   \   00000024   040094E5           LDR      R0,[R4, #+4]
   \   00000028   0D10D0E5           LDRB     R1,[R0, #+13]
   \   0000002C   000051E3           CMP      R1,#+0
   \   00000030   1000001A           BNE      ??_Copy_2
   \   00000034   0010A0E1           MOV      R1,R0
   \   00000038   000000EA           B        ??_Copy_3
   \                     ??_Copy_4:
   \   0000003C   0210A0E1           MOV      R1,R2
   \                     ??_Copy_3:
   \   00000040   002091E5           LDR      R2,[R1, #+0]
   \   00000044   0D30D2E5           LDRB     R3,[R2, #+13]
   \   00000048   000053E3           CMP      R3,#+0
   \   0000004C   FAFFFF0A           BEQ      ??_Copy_4
   \   00000050   001084E5           STR      R1,[R4, #+0]
   \   00000054   081084E2           ADD      R1,R4,#+8
   \   00000058   000000EA           B        ??_Copy_5
   \                     ??_Copy_6:
   \   0000005C   0200A0E1           MOV      R0,R2
   \                     ??_Copy_5:
   \   00000060   082090E5           LDR      R2,[R0, #+8]
   \   00000064   0D30D2E5           LDRB     R3,[R2, #+13]
   \   00000068   000053E3           CMP      R3,#+0
   \   0000006C   FAFFFF0A           BEQ      ??_Copy_6
   \   00000070   000081E5           STR      R0,[R1, #+0]
   \   00000074   010000EA           B        ??_Copy_7
   \                     ??_Copy_2:
   \   00000078   004084E5           STR      R4,[R4, #+0]
   \   0000007C   084084E5           STR      R4,[R4, #+8]
   \                     ??_Copy_7:
   \   00000080   3040BDE8           POP      {R4,R5,LR}
   \   00000084   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Copy(_Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr, _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr)
   \                     ??_Copy_1:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0D00D5E5           LDRB     R0,[R5, #+13]
   \   00000010   0280A0E1           MOV      R8,R2
   \   00000014   0460A0E1           MOV      R6,R4
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   1900001A           BNE      ??_Copy_8
   \   00000020   0C90D5E5           LDRB     R9,[R5, #+12]
   \   00000024   10A095E5           LDR      R10,[R5, #+16]
   \   00000028   1400A0E3           MOV      R0,#+20
   \   0000002C   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000030   0070B0E1           MOVS     R7,R0
   \   00000034   0600000A           BEQ      ??_Copy_9
   \   00000038   004087E5           STR      R4,[R7, #+0]
   \   0000003C   048087E5           STR      R8,[R7, #+4]
   \   00000040   084087E5           STR      R4,[R7, #+8]
   \   00000044   0C90C7E5           STRB     R9,[R7, #+12]
   \   00000048   0000A0E3           MOV      R0,#+0
   \   0000004C   0D00C7E5           STRB     R0,[R7, #+13]
   \   00000050   10A087E5           STR      R10,[R7, #+16]
   \                     ??_Copy_9:
   \   00000054   0D00D6E5           LDRB     R0,[R6, #+13]
   \   00000058   001095E5           LDR      R1,[R5, #+0]
   \   0000005C   0720A0E1           MOV      R2,R7
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0760A011           MOVNE    R6,R7
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   E3FFFFEB           BL       ??_Copy_1
   \   00000070   000087E5           STR      R0,[R7, #+0]
   \   00000074   081095E5           LDR      R1,[R5, #+8]
   \   00000078   0720A0E1           MOV      R2,R7
   \   0000007C   0400A0E1           MOV      R0,R4
   \   00000080   DEFFFFEB           BL       ??_Copy_1
   \   00000084   080087E5           STR      R0,[R7, #+8]
   \                     ??_Copy_8:
   \   00000088   0600A0E1           MOV      R0,R6
   \   0000008C   F047BDE8           POP      {R4-R10,LR}
   \   00000090   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Erase(_Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Nodeptr)
   \                     ??_Erase:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   060000EA           B        ??_Erase_6
   \                     ??_Erase_7:
   \   00000014   081096E5           LDR      R1,[R6, #+8]
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   F7FFFFEB           BL       ??_Erase
   \   00000020   006096E5           LDR      R6,[R6, #+0]
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   0000002C   0650A0E1           MOV      R5,R6
   \                     ??_Erase_6:
   \   00000030   0D00D6E5           LDRB     R0,[R6, #+13]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   F5FFFF0A           BEQ      ??_Erase_7
   \   0000003C   7040BDE8           POP      {R4-R6,LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Erase(_Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Nodeptr)
   \                     ??_Erase_1:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   060000EA           B        ??_Erase_8
   \                     ??_Erase_9:
   \   00000014   081096E5           LDR      R1,[R6, #+8]
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   F7FFFFEB           BL       ??_Erase_1
   \   00000020   006096E5           LDR      R6,[R6, #+0]
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   0000002C   0650A0E1           MOV      R5,R6
   \                     ??_Erase_8:
   \   00000030   0D00D6E5           LDRB     R0,[R6, #+13]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   F5FFFF0A           BEQ      ??_Erase_9
   \   0000003C   7040BDE8           POP      {R4-R6,LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Erase(_Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Nodeptr)
   \                     ??_Erase_2:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   060000EA           B        ??_Erase_10
   \                     ??_Erase_11:
   \   00000014   081096E5           LDR      R1,[R6, #+8]
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   F7FFFFEB           BL       ??_Erase_2
   \   00000020   006096E5           LDR      R6,[R6, #+0]
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   0000002C   0650A0E1           MOV      R5,R6
   \                     ??_Erase_10:
   \   00000030   0D00D6E5           LDRB     R0,[R6, #+13]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   F5FFFF0A           BEQ      ??_Erase_11
   \   0000003C   7040BDE8           POP      {R4-R6,LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Nodeptr)
   \                     ??_Erase_3:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   060000EA           B        ??_Erase_12
   \                     ??_Erase_13:
   \   00000014   081096E5           LDR      R1,[R6, #+8]
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   F7FFFFEB           BL       ??_Erase_3
   \   00000020   006096E5           LDR      R6,[R6, #+0]
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   0000002C   0650A0E1           MOV      R5,R6
   \                     ??_Erase_12:
   \   00000030   0D00D6E5           LDRB     R0,[R6, #+13]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   F5FFFF0A           BEQ      ??_Erase_13
   \   0000003C   7040BDE8           POP      {R4-R6,LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr)
   \                     ??_Erase_4:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   060000EA           B        ??_Erase_14
   \                     ??_Erase_15:
   \   00000014   081096E5           LDR      R1,[R6, #+8]
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   F7FFFFEB           BL       ??_Erase_4
   \   00000020   006096E5           LDR      R6,[R6, #+0]
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   0000002C   0650A0E1           MOV      R5,R6
   \                     ??_Erase_14:
   \   00000030   0D00D6E5           LDRB     R0,[R6, #+13]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   F5FFFF0A           BEQ      ??_Erase_15
   \   0000003C   7040BDE8           POP      {R4-R6,LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Erase(_Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr)
   \                     ??_Erase_5:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   060000EA           B        ??_Erase_16
   \                     ??_Erase_17:
   \   00000014   081096E5           LDR      R1,[R6, #+8]
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   F7FFFFEB           BL       ??_Erase_5
   \   00000020   006096E5           LDR      R6,[R6, #+0]
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   0000002C   0650A0E1           MOV      R5,R6
   \                     ??_Erase_16:
   \   00000030   0D00D6E5           LDRB     R0,[R6, #+13]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   F5FFFF0A           BEQ      ??_Erase_17
   \   0000003C   7040BDE8           POP      {R4-R6,LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::iterator _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Insert(bool, _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr, unsigned int)
   \                     ??_Insert_1:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   1400A0E3           MOV      R0,#+20
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0080B0E1           MOVS     R8,R0
   \   00000020   0600000A           BEQ      ??_Insert_17
   \   00000024   004088E5           STR      R4,[R8, #+0]
   \   00000028   046088E5           STR      R6,[R8, #+4]
   \   0000002C   084088E5           STR      R4,[R8, #+8]
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C00C8E5           STRB     R0,[R8, #+12]
   \   00000038   0D00C8E5           STRB     R0,[R8, #+13]
   \   0000003C   107088E5           STR      R7,[R8, #+16]
   \                     ??_Insert_17:
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           _BLF     ??_Insert,??_Insert??rA_7
   \   00000054   0800A0E1           MOV      R0,R8
   \   00000058   F041BDE8           POP      {R4-R8,LR}
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::iterator _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Insert(bool, _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Nodeptr, pair<unsigned int const, ModbusUnit *> const &)
   \                     ??_Insert_2:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0380A0E1           MOV      R8,R3
   \   00000014   1800A0E3           MOV      R0,#+24
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0070B0E1           MOVS     R7,R0
   \   00000020   0A00000A           BEQ      ??_Insert_18
   \   00000024   004087E5           STR      R4,[R7, #+0]
   \   00000028   046087E5           STR      R6,[R7, #+4]
   \   0000002C   084087E5           STR      R4,[R7, #+8]
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C00C7E5           STRB     R0,[R7, #+12]
   \   00000038   0D00C7E5           STRB     R0,[R7, #+13]
   \   0000003C   001098E5           LDR      R1,[R8, #+0]
   \   00000040   100087E2           ADD      R0,R7,#+16
   \   00000044   001080E5           STR      R1,[R0, #+0]
   \   00000048   041098E5           LDR      R1,[R8, #+4]
   \   0000004C   041080E5           STR      R1,[R0, #+4]
   \                     ??_Insert_18:
   \   00000050   0730A0E1           MOV      R3,R7
   \   00000054   0620A0E1           MOV      R2,R6
   \   00000058   0510A0E1           MOV      R1,R5
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           _BLF     ??_Insert,??_Insert??rA_7
   \   00000064   0700A0E1           MOV      R0,R7
   \   00000068   F041BDE8           POP      {R4-R8,LR}
   \   0000006C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::iterator _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::_Insert(bool, _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::_Nodeptr, AlarmBasic *)
   \                     ??_Insert_3:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   1400A0E3           MOV      R0,#+20
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0080B0E1           MOVS     R8,R0
   \   00000020   0600000A           BEQ      ??_Insert_19
   \   00000024   004088E5           STR      R4,[R8, #+0]
   \   00000028   046088E5           STR      R6,[R8, #+4]
   \   0000002C   084088E5           STR      R4,[R8, #+8]
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C00C8E5           STRB     R0,[R8, #+12]
   \   00000038   0D00C8E5           STRB     R0,[R8, #+13]
   \   0000003C   107088E5           STR      R7,[R8, #+16]
   \                     ??_Insert_19:
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           _BLF     ??_Insert,??_Insert??rA_7
   \   00000054   0800A0E1           MOV      R0,R8
   \   00000058   F041BDE8           POP      {R4-R8,LR}
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::iterator _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Insert(bool, _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr, PRogramObjectBase *)
   \                     ??_Insert_4:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   1400A0E3           MOV      R0,#+20
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0080B0E1           MOVS     R8,R0
   \   00000020   0600000A           BEQ      ??_Insert_20
   \   00000024   004088E5           STR      R4,[R8, #+0]
   \   00000028   046088E5           STR      R6,[R8, #+4]
   \   0000002C   084088E5           STR      R4,[R8, #+8]
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C00C8E5           STRB     R0,[R8, #+12]
   \   00000038   0D00C8E5           STRB     R0,[R8, #+13]
   \   0000003C   107088E5           STR      R7,[R8, #+16]
   \                     ??_Insert_20:
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           _BLF     ??_Insert,??_Insert??rA_7
   \   00000054   0800A0E1           MOV      R0,R8
   \   00000058   F041BDE8           POP      {R4-R8,LR}
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::iterator _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Insert(bool, _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Nodeptr, PRogramObject *)
   \                     ??_Insert_5:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   1400A0E3           MOV      R0,#+20
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0080B0E1           MOVS     R8,R0
   \   00000020   0600000A           BEQ      ??_Insert_21
   \   00000024   004088E5           STR      R4,[R8, #+0]
   \   00000028   046088E5           STR      R6,[R8, #+4]
   \   0000002C   084088E5           STR      R4,[R8, #+8]
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C00C8E5           STRB     R0,[R8, #+12]
   \   00000038   0D00C8E5           STRB     R0,[R8, #+13]
   \   0000003C   107088E5           STR      R7,[R8, #+16]
   \                     ??_Insert_21:
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           _BLF     ??_Insert,??_Insert??rA_7
   \   00000054   0800A0E1           MOV      R0,R8
   \   00000058   F041BDE8           POP      {R4-R8,LR}
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::iterator _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Insert(bool, _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Nodeptr, AnalogInput *)
   \                     ??_Insert_6:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   1400A0E3           MOV      R0,#+20
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0080B0E1           MOVS     R8,R0
   \   00000020   0600000A           BEQ      ??_Insert_22
   \   00000024   004088E5           STR      R4,[R8, #+0]
   \   00000028   046088E5           STR      R6,[R8, #+4]
   \   0000002C   084088E5           STR      R4,[R8, #+8]
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C00C8E5           STRB     R0,[R8, #+12]
   \   00000038   0D00C8E5           STRB     R0,[R8, #+13]
   \   0000003C   107088E5           STR      R7,[R8, #+16]
   \                     ??_Insert_22:
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           _BLF     ??_Insert,??_Insert??rA_7
   \   00000054   0800A0E1           MOV      R0,R8
   \   00000058   F041BDE8           POP      {R4-R8,LR}
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::iterator _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Insert(bool, _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Nodeptr, int)
   \                     ??_Insert_7:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   1400A0E3           MOV      R0,#+20
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0080B0E1           MOVS     R8,R0
   \   00000020   0600000A           BEQ      ??_Insert_23
   \   00000024   004088E5           STR      R4,[R8, #+0]
   \   00000028   046088E5           STR      R6,[R8, #+4]
   \   0000002C   084088E5           STR      R4,[R8, #+8]
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C00C8E5           STRB     R0,[R8, #+12]
   \   00000038   0D00C8E5           STRB     R0,[R8, #+13]
   \   0000003C   107088E5           STR      R7,[R8, #+16]
   \                     ??_Insert_23:
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           _BLF     ??_Insert,??_Insert??rA_7
   \   00000054   0800A0E1           MOV      R0,R8
   \   00000058   F041BDE8           POP      {R4-R8,LR}
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Nodeptr _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Lbound(unsigned int) const
   \                     ??_Lbound:
   \   00000000   042090E5           LDR      R2,[R0, #+4]
   \                     ??_Lbound_1:
   \   00000004   0D30D2E5           LDRB     R3,[R2, #+13]
   \   00000008   000053E3           CMP      R3,#+0
   \   0000000C   1EFF2F11           BXNE     LR
   \   00000010   103092E5           LDR      R3,[R2, #+16]
   \   00000014   010053E1           CMP      R3,R1
   \   00000018   08209235           LDRCC    R2,[R2, #+8]
   \   0000001C   0200A021           MOVCS    R0,R2
   \   00000020   00209225           LDRCS    R2,[R2, #+0]
   \   00000024   F6FFFFEA           B        ??_Lbound_1

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs set<PRogramObjectBase *>::~set()
   \                     `?~set`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   041094E5           LDR      R1,[R4, #+4]
   \   0000000C   ........           _BLF     ??_Erase_4,??_Erase??rA_1
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000018   1040BDE8           POP      {R4,LR}
   \   0000001C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs set<AnalogInput *>::~set()
   \                     `?~set_1`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   041094E5           LDR      R1,[R4, #+4]
   \   0000000C   ........           _BLF     ??_Erase,??_Erase??rA_2
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000018   1040BDE8           POP      {R4,LR}
   \   0000001C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs set<unsigned int>::set(set<unsigned int> const &)
   \                     ??set:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0150A0E1           MOV      R5,R1
   \   00000008   1460D5E5           LDRB     R6,[R5, #+20]
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000014   1460C4E5           STRB     R6,[R4, #+20]
   \   00000018   0510A0E1           MOV      R1,R5
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           _BLF     ??_Copy,??_Copy??rA_1
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   7040BDE8           POP      {R4-R6,LR}
   \   0000002C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs set<unsigned int>::~set()
   \                     `?~set_2`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   041094E5           LDR      R1,[R4, #+4]
   \   0000000C   ........           _BLF     ??_Erase_5,??_Erase??rA_3
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000018   1040BDE8           POP      {R4,LR}
   \   0000001C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs set<unsigned int>::set()
   \                     ??set_1:
   \   00000000   11402DE9           PUSH     {R0,R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   0D00A0E1           MOV      R0,SP
   \   00000010   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           _BLF     ??_Clear,??_Clear??rA
   \   0000001C   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000020   1400C4E5           STRB     R0,[R4, #+20]
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   1240BDE8           POP      {R1,R4,LR}
   \   0000002C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs map<unsigned int, ModbusUnit *>::~map()
   \                     `?~map`:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   ........           _BLF     ??clear,??clear??rA
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Tidy0()
   \                     ??_Tidy0:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   001090E5           LDR      R1,[R0, #+0]
   \   00000008   000051E3           CMP      R1,#+0
   \   0000000C   0200000A           BEQ      ??_Tidy0_1
   \   00000010   041080E5           STR      R1,[R0, #+4]
   \   00000014   0100A0E1           MOV      R0,R1
   \   00000018   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \                     ??_Tidy0_1:
   \   0000001C   0040BDE8           POP      {LR}
   \   00000020   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs ModbusUnit::AddressRange * _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Make_room(ModbusUnit::AddressRange *, unsigned int)
   \                     ??_Make_room:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   007094E5           LDR      R7,[R4, #+0]
   \   0000000C   080094E5           LDR      R0,[R4, #+8]
   \   00000010   043094E5           LDR      R3,[R4, #+4]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   070040E0           SUB      R0,R0,R7
   \   0000001C   0C10A0E3           MOV      R1,#+12
   \   00000020   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000024   0160A0E1           MOV      R6,R1
   \   00000028   070043E0           SUB      R0,R3,R7
   \   0000002C   0C10A0E3           MOV      R1,#+12
   \   00000030   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000034   000052E3           CMP      R2,#+0
   \   00000038   2D00000A           BEQ      ??_Make_room_1
   \   0000003C   BC009FE5           LDR      R0,??_Make_room_2  ;; 0x15555555
   \   00000040   017040E0           SUB      R7,R0,R1
   \   00000044   020057E1           CMP      R7,R2
   \   00000048   2900003A           BCC      ??_Make_room_1
   \   0000004C   0C80A0E3           MOV      R8,#+12
   \   00000050   980207E0           MUL      R7,R8,R2
   \   00000054   018082E0           ADD      R8,R2,R1
   \   00000058   080056E1           CMP      R6,R8
   \   0000005C   1D00002A           BCS      ??_Make_room_3
   \   00000060   A610A0E1           LSR      R1,R6,#+1
   \   00000064   010040E0           SUB      R0,R0,R1
   \   00000068   060050E1           CMP      R0,R6
   \   0000006C   0060A033           MOVCC    R6,#+0
   \   00000070   06608120           ADDCS    R6,R1,R6
   \   00000074   080056E1           CMP      R6,R8
   \   00000078   0860A031           MOVCC    R6,R8
   \   0000007C   0C10A0E3           MOV      R1,#+12
   \   00000080   910600E0           MUL      R0,R1,R6
   \   00000084   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000088   0090A0E1           MOV      R9,R0
   \   0000008C   000094E5           LDR      R0,[R4, #+0]
   \   00000090   0920A0E1           MOV      R2,R9
   \   00000094   0510A0E1           MOV      R1,R5
   \   00000098   ........           _BLF     _Copy_a4,??_Copy_a4??rA
   \   0000009C   041094E5           LDR      R1,[R4, #+4]
   \   000000A0   00A0A0E1           MOV      R10,R0
   \   000000A4   0A2087E0           ADD      R2,R7,R10
   \   000000A8   0500A0E1           MOV      R0,R5
   \   000000AC   ........           _BLF     _Copy_a4,??_Copy_a4??rA
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   ........           _BLF     ??_Tidy0,??_Tidy0??rA
   \   000000B8   0C00A0E3           MOV      R0,#+12
   \   000000BC   909621E0           MLA      R1,R0,R6,R9
   \   000000C0   081084E5           STR      R1,[R4, #+8]
   \   000000C4   909821E0           MLA      R1,R0,R8,R9
   \   000000C8   041084E5           STR      R1,[R4, #+4]
   \   000000CC   009084E5           STR      R9,[R4, #+0]
   \   000000D0   0A50A0E1           MOV      R5,R10
   \   000000D4   060000EA           B        ??_Make_room_1
   \                     ??_Make_room_3:
   \   000000D8   032087E0           ADD      R2,R7,R3
   \   000000DC   0310A0E1           MOV      R1,R3
   \   000000E0   0500A0E1           MOV      R0,R5
   \   000000E4   ........           _BLF     _Copy_backward_a4,??_Copy_backward_a4??rA
   \   000000E8   040094E5           LDR      R0,[R4, #+4]
   \   000000EC   000087E0           ADD      R0,R7,R0
   \   000000F0   040084E5           STR      R0,[R4, #+4]
   \                     ??_Make_room_1:
   \   000000F4   0500A0E1           MOV      R0,R5
   \   000000F8   F047BDE8           POP      {R4-R10,LR}
   \   000000FC   1EFF2FE1           BX       LR               ;; return
   \                     ??_Make_room_2:
   \   00000100   55555515           DC32     0x15555555

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs ModbusUnit::AddressRange * _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Insert0(ModbusUnit::AddressRange *, ModbusUnit::AddressRange const &)
   \                     ??_Insert0:
   \   00000000   77402DE9           PUSH     {R0-R2,R4-R6,LR}
   \   00000004   085092E8           LDM      R2,{R3,R12,LR}
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   000094E5           LDR      R0,[R4, #+0]
   \   00000010   0120A0E3           MOV      R2,#+1
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0050A003           MOVEQ    R5,#+0
   \   0000001C   00504110           SUBNE    R5,R1,R0
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   085080E8           STM      R0,{R3,R12,LR}
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           _BLF     ??_Make_room,??_Make_room??rA
   \   00000030   0110A0E3           MOV      R1,#+1
   \   00000034   0D30A0E1           MOV      R3,SP
   \                     ??_Insert0_1:
   \   00000038   405093E8           LDM      R3,{R6,R12,LR}
   \   0000003C   0020A0E1           MOV      R2,R0
   \   00000040   011041E2           SUB      R1,R1,#+1
   \   00000044   0C0080E2           ADD      R0,R0,#+12
   \   00000048   405082E8           STM      R2,{R6,R12,LR}
   \   0000004C   000051E3           CMP      R1,#+0
   \   00000050   F8FFFF1A           BNE      ??_Insert0_1
   \   00000054   000094E5           LDR      R0,[R4, #+0]
   \   00000058   000085E0           ADD      R0,R5,R0
   \   0000005C   7E40BDE8           POP      {R1-R6,LR}
   \   00000060   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Push_back0(ModbusUnit::AddressRange const &)
   \                     ??_Push_back0:
   \   00000000   D0412DE9           PUSH     {R4,R6-R8,LR}
   \   00000004   043090E5           LDR      R3,[R0, #+4]
   \   00000008   082090E5           LDR      R2,[R0, #+8]
   \   0000000C   020053E1           CMP      R3,R2
   \   00000010   0B00002A           BCS      ??_Push_back0_1
   \   00000014   0120A0E3           MOV      R2,#+1
   \   00000018   03C0A0E1           MOV      R12,R3
   \                     ??_Push_back0_2:
   \   0000001C   C00191E8           LDM      R1,{R6-R8}
   \   00000020   0C40A0E1           MOV      R4,R12
   \   00000024   012042E2           SUB      R2,R2,#+1
   \   00000028   0CC08CE2           ADD      R12,R12,#+12
   \   0000002C   C00184E8           STM      R4,{R6-R8}
   \   00000030   000052E3           CMP      R2,#+0
   \   00000034   F8FFFF1A           BNE      ??_Push_back0_2
   \   00000038   0C1083E2           ADD      R1,R3,#+12
   \   0000003C   041080E5           STR      R1,[R0, #+4]
   \   00000040   020000EA           B        ??_Push_back0_3
   \                     ??_Push_back0_1:
   \   00000044   0120A0E1           MOV      R2,R1
   \   00000048   0310A0E1           MOV      R1,R3
   \   0000004C   ........           _BLF     ??_Insert0,??_Insert0??rA
   \                     ??_Push_back0_3:
   \   00000050   D041BDE8           POP      {R4,R6-R8,LR}
   \   00000054   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs vector<ModbusUnit::AddressRange>::vector()
   \                     ??vector:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   001080E5           STR      R1,[R0, #+0]
   \   00000008   041080E5           STR      R1,[R0, #+4]
   \   0000000C   081080E5           STR      R1,[R0, #+8]
   \   00000010   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs vector<ModbusUnit::AddressRange>::~vector()
   \                     `?~vector`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   ........           _BLF     ??_Tidy0,??_Tidy0??rA
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   000084E5           STR      R0,[R4, #+0]
   \   00000014   040084E5           STR      R0,[R4, #+4]
   \   00000018   080084E5           STR      R0,[R4, #+8]
   \   0000001C   1040BDE8           POP      {R4,LR}
   \   00000020   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void operator+(string const &, string const &)
   \                     `??operator+`:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   ........           _BLF     ??string,??string??rA
   \   00000018   34109FE5           LDR      R1,`??operator+_3`  ;; ??npos
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   003091E5           LDR      R3,[R1, #+0]
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   ........           _BLF     ??append,??append??rA
   \   0000002C   0010A0E1           MOV      R1,R0
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           _BLF     ??string,??string??rA
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   0110A0E3           MOV      R1,#+1
   \   00000040   0D00A0E1           MOV      R0,SP
   \   00000044   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000048   1CD08DE2           ADD      SP,SP,#+28
   \   0000004C   3040BDE8           POP      {R4,R5,LR}
   \   00000050   1EFF2FE1           BX       LR               ;; return
   \                     `??operator+_3`:
   \   00000054   ........           DC32     ??npos

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void operator+(char const *, string const &)
   \                     `??operator+_1`:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0020A0E3           MOV      R2,#+0
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     strlen,??strlen??rA
   \   0000002C   0020A0E1           MOV      R2,R0
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   0D00A0E1           MOV      R0,SP
   \   00000038   ........           _BLF     ??assign_1,??assign??rA_1
   \   0000003C   38009FE5           LDR      R0,`??operator+_4`  ;; ??npos
   \   00000040   0020A0E3           MOV      R2,#+0
   \   00000044   003090E5           LDR      R3,[R0, #+0]
   \   00000048   0610A0E1           MOV      R1,R6
   \   0000004C   0D00A0E1           MOV      R0,SP
   \   00000050   ........           _BLF     ??append,??append??rA
   \   00000054   0010A0E1           MOV      R1,R0
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           _BLF     ??string,??string??rA
   \   00000060   0020A0E3           MOV      R2,#+0
   \   00000064   0110A0E3           MOV      R1,#+1
   \   00000068   0D00A0E1           MOV      R0,SP
   \   0000006C   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000070   1CD08DE2           ADD      SP,SP,#+28
   \   00000074   7040BDE8           POP      {R4-R6,LR}
   \   00000078   1EFF2FE1           BX       LR               ;; return
   \                     `??operator+_4`:
   \   0000007C   ........           DC32     ??npos

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void operator+(string const &, char const *)
   \                     `??operator+_2`:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   ........           _BLF     ??string,??string??rA
   \   00000018   0060A0E1           MOV      R6,R0
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   ........           _BLF     strlen,??strlen??rA
   \   00000024   0020A0E1           MOV      R2,R0
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   0600A0E1           MOV      R0,R6
   \   00000030   ........           _BLF     ??append_1,??append??rA_1
   \   00000034   0010A0E1           MOV      R1,R0
   \   00000038   0400A0E1           MOV      R0,R4
   \   0000003C   ........           _BLF     ??string,??string??rA
   \   00000040   0020A0E3           MOV      R2,#+0
   \   00000044   0110A0E3           MOV      R1,#+1
   \   00000048   0D00A0E1           MOV      R0,SP
   \   0000004C   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000050   1CD08DE2           ADD      SP,SP,#+28
   \   00000054   7040BDE8           POP      {R4-R6,LR}
   \   00000058   1EFF2FE1           BX       LR               ;; return
      2          #pragma hdrstop
      3          #ifdef BORLAND
      4              #pragma package(smart_init)
      5          #endif

   \                                 In segment DATA_C, align 4, align-sorted
      6          map<unsigned, ModbusUnit *>ModbusUnit::DeviceMap;
   \                     ?_0:
   \   00000000   ............       DC32 ?_1, ??DeviceMap, `?~map`
   \              ............
   \   0000000C   ............       DC32 ?_3, ??ObjectSet, `?~set`
   \              ............

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ??DeviceMap:
   \   00000000                      DS8 24
      7          set<PRogramObjectBase *>ModbusUnit::ObjectSet;
   \                     ??ObjectSet:
   \   00000018                      DS8 24
      8          

   \                                 In segment CODE, align 4, keep-with-next
      9          ModbusUnit::ModbusUnit(int Addr, int ComPortNo) {
   \                     ??ModbusUnit:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   ........           LDR      R8,??DataTable3  ;; ??__vtbl
   \   00000008   B4D04DE2           SUB      SP,SP,#+180
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   ........           _BLF     ??ModbusPro,??ModbusPro??rA
   \   0000001C   0110A0E3           MOV      R1,#+1
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           _BLF     ??PRogramObject,??PRogramObject??rA
   \   00000028   740BA0E3           MOV      R0,#+118784
   \   0000002C   8B0F80E3           ORR      R0,R0,#0x22C
   \   00000030   047080E0           ADD      R7,R0,R4
   \   00000034   588087E5           STR      R8,[R7, #+88]
   \   00000038   9C9084E2           ADD      R9,R4,#+156
   \   0000003C   0C0088E2           ADD      R0,R8,#+12
   \   00000040   080089E5           STR      R0,[R9, #+8]
   \   00000044   520F84E2           ADD      R0,R4,#+328
   \   00000048   ........           _BLF     ??vector,??vector??rA
   \   0000004C   550F84E2           ADD      R0,R4,#+340
   \   00000050   ........           _BLF     ??vector,??vector??rA
   \   00000054   580F84E2           ADD      R0,R4,#+352
   \   00000058   ........           _BLF     ??vector,??vector??rA
   \   0000005C   5B0F84E2           ADD      R0,R4,#+364
   \   00000060   ........           _BLF     ??vector,??vector??rA
   \   00000064   5EAF84E2           ADD      R10,R4,#+376
   \   00000068   0110A0E3           MOV      R1,#+1
   \   0000006C   0D00A0E1           MOV      R0,SP
   \   00000070   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   00000074   0A00A0E1           MOV      R0,R10
   \   00000078   ........           _BLF     ??_Clear,??_Clear??rA
   \   0000007C   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000080   0110A0E3           MOV      R1,#+1
   \   00000084   1400CAE5           STRB     R0,[R10, #+20]
   \   00000088   6DAF84E2           ADD      R10,R4,#+436
   \   0000008C   01008DE2           ADD      R0,SP,#+1
   \   00000090   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   00000094   0A00A0E1           MOV      R0,R10
   \   00000098   ........           _BLF     ??_Clear,??_Clear??rA
   \   0000009C   0100DDE5           LDRB     R0,[SP, #+1]
   \   000000A0   1400CAE5           STRB     R0,[R10, #+20]
   \   000000A4   400BA0E3           MOV      R0,#+65536
   \   000000A8   730F80E3           ORR      R0,R0,#0x1CC
   \   000000AC   040080E0           ADD      R0,R0,R4
   \   000000B0   ........           _BLF     ??set_1,??set??rA
   \   000000B4   400BA0E3           MOV      R0,#+65536
   \   000000B8   790F80E3           ORR      R0,R0,#0x1E4
   \   000000BC   040080E0           ADD      R0,R0,R4
   \   000000C0   ........           _BLF     ??set_1,??set??rA
   \   000000C4   400BA0E3           MOV      R0,#+65536
   \   000000C8   7F0F80E3           ORR      R0,R0,#0x1FC
   \   000000CC   040080E0           ADD      R0,R0,R4
   \   000000D0   ........           _BLF     ??set_1,??set??rA
   \   000000D4   400BA0E3           MOV      R0,#+65536
   \   000000D8   850F80E3           ORR      R0,R0,#0x214
   \   000000DC   040080E0           ADD      R0,R0,R4
   \   000000E0   ........           _BLF     ??set_1,??set??rA
   \   000000E4   740BA0E3           MOV      R0,#+118784
   \   000000E8   960F80E3           ORR      R0,R0,#0x258
   \   000000EC   04A080E0           ADD      R10,R0,R4
   \   000000F0   0110A0E3           MOV      R1,#+1
   \   000000F4   02008DE2           ADD      R0,SP,#+2
   \   000000F8   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   000000FC   0A00A0E1           MOV      R0,R10
   \   00000100   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000104   0200DDE5           LDRB     R0,[SP, #+2]
   \   00000108   1400CAE5           STRB     R0,[R10, #+20]
     10              ObjectSet.insert(this);
   \   0000010C   ........           LDR      R10,??DataTable2  ;; ??DeviceMap
   \   00000110   740BA0E3           MOV      R0,#+118784
   \   00000114   9D0F80E3           ORR      R0,R0,#0x274
   \   00000118   040080E0           ADD      R0,R0,R4
   \   0000011C   ........           _BLF     ??ANCriticalSection,??ANCriticalSection??rA
   \   00000120   0420A0E1           MOV      R2,R4
   \   00000124   18108AE2           ADD      R1,R10,#+24
   \   00000128   04008DE2           ADD      R0,SP,#+4
   \   0000012C   ........           _BLF     ??insert,??insert??rA
     11              IDNumber    = (C_PRO_MODBUS_UNIT << 16) + ObjectSet.size();
   \   00000130   28009AE5           LDR      R0,[R10, #+40]
     12              Type        = C_PRO_MODBUS_UNIT;
     13          
     14              IsMaster            = false;
   \   00000134   0010A0E3           MOV      R1,#+0
   \   00000138   AF0680E2           ADD      R0,R0,#+183500800
   \   0000013C   000089E5           STR      R0,[R9, #+0]
   \   00000140   AF0EA0E3           MOV      R0,#+2800
   \   00000144   040089E5           STR      R0,[R9, #+4]
   \   00000148   0000A0E3           MOV      R0,#+0
   \   0000014C   F410C9E5           STRB     R1,[R9, #+244]
     15              Address             = Addr;
   \   00000150   F85089E5           STR      R5,[R9, #+248]
     16              ComPort             = ComPortNo;
   \   00000154   FC6089E5           STR      R6,[R9, #+252]
     17              myPort              = NULL;
   \   00000158   000189E5           STR      R0,[R9, #+256]
     18              myRequestDelay      = 0;
   \   0000015C   080189E5           STR      R0,[R9, #+264]
     19              myTimeOut           = 0;
   \   00000160   0C0189E5           STR      R0,[R9, #+268]
     20              myFrameSpaceTime    = 0;
   \   00000164   100189E5           STR      R0,[R9, #+272]
     21              myFrameTimeOut      = 0;
   \   00000168   140189E5           STR      R0,[R9, #+276]
     22              for ( int i = 0; i < MODBUS_MAX_REGISTERS; i++ ) {
   \   0000016C   0060A0E1           MOV      R6,R0
     23                  AnalogOut[i]            = 0;
   \                     ??ModbusUnit_1:
   \   00000170   812084E0           ADD      R2,R4,R1, LSL #+1
   \   00000174   733F82E2           ADD      R3,R2,#+460
   \   00000178   B000C3E1           STRH     R0,[R3, #+0]
     24                  AnalogIn[i]             = 0;
   \   0000017C   CC30A0E3           MOV      R3,#+204
   \   00000180   813C83E3           ORR      R3,R3,#0x8100
   \   00000184   B20083E1           STRH     R0,[R3, +R2]
     25                  NewAnalogIn[i]          = false;
   \   00000188   402BA0E3           MOV      R2,#+65536
   \   0000018C   8B2F82E3           ORR      R2,R2,#0x22C
   \   00000190   043081E0           ADD      R3,R1,R4
   \   00000194   0360C2E7           STRB     R6,[R2, +R3]
     26                  PreviousDigitalIn[i]    = false;
   \   00000198   802C82E3           ORR      R2,R2,#0x8000
   \   0000019C   0360C2E7           STRB     R6,[R2, +R3]
     27                  NewDigitalIn[i]         = false;
   \   000001A0   402C42E2           SUB      R2,R2,#+16384
   \   000001A4   0360C2E7           STRB     R6,[R2, +R3]
     28              }
   \   000001A8   011081E2           ADD      R1,R1,#+1
   \   000001AC   400C51E3           CMP      R1,#+16384
   \   000001B0   EEFFFFBA           BLT      ??ModbusUnit_1
     29              for ( int i = 0; i < MODBUS_MAX_REGISTERS / 8; i++ ) {
   \   000001B4   0010A0E3           MOV      R1,#+0
     30                  DigitalOut[i] = 0;
   \                     ??ModbusUnit_2:
   \   000001B8   702BA0E3           MOV      R2,#+114688
   \   000001BC   8B2F82E3           ORR      R2,R2,#0x22C
   \   000001C0   043081E0           ADD      R3,R1,R4
   \   000001C4   032082E0           ADD      R2,R2,R3
   \   000001C8   0000C2E5           STRB     R0,[R2, #+0]
     31                  DigitalIn[i]  = 0;
   \   000001CC   0008C2E5           STRB     R0,[R2, #+2048]
     32              }
   \   000001D0   011081E2           ADD      R1,R1,#+1
   \   000001D4   800E51E3           CMP      R1,#+2048
   \   000001D8   F6FFFFBA           BLT      ??ModbusUnit_2
     33              LastAnalogOut      = 0;
   \   000001DC   000087E5           STR      R0,[R7, #+0]
     34              LastAnalogIn       = 0;
   \   000001E0   040087E5           STR      R0,[R7, #+4]
     35              LastDigitalOut     = 0;
   \   000001E4   080087E5           STR      R0,[R7, #+8]
     36              LastDigitalIn      = 0;
   \   000001E8   0C0087E5           STR      R0,[R7, #+12]
     37              StartAnalogOut     = INT_MAX;
   \   000001EC   8014E0E3           MVN      R1,#-2147483648
   \   000001F0   101087E5           STR      R1,[R7, #+16]
     38              StartAnalogIn      = INT_MAX;
   \   000001F4   141087E5           STR      R1,[R7, #+20]
     39              StartDigitalOut    = INT_MAX;
   \   000001F8   181087E5           STR      R1,[R7, #+24]
     40              StartDigitalIn     = INT_MAX;
   \   000001FC   1C1087E5           STR      R1,[R7, #+28]
     41              HasAnalogOut       = false;
   \   00000200   0010A0E3           MOV      R1,#+0
   \   00000204   2010C7E5           STRB     R1,[R7, #+32]
     42              HasDigitalOut      = false;
   \   00000208   2110C7E5           STRB     R1,[R7, #+33]
     43              HasAnalogIn        = false;
   \   0000020C   2210C7E5           STRB     R1,[R7, #+34]
     44              HasDigitalIn       = false;
   \   00000210   2310C7E5           STRB     R1,[R7, #+35]
     45              ComFailCount       = 0;
   \   00000214   240087E5           STR      R0,[R7, #+36]
     46              ComTotalFailCount   = 0;
   \   00000218   280087E5           STR      R0,[R7, #+40]
     47              hasNewRegOutput    = false;
   \   0000021C   4410C7E5           STRB     R1,[R7, #+68]
     48              hasNewCoilOutput   = false;
   \   00000220   4500C7E5           STRB     R0,[R7, #+69]
     49              AddressSystem      = C_UART_DEVICE;
   \   00000224   6000A0E3           MOV      R0,#+96
   \   00000228   7C0D80E3           ORR      R0,R0,#0x1F00
   \   0000022C   040189E5           STR      R0,[R9, #+260]
     50              AlarmModbusComFailure *ComAlarm  = new AlarmModbusComFailure(this, 5);
   \   00000230   4014A0E3           MOV      R1,#+1073741824
   \   00000234   A01881E3           ORR      R1,R1,#0xA00000
   \   00000238   0400A0E1           MOV      R0,R4
   \   0000023C   ........           _BLF     `??new AlarmModbusComFailure`,`??new AlarmModbusComFailure??rA`
   \   00000240   0060A0E1           MOV      R6,R0
     51              Name             = "ModbusUnit" + AnsiString(ComPort) + ":" + AnsiString(Addr);
   \   00000244   0510A0E1           MOV      R1,R5
   \   00000248   98008DE2           ADD      R0,SP,#+152
   \   0000024C   ........           _BLF     ??AnsiString,??AnsiString??rA
   \   00000250   FC1099E5           LDR      R1,[R9, #+252]
   \   00000254   0050A0E1           MOV      R5,R0
   \   00000258   7C008DE2           ADD      R0,SP,#+124
   \   0000025C   ........           _BLF     ??AnsiString,??AnsiString??rA
   \   00000260   0020A0E1           MOV      R2,R0
   \   00000264   881088E2           ADD      R1,R8,#+136
   \   00000268   44008DE2           ADD      R0,SP,#+68
   \   0000026C   ........           _BLF     `??operator+_1`,`??operator+??rA`
   \   00000270   2E2F8FE2           ADR      R2,??ModbusUnit_3  ;; ":"
   \   00000274   44108DE2           ADD      R1,SP,#+68
   \   00000278   28008DE2           ADD      R0,SP,#+40
   \   0000027C   ........           _BLF     `??operator+_2`,`??operator+??rA_1`
   \   00000280   0520A0E1           MOV      R2,R5
   \   00000284   28108DE2           ADD      R1,SP,#+40
   \   00000288   0C008DE2           ADD      R0,SP,#+12
   \   0000028C   ........           _BLF     `??operator+`,`??operator+??rA_2`
   \   00000290   0C108DE2           ADD      R1,SP,#+12
   \   00000294   60008DE2           ADD      R0,SP,#+96
   \   00000298   ........           _BLF     ??AnsiString_1,??AnsiString??rA_1
   \   0000029C   0010A0E1           MOV      R1,R0
   \   000002A0   8C009FE5           LDR      R0,??ModbusUnit_3+0x4  ;; ??npos
   \   000002A4   0020A0E3           MOV      R2,#+0
   \   000002A8   003090E5           LDR      R3,[R0, #+0]
   \   000002AC   440084E2           ADD      R0,R4,#+68
   \   000002B0   ........           _BLF     ??assign,??assign??rA
   \   000002B4   0020A0E3           MOV      R2,#+0
   \   000002B8   0110A0E3           MOV      R1,#+1
   \   000002BC   60008DE2           ADD      R0,SP,#+96
   \   000002C0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000002C4   0020A0E3           MOV      R2,#+0
   \   000002C8   0110A0E3           MOV      R1,#+1
   \   000002CC   0C008DE2           ADD      R0,SP,#+12
   \   000002D0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000002D4   0020A0E3           MOV      R2,#+0
   \   000002D8   0110A0E3           MOV      R1,#+1
   \   000002DC   98008DE2           ADD      R0,SP,#+152
   \   000002E0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000002E4   0020A0E3           MOV      R2,#+0
   \   000002E8   0110A0E3           MOV      R1,#+1
   \   000002EC   28008DE2           ADD      R0,SP,#+40
   \   000002F0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000002F4   0020A0E3           MOV      R2,#+0
   \   000002F8   0110A0E3           MOV      R1,#+1
   \   000002FC   44008DE2           ADD      R0,SP,#+68
   \   00000300   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000304   0020A0E3           MOV      R2,#+0
   \   00000308   0110A0E3           MOV      R1,#+1
   \   0000030C   7C008DE2           ADD      R0,SP,#+124
   \   00000310   ........           _BLF     ??_Tidy,??_Tidy??rA
     52              AlarmSet.insert(ComAlarm);
   \   00000314   0620A0E1           MOV      R2,R6
   \   00000318   E41084E2           ADD      R1,R4,#+228
   \   0000031C   04008DE2           ADD      R0,SP,#+4
   \   00000320   ........           _BLF     ??insert_5,??insert??rA_1
     53          }
   \   00000324   0400A0E1           MOV      R0,R4
   \   00000328   B4D08DE2           ADD      SP,SP,#+180
   \   0000032C   ........           B        ?Subroutine53
   \                     ??ModbusUnit_3:
   \   00000330   3A000000           DC8      ":",+0,+0
   \   00000334   ........           DC32     ??npos

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine53:
   \   00000000   F047BDE8           POP      {R4-R10,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
     54          

   \                                 In segment CODE, align 4, keep-with-next
     55          ModbusUnit::~ModbusUnit(void) {
   \                     `?~ModbusUnit`:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   3700000A           BEQ      `?~ModbusUnit_1`
   \   00000014   ........           LDR      R0,??DataTable3  ;; ??__vtbl
   \   00000018   741BA0E3           MOV      R1,#+118784
   \   0000001C   A11F81E3           ORR      R1,R1,#0x284
   \   00000020   040081E7           STR      R0,[R1, +R4]
   \   00000024   0C0080E2           ADD      R0,R0,#+12
   \   00000028   A40084E5           STR      R0,[R4, #+164]
     56          }
   \   0000002C   100041E2           SUB      R0,R1,#+16
   \   00000030   040080E0           ADD      R0,R0,R4
   \   00000034   ........           _BLF     `?~ANCriticalSection`,`?~ANCriticalSection??rA`
   \   00000038   740BA0E3           MOV      R0,#+118784
   \   0000003C   960F80E3           ORR      R0,R0,#0x258
   \   00000040   046080E0           ADD      R6,R0,R4
   \   00000044   041096E5           LDR      R1,[R6, #+4]
   \   00000048   0600A0E1           MOV      R0,R6
   \   0000004C   ........           _BLF     ??_Erase_3,??_Erase??rA_4
   \   00000050   0600A0E1           MOV      R0,R6
   \   00000054   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000058   400BA0E3           MOV      R0,#+65536
   \   0000005C   850F80E3           ORR      R0,R0,#0x214
   \   00000060   040080E0           ADD      R0,R0,R4
   \   00000064   ........           _BLF     `?~set_2`,`?~set??rA`
   \   00000068   400BA0E3           MOV      R0,#+65536
   \   0000006C   7F0F80E3           ORR      R0,R0,#0x1FC
   \   00000070   040080E0           ADD      R0,R0,R4
   \   00000074   ........           _BLF     `?~set_2`,`?~set??rA`
   \   00000078   400BA0E3           MOV      R0,#+65536
   \   0000007C   790F80E3           ORR      R0,R0,#0x1E4
   \   00000080   040080E0           ADD      R0,R0,R4
   \   00000084   ........           _BLF     `?~set_2`,`?~set??rA`
   \   00000088   400BA0E3           MOV      R0,#+65536
   \   0000008C   730F80E3           ORR      R0,R0,#0x1CC
   \   00000090   040080E0           ADD      R0,R0,R4
   \   00000094   ........           _BLF     `?~set_2`,`?~set??rA`
   \   00000098   6D6F84E2           ADD      R6,R4,#+436
   \   0000009C   041096E5           LDR      R1,[R6, #+4]
   \   000000A0   0600A0E1           MOV      R0,R6
   \   000000A4   ........           _BLF     ??_Erase_1,??_Erase??rA_5
   \   000000A8   0600A0E1           MOV      R0,R6
   \   000000AC   ........           _BLF     ??_Clear,??_Clear??rA
   \   000000B0   5E0F84E2           ADD      R0,R4,#+376
   \   000000B4   ........           _BLF     `?~set_1`,`?~set??rA_1`
   \   000000B8   5B0F84E2           ADD      R0,R4,#+364
   \   000000BC   ........           _BLF     `?~vector`,`?~vector??rA`
   \   000000C0   580F84E2           ADD      R0,R4,#+352
   \   000000C4   ........           _BLF     `?~vector`,`?~vector??rA`
   \   000000C8   550F84E2           ADD      R0,R4,#+340
   \   000000CC   ........           _BLF     `?~vector`,`?~vector??rA`
   \   000000D0   520F84E2           ADD      R0,R4,#+328
   \   000000D4   ........           _BLF     `?~vector`,`?~vector??rA`
   \   000000D8   0010A0E3           MOV      R1,#+0
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           _BLF     `?~PRogramObject`,`?~PRogramObject??rA`
   \   000000E4   010015E3           TST      R5,#0x1
   \   000000E8   0100000A           BEQ      `?~ModbusUnit_1`
   \   000000EC   0400A0E1           MOV      R0,R4
   \   000000F0   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \                     `?~ModbusUnit_1`:
   \   000000F4   ........           B        ??Subroutine49_0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine49:
   \   00000000   8B0F80E3           ORR      R0,R0,#0x22C
   \   00000004   C61185E0           ADD      R1,R5,R6, ASR #+3
   \   00000008   0100D0E7           LDRB     R0,[R0, +R1]
   \   0000000C   071006E2           AND      R1,R6,#0x7
   \   00000010   0120A0E3           MOV      R2,#+1
   \   00000014   300112E1           TST      R2,R0, LSR R1
   \   00000018   0150A013           MOVNE    R5,#+1
   \   0000001C   0050A003           MOVEQ    R5,#+0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           _BLF     ??Release,??Release??rA
   \   00000028   0500A0E1           MOV      R0,R5
   \                     ??Subroutine49_0:
   \   0000002C   7040BDE8           POP      {R4-R6,LR}
   \   00000030   1EFF2FE1           BX       LR               ;; return
     57          

   \                                 In segment CODE, align 4, keep-with-next
     58          U16  ModbusUnit::GetOutputRegister(int Index, bool LittleEndian) {
     59              U16 RetVal = 0;
   \                     ??GetOutputRegister:
   \   00000000   0030A0E3           MOV      R3,#+0
     60              if ( Index < MODBUS_MAX_REGISTERS ) {
   \   00000004   400C51E3           CMP      R1,#+16384
   \   00000008   050000AA           BGE      ??GetOutputRegister_1
     61                  U16 tmpReg = AnalogOut[Index];
   \   0000000C   810080E0           ADD      R0,R0,R1, LSL #+1
   \   00000010   730F80E2           ADD      R0,R0,#+460
   \   00000014   B030D0E1           LDRH     R3,[R0, #+0]
     62                  if ( LittleEndian ) {
   \   00000018   000052E3           CMP      R2,#+0
     63                      RetVal = tmpReg;
     64                  } else {
     65                      RetVal = (tmpReg >> 8) | ((tmpReg & 0xff) << 8);
   \   0000001C   0314A001           LSLEQ    R1,R3,#+8
   \   00000020   23348101           ORREQ    R3,R1,R3, LSR #+8
     66                  }
     67              }
     68              return RetVal;
   \                     ??GetOutputRegister_1:
   \   00000024   ........           B        ?Subroutine50
     69          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine50:
   \   00000000   0308A0E1           MOV      R0,R3, LSL #+16
   \                     ??Subroutine50_0:
   \   00000004   2008A0E1           MOV      R0,R0, LSR #+16
   \   00000008   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     70          U16  ModbusUnit::GetRegister(int Index, bool LittleEndian) {
     71              U16 RetVal = 0;
   \                     ??GetRegister:
   \   00000000   0030A0E3           MOV      R3,#+0
     72              if ( Index < MODBUS_MAX_REGISTERS ) {
   \   00000004   400C51E3           CMP      R1,#+16384
   \   00000008   060000AA           BGE      ??GetRegister_1
     73                  U16 tmpReg = AnalogIn[Index];
   \   0000000C   CC30A0E3           MOV      R3,#+204
   \   00000010   813C83E3           ORR      R3,R3,#0x8100
   \   00000014   810080E0           ADD      R0,R0,R1, LSL #+1
   \   00000018   B03093E1           LDRH     R3,[R3, +R0]
     74                  if ( LittleEndian ) {
   \   0000001C   000052E3           CMP      R2,#+0
     75                      RetVal = tmpReg;
     76                  } else {
     77                      RetVal = (tmpReg >> 8) | ((tmpReg & 0xff) << 8);
   \   00000020   0314A001           LSLEQ    R1,R3,#+8
   \   00000024   23348101           ORREQ    R3,R1,R3, LSR #+8
     78                  }
     79              }
     80              return RetVal;
   \                     ??GetRegister_1:
   \   00000028                      REQUIRE ?Subroutine50
   \   00000028                      ;; // Fall through to label ?Subroutine50
     81          }
     82          
     83          

   \                                 In segment CODE, align 4, keep-with-next
     84          U16  ModbusUnit::GetRegisterDirect(int Channel, bool LittleEndian) {
   \                     ??GetRegisterDirect:
   \   00000000   F1402DE9           PUSH     {R0,R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     85              U16 RetVal = 0;
   \   0000000C   0010A0E3           MOV      R1,#+0
     86              int RetryCnt = 0;
     87              bool ErrStat;
     88          
     89              U16 tmpReg = 0;
   \   00000010   B010CDE1           STRH     R1,[SP, #+0]
     90              if ( myPort ) {
   \   00000014   9C1194E5           LDR      R1,[R4, #+412]
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   0070A0E1           MOV      R7,R0
   \   00000024   000051E3           CMP      R1,#+0
   \   00000028   1C00000A           BEQ      ??GetRegisterDirect_1
     91                  do {
     92                      ErrStat = (Get_Multiple(myPort, MBUS_CMD_READ_HOLDING_REGISTER, Address, Channel, 1, (U8 *)&tmpReg, myTimeOut, myFrameSpaceTime, myFrameTimeOut) == PORT_FAILURE);
   \                     ??GetRegisterDirect_2:
   \   0000002C   B00194E5           LDR      R0,[R4, #+432]
   \   00000030   0530A0E1           MOV      R3,R5
   \   00000034   01002DE9           PUSH     {R0}
   \   00000038   AC0194E5           LDR      R0,[R4, #+428]
   \   0000003C   0310A0E3           MOV      R1,#+3
   \   00000040   01002DE9           PUSH     {R0}
   \   00000044   A80194E5           LDR      R0,[R4, #+424]
   \   00000048   01002DE9           PUSH     {R0}
   \   0000004C   0C008DE2           ADD      R0,SP,#+12
   \   00000050   01002DE9           PUSH     {R0}
   \   00000054   0100A0E3           MOV      R0,#+1
   \   00000058   01002DE9           PUSH     {R0}
   \   0000005C   942194E5           LDR      R2,[R4, #+404]
   \   00000060   9C0194E5           LDR      R0,[R4, #+412]
   \   00000064   ........           _BLF     ??Get_Multiple,??Get_Multiple??rA
   \   00000068   0B0070E3           CMN      R0,#+11
   \   0000006C   14D08DE2           ADD      SP,SP,#+20
   \   00000070   0500001A           BNE      ??GetRegisterDirect_3
     93                      if ( ErrStat ) {
     94                          //Cnt++;
     95                          TSN_Delay(10);
   \   00000074   0A00A0E3           MOV      R0,#+10
   \   00000078   ........           _BLF     OS_Delay,??OS_Delay??rA
   \   0000007C   0700A0E1           MOV      R0,R7
   \   00000080   017080E2           ADD      R7,R0,#+1
   \   00000084   050050E3           CMP      R0,#+5
   \   00000088   E7FFFFBA           BLT      ??GetRegisterDirect_2
     96                      }
     97                  }while ( ErrStat && RetryCnt++ < 5 );
     98          
     99                  if ( LittleEndian ) {
   \                     ??GetRegisterDirect_3:
   \   0000008C   B000DDE1           LDRH     R0,[SP, #+0]
   \   00000090   000056E3           CMP      R6,#+0
    100                      RetVal = tmpReg;
    101                  } else {
    102                      RetVal = (tmpReg >> 8) | ((tmpReg & 0xff) << 8);
   \   00000094   0010A001           MOVEQ    R1,R0
   \   00000098   0114A001           LSLEQ    R1,R1,#+8
   \   0000009C   20048101           ORREQ    R0,R1,R0, LSR #+8
    103                  }
    104              }
    105              return RetVal;
   \                     ??GetRegisterDirect_1:
   \   000000A0   F240BDE8           POP      {R1,R4-R7,LR}
   \   000000A4   0008A0E1           MOV      R0,R0, LSL #+16
   \   000000A8   ........           B        ??Subroutine50_0
    106          }
    107          
    108          

   \                                 In segment CODE, align 4, keep-with-next
    109          void ModbusUnit::SetRegisterDirect(int Channel, U16 NewVal) {
   \                     ??SetRegisterDirect:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    110              if ( myPort ) {
   \   00000008   9C0194E5           LDR      R0,[R4, #+412]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   1600000A           BEQ      ??SetRegisterDirect_1
    111                  //AnalogOut[Channel] = (NewVal >> 8) | ((NewVal & 0xff) << 8);
    112                  int RetryCnt = 0;
   \   0000001C   0070A0E3           MOV      R7,#+0
    113                  bool ErrStat;
    114          
    115                  do {
    116                      ErrStat = (Set_Single(myPort, MBUS_CMD_WRITE_SINGLE_REGISTER, Address, Channel, NewVal, myTimeOut, myFrameSpaceTime, myFrameTimeOut) == PORT_FAILURE);
   \                     ??SetRegisterDirect_2:
   \   00000020   B00194E5           LDR      R0,[R4, #+432]
   \   00000024   0530A0E1           MOV      R3,R5
   \   00000028   01002DE9           PUSH     {R0}
   \   0000002C   AC0194E5           LDR      R0,[R4, #+428]
   \   00000030   0610A0E3           MOV      R1,#+6
   \   00000034   01002DE9           PUSH     {R0}
   \   00000038   A80194E5           LDR      R0,[R4, #+424]
   \   0000003C   01002DE9           PUSH     {R0}
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   01002DE9           PUSH     {R0}
   \   00000048   942194E5           LDR      R2,[R4, #+404]
   \   0000004C   9C0194E5           LDR      R0,[R4, #+412]
   \   00000050   ........           _BLF     ??Set_Single,??Set_Single??rA
   \   00000054   0B0070E3           CMN      R0,#+11
   \   00000058   10D08DE2           ADD      SP,SP,#+16
   \   0000005C   0500001A           BNE      ??SetRegisterDirect_1
    117                      if ( ErrStat ) {
    118                          //Cnt++;
    119                          TSN_Delay(10);
   \   00000060   0A00A0E3           MOV      R0,#+10
   \   00000064   ........           _BLF     OS_Delay,??OS_Delay??rA
   \   00000068   0700A0E1           MOV      R0,R7
   \   0000006C   017080E2           ADD      R7,R0,#+1
   \   00000070   0A0050E3           CMP      R0,#+10
   \   00000074   E9FFFFBA           BLT      ??SetRegisterDirect_2
    120                      }
    121                  }while ( ErrStat && RetryCnt++ < 10 );
    122              }
    123          }
   \                     ??SetRegisterDirect_1:
   \   00000078   ........           B        ?Subroutine54

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine54:
   \   00000000   F040BDE8           POP      {R4-R7,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    124          

   \                                 In segment CODE, align 4, keep-with-next
    125          bool ModbusUnit::SlaveSetRegisters(U16 *Registers, int FirstReg, int NumberOfRegs, U8 *DataPtr) {
   \                     ??SlaveSetRegisters:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   18109DE5           LDR      R1,[SP, #+24]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0370A0E1           MOV      R7,R3
    126              bool NoError = false;
   \   00000018   0080A0E3           MOV      R8,#+0
    127              if ( FirstReg < MODBUS_MAX_REGISTERS && NumberOfRegs <= MAX_REGISTERS_RTU_WRITE ) {
   \   0000001C   400C56E3           CMP      R6,#+16384
   \   00000020   7C0057B3           CMPLT    R7,#+124
   \   00000024   0C0000AA           BGE      ??SlaveSetRegisters_1
    128                  memcpy(&Registers[FirstReg], DataPtr, NumberOfRegs * 2);
   \   00000028   8720A0E1           LSL      R2,R7,#+1
   \   0000002C   860085E0           ADD      R0,R5,R6, LSL #+1
   \   00000030   ........           _BLF     memcpy,??memcpy??rA
    129                  NoError = true;
   \   00000034   0180A0E3           MOV      R8,#+1
    130                  if ( (void*)Registers == (void*)AnalogIn ) {
   \   00000038   CC00A0E3           MOV      R0,#+204
   \   0000003C   810C80E3           ORR      R0,R0,#0x8100
   \   00000040   040080E0           ADD      R0,R0,R4
   \   00000044   000055E1           CMP      R5,R0
   \   00000048   0300001A           BNE      ??SlaveSetRegisters_1
    131                      FlagNewValues(FirstReg, NumberOfRegs);
   \   0000004C   0720A0E1           MOV      R2,R7
   \   00000050   0610A0E1           MOV      R1,R6
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       ??FlagNewValues
    132                  }
    133              }
    134              return NoError;
   \                     ??SlaveSetRegisters_1:
   \   0000005C   0800A0E1           MOV      R0,R8
   \   00000060                      REQUIRE ?Subroutine55
   \   00000060                      ;; // Fall through to label ?Subroutine55
    135          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine55:
   \   00000000   F041BDE8           POP      {R4-R8,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    136          

   \                                 In segment CODE, align 4, keep-with-next
    137          void ModbusUnit::SetRegister(int Index, U16 NewVal, bool LittleEndian) {
    138              if ( LittleEndian ) {
   \                     ??SetRegister:
   \   00000000   811080E0           ADD      R1,R0,R1, LSL #+1
   \   00000004   73CFA0E3           MOV      R12,#+460
   \   00000008   000053E3           CMP      R3,#+0
    139                  AnalogOut[Index] = NewVal;
    140              } else {
    141                  AnalogOut[Index] = (NewVal >> 8) | ((NewVal & 0xff) << 8);
   \   0000000C   0234A001           LSLEQ    R3,R2,#+8
   \   00000010   22248301           ORREQ    R2,R3,R2, LSR #+8
   \   00000014   B1208CE1           STRH     R2,[R12, +R1]
    142              }
    143              hasNewRegOutput = true;
   \   00000018   741BA0E3           MOV      R1,#+118784
   \   0000001C   9C1F81E3           ORR      R1,R1,#0x270
   \   00000020   0120A0E3           MOV      R2,#+1
   \   00000024   0020C1E7           STRB     R2,[R1, +R0]
    144          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    145          
    146          

   \                                 In segment CODE, align 4, keep-with-next
    147          void ModbusUnit::SetRegisterString(int Index, AnsiString MyString, int Size) {
   \                     ??SetRegisterString:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    148              char *RegAddress = (char *)&AnalogOut[Index];
   \   00000008   810084E0           ADD      R0,R4,R1, LSL #+1
   \   0000000C   736F80E2           ADD      R6,R0,#+460
    149              strncpy(RegAddress, MyString.c_str(), Size);
   \   00000010   180092E5           LDR      R0,[R2, #+24]
   \   00000014   0350A0E1           MOV      R5,R3
   \   00000018   100050E3           CMP      R0,#+16
   \   0000001C   04109225           LDRCS    R1,[R2, #+4]
   \   00000020   0600A0E1           MOV      R0,R6
   \   00000024   04108232           ADDCC    R1,R2,#+4
   \   00000028   0520A0E1           MOV      R2,R5
   \   0000002C   ........           _BLF     strncpy,??strncpy??rA
    150              int StrLen = strlen(RegAddress);
   \   00000030   0600A0E1           MOV      R0,R6
   \   00000034   ........           _BLF     strlen,??strlen??rA
    151              if ( StrLen < Size ) {
   \   00000038   050050E1           CMP      R0,R5
   \   0000003C   030000AA           BGE      ??SetRegisterString_1
    152                  memset(&RegAddress[StrLen], 0, Size - StrLen);
   \   00000040   002045E0           SUB      R2,R5,R0
   \   00000044   0010A0E3           MOV      R1,#+0
   \   00000048   060080E0           ADD      R0,R0,R6
   \   0000004C   ........           _BLF     memset,??memset??rA
    153              }
    154              hasNewRegOutput = true;
   \                     ??SetRegisterString_1:
   \   00000050   740BA0E3           MOV      R0,#+118784
   \   00000054   9C0F80E3           ORR      R0,R0,#0x270
   \   00000058   0110A0E3           MOV      R1,#+1
   \   0000005C   0410C0E7           STRB     R1,[R0, +R4]
    155          }
   \   00000060   ........           B        ??Subroutine49_0
    156          

   \                                 In segment CODE, align 4, keep-with-next
    157          void ModbusUnit::SetHoldingRegister(int Index, U16 NewVal, bool LittleEndian) {
    158              if ( LittleEndian ) {
   \                     ??SetHoldingRegister:
   \   00000000   CCC0A0E3           MOV      R12,#+204
   \   00000004   81CC8CE3           ORR      R12,R12,#0x8100
   \   00000008   810080E0           ADD      R0,R0,R1, LSL #+1
   \   0000000C   00008CE0           ADD      R0,R12,R0
   \   00000010   000053E3           CMP      R3,#+0
    159                  AnalogIn[Index] = NewVal;
   \   00000014   B020C011           STRHNE   R2,[R0, #+0]
   \   00000018   1EFF2F11           BXNE     LR
    160              } else {
    161                  AnalogIn[Index] = (NewVal >> 8) | ((NewVal & 0xff) << 8);
   \   0000001C   0214A0E1           LSL      R1,R2,#+8
   \   00000020   221481E1           ORR      R1,R1,R2, LSR #+8
   \   00000024   B010C0E1           STRH     R1,[R0, #+0]
    162              }
    163          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    164          

   \                                 In segment CODE, align 4, keep-with-next
    165          void ModbusUnit::MoveRegisters(int Index, int Entries, int Size) {
   \                     ??MoveRegisters:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   01C0A0E1           MOV      R12,R1
    166              memmove(&AnalogOut[Index], &AnalogOut[Index + Size], 2 * (Entries - Size));
   \   00000008   734FA0E3           MOV      R4,#+460
   \   0000000C   031042E0           SUB      R1,R2,R3
   \   00000010   8120A0E1           LSL      R2,R1,#+1
   \   00000014   0C1083E0           ADD      R1,R3,R12
   \   00000018   811080E0           ADD      R1,R0,R1, LSL #+1
   \   0000001C   011084E0           ADD      R1,R4,R1
   \   00000020   8C0080E0           ADD      R0,R0,R12, LSL #+1
   \   00000024   000084E0           ADD      R0,R4,R0
   \   00000028   ........           _BLF     memmove,??memmove??rA
    167          }
   \   0000002C   ........           B        ?Subroutine56

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine56:
   \   00000000   1040BDE8           POP      {R4,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    168          
    169          

   \                                 In segment CODE, align 4, keep-with-next
    170          bool ModbusUnit::HasNewValue(int Index) {
   \                     ??HasNewValue:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0020A0E1           MOV      R2,R0
    171              bool IsNewValue = false;
    172              // Should possibly remove IsMaster later
    173              if ( IsMaster ) {
   \   00000008   400BA0E3           MOV      R0,#+65536
   \   0000000C   8B0F80E3           ORR      R0,R0,#0x22C
   \   00000010   021081E0           ADD      R1,R1,R2
   \   00000014   014080E0           ADD      R4,R0,R1
   \   00000018   9001D2E5           LDRB     R0,[R2, #+400]
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0800000A           BEQ      ??HasNewValue_1
    174                  if ( IsAvailableNewData() ) {
   \   00000024   A41092E5           LDR      R1,[R2, #+164]
   \   00000028   0200A0E1           MOV      R0,R2
   \   0000002C   581091E5           LDR      R1,[R1, #+88]
   \   00000030   0FE0A0E1           MOV      LR,PC
   \   00000034   11FF2FE1           BX       R1
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0400000A           BEQ      ??HasNewValue_2
    175                      IsNewValue =  NewAnalogIn[Index]; 
   \   00000040   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000044   020000EA           B        ??HasNewValue_2
    176                  } else {
    177                      IsNewValue = false; //!HWFailure;
    178                  }
    179              } else {
    180                  IsNewValue         =  NewAnalogIn[Index]; // Should possibly remove IsMaster later
   \                     ??HasNewValue_1:
   \   00000048   0000D4E5           LDRB     R0,[R4, #+0]
    181                  NewAnalogIn[Index] = false;
   \   0000004C   0010A0E3           MOV      R1,#+0
   \   00000050   0010C4E5           STRB     R1,[R4, #+0]
    182              }
    183              return IsNewValue;
   \                     ??HasNewValue_2:
   \   00000054                      REQUIRE ?Subroutine56
   \   00000054                      ;; // Fall through to label ?Subroutine56
    184          }
    185          

   \                                 In segment CODE, align 4, keep-with-next
    186          bool ModbusUnit::FlagNewValues(int FirstReg, int NumberOfRegs) {
   \                     ??FlagNewValues:
   \   00000000   30002DE9           PUSH     {R4,R5}
    187              if ( FirstReg < MODBUS_MAX_REGISTERS && NumberOfRegs <= MAX_REGISTERS_RTU_WRITE ) {
   \   00000004   400C51E3           CMP      R1,#+16384
   \   00000008   7C0052B3           CMPLT    R2,#+124
   \   0000000C   0C0000AA           BGE      ??FlagNewValues_1
    188                  for ( int i = FirstReg; i < FirstReg + NumberOfRegs; i++ ) {
   \   00000010   0130A0E1           MOV      R3,R1
   \   00000014   0150A0E3           MOV      R5,#+1
   \   00000018   40CBA0E3           MOV      R12,#+65536
   \   0000001C   8BCF8CE3           ORR      R12,R12,#0x22C
   \   00000020   020000EA           B        ??FlagNewValues_2
    189                      NewAnalogIn[i] = true;
   \                     ??FlagNewValues_3:
   \   00000024   004083E0           ADD      R4,R3,R0
   \   00000028   0450CCE7           STRB     R5,[R12, +R4]
    190                  }
   \   0000002C   013083E2           ADD      R3,R3,#+1
   \                     ??FlagNewValues_2:
   \   00000030   014082E0           ADD      R4,R2,R1
   \   00000034   040053E1           CMP      R3,R4
   \   00000038   F9FFFFBA           BLT      ??FlagNewValues_3
    191                  return true;
   \   0000003C   0100A0E3           MOV      R0,#+1
   \   00000040   000000EA           B        ??FlagNewValues_4
    192              }
    193              return false;
   \                     ??FlagNewValues_1:
   \   00000044   0000A0E3           MOV      R0,#+0
   \                     ??FlagNewValues_4:
   \   00000048   3000BDE8           POP      {R4,R5}
   \   0000004C   1EFF2FE1           BX       LR               ;; return
    194          }
    195          

   \                                 In segment CODE, align 4, keep-with-next
    196          void ModbusUnit::HasReadValue(int Index) {
    197              NewAnalogIn[Index] = false;
   \                     ??HasReadValue:
   \   00000000   402BA0E3           MOV      R2,#+65536
   \   00000004   8B2F82E3           ORR      R2,R2,#0x22C
   \   00000008   000081E0           ADD      R0,R1,R0
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   0010C2E7           STRB     R1,[R2, +R0]
    198          }
   \   00000014   1EFF2FE1           BX       LR               ;; return
    199          

   \                                 In segment CODE, align 4, keep-with-next
    200          bool ModbusUnit::HasNewDigitalValue(int Index) {
   \                     ??HasNewDigitalValue:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   740BA0E3           MOV      R0,#+118784
   \   00000010   9D0F80E3           ORR      R0,R0,#0x274
   \   00000014   046080E0           ADD      R6,R0,R4
   \   00000018   0600A0E1           MOV      R0,R6
    201              AccessDigitalSema.Acquire();
   \   0000001C   ........           _BLF     ??Acquire,??Acquire??rA
    202              bool IsNewValue =  NewDigitalIn[Index]; // Should possibly remove IsMaster later
   \   00000020   500BA0E3           MOV      R0,#+81920
   \   00000024   8B0F80E3           ORR      R0,R0,#0x22C
   \   00000028   041085E0           ADD      R1,R5,R4
   \   0000002C   010080E0           ADD      R0,R0,R1
   \   00000030   0040D0E5           LDRB     R4,[R0, #+0]
    203              NewDigitalIn[Index] = false;
   \   00000034   0010A0E3           MOV      R1,#+0
   \   00000038   0010C0E5           STRB     R1,[R0, #+0]
    204              AccessDigitalSema.Release();
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   ........           _BLF     ??Release,??Release??rA
    205              return IsNewValue;
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           B        ??Subroutine49_0
    206          }
    207          

   \                                 In segment CODE, align 4, keep-with-next
    208          bool ModbusUnit::FlagNewDigitalValues(int FirstReg, int NumberOfRegs) {
   \                     ??FlagNewDigitalValues:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    209              if ( FirstReg < MODBUS_MAX_REGISTERS && NumberOfRegs <= MAX_COILS_RTU_WRITE ) {
   \   00000010   400C55E3           CMP      R5,#+16384
   \   00000014   B100A0B3           MOVLT    R0,#+177
   \   00000018   700E80B3           ORRLT    R0,R0,#0x700
   \   0000001C   000056B1           CMPLT    R6,R0
   \   00000020   130000AA           BGE      ??FlagNewDigitalValues_1
   \   00000024   740BA0E3           MOV      R0,#+118784
   \   00000028   9D0F80E3           ORR      R0,R0,#0x274
   \   0000002C   047080E0           ADD      R7,R0,R4
   \   00000030   0700A0E1           MOV      R0,R7
    210                  AccessDigitalSema.Acquire();
   \   00000034   ........           _BLF     ??Acquire,??Acquire??rA
    211                  for ( int i = FirstReg; i < FirstReg + NumberOfRegs; i++ ) {
   \   00000038   0500A0E1           MOV      R0,R5
   \   0000003C   0130A0E3           MOV      R3,#+1
   \   00000040   040000EA           B        ??FlagNewDigitalValues_2
    212                      NewDigitalIn[i] = true;
   \                     ??FlagNewDigitalValues_3:
   \   00000044   501BA0E3           MOV      R1,#+81920
   \   00000048   8B1F81E3           ORR      R1,R1,#0x22C
   \   0000004C   042080E0           ADD      R2,R0,R4
   \   00000050   0230C1E7           STRB     R3,[R1, +R2]
    213                  }
   \   00000054   010080E2           ADD      R0,R0,#+1
   \                     ??FlagNewDigitalValues_2:
   \   00000058   051086E0           ADD      R1,R6,R5
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   F7FFFFBA           BLT      ??FlagNewDigitalValues_3
    214                  AccessDigitalSema.Release();
   \   00000064   0700A0E1           MOV      R0,R7
   \   00000068   ........           _BLF     ??Release,??Release??rA
    215                  return true;
   \   0000006C   0100A0E3           MOV      R0,#+1
   \   00000070   000000EA           B        ??FlagNewDigitalValues_4
    216              }
    217              return false;
   \                     ??FlagNewDigitalValues_1:
   \   00000074   0000A0E3           MOV      R0,#+0
   \                     ??FlagNewDigitalValues_4:
   \   00000078                      REQUIRE ?Subroutine54
   \   00000078                      ;; // Fall through to label ?Subroutine54
    218          }
    219          

   \                                 In segment CODE, align 4, keep-with-next
    220          void ModbusUnit::HasReadDigitalValue(int Index) {
   \                     ??HasReadDigitalValue:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   740BA0E3           MOV      R0,#+118784
   \   00000010   9D0F80E3           ORR      R0,R0,#0x274
   \   00000014   046080E0           ADD      R6,R0,R4
   \   00000018   0600A0E1           MOV      R0,R6
    221              AccessDigitalSema.Acquire();
   \   0000001C   ........           _BLF     ??Acquire,??Acquire??rA
    222              NewDigitalIn[Index] = false;
   \   00000020   500BA0E3           MOV      R0,#+81920
   \   00000024   8B0F80E3           ORR      R0,R0,#0x22C
   \   00000028   041085E0           ADD      R1,R5,R4
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   0120C0E7           STRB     R2,[R0, +R1]
    223              AccessDigitalSema.Release();
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   ........           _BLF     ??Release,??Release??rA
    224          }
   \   0000003C   ........           B        ??Subroutine49_0
    225          

   \                                 In segment CODE, align 4, keep-with-next
    226          bool ModbusUnit::SlaveGetRegisters(U16 *Registers, int Index, int NumberOfRegisters, U8 *DataPtr) {
   \                     ??SlaveGetRegisters:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   04009DE5           LDR      R0,[SP, #+4]
   \   00000008   02C0A0E1           MOV      R12,R2
    227              bool NoError = false;
   \   0000000C   0020A0E3           MOV      R2,#+0
    228              if ( Index < MODBUS_MAX_REGISTERS && NumberOfRegisters <= MAX_REGISTERS_RTU_READ ) {
   \   00000010   400C5CE3           CMP      R12,#+16384
   \   00000014   7E0053B3           CMPLT    R3,#+126
   \   00000018   030000AA           BGE      ??SlaveGetRegisters_1
    229                  memcpy(DataPtr, &Registers[Index], NumberOfRegisters * 2);
   \   0000001C   8320A0E1           LSL      R2,R3,#+1
   \   00000020   8C1081E0           ADD      R1,R1,R12, LSL #+1
   \   00000024   ........           _BLF     memcpy,??memcpy??rA
    230                  NoError = true;
   \   00000028   0120A0E3           MOV      R2,#+1
    231              }
    232              return NoError;
   \                     ??SlaveGetRegisters_1:
   \   0000002C   0040BDE8           POP      {LR}
   \   00000030   0200A0E1           MOV      R0,R2
   \   00000034   1EFF2FE1           BX       LR               ;; return
    233          }
    234          

   \                                 In segment CODE, align 4, keep-with-next
    235          bool ModbusUnit::GetCoilIn(int Index) {
   \                     ??GetCoilIn:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    236              Index -= StartDigitalIn;
   \   00000008   740BA0E3           MOV      R0,#+118784
   \   0000000C   920F80E3           ORR      R0,R0,#0x248
   \   00000010   050090E7           LDR      R0,[R0, +R5]
   \   00000014   006041E0           SUB      R6,R1,R0
   \   00000018   740BA0E3           MOV      R0,#+118784
   \   0000001C   9D0F80E3           ORR      R0,R0,#0x274
   \   00000020   054080E0           ADD      R4,R0,R5
   \   00000024   0400A0E1           MOV      R0,R4
    237              AccessDigitalSema.Acquire();
   \   00000028   ........           _BLF     ??Acquire,??Acquire??rA
    238              bool State = MB_GetBit(DigitalIn, Index);
   \   0000002C   720BA0E3           MOV      R0,#+116736
   \   00000030   ........           B        ?Subroutine49
    239              AccessDigitalSema.Release();
    240              return State;
    241          }

   \                                 In segment CODE, align 4, keep-with-next
    242          bool ModbusUnit::GetCoilOut(int Index) {
   \                     ??GetCoilOut:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0050A0E1           MOV      R5,R0
    243              Index -= StartDigitalOut;
   \   00000008   740BA0E3           MOV      R0,#+118784
   \   0000000C   910F80E3           ORR      R0,R0,#0x244
   \   00000010   050090E7           LDR      R0,[R0, +R5]
   \   00000014   006041E0           SUB      R6,R1,R0
   \   00000018   740BA0E3           MOV      R0,#+118784
   \   0000001C   9D0F80E3           ORR      R0,R0,#0x274
   \   00000020   054080E0           ADD      R4,R0,R5
   \   00000024   0400A0E1           MOV      R0,R4
    244              AccessDigitalSema.Acquire();
   \   00000028   ........           _BLF     ??Acquire,??Acquire??rA
    245              bool State = MB_GetBit(DigitalOut, Index);
   \   0000002C   700BA0E3           MOV      R0,#+114688
   \   00000030                      REQUIRE ?Subroutine49
   \   00000030                      ;; // Fall through to label ?Subroutine49
    246              AccessDigitalSema.Release();
    247              return State;
    248          }
    249          

   \                                 In segment CODE, align 4, keep-with-next
    250          bool ModbusUnit::GetCoils(U8 *Coils, int FirstCoil, int NumberOfCoils, U8 *DataPtr) {
   \                     ??GetCoils:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   20609DE5           LDR      R6,[SP, #+32]
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    251              bool NoError = true;
   \   00000010   0180A0E3           MOV      R8,#+1
    252              int StartOffset = 0;
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   741BA0E3           MOV      R1,#+118784
   \   0000001C   911F81E3           ORR      R1,R1,#0x244
   \   00000020   041081E0           ADD      R1,R1,R4
   \   00000024   709BA0E3           MOV      R9,#+114688
   \   00000028   8B9F89E3           ORR      R9,R9,#0x22C
   \   0000002C   049089E0           ADD      R9,R9,R4
   \   00000030   090055E1           CMP      R5,R9
    253              if ( Coils == DigitalOut ) {
    254                  StartOffset = StartDigitalOut;
   \   00000034   00009105           LDREQ    R0,[R1, #+0]
   \   00000038   0400000A           BEQ      ??GetCoils_1
    255              } else if ( Coils == DigitalIn ) {
   \   0000003C   729BA0E3           MOV      R9,#+116736
   \   00000040   8B9F89E3           ORR      R9,R9,#0x22C
   \   00000044   049089E0           ADD      R9,R9,R4
   \   00000048   090055E1           CMP      R5,R9
    256                  StartOffset  = StartDigitalIn;
   \   0000004C   04009105           LDREQ    R0,[R1, #+4]
    257              }
    258              FirstCoil        -= StartOffset;
    259              int LastCoil      = FirstCoil + NumberOfCoils - 1;
    260              int NumberOfBytes = NumberOfCoils >> 3;
    261              if ( NumberOfCoils & 7 ) {
   \                     ??GetCoils_1:
   \   00000050   070013E3           TST      R3,#0x7
   \   00000054   00A042E0           SUB      R10,R2,R0
   \   00000058   0A0083E0           ADD      R0,R3,R10
   \   0000005C   019040E2           SUB      R9,R0,#+1
   \   00000060   C321A0E1           ASR      R2,R3,#+3
    262                  NumberOfBytes++;
   \   00000064   01208212           ADDNE    R2,R2,#+1
    263              }
    264              if ( FirstCoil >= 0 && (LastCoil < MODBUS_MAX_COILS) && NumberOfCoils <= MAX_COILS_RTU_READ ) {
   \   00000068   00005AE3           CMP      R10,#+0
   \   0000006C   1C00004A           BMI      ??GetCoils_2
   \   00000070   400C59E3           CMP      R9,#+16384
   \   00000074   7D0E88B3           ORRLT    R0,R8,#0x7D0
   \   00000078   000053B1           CMPLT    R3,R0
   \   0000007C   180000AA           BGE      ??GetCoils_2
    265                  memset(DataPtr, 0, NumberOfBytes);
   \   00000080   0010A0E3           MOV      R1,#+0
   \   00000084   0600A0E1           MOV      R0,R6
   \   00000088   ........           _BLF     memset,??memset??rA
   \   0000008C   740BA0E3           MOV      R0,#+118784
   \   00000090   9D0F80E3           ORR      R0,R0,#0x274
   \   00000094   044080E0           ADD      R4,R0,R4
   \   00000098   0400A0E1           MOV      R0,R4
    266                  AccessDigitalSema.Acquire();
   \   0000009C   ........           _BLF     ??Acquire,??Acquire??rA
    267                  for ( int Cnt = 0, i = FirstCoil; i <= LastCoil; i++ ) {
   \   000000A0   0000A0E3           MOV      R0,#+0
   \   000000A4   090000EA           B        ??GetCoils_3
    268                      if ( MB_GetBit(Coils, i) ) {
   \                     ??GetCoils_4:
   \   000000A8   CA11D5E7           LDRB     R1,[R5, +R10, ASR #+3]
   \   000000AC   07200AE2           AND      R2,R10,#0x7
    269                          MB_SetBit(DataPtr, Cnt);
    270                      }
    271                      Cnt++;
    272                  }
   \   000000B0   01A08AE2           ADD      R10,R10,#+1
   \   000000B4   310218E1           TST      R8,R1, LSR R2
   \   000000B8   C0118610           ADDNE    R1,R6,R0, ASR #+3
   \   000000BC   0020D115           LDRBNE   R2,[R1, #+0]
   \   000000C0   07C00012           ANDNE    R12,R0,#0x7
   \   000000C4   010080E2           ADD      R0,R0,#+1
   \   000000C8   182C8211           ORRNE    R2,R2,R8, LSL R12
   \   000000CC   0020C115           STRBNE   R2,[R1, #+0]
   \                     ??GetCoils_3:
   \   000000D0   0A0059E1           CMP      R9,R10
   \   000000D4   F3FFFFAA           BGE      ??GetCoils_4
    273                  AccessDigitalSema.Release();
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           _BLF     ??Release,??Release??rA
   \   000000E0   000000EA           B        ??GetCoils_5
    274              } else {
    275                  NoError = false;
   \                     ??GetCoils_2:
   \   000000E4   0080A0E3           MOV      R8,#+0
    276              }
    277              return NoError;
   \                     ??GetCoils_5:
   \   000000E8   0800A0E1           MOV      R0,R8
   \   000000EC                      REQUIRE ?Subroutine53
   \   000000EC                      ;; // Fall through to label ?Subroutine53
    278          }
    279          

   \                                 In segment CODE, align 4, keep-with-next
    280          bool ModbusUnit::SetCoils(int FirstCoil, int NumberOfCoils, U8 *DataPtr) {
   \                     ??SetCoils:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    281              FirstCoil   -= StartDigitalIn;
   \   00000008   740BA0E3           MOV      R0,#+118784
   \   0000000C   920F80E3           ORR      R0,R0,#0x248
   \   00000010   040090E7           LDR      R0,[R0, +R4]
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   0360A0E1           MOV      R6,R3
   \   0000001C   00A041E0           SUB      R10,R1,R0
    282              bool NoError = true;
   \   00000020   0180A0E3           MOV      R8,#+1
    283              int NumberOfBytes = NumberOfCoils >> 3;
    284              int LastCoil      = FirstCoil + NumberOfCoils - 1;
   \   00000024   0A0085E0           ADD      R0,R5,R10
   \   00000028   010040E2           SUB      R0,R0,#+1
    285              if ( NumberOfCoils & 7 ) {
    286                  NumberOfBytes++;
    287              }
    288          
    289              if ( FirstCoil >= 0 && (LastCoil >= 0) && (LastCoil < MODBUS_MAX_COILS) && NumberOfCoils <= MAX_COILS_RTU_WRITE ) {
   \   0000002C   00005AE3           CMP      R10,#+0
   \   00000030   00005053           CMPPL    R0,#+0
   \   00000034   2500004A           BMI      ??SetCoils_1
   \   00000038   400C50E3           CMP      R0,#+16384
   \   0000003C   7B0E88B3           ORRLT    R0,R8,#0x7B0
   \   00000040   000055B1           CMPLT    R5,R0
   \   00000044   210000AA           BGE      ??SetCoils_1
   \   00000048   740BA0E3           MOV      R0,#+118784
   \   0000004C   9D0F80E3           ORR      R0,R0,#0x274
   \   00000050   049080E0           ADD      R9,R0,R4
   \   00000054   0900A0E1           MOV      R0,R9
    290                  AccessDigitalSema.Acquire();
   \   00000058   ........           _BLF     ??Acquire,??Acquire??rA
    291                  for ( int Cnt = FirstCoil, i = 0; i < NumberOfCoils; i++, Cnt++ ) {
   \   0000005C   0A10A0E1           MOV      R1,R10
   \   00000060   0000A0E3           MOV      R0,#+0
   \   00000064   020000EA           B        ??SetCoils_2
    292                      if ( MB_GetBit(DataPtr, i) ) {
    293                          MB_SetBit(DigitalIn, Cnt);
   \                     ??SetCoils_3:
   \   00000068   0020C3E5           STRB     R2,[R3, #+0]
   \   0000006C   010080E2           ADD      R0,R0,#+1
   \   00000070   011081E2           ADD      R1,R1,#+1
   \                     ??SetCoils_2:
   \   00000074   050050E1           CMP      R0,R5
   \   00000078   0D0000AA           BGE      ??SetCoils_4
   \   0000007C   C0E1D6E7           LDRB     LR,[R6, +R0, ASR #+3]
   \   00000080   0120A0E3           MOV      R2,#+1
   \   00000084   073001E2           AND      R3,R1,#0x7
   \   00000088   1223A0E1           LSL      R2,R2,R3
   \   0000008C   723BA0E3           MOV      R3,#+116736
   \   00000090   8B3F83E3           ORR      R3,R3,#0x22C
   \   00000094   C1B184E0           ADD      R11,R4,R1, ASR #+3
   \   00000098   0B3083E0           ADD      R3,R3,R11
   \   0000009C   00B0D3E5           LDRB     R11,[R3, #+0]
   \   000000A0   07C000E2           AND      R12,R0,#0x7
   \   000000A4   3E0C18E1           TST      R8,LR, LSR R12
   \   000000A8   0220CB01           BICEQ    R2,R11,R2
   \   000000AC   0B208211           ORRNE    R2,R2,R11
   \   000000B0   ECFFFFEA           B        ??SetCoils_3
    294                      } else {
    295                          MB_ResetBit(DigitalIn, Cnt);
    296                      }
    297                  }
    298                  FlagNewDigitalValues(FirstCoil, NumberOfCoils);
   \                     ??SetCoils_4:
   \   000000B4   0520A0E1           MOV      R2,R5
   \   000000B8   0A10A0E1           MOV      R1,R10
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   ........           BL       ??FlagNewDigitalValues
    299                  AccessDigitalSema.Release();
   \   000000C4   0900A0E1           MOV      R0,R9
   \   000000C8   ........           _BLF     ??Release,??Release??rA
   \   000000CC   000000EA           B        ??SetCoils_5
    300              } else {
    301                  NoError = false;
   \                     ??SetCoils_1:
   \   000000D0   0080A0E3           MOV      R8,#+0
    302              }
    303          
    304              return NoError;
   \                     ??SetCoils_5:
   \   000000D4   0800A0E1           MOV      R0,R8
   \   000000D8   ........           B        ?Subroutine57
    305          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine57:
   \   00000000   F04FBDE8           POP      {R4-R11,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    306          

   \                                 In segment CODE, align 4, keep-with-next
    307          bool ModbusUnit::SetInCoil(int Index, U16 State) {
   \                     ??SetInCoil:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    308              bool NoError = true;
   \   0000000C   740BA0E3           MOV      R0,#+118784
   \   00000010   920F80E3           ORR      R0,R0,#0x248
   \   00000014   040080E0           ADD      R0,R0,R4
   \   00000018   001090E5           LDR      R1,[R0, #+0]
   \   0000001C   0280A0E1           MOV      R8,R2
   \   00000020   0160A0E3           MOV      R6,#+1
   \   00000024   0170A0E3           MOV      R7,#+1
   \   00000028   010055E1           CMP      R5,R1
   \   0000002C   190000BA           BLT      ??SetInCoil_1
   \   00000030   400C55E3           CMP      R5,#+16384
   \   00000034   170000AA           BGE      ??SetInCoil_1
    309              if ( Index >= StartDigitalIn && Index < MODBUS_MAX_COILS ) {
    310                  Index -= StartDigitalIn;
   \   00000038   015045E0           SUB      R5,R5,R1
   \   0000003C   740BA0E3           MOV      R0,#+118784
   \   00000040   9D0F80E3           ORR      R0,R0,#0x274
   \   00000044   049080E0           ADD      R9,R0,R4
   \   00000048   0900A0E1           MOV      R0,R9
    311                  AccessDigitalSema.Acquire();
   \   0000004C   ........           _BLF     ??Acquire,??Acquire??rA
    312                  if ( State == 0xFF00 ) {
   \   00000050   720BA0E3           MOV      R0,#+116736
   \   00000054   8B0F80E3           ORR      R0,R0,#0x22C
   \   00000058   C51184E0           ADD      R1,R4,R5, ASR #+3
   \   0000005C   010080E0           ADD      R0,R0,R1
   \   00000060   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000064   FF0C58E3           CMP      R8,#+65280
   \   00000068   072005E2           AND      R2,R5,#0x7
    313                      MB_SetBit(DigitalIn, Index);
   \   0000006C   16128101           ORREQ    R1,R1,R6, LSL R2
    314                  } else {
    315                      MB_ResetBit(DigitalIn, Index);
   \   00000070   1622E011           MVNNE    R2,R6, LSL R2
   \   00000074   01100210           ANDNE    R1,R2,R1
   \   00000078   0010C0E5           STRB     R1,[R0, #+0]
    316                  }
    317                  FlagNewDigitalValues(Index, 1);
   \   0000007C   0120A0E3           MOV      R2,#+1
   \   00000080   0510A0E1           MOV      R1,R5
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       ??FlagNewDigitalValues
    318                  AccessDigitalSema.Release();
   \   0000008C   0900A0E1           MOV      R0,R9
   \   00000090   ........           _BLF     ??Release,??Release??rA
   \   00000094   000000EA           B        ??SetInCoil_2
    319              } else {
    320                  NoError = false;
   \                     ??SetInCoil_1:
   \   00000098   0070A0E3           MOV      R7,#+0
    321              }
    322              return NoError;
   \                     ??SetInCoil_2:
   \   0000009C   ........           B        ?Subroutine51
    323          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine51:
   \   00000000   0700A0E1           MOV      R0,R7
   \                     ??Subroutine51_0:
   \   00000004   F043BDE8           POP      {R4-R9,LR}
   \   00000008   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
    324          bool ModbusUnit::InitInCoil(int Index, U16 State) {
   \                     ??InitInCoil:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    325              bool NoError = true;
   \   0000000C   740BA0E3           MOV      R0,#+118784
   \   00000010   920F80E3           ORR      R0,R0,#0x248
   \   00000014   040080E0           ADD      R0,R0,R4
   \   00000018   001090E5           LDR      R1,[R0, #+0]
   \   0000001C   0280A0E1           MOV      R8,R2
   \   00000020   0160A0E3           MOV      R6,#+1
   \   00000024   0170A0E3           MOV      R7,#+1
   \   00000028   010055E1           CMP      R5,R1
   \   0000002C   190000BA           BLT      ??InitInCoil_1
   \   00000030   400C55E3           CMP      R5,#+16384
   \   00000034   170000AA           BGE      ??InitInCoil_1
    326              if ( Index >= StartDigitalIn && Index < MODBUS_MAX_COILS ) {
    327                  Index -= StartDigitalIn;
   \   00000038   015045E0           SUB      R5,R5,R1
   \   0000003C   740BA0E3           MOV      R0,#+118784
   \   00000040   9D0F80E3           ORR      R0,R0,#0x274
   \   00000044   049080E0           ADD      R9,R0,R4
   \   00000048   0900A0E1           MOV      R0,R9
    328                  AccessDigitalSema.Acquire();
   \   0000004C   ........           _BLF     ??Acquire,??Acquire??rA
    329                  if ( State ) {
   \   00000050   720BA0E3           MOV      R0,#+116736
   \   00000054   8B0F80E3           ORR      R0,R0,#0x22C
   \   00000058   C51184E0           ADD      R1,R4,R5, ASR #+3
   \   0000005C   010080E0           ADD      R0,R0,R1
   \   00000060   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000064   000058E3           CMP      R8,#+0
   \   00000068   072005E2           AND      R2,R5,#0x7
    330                      MB_SetBit(DigitalIn, Index);
   \   0000006C   16128111           ORRNE    R1,R1,R6, LSL R2
    331                  } else {
    332                      MB_ResetBit(DigitalIn, Index);
   \   00000070   1622E001           MVNEQ    R2,R6, LSL R2
   \   00000074   01100200           ANDEQ    R1,R2,R1
   \   00000078   0010C0E5           STRB     R1,[R0, #+0]
    333                  }
    334                  FlagNewDigitalValues(Index, 1);
   \   0000007C   0120A0E3           MOV      R2,#+1
   \   00000080   0510A0E1           MOV      R1,R5
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       ??FlagNewDigitalValues
    335                  AccessDigitalSema.Release();
   \   0000008C   0900A0E1           MOV      R0,R9
   \   00000090   ........           _BLF     ??Release,??Release??rA
   \   00000094   000000EA           B        ??InitInCoil_2
    336              } else {
    337                  NoError = false;
   \                     ??InitInCoil_1:
   \   00000098   0070A0E3           MOV      R7,#+0
    338              }
    339              return NoError;
   \                     ??InitInCoil_2:
   \   0000009C                      REQUIRE ?Subroutine51
   \   0000009C                      ;; // Fall through to label ?Subroutine51
    340          }
    341          

   \                                 In segment CODE, align 4, keep-with-next
    342          bool ModbusUnit::SetCoil(int Index, bool State) {
   \                     ??SetCoil:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0070A0E1           MOV      R7,R0
    343              bool NoError = true;
   \   00000008   740BA0E3           MOV      R0,#+118784
   \   0000000C   910F80E3           ORR      R0,R0,#0x244
   \   00000010   079080E0           ADD      R9,R0,R7
   \   00000014   000099E5           LDR      R0,[R9, #+0]
   \   00000018   0280A0E1           MOV      R8,R2
   \   0000001C   0150A0E3           MOV      R5,#+1
   \   00000020   0160A0E3           MOV      R6,#+1
   \   00000024   000051E1           CMP      R1,R0
   \   00000028   150000BA           BLT      ??SetCoil_1
   \   0000002C   400C51E3           CMP      R1,#+16384
   \   00000030   130000AA           BGE      ??SetCoil_1
    344              if ( Index >= StartDigitalOut && Index < MODBUS_MAX_COILS ) {
    345                  Index -= StartDigitalOut;
   \   00000034   004041E0           SUB      R4,R1,R0
   \   00000038   740BA0E3           MOV      R0,#+118784
   \   0000003C   9D0F80E3           ORR      R0,R0,#0x274
   \   00000040   07A080E0           ADD      R10,R0,R7
   \   00000044   0A00A0E1           MOV      R0,R10
    346                  AccessDigitalSema.Acquire();
   \   00000048   ........           _BLF     ??Acquire,??Acquire??rA
    347                  if ( State ) {
   \   0000004C   700BA0E3           MOV      R0,#+114688
   \   00000050   8B0F80E3           ORR      R0,R0,#0x22C
   \   00000054   C41187E0           ADD      R1,R7,R4, ASR #+3
   \   00000058   010080E0           ADD      R0,R0,R1
   \   0000005C   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000060   000058E3           CMP      R8,#+0
   \   00000064   072004E2           AND      R2,R4,#0x7
    348                      MB_SetBit(DigitalOut, Index);
   \   00000068   15128111           ORRNE    R1,R1,R5, LSL R2
    349                  } else {
    350                      MB_ResetBit(DigitalOut, Index);
   \   0000006C   1522E001           MVNEQ    R2,R5, LSL R2
   \   00000070   01100200           ANDEQ    R1,R2,R1
   \   00000074   0010C0E5           STRB     R1,[R0, #+0]
    351                  }
    352                  AccessDigitalSema.Release();
   \   00000078   0A00A0E1           MOV      R0,R10
   \   0000007C   ........           _BLF     ??Release,??Release??rA
   \   00000080   000000EA           B        ??SetCoil_2
    353              } else {
    354                  NoError = false;
   \                     ??SetCoil_1:
   \   00000084   0060A0E3           MOV      R6,#+0
    355              }
    356              hasNewCoilOutput = true;
   \                     ??SetCoil_2:
   \   00000088   2D50C9E5           STRB     R5,[R9, #+45]
    357              return NoError;
   \   0000008C   0600A0E1           MOV      R0,R6
   \   00000090   ........           B        ?Subroutine53
    358          
    359          }
    360          
    361          

   \                                 In segment CODE, align 4, keep-with-next
    362          bool ModbusUnit::SetCoilDirect(int Channel, bool State) {
   \                     ??SetCoilDirect:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    363              bool NoError = true;
    364              if ( myPort ) {
   \   00000008   9C0194E5           LDR      R0,[R4, #+412]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1E00000A           BEQ      ??SetCoilDirect_1
    365                  unsigned Value = 0;
   \   00000018   0070A0E3           MOV      R7,#+0
    366                  if ( State ) {
   \   0000001C   000052E3           CMP      R2,#+0
    367                      Value = 0xFF00;
   \   00000020   FF7CA013           MOVNE    R7,#+65280
    368                  }
    369                  int RetryCnt = 0;
   \   00000024   0080A0E3           MOV      R8,#+0
   \   00000028   070000EA           B        ??SetCoilDirect_2
    370                  do {
    371                      NoError = (Set_Single(myPort, MBUS_CMD_WRITE_SINGLE_COIL, Address, Channel, Value, 200, myFrameSpaceTime, myFrameTimeOut) != PORT_FAILURE);
    372                      if ( !NoError ) {
    373                          //Cnt++;
    374                      }
    375                      TSN_Delay(100);
   \                     ??SetCoilDirect_3:
   \   0000002C   6400A0E3           MOV      R0,#+100
   \   00000030   ........           _BLF     OS_Delay,??OS_Delay??rA
    376                  }while ( !NoError && RetryCnt++ < 10 );
   \   00000034   000059E3           CMP      R9,#+0
   \   00000038   1600001A           BNE      ??SetCoilDirect_4
   \   0000003C   0800A0E1           MOV      R0,R8
   \   00000040   018080E2           ADD      R8,R0,#+1
   \   00000044   0A0050E3           CMP      R0,#+10
   \   00000048   120000AA           BGE      ??SetCoilDirect_4
   \                     ??SetCoilDirect_2:
   \   0000004C   B00194E5           LDR      R0,[R4, #+432]
   \   00000050   0530A0E1           MOV      R3,R5
   \   00000054   01002DE9           PUSH     {R0}
   \   00000058   AC0194E5           LDR      R0,[R4, #+428]
   \   0000005C   0510A0E3           MOV      R1,#+5
   \   00000060   01002DE9           PUSH     {R0}
   \   00000064   C800A0E3           MOV      R0,#+200
   \   00000068   01002DE9           PUSH     {R0}
   \   0000006C   0700A0E1           MOV      R0,R7
   \   00000070   01002DE9           PUSH     {R0}
   \   00000074   942194E5           LDR      R2,[R4, #+404]
   \   00000078   9C0194E5           LDR      R0,[R4, #+412]
   \   0000007C   ........           _BLF     ??Set_Single,??Set_Single??rA
   \   00000080   0B0070E3           CMN      R0,#+11
   \   00000084   10D08DE2           ADD      SP,SP,#+16
   \   00000088   0090A003           MOVEQ    R9,#+0
   \   0000008C   0190A013           MOVNE    R9,#+1
   \   00000090   E5FFFFEA           B        ??SetCoilDirect_3
    377              } else {
    378                  NoError = false;
   \                     ??SetCoilDirect_1:
   \   00000094   0090A0E3           MOV      R9,#+0
    379              }
    380              return NoError;
   \                     ??SetCoilDirect_4:
   \   00000098   0900A0E1           MOV      R0,R9
   \   0000009C   ........           B        ??Subroutine51_0
    381          
    382          }
    383          

   \                                 In segment CODE, align 4, keep-with-next
    384          void ModbusUnit::SetCoilHistory(int Index, bool State, int Entries) {
   \                     ??SetCoilHistory:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    385              Index -= StartDigitalOut;
   \   00000008   740BA0E3           MOV      R0,#+118784
   \   0000000C   910F80E3           ORR      R0,R0,#0x244
   \   00000010   040090E7           LDR      R0,[R0, +R4]
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   0380A0E1           MOV      R8,R3
   \   0000001C   006041E0           SUB      R6,R1,R0
   \   00000020   740BA0E3           MOV      R0,#+118784
   \   00000024   9D0F80E3           ORR      R0,R0,#0x274
   \   00000028   047080E0           ADD      R7,R0,R4
   \   0000002C   0700A0E1           MOV      R0,R7
    386              AccessDigitalSema.Acquire();
   \   00000030   ........           _BLF     ??Acquire,??Acquire??rA
    387              for ( int i = Entries - 1; i >= 1; i-- ) {
   \   00000034   010048E2           SUB      R0,R8,#+1
   \   00000038   01B0A0E3           MOV      R11,#+1
   \   0000003C   030000EA           B        ??SetCoilHistory_1
    388                  if ( MB_GetBit(DigitalIn, i - 1 + Index) ) {
    389                      MB_SetBit(DigitalOut, i + Index);
    390                  } else {
    391                      MB_ResetBit(DigitalOut, Index);
   \                     ??SetCoilHistory_2:
   \   00000040   0010DCE5           LDRB     R1,[R12, #+0]
   \   00000044   011002E0           AND      R1,R2,R1
   \   00000048   0010CCE5           STRB     R1,[R12, #+0]
    392                  }
   \                     ??SetCoilHistory_3:
   \   0000004C   010040E2           SUB      R0,R0,#+1
   \                     ??SetCoilHistory_1:
   \   00000050   073006E2           AND      R3,R6,#0x7
   \   00000054   1B83A0E1           LSL      R8,R11,R3
   \   00000058   0820E0E1           MVN      R2,R8
   \   0000005C   703BA0E3           MOV      R3,#+114688
   \   00000060   8B3F83E3           ORR      R3,R3,#0x22C
   \   00000064   C69184E0           ADD      R9,R4,R6, ASR #+3
   \   00000068   09C083E0           ADD      R12,R3,R9
   \   0000006C   010050E3           CMP      R0,#+1
   \   00000070   100000BA           BLT      ??SetCoilHistory_4
   \   00000074   068080E0           ADD      R8,R0,R6
   \   00000078   809E83E3           ORR      R9,R3,#0x800
   \   0000007C   01A048E2           SUB      R10,R8,#+1
   \   00000080   CAA184E0           ADD      R10,R4,R10, ASR #+3
   \   00000084   0AA0D9E7           LDRB     R10,[R9, +R10]
   \   00000088   06E080E0           ADD      LR,R0,R6
   \   0000008C   01904EE2           SUB      R9,LR,#+1
   \   00000090   079009E2           AND      R9,R9,#0x7
   \   00000094   3A091BE1           TST      R11,R10, LSR R9
   \   00000098   E8FFFF0A           BEQ      ??SetCoilHistory_2
   \   0000009C   C82184E0           ADD      R2,R4,R8, ASR #+3
   \   000000A0   022083E0           ADD      R2,R3,R2
   \   000000A4   0030D2E5           LDRB     R3,[R2, #+0]
   \   000000A8   07800EE2           AND      R8,LR,#0x7
   \   000000AC   1B1883E1           ORR      R1,R3,R11, LSL R8
   \   000000B0   0010C2E5           STRB     R1,[R2, #+0]
   \   000000B4   E4FFFFEA           B        ??SetCoilHistory_3
    393              }
    394              if ( State ) {
   \                     ??SetCoilHistory_4:
   \   000000B8   0000DCE5           LDRB     R0,[R12, #+0]
   \   000000BC   000055E3           CMP      R5,#+0
    395                  MB_SetBit(DigitalOut, Index);
   \   000000C0   00008811           ORRNE    R0,R8,R0
    396              } else {
    397                  MB_ResetBit(DigitalOut, Index);
   \   000000C4   00000200           ANDEQ    R0,R2,R0
   \   000000C8   0000CCE5           STRB     R0,[R12, #+0]
    398              }
    399              AccessDigitalSema.Release();
   \   000000CC   0700A0E1           MOV      R0,R7
   \   000000D0   ........           _BLF     ??Release,??Release??rA
    400          }
   \   000000D4                      REQUIRE ?Subroutine57
   \   000000D4                      ;; // Fall through to label ?Subroutine57
    401          
    402          
    403          

   \                                 In segment CODE, align 4, keep-with-next
    404          void ModbusUnit::SetPreviousState(int Channel, bool CurrentState)
    405          {
    406              PreviousDigitalIn[Channel] = CurrentState;
   \                     ??SetPreviousState:
   \   00000000   603BA0E3           MOV      R3,#+98304
   \   00000004   8B3F83E3           ORR      R3,R3,#0x22C
   \   00000008   000081E0           ADD      R0,R1,R0
   \   0000000C   0020C3E7           STRB     R2,[R3, +R0]
    407          }
   \   00000010   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
    408          bool ModbusUnit::IsNewDigitalInput(int Channel, bool CurrentState)
    409          {
    410              if (PreviousDigitalIn[Channel] == CurrentState) {
   \                     ??IsNewDigitalInput:
   \   00000000   603BA0E3           MOV      R3,#+98304
   \   00000004   8B3F83E3           ORR      R3,R3,#0x22C
   \   00000008   000081E0           ADD      R0,R1,R0
   \   0000000C   0000D3E7           LDRB     R0,[R3, +R0]
   \   00000010   020050E1           CMP      R0,R2
    411                  return false;
   \   00000014   0000A003           MOVEQ    R0,#+0
   \   00000018   1EFF2F01           BXEQ     LR
    412              }
    413              return true;
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   1EFF2FE1           BX       LR               ;; return
    414          }

   \                                 In segment CODE, align 4, keep-with-next
    415          void ModbusUnit::HandleRequest(U8 *RequestData) {
   \                     ??HandleRequest:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   83DF4DE2           SUB      SP,SP,#+524
   \   00000008   0040A0E1           MOV      R4,R0
    416              int Offset;
    417              switch ( myPort->Device ) {
   \   0000000C   9C0194E5           LDR      R0,[R4, #+412]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   A80090E5           LDR      R0,[R0, #+168]
   \   00000018   6A0040E2           SUB      R0,R0,#+106
   \   0000001C   7C0D40E2           SUB      R0,R0,#+7936
   \   00000020   070050E3           CMP      R0,#+7
   \   00000024   0600008A           BHI      ??HandleRequest_5
   \   00000028   011F8FE2           ADR      R1,??HandleRequest_1
   \   0000002C   0010D1E7           LDRB     R1,[R1, R0]
   \   00000030   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??HandleRequest_1:
   \   00000034   01030301           DC8      +1,+3,+3,+1
   \   00000038   03030101           DC8      +3,+3,+1,+1
    418              case C_UART_DEVICE_MODICON_MASTER_TCP   :
    419              case C_UART_DEVICE_MODICON_SLAVE_TCP    :
    420              case C_UART_DEVICE_MODBUS_SLAVE_TCP     :
    421              case C_UART_DEVICE_MODBUS_MASTER_TCP    :
    422                  Offset = MODBUS_INDEX_TCP_OFFSET;
   \                     ??HandleRequest_6:
   \   0000003C   0660A0E3           MOV      R6,#+6
   \   00000040   000000EA           B        ??HandleRequest_7
    423                  break;
    424              case C_UART_DEVICE_MODICON_MASTER       :
    425              case C_UART_DEVICE_MODICON_SLAVE        :
    426              case C_UART_DEVICE_MODBUS_SLAVE_INV     :
    427              case C_UART_DEVICE_MODBUS_SLAVE         :
    428              case C_UART_DEVICE_MODBUS_MASTER        :
    429              case C_UART_DEVICE_MODBUS_MASTER_INV    :
    430              default:
    431                  Offset = 0;
   \                     ??HandleRequest_5:
   \   00000044   0060A0E3           MOV      R6,#+0
    432                  break;
    433              }
    434              TimeStamp  = clock();
   \                     ??HandleRequest_7:
   \   00000048   ........           _BLF     clock,??clock??rA
   \   0000004C   400084E5           STR      R0,[R4, #+64]
    435              switch ( RequestData[MODBUS_INDEX_COMMAND] ) {
   \   00000050   CC00A0E3           MOV      R0,#+204
   \   00000054   810C80E3           ORR      R0,R0,#0x8100
   \   00000058   041080E0           ADD      R1,R0,R4
   \   0000005C   0100D5E5           LDRB     R0,[R5, #+1]
   \   00000060   067086E2           ADD      R7,R6,#+6
   \   00000064   038086E2           ADD      R8,R6,#+3
   \   00000068   733FA0E3           MOV      R3,#+460
   \   0000006C   0290A0E3           MOV      R9,#+2
   \   00000070   010040E2           SUB      R0,R0,#+1
   \   00000074   0F0050E3           CMP      R0,#+15
   \   00000078   1701008A           BHI      ??HandleRequest_8
   \   0000007C   022F8FE2           ADR      R2,??HandleRequest_2
   \   00000080   8000A0E1           MOV      R0,R0, LSL #+1
   \   00000084   B02092E1           LDRH     R2,[R2, R0]
   \   00000088   02F18FE0           ADD      PC,PC,R2, LSL #+2
   \                     ??HandleRequest_2:
   \   0000008C   070007003E00       DC16     +7,+7,+62,+62
   \              3E00        
   \   00000094   720093002001       DC16     +114,+147,+288,+275
   \              1301        
   \   0000009C   130113011301       DC16     +275,+275,+275,+275
   \              1301        
   \   000000A4   13011301C400       DC16     +275,+275,+196,+225
   \              E100        
    436              case MBUS_CMD_READ_COIL_STATUS          :
    437              case MBUS_CMD_READ_INPUT_STATUS         :
    438                  {
    439                      int FCoil         = (RequestData[MODBUS_INDEX_ADDRESS] << 8) | RequestData[MODBUS_INDEX_ADDRESS + 1];
   \                     ??HandleRequest_9:
   \   000000AC   0200D5E5           LDRB     R0,[R5, #+2]
   \   000000B0   0320D5E5           LDRB     R2,[R5, #+3]
    440                      int NCoils        = (RequestData[MODBUS_INDEX_CNT] << 8) | RequestData[MODBUS_INDEX_CNT + 1];
   \   000000B4   0530D5E5           LDRB     R3,[R5, #+5]
    441                      int NumberOfBytes = NCoils >> 3;
    442                      if ( NCoils & 7 ) {
    443                          NumberOfBytes++;
    444                      }
    445                      //SlaveAddress--;
    446                      // Not that the Packet contains 3 times 0x0 to make space for CRC
    447                      U8 Packet[MAX_QUERY_LENGTH + CHECKSUM_SIZE + 1];
    448          
    449                      Packet[MODBUS_INDEX_SLAVE_ADDRESS + Offset] = Address;
   \   000000B8   94A194E5           LDR      R10,[R4, #+404]
   \   000000BC   002482E1           ORR      R2,R2,R0, LSL #+8
   \   000000C0   0400D5E5           LDRB     R0,[R5, #+4]
   \   000000C4   003483E1           ORR      R3,R3,R0, LSL #+8
   \   000000C8   08008DE2           ADD      R0,SP,#+8
   \   000000CC   000086E0           ADD      R0,R6,R0
   \   000000D0   00A0C0E5           STRB     R10,[R0, #+0]
    450                      Packet[MODBUS_INDEX_COMMAND       + Offset] = RequestData[MODBUS_INDEX_COMMAND];
   \   000000D4   01A0D5E5           LDRB     R10,[R5, #+1]
   \   000000D8   C371A0E1           ASR      R7,R3,#+3
   \   000000DC   070013E3           TST      R3,#0x7
   \   000000E0   01708712           ADDNE    R7,R7,#+1
   \   000000E4   01A0C0E5           STRB     R10,[R0, #+1]
    451                      Packet[MODBUS_INDEX_EXCEPTION_CODE + Offset] = NumberOfBytes;
   \   000000E8   0270C0E5           STRB     R7,[R0, #+2]
    452                      U8 *tmpCoilPtr;
    453                      switch ( RequestData[MODBUS_INDEX_COMMAND] ) {
   \   000000EC   0150D5E5           LDRB     R5,[R5, #+1]
   \   000000F0   015055E2           SUBS     R5,R5,#+1
   \   000000F4   0200000A           BEQ      ??HandleRequest_10
   \   000000F8   015055E2           SUBS     R5,R5,#+1
   \   000000FC   1300000A           BEQ      ??HandleRequest_11
   \   00000100   080000EA           B        ??HandleRequest_12
    454                      case MBUS_CMD_READ_COIL_STATUS   :
    455                          switch ( myPort->Device ) {
   \                     ??HandleRequest_10:
   \   00000104   9C1194E5           LDR      R1,[R4, #+412]
   \   00000108   6B50A0E3           MOV      R5,#+107
   \   0000010C   A81091E5           LDR      R1,[R1, #+168]
   \   00000110   7C5D85E3           ORR      R5,R5,#0x1F00
   \   00000114   050051E1           CMP      R1,R5
   \   00000118   1200001A           BNE      ??HandleRequest_13
    456                          case C_UART_DEVICE_MODBUS_SLAVE     :
    457                              tmpCoilPtr = DigitalOut;
   \                     ??HandleRequest_14:
   \   0000011C   701BA0E3           MOV      R1,#+114688
   \                     ??HandleRequest_15:
   \   00000120   8B1F81E3           ORR      R1,R1,#0x22C
   \   00000124   041081E0           ADD      R1,R1,R4
    458                              break;
    459                          case C_UART_DEVICE_MODBUS_SLAVE_TCP :
    460                              tmpCoilPtr = DigitalIn;
    461                              break;
    462                          default:
    463                              tmpCoilPtr = DigitalIn;
    464                          }
    465                          break;
    466                      case MBUS_CMD_READ_INPUT_STATUS  :
    467                          switch ( myPort->Device ) {
    468                          case C_UART_DEVICE_MODBUS_SLAVE     :
    469                              tmpCoilPtr = DigitalIn;
    470                              break;
    471                          case C_UART_DEVICE_MODBUS_SLAVE_TCP :
    472                              tmpCoilPtr = DigitalOut;
    473                              break;
    474                          default:
    475                              tmpCoilPtr = DigitalOut;
    476                          }
    477                      }
    478          
    479                      if ( GetCoils(tmpCoilPtr, FCoil, NCoils, &Packet[MODBUS_INDEX_DATA_START + Offset]) ) {
   \                     ??HandleRequest_12:
   \   00000128   030080E2           ADD      R0,R0,#+3
   \   0000012C   01002DE9           PUSH     {R0}
   \   00000130   0400A0E1           MOV      R0,R4
   \   00000134   ........           BL       ??GetCoils
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   04D08DE2           ADD      SP,SP,#+4
   \   00000140   0A00000A           BEQ      ??HandleRequest_16
    480                          Send_Query(myPort, Packet, MODBUS_INDEX_DATA_START + NumberOfBytes + Offset);
   \   00000144   070086E0           ADD      R0,R6,R7
   \                     ??HandleRequest_17:
   \   00000148   032080E2           ADD      R2,R0,#+3
   \   0000014C   EC0000EA           B        ??HandleRequest_18
    481                      } else {
   \                     ??HandleRequest_11:
   \   00000150   9C1194E5           LDR      R1,[R4, #+412]
   \   00000154   6B50A0E3           MOV      R5,#+107
   \   00000158   A81091E5           LDR      R1,[R1, #+168]
   \   0000015C   7C5D85E3           ORR      R5,R5,#0x1F00
   \   00000160   050051E1           CMP      R1,R5
   \   00000164   ECFFFF1A           BNE      ??HandleRequest_14
   \                     ??HandleRequest_13:
   \   00000168   721BA0E3           MOV      R1,#+116736
   \   0000016C   EBFFFFEA           B        ??HandleRequest_15
    482                          Packet[MODBUS_INDEX_COMMAND] += 0x80;
   \                     ??HandleRequest_16:
   \   00000170   0910DDE5           LDRB     R1,[SP, #+9]
    483                          Packet[MODBUS_INDEX_EXCEPTION_CODE] = MODBUS_EX_ILLEGAL_ADDRESS;
    484                          Send_Query(myPort, Packet, MODBUS_INDEX_EXCEPTION_CODE + 1 + Offset);
   \   00000174   0820A0E1           MOV      R2,R8
   \   00000178   801081E2           ADD      R1,R1,#+128
   \   0000017C   0910CDE5           STRB     R1,[SP, #+9]
   \   00000180   0A90CDE5           STRB     R9,[SP, #+10]
   \   00000184   DE0000EA           B        ??HandleRequest_18
    485                      }
    486                  }
    487                  break;
    488              case MBUS_CMD_READ_HOLDING_REGISTER     :
    489              case MBUS_CMD_READ_INPUT_REGISTER       :
    490                  {
    491                      int FReg  = (RequestData[MODBUS_INDEX_ADDRESS] << 8) | RequestData[MODBUS_INDEX_ADDRESS + 1];
   \                     ??HandleRequest_19:
   \   00000188   0220D5E5           LDRB     R2,[R5, #+2]
   \   0000018C   0370D5E5           LDRB     R7,[R5, #+3]
    492                      int NRegs = (RequestData[MODBUS_INDEX_CNT] << 8) | RequestData[MODBUS_INDEX_CNT    + 1];
   \   00000190   05A0D5E5           LDRB     R10,[R5, #+5]
    493                      //SlaveAddress--;
    494                      // Not that the Packet contains 3 times 0x0 to make space for CRC
    495                      U8 Packet[MAX_QUERY_LENGTH + CHECKSUM_SIZE + 1];
    496          
    497                      Packet[MODBUS_INDEX_SLAVE_ADDRESS + Offset] = Address;
   \   00000194   94C194E5           LDR      R12,[R4, #+404]
   \   00000198   022487E1           ORR      R2,R7,R2, LSL #+8
   \   0000019C   0470D5E5           LDRB     R7,[R5, #+4]
   \   000001A0   07748AE1           ORR      R7,R10,R7, LSL #+8
   \   000001A4   08A08DE2           ADD      R10,SP,#+8
   \   000001A8   0AA086E0           ADD      R10,R6,R10
   \   000001AC   00C0CAE5           STRB     R12,[R10, #+0]
    498                      Packet[MODBUS_INDEX_COMMAND       + Offset] = RequestData[MODBUS_INDEX_COMMAND];
   \   000001B0   01C0D5E5           LDRB     R12,[R5, #+1]
   \   000001B4   01C0CAE5           STRB     R12,[R10, #+1]
    499                      Packet[MODBUS_INDEX_BYTE_CNT + Offset] = NRegs * 2;
   \   000001B8   07C0A0E1           MOV      R12,R7
   \   000001BC   8CC0A0E1           LSL      R12,R12,#+1
   \   000001C0   02C0CAE5           STRB     R12,[R10, #+2]
    500          
    501                      U16 *tmpRegPtr;
    502                      switch ( RequestData[MODBUS_INDEX_COMMAND] ) {
   \   000001C4   0150D5E5           LDRB     R5,[R5, #+1]
   \   000001C8   035055E2           SUBS     R5,R5,#+3
   \   000001CC   1300000A           BEQ      ??HandleRequest_20
   \   000001D0   015055E2           SUBS     R5,R5,#+1
   \   000001D4   0600001A           BNE      ??HandleRequest_21
    503                      case MBUS_CMD_READ_INPUT_REGISTER   :
    504                          switch ( myPort->Device ) {
   \   000001D8   9C0194E5           LDR      R0,[R4, #+412]
   \   000001DC   6B50A0E3           MOV      R5,#+107
   \   000001E0   A80090E5           LDR      R0,[R0, #+168]
   \   000001E4   7C5D85E3           ORR      R5,R5,#0x1F00
   \   000001E8   050050E1           CMP      R0,R5
   \   000001EC   1100001A           BNE      ??HandleRequest_22
    505                          case C_UART_DEVICE_MODBUS_SLAVE     :
    506                              tmpRegPtr = AnalogIn;
   \                     ??HandleRequest_23:
   \   000001F0   0100A0E1           MOV      R0,R1
    507                              break;
    508                          case C_UART_DEVICE_MODBUS_SLAVE_TCP :
    509                              tmpRegPtr = AnalogOut;
    510                              break;
    511                          default:
    512                              tmpRegPtr = AnalogOut;
    513                          }
    514                          break;
    515                      case MBUS_CMD_READ_HOLDING_REGISTER :
    516                          switch ( myPort->Device ) {
    517                          case C_UART_DEVICE_MODBUS_SLAVE     :
    518                              tmpRegPtr = AnalogOut;
    519                              break;
    520                          case C_UART_DEVICE_MODBUS_SLAVE_TCP :
    521                              tmpRegPtr = AnalogIn;
    522                              break;
    523                          default:
    524                              tmpRegPtr = AnalogIn;
    525                          }
    526                          break;
    527                      }
    528                      if ( SlaveGetRegisters(tmpRegPtr, FReg, NRegs, &Packet[MODBUS_INDEX_DATA_START + Offset]) ) {
   \                     ??HandleRequest_21:
   \   000001F4   03108AE2           ADD      R1,R10,#+3
   \   000001F8   02002DE9           PUSH     {R1}
   \   000001FC   0730A0E1           MOV      R3,R7
   \   00000200   0010A0E1           MOV      R1,R0
   \   00000204   0400A0E1           MOV      R0,R4
   \   00000208   ........           BL       ??SlaveGetRegisters
   \   0000020C   000050E3           CMP      R0,#+0
   \   00000210   04D08DE2           ADD      SP,SP,#+4
   \   00000214   0900000A           BEQ      ??HandleRequest_24
    529                          Send_Query(myPort, Packet, MODBUS_INDEX_DATA_START + NRegs * 2 + Offset);
   \   00000218   870086E0           ADD      R0,R6,R7, LSL #+1
   \   0000021C   C9FFFFEA           B        ??HandleRequest_17
    530                      } else {
   \                     ??HandleRequest_20:
   \   00000220   9C0194E5           LDR      R0,[R4, #+412]
   \   00000224   6B50A0E3           MOV      R5,#+107
   \   00000228   A80090E5           LDR      R0,[R0, #+168]
   \   0000022C   7C5D85E3           ORR      R5,R5,#0x1F00
   \   00000230   050050E1           CMP      R0,R5
   \   00000234   EDFFFF1A           BNE      ??HandleRequest_23
   \                     ??HandleRequest_22:
   \   00000238   040083E0           ADD      R0,R3,R4
   \   0000023C   ECFFFFEA           B        ??HandleRequest_21
    531                          Packet[MODBUS_INDEX_COMMAND       + Offset] += 0x80;
   \                     ??HandleRequest_24:
   \   00000240   0100DAE5           LDRB     R0,[R10, #+1]
    532                          Packet[MODBUS_INDEX_EXCEPTION_CODE + Offset] = MODBUS_EX_ILLEGAL_ADDRESS;
    533                          Send_Query(myPort, Packet, MODBUS_INDEX_EXCEPTION_CODE + 1 + Offset);
   \   00000244   0820A0E1           MOV      R2,R8
   \   00000248   800080E2           ADD      R0,R0,#+128
   \   0000024C   0100CAE5           STRB     R0,[R10, #+1]
   \   00000250   0290CAE5           STRB     R9,[R10, #+2]
   \   00000254   AA0000EA           B        ??HandleRequest_18
    534                      }
    535                  }
    536                  break;
    537              case MBUS_CMD_WRITE_SINGLE_COIL         :
    538                  {
    539                      int FReg = (RequestData[MODBUS_INDEX_ADDRESS] << 8) | RequestData[MODBUS_INDEX_ADDRESS + 1];
   \                     ??HandleRequest_25:
   \   00000258   0200D5E5           LDRB     R0,[R5, #+2]
   \   0000025C   0310D5E5           LDRB     R1,[R5, #+3]
    540                      int Coil = (RequestData[MODBUS_INDEX_CNT] << 8) | RequestData[MODBUS_INDEX_CNT + 1];
   \   00000260   0520D5E5           LDRB     R2,[R5, #+5]
   \   00000264   001481E1           ORR      R1,R1,R0, LSL #+8
   \   00000268   0400D5E5           LDRB     R0,[R5, #+4]
   \   0000026C   002482E1           ORR      R2,R2,R0, LSL #+8
    541                      //SlaveAddress--;
    542                      // Not that the Packet contains 3 times 0x0 to make space for CRC
    543                      U8 Packet[MAX_QUERY_LENGTH + CHECKSUM_SIZE + 1];
    544          
    545                      Packet[MODBUS_INDEX_SLAVE_ADDRESS + Offset] = Address;
   \   00000270   08008DE2           ADD      R0,SP,#+8
   \   00000274   006086E0           ADD      R6,R6,R0
   \   00000278   940194E5           LDR      R0,[R4, #+404]
   \   0000027C   0000C6E5           STRB     R0,[R6, #+0]
    546                      Packet[MODBUS_INDEX_COMMAND       + Offset] = RequestData[MODBUS_INDEX_COMMAND];
   \   00000280   0100D5E5           LDRB     R0,[R5, #+1]
   \   00000284   0100C6E5           STRB     R0,[R6, #+1]
    547                      Packet[MODBUS_INDEX_ADDRESS       + Offset] = RequestData[MODBUS_INDEX_ADDRESS];
   \   00000288   0200D5E5           LDRB     R0,[R5, #+2]
   \   0000028C   0200C6E5           STRB     R0,[R6, #+2]
    548                      Packet[MODBUS_INDEX_ADDRESS + 1   + Offset] = RequestData[MODBUS_INDEX_ADDRESS + 1];
   \   00000290   0300D5E5           LDRB     R0,[R5, #+3]
   \   00000294   0300C6E5           STRB     R0,[R6, #+3]
    549                      Packet[MODBUS_INDEX_CNT           + Offset] = RequestData[MODBUS_INDEX_CNT];
   \   00000298   0400D5E5           LDRB     R0,[R5, #+4]
   \   0000029C   0400C6E5           STRB     R0,[R6, #+4]
    550                      Packet[MODBUS_INDEX_CNT + 1       + Offset] = RequestData[MODBUS_INDEX_CNT + 1];
   \   000002A0   0500D5E5           LDRB     R0,[R5, #+5]
   \   000002A4   0500C6E5           STRB     R0,[R6, #+5]
    551          
    552                      if ( SetInCoil(FReg, Coil) ) {
   \   000002A8   0400A0E1           MOV      R0,R4
   \   000002AC   ........           BL       ??SetInCoil
   \   000002B0   000050E3           CMP      R0,#+0
    553                          // Just send the request packet
    554                          Send_Query(myPort, RequestData, REQUEST_QUERY_SIZE + Offset);
   \   000002B4   0720A011           MOVNE    R2,R7
   \   000002B8   0510A011           MOVNE    R1,R5
   \   000002BC   9100001A           BNE      ??HandleRequest_26
    555                      } else {
    556                          Packet[MODBUS_INDEX_COMMAND + Offset] += 0x80;
   \   000002C0   0100D6E5           LDRB     R0,[R6, #+1]
    557                          Packet[MODBUS_INDEX_EXCEPTION_CODE + Offset] = MODBUS_EX_ILLEGAL_ADDRESS;
    558                          Send_Query(myPort, Packet, MODBUS_INDEX_EXCEPTION_CODE + 1 + Offset);
   \   000002C4   0820A0E1           MOV      R2,R8
   \   000002C8   08108DE2           ADD      R1,SP,#+8
   \   000002CC   800080E2           ADD      R0,R0,#+128
   \   000002D0   0100C6E5           STRB     R0,[R6, #+1]
   \   000002D4   0290C6E5           STRB     R9,[R6, #+2]
   \   000002D8   8A0000EA           B        ??HandleRequest_26
    559                      }
    560                  }
    561                  break;
    562              case MBUS_CMD_WRITE_SINGLE_REGISTER     :
    563                  {
    564                      int FReg = (RequestData[MODBUS_INDEX_ADDRESS] << 8) | RequestData[MODBUS_INDEX_ADDRESS + 1];
   \                     ??HandleRequest_27:
   \   000002DC   0200D5E5           LDRB     R0,[R5, #+2]
   \   000002E0   0320D5E5           LDRB     R2,[R5, #+3]
   \   000002E4   002482E1           ORR      R2,R2,R0, LSL #+8
    565                      //SlaveAddress--;
    566                      // Not that the Packet contains 3 times 0x0 to make space for CRC
    567                      U8 Packet[MAX_QUERY_LENGTH + CHECKSUM_SIZE + 1];
    568          
    569                      Packet[MODBUS_INDEX_SLAVE_ADDRESS + Offset] = Address;
   \   000002E8   08008DE2           ADD      R0,SP,#+8
   \   000002EC   00A086E0           ADD      R10,R6,R0
   \   000002F0   940194E5           LDR      R0,[R4, #+404]
    570                      Packet[MODBUS_INDEX_COMMAND       + Offset] = RequestData[MODBUS_INDEX_COMMAND];
    571                      Packet[MODBUS_INDEX_ADDRESS       + Offset] = RequestData[MODBUS_INDEX_ADDRESS];
    572                      Packet[MODBUS_INDEX_ADDRESS + 1   + Offset] = RequestData[MODBUS_INDEX_ADDRESS + 1];
    573                      Packet[MODBUS_INDEX_CNT           + Offset] = RequestData[MODBUS_INDEX_CNT];
    574                      Packet[MODBUS_INDEX_CNT + 1       + Offset] = RequestData[MODBUS_INDEX_CNT + 1];
    575          
    576                      if ( FReg < MODBUS_MAX_REGISTERS ) {
   \   000002F4   400C52E3           CMP      R2,#+16384
   \   000002F8   0000CAE5           STRB     R0,[R10, #+0]
   \   000002FC   0100D5E5           LDRB     R0,[R5, #+1]
   \   00000300   0100CAE5           STRB     R0,[R10, #+1]
   \   00000304   0200D5E5           LDRB     R0,[R5, #+2]
   \   00000308   0200CAE5           STRB     R0,[R10, #+2]
   \   0000030C   0300D5E5           LDRB     R0,[R5, #+3]
   \   00000310   0300CAE5           STRB     R0,[R10, #+3]
   \   00000314   0400D5E5           LDRB     R0,[R5, #+4]
   \   00000318   0400CAE5           STRB     R0,[R10, #+4]
   \   0000031C   0500D5E5           LDRB     R0,[R5, #+5]
   \   00000320   0500CAE5           STRB     R0,[R10, #+5]
   \   00000324   160000AA           BGE      ??HandleRequest_28
    577                          U16 *tmpRegPtr;
    578                          switch ( myPort->Device ) {
   \   00000328   9C0194E5           LDR      R0,[R4, #+412]
   \   0000032C   A80090E5           LDR      R0,[R0, #+168]
   \   00000330   6B0040E2           SUB      R0,R0,#+107
   \   00000334   7C0D40E2           SUB      R0,R0,#+7936
   \   00000338   060050E3           CMP      R0,#+6
   \   0000033C   0400008A           BHI      ??HandleRequest_29
   \   00000340   01CF8FE2           ADR      R12,??HandleRequest_3
   \   00000344   00C0DCE7           LDRB     R12,[R12, R0]
   \   00000348   0CF18FE0           ADD      PC,PC,R12, LSL #+2
   \                     ??HandleRequest_3:
   \   0000034C   02020201           DC8      +2,+2,+2,+1
   \   00000350   02010200           DC8      +2,+1,+2,+0
    579                          case C_UART_DEVICE_MODICON_SLAVE_TCP    :
    580                          case C_UART_DEVICE_MODICON_SLAVE        :
    581                          case C_UART_DEVICE_MODBUS_SLAVE_TCP     :
    582                          case C_UART_DEVICE_MODBUS_SLAVE_INV     :
    583                          case C_UART_DEVICE_MODBUS_SLAVE         :
    584                              tmpRegPtr = AnalogIn;
    585                              break;
    586                          case C_UART_DEVICE_MODICON_MASTER_TCP   :
    587                          case C_UART_DEVICE_MODICON_MASTER       :
    588                          case C_UART_DEVICE_MODBUS_MASTER        :
    589                          case C_UART_DEVICE_MODBUS_MASTER_TCP    :
    590                          case C_UART_DEVICE_MODBUS_MASTER_INV    :
    591                          default:
    592                              tmpRegPtr = AnalogOut;
   \                     ??HandleRequest_29:
   \   00000354   041083E0           ADD      R1,R3,R4
    593                              break;
    594                          }
    595          
    596                          if ( SlaveSetRegisters(tmpRegPtr, FReg, 1, &RequestData[MODBUS_INDEX_CNT + Offset]) ) {
   \                     ??HandleRequest_30:
   \   00000358   050086E0           ADD      R0,R6,R5
   \   0000035C   040080E2           ADD      R0,R0,#+4
   \   00000360   01002DE9           PUSH     {R0}
   \   00000364   0130A0E3           MOV      R3,#+1
   \   00000368   0400A0E1           MOV      R0,R4
   \   0000036C   ........           BL       ??SlaveSetRegisters
   \   00000370   000050E3           CMP      R0,#+0
   \   00000374   04D08DE2           ADD      SP,SP,#+4
    597                              Send_Query(myPort, Packet, REQUEST_QUERY_SIZE + Offset);
   \   00000378   0720A011           MOVNE    R2,R7
   \   0000037C   08108D12           ADDNE    R1,SP,#+8
   \   00000380   6000001A           BNE      ??HandleRequest_26
    598                          } else {
    599                              Packet[MODBUS_INDEX_COMMAND + Offset] += 0x80;
   \                     ??HandleRequest_28:
   \   00000384   0100DAE5           LDRB     R0,[R10, #+1]
    600                              Packet[MODBUS_INDEX_EXCEPTION_CODE + Offset] = MODBUS_EX_ILLEGAL_ADDRESS;
    601                              Send_Query(myPort, Packet, MODBUS_INDEX_EXCEPTION_CODE + 1 + Offset);
   \   00000388   0820A0E1           MOV      R2,R8
   \   0000038C   08108DE2           ADD      R1,SP,#+8
   \   00000390   800080E2           ADD      R0,R0,#+128
   \   00000394   0100CAE5           STRB     R0,[R10, #+1]
   \   00000398   0290CAE5           STRB     R9,[R10, #+2]
   \   0000039C   590000EA           B        ??HandleRequest_26
    602                          }
    603                      } else {
    604                          Packet[MODBUS_INDEX_COMMAND + Offset] += 0x80;
    605                          Packet[MODBUS_INDEX_EXCEPTION_CODE + Offset] = MODBUS_EX_ILLEGAL_ADDRESS;
    606                          Send_Query(myPort, Packet, MODBUS_INDEX_EXCEPTION_CODE + 1 + Offset);
    607                      }
    608                  }
    609                  break;
    610              case MBUS_CMD_READ_EXCEPTION_STATUS     :
    611                  break;
    612              case MBUS_CMD_WRITE_MULTIPLE_COILS      :
    613                  {
    614                      int FCoil         = (RequestData[MODBUS_INDEX_ADDRESS] << 8) | RequestData[MODBUS_INDEX_ADDRESS + 1];
   \                     ??HandleRequest_31:
   \   000003A0   0200D5E5           LDRB     R0,[R5, #+2]
   \   000003A4   0310D5E5           LDRB     R1,[R5, #+3]
    615                      int NCoils        = (RequestData[MODBUS_INDEX_CNT] << 8) | RequestData[MODBUS_INDEX_CNT    + 1];
   \   000003A8   0520D5E5           LDRB     R2,[R5, #+5]
   \   000003AC   001481E1           ORR      R1,R1,R0, LSL #+8
   \   000003B0   0400D5E5           LDRB     R0,[R5, #+4]
   \   000003B4   002482E1           ORR      R2,R2,R0, LSL #+8
    616                      int NumberOfBytes = NCoils >> 3;
    617                      if ( NCoils & 7 ) {
    618                          NumberOfBytes++;
    619                      }
    620                      //SlaveAddress--;
    621                      // Not that the Packet contains 3 times 0x0 to make space for CRC
    622                      U8 Packet[MAX_QUERY_LENGTH + CHECKSUM_SIZE + 1];
    623          
    624                      Packet[MODBUS_INDEX_SLAVE_ADDRESS + Offset] = Address;
   \   000003B8   08008DE2           ADD      R0,SP,#+8
   \   000003BC   00A086E0           ADD      R10,R6,R0
   \   000003C0   940194E5           LDR      R0,[R4, #+404]
   \   000003C4   0000CAE5           STRB     R0,[R10, #+0]
    625                      Packet[MODBUS_INDEX_COMMAND       + Offset] = RequestData[MODBUS_INDEX_COMMAND];
   \   000003C8   0100D5E5           LDRB     R0,[R5, #+1]
   \   000003CC   0100CAE5           STRB     R0,[R10, #+1]
    626                      Packet[MODBUS_INDEX_ADDRESS       + Offset] = RequestData[MODBUS_INDEX_ADDRESS];
   \   000003D0   0200D5E5           LDRB     R0,[R5, #+2]
   \   000003D4   0200CAE5           STRB     R0,[R10, #+2]
    627                      Packet[MODBUS_INDEX_ADDRESS + 1   + Offset] = RequestData[MODBUS_INDEX_ADDRESS + 1];
   \   000003D8   0300D5E5           LDRB     R0,[R5, #+3]
   \   000003DC   0300CAE5           STRB     R0,[R10, #+3]
    628                      Packet[MODBUS_INDEX_CNT           + Offset] = RequestData[MODBUS_INDEX_CNT];
   \   000003E0   0400D5E5           LDRB     R0,[R5, #+4]
   \   000003E4   0400CAE5           STRB     R0,[R10, #+4]
    629                      Packet[MODBUS_INDEX_CNT + 1       + Offset] = RequestData[MODBUS_INDEX_CNT + 1];
   \   000003E8   0500D5E5           LDRB     R0,[R5, #+5]
   \   000003EC   0500CAE5           STRB     R0,[R10, #+5]
    630                      if ( SetCoils(FCoil, NCoils, &RequestData[REQUEST_MULTIPLE_SIZE + Offset]) ) {
   \   000003F0   050086E0           ADD      R0,R6,R5
   \   000003F4   073080E2           ADD      R3,R0,#+7
   \   000003F8   0400A0E1           MOV      R0,R4
   \   000003FC   ........           BL       ??SetCoils
   \   00000400   000050E3           CMP      R0,#+0
    631                          Send_Query(myPort, Packet, REQUEST_QUERY_SIZE + Offset);
   \   00000404   0720A011           MOVNE    R2,R7
   \   00000408   08108D12           ADDNE    R1,SP,#+8
   \   0000040C   3D00001A           BNE      ??HandleRequest_26
    632                      } else {
    633                          Packet[MODBUS_INDEX_COMMAND       + Offset] += 0x80;
   \   00000410   DBFFFFEA           B        ??HandleRequest_28
    634                          Packet[MODBUS_INDEX_EXCEPTION_CODE + Offset] = MODBUS_EX_ILLEGAL_ADDRESS;
    635                          Send_Query(myPort, Packet, MODBUS_INDEX_EXCEPTION_CODE + 1 + Offset);
    636                      }
    637                  }
    638                  break;
    639              case MBUS_CMD_WRITE_MULTIPLE_REGISTERS  :
    640                  {
    641                      int FReg  = (RequestData[MODBUS_INDEX_ADDRESS] << 8) | RequestData[MODBUS_INDEX_ADDRESS + 1];
   \                     ??HandleRequest_32:
   \   00000414   0200D5E5           LDRB     R0,[R5, #+2]
   \   00000418   0320D5E5           LDRB     R2,[R5, #+3]
    642                      int NRegs = (RequestData[MODBUS_INDEX_CNT] << 8) | RequestData[MODBUS_INDEX_CNT + 1];
   \   0000041C   0570D5E5           LDRB     R7,[R5, #+5]
    643                      //SlaveAddress--;
    644                      // Not that the Packet contains 3 times 0x0 to make space for CRC
    645                      U8 Packet[MAX_QUERY_LENGTH + CHECKSUM_SIZE + 1];
    646          
    647                      Packet[MODBUS_INDEX_SLAVE_ADDRESS + Offset] = Address;
   \   00000420   94A194E5           LDR      R10,[R4, #+404]
   \   00000424   002482E1           ORR      R2,R2,R0, LSL #+8
   \   00000428   0400D5E5           LDRB     R0,[R5, #+4]
   \   0000042C   000487E1           ORR      R0,R7,R0, LSL #+8
   \   00000430   08708DE2           ADD      R7,SP,#+8
   \   00000434   077086E0           ADD      R7,R6,R7
   \   00000438   00A0C7E5           STRB     R10,[R7, #+0]
    648                      Packet[MODBUS_INDEX_COMMAND       + Offset] = RequestData[MODBUS_INDEX_COMMAND];
   \   0000043C   01A0D5E5           LDRB     R10,[R5, #+1]
   \   00000440   01A0C7E5           STRB     R10,[R7, #+1]
    649                      Packet[MODBUS_INDEX_ADDRESS       + Offset] = RequestData[MODBUS_INDEX_ADDRESS];
   \   00000444   02A0D5E5           LDRB     R10,[R5, #+2]
   \   00000448   02A0C7E5           STRB     R10,[R7, #+2]
    650                      Packet[MODBUS_INDEX_ADDRESS + 1   + Offset] = RequestData[MODBUS_INDEX_ADDRESS + 1];
   \   0000044C   03A0D5E5           LDRB     R10,[R5, #+3]
   \   00000450   03A0C7E5           STRB     R10,[R7, #+3]
    651                      Packet[MODBUS_INDEX_CNT           + Offset] = RequestData[MODBUS_INDEX_CNT];
   \   00000454   04A0D5E5           LDRB     R10,[R5, #+4]
   \   00000458   04A0C7E5           STRB     R10,[R7, #+4]
    652                      Packet[MODBUS_INDEX_CNT + 1       + Offset] = RequestData[MODBUS_INDEX_CNT + 1];
   \   0000045C   05A0D5E5           LDRB     R10,[R5, #+5]
   \   00000460   05A0C7E5           STRB     R10,[R7, #+5]
    653          
    654                      U16 *tmpRegPtr;
    655                      switch ( myPort->Device ) {
   \   00000464   9CA194E5           LDR      R10,[R4, #+412]
   \   00000468   A8A09AE5           LDR      R10,[R10, #+168]
   \   0000046C   6BA04AE2           SUB      R10,R10,#+107
   \   00000470   7CAD4AE2           SUB      R10,R10,#+7936
   \   00000474   06005AE3           CMP      R10,#+6
   \   00000478   0400008A           BHI      ??HandleRequest_33
   \   0000047C   01CF8FE2           ADR      R12,??HandleRequest_4
   \   00000480   0AC0DCE7           LDRB     R12,[R12, R10]
   \   00000484   0CF18FE0           ADD      PC,PC,R12, LSL #+2
   \                     ??HandleRequest_4:
   \   00000488   02020201           DC8      +2,+2,+2,+1
   \   0000048C   02010200           DC8      +2,+1,+2,+0
    656                      case C_UART_DEVICE_MODICON_SLAVE_TCP    :
    657                      case C_UART_DEVICE_MODICON_SLAVE        :
    658                      case C_UART_DEVICE_MODBUS_SLAVE_TCP     :
    659                      case C_UART_DEVICE_MODBUS_SLAVE_INV     :
    660                      case C_UART_DEVICE_MODBUS_SLAVE         :
    661                          tmpRegPtr = AnalogIn;
    662                          break;
    663                      case C_UART_DEVICE_MODBUS_MASTER:
    664                      default:
    665                          tmpRegPtr = AnalogOut;
   \                     ??HandleRequest_33:
   \   00000490   041083E0           ADD      R1,R3,R4
    666                          break;
    667                      }
    668          
    669                      if ( SlaveSetRegisters(tmpRegPtr, FReg, NRegs, &RequestData[REQUEST_MULTIPLE_SIZE + Offset]) ) {
   \                     ??HandleRequest_34:
   \   00000494   053086E0           ADD      R3,R6,R5
   \   00000498   073083E2           ADD      R3,R3,#+7
   \   0000049C   08002DE9           PUSH     {R3}
   \   000004A0   0030A0E1           MOV      R3,R0
   \   000004A4   0400A0E1           MOV      R0,R4
   \   000004A8   ........           BL       ??SlaveSetRegisters
   \   000004AC   000050E3           CMP      R0,#+0
   \   000004B0   04D08DE2           ADD      SP,SP,#+4
    670                          Send_Query(myPort, Packet, REQUEST_QUERY_SIZE);
   \   000004B4   0620A013           MOVNE    R2,#+6
   \   000004B8   08108D12           ADDNE    R1,SP,#+8
   \   000004BC   1100001A           BNE      ??HandleRequest_26
    671                      } else {
    672                          Packet[MODBUS_INDEX_COMMAND + Offset] += 0x80;
   \   000004C0   0100D7E5           LDRB     R0,[R7, #+1]
    673                          Packet[MODBUS_INDEX_EXCEPTION_CODE + Offset] = MODBUS_EX_ILLEGAL_ADDRESS;
    674                          Send_Query(myPort, Packet, MODBUS_INDEX_EXCEPTION_CODE + 1 + Offset);
   \   000004C4   0820A0E1           MOV      R2,R8
   \   000004C8   08108DE2           ADD      R1,SP,#+8
   \   000004CC   800080E2           ADD      R0,R0,#+128
   \   000004D0   0100C7E5           STRB     R0,[R7, #+1]
   \   000004D4   0290C7E5           STRB     R9,[R7, #+2]
   \   000004D8   0A0000EA           B        ??HandleRequest_26
    675                      }
    676                  }
    677                  break;
    678              default:
    679                  {
    680                      //SlaveAddress--;
    681                      // Not that the Packet contains 3 times 0x0 to make space for CRC
    682                      U8 Packet[MAX_QUERY_LENGTH + CHECKSUM_SIZE + 1];
    683          
    684                      Packet[MODBUS_INDEX_SLAVE_ADDRESS + Offset] = Address;
   \                     ??HandleRequest_8:
   \   000004DC   941194E5           LDR      R1,[R4, #+404]
   \   000004E0   08008DE2           ADD      R0,SP,#+8
   \   000004E4   000086E0           ADD      R0,R6,R0
   \   000004E8   0010C0E5           STRB     R1,[R0, #+0]
    685                      Packet[MODBUS_INDEX_COMMAND       + Offset] = RequestData[MODBUS_INDEX_COMMAND] + 0x80;
   \   000004EC   0110D5E5           LDRB     R1,[R5, #+1]
    686                      Packet[MODBUS_INDEX_EXCEPTION_CODE + Offset] = MODBUS_EX_ILLEGAL_FUNCTION;
    687                      Send_Query(myPort, Packet, MODBUS_INDEX_EXCEPTION_CODE + 1 + Offset);
   \   000004F0   0820A0E1           MOV      R2,R8
   \   000004F4   801081E2           ADD      R1,R1,#+128
   \   000004F8   0110C0E5           STRB     R1,[R0, #+1]
   \   000004FC   0110A0E3           MOV      R1,#+1
   \   00000500   0210C0E5           STRB     R1,[R0, #+2]
   \                     ??HandleRequest_18:
   \   00000504   08108DE2           ADD      R1,SP,#+8
   \                     ??HandleRequest_26:
   \   00000508   9C0194E5           LDR      R0,[R4, #+412]
   \   0000050C   ........           _BLF     ??Send_Query,??Send_Query??rA
    688                  }
    689                  break;
    690          
    691          
    692              }
    693          }
   \                     ??HandleRequest_35:
   \   00000510   83DF8DE2           ADD      SP,SP,#+524
   \   00000514   ........           B        ?Subroutine53
    694          #ifdef ANWIN
    695          bool ModbusUnit::HandleIO(HANDLE m_hWagoSocketHandle, mbtReadRegistersFunc pMBTReadRegisters, mbtWriteRegistersFunc pMBTWriteRegisters, mbtReadCoilsFunc pMBTReadCoils, mbtWriteCoilsFunc pMBTWriteCoils) {
    696              bool returnValue = true;
    697              const int RequestDelay = 100;
    698              unsigned WagoConnectionStatus;
    699              int Cnt = 0; // Assume that the problem is a general communication failure
    700              /*
    701              for (unsigned i = 0; i < AddressesVectAnalogOut.size(); i++) {
    702                  unsigned Channel = AddressesVectAnalogOut[i].First;
    703                  unsigned Count   = AddressesVectAnalogOut[i].NumberOfAddr;
    704                  if (WriteMultipleRegisters(Port, Address, Channel, Count, (U8 *)&AnalogOut[Channel], TimeOut, FrameSpaceTime, FrameTimeOut) == PORT_FAILURE) {
    705                      Cnt++;
    706                  }
    707                  TSN_Delay(myRequestDelay);
    708              }
    709              */
    710              for ( unsigned i = 0; i < AddressesVectAnalogIn.size(); i++ ) {
    711                  unsigned Channel = AddressesVectAnalogIn[i].First;
    712                  unsigned Count   = AddressesVectAnalogIn[i].NumberOfAddr;
    713                  WagoConnectionStatus = pMBTReadRegisters(m_hWagoSocketHandle, MODBUSTCP_TABLE_INPUT_REGISTER, Channel, Count, (char *)&AnalogIn[Channel], NULL, 0);
    714          
    715                  if ( WagoConnectionStatus != 0 ) {
    716                      returnValue = false;
    717                  }
    718                  TSN_Delay(myRequestDelay);
    719              }
    720              for ( unsigned i = 0; i < AddressesVectDigitalOut.size(); i++ ) {
    721                  unsigned Channel = AddressesVectDigitalOut[i].First;
    722                  unsigned Count   = AddressesVectDigitalOut[i].NumberOfAddr;
    723                  /*
    724                  if (WriteMultipleCoils(Port, Address, Channel, Count, &DigitalOut[Channel / 8], TimeOut, FrameSpaceTime, FrameTimeOut) == PORT_FAILURE) {
    725                      Cnt++;
    726                  }
    727                  TSN_Delay(RequestDelay);
    728                  */
    729              }
    730              for ( unsigned i = 0; i < AddressesVectDigitalIn.size(); i++ ) {
    731                  unsigned Channel = AddressesVectDigitalIn[i].First;
    732                  unsigned Count   = AddressesVectDigitalIn[i].NumberOfAddr;
    733                  /*
    734                  if (Get_Multiple(Port, Port->ModbusCmdInputStatus, Address, Channel, Count, &DigitalIn[Channel / 8], TimeOut, FrameSpaceTime, FrameTimeOut) == PORT_FAILURE) {
    735                      Cnt++;
    736                  }
    737                  TSN_Delay(RequestDelay);
    738                  */
    739              }
    740              if ( Cnt ) {
    741                  ComFailCount        += Cnt;
    742                  ComTotalFailCount   += Cnt;
    743              } else {
    744                  ComFailCount = 0;
    745              }
    746              return returnValue;
    747          }
    748          #else

   \                                 In segment CODE, align 4, keep-with-next
    749          void ModbusUnit::HandleIO(void) {
   \                     ??HandleIO:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   C0DF4DE2           SUB      SP,SP,#+768
   \   00000008   0040A0E1           MOV      R4,R0
    750          
    751              int Cnt = 0; // Assume that the problem is a general communication failure
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   0080A0E3           MOV      R8,#+0
   \   00000014   406084E2           ADD      R6,R4,#+64
   \   00000018   0A70E0E3           MVN      R7,#+10
   \   0000001C   040000EA           B        ??HandleIO_1
    752              for ( unsigned i = 0; i < AddressesVectAnalogIn.size(); i++ ) {
    753                  unsigned Channel = AddressesVectAnalogIn[i].First;
    754                  unsigned Count   = AddressesVectAnalogIn[i].NumberOfAddr;
    755                  if ( Get_Multiple(myPort, myPort->ModbusCmdInputRegister, Address, Channel, Count, (U8 *)&AnalogIn[Channel], myTimeOut, myFrameSpaceTime, myFrameTimeOut) == PORT_FAILURE ) {
    756                      Cnt++;
    757                  } else {
    758                      FlagNewValues(Channel, Count);
   \                     ??HandleIO_2:
   \   00000020   0A20A0E1           MOV      R2,R10
   \   00000024   0910A0E1           MOV      R1,R9
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           BL       ??FlagNewValues
    759                  }
   \                     ??HandleIO_3:
   \   00000030   018088E2           ADD      R8,R8,#+1
   \                     ??HandleIO_1:
   \   00000034   520F84E2           ADD      R0,R4,#+328
   \   00000038   041090E5           LDR      R1,[R0, #+4]
   \   0000003C   000090E5           LDR      R0,[R0, #+0]
   \   00000040   000041E0           SUB      R0,R1,R0
   \   00000044   0C10A0E3           MOV      R1,#+12
   \   00000048   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   0000004C   010058E1           CMP      R8,R1
   \   00000050   1B00002A           BCS      ??HandleIO_4
   \   00000054   080196E5           LDR      R0,[R6, #+264]
   \   00000058   0C10A0E3           MOV      R1,#+12
   \   0000005C   910820E0           MLA      R0,R1,R8,R0
   \   00000060   701196E5           LDR      R1,[R6, #+368]
   \   00000064   009090E5           LDR      R9,[R0, #+0]
   \   00000068   08A090E5           LDR      R10,[R0, #+8]
   \   0000006C   5C0196E5           LDR      R0,[R6, #+348]
   \   00000070   02002DE9           PUSH     {R1}
   \   00000074   6C1196E5           LDR      R1,[R6, #+364]
   \   00000078   892084E0           ADD      R2,R4,R9, LSL #+1
   \   0000007C   02002DE9           PUSH     {R1}
   \   00000080   681196E5           LDR      R1,[R6, #+360]
   \   00000084   0930A0E1           MOV      R3,R9
   \   00000088   02002DE9           PUSH     {R1}
   \   0000008C   CC10A0E3           MOV      R1,#+204
   \   00000090   811C81E3           ORR      R1,R1,#0x8100
   \   00000094   021081E0           ADD      R1,R1,R2
   \   00000098   02002DE9           PUSH     {R1}
   \   0000009C   0A10A0E1           MOV      R1,R10
   \   000000A0   02002DE9           PUSH     {R1}
   \   000000A4   542196E5           LDR      R2,[R6, #+340]
   \   000000A8   6C1090E5           LDR      R1,[R0, #+108]
   \   000000AC   ........           _BLF     ??Get_Multiple,??Get_Multiple??rA
   \   000000B0   070050E1           CMP      R0,R7
   \   000000B4   14D08DE2           ADD      SP,SP,#+20
   \   000000B8   D8FFFF1A           BNE      ??HandleIO_2
   \   000000BC   015085E2           ADD      R5,R5,#+1
   \   000000C0   DAFFFFEA           B        ??HandleIO_3
    760              }
    761              for ( unsigned i = 0; i < AddressesVectDigitalIn.size(); i++ ) {
   \                     ??HandleIO_4:
   \   000000C4   0080A0E3           MOV      R8,#+0
   \   000000C8   090000EA           B        ??HandleIO_5
    762                  unsigned Channel = AddressesVectDigitalIn[i].First;
    763                  unsigned Count   = AddressesVectDigitalIn[i].NumberOfAddr;
    764                  U8 tmpReplyData[256];
    765                  if ( Get_Multiple(myPort, myPort->ModbusCmdInputStatus, Address, Channel, Count, tmpReplyData, myTimeOut, myFrameSpaceTime, myFrameTimeOut) == PORT_FAILURE ) {
    766                      Cnt++;
    767                  } else {
    768                      SetCoils(Channel, Count, tmpReplyData);
   \                     ??HandleIO_6:
   \   000000CC   803F8DE2           ADD      R3,SP,#+512
   \   000000D0   0A20A0E1           MOV      R2,R10
   \   000000D4   0910A0E1           MOV      R1,R9
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           BL       ??SetCoils
    769                      FlagNewDigitalValues(Channel, Count);
   \   000000E0   0A20A0E1           MOV      R2,R10
   \   000000E4   0910A0E1           MOV      R1,R9
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   ........           BL       ??FlagNewDigitalValues
    770                  }
   \                     ??HandleIO_7:
   \   000000F0   018088E2           ADD      R8,R8,#+1
   \                     ??HandleIO_5:
   \   000000F4   580F84E2           ADD      R0,R4,#+352
   \   000000F8   041090E5           LDR      R1,[R0, #+4]
   \   000000FC   000090E5           LDR      R0,[R0, #+0]
   \   00000100   000041E0           SUB      R0,R1,R0
   \   00000104   0C10A0E3           MOV      R1,#+12
   \   00000108   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   0000010C   010058E1           CMP      R8,R1
   \   00000110   1800002A           BCS      ??HandleIO_8
   \   00000114   200196E5           LDR      R0,[R6, #+288]
   \   00000118   0C10A0E3           MOV      R1,#+12
   \   0000011C   910820E0           MLA      R0,R1,R8,R0
   \   00000120   701196E5           LDR      R1,[R6, #+368]
   \   00000124   009090E5           LDR      R9,[R0, #+0]
   \   00000128   08A090E5           LDR      R10,[R0, #+8]
   \   0000012C   5C0196E5           LDR      R0,[R6, #+348]
   \   00000130   02002DE9           PUSH     {R1}
   \   00000134   6C1196E5           LDR      R1,[R6, #+364]
   \   00000138   0930A0E1           MOV      R3,R9
   \   0000013C   02002DE9           PUSH     {R1}
   \   00000140   681196E5           LDR      R1,[R6, #+360]
   \   00000144   02002DE9           PUSH     {R1}
   \   00000148   831F8DE2           ADD      R1,SP,#+524
   \   0000014C   02002DE9           PUSH     {R1}
   \   00000150   0A10A0E1           MOV      R1,R10
   \   00000154   02002DE9           PUSH     {R1}
   \   00000158   542196E5           LDR      R2,[R6, #+340]
   \   0000015C   681090E5           LDR      R1,[R0, #+104]
   \   00000160   ........           _BLF     ??Get_Multiple,??Get_Multiple??rA
   \   00000164   070050E1           CMP      R0,R7
   \   00000168   14D08DE2           ADD      SP,SP,#+20
   \   0000016C   D6FFFF1A           BNE      ??HandleIO_6
   \   00000170   015085E2           ADD      R5,R5,#+1
   \   00000174   DDFFFFEA           B        ??HandleIO_7
    771              }
   \                     ??HandleIO_8:
   \   00000178   740BA0E3           MOV      R0,#+118784
   \   0000017C   940F80E3           ORR      R0,R0,#0x250
   \   00000180   048080E0           ADD      R8,R0,R4
   \   00000184   2000D8E5           LDRB     R0,[R8, #+32]
   \   00000188   000050E3           CMP      R0,#+0
   \   0000018C   2000000A           BEQ      ??HandleIO_9
    772              if ( hasNewRegOutput ) {
    773                  hasNewRegOutput = false;
   \   00000190   0000A0E3           MOV      R0,#+0
   \   00000194   2000C8E5           STRB     R0,[R8, #+32]
    774                  for ( unsigned i = 0; i < AddressesVectAnalogOut.size(); i++ ) {
   \   00000198   0090A0E3           MOV      R9,#+0
   \   0000019C   140000EA           B        ??HandleIO_10
    775                      unsigned Channel = AddressesVectAnalogOut[i].First;
   \                     ??HandleIO_11:
   \   000001A0   140196E5           LDR      R0,[R6, #+276]
   \   000001A4   0C10A0E3           MOV      R1,#+12
   \   000001A8   910920E0           MLA      R0,R1,R9,R0
    776                      unsigned Count   = AddressesVectAnalogOut[i].NumberOfAddr;
    777                      if ( WriteMultipleRegisters(myPort, Address, Channel, Count, (U8 *)&AnalogOut[Channel], myTimeOut, myFrameSpaceTime, myFrameTimeOut) == PORT_FAILURE ) {
   \   000001AC   701196E5           LDR      R1,[R6, #+368]
   \   000001B0   002090E5           LDR      R2,[R0, #+0]
   \   000001B4   02002DE9           PUSH     {R1}
   \   000001B8   6C1196E5           LDR      R1,[R6, #+364]
    778                          Cnt++;
    779                      }
    780                  }
   \   000001BC   019089E2           ADD      R9,R9,#+1
   \   000001C0   02002DE9           PUSH     {R1}
   \   000001C4   681196E5           LDR      R1,[R6, #+360]
   \   000001C8   02002DE9           PUSH     {R1}
   \   000001CC   821084E0           ADD      R1,R4,R2, LSL #+1
   \   000001D0   731F81E2           ADD      R1,R1,#+460
   \   000001D4   02002DE9           PUSH     {R1}
   \   000001D8   083090E5           LDR      R3,[R0, #+8]
   \   000001DC   541196E5           LDR      R1,[R6, #+340]
   \   000001E0   5C0196E5           LDR      R0,[R6, #+348]
   \   000001E4   ........           _BLF     ??WriteMultipleRegisters,??WriteMultipleRegisters??rA
   \   000001E8   070050E1           CMP      R0,R7
   \   000001EC   10D08DE2           ADD      SP,SP,#+16
   \   000001F0   01508502           ADDEQ    R5,R5,#+1
   \                     ??HandleIO_10:
   \   000001F4   550F84E2           ADD      R0,R4,#+340
   \   000001F8   041090E5           LDR      R1,[R0, #+4]
   \   000001FC   000090E5           LDR      R0,[R0, #+0]
   \   00000200   000041E0           SUB      R0,R1,R0
   \   00000204   0C10A0E3           MOV      R1,#+12
   \   00000208   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   0000020C   010059E1           CMP      R9,R1
   \   00000210   E2FFFF3A           BCC      ??HandleIO_11
    781              }
    782              if ( hasNewCoilOutput ) {
   \                     ??HandleIO_9:
   \   00000214   2100D8E5           LDRB     R0,[R8, #+33]
   \   00000218   000050E3           CMP      R0,#+0
   \   0000021C   2D00000A           BEQ      ??HandleIO_12
    783                  hasNewCoilOutput = false;
   \   00000220   0000A0E3           MOV      R0,#+0
   \   00000224   2100C8E5           STRB     R0,[R8, #+33]
    784                  for ( unsigned i = 0; i < AddressesVectDigitalOut.size(); i++ ) {
   \   00000228   0090A0E3           MOV      R9,#+0
   \   0000022C   210000EA           B        ??HandleIO_13
    785                      unsigned FCoil  = AddressesVectDigitalOut[i].First;
   \                     ??HandleIO_14:
   \   00000230   2C0196E5           LDR      R0,[R6, #+300]
   \   00000234   0C10A0E3           MOV      R1,#+12
   \   00000238   910920E0           MLA      R0,R1,R9,R0
   \   0000023C   00A090E5           LDR      R10,[R0, #+0]
    786                      unsigned NCoils = AddressesVectDigitalOut[i].NumberOfAddr;
   \   00000240   08B090E5           LDR      R11,[R0, #+8]
    787                      U8 Packet[MAX_QUERY_LENGTH];  // Could subtract REQUEST_MULTIPLE_SIZE
    788                      if ( GetCoils(DigitalOut, FCoil, NCoils, Packet) ) {
   \   00000244   0D00A0E1           MOV      R0,SP
   \   00000248   01002DE9           PUSH     {R0}
   \   0000024C   0B30A0E1           MOV      R3,R11
   \   00000250   0A20A0E1           MOV      R2,R10
   \   00000254   700BA0E3           MOV      R0,#+114688
   \   00000258   8B0F80E3           ORR      R0,R0,#0x22C
   \   0000025C   041080E0           ADD      R1,R0,R4
   \   00000260   0400A0E1           MOV      R0,R4
   \   00000264   ........           BL       ??GetCoils
   \   00000268   000050E3           CMP      R0,#+0
   \   0000026C   04D08DE2           ADD      SP,SP,#+4
   \   00000270   0F00000A           BEQ      ??HandleIO_15
    789                          if ( WriteMultipleCoils(myPort, Address, FCoil, NCoils, Packet, myTimeOut, myFrameSpaceTime, myFrameTimeOut) == PORT_FAILURE ) {
   \   00000274   700196E5           LDR      R0,[R6, #+368]
   \   00000278   0B30A0E1           MOV      R3,R11
   \   0000027C   01002DE9           PUSH     {R0}
   \   00000280   6C0196E5           LDR      R0,[R6, #+364]
   \   00000284   0A20A0E1           MOV      R2,R10
   \   00000288   01002DE9           PUSH     {R0}
   \   0000028C   680196E5           LDR      R0,[R6, #+360]
   \   00000290   01002DE9           PUSH     {R0}
   \   00000294   0C008DE2           ADD      R0,SP,#+12
   \   00000298   01002DE9           PUSH     {R0}
   \   0000029C   541196E5           LDR      R1,[R6, #+340]
   \   000002A0   5C0196E5           LDR      R0,[R6, #+348]
   \   000002A4   ........           _BLF     ??WriteMultipleCoils,??WriteMultipleCoils??rA
   \   000002A8   070050E1           CMP      R0,R7
   \   000002AC   10D08DE2           ADD      SP,SP,#+16
    790                              Cnt++;
   \   000002B0   01508502           ADDEQ    R5,R5,#+1
    791                          }
    792                      }
    793                  }
   \                     ??HandleIO_15:
   \   000002B4   019089E2           ADD      R9,R9,#+1
   \                     ??HandleIO_13:
   \   000002B8   5B0F84E2           ADD      R0,R4,#+364
   \   000002BC   041090E5           LDR      R1,[R0, #+4]
   \   000002C0   000090E5           LDR      R0,[R0, #+0]
   \   000002C4   000041E0           SUB      R0,R1,R0
   \   000002C8   0C10A0E3           MOV      R1,#+12
   \   000002CC   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   000002D0   010059E1           CMP      R9,R1
   \   000002D4   D5FFFF3A           BCC      ??HandleIO_14
    794              }
    795              TSN_Delay(myRequestDelay * 2);
   \                     ??HandleIO_12:
   \   000002D8   640196E5           LDR      R0,[R6, #+356]
   \   000002DC   8000A0E1           LSL      R0,R0,#+1
   \   000002E0   ........           _BLF     OS_Delay,??OS_Delay??rA
    796              if ( Cnt ) {
   \   000002E4   000055E3           CMP      R5,#+0
   \   000002E8   0D00000A           BEQ      ??HandleIO_16
    797                  if ( myPort->Relaxed ) {
   \   000002EC   5C1196E5           LDR      R1,[R6, #+348]
   \   000002F0   000098E5           LDR      R0,[R8, #+0]
   \   000002F4   5810D1E5           LDRB     R1,[R1, #+88]
   \   000002F8   000051E3           CMP      R1,#+0
   \   000002FC   00008500           ADDEQ    R0,R5,R0
   \   00000300   00008805           STREQ    R0,[R8, #+0]
   \   00000304   04009805           LDREQ    R0,[R8, #+4]
   \   00000308   00008500           ADDEQ    R0,R5,R0
    798                      ComFailCount++;
   \   0000030C   01008012           ADDNE    R0,R0,#+1
   \   00000310   00008815           STRNE    R0,[R8, #+0]
    799                      ComTotalFailCount++;
   \   00000314   04009815           LDRNE    R0,[R8, #+4]
   \   00000318   01008012           ADDNE    R0,R0,#+1
   \   0000031C   040088E5           STR      R0,[R8, #+4]
   \   00000320   030000EA           B        ??HandleIO_17
    800                  } else {
    801                      ComFailCount        += Cnt;
    802                      ComTotalFailCount   += Cnt;
    803                  }
    804              } else {
    805                  ComFailCount = 0;
   \                     ??HandleIO_16:
   \   00000324   0000A0E3           MOV      R0,#+0
   \   00000328   000088E5           STR      R0,[R8, #+0]
    806                  TimeStamp  = clock();
   \   0000032C   ........           _BLF     clock,??clock??rA
   \   00000330   000086E5           STR      R0,[R6, #+0]
    807              }
    808              //SendData();
    809              CheckAlarms(AlarmSet, &HWFailure);
   \                     ??HandleIO_17:
   \   00000334   3C1084E2           ADD      R1,R4,#+60
   \   00000338   E40084E2           ADD      R0,R4,#+228
   \   0000033C   ........           _BLF     ??CheckAlarms,??CheckAlarms??rA
    810          }
   \   00000340   C0DF8DE2           ADD      SP,SP,#+768
   \   00000344   ........           B        ?Subroutine57
    811          #endif

   \                                 In segment CODE, align 4, keep-with-next
    812          ModbusUnit* ModbusUnit::FindDevice(U8 TCUUnit, U16 ComPort, U8 Address) {
   \                     ??FindDevice:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    813              unsigned Key = (TCUUnit << 24) | (Address << 16) | ComPort;
    814              ModbusUnit *ObjPtr = NULL;
    815              map<unsigned, ModbusUnit *>::iterator ObjMapIterator;
    816              ObjMapIterator = DeviceMap.find(Key);
   \   00000004   ........           LDR      R5,??DataTable6  ;; ??DeviceMap
   \   00000008   0040A0E3           MOV      R4,#+0
   \   0000000C   0228A0E1           LSL      R2,R2,#+16
   \   00000010   000C82E1           ORR      R0,R2,R0, LSL #+24
   \   00000014   001081E1           ORR      R1,R1,R0
   \   00000018   0500A0E1           MOV      R0,R5
   \   0000001C   ........           _BLF     ??find,??find??rA
    817              if ( ObjMapIterator != DeviceMap.end() ) {
   \   00000020   050050E1           CMP      R0,R5
    818                  ObjPtr = ObjMapIterator->second;
   \   00000024   14409015           LDRNE    R4,[R0, #+20]
    819              }
    820              return (ObjPtr);
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C                      REQUIRE ?Subroutine52
   \   0000002C                      ;; // Fall through to label ?Subroutine52
    821          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine52:
   \   00000000   3040BDE8           POP      {R4,R5,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    822          //----------------------------------------------------------------------------

   \                                 In segment CODE, align 4, keep-with-next
    823          void ModbusUnit::InsertInMap(U8 TCUUnit, U16 ComPort, U8 Address, int ObjType, int Channel, unsigned RefObjId, bool isVolatile) {
   \                     ??InsertInMap:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   38509DE5           LDR      R5,[SP, #+56]
   \   0000000C   3C609DE5           LDR      R6,[SP, #+60]
   \   00000010   4070DDE5           LDRB     R7,[SP, #+64]
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   0190A0E1           MOV      R9,R1
   \   0000001C   02A0A0E1           MOV      R10,R2
    824              ModbusUnit *tmpReg = FindDevice(TCUUnit, ComPort, Address);
   \   00000020   ........           BL       ??FindDevice
   \   00000024   0080B0E1           MOVS     R8,R0
    825              if ( !tmpReg ) {
   \   00000028   0C00001A           BNE      ??InsertInMap_2
    826                  unsigned Key = (TCUUnit << 24) | (Address << 16) | ComPort;
    827                  tmpReg = new ModbusUnit(Address, ComPort);
   \   0000002C   0910A0E1           MOV      R1,R9
   \   00000030   0A00A0E1           MOV      R0,R10
   \   00000034   ........           BL       `??new ModbusUnit`
    828                  DeviceMap.insert(pair<unsigned, ModbusUnit *>(Key, tmpReg));
   \   00000038   0A18A0E1           LSL      R1,R10,#+16
   \   0000003C   041C81E1           ORR      R1,R1,R4, LSL #+24
   \   00000040   011089E1           ORR      R1,R9,R1
   \   00000044   00108DE5           STR      R1,[SP, #+0]
   \   00000048   ........           LDR      R1,??DataTable6  ;; ??DeviceMap
   \   0000004C   0080A0E1           MOV      R8,R0
   \   00000050   04808DE5           STR      R8,[SP, #+4]
   \   00000054   0D20A0E1           MOV      R2,SP
   \   00000058   08008DE2           ADD      R0,SP,#+8
   \   0000005C   ........           _BLF     ??insert_3,??insert??rA_2
   \                     ??InsertInMap_2:
   \   00000060   10C09DE5           LDR      R12,[SP, #+16]
   \   00000064   740BA0E3           MOV      R0,#+118784
   \   00000068   8B0F80E3           ORR      R0,R0,#0x22C
   \   0000006C   089080E0           ADD      R9,R0,R8
   \   00000070   102099E5           LDR      R2,[R9, #+16]
   \   00000074   183099E5           LDR      R3,[R9, #+24]
   \   00000078   400BA0E3           MOV      R0,#+65536
   \   0000007C   790F80E3           ORR      R0,R0,#0x1E4
   \   00000080   081080E0           ADD      R1,R0,R8
   \   00000084   180040E2           SUB      R0,R0,#+24
   \   00000088   08A080E0           ADD      R10,R0,R8
   \   0000008C   480080E2           ADD      R0,R0,#+72
   \   00000090   080080E0           ADD      R0,R0,R8
   \   00000094   014085E2           ADD      R4,R5,#+1
   \   00000098   01B0A0E3           MOV      R11,#+1
   \   0000009C   F3C04CE2           SUB      R12,R12,#+243
   \   000000A0   A0CE4CE2           SUB      R12,R12,#+2560
   \   000000A4   33005CE3           CMP      R12,#+51
   \   000000A8   4C00008A           BHI      ??InsertInMap_3
   \   000000AC   01EF8FE2           ADR      LR,??InsertInMap_1
   \   000000B0   0CE0DEE7           LDRB     LR,[LR, R12]
   \   000000B4   0EF18FE0           ADD      PC,PC,LR, LSL #+2
   \                     ??InsertInMap_1:
   \   000000B8   25192549           DC8      +37,+25,+37,+73
   \   000000BC   2F3A2F19           DC8      +47,+58,+47,+25
   \   000000C0   0C494949           DC8      +12,+73,+73,+73
   \   000000C4   49494949           DC8      +73,+73,+73,+73
   \   000000C8   49494949           DC8      +73,+73,+73,+73
   \   000000CC   49494949           DC8      +73,+73,+73,+73
   \   000000D0   49494949           DC8      +73,+73,+73,+73
   \   000000D4   49494949           DC8      +73,+73,+73,+73
   \   000000D8   49494949           DC8      +73,+73,+73,+73
   \   000000DC   49494949           DC8      +73,+73,+73,+73
   \   000000E0   49494949           DC8      +73,+73,+73,+73
   \   000000E4   49494919           DC8      +73,+73,+73,+25
   \   000000E8   19191919           DC8      +25,+25,+25,+25
    829              }
    830              switch ( ObjType ) {
    831              case C_PRO_MODBUS_REG_BIT_OUT:
    832                  tmpReg->StartAnalogOut   = MIN(tmpReg->StartAnalogOut, Channel);
   \                     ??InsertInMap_4:
   \   000000EC   050052E1           CMP      R2,R5
   \   000000F0   0520A0A1           MOVGE    R2,R5
   \   000000F4   102089E5           STR      R2,[R9, #+16]
    833                  tmpReg->LastAnalogOut    = MAX(tmpReg->LastAnalogOut, Channel + 1);
   \   000000F8   000099E5           LDR      R0,[R9, #+0]
    834                  tmpReg->HasAnalogOut     = true;
    835                  tmpReg->AnalogOutSet.insert(Channel);
   \   000000FC   0520A0E1           MOV      R2,R5
   \   00000100   040050E1           CMP      R0,R4
   \   00000104   0400A0B1           MOVLT    R0,R4
   \   00000108   000089E5           STR      R0,[R9, #+0]
   \   0000010C   20B0C9E5           STRB     R11,[R9, #+32]
   \   00000110   0D00A0E1           MOV      R0,SP
   \   00000114   ........           _BLF     ??insert_1,??insert??rA_3
    836                  if ( isVolatile ) {
   \   00000118   000057E3           CMP      R7,#+0
   \   0000011C   2F00000A           BEQ      ??InsertInMap_3
    837                      tmpReg->StartAnalogIn    = MIN(tmpReg->StartAnalogIn, Channel);
   \                     ??InsertInMap_5:
   \   00000120   140099E5           LDR      R0,[R9, #+20]
    838                      tmpReg->LastAnalogIn     = MAX(tmpReg->LastAnalogIn, Channel + 1);
    839                      tmpReg->HasAnalogIn      = true;
    840                      tmpReg->AnalogInSet.insert(Channel);
   \   00000124   0520A0E1           MOV      R2,R5
   \   00000128   050050E1           CMP      R0,R5
   \   0000012C   0500A0A1           MOVGE    R0,R5
   \   00000130   140089E5           STR      R0,[R9, #+20]
   \   00000134   040099E5           LDR      R0,[R9, #+4]
   \   00000138   0A10A0E1           MOV      R1,R10
   \   0000013C   040050E1           CMP      R0,R4
   \   00000140   0400A0B1           MOVLT    R0,R4
   \   00000144   040089E5           STR      R0,[R9, #+4]
   \   00000148   22B0C9E5           STRB     R11,[R9, #+34]
   \   0000014C   210000EA           B        ??InsertInMap_6
    841                  }
    842                  break;
    843              case C_PRO_MODBUS_REG_OUT    :
    844                  tmpReg->StartAnalogOut   = MIN(tmpReg->StartAnalogOut, Channel);
   \                     ??InsertInMap_7:
   \   00000150   050052E1           CMP      R2,R5
   \   00000154   0520A0A1           MOVGE    R2,R5
   \   00000158   102089E5           STR      R2,[R9, #+16]
    845                  tmpReg->LastAnalogOut    = MAX(tmpReg->LastAnalogOut, Channel + 1);
   \   0000015C   000099E5           LDR      R0,[R9, #+0]
    846                  tmpReg->HasAnalogOut     = true;
    847                  tmpReg->AnalogOutSet.insert(Channel);
   \   00000160   0520A0E1           MOV      R2,R5
   \   00000164   040050E1           CMP      R0,R4
   \   00000168   0400A0B1           MOVLT    R0,R4
   \   0000016C   000089E5           STR      R0,[R9, #+0]
   \   00000170   20B0C9E5           STRB     R11,[R9, #+32]
   \   00000174   170000EA           B        ??InsertInMap_6
    848                  break;
    849              case C_PRO_MODBUS_REG_HIST  :
    850                  tmpReg->StartAnalogOut   = MIN(tmpReg->StartAnalogOut, Channel);
    851                  tmpReg->LastAnalogOut    = MAX(tmpReg->LastAnalogOut, Channel + 1);
    852                  tmpReg->HasAnalogOut     = true;
    853                  tmpReg->AnalogOutSet.insert(Channel);
    854                  break;
    855              case C_PRO_MODBUS_REG_IN     :
    856              case C_PRO_MBUS_WAGO473_RIN  :
    857              case C_PRO_MBUS_WAGO479_RIN  :
    858              case C_PRO_MBUS_WAGO482_RIN  :
    859              case C_PRO_MBUS_WAGO485_RIN  :
    860              case C_PRO_MBUS_WAGO487_RIN  :
    861              case C_PRO_MODBUS_REG_BIT_IN :
    862                  tmpReg->StartAnalogIn    = MIN(tmpReg->StartAnalogIn, Channel);
    863                  tmpReg->LastAnalogIn     = MAX(tmpReg->LastAnalogIn, Channel + 1);
    864                  tmpReg->HasAnalogIn      = true;
    865                  tmpReg->AnalogInSet.insert(Channel);
    866                  break;
    867              case C_PRO_MODBUS_COIL_OUT  :
    868                  tmpReg->StartDigitalOut  = MIN(tmpReg->StartDigitalOut, Channel);
   \                     ??InsertInMap_8:
   \   00000178   050053E1           CMP      R3,R5
   \   0000017C   0530A0A1           MOVGE    R3,R5
   \   00000180   183089E5           STR      R3,[R9, #+24]
    869                  tmpReg->LastDigitalOut   = MAX(tmpReg->LastDigitalOut, Channel + 1);
   \   00000184   081099E5           LDR      R1,[R9, #+8]
    870                  tmpReg->HasDigitalOut    = true;
    871                  tmpReg->DigitalOutSet.insert(Channel);
   \   00000188   0520A0E1           MOV      R2,R5
   \   0000018C   040051E1           CMP      R1,R4
   \   00000190   0410A0B1           MOVLT    R1,R4
   \   00000194   081089E5           STR      R1,[R9, #+8]
   \   00000198   21B0C9E5           STRB     R11,[R9, #+33]
   \   0000019C   0010A0E1           MOV      R1,R0
   \   000001A0   0C0000EA           B        ??InsertInMap_6
    872                  break;
    873              case C_PRO_MODBUS_COIL_HIST :
    874                  tmpReg->StartDigitalOut  = MIN(tmpReg->StartDigitalOut, Channel);
    875                  tmpReg->LastDigitalOut   = MAX(tmpReg->LastDigitalOut, Channel + 1);
    876                  tmpReg->HasDigitalOut    = true;
    877                  tmpReg->DigitalOutSet.insert(Channel);
    878                  break;
    879              case C_PRO_MODBUS_COIL_IN   :
    880                  tmpReg->StartDigitalIn   = MIN(tmpReg->StartDigitalIn, Channel);
   \                     ??InsertInMap_9:
   \   000001A4   1C0099E5           LDR      R0,[R9, #+28]
    881                  tmpReg->LastDigitalIn    = MAX(tmpReg->LastDigitalIn, Channel + 1);
    882                  tmpReg->HasDigitalIn     = true;
    883                  tmpReg->DigitalInSet.insert(Channel);
   \   000001A8   0520A0E1           MOV      R2,R5
   \   000001AC   050050E1           CMP      R0,R5
   \   000001B0   0500A0A1           MOVGE    R0,R5
   \   000001B4   1C0089E5           STR      R0,[R9, #+28]
   \   000001B8   0C0099E5           LDR      R0,[R9, #+12]
   \   000001BC   040050E1           CMP      R0,R4
   \   000001C0   0400A0B1           MOVLT    R0,R4
   \   000001C4   0C0089E5           STR      R0,[R9, #+12]
   \   000001C8   23B0C9E5           STRB     R11,[R9, #+35]
   \   000001CC   400BA0E3           MOV      R0,#+65536
   \   000001D0   7F0F80E3           ORR      R0,R0,#0x1FC
   \   000001D4   081080E0           ADD      R1,R0,R8
   \                     ??InsertInMap_6:
   \   000001D8   0D00A0E1           MOV      R0,SP
   \   000001DC   ........           _BLF     ??insert_1,??insert??rA_3
    884                  break;
    885              }
    886              if ( RefObjId ) {
   \                     ??InsertInMap_3:
   \   000001E0   000056E3           CMP      R6,#+0
   \   000001E4   0300000A           BEQ      ??InsertInMap_10
    887                  tmpReg->ObjectIdSet.insert(RefObjId);
   \   000001E8   0620A0E1           MOV      R2,R6
   \   000001EC   6D1F88E2           ADD      R1,R8,#+436
   \   000001F0   0D00A0E1           MOV      R0,SP
   \   000001F4   ........           _BLF     ??insert_4,??insert??rA_4
    888              }
    889          }
   \                     ??InsertInMap_10:
   \   000001F8   14D08DE2           ADD      SP,SP,#+20
   \   000001FC   ........           B        ?Subroutine57

   \                                 In segment CODE, align 4, keep-with-next
    890          void ModbusUnit::DeleteAllInDeviceMap(void) {
   \                     ??DeleteAllInDeviceMap:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    891              map<unsigned, ModbusUnit *>::iterator ObjMapIterator;
    892              for ( ObjMapIterator = DeviceMap.begin(); ObjMapIterator != DeviceMap.end(); ObjMapIterator++ ) {
   \   00000004   ........           LDR      R4,??DataTable6  ;; ??DeviceMap
   \   00000008   005094E5           LDR      R5,[R4, #+0]
   \   0000000C   0D0000EA           B        ??DeleteAllInDeviceMap_1
    893                  delete (*ObjMapIterator).second;
   \                     ??DeleteAllInDeviceMap_2:
   \   00000010   142095E5           LDR      R2,[R5, #+20]
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   0700000A           BEQ      ??DeleteAllInDeviceMap_3
   \   0000001C   0200A0E1           MOV      R0,R2
   \   00000020   743BA0E3           MOV      R3,#+118784
   \   00000024   A13F83E3           ORR      R3,R3,#0x284
   \   00000028   022093E7           LDR      R2,[R3, +R2]
   \   0000002C   0310A0E3           MOV      R1,#+3
   \   00000030   002092E5           LDR      R2,[R2, #+0]
   \   00000034   0FE0A0E1           MOV      LR,PC
   \   00000038   12FF2FE1           BX       R2
    894              }
   \                     ??DeleteAllInDeviceMap_3:
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   ........           _BLF     ??_IncP,??_IncP??rA
   \   00000044   0050A0E1           MOV      R5,R0
   \                     ??DeleteAllInDeviceMap_1:
   \   00000048   040055E1           CMP      R5,R4
   \   0000004C   EFFFFF1A           BNE      ??DeleteAllInDeviceMap_2
    895              DeviceMap.clear();
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           _BLF     ??clear,??clear??rA
    896          }
   \   00000058   ........           B        ?Subroutine52
    897          

   \                                 In segment CODE, align 4, keep-with-next
    898          void ModbusUnit::SetIsMaster(void) {
   \                     ??SetIsMaster:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   60D04DE2           SUB      SP,SP,#+96
   \   00000008   0040A0E1           MOV      R4,R0
    899              IsMaster = true;
   \   0000000C   0100A0E3           MOV      R0,#+1
   \   00000010   9001C4E5           STRB     R0,[R4, #+400]
    900              SetAddressRanges(AnalogOutSet   , AddressesVectAnalogOut    , MAX_REGISTERS_RTU_WRITE   );
   \   00000014   400BA0E3           MOV      R0,#+65536
   \   00000018   790F80E3           ORR      R0,R0,#0x1E4
   \   0000001C   041080E0           ADD      R1,R0,R4
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   ........           _BLF     ??set,??set??rA_1
   \   00000028   7B30A0E3           MOV      R3,#+123
   \   0000002C   552F84E2           ADD      R2,R4,#+340
   \   00000030   0010A0E1           MOV      R1,R0
   \   00000034   0400A0E1           MOV      R0,R4
   \   00000038   ........           BL       ??SetAddressRanges
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           _BLF     `?~set_2`,`?~set??rA`
    901              SetAddressRanges(AnalogInSet    , AddressesVectAnalogIn     , MAX_REGISTERS_RTU_READ    );
   \   00000044   400BA0E3           MOV      R0,#+65536
   \   00000048   730F80E3           ORR      R0,R0,#0x1CC
   \   0000004C   041080E0           ADD      R1,R0,R4
   \   00000050   18008DE2           ADD      R0,SP,#+24
   \   00000054   ........           _BLF     ??set,??set??rA_1
   \   00000058   0010A0E1           MOV      R1,R0
   \   0000005C   7D30A0E3           MOV      R3,#+125
   \   00000060   522F84E2           ADD      R2,R4,#+328
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       ??SetAddressRanges
   \   0000006C   18008DE2           ADD      R0,SP,#+24
   \   00000070   ........           _BLF     `?~set_2`,`?~set??rA`
    902              SetAddressRanges(DigitalOutSet  , AddressesVectDigitalOut   , MAX_COILS_RTU_WRITE       );
   \   00000074   400BA0E3           MOV      R0,#+65536
   \   00000078   850F80E3           ORR      R0,R0,#0x214
   \   0000007C   041080E0           ADD      R1,R0,R4
   \   00000080   30008DE2           ADD      R0,SP,#+48
   \   00000084   ........           _BLF     ??set,??set??rA_1
   \   00000088   7B3EA0E3           MOV      R3,#+1968
   \   0000008C   5B2F84E2           ADD      R2,R4,#+364
   \   00000090   0010A0E1           MOV      R1,R0
   \   00000094   0400A0E1           MOV      R0,R4
   \   00000098   ........           BL       ??SetAddressRanges
   \   0000009C   30008DE2           ADD      R0,SP,#+48
   \   000000A0   ........           _BLF     `?~set_2`,`?~set??rA`
    903              SetAddressRanges(DigitalInSet   , AddressesVectDigitalIn    , MAX_COILS_RTU_READ        );
   \   000000A4   400BA0E3           MOV      R0,#+65536
   \   000000A8   7F0F80E3           ORR      R0,R0,#0x1FC
   \   000000AC   041080E0           ADD      R1,R0,R4
   \   000000B0   48008DE2           ADD      R0,SP,#+72
   \   000000B4   ........           _BLF     ??set,??set??rA_1
   \   000000B8   7D3EA0E3           MOV      R3,#+2000
   \   000000BC   582F84E2           ADD      R2,R4,#+352
   \   000000C0   0010A0E1           MOV      R1,R0
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       ??SetAddressRanges
   \   000000CC   48008DE2           ADD      R0,SP,#+72
   \   000000D0   ........           _BLF     `?~set_2`,`?~set??rA`
    904          }
   \   000000D4   60D08DE2           ADD      SP,SP,#+96
   \   000000D8   ........           B        ?Subroutine56
    905          
    906          

   \                                 In segment CODE, align 4, keep-with-next
    907          void ModbusUnit::SetAddressRanges(set<unsigned>AddressSet, vector<AddressRange> &AddressVector, int MaxAddressStep) {
   \                     ??SetAddressRanges:
   \   00000000   F7432DE9           PUSH     {R0-R2,R4-R9,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
   \   0000000C   0360A0E1           MOV      R6,R3
    908              AddressRange Addresses = { 0, 0, 0 };
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   0020A0E3           MOV      R2,#+0
   \   0000001C   0130A0E1           MOV      R3,R1
   \   00000020   0E0080E8           STM      R0,{R1-R3}
    909              bool FirstAddress = true;
    910              set<unsigned>::iterator IdIt;
    911              for ( IdIt = AddressSet.begin(); IdIt != AddressSet.end(); IdIt++ ) {
   \   00000024   008094E5           LDR      R8,[R4, #+0]
   \   00000028   0170A0E3           MOV      R7,#+1
   \   0000002C   030000EA           B        ??SetAddressRanges_1
    912                  unsigned Addr = *IdIt;
    913                  if ( FirstAddress ) {
    914                      FirstAddress = false;
    915                      Addresses.First = Addr;
    916                      Addresses.Last  = Addr;
    917                  } else {
    918                      if ( Addr >= (Addresses.First + MaxAddressStep) ) {
    919                          Addresses.NumberOfAddr = Addresses.Last - Addresses.First + 1;
    920                          AddressVector.push_back(Addresses);
    921                          Addresses.First = Addr;
    922                          Addresses.Last  = Addr;
    923                      } else {
    924                          Addresses.Last  = Addr;
   \                     ??SetAddressRanges_2:
   \   00000030   04908DE5           STR      R9,[SP, #+4]
    925                      }
   \   00000034   0800A0E1           MOV      R0,R8
   \   00000038   ........           _BLF     ??_IncP,??_IncP??rA
   \   0000003C   0080A0E1           MOV      R8,R0
   \                     ??SetAddressRanges_1:
   \   00000040   04009DE5           LDR      R0,[SP, #+4]
   \   00000044   00109DE5           LDR      R1,[SP, #+0]
   \   00000048   040058E1           CMP      R8,R4
   \   0000004C   010040E0           SUB      R0,R0,R1
   \   00000050   010080E2           ADD      R0,R0,#+1
   \   00000054   0700001A           BNE      ??SetAddressRanges_3
    926                  }
    927              }
    928              if ( !FirstAddress ) {
   \   00000058   000057E3           CMP      R7,#+0
   \   0000005C   0300001A           BNE      ??SetAddressRanges_4
    929                  Addresses.NumberOfAddr = Addresses.Last - Addresses.First + 1;
   \   00000060   08008DE5           STR      R0,[SP, #+8]
    930                  AddressVector.push_back(Addresses);
   \   00000064   0D10A0E1           MOV      R1,SP
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   ........           _BLF     ??_Push_back0,??_Push_back0??rA
    931              }
    932          }
   \                     ??SetAddressRanges_4:
   \   00000070   F743BDE8           POP      {R0-R2,R4-R9,LR}
   \   00000074   1EFF2FE1           BX       LR               ;; return
   \                     ??SetAddressRanges_3:
   \   00000078   109098E5           LDR      R9,[R8, #+16]
   \   0000007C   000057E3           CMP      R7,#+0
   \   00000080   0070A013           MOVNE    R7,#+0
   \   00000084   00908D15           STRNE    R9,[SP, #+0]
   \   00000088   E8FFFF1A           BNE      ??SetAddressRanges_2
   \   0000008C   011086E0           ADD      R1,R6,R1
   \   00000090   010059E1           CMP      R9,R1
   \   00000094   E5FFFF3A           BCC      ??SetAddressRanges_2
   \   00000098   08008DE5           STR      R0,[SP, #+8]
   \   0000009C   0D10A0E1           MOV      R1,SP
   \   000000A0   0500A0E1           MOV      R0,R5
   \   000000A4   ........           _BLF     ??_Push_back0,??_Push_back0??rA
   \   000000A8   00908DE5           STR      R9,[SP, #+0]
   \   000000AC   DFFFFFEA           B        ??SetAddressRanges_2
    933          

   \                                 In segment CODE, align 4, keep-with-next
    934          int ModbusUnit::GetFailCount(void) {
    935              return ComFailCount;
   \                     ??GetFailCount:
   \   00000000   741BA0E3           MOV      R1,#+118784
   \   00000004   941F81E3           ORR      R1,R1,#0x250
   \   00000008   ........           B        ?Subroutine58
    936          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine58:
   \   00000000   000091E7           LDR      R0,[R1, +R0]
   \   00000004   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
    937          int ModbusUnit::GetTotalFailCount(void) {
    938              return ComTotalFailCount;
   \                     ??GetTotalFailCount:
   \   00000000   741BA0E3           MOV      R1,#+118784
   \   00000004   951F81E3           ORR      R1,R1,#0x254
   \   00000008                      REQUIRE ?Subroutine58
   \   00000008                      ;; // Fall through to label ?Subroutine58
    939          }
    940          

   \                                 In segment CODE, align 4, keep-with-next
    941          void ModbusUnit::SetHWFailure(bool Failure) {
   \                     ??SetHWFailure:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    942              if ( Failure ) {
   \   00000008   000051E3           CMP      R1,#+0
   \   0000000C   1100000A           BEQ      ??SetHWFailure_1
    943                  set<AnalogInput *>::iterator pSnsIt;
    944                  for ( pSnsIt = SensorSet.begin(); pSnsIt != SensorSet.end(); pSnsIt++ ) {
   \   00000010   5E5FA0E3           MOV      R5,#+376
   \   00000014   046095E7           LDR      R6,[R5, +R4]
   \   00000018   0B0000EA           B        ??SetHWFailure_2
    945                      AnalogInput *SnsPtr = *pSnsIt;
   \                     ??SetHWFailure_3:
   \   0000001C   102096E5           LDR      R2,[R6, #+16]
    946                      SnsPtr->HWFailure = true;
   \   00000020   0100A0E3           MOV      R0,#+1
   \   00000024   0C01C2E5           STRB     R0,[R2, #+268]
    947                      SnsPtr->SendData();
   \   00000028   0200A0E1           MOV      R0,R2
   \   0000002C   A42092E5           LDR      R2,[R2, #+164]
   \   00000030   6510A0E3           MOV      R1,#+101
   \   00000034   402092E5           LDR      R2,[R2, #+64]
   \   00000038   0FE0A0E1           MOV      LR,PC
   \   0000003C   12FF2FE1           BX       R2
    948                  }
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   ........           _BLF     ??_IncP,??_IncP??rA
   \   00000048   0060A0E1           MOV      R6,R0
   \                     ??SetHWFailure_2:
   \   0000004C   040085E0           ADD      R0,R5,R4
   \   00000050   000056E1           CMP      R6,R0
   \   00000054   F0FFFF1A           BNE      ??SetHWFailure_3
    949              }
    950          }
   \                     ??SetHWFailure_1:
   \   00000058   ........           B        ??Subroutine49_0
    951          
    952          
    953          //---------------------------------------------------------------------------

   \                                 In segment CODE, align 4, keep-with-next
    954          void ModbusUnit::SetAlarmList(void) {
    955          }
   \                     ??SetAlarmList:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    956          //---------------------------------------------------------------------------

   \                                 In segment CODE, align 4, keep-with-next
    957          void ModbusUnit::SetProList(void) {
   \                     ??SetProList:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   ACD04DE2           SUB      SP,SP,#+172
   \   00000008   0040A0E1           MOV      R4,R0
    958          
    959              set<int>::iterator pBIt;
    960              for ( pBIt = ObjectIdSet.begin(); pBIt != ObjectIdSet.end(); pBIt++ ) {
   \   0000000C   6D5FA0E3           MOV      R5,#+436
   \   00000010   046095E7           LDR      R6,[R5, +R4]
   \   00000014   2A0000EA           B        ??SetProList_1
    961                  int ObjectId = *pBIt;
    962                  // Add PROgramobjects like e.g. a tank to this Modbus device
    963                  PRogramObject *ObjPtr = (PRogramObject *)FindPROFromIDNumber(ObjectId);
    964                  if ( ObjPtr ) {
    965                      pair<set<PRogramObject *>::iterator, bool> Ret;
    966                      Ret = IOUniquePROSet.insert(ObjPtr);
    967                      // Currently ignore thes PRogramObject alarms.
    968                      if ( Ret.second && ObjPtr->DataFromOther ) {
    969                          //AddAlarms(ObjPtr->CompleteAlarmInfoList);
    970                          ObjPtr->AddToExternalAlarms(AlarmSet);
    971                      }
    972                      // Now we find the sensors
    973                      set<AnalogInput *>tmpSensorSet = ObjPtr->GetModBusSensorList();
    974          
    975                      set<AnalogInput *>::iterator pSnsIt;
    976                      for ( pSnsIt = tmpSensorSet.begin(); pSnsIt != tmpSensorSet.end(); pSnsIt++ ) {
    977                          AnalogInput *SnsPtr = *pSnsIt;
    978                          SensorSet.insert(SnsPtr);
    979                          SnsPtr->AddAlarms(CompleteAlarmInfoList);
    980                      }
    981                  } else {
    982                      AnsiString ObjectIdStr;
    983                      ObjectIdStr.cat_sprintf("0x%0x", ObjectId);
   \                     ??SetProList_2:
   \   00000018   5C719FE5           LDR      R7,??SetProList_3  ;; `?<Constant "0x%0x">`
   \   0000001C   40008DE2           ADD      R0,SP,#+64
   \   00000020   ........           _BLF     ??AnsiString_2,??AnsiString??rA_2
   \   00000024   0830A0E1           MOV      R3,R8
   \   00000028   0720A0E1           MOV      R2,R7
   \   0000002C   90108DE2           ADD      R1,SP,#+144
   \   00000030   40008DE2           ADD      R0,SP,#+64
   \   00000034   ........           _BLF     ??cat_sprintf,??cat_sprintf??rA
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   0110A0E3           MOV      R1,#+1
   \   00000040   90008DE2           ADD      R0,SP,#+144
   \   00000044   ........           _BLF     ??_Tidy,??_Tidy??rA
    984          
    985                      AnsiString Message = "Program object not found for " + ObjectIdStr;
   \   00000048   40208DE2           ADD      R2,SP,#+64
   \   0000004C   081087E2           ADD      R1,R7,#+8
   \   00000050   08008DE2           ADD      R0,SP,#+8
   \   00000054   ........           _BLF     `??operator+_1`,`??operator+??rA`
   \   00000058   08108DE2           ADD      R1,SP,#+8
   \   0000005C   5C008DE2           ADD      R0,SP,#+92
   \   00000060   ........           _BLF     ??AnsiString_1,??AnsiString??rA_1
   \   00000064   0020A0E3           MOV      R2,#+0
   \   00000068   0110A0E3           MOV      R1,#+1
   \   0000006C   08008DE2           ADD      R0,SP,#+8
   \   00000070   ........           _BLF     ??_Tidy,??_Tidy??rA
    986                      HardwareSetupWarning(Message);
   \   00000074   5C108DE2           ADD      R1,SP,#+92
   \   00000078   24008DE2           ADD      R0,SP,#+36
   \   0000007C   ........           _BLF     ??string,??string??rA
   \   00000080   24008DE2           ADD      R0,SP,#+36
   \   00000084   ........           _BLF     ??HardwareSetupWarning,??HardwareSetupWarning??rA
   \   00000088   0020A0E3           MOV      R2,#+0
   \   0000008C   0110A0E3           MOV      R1,#+1
   \   00000090   24008DE2           ADD      R0,SP,#+36
   \   00000094   ........           _BLF     ??_Tidy,??_Tidy??rA
    987                  }
   \   00000098   0020A0E3           MOV      R2,#+0
   \   0000009C   0110A0E3           MOV      R1,#+1
   \   000000A0   5C008DE2           ADD      R0,SP,#+92
   \   000000A4   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000A8   0020A0E3           MOV      R2,#+0
   \   000000AC   0110A0E3           MOV      R1,#+1
   \   000000B0   40008DE2           ADD      R0,SP,#+64
   \   000000B4   ........           _BLF     ??_Tidy,??_Tidy??rA
   \                     ??SetProList_4:
   \   000000B8   0600A0E1           MOV      R0,R6
   \   000000BC   ........           _BLF     ??_IncP,??_IncP??rA
   \   000000C0   0060A0E1           MOV      R6,R0
   \                     ??SetProList_1:
   \   000000C4   040085E0           ADD      R0,R5,R4
   \   000000C8   000056E1           CMP      R6,R0
   \   000000CC   0100001A           BNE      ??SetProList_5
    988              }
    989          }
   \   000000D0   ACD08DE2           ADD      SP,SP,#+172
   \   000000D4   ........           B        ?Subroutine55
   \                     ??SetProList_5:
   \   000000D8   108096E5           LDR      R8,[R6, #+16]
   \   000000DC   0010A0E3           MOV      R1,#+0
   \   000000E0   0800A0E1           MOV      R0,R8
   \   000000E4   ........           _BLF     ??FindPROFromIDNumber,??FindPROFromIDNumber??rA
   \   000000E8   0070B0E1           MOVS     R7,R0
   \   000000EC   C9FFFF0A           BEQ      ??SetProList_2
   \   000000F0   0720A0E1           MOV      R2,R7
   \   000000F4   740BA0E3           MOV      R0,#+118784
   \   000000F8   960F80E3           ORR      R0,R0,#0x258
   \   000000FC   041080E0           ADD      R1,R0,R4
   \   00000100   0D00A0E1           MOV      R0,SP
   \   00000104   ........           _BLF     ??insert_2,??insert??rA_5
   \   00000108   0400DDE5           LDRB     R0,[SP, #+4]
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   4401D715           LDRBNE   R0,[R7, #+324]
   \   00000114   00005013           CMPNE    R0,#+0
   \   00000118   0200000A           BEQ      ??SetProList_6
   \   0000011C   E41084E2           ADD      R1,R4,#+228
   \   00000120   0700A0E1           MOV      R0,R7
   \   00000124   ........           _BLF     ??AddToExternalAlarms,??AddToExternalAlarms??rA
   \                     ??SetProList_6:
   \   00000128   78108DE2           ADD      R1,SP,#+120
   \   0000012C   0700A0E1           MOV      R0,R7
   \   00000130   ........           _BLF     ??GetModBusSensorList,??GetModBusSensorList??rA
   \   00000134   78709DE5           LDR      R7,[SP, #+120]
   \   00000138   0A0000EA           B        ??SetProList_7
   \                     ??SetProList_8:
   \   0000013C   108097E5           LDR      R8,[R7, #+16]
   \   00000140   5E1F84E2           ADD      R1,R4,#+376
   \   00000144   0820A0E1           MOV      R2,R8
   \   00000148   0D00A0E1           MOV      R0,SP
   \   0000014C   ........           _BLF     ??insert_6,??insert??rA_6
   \   00000150   FC1084E2           ADD      R1,R4,#+252
   \   00000154   0800A0E1           MOV      R0,R8
   \   00000158   ........           _BLF     ??AddAlarms,??AddAlarms??rA
   \   0000015C   0700A0E1           MOV      R0,R7
   \   00000160   ........           _BLF     ??_IncP,??_IncP??rA
   \   00000164   0070A0E1           MOV      R7,R0
   \                     ??SetProList_7:
   \   00000168   78008DE2           ADD      R0,SP,#+120
   \   0000016C   000057E1           CMP      R7,R0
   \   00000170   F1FFFF1A           BNE      ??SetProList_8
   \   00000174   ........           _BLF     `?~set_1`,`?~set??rA_1`
   \   00000178   CEFFFFEA           B        ??SetProList_4
   \                     ??SetProList_3:
   \   0000017C   ........           DC32     `?<Constant "0x%0x">`
    990          
    991          
    992          //---------------------------------------------------------------------------

   \                                 In segment CODE, align 4, keep-with-next
    993          void ModbusUnit::SetGlobalProList(void) {
   \                     ??SetGlobalProList:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    994              if ( !ObjectSet.empty() ) {
   \   00000004   ........           LDR      R4,??DataTable8  ;; ??DeviceMap
   \   00000008   280094E5           LDR      R0,[R4, #+40]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0900000A           BEQ      ??SetGlobalProList_1
    995                  set<PRogramObjectBase *>::iterator pBIt;
    996                  for ( pBIt = ObjectSet.begin(); pBIt != ObjectSet.end(); pBIt++ ) {
   \   00000014   185094E5           LDR      R5,[R4, #+24]
   \   00000018   040000EA           B        ??SetGlobalProList_2
    997                      ModbusUnit *tmpPtr = (ModbusUnit *)*pBIt;
    998                      tmpPtr->SetProList();
   \                     ??SetGlobalProList_3:
   \   0000001C   100095E5           LDR      R0,[R5, #+16]
   \   00000020   ........           BL       ??SetProList
    999                  }
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     ??_IncP,??_IncP??rA
   \   0000002C   0050A0E1           MOV      R5,R0
   \                     ??SetGlobalProList_2:
   \   00000030   180084E2           ADD      R0,R4,#+24
   \   00000034   000055E1           CMP      R5,R0
   \   00000038   F7FFFF1A           BNE      ??SetGlobalProList_3
   1000              }
   1001          }
   \                     ??SetGlobalProList_1:
   \   0000003C   ........           B        ?Subroutine52
   1002          
   1003          

   \                                 In segment CODE, align 4, keep-with-next
   1004          void ModbusUnit::SetToMaster(void) {
   \                     ??SetToMaster:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   1005              set<PRogramObjectBase *>::iterator MBUnitIt;
   1006              for ( MBUnitIt = ObjectSet.begin(); MBUnitIt != ObjectSet.end(); MBUnitIt++ ) {
   \   00000004   ........           LDR      R4,??DataTable8  ;; ??DeviceMap
   \   00000008   185094E5           LDR      R5,[R4, #+24]
   \   0000000C   040000EA           B        ??SetToMaster_1
   1007                  ModbusUnit *MBUnitPtr = (ModbusUnit *)*MBUnitIt;
   1008                  MBUnitPtr->SetIsMaster();
   \                     ??SetToMaster_2:
   \   00000010   100095E5           LDR      R0,[R5, #+16]
   \   00000014   ........           BL       ??SetIsMaster
   1009              }
   \   00000018   0500A0E1           MOV      R0,R5
   \   0000001C   ........           _BLF     ??_IncP,??_IncP??rA
   \   00000020   0050A0E1           MOV      R5,R0
   \                     ??SetToMaster_1:
   \   00000024   180084E2           ADD      R0,R4,#+24
   \   00000028   000055E1           CMP      R5,R0
   \   0000002C   F7FFFF1A           BNE      ??SetToMaster_2
   1010          }
   \   00000030   ........           B        ?Subroutine52
   1011          

   \                                 In segment CODE, align 4, keep-with-next
   1012          int ModbusUnit::ReceiveData(U8 *data) {
   \                     ??ReceiveData:
   \   00000000   00402DE9           PUSH     {LR}
   1013              int ErrorStatus = E_OK;
   1014              ANPRO10_CommandHeading *pCH = (ANPRO10_CommandHeading *)data;
   1015              switch ( pCH->CommandNo ) {
   \   00000004   0120D1E5           LDRB     R2,[R1, #+1]
   \   00000008   0030D1E5           LDRB     R3,[R1, #+0]
   \   0000000C   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000010   650052E3           CMP      R2,#+101
   \   00000014   1200001A           BNE      ??ReceiveData_1
   \   00000018   0930D1E5           LDRB     R3,[R1, #+9]
   \   0000001C   08C0D1E5           LDRB     R12,[R1, #+8]
   \   00000020   742BA0E3           MOV      R2,#+118784
   \   00000024   942F82E3           ORR      R2,R2,#0x250
   \   00000028   002082E0           ADD      R2,R2,R0
   \   0000002C   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   00000030   003082E5           STR      R3,[R2, #+0]
   1016              case CMD_GENERIC_REALTIME_DATA:
   1017                  {
   1018                      ANPRO10_COMMAND_2750 *pData = (ANPRO10_COMMAND_2750 *)data;
   1019                      ComFailCount        = pData->ComFailCount;
   1020                      ComTotalFailCount   = pData->ComTotalFailCount;
   \   00000034   0B30D1E5           LDRB     R3,[R1, #+11]
   \   00000038   0AC0D1E5           LDRB     R12,[R1, #+10]
   1021                      memcpy(DigitalIn, pData->DigitalIn, MODBUS_MAX_COILS / 8);
   \   0000003C   0C1081E2           ADD      R1,R1,#+12
   \   00000040   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   00000044   043082E5           STR      R3,[R2, #+4]
   \   00000048   802EA0E3           MOV      R2,#+2048
   \   0000004C   723BA0E3           MOV      R3,#+116736
   \   00000050   8B3F83E3           ORR      R3,R3,#0x22C
   \   00000054   000083E0           ADD      R0,R3,R0
   \   00000058   ........           _BLF     memcpy,??memcpy??rA
   1022                      ErrorStatus         = E_OK;
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   000000EA           B        ??ReceiveData_2
   1023                  }
   1024                  break;
   1025              case CMD_GENERIC_STATIC_DATA:
   1026              default:
   1027                  ErrorStatus = E_UNKNOWN_COMMAND;
   \                     ??ReceiveData_1:
   \   00000064   0100A0E3           MOV      R0,#+1
   1028                  break;
   1029              }
   1030              return (ErrorStatus);
   \                     ??ReceiveData_2:
   \   00000068   ........           B        ?Subroutine59
   1031          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine59:
   \   00000000   0040BDE8           POP      {LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
   1032          

   \                                 In segment CODE, align 4, keep-with-next
   1033          int ModbusUnit::SendData(U16 cmd) {
   \                     ??SendData:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   80DE4DE2           SUB      SP,SP,#+2048
   1034              int ErrorStatus = E_OK;
   1035              switch ( cmd ) {
   \   0000000C   650051E3           CMP      R1,#+101
   \   00000010   2500001A           BNE      ??SendData_1
   1036              case CMD_GENERIC_REALTIME_DATA:
   1037                  {
   1038                      QueueANPRO10_COMMAND_2750 Cmd;
   1039                      Cmd.TxInfo.Port         = NULL;
   \   00000014   0020A0E3           MOV      R2,#+0
   \   00000018   00208DE5           STR      R2,[SP, #+0]
   1040                      Cmd.TxInfo.rxAddr       = DEVICE_BROADCAST_ADDR;
   \   0000001C   FF20A0E3           MOV      R2,#+255
   \   00000020   0420CDE5           STRB     R2,[SP, #+4]
   1041                      Cmd.TxInfo.rxId         = DEVICE_BROADCAST_TXU;
   \   00000024   0E20A0E3           MOV      R2,#+14
   \   00000028   0520CDE5           STRB     R2,[SP, #+5]
   1042                      Cmd.Data.ObjectId       = IDNumber;
   \   0000002C   9C1090E5           LDR      R1,[R0, #+156]
   1043                      Cmd.Data.ndb            = sizeof(Cmd) - sizeof(QueueANPRO10_CommandHeading);
   \   00000030   0820A0E3           MOV      R2,#+8
   \   00000034   0A10CDE5           STRB     R1,[SP, #+10]
   \   00000038   2114A0E1           LSR      R1,R1,#+8
   \   0000003C   0B10CDE5           STRB     R1,[SP, #+11]
   \   00000040   2114A0E1           LSR      R1,R1,#+8
   \   00000044   0C10CDE5           STRB     R1,[SP, #+12]
   \   00000048   2114A0E1           LSR      R1,R1,#+8
   \   0000004C   0D10CDE5           STRB     R1,[SP, #+13]
   \   00000050   802E82E3           ORR      R2,R2,#0x800
   \   00000054   B820CDE1           STRH     R2,[SP, #+8]
   1044                      Cmd.Data.CommandNo      = CMD_GENERIC_REALTIME_DATA;
   \   00000058   6520A0E3           MOV      R2,#+101
   \   0000005C   B620CDE1           STRH     R2,[SP, #+6]
   \   00000060   741BA0E3           MOV      R1,#+118784
   \   00000064   941F81E3           ORR      R1,R1,#0x250
   \   00000068   001081E0           ADD      R1,R1,R0
   \   0000006C   003091E5           LDR      R3,[R1, #+0]
   1045                      Cmd.Data.ComFailCount   = ComFailCount;
   1046                      Cmd.Data.ComTotalFailCount = ComTotalFailCount;
   1047                      memcpy(Cmd.Data.DigitalIn, DigitalIn, MODBUS_MAX_COILS / 8);
   \   00000070   802EA0E3           MOV      R2,#+2048
   \   00000074   BE30CDE1           STRH     R3,[SP, #+14]
   \   00000078   041091E5           LDR      R1,[R1, #+4]
   \   0000007C   B011CDE1           STRH     R1,[SP, #+16]
   \   00000080   721BA0E3           MOV      R1,#+116736
   \   00000084   8B1F81E3           ORR      R1,R1,#0x22C
   \   00000088   001081E0           ADD      R1,R1,R0
   \   0000008C   12008DE2           ADD      R0,SP,#+18
   \   00000090   ........           _BLF     memcpy,??memcpy??rA
   1048                      bool sent = ANPRO10SendNormal(&Cmd);
   1049                      if ( !sent ) ErrorStatus = E_QUEUE_FULL;
   \   00000094   0D00A0E1           MOV      R0,SP
   \   00000098   ........           _BLF     ??ANPRO10SendNormal,??ANPRO10SendNormal??rA
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   0000A013           MOVNE    R0,#+0
   \   000000A4   0300A003           MOVEQ    R0,#+3
   \   000000A8   000000EA           B        ??SendData_2
   1050                      else ErrorStatus = E_OK;
   1051                  }
   1052                  break;
   1053              case CMD_GENERIC_STATIC_DATA:
   1054              default:
   1055                  ErrorStatus = E_UNKNOWN_COMMAND;
   \                     ??SendData_1:
   \   000000AC   0100A0E3           MOV      R0,#+1
   1056                  break;
   1057              }
   1058              return (ErrorStatus);
   \                     ??SendData_2:
   \   000000B0   14D08DE2           ADD      SP,SP,#+20
   \   000000B4   80DE8DE2           ADD      SP,SP,#+2048
   \   000000B8                      REQUIRE ?Subroutine59
   \   000000B8                      ;; // Fall through to label ?Subroutine59
   1059          }
   1060          
   1061          //---------------------------------------------------------------------------
   1062          // Only one thread will call this

   \                                 In segment CODE, align 4, keep-with-next
   1063          int ModbusUnit::GetActiveAlarms(void) {
   \                     ??GetActiveAlarms:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   1064              int ActAl       = 0;
   1065              set<AlarmBasic *>::iterator pBIt;
   1066              for ( pBIt = AlarmSet.begin(); pBIt != AlarmSet.end(); pBIt++ ) {
   \   00000008   E40094E5           LDR      R0,[R4, #+228]
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   050000EA           B        ??GetActiveAlarms_1
   1067                  AlarmBasic *Element = *pBIt;
   1068                  switch ( Element->State ) {
   \                     ??GetActiveAlarms_2:
   \   00000014   101090E5           LDR      R1,[R0, #+16]
   \   00000018   E010D1E5           LDRB     R1,[R1, #+224]
   \   0000001C   011041E2           SUB      R1,R1,#+1
   \   00000020   010051E3           CMP      R1,#+1
   1069                  case AlarmBasic::AlActive     :
   1070                  case AlarmBasic::AlAknowledged:
   1071                      ActAl++;
   \   00000024   01508592           ADDLS    R5,R5,#+1
   1072                      break;
   1073                  case AlarmBasic::AlIdle       :
   1074                  case AlarmBasic::AlBlocked  :
   1075                      break;
   1076                  }
   1077              }
   \   00000028   ........           _BLF     ??_IncP,??_IncP??rA
   \                     ??GetActiveAlarms_1:
   \   0000002C   E41084E2           ADD      R1,R4,#+228
   \   00000030   010050E1           CMP      R0,R1
   \   00000034   F6FFFF1A           BNE      ??GetActiveAlarms_2
   1078              return (ActAl);
   \   00000038   0500A0E1           MOV      R0,R5
   \   0000003C   ........           B        ?Subroutine52
   1079          }
   1080          

   \                                 In segment CODE, align 4, keep-with-next
   1081          void ModbusUnit::SetUpCom(TSNUart *Port, int RequestDelay, int TimeOut, int FrameSpaceTime, int FrameTimeOut) {
   \                     ??SetUpCom:
   \   00000000   10002DE9           PUSH     {R4}
   \   00000004   04C09DE5           LDR      R12,[SP, #+4]
   \   00000008   08409DE5           LDR      R4,[SP, #+8]
   1082              myPort              = Port;
   \   0000000C   9C1180E5           STR      R1,[R0, #+412]
   1083              myRequestDelay      = RequestDelay;
   \   00000010   A42180E5           STR      R2,[R0, #+420]
   1084              myTimeOut           = TimeOut;
   \   00000014   A83180E5           STR      R3,[R0, #+424]
   1085              myFrameSpaceTime    = FrameSpaceTime;
   \   00000018   ACC180E5           STR      R12,[R0, #+428]
   1086              myFrameTimeOut      = FrameTimeOut;
   \   0000001C   B04180E5           STR      R4,[R0, #+432]
   1087              AddressSystem       = Port->Device;
   \   00000020   A81091E5           LDR      R1,[R1, #+168]
   \   00000024   A01180E5           STR      R1,[R0, #+416]
   1088          }
   \   00000028   1000BDE8           POP      {R4}
   \   0000002C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment DIFUNCT, align 4, keep-with-next, root
   \   00000000                      REQUIRE ?call_ctors
   \   00000000   ........           DC32    ??__sti__routine

   \                                 In segment DATA_C, align 4, align-sorted
   \   __vtbl_entry const __data ModbusUnit::__vtbl[3]
   \                     ??__vtbl:
   \   00000000   ............       DC32 `?~ModbusUnit`, ??ReceiveData, ??SendData
   \              ............
   \   __vtbl_entry const __data ModbusUnit::__vtbl_PRogramObject[31]
   \                     ??__vtbl_PRogramObject:
   \   0000000C   ............       DC32 `?~ModbusUnit`, ??WriteConfigToFile, ??LoadConfigFromFile
   \              ............
   \   00000018   ............       DC32 ??MakeConfigString, ??LoadConfigString, ??RestoreSettings
   \              ............
   \   00000024   ............       DC32 ??GetName, ??FindPROStatus, ??GetFloatValue, ??GetValue
   \              ............
   \              ........    
   \   00000034   ............       DC32 ??GetStringValue, ??GetBitValue, ??PutValue, ??PutFloatValue
   \              ............
   \              ........    
   \   00000044   ............       DC32 ??PutBitValue, ??ReceiveData, ??SendData, ??StartTimer
   \              ............
   \              ........    
   \   00000054   ............       DC32 ??InputTimeout, ??GetValueInfoTable, ??GetServiceValueInfoTable
   \              ............
   \   00000060   ............       DC32 ??SetModifiedFlag, ??IsAvailableNewData, ??SortAnalogInputs
   \              ............
   \   0000006C   ............       DC32 ??SaveSettings, ??Calculate, ??CreateAlarms, ??WriteXML
   \              ............
   \              ........    
   \   0000007C   ............       DC32 ??LCWriteXML, ??RefreshData, ??IsStaticValue
   \              ............
   \   00000088   4D6F64627573       DC8 "ModbusUnit"
   \              556E697400  
   \   00000093   00                 DC8 0

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   3A00               DC8 ":"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   000000000000       DC32 0, 0, 0
   \              000000000000

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "0x%0x">`:
   \   00000000   307825307800       DC8 "0x%0x"
   \   00000006   0000               DC8 0, 0
   \   00000008   50726F677261       DC8 "Program object not found for "
   \              6D206F626A65
   \              6374206E6F74
   \              20666F756E64
   \              20666F722000
   \   00000026   0000               DC8 0, 0

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs ModbusUnit &ModbusUnit::new ModbusUnit(int, int)
   \                     `??new ModbusUnit`:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   740BA0E3           MOV      R0,#+118784
   \   00000010   A20F80E3           ORR      R0,R0,#0x288
   \   00000014   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0200000A           BEQ      `??new ModbusUnit_1`
   \   00000020   0520A0E1           MOV      R2,R5
   \   00000024   0410A0E1           MOV      R1,R4
   \   00000028   ........           BL       ??ModbusUnit
   \                     `??new ModbusUnit_1`:
   \   0000002C   ........           B        ?Subroutine52

   \                                 In segment CODE, align 4, keep-with-next
   \   static __??Code32?? __intrinsic __code __interwork __atpcs void __sti__routine()
   \                     ??__sti__routine:
   \   00000000   31402DE9           PUSH     {R0,R4,R5,LR}
   \   00000004   ........           LDR      R4,??DataTable0  ;; ??DeviceMap
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   48509FE5           LDR      R5,??__sti__routine_1  ;; ?_0
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000020   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000024   1400C4E5           STRB     R0,[R4, #+20]
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           _BLF     __record_needed_destruction,??__record_needed_destruction??rA
   \   00000030   0110A0E3           MOV      R1,#+1
   \   00000034   0D00A0E1           MOV      R0,SP
   \   00000038   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   0000003C   180084E2           ADD      R0,R4,#+24
   \   00000040   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000044   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000048   2C00C4E5           STRB     R0,[R4, #+44]
   \   0000004C   0C0085E2           ADD      R0,R5,#+12
   \   00000050   ........           _BLF     __record_needed_destruction,??__record_needed_destruction??rA
   \   00000054   3140BDE8           POP      {R0,R4,R5,LR}
   \   00000058   1EFF2FE1           BX       LR               ;; return
   \                     ??__sti__routine_1:
   \   0000005C   ........           DC32     ?_0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     ??DeviceMap

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     ??DeviceMap

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     ??__vtbl

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     ??DeviceMap

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     ??DeviceMap
   1089          
   1090          

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     ModbusUnit::DeleteAllInDeviceMap()
                                       12
     ModbusUnit::FindDevice(unsigned char, unsigned short, unsigned char)
                                       12
     ModbusUnit::FlagNewDigitalValues(int, int)
                                       20
     ModbusUnit::FlagNewValues(int, int)
                                        8
     ModbusUnit::GetActiveAlarms()     12
     ModbusUnit::GetCoilIn(int)        16
     ModbusUnit::GetCoilOut(int)       16
     ModbusUnit::GetCoils(unsigned char *, int, int, unsigned char *)
                                       32
     ModbusUnit::GetFailCount()         0
     ModbusUnit::GetOutputRegister(int, bool)
                                        0
     ModbusUnit::GetRegister(int, bool)
                                        0
     ModbusUnit::GetRegisterDirect(int, bool)
                                       44
     ModbusUnit::GetTotalFailCount()
                                        0
     ModbusUnit::HandleIO()           824
     ModbusUnit::HandleRequest(unsigned char *)
                                      560
     ModbusUnit::HasNewDigitalValue(int)
                                       16
     ModbusUnit::HasNewValue(int)       8
     ModbusUnit::HasReadDigitalValue(int)
                                       16
     ModbusUnit::HasReadValue(int)      0
     ModbusUnit::InitInCoil(int, unsigned short)
                                       28
     ModbusUnit::InsertInMap(unsigned char, unsigned short, unsigned char, int, int, unsigned int, bool)
                                       56
     ModbusUnit::IsNewDigitalInput(int, bool)
                                        0
     ModbusUnit::ModbusUnit(int, int)
                                      212
     ModbusUnit::MoveRegisters(int, int, int)
                                        8
     ModbusUnit::ReceiveData(unsigned char *)
                                        4
     ModbusUnit::SendData(unsigned short)
                                     2072
     ModbusUnit::SetAddressRanges(set<unsigned int>, vector<ModbusUnit::AddressRange> &, int)
                                       40
     ModbusUnit::SetAlarmList()         0
     ModbusUnit::SetCoil(int, bool)    32
     ModbusUnit::SetCoilDirect(int, bool)
                                       44
     ModbusUnit::SetCoilHistory(int, bool, int)
                                       36
     ModbusUnit::SetCoils(int, int, unsigned char *)
                                       36
     ModbusUnit::SetGlobalProList()    12
     ModbusUnit::SetHWFailure(bool)    16
     ModbusUnit::SetHoldingRegister(int, unsigned short, bool)
                                        0
     ModbusUnit::SetInCoil(int, unsigned short)
                                       28
     ModbusUnit::SetIsMaster()        104
     ModbusUnit::SetPreviousState(int, bool)
                                        0
     ModbusUnit::SetProList()         196
     ModbusUnit::SetRegister(int, unsigned short, bool)
                                        0
     ModbusUnit::SetRegisterDirect(int, unsigned short)
                                       36
     ModbusUnit::SetRegisterString(int, AnsiString, int)
                                       16
     ModbusUnit::SetToMaster()         12
     ModbusUnit::SetUpCom(TSNUart *, int, int, int, int)
                                        4
     ModbusUnit::SlaveGetRegisters(unsigned short *, int, int, unsigned char *)
                                        4
     ModbusUnit::SlaveSetRegisters(unsigned short *, int, int, unsigned char *)
                                       24
     ModbusUnit::new ModbusUnit(int, int)
                                       12
     ModbusUnit::~ModbusUnit()         16
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Erase(_Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Nodeptr)
                                       16
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Insert(bool, _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Nodeptr, pair<unsigned int const, ModbusUnit *> const &)
                                       24
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Lbound(unsigned int) const
                                        0
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::clear()
                                        8
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::find(unsigned int)
                                       12
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::insert(pair<unsigned int const, ModbusUnit *> const &)
                                       40
     _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::_Insert(bool, _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::_Nodeptr, AlarmBasic *)
                                       24
     _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::insert(AlarmBasic *)
                                       44
     _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Erase(_Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Nodeptr)
                                       16
     _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Insert(bool, _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Nodeptr, AnalogInput *)
                                       24
     _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::insert(AnalogInput *)
                                       44
     _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Nodeptr)
                                       16
     _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Insert(bool, _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Nodeptr, PRogramObject *)
                                       24
     _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::insert(PRogramObject *)
                                       44
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr)
                                       16
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Insert(bool, _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr, PRogramObjectBase *)
                                       24
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::insert(PRogramObjectBase *)
                                       44
     _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Erase(_Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Nodeptr)
                                       16
     _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Insert(bool, _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Nodeptr, int)
                                       24
     _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::insert(int)
                                       40
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Copy(_Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>> const &)
                                       12
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Copy(_Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr, _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr)
                                       32
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Erase(_Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr)
                                       16
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Insert(bool, _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr, unsigned int)
                                       24
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::insert(unsigned int)
                                       40
     _Tree_algobase<allocator<void>>::_Clear()
                                        0
     _Tree_algobase<allocator<void>>::_DecP(_Tree_algobase<allocator<void>>::_Genptr)
                                        0
     _Tree_algobase<allocator<void>>::_IncP(_Tree_algobase<allocator<void>>::_Genptr)
                                        0
     _Tree_algobase<allocator<void>>::_Insert(bool, _Tree_algobase<allocator<void>>::_Genptr, _Tree_algobase<allocator<void>>::_Genptr)
                                       20
     _Tree_algobase<allocator<void>>::_Lrotate(_Tree_algobase<allocator<void>>::_Genptr)
                                        0
     _Tree_algobase<allocator<void>>::_Rrotate(_Tree_algobase<allocator<void>>::_Genptr)
                                        0
     _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Insert0(ModbusUnit::AddressRange *, ModbusUnit::AddressRange const &)
                                       28
     _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Make_room(ModbusUnit::AddressRange *, unsigned int)
                                       32
     _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Push_back0(ModbusUnit::AddressRange const &)
                                       24
     _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Tidy0()
                                        4
     __sti__routine()                  16
     map<unsigned int, ModbusUnit *>::~map()
                                        4
     operator+(char const *, string const &)
                                       44
     operator+(string const &, char const *)
                                       44
     operator+(string const &, string const &)
                                       40
     set<AnalogInput *>::~set()         8
     set<PRogramObjectBase *>::~set()
                                        8
     set<unsigned int>::set()          12
     set<unsigned int>::set(set<unsigned int> const &)
                                       16
     set<unsigned int>::~set()          8
     string::string(string const &)    12
     vector<ModbusUnit::AddressRange>::vector()
                                        0
     vector<ModbusUnit::AddressRange>::~vector()
                                        8


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     string::string(string const &)   64
     _Tree_algobase<allocator<void>>::_DecP(_Tree_algobase<allocator<void>>::_Genptr)
                                     100
     _Tree_algobase<allocator<void>>::_IncP(_Tree_algobase<allocator<void>>::_Genptr)
                                      92
     _Tree_algobase<allocator<void>>::_Clear()
                                      36
     _Tree_algobase<allocator<void>>::_Rrotate(_Tree_algobase<allocator<void>>::_Genptr)
                                      84
     _Tree_algobase<allocator<void>>::_Lrotate(_Tree_algobase<allocator<void>>::_Genptr)
                                      84
     _Tree_algobase<allocator<void>>::_Insert(bool, _Tree_algobase<allocator<void>>::_Genptr, _Tree_algobase<allocator<void>>::_Genptr)
                                     356
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::insert(PRogramObjectBase *)
                                     200
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::insert(unsigned int)
                                     200
     _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::insert(PRogramObject *)
                                     200
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::insert(pair<unsigned int const, ModbusUnit *> const &)
                                     208
     _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::insert(int)
                                     200
     _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::insert(AlarmBasic *)
                                     200
     _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::insert(AnalogInput *)
                                     200
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::clear()
                                      32
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::find(unsigned int)
                                      48
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Copy(_Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>> const &)
                                     136
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Copy(_Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr, _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr)
                                     148
     _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Erase(_Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Nodeptr)
                                      68
     _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Erase(_Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Nodeptr)
                                      68
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Erase(_Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Nodeptr)
                                      68
     _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Nodeptr)
                                      68
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr)
                                      68
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Erase(_Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr)
                                      68
     _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Insert(bool, _Tree<_Tset_traits<unsigned int, less<unsigned int>, allocator<unsigned int>, false>>::_Nodeptr, unsigned int)
                                      96
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Insert(bool, _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Nodeptr, pair<unsigned int const, ModbusUnit *> const &)
                                     112
     _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::_Insert(bool, _Tree<_Tset_traits<AlarmBasic *, less<AlarmBasic *>, allocator<AlarmBasic *>, false>>::_Nodeptr, AlarmBasic *)
                                      96
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Insert(bool, _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr, PRogramObjectBase *)
                                      96
     _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Insert(bool, _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Nodeptr, PRogramObject *)
                                      96
     _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Insert(bool, _Tree<_Tset_traits<AnalogInput *, less<AnalogInput *>, allocator<AnalogInput *>, false>>::_Nodeptr, AnalogInput *)
                                      96
     _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Insert(bool, _Tree<_Tset_traits<int, less<int>, allocator<int>, false>>::_Nodeptr, int)
                                      96
     _Tree<_Tmap_traits<unsigned int, ModbusUnit *, less<unsigned int>, allocator<pair<unsigned int const, ModbusUnit *>>, false>>::_Lbound(unsigned int) const
                                      40
     set<PRogramObjectBase *>::~set()
                                      32
     set<AnalogInput *>::~set()       32
     set<unsigned int>::set(set<unsigned int> const &)
                                      48
     set<unsigned int>::~set()        32
     set<unsigned int>::set()         48
     map<unsigned int, ModbusUnit *>::~map()
                                      16
     _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Tidy0()
                                      36
     _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Make_room(ModbusUnit::AddressRange *, unsigned int)
                                     260
     _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Insert0(ModbusUnit::AddressRange *, ModbusUnit::AddressRange const &)
                                     100
     _Vector_impl<ModbusUnit::AddressRange, allocator<ModbusUnit::AddressRange>>::_Push_back0(ModbusUnit::AddressRange const &)
                                      88
     vector<ModbusUnit::AddressRange>::vector()
                                      20
     vector<ModbusUnit::AddressRange>::~vector()
                                      36
     operator+(string const &, string const &)
                                      88
     operator+(char const *, string const &)
                                     128
     operator+(string const &, char const *)
                                      92
     ?_0                              24
     ModbusUnit::DeviceMap            48
     ModbusUnit::ModbusUnit(int, int)
                                     824
     ?Subroutine53                     8
     ModbusUnit::~ModbusUnit()       248
     ?Subroutine49                    52
     ModbusUnit::GetOutputRegister(int, bool)
                                      40
     ?Subroutine50                    12
     ModbusUnit::GetRegister(int, bool)
                                      40
     ModbusUnit::GetRegisterDirect(int, bool)
                                     172
     ModbusUnit::SetRegisterDirect(int, unsigned short)
                                     124
     ?Subroutine54                     8
     ModbusUnit::SlaveSetRegisters(unsigned short *, int, int, unsigned char *)
                                      96
     ?Subroutine55                     8
     ModbusUnit::SetRegister(int, unsigned short, bool)
                                      44
     ModbusUnit::SetRegisterString(int, AnsiString, int)
                                     100
     ModbusUnit::SetHoldingRegister(int, unsigned short, bool)
                                      44
     ModbusUnit::MoveRegisters(int, int, int)
                                      48
     ?Subroutine56                     8
     ModbusUnit::HasNewValue(int)     84
     ModbusUnit::FlagNewValues(int, int)
                                      80
     ModbusUnit::HasReadValue(int)    24
     ModbusUnit::HasNewDigitalValue(int)
                                      76
     ModbusUnit::FlagNewDigitalValues(int, int)
                                     120
     ModbusUnit::HasReadDigitalValue(int)
                                      64
     ModbusUnit::SlaveGetRegisters(unsigned short *, int, int, unsigned char *)
                                      56
     ModbusUnit::GetCoilIn(int)       52
     ModbusUnit::GetCoilOut(int)      48
     ModbusUnit::GetCoils(unsigned char *, int, int, unsigned char *)
                                     236
     ModbusUnit::SetCoils(int, int, unsigned char *)
                                     220
     ?Subroutine57                     8
     ModbusUnit::SetInCoil(int, unsigned short)
                                     160
     ?Subroutine51                    12
     ModbusUnit::InitInCoil(int, unsigned short)
                                     156
     ModbusUnit::SetCoil(int, bool)  148
     ModbusUnit::SetCoilDirect(int, bool)
                                     160
     ModbusUnit::SetCoilHistory(int, bool, int)
                                     212
     ModbusUnit::SetPreviousState(int, bool)
                                      20
     ModbusUnit::IsNewDigitalInput(int, bool)
                                      36
     ModbusUnit::HandleRequest(unsigned char *)
                                    1304
     ModbusUnit::HandleIO()          840
     ModbusUnit::FindDevice(unsigned char, unsigned short, unsigned char)
                                      44
     ?Subroutine52                     8
     ModbusUnit::InsertInMap(unsigned char, unsigned short, unsigned char, int, int, unsigned int, bool)
                                     512
     ModbusUnit::DeleteAllInDeviceMap()
                                      92
     ModbusUnit::SetIsMaster()       220
     ModbusUnit::SetAddressRanges(set<unsigned int>, vector<ModbusUnit::AddressRange> &, int)
                                     176
     ModbusUnit::GetFailCount()       12
     ?Subroutine58                     8
     ModbusUnit::GetTotalFailCount()
                                       8
     ModbusUnit::SetHWFailure(bool)   92
     ModbusUnit::SetAlarmList()        4
     ModbusUnit::SetProList()        384
     ModbusUnit::SetGlobalProList()   64
     ModbusUnit::SetToMaster()        52
     ModbusUnit::ReceiveData(unsigned char *)
                                     108
     ?Subroutine59                     8
     ModbusUnit::SendData(unsigned short)
                                     184
     ModbusUnit::GetActiveAlarms()    64
     ModbusUnit::SetUpCom(TSNUart *, int, int, int, int)
                                      48
     ModbusUnit::__vtbl              148
     ?<Constant ":">                   2
     ?<Constant {0, 0, 0}>            12
     ?<Constant "0x%0x">              40
     ModbusUnit::new ModbusUnit(int, int)
                                      48
     __sti__routine()                 96
     ??DataTable0                      4
     ??DataTable2                      4
     ??DataTable3                      4
     ??DataTable6                      4
     ??DataTable8                      4
      Others                        1276

 
 14 276 bytes in segment CODE
    226 bytes in segment DATA_C
     56 bytes in segment DATA_Z
      4 bytes in segment DIFUNCT
     12 bytes in segment INITTAB
 
 8 248 bytes of CODE  memory (+ 6 044 bytes shared)
   226 bytes of CONST memory
    56 bytes of DATA  memory

Errors: none
Warnings: none
