##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:14:25 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\Shared\Src\ModbusRegisterIn.cpp            #
#    Command line    =  D:\S2Prog\Shared\Src\ModbusRegisterIn.cpp --fpu      #
#                       None -D OS_LIBMODE_SP -D CPU_S3C2410 -D              #
#                       OS_RAMVECT=0 -D OS_UART=-1 -D S2TXU -D USE_LZO=1 -D  #
#                       __ARM_LIBRARY__ -D WATCHDOG=1 -D NETWORK=1 -lCN      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -z9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --eec++           #
#                       --dlib_config "C:\Program Files (x86)\IAR            #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl4tpainl8n.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\ModbusRegisterIn.lst        #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\ModbusRegisterIn.r79         #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\Shared\Src\ModbusRegisterIn.cpp
      1          #include "TSNIncludes.h"

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree_algobase<allocator<void>>::_Genptr _Tree_algobase<allocator<void>>::_DecP(_Tree_algobase<allocator<void>>::_Genptr)
   \                     ??_DecP:
   \   00000000   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   08009015           LDRNE    R0,[R0, #+8]
   \   0000000C   1EFF2F11           BXNE     LR
   \   00000010   001090E5           LDR      R1,[R0, #+0]
   \   00000014   0D20D1E5           LDRB     R2,[R1, #+13]
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   0700001A           BNE      ??_DecP_1
   \   00000020   000000EA           B        ??_DecP_2
   \                     ??_DecP_3:
   \   00000024   0010A0E1           MOV      R1,R0
   \                     ??_DecP_2:
   \   00000028   080091E5           LDR      R0,[R1, #+8]
   \   0000002C   0D20D0E5           LDRB     R2,[R0, #+13]
   \   00000030   000052E3           CMP      R2,#+0
   \   00000034   FAFFFF0A           BEQ      ??_DecP_3
   \   00000038   0100A0E1           MOV      R0,R1
   \   0000003C   1EFF2FE1           BX       LR
   \                     ??_DecP_1:
   \   00000040   041090E5           LDR      R1,[R0, #+4]
   \   00000044   0D20D1E5           LDRB     R2,[R1, #+13]
   \   00000048   000052E3           CMP      R2,#+0
   \   0000004C   1EFF2F11           BXNE     LR
   \   00000050   002091E5           LDR      R2,[R1, #+0]
   \   00000054   020050E1           CMP      R0,R2
   \   00000058   0100A0E1           MOV      R0,R1
   \   0000005C   F7FFFF0A           BEQ      ??_DecP_1
   \   00000060   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree_algobase<allocator<void>>::_Clear()
   \                     ??_Clear:
   \   00000000   040080E5           STR      R0,[R0, #+4]
   \   00000004   000080E5           STR      R0,[R0, #+0]
   \   00000008   080080E5           STR      R0,[R0, #+8]
   \   0000000C   0110A0E3           MOV      R1,#+1
   \   00000010   0D10C0E5           STRB     R1,[R0, #+13]
   \   00000014   0C10C0E5           STRB     R1,[R0, #+12]
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   101080E5           STR      R1,[R0, #+16]
   \   00000020   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree_algobase<allocator<void>>::_Rrotate(_Tree_algobase<allocator<void>>::_Genptr)
   \                     ??_Rrotate:
   \   00000000   002091E5           LDR      R2,[R1, #+0]
   \   00000004   083092E5           LDR      R3,[R2, #+8]
   \   00000008   003081E5           STR      R3,[R1, #+0]
   \   0000000C   083092E5           LDR      R3,[R2, #+8]
   \   00000010   0DC0D3E5           LDRB     R12,[R3, #+13]
   \   00000014   00005CE3           CMP      R12,#+0
   \   00000018   04108305           STREQ    R1,[R3, #+4]
   \   0000001C   043091E5           LDR      R3,[R1, #+4]
   \   00000020   043082E5           STR      R3,[R2, #+4]
   \   00000024   043090E5           LDR      R3,[R0, #+4]
   \   00000028   030051E1           CMP      R1,R3
   \   0000002C   04208005           STREQ    R2,[R0, #+4]
   \   00000030   0400000A           BEQ      ??_Rrotate_1
   \   00000034   040091E5           LDR      R0,[R1, #+4]
   \   00000038   083090E5           LDR      R3,[R0, #+8]
   \   0000003C   030051E1           CMP      R1,R3
   \   00000040   08208005           STREQ    R2,[R0, #+8]
   \   00000044   00208015           STRNE    R2,[R0, #+0]
   \                     ??_Rrotate_1:
   \   00000048   081082E5           STR      R1,[R2, #+8]
   \   0000004C   042081E5           STR      R2,[R1, #+4]
   \   00000050   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree_algobase<allocator<void>>::_Lrotate(_Tree_algobase<allocator<void>>::_Genptr)
   \                     ??_Lrotate:
   \   00000000   082091E5           LDR      R2,[R1, #+8]
   \   00000004   003092E5           LDR      R3,[R2, #+0]
   \   00000008   083081E5           STR      R3,[R1, #+8]
   \   0000000C   003092E5           LDR      R3,[R2, #+0]
   \   00000010   0DC0D3E5           LDRB     R12,[R3, #+13]
   \   00000014   00005CE3           CMP      R12,#+0
   \   00000018   04108305           STREQ    R1,[R3, #+4]
   \   0000001C   043091E5           LDR      R3,[R1, #+4]
   \   00000020   043082E5           STR      R3,[R2, #+4]
   \   00000024   043090E5           LDR      R3,[R0, #+4]
   \   00000028   030051E1           CMP      R1,R3
   \   0000002C   04208005           STREQ    R2,[R0, #+4]
   \   00000030   0400000A           BEQ      ??_Lrotate_1
   \   00000034   040091E5           LDR      R0,[R1, #+4]
   \   00000038   003090E5           LDR      R3,[R0, #+0]
   \   0000003C   030051E1           CMP      R1,R3
   \   00000040   00208005           STREQ    R2,[R0, #+0]
   \   00000044   08208015           STRNE    R2,[R0, #+8]
   \                     ??_Lrotate_1:
   \   00000048   001082E5           STR      R1,[R2, #+0]
   \   0000004C   042081E5           STR      R2,[R1, #+4]
   \   00000050   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree_algobase<allocator<void>>::_Insert(bool, _Tree_algobase<allocator<void>>::_Genptr, _Tree_algobase<allocator<void>>::_Genptr)
   \                     ??_Insert:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   100094E5           LDR      R0,[R4, #+16]
   \   0000000C   0350A0E1           MOV      R5,R3
   \   00000010   010080E2           ADD      R0,R0,#+1
   \   00000014   100084E5           STR      R0,[R4, #+16]
   \   00000018   040052E1           CMP      R2,R4
   \   0000001C   0300001A           BNE      ??_Insert_3
   \   00000020   045084E5           STR      R5,[R4, #+4]
   \   00000024   005084E5           STR      R5,[R4, #+0]
   \                     ??_Insert_4:
   \   00000028   085084E5           STR      R5,[R4, #+8]
   \   0000002C   130000EA           B        ??_Insert_5
   \                     ??_Insert_3:
   \   00000030   000051E3           CMP      R1,#+0
   \   00000034   0500000A           BEQ      ??_Insert_6
   \   00000038   005082E5           STR      R5,[R2, #+0]
   \   0000003C   000094E5           LDR      R0,[R4, #+0]
   \   00000040   000052E1           CMP      R2,R0
   \   00000044   0D00001A           BNE      ??_Insert_5
   \   00000048   005084E5           STR      R5,[R4, #+0]
   \   0000004C   0B0000EA           B        ??_Insert_5
   \                     ??_Insert_6:
   \   00000050   085082E5           STR      R5,[R2, #+8]
   \   00000054   080094E5           LDR      R0,[R4, #+8]
   \   00000058   000052E1           CMP      R2,R0
   \   0000005C   0700001A           BNE      ??_Insert_5
   \   00000060   F0FFFFEA           B        ??_Insert_4
   \                     ??_Insert_7:
   \   00000064   0C70C0E5           STRB     R7,[R0, #+12]
   \   00000068   0C70C2E5           STRB     R7,[R2, #+12]
   \   0000006C   040095E5           LDR      R0,[R5, #+4]
   \   00000070   040090E5           LDR      R0,[R0, #+4]
   \   00000074   0C60C0E5           STRB     R6,[R0, #+12]
   \   00000078   040095E5           LDR      R0,[R5, #+4]
   \   0000007C   045090E5           LDR      R5,[R0, #+4]
   \                     ??_Insert_5:
   \   00000080   0170A0E3           MOV      R7,#+1
   \   00000084   040095E5           LDR      R0,[R5, #+4]
   \   00000088   0C10D0E5           LDRB     R1,[R0, #+12]
   \   0000008C   000051E3           CMP      R1,#+0
   \   00000090   2F00001A           BNE      ??_Insert_8
   \   00000094   041090E5           LDR      R1,[R0, #+4]
   \   00000098   0060A0E3           MOV      R6,#+0
   \   0000009C   001091E5           LDR      R1,[R1, #+0]
   \   000000A0   010050E1           CMP      R0,R1
   \   000000A4   041090E5           LDR      R1,[R0, #+4]
   \   000000A8   1400001A           BNE      ??_Insert_9
   \   000000AC   082091E5           LDR      R2,[R1, #+8]
   \   000000B0   0C10D2E5           LDRB     R1,[R2, #+12]
   \   000000B4   000051E3           CMP      R1,#+0
   \   000000B8   E9FFFF0A           BEQ      ??_Insert_7
   \   000000BC   081090E5           LDR      R1,[R0, #+8]
   \   000000C0   010055E1           CMP      R5,R1
   \   000000C4   0300001A           BNE      ??_Insert_10
   \   000000C8   0050A0E1           MOV      R5,R0
   \   000000CC   0510A0E1           MOV      R1,R5
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           _BLF     ??_Lrotate,??_Lrotate??rA
   \                     ??_Insert_10:
   \   000000D8   040095E5           LDR      R0,[R5, #+4]
   \   000000DC   0C70C0E5           STRB     R7,[R0, #+12]
   \   000000E0   040095E5           LDR      R0,[R5, #+4]
   \   000000E4   040090E5           LDR      R0,[R0, #+4]
   \   000000E8   0C60C0E5           STRB     R6,[R0, #+12]
   \   000000EC   040095E5           LDR      R0,[R5, #+4]
   \   000000F0   041090E5           LDR      R1,[R0, #+4]
   \   000000F4   0400A0E1           MOV      R0,R4
   \   000000F8   ........           _BLF     ??_Rrotate,??_Rrotate??rA
   \   000000FC   DFFFFFEA           B        ??_Insert_5
   \                     ??_Insert_9:
   \   00000100   002091E5           LDR      R2,[R1, #+0]
   \   00000104   0C10D2E5           LDRB     R1,[R2, #+12]
   \   00000108   000051E3           CMP      R1,#+0
   \   0000010C   D4FFFF0A           BEQ      ??_Insert_7
   \   00000110   001090E5           LDR      R1,[R0, #+0]
   \   00000114   010055E1           CMP      R5,R1
   \   00000118   0300001A           BNE      ??_Insert_11
   \   0000011C   0050A0E1           MOV      R5,R0
   \   00000120   0510A0E1           MOV      R1,R5
   \   00000124   0400A0E1           MOV      R0,R4
   \   00000128   ........           _BLF     ??_Rrotate,??_Rrotate??rA
   \                     ??_Insert_11:
   \   0000012C   040095E5           LDR      R0,[R5, #+4]
   \   00000130   0C70C0E5           STRB     R7,[R0, #+12]
   \   00000134   040095E5           LDR      R0,[R5, #+4]
   \   00000138   040090E5           LDR      R0,[R0, #+4]
   \   0000013C   0C60C0E5           STRB     R6,[R0, #+12]
   \   00000140   040095E5           LDR      R0,[R5, #+4]
   \   00000144   041090E5           LDR      R1,[R0, #+4]
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           _BLF     ??_Lrotate,??_Lrotate??rA
   \   00000150   CAFFFFEA           B        ??_Insert_5
   \                     ??_Insert_8:
   \   00000154   040094E5           LDR      R0,[R4, #+4]
   \   00000158   0C70C0E5           STRB     R7,[R0, #+12]
   \   0000015C   F040BDE8           POP      {R4-R7,LR}
   \   00000160   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::_Pairib _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::insert(ModbusObject *)
   \                     ??insert:
   \   00000000   F34C2DE9           PUSH     {R0,R1,R4-R7,R10,R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   040095E5           LDR      R0,[R5, #+4]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   05B0A0E1           MOV      R11,R5
   \   00000018   0170A0E3           MOV      R7,#+1
   \                     ??insert_2:
   \   0000001C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0700001A           BNE      ??insert_3
   \   00000028   101090E5           LDR      R1,[R0, #+16]
   \   0000002C   00B0A0E1           MOV      R11,R0
   \   00000030   010056E1           CMP      R6,R1
   \   00000034   00009035           LDRCC    R0,[R0, #+0]
   \   00000038   0170A033           MOVCC    R7,#+1
   \   0000003C   08009025           LDRCS    R0,[R0, #+8]
   \   00000040   0070A023           MOVCS    R7,#+0
   \   00000044   F4FFFFEA           B        ??insert_2
   \                     ??insert_3:
   \   00000048   0B00A0E1           MOV      R0,R11
   \   0000004C   01A0A0E3           MOV      R10,#+1
   \   00000050   000057E3           CMP      R7,#+0
   \   00000054   0B00000A           BEQ      ??insert_4
   \   00000058   001095E5           LDR      R1,[R5, #+0]
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   0700001A           BNE      ??insert_5
   \   00000064   0630A0E1           MOV      R3,R6
   \   00000068   0B20A0E1           MOV      R2,R11
   \   0000006C   0110A0E3           MOV      R1,#+1
   \                     ??insert_6:
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           _BLF     ??_Insert_2,??_Insert??rA
   \   00000078   00008DE5           STR      R0,[SP, #+0]
   \   0000007C   04A0CDE5           STRB     R10,[SP, #+4]
   \   00000080   0A0000EA           B        ??insert_7
   \                     ??insert_5:
   \   00000084   ........           _BLF     ??_DecP,??_DecP??rA
   \                     ??insert_4:
   \   00000088   101090E5           LDR      R1,[R0, #+16]
   \   0000008C   060051E1           CMP      R1,R6
   \   00000090   0300002A           BCS      ??insert_8
   \   00000094   0630A0E1           MOV      R3,R6
   \   00000098   0B20A0E1           MOV      R2,R11
   \   0000009C   0710A0E1           MOV      R1,R7
   \   000000A0   F2FFFFEA           B        ??insert_6
   \                     ??insert_8:
   \   000000A4   00008DE5           STR      R0,[SP, #+0]
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0410CDE5           STRB     R1,[SP, #+4]
   \                     ??insert_7:
   \   000000B0   0D00A0E1           MOV      R0,SP
   \   000000B4   030090E8           LDM      R0,{R0,R1}
   \   000000B8   030084E8           STM      R4,{R0,R1}
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   F64CBDE8           POP      {R1,R2,R4-R7,R10,R11,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Pairib _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::insert(PRogramObjectBase *)
   \                     ??insert_1:
   \   00000000   F34C2DE9           PUSH     {R0,R1,R4-R7,R10,R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   040095E5           LDR      R0,[R5, #+4]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   05B0A0E1           MOV      R11,R5
   \   00000018   0170A0E3           MOV      R7,#+1
   \                     ??insert_9:
   \   0000001C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0700001A           BNE      ??insert_10
   \   00000028   101090E5           LDR      R1,[R0, #+16]
   \   0000002C   00B0A0E1           MOV      R11,R0
   \   00000030   010056E1           CMP      R6,R1
   \   00000034   00009035           LDRCC    R0,[R0, #+0]
   \   00000038   0170A033           MOVCC    R7,#+1
   \   0000003C   08009025           LDRCS    R0,[R0, #+8]
   \   00000040   0070A023           MOVCS    R7,#+0
   \   00000044   F4FFFFEA           B        ??insert_9
   \                     ??insert_10:
   \   00000048   0B00A0E1           MOV      R0,R11
   \   0000004C   01A0A0E3           MOV      R10,#+1
   \   00000050   000057E3           CMP      R7,#+0
   \   00000054   0B00000A           BEQ      ??insert_11
   \   00000058   001095E5           LDR      R1,[R5, #+0]
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   0700001A           BNE      ??insert_12
   \   00000064   0630A0E1           MOV      R3,R6
   \   00000068   0B20A0E1           MOV      R2,R11
   \   0000006C   0110A0E3           MOV      R1,#+1
   \                     ??insert_13:
   \   00000070   0500A0E1           MOV      R0,R5
   \   00000074   ........           _BLF     ??_Insert_1,??_Insert??rA_1
   \   00000078   00008DE5           STR      R0,[SP, #+0]
   \   0000007C   04A0CDE5           STRB     R10,[SP, #+4]
   \   00000080   0A0000EA           B        ??insert_14
   \                     ??insert_12:
   \   00000084   ........           _BLF     ??_DecP,??_DecP??rA
   \                     ??insert_11:
   \   00000088   101090E5           LDR      R1,[R0, #+16]
   \   0000008C   060051E1           CMP      R1,R6
   \   00000090   0300002A           BCS      ??insert_15
   \   00000094   0630A0E1           MOV      R3,R6
   \   00000098   0B20A0E1           MOV      R2,R11
   \   0000009C   0710A0E1           MOV      R1,R7
   \   000000A0   F2FFFFEA           B        ??insert_13
   \                     ??insert_15:
   \   000000A4   00008DE5           STR      R0,[SP, #+0]
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   0410CDE5           STRB     R1,[SP, #+4]
   \                     ??insert_14:
   \   000000B0   0D00A0E1           MOV      R0,SP
   \   000000B4   030090E8           LDM      R0,{R0,R1}
   \   000000B8   030084E8           STM      R4,{R0,R1}
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   F64CBDE8           POP      {R1,R2,R4-R7,R10,R11,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr)
   \                     ??_Erase:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   060000EA           B        ??_Erase_2
   \                     ??_Erase_3:
   \   00000014   081096E5           LDR      R1,[R6, #+8]
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   F7FFFFEB           BL       ??_Erase
   \   00000020   006096E5           LDR      R6,[R6, #+0]
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   0000002C   0650A0E1           MOV      R5,R6
   \                     ??_Erase_2:
   \   00000030   0D00D6E5           LDRB     R0,[R6, #+13]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   F5FFFF0A           BEQ      ??_Erase_3
   \   0000003C   7040BDE8           POP      {R4-R6,LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Nodeptr)
   \                     ??_Erase_1:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   060000EA           B        ??_Erase_4
   \                     ??_Erase_5:
   \   00000014   081096E5           LDR      R1,[R6, #+8]
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   F7FFFFEB           BL       ??_Erase_1
   \   00000020   006096E5           LDR      R6,[R6, #+0]
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   0000002C   0650A0E1           MOV      R5,R6
   \                     ??_Erase_4:
   \   00000030   0D00D6E5           LDRB     R0,[R6, #+13]
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   F5FFFF0A           BEQ      ??_Erase_5
   \   0000003C   7040BDE8           POP      {R4-R6,LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::iterator _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Insert(bool, _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr, PRogramObjectBase *)
   \                     ??_Insert_1:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   1400A0E3           MOV      R0,#+20
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0080B0E1           MOVS     R8,R0
   \   00000020   0600000A           BEQ      ??_Insert_12
   \   00000024   004088E5           STR      R4,[R8, #+0]
   \   00000028   046088E5           STR      R6,[R8, #+4]
   \   0000002C   084088E5           STR      R4,[R8, #+8]
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C00C8E5           STRB     R0,[R8, #+12]
   \   00000038   0D00C8E5           STRB     R0,[R8, #+13]
   \   0000003C   107088E5           STR      R7,[R8, #+16]
   \                     ??_Insert_12:
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           _BLF     ??_Insert,??_Insert??rA_2
   \   00000054   0800A0E1           MOV      R0,R8
   \   00000058   F041BDE8           POP      {R4-R8,LR}
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::iterator _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::_Insert(bool, _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::_Nodeptr, ModbusObject *)
   \                     ??_Insert_2:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
   \   00000014   1400A0E3           MOV      R0,#+20
   \   00000018   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000001C   0080B0E1           MOVS     R8,R0
   \   00000020   0600000A           BEQ      ??_Insert_13
   \   00000024   004088E5           STR      R4,[R8, #+0]
   \   00000028   046088E5           STR      R6,[R8, #+4]
   \   0000002C   084088E5           STR      R4,[R8, #+8]
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   0C00C8E5           STRB     R0,[R8, #+12]
   \   00000038   0D00C8E5           STRB     R0,[R8, #+13]
   \   0000003C   107088E5           STR      R7,[R8, #+16]
   \                     ??_Insert_13:
   \   00000040   0830A0E1           MOV      R3,R8
   \   00000044   0620A0E1           MOV      R2,R6
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           _BLF     ??_Insert,??_Insert??rA_2
   \   00000054   0800A0E1           MOV      R0,R8
   \   00000058   F041BDE8           POP      {R4-R8,LR}
   \   0000005C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs set<PRogramObject *>::~set()
   \                     `?~set`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   041094E5           LDR      R1,[R4, #+4]
   \   0000000C   ........           _BLF     ??_Erase_1,??_Erase??rA
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000018   1040BDE8           POP      {R4,LR}
   \   0000001C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs set<PRogramObjectBase *>::~set()
   \                     `?~set_1`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   041094E5           LDR      R1,[R4, #+4]
   \   0000000C   ........           _BLF     ??_Erase,??_Erase??rA_1
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000018   1040BDE8           POP      {R4,LR}
   \   0000001C   1EFF2FE1           BX       LR               ;; return
      2          #pragma hdrstop
      3          #ifdef BORLAND
      4          #pragma package(smart_init)
      5          #endif
      6          

   \                                 In segment DATA_C, align 4, align-sorted
      7          set<PRogramObject *>ModbusRegisterIn::UniquePROSet;
   \                     ?_0:
   \   00000000   ............       DC32 ?_1, ??UniquePROSet, `?~set`
   \              ............
   \   0000000C   ............       DC32 ?_3, ??ModbusSet, `?~set_1`
   \              ............

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ??UniquePROSet:
   \   00000000                      DS8 24
      8          set<PRogramObjectBase *>ModbusRegisterIn::ModbusSet;
   \                     ??ModbusSet:
   \   00000018                      DS8 24
      9          
     10          

   \                                 In segment CODE, align 4, keep-with-next
     11          ModbusRegisterIn::ModbusRegisterIn(bool pIsCreatedFromMultiple, int ModuleType, bool InsertInSet) {
   \                     ??ModbusRegisterIn:
   \   00000000   F3412DE9           PUSH     {R0,R1,R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
     12          	NotInitiated = true;
     13          
     14          	if (InsertInSet) {
   \   00000010   4C809FE5           LDR      R8,??ModbusRegisterIn_1  ;; ??UniquePROSet
   \   00000014   0370A0E1           MOV      R7,R3
   \   00000018   ........           _BLF     ??ModbusRegister,??ModbusRegister??rA
   \   0000001C   44009FE5           LDR      R0,??ModbusRegisterIn_1+0x4  ;; ??__vtbl
   \   00000020   000057E3           CMP      R7,#+0
   \   00000024   A40084E5           STR      R0,[R4, #+164]
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   AC01C4E5           STRB     R0,[R4, #+428]
   \   00000030   0300000A           BEQ      ??ModbusRegisterIn_2
     15          		ModbusSet.insert(this);
   \   00000034   0420A0E1           MOV      R2,R4
   \   00000038   181088E2           ADD      R1,R8,#+24
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           _BLF     ??insert_1,??insert??rA
     16          	}
     17          	IDNumber    = (ModuleType << 16) + ModbusSet.size();
   \                     ??ModbusRegisterIn_2:
   \   00000044   280098E5           LDR      R0,[R8, #+40]
   \   00000048   060880E0           ADD      R0,R0,R6, LSL #+16
   \   0000004C   9C0084E5           STR      R0,[R4, #+156]
     18          	Type        = ModuleType;
   \   00000050   A06084E5           STR      R6,[R4, #+160]
     19              IsCreatedFromMultiple = pIsCreatedFromMultiple;
   \   00000054   7851C4E5           STRB     R5,[R4, #+376]
     20          }
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   F641BDE8           POP      {R1,R2,R4-R8,LR}
   \   00000060   1EFF2FE1           BX       LR               ;; return
   \                     ??ModbusRegisterIn_1:
   \   00000064   ........           DC32     ??UniquePROSet
   \   00000068   ........           DC32     ??__vtbl
     21          

   \                                 In segment CODE, align 4, keep-with-next
     22          ModbusRegisterIn::~ModbusRegisterIn() {
   \                     `?~ModbusRegisterIn`:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   0500000A           BEQ      `?~ModbusRegisterIn_1`
     23          }
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   ........           _BLF     `?~ModbusRegister`,`?~ModbusRegister??rA`
   \   0000001C   010015E3           TST      R5,#0x1
   \   00000020   0100000A           BEQ      `?~ModbusRegisterIn_1`
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \                     `?~ModbusRegisterIn_1`:
   \   0000002C   ........           B        ?Subroutine15

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine15:
   \   00000000   3040BDE8           POP      {R4,R5,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
     24          
     25          
     26          //---------------------------------------------------------------------------

   \                                 In segment CODE, align 4, keep-with-next
     27          void ModbusRegisterIn::CalculateScale(void) {
   \                     ??CalculateScale:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   A80194E5           LDR      R0,[R4, #+424]
   \   0000000C   ........           _BLF     __longToFloat,??__longToFloat??rA
   \   00000010   806194E5           LDR      R6,[R4, #+384]
   \   00000014   7C1194E5           LDR      R1,[R4, #+380]
   \   00000018   0050A0E1           MOV      R5,R0
   \   0000001C   0600A0E1           MOV      R0,R6
   \   00000020   ........           _BLF     __fSub,??__fSub??rA
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   ........           _BLF     __fDiv,??__fDiv??rA
   \   0000002C   880184E5           STR      R0,[R4, #+392]
     28              Scale = (MaxRange - MinRange) / (RegMax - 0);
     29              Offset = MaxRange - Scale * float(RegMax);
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   ........           _BLF     __fMul,??__fMul??rA
   \   00000038   0010A0E1           MOV      R1,R0
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   ........           _BLF     __fSub,??__fSub??rA
   \   00000044   8C0184E5           STR      R0,[R4, #+396]
     30          }
   \   00000048                      REQUIRE ?Subroutine14
   \   00000048                      ;; // Fall through to label ?Subroutine14

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine14:
   \   00000000   7040BDE8           POP      {R4-R6,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
     31          

   \                                 In segment CODE, align 4, keep-with-next
     32          void ModbusRegisterIn::Update(void) {
   \                     ??Update:
   \   00000000   F3412DE9           PUSH     {R0,R1,R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     33              ModbusUnit *tmpPtr = FindUnit();
   \   00000008   ........           _BLF     ??FindUnit,??FindUnit??rA
   \   0000000C   0070B0E1           MOVS     R7,R0
     34              if (tmpPtr) {
   \   00000010   C000000A           BEQ      ??Update_2
     35          #if defined (ANWIN) || defined (ANTDUSIM)
     36                  if (NotInitiated) {
     37          #elif S2TXU
     38                  if (NotInitiated && OS_Time > 10000) {
   \   00000014   AC01D4E5           LDRB     R0,[R4, #+428]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0E00000A           BEQ      ??Update_3
   \   00000020   F8029FE5           LDR      R0,??Update_4    ;; OS_Time
   \   00000024   1110A0E3           MOV      R1,#+17
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   9C1D81E3           ORR      R1,R1,#0x2700
   \   00000030   010050E1           CMP      R0,R1
   \   00000034   080000BA           BLT      ??Update_3
     39          #endif
     40                      NotInitiated = false;
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   AC01C4E5           STRB     R0,[R4, #+428]
     41                      InitiateHoldingRegisters(tmpPtr);
   \   00000040   A42094E5           LDR      R2,[R4, #+164]
   \   00000044   0710A0E1           MOV      R1,R7
   \   00000048   A82092E5           LDR      R2,[R2, #+168]
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   0FE0A0E1           MOV      LR,PC
   \   00000054   12FF2FE1           BX       R2
   \   00000058   AE0000EA           B        ??Update_2
     42                  } else {
     43                      if (tmpPtr->HasNewValue(Channel)) {
   \                     ??Update_3:
   \   0000005C   5C8FA0E3           MOV      R8,#+368
   \   00000060   041098E7           LDR      R1,[R8, +R4]
   \   00000064   695FA0E3           MOV      R5,#+420
   \   00000068   686FA0E3           MOV      R6,#+416
   \   0000006C   0700A0E1           MOV      R0,R7
   \   00000070   ........           _BLF     ??HasNewValue,??HasNewValue??rA
   \   00000074   000050E3           CMP      R0,#+0
   \   00000078   A100000A           BEQ      ??Update_5
     44                          int   intValue;
     45                          float Value;
     46                          switch (ModbusDataFormat) {
   \   0000007C   9921D4E5           LDRB     R2,[R4, #+409]
   \   00000080   041098E7           LDR      R1,[R8, +R4]
   \   00000084   010081E2           ADD      R0,R1,#+1
   \   00000088   080052E3           CMP      R2,#+8
   \   0000008C   7D00008A           BHI      ??Update_6
   \   00000090   013F8FE2           ADR      R3,??Update_1
   \   00000094   0230D3E7           LDRB     R3,[R3, R2]
   \   00000098   03F18FE0           ADD      PC,PC,R3, LSL #+2
   \                     ??Update_1:
   \   0000009C   4902140D           DC8      +73,+2,+20,+13
   \   000000A0   1C243932           DC8      +28,+36,+57,+50
   \   000000A4   41000000           DC8      +65,+0,+0,+0
     47                          case Float_B_Endian:
     48                              {
     49                                  U16 *ValuePtr = (U16 *)&Value;
     50                                  ValuePtr[0] = tmpPtr->GetRegister(Channel + 1);
   \                     ??Update_7:
   \   000000A8   0020A0E3           MOV      R2,#+0
   \   000000AC   0010A0E1           MOV      R1,R0
   \   000000B0   0700A0E1           MOV      R0,R7
   \   000000B4   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   000000B8   B000CDE1           STRH     R0,[SP, #+0]
     51                                  ValuePtr[1] = tmpPtr->GetRegister(Channel);
   \   000000BC   0020A0E3           MOV      R2,#+0
   \                     ??Update_8:
   \   000000C0   041098E7           LDR      R1,[R8, +R4]
   \                     ??Update_9:
   \   000000C4   0700A0E1           MOV      R0,R7
   \   000000C8   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   000000CC   B200CDE1           STRH     R0,[SP, #+2]
   \   000000D0   6C0000EA           B        ??Update_6
     52                              }
     53                              break;
     54                          case Float_B_Endian_ByteSwap:
     55                              {
     56                                  U16 *ValuePtr = (U16 *)&Value;
     57                                  ValuePtr[0] = tmpPtr->GetRegister(Channel + 1, true);
   \                     ??Update_10:
   \   000000D4   0120A0E3           MOV      R2,#+1
   \   000000D8   0010A0E1           MOV      R1,R0
   \   000000DC   0700A0E1           MOV      R0,R7
   \   000000E0   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   000000E4   B000CDE1           STRH     R0,[SP, #+0]
     58                                  ValuePtr[1] = tmpPtr->GetRegister(Channel, true);
   \   000000E8   0120A0E3           MOV      R2,#+1
   \   000000EC   F3FFFFEA           B        ??Update_8
     59                              }
     60                              break;
     61                          case Float_L_Endian:
     62                              {
     63                                  U16 *ValuePtr = (U16 *)&Value;
     64                                  ValuePtr[0] = tmpPtr->GetRegister(Channel, true);
   \                     ??Update_11:
   \   000000F0   0120A0E3           MOV      R2,#+1
   \   000000F4   0700A0E1           MOV      R0,R7
   \   000000F8   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   000000FC   B000CDE1           STRH     R0,[SP, #+0]
     65                                  ValuePtr[1] = tmpPtr->GetRegister(Channel + 1, true);
   \   00000100   040098E7           LDR      R0,[R8, +R4]
   \   00000104   0120A0E3           MOV      R2,#+1
   \   00000108   011080E2           ADD      R1,R0,#+1
   \   0000010C   ECFFFFEA           B        ??Update_9
     66                              }
     67                              break;
     68                          case Float_L_Endian_ByteSwap:
     69                              {
     70                                  U16 *ValuePtr = (U16 *)&Value;
     71                                  ValuePtr[0] = tmpPtr->GetRegister(Channel);
   \                     ??Update_12:
   \   00000110   0020A0E3           MOV      R2,#+0
   \   00000114   0700A0E1           MOV      R0,R7
   \   00000118   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   0000011C   B000CDE1           STRH     R0,[SP, #+0]
     72                                  ValuePtr[1] = tmpPtr->GetRegister(Channel + 1);
   \   00000120   040098E7           LDR      R0,[R8, +R4]
   \   00000124   0020A0E3           MOV      R2,#+0
   \   00000128   011080E2           ADD      R1,R0,#+1
   \   0000012C   E4FFFFEA           B        ??Update_9
     73                              }
     74                              break;
     75                          case Integer_B_Endian:
     76                              {
     77                                  U16 *ValuePtr = (U16 *)&intValue;
     78                                  ValuePtr[0] = tmpPtr->GetRegister(Channel + 1);
   \                     ??Update_13:
   \   00000130   0020A0E3           MOV      R2,#+0
   \   00000134   0010A0E1           MOV      R1,R0
   \   00000138   0700A0E1           MOV      R0,R7
   \   0000013C   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   00000140   B400CDE1           STRH     R0,[SP, #+4]
     79                                  ValuePtr[1] = tmpPtr->GetRegister(Channel);
   \   00000144   0020A0E3           MOV      R2,#+0
   \                     ??Update_14:
   \   00000148   041098E7           LDR      R1,[R8, +R4]
   \                     ??Update_15:
   \   0000014C   0700A0E1           MOV      R0,R7
   \   00000150   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   00000154   B600CDE1           STRH     R0,[SP, #+6]
     80                                  Value       = intValue;
   \   00000158   04009DE5           LDR      R0,[SP, #+4]
   \   0000015C   ........           _BLF     __longToFloat,??__longToFloat??rA
   \   00000160   00008DE5           STR      R0,[SP, #+0]
   \   00000164   470000EA           B        ??Update_6
     81                              }
     82                              break;
     83                          case Integer_B_Endian_ByteSwap:
     84                              {
     85                                  U16 *ValuePtr = (U16 *)&intValue;
     86                                  ValuePtr[0] = tmpPtr->GetRegister(Channel + 1, true);
   \                     ??Update_16:
   \   00000168   0120A0E3           MOV      R2,#+1
   \   0000016C   0010A0E1           MOV      R1,R0
   \   00000170   0700A0E1           MOV      R0,R7
   \   00000174   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   00000178   B400CDE1           STRH     R0,[SP, #+4]
     87                                  ValuePtr[1] = tmpPtr->GetRegister(Channel, true);
   \   0000017C   0120A0E3           MOV      R2,#+1
   \   00000180   F0FFFFEA           B        ??Update_14
     88                                  Value       = intValue;
     89                              }
     90                              break;
     91                          case Integer_L_Endian:
     92                              {
     93                                  U16 *ValuePtr = (U16 *)&intValue;
     94                                  ValuePtr[0] = tmpPtr->GetRegister(Channel, true);
   \                     ??Update_17:
   \   00000184   0120A0E3           MOV      R2,#+1
   \   00000188   0700A0E1           MOV      R0,R7
   \   0000018C   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   00000190   B400CDE1           STRH     R0,[SP, #+4]
     95                                  ValuePtr[1] = tmpPtr->GetRegister(Channel + 1, true);
   \   00000194   040098E7           LDR      R0,[R8, +R4]
   \   00000198   0120A0E3           MOV      R2,#+1
   \   0000019C   011080E2           ADD      R1,R0,#+1
   \   000001A0   E9FFFFEA           B        ??Update_15
     96                                  Value       = intValue;
     97                              }
     98                              break;
     99                          case Integer_L_Endian_ByteSwap:
    100                              {
    101                                  U16 *ValuePtr = (U16 *)&intValue;
    102                                  ValuePtr[0] = tmpPtr->GetRegister(Channel);
   \                     ??Update_18:
   \   000001A4   0020A0E3           MOV      R2,#+0
   \   000001A8   0700A0E1           MOV      R0,R7
   \   000001AC   ........           _BLF     ??GetRegister,??GetRegister??rA
   \   000001B0   B400CDE1           STRH     R0,[SP, #+4]
    103                                  ValuePtr[1] = tmpPtr->GetRegister(Channel + 1);
   \   000001B4   040098E7           LDR      R0,[R8, +R4]
   \   000001B8   0020A0E3           MOV      R2,#+0
   \   000001BC   011080E2           ADD      R1,R0,#+1
   \   000001C0   E1FFFFEA           B        ??Update_15
    104                                  Value       = intValue;
    105                              }
    106                              break;
    107                          case Float_None:
    108                              {
    109                                  if (HasDecimalScaling) {
   \                     ??Update_19:
   \   000001C4   9801D4E5           LDRB     R0,[R4, #+408]
   \   000001C8   618FA0E3           MOV      R8,#+388
   \   000001CC   0020A0E3           MOV      R2,#+0
   \   000001D0   000050E3           CMP      R0,#+0
   \   000001D4   0700A0E1           MOV      R0,R7
   \   000001D8   0B00000A           BEQ      ??Update_20
    110                                      U16 rInVal = tmpPtr->GetRegister(Channel);
   \   000001DC   ........           _BLF     ??GetRegister,??GetRegister??rA
    111                                      float InVal = HasSign ? ((float)(I16)rInVal) : (float)rInVal;
   \   000001E0   0410D8E7           LDRB     R1,[R8, +R4]
   \   000001E4   000051E3           CMP      R1,#+0
   \   000001E8   0300000A           BEQ      ??Update_21
   \   000001EC   0008A0E1           MOV      R0,R0, LSL #+16
   \   000001F0   4008A0E1           MOV      R0,R0, ASR #+16
   \   000001F4   ........           _BLF     __longToFloat,??__longToFloat??rA
   \   000001F8   000000EA           B        ??Update_22
   \                     ??Update_21:
   \   000001FC   ........           _BLF     __ulongToFloat,??__ulongToFloat??rA
    112                                      Value = InVal / DecimalScaling;
   \                     ??Update_22:
   \   00000200   901194E5           LDR      R1,[R4, #+400]
   \   00000204   ........           _BLF     __fDiv,??__fDiv??rA
   \   00000208   0D0000EA           B        ??Update_23
    113                                  } else {
    114                                      U16 rInVal = tmpPtr->GetRegister(Channel);
   \                     ??Update_20:
   \   0000020C   ........           _BLF     ??GetRegister,??GetRegister??rA
    115                                      float InVal = HasSign ? ((float)(I16)rInVal) : (float)rInVal;
   \   00000210   0410D8E7           LDRB     R1,[R8, +R4]
   \   00000214   000051E3           CMP      R1,#+0
   \   00000218   0300000A           BEQ      ??Update_24
   \   0000021C   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000220   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000224   ........           _BLF     __longToFloat,??__longToFloat??rA
   \   00000228   000000EA           B        ??Update_25
   \                     ??Update_24:
   \   0000022C   ........           _BLF     __ulongToFloat,??__ulongToFloat??rA
   \                     ??Update_25:
   \   00000230   0010A0E1           MOV      R1,R0
    116                                      Value = Scale * InVal + Offset;
   \   00000234   880194E5           LDR      R0,[R4, #+392]
   \   00000238   ........           _BLF     __fMul,??__fMul??rA
   \   0000023C   8C1194E5           LDR      R1,[R4, #+396]
   \   00000240   ........           _BLF     __fAdd,??__fAdd??rA
   \                     ??Update_23:
   \   00000244   00008DE5           STR      R0,[SP, #+0]
    117                                  }
    118                                  if (HasRange) {
   \   00000248   9A01D4E5           LDRB     R0,[R4, #+410]
   \   0000024C   000050E3           CMP      R0,#+0
   \   00000250   0C00000A           BEQ      ??Update_6
   \   00000254   7C7194E5           LDR      R7,[R4, #+380]
   \   00000258   00009DE5           LDR      R0,[SP, #+0]
   \   0000025C   0710A0E1           MOV      R1,R7
   \   00000260   ........           _BLF     __fLess,??__fLess??rA
   \   00000264   000050E3           CMP      R0,#+0
   \   00000268   0500001A           BNE      ??Update_26
   \   0000026C   807194E5           LDR      R7,[R4, #+384]
   \   00000270   00109DE5           LDR      R1,[SP, #+0]
   \   00000274   0700A0E1           MOV      R0,R7
   \   00000278   ........           _BLF     __fLess,??__fLess??rA
   \   0000027C   000050E3           CMP      R0,#+0
   \   00000280   0000000A           BEQ      ??Update_6
    119                                      if (Value < MinRange) {
    120                                          Value = MinRange;
    121                                      } else if (Value > MaxRange) {
    122                                          Value = MaxRange;
   \                     ??Update_26:
   \   00000284   00708DE5           STR      R7,[SP, #+0]
    123                                      }
    124                                  }
    125                              }
    126                              break;
    127                          }
    128                          if (ObjPtr) {
   \                     ??Update_6:
   \   00000288   040096E7           LDR      R0,[R6, +R4]
   \   0000028C   000050E3           CMP      R0,#+0
   \   00000290   2000000A           BEQ      ??Update_2
    129                              if (Master) {
   \   00000294   88109FE5           LDR      R1,??Update_4+0x4  ;; Master
   \   00000298   0010D1E5           LDRB     R1,[R1, #+0]
   \   0000029C   000051E3           CMP      R1,#+0
   \   000002A0   1000000A           BEQ      ??Update_27
    130                                  ObjPtr->SetTimeStamp();
   \   000002A4   ........           _BLF     ??SetTimeStamp,??SetTimeStamp??rA
    131                                  ObjPtr->PutFloatValue(ValueKey, Value);
   \   000002A8   043096E7           LDR      R3,[R6, +R4]
   \   000002AC   00209DE5           LDR      R2,[SP, #+0]
   \   000002B0   041095E7           LDR      R1,[R5, +R4]
   \   000002B4   0300A0E1           MOV      R0,R3
   \   000002B8   A43093E5           LDR      R3,[R3, #+164]
   \   000002BC   343093E5           LDR      R3,[R3, #+52]
   \   000002C0   0FE0A0E1           MOV      LR,PC
   \   000002C4   13FF2FE1           BX       R3
    132                                  ObjPtr->RefreshData(ValueKey);
   \   000002C8   042096E7           LDR      R2,[R6, +R4]
   \   000002CC   041095E7           LDR      R1,[R5, +R4]
   \   000002D0   0200A0E1           MOV      R0,R2
   \   000002D4   A42092E5           LDR      R2,[R2, #+164]
   \   000002D8   742092E5           LDR      R2,[R2, #+116]
   \   000002DC   0FE0A0E1           MOV      LR,PC
   \   000002E0   12FF2FE1           BX       R2
   \   000002E4   0B0000EA           B        ??Update_2
    133                              }else{
    134                                  // Should also include the com port. Now send broadcast to all TDUs and PCs
    135                                  // connected to this slave TCU
    136                                  ObjPtr->SendModbusData(ValueKey, Value);
   \                     ??Update_27:
   \   000002E8   00209DE5           LDR      R2,[SP, #+0]
   \   000002EC   041095E7           LDR      R1,[R5, +R4]
   \   000002F0   6730A0E3           MOV      R3,#+103
   \   000002F4   0118A0E1           MOV      R1,R1, LSL #+16
   \   000002F8   2118A0E1           MOV      R1,R1, LSR #+16
   \   000002FC   ........           _BLF     ??SendModbusData,??SendModbusData??rA
   \   00000300   040000EA           B        ??Update_2
    137                              }
    138                          }
    139                      } else {
    140                          if (ObjPtr) {
   \                     ??Update_5:
   \   00000304   040096E7           LDR      R0,[R6, +R4]
   \   00000308   000050E3           CMP      R0,#+0
   \   0000030C   0100000A           BEQ      ??Update_2
    141                              ObjPtr->SetOffline(ValueKey);
   \   00000310   041095E7           LDR      R1,[R5, +R4]
   \   00000314   ........           _BLF     ??SetOffline,??SetOffline??rA
    142                          }
    143                      }
    144                  }
    145              }
    146          }
   \                     ??Update_2:
   \   00000318   F341BDE8           POP      {R0,R1,R4-R8,LR}
   \   0000031C   1EFF2FE1           BX       LR               ;; return
   \                     ??Update_4:
   \   00000320   ........           DC32     OS_Time
   \   00000324   ........           DC32     Master
    147          

   \                                 In segment CODE, align 4, keep-with-next
    148          void ModbusRegisterIn::CalculateScaleOut(float &ScaleOut, float &OffsetOut) {
   \                     ??CalculateScaleOut:
   \   00000000   F04D2DE9           PUSH     {R4-R8,R10,R11,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    149              float Divisor = MaxRange - MinRange;
    150              if (Divisor) {
   \   00000008   800194E5           LDR      R0,[R4, #+384]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   5F7FA0E3           MOV      R7,#+380
   \   00000014   041097E7           LDR      R1,[R7, +R4]
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   ........           _BLF     __fSub,??__fSub??rA
   \   00000020   0080A0E1           MOV      R8,R0
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   0810A0E1           MOV      R1,R8
   \   0000002C   ........           _BLF     __fNotEqual,??__fNotEqual??rA
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0D00000A           BEQ      ??CalculateScaleOut_1
    151                  ScaleOut = (float(RegMax) - 0.0) / (MaxRange - MinRange);
   \   00000038   A80194E5           LDR      R0,[R4, #+424]
   \   0000003C   ........           _BLF     __longToFloat,??__longToFloat??rA
   \   00000040   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   00000044   00A0A0E1           MOV      R10,R0
   \   00000048   01B0A0E1           MOV      R11,R1
   \   0000004C   0800A0E1           MOV      R0,R8
   \   00000050   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   00000054   0020A0E1           MOV      R2,R0
   \   00000058   0130A0E1           MOV      R3,R1
   \   0000005C   0A00A0E1           MOV      R0,R10
   \   00000060   0B10A0E1           MOV      R1,R11
   \   00000064   ........           _BLF     __dDiv,??__dDiv??rA
   \   00000068   ........           _BLF     __doubleToFloat,??__doubleToFloat??rA
   \   0000006C   000000EA           B        ??CalculateScaleOut_2
    152              } else {
    153                  ScaleOut = 1.0;
   \                     ??CalculateScaleOut_1:
   \   00000070   FE05A0E3           MOV      R0,#+1065353216
   \                     ??CalculateScaleOut_2:
   \   00000074   000085E5           STR      R0,[R5, #+0]
    154              }
    155              OffsetOut = -ScaleOut * MinRange;
   \   00000078   041097E7           LDR      R1,[R7, +R4]
   \   0000007C   ........           _BLF     __fMul,??__fMul??rA
   \   00000080   800420E2           EOR      R0,R0,#0x80000000
   \   00000084   000086E5           STR      R0,[R6, #+0]
    156          }
   \   00000088   F04DBDE8           POP      {R4-R8,R10,R11,LR}
   \   0000008C   1EFF2FE1           BX       LR               ;; return
    157          
    158          //---------------------------------------------------------------------------
    159          

   \                                 In segment CODE, align 4, keep-with-next
    160          int ModbusRegisterIn::GetOutputVal(void) {
   \                     ??GetOutputVal:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   A0C194E5           LDR      R12,[R4, #+416]
   \   00000010   00005CE3           CMP      R12,#+0
   \   00000014   5300000A           BEQ      ??GetOutputVal_1
    161              if (ObjPtr) {
    162                  float OutVal;
    163                  int DecPnt, Unit; // These variables are not used
    164                  int Status = ObjPtr->GetValue(ValueKey, 0, OutVal, DecPnt, Unit);
   \   00000018   08008DE2           ADD      R0,SP,#+8
   \   0000001C   01002DE9           PUSH     {R0}
   \   00000020   08008DE2           ADD      R0,SP,#+8
   \   00000024   01002DE9           PUSH     {R0}
   \   00000028   A4509CE5           LDR      R5,[R12, #+164]
   \   0000002C   A41194E5           LDR      R1,[R4, #+420]
   \   00000030   245095E5           LDR      R5,[R5, #+36]
   \   00000034   08308DE2           ADD      R3,SP,#+8
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   0C00A0E1           MOV      R0,R12
   \   00000040   0FE0A0E1           MOV      LR,PC
   \   00000044   15FF2FE1           BX       R5
    165                  switch (Status) {
   \   00000048   08D08DE2           ADD      SP,SP,#+8
   \   0000004C   000050E3           CMP      R0,#+0
    166                  case GETVAL_FLOAT_NOT_LEGAL:
    167                  case GETVAL_NOT_AVAILABLE:
    168                  default:
    169                      OutVal = 0.0;
   \   00000050   0010A013           MOVNE    R1,#+0
   \   00000054   00108D15           STRNE    R1,[SP, #+0]
   \   00000058   0800001A           BNE      ??GetOutputVal_2
    170                      break;
    171                  case GETVAL_NO_ERR:
    172                      OutVal = ConvertFromSi(NULL, OutVal, 0, DecPnt, Unit);
   \   0000005C   08009DE5           LDR      R0,[SP, #+8]
   \   00000060   0020A0E3           MOV      R2,#+0
   \   00000064   01002DE9           PUSH     {R0}
   \   00000068   08309DE5           LDR      R3,[SP, #+8]
   \   0000006C   04109DE5           LDR      R1,[SP, #+4]
   \   00000070   0000A0E3           MOV      R0,#+0
   \   00000074   ........           _BLF     ??ConvertFromSi,??ConvertFromSi??rA
   \   00000078   04008DE5           STR      R0,[SP, #+4]
   \   0000007C   04D08DE2           ADD      SP,SP,#+4
    173                      break;
    174                  }
    175                  if (HasRange) {
   \                     ??GetOutputVal_2:
   \   00000080   9A01D4E5           LDRB     R0,[R4, #+410]
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0C00000A           BEQ      ??GetOutputVal_3
   \   0000008C   7C5194E5           LDR      R5,[R4, #+380]
   \   00000090   00009DE5           LDR      R0,[SP, #+0]
   \   00000094   0510A0E1           MOV      R1,R5
   \   00000098   ........           _BLF     __fLess,??__fLess??rA
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   0500001A           BNE      ??GetOutputVal_4
   \   000000A4   805194E5           LDR      R5,[R4, #+384]
   \   000000A8   00109DE5           LDR      R1,[SP, #+0]
   \   000000AC   0500A0E1           MOV      R0,R5
   \   000000B0   ........           _BLF     __fLess,??__fLess??rA
   \   000000B4   000050E3           CMP      R0,#+0
   \   000000B8   0000000A           BEQ      ??GetOutputVal_3
    176                      if (OutVal < MinRange) {
    177                          OutVal = MinRange;
    178                      } else if (OutVal > MaxRange) {
    179                          OutVal = MaxRange;
   \                     ??GetOutputVal_4:
   \   000000BC   00508DE5           STR      R5,[SP, #+0]
    180                      }
    181                  }
    182                  if (HasDecimalScaling) {
   \                     ??GetOutputVal_3:
   \   000000C0   9801D4E5           LDRB     R0,[R4, #+408]
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   1C00000A           BEQ      ??GetOutputVal_5
    183                      float rValue = DecimalScaling * OutVal;
   \   000000CC   901194E5           LDR      R1,[R4, #+400]
   \   000000D0   00009DE5           LDR      R0,[SP, #+0]
   \   000000D4   ........           _BLF     __fMul,??__fMul??rA
   \                     ??GetOutputVal_6:
   \   000000D8   0060A0E1           MOV      R6,R0
    184                      return (floor(rValue) + 0.5)> rValue ? ((U16)floor(rValue) ) : ((U16) ceil(rValue) );
   \   000000DC   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   000000E0   0040A0E1           MOV      R4,R0
   \   000000E4   0150A0E1           MOV      R5,R1
   \   000000E8   0600A0E1           MOV      R0,R6
   \   000000EC   ........           _BLF     floorf,??floorf??rA
   \   000000F0   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   000000F4   0020A0E3           MOV      R2,#+0
   \   000000F8   C035A0E3           MOV      R3,#+805306368
   \   000000FC   FE3683E3           ORR      R3,R3,#0xFE00000
   \   00000100   ........           _BLF     __dAdd,??__dAdd??rA
   \   00000104   0020A0E1           MOV      R2,R0
   \   00000108   0130A0E1           MOV      R3,R1
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   0510A0E1           MOV      R1,R5
   \   00000114   ........           _BLF     __dLess,??__dLess??rA
   \   00000118   000050E3           CMP      R0,#+0
   \   0000011C   0600A0E1           MOV      R0,R6
   \   00000120   0100000A           BEQ      ??GetOutputVal_7
   \   00000124   ........           _BLF     floorf,??floorf??rA
   \   00000128   000000EA           B        ??GetOutputVal_8
   \                     ??GetOutputVal_7:
   \   0000012C   ........           _BLF     ceilf,??ceilf??rA
   \                     ??GetOutputVal_8:
   \   00000130   ........           _BLF     __floatToLong,??__floatToLong??rA
   \   00000134   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000138   2008A0E1           MOV      R0,R0, LSR #+16
   \   0000013C   0A0000EA           B        ??GetOutputVal_9
    185                  } else {
    186                      // Round output to nearest integer, but let -0.6 be -1 for example
    187                      float ScaleOut, OffsetOut;
    188                      CalculateScaleOut(ScaleOut, OffsetOut);
   \                     ??GetOutputVal_5:
   \   00000140   10208DE2           ADD      R2,SP,#+16
   \   00000144   0C108DE2           ADD      R1,SP,#+12
   \   00000148   0400A0E1           MOV      R0,R4
   \   0000014C   ........           BL       ??CalculateScaleOut
    189                      float rValue = ScaleOut * OutVal + OffsetOut;
   \   00000150   0C109DE5           LDR      R1,[SP, #+12]
   \   00000154   00009DE5           LDR      R0,[SP, #+0]
   \   00000158   ........           _BLF     __fMul,??__fMul??rA
   \   0000015C   10109DE5           LDR      R1,[SP, #+16]
   \   00000160   ........           _BLF     __fAdd,??__fAdd??rA
   \   00000164   DBFFFFEA           B        ??GetOutputVal_6
    190                      return (floor(rValue) + 0.5)> rValue ? ((U16)floor(rValue) ) : ((U16) ceil(rValue) );
    191                  }
    192              } else {
    193                  return 0;
   \                     ??GetOutputVal_1:
   \   00000168   0000A0E3           MOV      R0,#+0
   \                     ??GetOutputVal_9:
   \   0000016C   14D08DE2           ADD      SP,SP,#+20
   \   00000170   ........           B        ?Subroutine14
    194              }
    195          
    196          }

   \                                 In segment CODE, align 4, keep-with-next
    197          float ModbusRegisterIn::GetOutputValFloat(void) {
   \                     ??GetOutputValFloat:
   \   00000000   07402DE9           PUSH     {R0-R2,LR}
   \   00000004   A0C190E5           LDR      R12,[R0, #+416]
   \   00000008   00005CE3           CMP      R12,#+0
   \   0000000C   0E00000A           BEQ      ??GetOutputValFloat_1
    198              float OutVal;
    199              int DecPnt, Unit; // These variables are not used
    200              int Status;
    201              if (ObjPtr) {
    202                  Status = ObjPtr->GetValue(ValueKey, 0, OutVal, DecPnt, Unit);
   \   00000010   08108DE2           ADD      R1,SP,#+8
   \   00000014   02002DE9           PUSH     {R1}
   \   00000018   08108DE2           ADD      R1,SP,#+8
   \   0000001C   02002DE9           PUSH     {R1}
   \   00000020   A41190E5           LDR      R1,[R0, #+420]
   \   00000024   0C00A0E1           MOV      R0,R12
   \   00000028   A4C09CE5           LDR      R12,[R12, #+164]
   \   0000002C   08308DE2           ADD      R3,SP,#+8
   \   00000030   24C09CE5           LDR      R12,[R12, #+36]
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   0FE0A0E1           MOV      LR,PC
   \   0000003C   1CFF2FE1           BX       R12
    203              } else {
    204                  Status = GETVAL_ERROR;
    205              }
    206              switch (Status) {
   \   00000040   08D08DE2           ADD      SP,SP,#+8
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0200000A           BEQ      ??GetOutputValFloat_2
    207              case GETVAL_FLOAT_NOT_LEGAL:
    208              case GETVAL_NOT_AVAILABLE:
    209              case GETVAL_ERROR:
    210              default:
    211                  OutVal = 0.0;
   \                     ??GetOutputValFloat_1:
   \   0000004C   0010A0E3           MOV      R1,#+0
   \   00000050   00108DE5           STR      R1,[SP, #+0]
   \   00000054   080000EA           B        ??GetOutputValFloat_3
    212                  break;
    213              case GETVAL_NO_ERR:
    214                  OutVal = ConvertFromSi(NULL, OutVal, 0, DecPnt, Unit);
   \                     ??GetOutputValFloat_2:
   \   00000058   08009DE5           LDR      R0,[SP, #+8]
   \   0000005C   0020A0E3           MOV      R2,#+0
   \   00000060   01002DE9           PUSH     {R0}
   \   00000064   08309DE5           LDR      R3,[SP, #+8]
   \   00000068   04109DE5           LDR      R1,[SP, #+4]
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   ........           _BLF     ??ConvertFromSi,??ConvertFromSi??rA
   \   00000074   04008DE5           STR      R0,[SP, #+4]
   \   00000078   04D08DE2           ADD      SP,SP,#+4
    215                  break;
    216              }
    217              return OutVal;
   \                     ??GetOutputValFloat_3:
   \   0000007C   00009DE5           LDR      R0,[SP, #+0]
   \   00000080   0E40BDE8           POP      {R1-R3,LR}
   \   00000084   1EFF2FE1           BX       LR               ;; return
    218          }
    219          
    220          

   \                                 In segment CODE, align 4, keep-with-next
    221          void ModbusRegisterIn::InitiateHoldingRegisters(ModbusUnit *UnitPtr) {
   \                     ??InitiateHoldingRegisters:
   \   00000000   71402DE9           PUSH     {R0,R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    222              switch (ModbusDataFormat) {
   \   00000008   9901D4E5           LDRB     R0,[R4, #+409]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   5C6FA0E3           MOV      R6,#+368
   \   00000014   040050E3           CMP      R0,#+4
   \   00000018   3C00008A           BHI      ??InitiateHoldingRegisters_2
   \   0000001C   011F8FE2           ADR      R1,??InitiateHoldingRegisters_1
   \   00000020   0010D1E7           LDRB     R1,[R1, R0]
   \   00000024   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??InitiateHoldingRegisters_1:
   \   00000028   2E01180C           DC8      +46,+1,+24,+12
   \   0000002C   23000000           DC8      +35,+0,+0,+0
    223              case Float_B_Endian:
    224                  {
    225                      float OutVal = GetOutputValFloat();
   \                     ??InitiateHoldingRegisters_3:
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       ??GetOutputValFloat
   \   00000038   00008DE5           STR      R0,[SP, #+0]
    226                      U16 *OutValPtr = (U16 *)&OutVal;
    227                      UnitPtr->SetHoldingRegister(Channel + 1, OutValPtr[0]);
   \   0000003C   B020DDE1           LDRH     R2,[SP, #+0]
   \   00000040   040096E7           LDR      R0,[R6, +R4]
   \   00000044   0030A0E3           MOV      R3,#+0
   \   00000048   011080E2           ADD      R1,R0,#+1
   \   0000004C   0500A0E1           MOV      R0,R5
   \   00000050   ........           _BLF     ??SetHoldingRegister,??SetHoldingRegister??rA
    228                      UnitPtr->SetHoldingRegister(Channel, OutValPtr[1]);
   \   00000054   B220DDE1           LDRH     R2,[SP, #+2]
   \   00000058   280000EA           B        ??InitiateHoldingRegisters_4
    229                  }
    230                  break;
    231              case Float_B_Endian_ByteSwap:
    232                  {
    233                      float OutVal = GetOutputValFloat();
   \                     ??InitiateHoldingRegisters_5:
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   ........           BL       ??GetOutputValFloat
   \   00000064   00008DE5           STR      R0,[SP, #+0]
    234                      U16 *OutValPtr = (U16 *)&OutVal;
    235                      UnitPtr->SetHoldingRegister(Channel + 1, OutValPtr[0], true);
   \   00000068   B020DDE1           LDRH     R2,[SP, #+0]
   \   0000006C   040096E7           LDR      R0,[R6, +R4]
   \   00000070   0130A0E3           MOV      R3,#+1
   \   00000074   011080E2           ADD      R1,R0,#+1
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           _BLF     ??SetHoldingRegister,??SetHoldingRegister??rA
    236                      UnitPtr->SetHoldingRegister(Channel, OutValPtr[1], true);
   \   00000080   B220DDE1           LDRH     R2,[SP, #+2]
   \                     ??InitiateHoldingRegisters_6:
   \   00000084   0130A0E3           MOV      R3,#+1
   \   00000088   1D0000EA           B        ??InitiateHoldingRegisters_7
    237                  }
    238                  break;
    239              case Float_L_Endian:
    240                  {
    241                      float OutVal = GetOutputValFloat();
   \                     ??InitiateHoldingRegisters_8:
   \   0000008C   0400A0E1           MOV      R0,R4
   \   00000090   ........           BL       ??GetOutputValFloat
   \   00000094   00008DE5           STR      R0,[SP, #+0]
    242                      U16 *OutValPtr = (U16 *)&OutVal;
    243                      UnitPtr->SetHoldingRegister(Channel + 1, OutValPtr[1], true);
   \   00000098   B220DDE1           LDRH     R2,[SP, #+2]
   \   0000009C   040096E7           LDR      R0,[R6, +R4]
   \   000000A0   0130A0E3           MOV      R3,#+1
   \   000000A4   011080E2           ADD      R1,R0,#+1
   \   000000A8   0500A0E1           MOV      R0,R5
   \   000000AC   ........           _BLF     ??SetHoldingRegister,??SetHoldingRegister??rA
    244                      UnitPtr->SetHoldingRegister(Channel, OutValPtr[0], true);
   \   000000B0   B020DDE1           LDRH     R2,[SP, #+0]
   \   000000B4   F2FFFFEA           B        ??InitiateHoldingRegisters_6
    245                  }
    246                  break;
    247              case Float_L_Endian_ByteSwap:
    248                  {
    249                      float OutVal = GetOutputValFloat();
   \                     ??InitiateHoldingRegisters_9:
   \   000000B8   0400A0E1           MOV      R0,R4
   \   000000BC   ........           BL       ??GetOutputValFloat
   \   000000C0   00008DE5           STR      R0,[SP, #+0]
    250                      U16 *OutValPtr = (U16 *)&OutVal;
    251                      UnitPtr->SetHoldingRegister(Channel + 1, OutValPtr[1]);
   \   000000C4   B220DDE1           LDRH     R2,[SP, #+2]
   \   000000C8   040096E7           LDR      R0,[R6, +R4]
   \   000000CC   0030A0E3           MOV      R3,#+0
   \   000000D0   011080E2           ADD      R1,R0,#+1
   \   000000D4   0500A0E1           MOV      R0,R5
   \   000000D8   ........           _BLF     ??SetHoldingRegister,??SetHoldingRegister??rA
    252                      UnitPtr->SetHoldingRegister(Channel, OutValPtr[0]);
   \   000000DC   B020DDE1           LDRH     R2,[SP, #+0]
   \   000000E0   060000EA           B        ??InitiateHoldingRegisters_4
    253                  }
    254                  break;
    255              case Float_None:
    256                  {
    257                      U16 OutVal = (U16)GetOutputVal();
   \                     ??InitiateHoldingRegisters_10:
   \   000000E4   A41094E5           LDR      R1,[R4, #+164]
   \   000000E8   0400A0E1           MOV      R0,R4
   \   000000EC   A41091E5           LDR      R1,[R1, #+164]
   \   000000F0   0FE0A0E1           MOV      LR,PC
   \   000000F4   11FF2FE1           BX       R1
   \   000000F8   0028A0E1           MOV      R2,R0, LSL #+16
   \   000000FC   2228A0E1           MOV      R2,R2, LSR #+16
    258                      UnitPtr->SetHoldingRegister(Channel, OutVal);
   \                     ??InitiateHoldingRegisters_4:
   \   00000100   0030A0E3           MOV      R3,#+0
   \                     ??InitiateHoldingRegisters_7:
   \   00000104   041096E7           LDR      R1,[R6, +R4]
   \   00000108   0500A0E1           MOV      R0,R5
   \   0000010C   ........           _BLF     ??SetHoldingRegister,??SetHoldingRegister??rA
    259                  }
    260                  break;
    261              }
    262          }
   \                     ??InitiateHoldingRegisters_2:
   \   00000110   7140BDE8           POP      {R0,R4-R6,LR}
   \   00000114   1EFF2FE1           BX       LR               ;; return
    263          
    264          

   \                                 In segment CODE, align 4, keep-with-next
    265          ModbusRegisterIn& ModbusRegisterIn::operator = (ModbusRegisterIn Src) {
   \                     `??operator=`:
   \   00000000   73402DE9           PUSH     {R0,R1,R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    266              Name          = Src.Name;
   \   00000008   ........           LDR      R0,??DataTable2  ;; ??npos
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   006090E5           LDR      R6,[R0, #+0]
   \   00000014   0020A0E3           MOV      R2,#+0
   \   00000018   0630A0E1           MOV      R3,R6
   \   0000001C   441085E2           ADD      R1,R5,#+68
   \   00000020   440084E2           ADD      R0,R4,#+68
   \   00000024   ........           _BLF     ??assign,??assign??rA
    267              Description   = Src.Description;
   \   00000028   0630A0E1           MOV      R3,R6
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   7C1085E2           ADD      R1,R5,#+124
   \   00000034   7C0084E2           ADD      R0,R4,#+124
   \   00000038   ........           _BLF     ??assign,??assign??rA
    268          
    269              IPAddress     = Src.IPAddress;
   \   0000003C   520FA0E3           MOV      R0,#+328
   \   00000040   0630A0E1           MOV      R3,R6
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   051080E0           ADD      R1,R0,R5
   \   0000004C   040080E0           ADD      R0,R0,R4
   \   00000050   ........           _BLF     ??assign,??assign??rA
    270              TCUAddress    = Src.TCUAddress;
   \   00000054   590FA0E3           MOV      R0,#+356
   \   00000058   051090E7           LDR      R1,[R0, +R5]
   \   0000005C   041080E7           STR      R1,[R0, +R4]
    271              TCUPortNo     = Src.TCUPortNo;
   \   00000060   5A1FA0E3           MOV      R1,#+360
   \   00000064   052091E7           LDR      R2,[R1, +R5]
   \   00000068   042081E7           STR      R2,[R1, +R4]
    272              Address       = Src.Address;
   \   0000006C   5B1FA0E3           MOV      R1,#+364
   \   00000070   052091E7           LDR      R2,[R1, +R5]
   \   00000074   042081E7           STR      R2,[R1, +R4]
    273              Channel       = Src.Channel;
   \   00000078   5C1FA0E3           MOV      R1,#+368
   \   0000007C   052091E7           LDR      R2,[R1, +R5]
   \   00000080   042081E7           STR      R2,[R1, +R4]
    274          
    275          
    276              MinRange      = Src.MinRange;
   \   00000084   5F1FA0E3           MOV      R1,#+380
   \   00000088   052091E7           LDR      R2,[R1, +R5]
   \   0000008C   042081E7           STR      R2,[R1, +R4]
    277              MaxRange      = Src.MaxRange;
   \   00000090   601FA0E3           MOV      R1,#+384
   \   00000094   052091E7           LDR      R2,[R1, +R5]
   \   00000098   042081E7           STR      R2,[R1, +R4]
    278              RegMax        = Src.RegMax;
   \   0000009C   6A1FA0E3           MOV      R1,#+424
   \   000000A0   052091E7           LDR      R2,[R1, +R5]
   \   000000A4   042081E7           STR      R2,[R1, +R4]
    279              ValueKey      = Src.ValueKey;
   \   000000A8   691FA0E3           MOV      R1,#+420
   \   000000AC   052091E7           LDR      R2,[R1, +R5]
   \   000000B0   042081E7           STR      R2,[R1, +R4]
    280              RefObjectId   = Src.RefObjectId;
   \   000000B4   671FA0E3           MOV      R1,#+412
   \   000000B8   052091E7           LDR      R2,[R1, +R5]
   \   000000BC   042081E7           STR      R2,[R1, +R4]
    281          
    282              Scale             = Src.Scale;
   \   000000C0   621FA0E3           MOV      R1,#+392
   \   000000C4   052091E7           LDR      R2,[R1, +R5]
   \   000000C8   042081E7           STR      R2,[R1, +R4]
    283              Offset            = Src.Offset;
   \   000000CC   631FA0E3           MOV      R1,#+396
   \   000000D0   052091E7           LDR      R2,[R1, +R5]
   \   000000D4   042081E7           STR      R2,[R1, +R4]
    284              HasSign           = Src.HasSign;
   \   000000D8   611FA0E3           MOV      R1,#+388
   \   000000DC   0520D1E7           LDRB     R2,[R1, +R5]
   \   000000E0   0420C1E7           STRB     R2,[R1, +R4]
    285              HasDecimalScaling = Src.HasDecimalScaling;
   \   000000E4   661FA0E3           MOV      R1,#+408
   \   000000E8   0520D1E7           LDRB     R2,[R1, +R5]
   \   000000EC   0420C1E7           STRB     R2,[R1, +R4]
    286              ModbusDataFormat   = Src.ModbusDataFormat;
   \   000000F0   351080E2           ADD      R1,R0,#+53
   \   000000F4   0520D1E7           LDRB     R2,[R1, +R5]
   \   000000F8   0420C1E7           STRB     R2,[R1, +R4]
    287              HasRange          = Src.HasRange;
   \   000000FC   361080E2           ADD      R1,R0,#+54
   \   00000100   0520D1E7           LDRB     R2,[R1, +R5]
   \   00000104   0420C1E7           STRB     R2,[R1, +R4]
    288              DecimalPoint      = Src.DecimalPoint;
   \   00000108   651FA0E3           MOV      R1,#+404
   \   0000010C   052091E7           LDR      R2,[R1, +R5]
   \   00000110   042081E7           STR      R2,[R1, +R4]
    289              DecimalScaling    = Src.DecimalScaling;
   \   00000114   641FA0E3           MOV      R1,#+400
   \   00000118   052091E7           LDR      R2,[R1, +R5]
   \   0000011C   042081E7           STR      R2,[R1, +R4]
    290              if ((TCUAddress==CurrentDeviceAddress) && (CurrentDeviceId == DEVICE_TCU)) {
   \   00000120   34109FE5           LDR      R1,`??operator=_1`  ;; CurrentDeviceAddress
   \   00000124   040090E7           LDR      R0,[R0, +R4]
   \   00000128   F010D1E1           LDRSH    R1,[R1, #+0]
   \   0000012C   010050E1           CMP      R0,R1
   \   00000130   28009F05           LDREQ    R0,`??operator=_1`+0x4  ;; CurrentDeviceId
   \   00000134   F000D001           LDRSHEQ  R0,[R0, #+0]
   \   00000138   20005003           CMPEQ    R0,#+32
   \   0000013C   0300001A           BNE      `??operator=_2`
    291                  MyModbusSet.insert(this);
   \   00000140   1C109FE5           LDR      R1,`??operator=_1`+0x8  ;; ??MyModbusSet
   \   00000144   0420A0E1           MOV      R2,R4
   \   00000148   0D00A0E1           MOV      R0,SP
   \   0000014C   ........           _BLF     ??insert,??insert??rA_1
    292              }
    293              return *this;
   \                     `??operator=_2`:
   \   00000150   0400A0E1           MOV      R0,R4
   \   00000154   7640BDE8           POP      {R1,R2,R4-R6,LR}
   \   00000158   1EFF2FE1           BX       LR               ;; return
   \                     `??operator=_1`:
   \   0000015C   ........           DC32     CurrentDeviceAddress
   \   00000160   ........           DC32     CurrentDeviceId
   \   00000164   ........           DC32     ??MyModbusSet
    294          }
    295          

   \                                 In segment CODE, align 4, keep-with-next
    296          void ModbusRegisterIn::UpdateFromMultiple(unsigned pIdNumber, int pChannel) {
   \                     ??UpdateFromMultiple:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    297              Channel +=  pChannel;
   \   00000008   5C5FA0E3           MOV      R5,#+368
   \   0000000C   040095E7           LDR      R0,[R5, +R4]
    298              RefObjectId = pIdNumber;
   \   00000010   676FA0E3           MOV      R6,#+412
   \   00000014   000082E0           ADD      R0,R2,R0
   \   00000018   040085E7           STR      R0,[R5, +R4]
   \   0000001C   041086E7           STR      R1,[R6, +R4]
    299              ModbusUnit::InsertInMap(TCUAddress, TCUPortNo, Address, Type, Channel,RefObjectId);
   \   00000020   0010A0E3           MOV      R1,#+0
   \   00000024   02002DE9           PUSH     {R1}
   \   00000028   041096E7           LDR      R1,[R6, +R4]
   \   0000002C   597FA0E3           MOV      R7,#+356
   \   00000030   5A8FA0E3           MOV      R8,#+360
   \   00000034   5B9FA0E3           MOV      R9,#+364
   \   00000038   02002DE9           PUSH     {R1}
   \   0000003C   01002DE9           PUSH     {R0}
   \   00000040   A03094E5           LDR      R3,[R4, #+160]
   \   00000044   042099E7           LDR      R2,[R9, +R4]
   \   00000048   041098E7           LDR      R1,[R8, +R4]
   \   0000004C   040097E7           LDR      R0,[R7, +R4]
   \   00000050   FF2002E2           AND      R2,R2,#0xFF
   \   00000054   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000058   2118A0E1           MOV      R1,R1, LSR #+16
   \   0000005C   FF0000E2           AND      R0,R0,#0xFF
   \   00000060   ........           _BLF     ??InsertInMap,??InsertInMap??rA
    300              if (ModbusDataFormat) { // Check if two registers are required
   \   00000064   9901D4E5           LDRB     R0,[R4, #+409]
   \   00000068   0CD08DE2           ADD      SP,SP,#+12
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   1000000A           BEQ      ??UpdateFromMultiple_1
    301                  ModbusUnit::InsertInMap(TCUAddress, TCUPortNo, Address, Type, Channel + 1,RefObjectId);
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   01002DE9           PUSH     {R0}
   \   0000007C   040096E7           LDR      R0,[R6, +R4]
   \   00000080   01002DE9           PUSH     {R0}
   \   00000084   040095E7           LDR      R0,[R5, +R4]
   \   00000088   010080E2           ADD      R0,R0,#+1
   \   0000008C   01002DE9           PUSH     {R0}
   \   00000090   A03094E5           LDR      R3,[R4, #+160]
   \   00000094   042099E7           LDR      R2,[R9, +R4]
   \   00000098   041098E7           LDR      R1,[R8, +R4]
   \   0000009C   040097E7           LDR      R0,[R7, +R4]
   \   000000A0   FF2002E2           AND      R2,R2,#0xFF
   \   000000A4   0118A0E1           MOV      R1,R1, LSL #+16
   \   000000A8   2118A0E1           MOV      R1,R1, LSR #+16
   \   000000AC   FF0000E2           AND      R0,R0,#0xFF
   \   000000B0   ........           _BLF     ??InsertInMap,??InsertInMap??rA
   \   000000B4   0CD08DE2           ADD      SP,SP,#+12
    302              }
    303          }
   \                     ??UpdateFromMultiple_1:
   \   000000B8   F043BDE8           POP      {R4-R9,LR}
   \   000000BC   1EFF2FE1           BX       LR               ;; return
    304          

   \                                 In segment CODE, align 4, keep-with-next
    305          AnsiString ModbusRegisterIn::GetRegisterValue(void) {
   \                     ??GetRegisterValue:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    306              AnsiString Result;
   \   00000010   0500A0E1           MOV      R0,R5
   \   00000014   ........           _BLF     ??AnsiString,??AnsiString??rA
    307              //Result.sprintf("%8.3f",GetOutputValFloat());
    308              Result = LibGetValue(ValueKey, ObjPtr);
   \   00000018   A02194E5           LDR      R2,[R4, #+416]
   \   0000001C   A41194E5           LDR      R1,[R4, #+420]
   \   00000020   0030A0E3           MOV      R3,#+0
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   ........           _BLF     ??LibGetValue,??LibGetValue??rA
   \   0000002C   ........           LDR      R0,??DataTable2  ;; ??npos
   \   00000030   0020A0E3           MOV      R2,#+0
   \   00000034   003090E5           LDR      R3,[R0, #+0]
   \   00000038   0D10A0E1           MOV      R1,SP
   \   0000003C   0500A0E1           MOV      R0,R5
   \   00000040   ........           _BLF     ??assign,??assign??rA
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   0110A0E3           MOV      R1,#+1
   \   0000004C   0D00A0E1           MOV      R0,SP
   \   00000050   ........           _BLF     ??_Tidy,??_Tidy??rA
    309              return Result;
   \   00000054   1CD08DE2           ADD      SP,SP,#+28
   \   00000058                      REQUIRE ?Subroutine15
   \   00000058                      ;; // Fall through to label ?Subroutine15
    310          }
    311          
    312          
    313          //---------------------------------------------------------------------------
    314          
    315          

   \                                 In segment CODE, align 4, keep-with-next
    316          void ModbusRegisterIn::SetProList(void) {
   \                     ??SetProList:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   54D04DE2           SUB      SP,SP,#+84
   \   00000008   0040A0E1           MOV      R4,R0
    317              ObjPtr = (PRogramObject *)FindPROFromIDNumber(RefObjectId);
   \   0000000C   676FA0E3           MOV      R6,#+412
   \   00000010   040096E7           LDR      R0,[R6, +R4]
   \   00000014   685FA0E3           MOV      R5,#+416
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   ........           _BLF     ??FindPROFromIDNumber,??FindPROFromIDNumber??rA
   \   00000020   040085E7           STR      R0,[R5, +R4]
    318              if (!ObjPtr) {
   \   00000024   000050E3           CMP      R0,#+0
   \   00000028   2C00001A           BNE      ??SetProList_1
    319                  AnsiString InfoStr;
   \   0000002C   38008DE2           ADD      R0,SP,#+56
   \   00000030   ........           _BLF     ??AnsiString,??AnsiString??rA
    320                  if (IsCreatedFromMultiple) {
   \   00000034   7801D4E5           LDRB     R0,[R4, #+376]
   \   00000038   A8209FE5           LDR      R2,??SetProList_2  ;; `?<Constant "Created by ModbusMult...">`
   \   0000003C   043096E7           LDR      R3,[R6, +R4]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0400000A           BEQ      ??SetProList_3
    321                      InfoStr.cat_sprintf("Created by ModbusMultiple (Line number %i): ModbusRegisterIn RefIDNumber %i (0x%0x) is incorrect", LineNumber, RefObjectId,RefObjectId);
   \   00000048   0300A0E1           MOV      R0,R3
   \   0000004C   01002DE9           PUSH     {R0}
   \   00000050   08002DE9           PUSH     {R3}
   \   00000054   043094E5           LDR      R3,[R4, #+4]
   \   00000058   040000EA           B        ??SetProList_4
    322                  } else {
    323                      InfoStr.cat_sprintf("ModbusRegisterIn RefIDNumber %i (0x%0x) is incorrect. Line Number %i", RefObjectId, RefObjectId,LineNumber);
   \                     ??SetProList_3:
   \   0000005C   040094E5           LDR      R0,[R4, #+4]
   \   00000060   642082E2           ADD      R2,R2,#+100
   \   00000064   01002DE9           PUSH     {R0}
   \   00000068   0300A0E1           MOV      R0,R3
   \   0000006C   01002DE9           PUSH     {R0}
   \                     ??SetProList_4:
   \   00000070   08108DE2           ADD      R1,SP,#+8
   \   00000074   40008DE2           ADD      R0,SP,#+64
   \   00000078   ........           _BLF     ??cat_sprintf,??cat_sprintf??rA
   \   0000007C   0020A0E3           MOV      R2,#+0
   \   00000080   0110A0E3           MOV      R1,#+1
   \   00000084   08008DE2           ADD      R0,SP,#+8
   \   00000088   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   0000008C   08D08DE2           ADD      SP,SP,#+8
    324                  }
    325                  GiveConfigWarning(InfoStr);
   \   00000090   0020A0E3           MOV      R2,#+0
   \   00000094   0010A0E3           MOV      R1,#+0
   \   00000098   1C008DE2           ADD      R0,SP,#+28
   \   0000009C   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000A0   ........           LDR      R0,??DataTable2  ;; ??npos
   \   000000A4   0020A0E3           MOV      R2,#+0
   \   000000A8   003090E5           LDR      R3,[R0, #+0]
   \   000000AC   38108DE2           ADD      R1,SP,#+56
   \   000000B0   1C008DE2           ADD      R0,SP,#+28
   \   000000B4   ........           _BLF     ??assign,??assign??rA
   \   000000B8   1C008DE2           ADD      R0,SP,#+28
   \   000000BC   ........           _BLF     ??GiveConfigWarning,??GiveConfigWarning??rA
   \   000000C0   0020A0E3           MOV      R2,#+0
   \   000000C4   0110A0E3           MOV      R1,#+1
   \   000000C8   1C008DE2           ADD      R0,SP,#+28
   \   000000CC   ........           _BLF     ??_Tidy,??_Tidy??rA
    326              }
   \   000000D0   0020A0E3           MOV      R2,#+0
   \   000000D4   0110A0E3           MOV      R1,#+1
   \   000000D8   38008DE2           ADD      R0,SP,#+56
   \   000000DC   ........           _BLF     ??_Tidy,??_Tidy??rA
    327          
    328          }
   \                     ??SetProList_1:
   \   000000E0   54D08DE2           ADD      SP,SP,#+84
   \   000000E4   ........           B        ?Subroutine14
   \                     ??SetProList_2:
   \   000000E8   ........           DC32     `?<Constant "Created by ModbusMult...">`

   \                                 In segment DIFUNCT, align 4, keep-with-next, root
   \   00000000                      REQUIRE ?call_ctors
   \   00000000   ........           DC32    ??__sti__routine

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Created by ModbusMult...">`:
   \   00000000   437265617465       DC8 43H, 72H, 65H, 61H, 74H, 65H, 64H, 20H
   \              6420        
   \   00000008   6279204D6F64       DC8 62H, 79H, 20H, 4DH, 6FH, 64H, 62H, 75H
   \              6275        
   \   00000010   734D756C7469       DC8 73H, 4DH, 75H, 6CH, 74H, 69H, 70H, 6CH
   \              706C        
   \   00000018   6520284C696E       DC8 65H, 20H, 28H, 4CH, 69H, 6EH, 65H, 20H
   \              6520        
   \   00000020   6E756D626572       DC8 6EH, 75H, 6DH, 62H, 65H, 72H, 20H, 25H
   \              2025        
   \   00000028   69293A204D6F       DC8 69H, 29H, 3AH, 20H, 4DH, 6FH, 64H, 62H
   \              6462        
   \   00000030   757352656769       DC8 75H, 73H, 52H, 65H, 67H, 69H, 73H, 74H
   \              7374        
   \   00000038   6572496E2052       DC8 65H, 72H, 49H, 6EH, 20H, 52H, 65H, 66H
   \              6566        
   \   00000040   49444E756D62       DC8 49H, 44H, 4EH, 75H, 6DH, 62H, 65H, 72H
   \              6572        
   \   00000048   202569202830       DC8 20H, 25H, 69H, 20H, 28H, 30H, 78H, 25H
   \              7825        
   \   00000050   307829206973       DC8 30H, 78H, 29H, 20H, 69H, 73H, 20H, 69H
   \              2069        
   \   00000058   6E636F727265       DC8 6EH, 63H, 6FH, 72H, 72H, 65H, 63H, 74H
   \              6374        
   \   00000060   00                 DC8 0
   \   00000061   000000             DC8 0, 0, 0
   \   00000064   4D6F64627573       DC8 4DH, 6FH, 64H, 62H, 75H, 73H, 52H, 65H
   \              5265        
   \   0000006C   676973746572       DC8 67H, 69H, 73H, 74H, 65H, 72H, 49H, 6EH
   \              496E        
   \   00000074   205265664944       DC8 20H, 52H, 65H, 66H, 49H, 44H, 4EH, 75H
   \              4E75        
   \   0000007C   6D6265722025       DC8 6DH, 62H, 65H, 72H, 20H, 25H, 69H, 20H
   \              6920        
   \   00000084   283078253078       DC8 28H, 30H, 78H, 25H, 30H, 78H, 29H, 20H
   \              2920        
   \   0000008C   697320696E63       DC8 69H, 73H, 20H, 69H, 6EH, 63H, 6FH, 72H
   \              6F72        
   \   00000094   726563742E20       DC8 72H, 65H, 63H, 74H, 2EH, 20H, 4CH, 69H
   \              4C69        
   \   0000009C   6E65204E756D       DC8 6EH, 65H, 20H, 4EH, 75H, 6DH, 62H, 65H
   \              6265        
   \   000000A4   7220256900         DC8 72H, 20H, 25H, 69H, 0
   \   000000A9   000000             DC8 0, 0, 0

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs ModbusRegisterIn &ModbusRegisterIn::new ModbusRegisterIn(bool, int, bool)
   \                     `??new ModbusRegisterIn`:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   6C0FA0E3           MOV      R0,#+432
   \   00000014   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0300000A           BEQ      `??new ModbusRegisterIn_1`
   \   00000020   0630A0E1           MOV      R3,R6
   \   00000024   0520A0E1           MOV      R2,R5
   \   00000028   0410A0E1           MOV      R1,R4
   \   0000002C   ........           BL       ??ModbusRegisterIn
   \                     `??new ModbusRegisterIn_1`:
   \   00000030   ........           B        ?Subroutine14

   \                                 In segment CODE, align 4, keep-with-next
   \   static __??Code32?? __intrinsic __code __interwork __atpcs void __sti__routine()
   \                     ??__sti__routine:
   \   00000000   31402DE9           PUSH     {R0,R4,R5,LR}
   \   00000004   50409FE5           LDR      R4,??__sti__routine_1  ;; ??UniquePROSet
   \   00000008   0110A0E3           MOV      R1,#+1
   \   0000000C   4C509FE5           LDR      R5,??__sti__routine_1+0x4  ;; ?_0
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000020   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000024   1400C4E5           STRB     R0,[R4, #+20]
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           _BLF     __record_needed_destruction,??__record_needed_destruction??rA
   \   00000030   0110A0E3           MOV      R1,#+1
   \   00000034   0D00A0E1           MOV      R0,SP
   \   00000038   ........           _BLF     __data_memzero,??__data_memzero??rA
   \   0000003C   180084E2           ADD      R0,R4,#+24
   \   00000040   ........           _BLF     ??_Clear,??_Clear??rA
   \   00000044   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000048   2C00C4E5           STRB     R0,[R4, #+44]
   \   0000004C   0C0085E2           ADD      R0,R5,#+12
   \   00000050   ........           _BLF     __record_needed_destruction,??__record_needed_destruction??rA
   \   00000054   3140BDE8           POP      {R0,R4,R5,LR}
   \   00000058   1EFF2FE1           BX       LR               ;; return
   \                     ??__sti__routine_1:
   \   0000005C   ........           DC32     ??UniquePROSet
   \   00000060   ........           DC32     ?_0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     ??npos

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     ModbusRegisterIn::CalculateScale()
                                       16
     ModbusRegisterIn::CalculateScaleOut(float &, float &)
                                       32
     ModbusRegisterIn::GetOutputVal()
                                       44
     ModbusRegisterIn::GetOutputValFloat()
                                       24
     ModbusRegisterIn::GetRegisterValue()
                                       40
     ModbusRegisterIn::InitiateHoldingRegisters(ModbusUnit *)
                                       20
     ModbusRegisterIn::ModbusRegisterIn(bool, int, bool)
                                       32
     ModbusRegisterIn::SetProList()   108
     ModbusRegisterIn::Update()        32
     ModbusRegisterIn::UpdateFromMultiple(unsigned int, int)
                                       40
     ModbusRegisterIn::new ModbusRegisterIn(bool, int, bool)
                                       16
     ModbusRegisterIn::operator=(ModbusRegisterIn)
                                       24
     ModbusRegisterIn::~ModbusRegisterIn()
                                       12
     _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::_Insert(bool, _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::_Nodeptr, ModbusObject *)
                                       24
     _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::insert(ModbusObject *)
                                       44
     _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Nodeptr)
                                       16
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr)
                                       16
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Insert(bool, _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr, PRogramObjectBase *)
                                       24
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::insert(PRogramObjectBase *)
                                       44
     _Tree_algobase<allocator<void>>::_Clear()
                                        0
     _Tree_algobase<allocator<void>>::_DecP(_Tree_algobase<allocator<void>>::_Genptr)
                                        0
     _Tree_algobase<allocator<void>>::_Insert(bool, _Tree_algobase<allocator<void>>::_Genptr, _Tree_algobase<allocator<void>>::_Genptr)
                                       20
     _Tree_algobase<allocator<void>>::_Lrotate(_Tree_algobase<allocator<void>>::_Genptr)
                                        0
     _Tree_algobase<allocator<void>>::_Rrotate(_Tree_algobase<allocator<void>>::_Genptr)
                                        0
     __sti__routine()                  16
     set<PRogramObject *>::~set()       8
     set<PRogramObjectBase *>::~set()
                                        8


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _Tree_algobase<allocator<void>>::_DecP(_Tree_algobase<allocator<void>>::_Genptr)
                                     100
     _Tree_algobase<allocator<void>>::_Clear()
                                      36
     _Tree_algobase<allocator<void>>::_Rrotate(_Tree_algobase<allocator<void>>::_Genptr)
                                      84
     _Tree_algobase<allocator<void>>::_Lrotate(_Tree_algobase<allocator<void>>::_Genptr)
                                      84
     _Tree_algobase<allocator<void>>::_Insert(bool, _Tree_algobase<allocator<void>>::_Genptr, _Tree_algobase<allocator<void>>::_Genptr)
                                     356
     _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::insert(ModbusObject *)
                                     200
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::insert(PRogramObjectBase *)
                                     200
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr)
                                      68
     _Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Erase(_Tree<_Tset_traits<PRogramObject *, less<PRogramObject *>, allocator<PRogramObject *>, false>>::_Nodeptr)
                                      68
     _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Insert(bool, _Tree<_Tset_traits<PRogramObjectBase *, less<PRogramObjectBase *>, allocator<PRogramObjectBase *>, false>>::_Nodeptr, PRogramObjectBase *)
                                      96
     _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::_Insert(bool, _Tree<_Tset_traits<ModbusObject *, less<ModbusObject *>, allocator<ModbusObject *>, false>>::_Nodeptr, ModbusObject *)
                                      96
     set<PRogramObject *>::~set()     32
     set<PRogramObjectBase *>::~set()
                                      32
     ?_0                              24
     ModbusRegisterIn::UniquePROSet   48
     ModbusRegisterIn::ModbusRegisterIn(bool, int, bool)
                                     108
     ModbusRegisterIn::~ModbusRegisterIn()
                                      48
     ?Subroutine15                     8
     ModbusRegisterIn::CalculateScale()
                                      72
     ?Subroutine14                     8
     ModbusRegisterIn::Update()      808
     ModbusRegisterIn::CalculateScaleOut(float &, float &)
                                     144
     ModbusRegisterIn::GetOutputVal()
                                     372
     ModbusRegisterIn::GetOutputValFloat()
                                     136
     ModbusRegisterIn::InitiateHoldingRegisters(ModbusUnit *)
                                     280
     ModbusRegisterIn::operator=(ModbusRegisterIn)
                                     360
     ModbusRegisterIn::UpdateFromMultiple(unsigned int, int)
                                     192
     ModbusRegisterIn::GetRegisterValue()
                                      88
     ModbusRegisterIn::SetProList()  236
     ?<Constant "Created by ModbusMult...">
                                     172
     ModbusRegisterIn::new ModbusRegisterIn(bool, int, bool)
                                      52
     __sti__routine()                100
     ??DataTable2                      4
      Others                         840

 
 5 112 bytes in segment CODE
   368 bytes in segment DATA_C
    56 bytes in segment DATA_Z
     4 bytes in segment DIFUNCT
    12 bytes in segment INITTAB
 
 3 020 bytes of CODE  memory (+ 2 108 bytes shared)
   368 bytes of CONST memory
    56 bytes of DATA  memory

Errors: none
Warnings: none
