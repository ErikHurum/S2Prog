##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:17:24 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\src\ST16554Uart.cpp                    #
#    Command line    =  D:\S2Prog\TXU\src\ST16554Uart.cpp --fpu None -D      #
#                       OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D      #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --eec++           #
#                       --dlib_config "C:\Program Files (x86)\IAR            #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl4tpainl8n.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\ST16554Uart.lst             #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\ST16554Uart.r79              #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\src\ST16554Uart.cpp
      1          #include <string.h>
      2          #include <ctype.h>
      3          #include <stdlib.h>
      4          
      5          #include "def.h"
      6          
      7          #include "2410addr.h"
      8          #include "2410lib.h"
      9          #include "2410slib.h"
     10          #include "rtos.h"
     11          #include "TSNDefines.h"
     12          #include "TSNConstants.h"
     13          #include "ANSIString.h"
     14          #include "TSNConfigString.h"
     15          #include "TsnUart.h"
     16          #include "ST16554Uart.h"
     17          #ifndef MIN
     18              #define MIN(a, b) (((a) < (b)) ? (a) : (b))
     19          #endif
     20          
     21          

   \                                 In segment CODE, align 4, keep-with-next
     22          ST165540Uart::ST165540Uart(int PortNum, unsigned BdRate, unsigned WrdLength, unsigned StpBits, char Prty, unsigned BufSize, int Dev, int HWProt, int SWProt, bool IsMstr, int MaxTimeChar, bool Relax, int LogP, int LogE) :
   \                     ??ST165540Uart:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   3C20DDE5           LDRB     R2,[SP, #+60]
   \   0000000C   5070DDE5           LDRB     R7,[SP, #+80]
   \   00000010   5890DDE5           LDRB     R9,[SP, #+88]
   \   00000014   40509DE5           LDR      R5,[SP, #+64]
   \   00000018   44C09DE5           LDR      R12,[SP, #+68]
   \   0000001C   48E09DE5           LDR      LR,[SP, #+72]
   \   00000020   4C609DE5           LDR      R6,[SP, #+76]
   \   00000024   54809DE5           LDR      R8,[SP, #+84]
   \   00000028   5CA09DE5           LDR      R10,[SP, #+92]
   \   0000002C   60B09DE5           LDR      R11,[SP, #+96]
   \   00000030   0040A0E1           MOV      R4,R0
   \   00000034   38009DE5           LDR      R0,[SP, #+56]
     23              TSNUart(PortNum, BdRate, WrdLength, StpBits, Prty, BufSize, Dev, HWProt, SWProt, IsMstr, MaxTimeChar, Relax, LogP, LogE),
     24              FIFOInstalled(Unknown) {
   \   00000038   00082DE9           PUSH     {R11}
   \   0000003C   00042DE9           PUSH     {R10}
   \   00000040   00022DE9           PUSH     {R9}
   \   00000044   00012DE9           PUSH     {R8}
   \   00000048   90819FE5           LDR      R8,??ST165540Uart_1  ;; `?<Constant {(unsigned char *)134217728, (unsig`
   \   0000004C   80002DE9           PUSH     {R7}
   \   00000050   0670A0E1           MOV      R7,R6
   \   00000054   80002DE9           PUSH     {R7}
   \   00000058   00402DE9           PUSH     {LR}
   \   0000005C   00102DE9           PUSH     {R12}
   \   00000060   0570A0E1           MOV      R7,R5
   \   00000064   80002DE9           PUSH     {R7}
   \   00000068   04002DE9           PUSH     {R2}
   \   0000006C   01002DE9           PUSH     {R0}
   \   00000070   3C209DE5           LDR      R2,[SP, #+60]
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           _BLF     ??TSNUart,??TSNUart??rA
   \   0000007C   2CD08DE2           ADD      SP,SP,#+44
   \   00000080   100088E2           ADD      R0,R8,#+16
   \   00000084   DC0084E5           STR      R0,[R4, #+220]
   \   00000088   0070A0E3           MOV      R7,#+0
   \   0000008C   E070C4E5           STRB     R7,[R4, #+224]
     25              LastTxTime = 0;
   \   00000090   E87084E5           STR      R7,[R4, #+232]
     26              OS_CREATERSEMA(&TxSema);
   \   00000094   700084E2           ADD      R0,R4,#+112
   \   00000098   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
     27          
     28              Channels[PortNumber] = this;
   \   0000009C   800094E5           LDR      R0,[R4, #+128]
   \   000000A0   3C119FE5           LDR      R1,??ST165540Uart_1+0x4  ;; ??Channels
   \   000000A4   004181E7           STR      R4,[R1, +R0, LSL #+2]
     29          
     30              RxBufPtr = (U8 *)malloc(BufSize);
   \   000000A8   0500A0E1           MOV      R0,R5
   \   000000AC   ........           _BLF     __data_malloc,??__data_malloc??rA
   \   000000B0   240084E5           STR      R0,[R4, #+36]
     31              OS_CreateMB(&RxBuf, 1, BufSize, (char *)RxBufPtr);
   \   000000B4   0030A0E1           MOV      R3,R0
   \   000000B8   0520A0E1           MOV      R2,R5
   \   000000BC   0110A0E3           MOV      R1,#+1
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   ........           _BLF     OS_CreateMB,??OS_CreateMB??rA
     32          
     33              U8 *BasePtr[] = { rEXT_UART0, rEXT_UART1, rEXT_UART2, rEXT_UART3 };
   \   000000C8   2E0098E8           LDM      R8,{R1-R3,R5}
   \   000000CC   0D00A0E1           MOV      R0,SP
   \   000000D0   2E0080E8           STM      R0,{R1-R3,R5}
     34              UartBase = BasePtr[PortNumber - FIRST_ST16554_PORT];
   \   000000D4   800094E5           LDR      R0,[R4, #+128]
   \   000000D8   0D10A0E1           MOV      R1,SP
   \   000000DC   000181E0           ADD      R0,R1,R0, LSL #+2
   \   000000E0   0C0010E5           LDR      R0,[R0, #-12]
   \   000000E4   E40084E5           STR      R0,[R4, #+228]
     35          
     36          
     37              switch (toupper(Parity)) {
   \   000000E8   C010D4E5           LDRB     R1,[R4, #+192]
   \   000000EC   610051E3           CMP      R1,#+97
   \   000000F0   010000BA           BLT      ??ST165540Uart_2
   \   000000F4   7B0051E3           CMP      R1,#+123
   \   000000F8   201041B2           SUBLT    R1,R1,#+32
   \                     ??ST165540Uart_2:
   \   000000FC   451051E2           SUBS     R1,R1,#+69
   \   00000100   0200000A           BEQ      ??ST165540Uart_3
   \   00000104   0A1051E2           SUBS     R1,R1,#+10
   \   00000108   0200000A           BEQ      ??ST165540Uart_4
   \   0000010C   030000EA           B        ??ST165540Uart_5
     38              case 'E':
     39                  ParityValue = 0x18;
   \                     ??ST165540Uart_3:
   \   00000110   1810A0E3           MOV      R1,#+24
   \   00000114   020000EA           B        ??ST165540Uart_6
     40                  break;
     41              case 'O':
     42                  ParityValue = 0x08;
   \                     ??ST165540Uart_4:
   \   00000118   0810A0E3           MOV      R1,#+8
   \   0000011C   000000EA           B        ??ST165540Uart_6
     43                  break;
     44              default:
     45              case 'N':
     46                  ParityValue = 0x00;
   \                     ??ST165540Uart_5:
   \   00000120   0010A0E3           MOV      R1,#+0
   \                     ??ST165540Uart_6:
   \   00000124   C110C4E5           STRB     R1,[R4, #+193]
     47                  break;
     48              }
     49              UartBase[IER] = 0;
   \   00000128   0170C0E5           STRB     R7,[R0, #+1]
     50              UartBase[LCR] = 0x80;
   \   0000012C   E40094E5           LDR      R0,[R4, #+228]
   \   00000130   8010A0E3           MOV      R1,#+128
   \   00000134   0310C0E5           STRB     R1,[R0, #+3]
     51              UartBase[DLL] = (XTAL_UART / 16 / BaudRate) & 0xff;
   \   00000138   E42094E5           LDR      R2,[R4, #+228]
   \   0000013C   AC1094E5           LDR      R1,[R4, #+172]
   \   00000140   E10BA0E3           MOV      R0,#+230400
   \   00000144   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000148   0010C2E5           STRB     R1,[R2, #+0]
     52              UartBase[DLM] = ((XTAL_UART  / 16 / BaudRate) >> 8) & 0xff;
   \   0000014C   E42094E5           LDR      R2,[R4, #+228]
   \   00000150   AC1094E5           LDR      R1,[R4, #+172]
   \   00000154   E10BA0E3           MOV      R0,#+230400
   \   00000158   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   0000015C   2104A0E1           LSR      R0,R1,#+8
   \   00000160   0100C2E5           STRB     R0,[R2, #+1]
     53              UartBase[LCR] = (WordLength - 5) + ((StopBits - 1) << 2) + ParityValue;
   \   00000164   B01094E5           LDR      R1,[R4, #+176]
   \   00000168   B42094E5           LDR      R2,[R4, #+180]
   \   0000016C   E40094E5           LDR      R0,[R4, #+228]
   \   00000170   021181E0           ADD      R1,R1,R2, LSL #+2
   \   00000174   C120D4E5           LDRB     R2,[R4, #+193]
   \   00000178   011082E0           ADD      R1,R2,R1
   \   0000017C   F71081E2           ADD      R1,R1,#+247
   \   00000180   0310C0E5           STRB     R1,[R0, #+3]
     54              switch (SWProt) {
   \   00000184   5800A0E3           MOV      R0,#+88
   \   00000188   7C0D80E3           ORR      R0,R0,#0x1F00
   \   0000018C   000056E1           CMP      R6,R0
   \   00000190   0600001A           BNE      ??ST165540Uart_7
     55              case C_UART_SWPRO_MODBUS:
     56                  if (BdRate <= 19200) {
   \   00000194   10009DE5           LDR      R0,[SP, #+16]
   \   00000198   0110A0E3           MOV      R1,#+1
   \   0000019C   4B1C81E3           ORR      R1,R1,#0x4B00
   \   000001A0   010050E1           CMP      R0,R1
   \   000001A4   0810A023           MOVCS    R1,#+8
     57                      EnableFIFO(1);  //EHSMark Was 0
   \   000001A8   0110A033           MOVCC    R1,#+1
   \   000001AC   000000EA           B        ??ST165540Uart_8
     58                  } else {
     59                      //Speed too high to measure time between character so better use FIFO
     60                      EnableFIFO(8);
     61                  }
     62                  break;
     63              default:
     64                  EnableFIFO(8);
   \                     ??ST165540Uart_7:
   \   000001B0   0810A0E3           MOV      R1,#+8
   \                     ??ST165540Uart_8:
   \   000001B4   0400A0E1           MOV      R0,R4
   \   000001B8   ........           BL       ??EnableFIFO
     65                  break;
     66              }
     67              EnableInt();
   \   000001BC   DC1094E5           LDR      R1,[R4, #+220]
   \   000001C0   0400A0E1           MOV      R0,R4
   \   000001C4   001091E5           LDR      R1,[R1, #+0]
   \   000001C8   0FE0A0E1           MOV      LR,PC
   \   000001CC   11FF2FE1           BX       R1
     68          
     69          }
   \   000001D0   0400A0E1           MOV      R0,R4
   \   000001D4   14D08DE2           ADD      SP,SP,#+20
   \   000001D8   F04FBDE8           POP      {R4-R11,LR}
   \   000001DC   1EFF2FE1           BX       LR               ;; return
   \                     ??ST165540Uart_1:
   \   000001E0   ........           DC32     `?<Constant {(unsigned char *)134217728, (unsig`
   \   000001E4   ........           DC32     ??Channels
     70          

   \                                 In segment CODE, align 4, keep-with-next
     71          void ST165540Uart::EnableInt(void) {
     72              switch (PortNumber - FIRST_ST16554_PORT) {
   \                     ??EnableInt:
   \   00000000   802090E5           LDR      R2,[R0, #+128]
   \   00000004   0810A0E3           MOV      R1,#+8
   \   00000008   4A1481E3           ORR      R1,R1,#0x4A000000
   \   0000000C   032052E2           SUBS     R2,R2,#+3
   \   00000010   0600000A           BEQ      ??EnableInt_1
   \   00000014   012052E2           SUBS     R2,R2,#+1
   \   00000018   0700000A           BEQ      ??EnableInt_2
   \   0000001C   012052E2           SUBS     R2,R2,#+1
   \   00000020   0800000A           BEQ      ??EnableInt_3
   \   00000024   012052E2           SUBS     R2,R2,#+1
   \   00000028   0900000A           BEQ      ??EnableInt_4
   \   0000002C   0B0000EA           B        ??EnableInt_5
     73              case 0:
     74                  rINTMSK    &= ~BIT_EINT0;
   \                     ??EnableInt_1:
   \   00000030   002091E5           LDR      R2,[R1, #+0]
   \   00000034   0120C2E3           BIC      R2,R2,#0x1
   \   00000038   070000EA           B        ??EnableInt_6
     75                  break;
     76              case 1:
     77                  rINTMSK    &= ~BIT_EINT1;
   \                     ??EnableInt_2:
   \   0000003C   002091E5           LDR      R2,[R1, #+0]
   \   00000040   0220C2E3           BIC      R2,R2,#0x2
   \   00000044   040000EA           B        ??EnableInt_6
     78                  break;
     79              case 2:
     80                  rINTMSK    &= ~BIT_EINT2;
   \                     ??EnableInt_3:
   \   00000048   002091E5           LDR      R2,[R1, #+0]
   \   0000004C   0420C2E3           BIC      R2,R2,#0x4
   \   00000050   010000EA           B        ??EnableInt_6
     81                  break;
     82              case 3:
     83                  rINTMSK    &= ~BIT_EINT3;
   \                     ??EnableInt_4:
   \   00000054   002091E5           LDR      R2,[R1, #+0]
   \   00000058   0820C2E3           BIC      R2,R2,#0x8
   \                     ??EnableInt_6:
   \   0000005C   002081E5           STR      R2,[R1, #+0]
     84                  break;
     85              default:
     86                  break;
     87              }
     88              UartBase[MCR] = MCR_OUT2;   // Enable interrupt
   \                     ??EnableInt_5:
   \   00000060   E41090E5           LDR      R1,[R0, #+228]
   \   00000064   0820A0E3           MOV      R2,#+8
   \   00000068   0420C1E5           STRB     R2,[R1, #+4]
     89              UartBase[IER] = IER_TBE | IER_RXRDY;
   \   0000006C   E40090E5           LDR      R0,[R0, #+228]
   \   00000070   0310A0E3           MOV      R1,#+3
   \   00000074   0110C0E5           STRB     R1,[R0, #+1]
     90          }
   \   00000078   1EFF2FE1           BX       LR               ;; return
     91          
     92          /******************************************************************************
     93          *
     94          *   Tsn16550PhysicalHasFIFO
     95          */
     96          
     97          

   \                                 In segment CODE, align 4, keep-with-next
     98          FIFOStatus ST165540Uart::PhysicalHasFIFO(void) {
     99              if ((UartBase[FCR] & 0x30) == 0) {
   \                     ??PhysicalHasFIFO:
   \   00000000   E41090E5           LDR      R1,[R0, #+228]
   \   00000004   0220D1E5           LDRB     R2,[R1, #+2]
   \   00000008   300012E3           TST      R2,#0x30
   \   0000000C   0B00001A           BNE      ??PhysicalHasFIFO_1
    100                  if ((UartBase[FCR] & 0xC0) == 0xC0) return (FIFOPresent);
   \   00000010   C02002E2           AND      R2,R2,#0xC0
   \   00000014   C00052E3           CMP      R2,#+192
   \   00000018   0100A003           MOVEQ    R0,#+1
   \   0000001C   1EFF2F01           BXEQ     LR
    101                  /* FIFO not enabeled allready, so we can continue */
    102                  UartBase[FCR] = 0x01;
   \   00000020   0120A0E3           MOV      R2,#+1
   \   00000024   0220C1E5           STRB     R2,[R1, #+2]
    103                  if ((UartBase[FCR] & 0xC0) == 0xC0) return (FIFOPresent);
   \   00000028   E40090E5           LDR      R0,[R0, #+228]
   \   0000002C   0200D0E5           LDRB     R0,[R0, #+2]
   \   00000030   C00000E2           AND      R0,R0,#0xC0
   \   00000034   C00050E3           CMP      R0,#+192
   \   00000038   0100A003           MOVEQ    R0,#+1
   \   0000003C   1EFF2F01           BXEQ     LR
    104                  else return (FIFONotPresent);
    105              } else return (FIFONotPresent);
   \                     ??PhysicalHasFIFO_1:
   \   00000040   0200A0E3           MOV      R0,#+2
   \   00000044   1EFF2FE1           BX       LR               ;; return
    106          }
    107          
    108          /******************************************************************************
    109          *
    110          *   PhysicalHasFIFO
    111          */
    112          
    113          
    114          /******************************************************************************
    115          *
    116          *   HasFIFO
    117          */
    118          

   \                                 In segment CODE, align 4, keep-with-next
    119          bool  ST165540Uart::HasFIFO(void) {
   \                     ??HasFIFO:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    120              if (FIFOInstalled == Unknown) FIFOInstalled = PhysicalHasFIFO();
   \   00000008   E000D4E5           LDRB     R0,[R4, #+224]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0200001A           BNE      ??HasFIFO_1
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       ??PhysicalHasFIFO
   \   0000001C   E000C4E5           STRB     R0,[R4, #+224]
    121              return (FIFOInstalled == FIFOPresent);
   \                     ??HasFIFO_1:
   \   00000020   E000D4E5           LDRB     R0,[R4, #+224]
   \   00000024   1040BDE8           POP      {R4,LR}
   \   00000028   010050E3           CMP      R0,#+1
   \   0000002C   0000A013           MOVNE    R0,#+0
   \   00000030   1EFF2FE1           BX       LR               ;; return
    122          }
    123          
    124          
    125          /******************************************************************************
    126          *
    127          *   EnableFIFO
    128          */
    129          

   \                                 In segment CODE, align 4, keep-with-next
    130          void ST165540Uart::EnableFIFO(int Trigger) {
   \                     ??EnableFIFO:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    131              if (HasFIFO()) switch (Trigger) {
   \   0000000C   ........           BL       ??HasFIFO
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   1400000A           BEQ      ??EnableFIFO_2
   \   00000018   E40094E5           LDR      R0,[R4, #+228]
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   0E0051E3           CMP      R1,#+14
   \   00000024   1000008A           BHI      ??EnableFIFO_2
   \   00000028   012F8FE2           ADR      R2,??EnableFIFO_1
   \   0000002C   0120D2E7           LDRB     R2,[R2, R1]
   \   00000030   02F18FE0           ADD      PC,PC,R2, LSL #+2
   \                     ??EnableFIFO_1:
   \   00000034   03050D0D           DC8      +3,+5,+13,+13
   \   00000038   070D0D0D           DC8      +7,+13,+13,+13
   \   0000003C   090D0D0D           DC8      +9,+13,+13,+13
   \   00000040   0D0D0B00           DC8      +13,+13,+11,+0
    132                  case  0:
    133                      UartBase[FCR] = 0x00; break;
   \                     ??EnableFIFO_3:
   \   00000044   0010A0E3           MOV      R1,#+0
   \   00000048   060000EA           B        ??EnableFIFO_4
    134                  case  1:
    135                      UartBase[FCR] = 0x01; break;
   \                     ??EnableFIFO_5:
   \   0000004C   0110A0E3           MOV      R1,#+1
   \   00000050   040000EA           B        ??EnableFIFO_4
    136                  case  4:
    137                      UartBase[FCR] = 0x41; break;
   \                     ??EnableFIFO_6:
   \   00000054   4110A0E3           MOV      R1,#+65
   \   00000058   020000EA           B        ??EnableFIFO_4
    138                  case  8:
    139                      UartBase[FCR] = 0x81; break;
   \                     ??EnableFIFO_7:
   \   0000005C   8110A0E3           MOV      R1,#+129
   \   00000060   000000EA           B        ??EnableFIFO_4
    140                  case 14:
    141                      UartBase[FCR] = 0xC1; break;
   \                     ??EnableFIFO_8:
   \   00000064   C110A0E3           MOV      R1,#+193
   \                     ??EnableFIFO_4:
   \   00000068   0210C0E5           STRB     R1,[R0, #+2]
    142                  default:
    143                      /* Do nothing. Should give a message! */
    144                      break;
    145                  } else if (Trigger != 0) {}
    146          
    147              if (Trigger == 0) {
   \                     ??EnableFIFO_2:
   \   0000006C   000055E3           CMP      R5,#+0
    148                  TxFIFOSize = 1;
   \   00000070   0100A003           MOVEQ    R0,#+1
    149              } else {
    150                  TxFIFOSize = 16;
   \   00000074   1000A013           MOVNE    R0,#+16
   \   00000078   1C0084E5           STR      R0,[R4, #+28]
    151              }
    152              //TxFIFOSize = 16-TxTrigger;
    153          
    154              RxFIFOSize = Trigger;
   \   0000007C   205084E5           STR      R5,[R4, #+32]
    155          }
   \   00000080   3040BDE8           POP      {R4,R5,LR}
   \   00000084   1EFF2FE1           BX       LR               ;; return
    156          
    157          
    158          
    159          /*******************************************************************************
    160          *
    161          * 16550IntWr - handle a transmitter interrupt
    162          *
    163          * This routine handles write interrupts from the UART. It reads a character
    164          * and puts it in the transmit holding register of the device for transfer.
    165          *
    166          * If there are no more characters to transmit, transmission is disabled by
    167          * clearing the transmit interrupt enable bit in the IER(int enable register).
    168          *
    169          * RETURNS: N/A
    170          *
    171          */
    172          

   \                                 In segment CODE, align 4, keep-with-next
    173          void ST165540Uart::Transmit(void) {
   \                     ??Transmit:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    174              bool SomeDataSent = false;
    175              if (TxDataPtr) {
   \   00000008   281094E5           LDR      R1,[R4, #+40]
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   000051E3           CMP      R1,#+0
   \   00000018   1600000A           BEQ      ??Transmit_1
    176                  for (int i = 0; i < TxFIFOSize && TxDataPos < TxDataSize; i++) {
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0B0000EA           B        ??Transmit_2
    177                      UartBase[TXB] = TxDataPtr[TxDataPos++];
   \                     ??Transmit_3:
   \   00000024   400094E5           LDR      R0,[R4, #+64]
    178                      TxByteCnt++;
    179                      SomeDataSent = true;
    180                  }
   \   00000028   011081E2           ADD      R1,R1,#+1
   \   0000002C   012080E2           ADD      R2,R0,#+1
   \   00000030   402084E5           STR      R2,[R4, #+64]
   \   00000034   283094E5           LDR      R3,[R4, #+40]
   \   00000038   E42094E5           LDR      R2,[R4, #+228]
   \   0000003C   0300D0E7           LDRB     R0,[R0, +R3]
   \   00000040   0000C2E5           STRB     R0,[R2, #+0]
   \   00000044   D00094E5           LDR      R0,[R4, #+208]
   \   00000048   010080E2           ADD      R0,R0,#+1
   \   0000004C   D00084E5           STR      R0,[R4, #+208]
   \   00000050   0100A0E3           MOV      R0,#+1
   \                     ??Transmit_2:
   \   00000054   1C2094E5           LDR      R2,[R4, #+28]
   \   00000058   020051E1           CMP      R1,R2
   \   0000005C   030000AA           BGE      ??Transmit_4
   \   00000060   402094E5           LDR      R2,[R4, #+64]
   \   00000064   2C3094E5           LDR      R3,[R4, #+44]
   \   00000068   030052E1           CMP      R2,R3
   \   0000006C   ECFFFFBA           BLT      ??Transmit_3
    181              }
    182              if (!SomeDataSent) {
   \                     ??Transmit_4:
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   1100001A           BNE      ??Transmit_5
    183                  switch (SWProtocol) {
   \                     ??Transmit_1:
   \   00000078   A40094E5           LDR      R0,[R4, #+164]
   \   0000007C   5710A0E3           MOV      R1,#+87
   \   00000080   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000084   010050E1           CMP      R0,R1
   \   00000088   0400001A           BNE      ??Transmit_6
    184                  case C_UART_SWPRO_ANPRO10:
    185                      // Turn off the RS485 if nothing to send on this interrupt
    186                      UartBase[MCR] = MCR_OUT2;
   \   0000008C   E40094E5           LDR      R0,[R4, #+228]
   \   00000090   0810A0E3           MOV      R1,#+8
   \   00000094   0410C0E5           STRB     R1,[R0, #+4]
    187                      ProtocolState = pNew_Sync;
   \   00000098   0400A0E3           MOV      R0,#+4
   \   0000009C   4400C4E5           STRB     R0,[R4, #+68]
    188                      break;
    189                  default:
    190                      break;
    191                  }
    192                  if (TxTaskPtr && EventMask) {
   \                     ??Transmit_6:
   \   000000A0   3C1094E5           LDR      R1,[R4, #+60]
   \   000000A4   000051E3           CMP      R1,#+0
   \   000000A8   3800D415           LDRBNE   R0,[R4, #+56]
   \   000000AC   00005013           CMPNE    R0,#+0
   \   000000B0   0200000A           BEQ      ??Transmit_5
    193                      OS_SignalEvent(EventMask, (TSN_TASK *)TxTaskPtr);
   \   000000B4   3800D4E5           LDRB     R0,[R4, #+56]
   \   000000B8   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
    194                      TxTaskPtr = NULL;
   \   000000BC   3C5084E5           STR      R5,[R4, #+60]
    195                  }
    196              }
    197          }
   \                     ??Transmit_5:
   \   000000C0   3040BDE8           POP      {R4,R5,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return
    198          
    199          /*******************************************************************************
    200          *
    201          * 16550IntRd - handle a  receiver interrupt
    202          *
    203          * This routine handles read interrupts from the UART.
    204          *
    205          * RETURNS: N/A
    206          *
    207          */
    208          

   \                                 In segment CODE, align 4, keep-with-next
    209          void ST165540Uart::Receive(void) {
   \                     ??Receive_1:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    210              /* read character from Receive Holding Reg.                 */
    211              /* I will allways read rx register and push it on the stack */
    212              do {
    213                  U8 RxData = UartBase[RXB];
   \                     ??Receive_2:
   \   0000000C   E41094E5           LDR      R1,[R4, #+228]
    214                  OS_PutMailCond1(&RxBuf, (char *)&RxData);
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000018   0010CDE5           STRB     R1,[SP, #+0]
   \   0000001C   0D10A0E1           MOV      R1,SP
   \   00000020   ........           _BLF     OS_PutMailCond1,??OS_PutMailCond1??rA
    215                  RxByteCnt++;
   \   00000024   CC0094E5           LDR      R0,[R4, #+204]
   \   00000028   010080E2           ADD      R0,R0,#+1
   \   0000002C   CC0084E5           STR      R0,[R4, #+204]
    216              } while (UartBase[LSR] & LSR_RXRDY);
   \   00000030   E40094E5           LDR      R0,[R4, #+228]
   \   00000034   0500D0E5           LDRB     R0,[R0, #+5]
   \   00000038   010010E3           TST      R0,#0x1
   \   0000003C   F2FFFF1A           BNE      ??Receive_2
    217              LastRxTime      = (int)OS_Time;
   \   00000040   ........           LDR      R0,??DataTable1  ;; OS_Time
   \   00000044   000090E5           LDR      R0,[R0, #+0]
   \   00000048   480084E5           STR      R0,[R4, #+72]
    218          }
   \   0000004C   1140BDE8           POP      {R0,R4,LR}
   \   00000050   1EFF2FE1           BX       LR               ;; return
    219          /*******************************************************************************
    220          *
    221          * 16550Int - handle a receiver/transmitter interrupt
    222          *
    223          * This routine handles four sources of interrupts from the UART. They are
    224          * prioritized in the following order by the Interrupt Identification Register:
    225          * Receiver Line Status, Received Data Ready, Transmit Holding Register Empty
    226          * and Modem Status.
    227          *
    228          * If there is another character to be transmitted, it sends it.  If
    229          * not, or if a device has never been created for this channel, just
    230          * disable the interrupt.
    231          * When a modem status interrupt occurs, the transmit interrupt is enabled if
    232          * the CTS signal is TRUE.
    233          *
    234          * RETURNS: N/A
    235          */
    236          #pragma diag_suppress=Pe177
    237          

   \                                 In segment CODE, align 4, keep-with-next
    238          void ST165540Uart::HandleInterrupt(void) {
   \                     ??HandleInterrupt:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    239          
    240              volatile U8 interruptID = UartBase[IIR];
   \   0000000C   E41094E5           LDR      R1,[R4, #+228]
   \   00000010   0210D1E5           LDRB     R1,[R1, #+2]
   \   00000014   0010CDE5           STRB     R1,[SP, #+0]
    241          
    242              do {
    243                  interruptID &= IIR_MASK;
   \                     ??HandleInterrupt_1:
   \   00000018   0010DDE5           LDRB     R1,[SP, #+0]
   \   0000001C   0F1001E2           AND      R1,R1,#0xF
   \   00000020   0010CDE5           STRB     R1,[SP, #+0]
    244                  switch (interruptID) {
   \   00000024   DC1094E5           LDR      R1,[R4, #+220]
   \   00000028   0000DDE5           LDRB     R0,[SP, #+0]
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0E00000A           BEQ      ??HandleInterrupt_2
   \   00000034   020050E2           SUBS     R0,R0,#+2
   \   00000038   0700000A           BEQ      ??HandleInterrupt_3
   \   0000003C   020050E2           SUBS     R0,R0,#+2
   \   00000040   08005012           SUBSNE   R0,R0,#+8
   \   00000044   1000001A           BNE      ??HandleInterrupt_4
    245                  case IIR_SEOB:
    246                      {
    247                          U8 LineStatus = UartBase[LSR];
    248                      }
    249                      break;
    250                  case IIR_TOUT:
    251                  case IIR_RBRF:
    252                      Receive();
   \   00000048   0C1091E5           LDR      R1,[R1, #+12]
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   0FE0A0E1           MOV      LR,PC
   \   00000054   11FF2FE1           BX       R1
   \   00000058   0B0000EA           B        ??HandleInterrupt_4
    253                      break;
    254                  case IIR_THRE:
    255                      Transmit();
   \                     ??HandleInterrupt_3:
   \   0000005C   1C1091E5           LDR      R1,[R1, #+28]
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   0FE0A0E1           MOV      LR,PC
   \   00000068   11FF2FE1           BX       R1
   \   0000006C   060000EA           B        ??HandleInterrupt_4
    256                      break;
    257                  case IIR_MSTAT:
    258                      {     /* Should never come her but anyway be a little prepared for the future */
    259                          /* modem status register */
    260                          U8 msr = UartBase[MSR];
    261          
    262                          /* if CTS is asserted by modem, enable tx interrupt */
    263          
    264                          if ((msr & MSR_CTS) && (msr & MSR_DCTS)) {
   \                     ??HandleInterrupt_2:
   \   00000070   E40094E5           LDR      R0,[R4, #+228]
   \   00000074   0610D0E5           LDRB     R1,[R0, #+6]
   \   00000078   111001E2           AND      R1,R1,#0x11
   \   0000007C   110051E3           CMP      R1,#+17
    265                              UartBase[IER] = IER_TBE | IER_RXRDY | IER_MSI;
   \   00000080   0B10A003           MOVEQ    R1,#+11
    266                          } else {
    267                              UartBase[IER] = IER_RXRDY | IER_MSI;
   \   00000084   0910A013           MOVNE    R1,#+9
   \   00000088   0110C0E5           STRB     R1,[R0, #+1]
    268                          }
    269                      }
    270                      break;
    271                  }
    272                  interruptID = UartBase[IIR];
   \                     ??HandleInterrupt_4:
   \   0000008C   E41094E5           LDR      R1,[R4, #+228]
   \   00000090   0210D1E5           LDRB     R1,[R1, #+2]
   \   00000094   0010CDE5           STRB     R1,[SP, #+0]
    273              } while ((interruptID & 0x01) == 0);
   \   00000098   0000DDE5           LDRB     R0,[SP, #+0]
   \   0000009C   010010E3           TST      R0,#0x1
   \   000000A0   DCFFFF0A           BEQ      ??HandleInterrupt_1
    274          }
   \   000000A4   1140BDE8           POP      {R0,R4,LR}
   \   000000A8   1EFF2FE1           BX       LR               ;; return
    275          

   \                                 In segment CODE, align 4, keep-with-next
    276          void ST165540Uart::ActivateTx(void) {
   \                     ??ActivateTx:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    277              // Turn on the RS485 if nothing to send on this interrupt
    278              UartBase[MCR] = MCR_OUT2 | MCR_RTS;
   \   00000008   E40094E5           LDR      R0,[R4, #+228]
   \   0000000C   0A10A0E3           MOV      R1,#+10
   \   00000010   0410C0E5           STRB     R1,[R0, #+4]
    279              ProtocolState = pInTx;
   \   00000014   0200A0E3           MOV      R0,#+2
   \   00000018   4400C4E5           STRB     R0,[R4, #+68]
    280              switch (SWProtocol) {
   \   0000001C   A40094E5           LDR      R0,[R4, #+164]
   \   00000020   5710A0E3           MOV      R1,#+87
   \   00000024   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000028   010050E1           CMP      R0,R1
   \   0000002C   0500001A           BNE      ??ActivateTx_1
    281              case C_UART_SWPRO_ANPRO10:
    282                  TxDataPtr[TxDataSize++] = 0x0;
   \   00000030   2C0094E5           LDR      R0,[R4, #+44]
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   011080E2           ADD      R1,R0,#+1
   \   0000003C   2C1084E5           STR      R1,[R4, #+44]
   \   00000040   281094E5           LDR      R1,[R4, #+40]
   \   00000044   0120C0E7           STRB     R2,[R0, +R1]
    283                  break;
    284              default:
    285                  break;
    286              }
    287              LastTxTime   = OS_Time;
   \                     ??ActivateTx_1:
   \   00000048   ........           LDR      R0,??DataTable1  ;; OS_Time
   \   0000004C   000090E5           LDR      R0,[R0, #+0]
   \   00000050   E80084E5           STR      R0,[R4, #+232]
    288              OS_Delay(RS485_ON_DELAY);
   \   00000054   0200A0E3           MOV      R0,#+2
   \   00000058   ........           _BLF     OS_Delay,??OS_Delay??rA
    289              UartBase[TXB] = TxDataPtr[TxDataPos++];
   \   0000005C   400094E5           LDR      R0,[R4, #+64]
   \   00000060   011080E2           ADD      R1,R0,#+1
   \   00000064   401084E5           STR      R1,[R4, #+64]
   \   00000068   282094E5           LDR      R2,[R4, #+40]
   \   0000006C   E41094E5           LDR      R1,[R4, #+228]
   \   00000070   0200D0E7           LDRB     R0,[R0, +R2]
   \   00000074   0000C1E5           STRB     R0,[R1, #+0]
    290          }
   \   00000078   1040BDE8           POP      {R4,LR}
   \   0000007C   1EFF2FE1           BX       LR               ;; return
    291          

   \                                 In segment CODE, align 4, keep-with-next
    292          void ST165540Uart::DeactivateTx(void) {
    293              // Turn off the RS485
    294              if (HWProtocol == C_UART_HWPRO_485) {
   \                     ??DeactivateTx:
   \   00000000   A01090E5           LDR      R1,[R0, #+160]
   \   00000004   4C20A0E3           MOV      R2,#+76
   \   00000008   7C2D82E3           ORR      R2,R2,#0x1F00
   \   0000000C   020051E1           CMP      R1,R2
    295                  UartBase[MCR] = MCR_OUT2;
   \   00000010   E4009005           LDREQ    R0,[R0, #+228]
   \   00000014   0810A003           MOVEQ    R1,#+8
   \   00000018   0410C005           STRBEQ   R1,[R0, #+4]
    296              }
    297          }
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    298          

   \                                 In segment CODE, align 4, keep-with-next
    299          bool ST165540Uart::Send(U8 *MyData, int Size, char EventMsk, bool Wait) {
   \                     ??Send:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   2060DDE5           LDRB     R6,[SP, #+32]
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0190A0E1           MOV      R9,R1
   \   00000010   02A0A0E1           MOV      R10,R2
   \   00000014   0350A0E1           MOV      R5,R3
    300              bool TxOk = false;
   \   00000018   0070A0E3           MOV      R7,#+0
   \   0000001C   0080A0E3           MOV      R8,#+0
    301              if (Size) {
   \   00000020   00005AE3           CMP      R10,#+0
   \   00000024   5C00000A           BEQ      ??Send_1
    302                  OS_Use(&TxSema);
   \   00000028   700084E2           ADD      R0,R4,#+112
   \   0000002C   ........           _BLF     OS_Use,??OS_Use??rA
    303                  TxDataPtr   = MyData;
    304                  TxDataSize  = Size;
    305                  TxDataPos   = 0;
    306          
    307                  EventMask = EventMsk;
    308                  if (EventMsk) {
   \   00000030   000055E3           CMP      R5,#+0
    309                      TxTaskPtr = OS_GetpCurrentTask();
   \   00000034   6C019F15           LDRNE    R0,??Send_2      ;; OS_pCurrentTask
   \   00000038   289084E5           STR      R9,[R4, #+40]
   \   0000003C   2CA084E5           STR      R10,[R4, #+44]
   \   00000040   407084E5           STR      R7,[R4, #+64]
   \   00000044   3850C4E5           STRB     R5,[R4, #+56]
   \   00000048   00009015           LDRNE    R0,[R0, #+0]
    310                  } else {
    311                      TxTaskPtr = NULL;
    312                  }
    313                  int sendDelay = (130000 * TxDataSize) / BaudRate + RS485_EXTRA_DELAY;
   \   0000004C   7C1BA0E3           MOV      R1,#+126976
   \   00000050   0000A003           MOVEQ    R0,#+0
   \   00000054   3C0084E5           STR      R0,[R4, #+60]
   \   00000058   0A00A0E1           MOV      R0,R10
   \   0000005C   BD1E81E3           ORR      R1,R1,#0xBD0
   \   00000060   910000E0           MUL      R0,R1,R0
   \   00000064   AC1094E5           LDR      R1,[R4, #+172]
   \   00000068   ........           _BLF     ??divu32_a,??rA??divu32_a
    314                  switch (SWProtocol) {
   \   0000006C   A40094E5           LDR      R0,[R4, #+164]
   \   00000070   029081E2           ADD      R9,R1,#+2
   \   00000074   5710A0E3           MOV      R1,#+87
   \   00000078   7C1D81E3           ORR      R1,R1,#0x1F00
   \   0000007C   010050E1           CMP      R0,R1
   \   00000080   1A00001A           BNE      ??Send_3
    315                  case C_UART_SWPRO_ANPRO10:
    316                      if (IsMaster) {
   \   00000084   3020D4E5           LDRB     R2,[R4, #+48]
   \   00000088   C80089E2           ADD      R0,R9,#+200
   \   0000008C   0110A0E3           MOV      R1,#+1
   \   00000090   000052E3           CMP      R2,#+0
   \   00000094   0B00000A           BEQ      ??Send_4
    317                          // Asume we have to force the tx if TxRequest = true!
    318                          if (TxRequest || ProtocolState == pNew_Sync) {
   \   00000098   4520D4E5           LDRB     R2,[R4, #+69]
   \   0000009C   000052E3           CMP      R2,#+0
   \   000000A0   0200001A           BNE      ??Send_5
   \   000000A4   4420D4E5           LDRB     R2,[R4, #+68]
   \   000000A8   040052E3           CMP      R2,#+4
   \   000000AC   0200001A           BNE      ??Send_6
    319                              TxRequest = false;
   \                     ??Send_5:
   \   000000B0   0000A0E3           MOV      R0,#+0
   \   000000B4   4500C4E5           STRB     R0,[R4, #+69]
    320                              ActivateTx();
   \   000000B8   0C0000EA           B        ??Send_3
    321                          } else {
    322                              sendDelay += RS485_DELAY;
   \                     ??Send_6:
   \   000000BC   0090A0E1           MOV      R9,R0
    323                              TxRequest = true;
   \   000000C0   4510C4E5           STRB     R1,[R4, #+69]
   \   000000C4   0E0000EA           B        ??Send_7
    324                          }
    325                      } else {
    326                          TxRequest  = true;
   \                     ??Send_4:
   \   000000C8   4510C4E5           STRB     R1,[R4, #+69]
    327                          if (LastRxTime < 10) {
   \   000000CC   481094E5           LDR      R1,[R4, #+72]
   \   000000D0   0A0051E3           CMP      R1,#+10
   \   000000D4   030000AA           BGE      ??Send_8
    328                              sendDelay     += RS485_DELAY; // Abort Tx if not completed within this time
   \   000000D8   0090A0E1           MOV      R9,R0
    329                              ActivateIfTxRequest();
   \   000000DC   0400A0E1           MOV      R0,R4
   \   000000E0   ........           _BLF     ??ActivateIfTxRequest,??ActivateIfTxRequest??rA
   \   000000E4   060000EA           B        ??Send_7
    330                          } else {
    331                              sendDelay     += RS485_DELAY + 1000; // Abort Tx if not completed within this time
   \                     ??Send_8:
   \   000000E8   4B9E89E2           ADD      R9,R9,#+1200
   \   000000EC   040000EA           B        ??Send_7
    332                          }
    333                      }
    334                      break;
    335                  default:
    336                      ActivateTx();
   \                     ??Send_3:
   \   000000F0   DC1094E5           LDR      R1,[R4, #+220]
   \   000000F4   0400A0E1           MOV      R0,R4
   \   000000F8   141091E5           LDR      R1,[R1, #+20]
   \   000000FC   0FE0A0E1           MOV      LR,PC
   \   00000100   11FF2FE1           BX       R1
    337                      break;
    338                  }
    339          
    340                  char Status = 0;
   \                     ??Send_7:
   \   00000104   00A0A0E3           MOV      R10,#+0
    341                  if (Wait && EventMsk) {
   \   00000108   000056E3           CMP      R6,#+0
   \   0000010C   00005513           CMPNE    R5,#+0
   \   00000110   1D00000A           BEQ      ??Send_9
    342                      Status = OS_WaitEventTimed(EventMsk, sendDelay);
   \   00000114   0910A0E1           MOV      R1,R9
   \   00000118   0500A0E1           MOV      R0,R5
   \   0000011C   ........           _BLF     OS_WaitEventTimed,??OS_WaitEventTimed??rA
   \   00000120   00A0A0E1           MOV      R10,R0
    343                      TxTaskPtr = NULL;
   \   00000124   3C7084E5           STR      R7,[R4, #+60]
    344                      switch (SWProtocol) {
   \   00000128   A40094E5           LDR      R0,[R4, #+164]
   \   0000012C   5710A0E3           MOV      R1,#+87
   \   00000130   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000134   010050E1           CMP      R0,R1
   \   00000138   0C00001A           BNE      ??Send_10
    345                      case C_UART_SWPRO_ANPRO10:
    346                          ClearRxBuffer();
   \   0000013C   DC1094E5           LDR      R1,[R4, #+220]
   \   00000140   0400A0E1           MOV      R0,R4
   \   00000144   101091E5           LDR      R1,[R1, #+16]
   \   00000148   0FE0A0E1           MOV      LR,PC
   \   0000014C   11FF2FE1           BX       R1
    347                          DeactivateTx();
   \   00000150   DC1094E5           LDR      R1,[R4, #+220]
   \   00000154   0400A0E1           MOV      R0,R4
   \   00000158   181091E5           LDR      R1,[R1, #+24]
   \   0000015C   0FE0A0E1           MOV      LR,PC
   \   00000160   11FF2FE1           BX       R1
    348                          ProtocolState = pNew_Sync;
   \   00000164   0400A0E3           MOV      R0,#+4
   \   00000168   4400C4E5           STRB     R0,[R4, #+68]
   \   0000016C   060000EA           B        ??Send_9
    349                          break;
    350                      default:
    351                          OS_Delay(RS485_ON_DELAY);
   \                     ??Send_10:
   \   00000170   0200A0E3           MOV      R0,#+2
   \   00000174   ........           _BLF     OS_Delay,??OS_Delay??rA
    352                          DeactivateTx();
   \   00000178   DC1094E5           LDR      R1,[R4, #+220]
   \   0000017C   0400A0E1           MOV      R0,R4
   \   00000180   181091E5           LDR      R1,[R1, #+24]
   \   00000184   0FE0A0E1           MOV      LR,PC
   \   00000188   11FF2FE1           BX       R1
    353                          break;
    354                      }
    355                  }
    356                  OS_Unuse(&TxSema);
   \                     ??Send_9:
   \   0000018C   700084E2           ADD      R0,R4,#+112
   \   00000190   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    357                  TxOk = (Status == EventMsk);
   \   00000194   05005AE1           CMP      R10,R5
   \   00000198   0180A003           MOVEQ    R8,#+1
    358              }
    359          
    360              return (TxOk);
   \                     ??Send_1:
   \   0000019C   0800A0E1           MOV      R0,R8
   \   000001A0   F047BDE8           POP      {R4-R10,LR}
   \   000001A4   1EFF2FE1           BX       LR               ;; return
   \                     ??Send_2:
   \   000001A8   ........           DC32     OS_pCurrentTask
    361          }
    362          
    363          
    364          

   \                                 In segment CODE, align 4, keep-with-next
    365          bool ST165540Uart::Receive(U8 *MyData, int Size, int TimeOut) {
   \                     ??Receive:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
    366              int Cnt = 0;
   \   00000014   0080A0E3           MOV      R8,#+0
    367              bool ReceivedData = true;
   \                     ??Receive_3:
   \   00000018   0100A0E3           MOV      R0,#+1
   \   0000001C   060058E1           CMP      R8,R6
   \   00000020   070000AA           BGE      ??Receive_4
    368          
    369              while (ReceivedData && Cnt < Size) {
    370                  ReceivedData = !OS_GetMailTimed(&RxBuf, (char *)&MyData[Cnt++], TimeOut);
   \   00000024   0720A0E1           MOV      R2,R7
   \   00000028   051088E0           ADD      R1,R8,R5
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           _BLF     OS_GetMailTimed,??OS_GetMailTimed??rA
   \   00000034   018088E2           ADD      R8,R8,#+1
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   F5FFFF0A           BEQ      ??Receive_3
   \   00000040   0000A0E3           MOV      R0,#+0
    371              }
    372              return (ReceivedData);
   \                     ??Receive_4:
   \   00000044   F041BDE8           POP      {R4-R8,LR}
   \   00000048   1EFF2FE1           BX       LR               ;; return
    373          }
    374          

   \                                 In segment CODE, align 4, keep-with-next
    375          void ST165540Uart::ClearRxBuffer(void) {
   \                     ??ClearRxBuffer:
   \   00000000   00402DE9           PUSH     {LR}
    376              OS_ClearMB(&RxBuf);
   \   00000004   ........           _BLF     OS_ClearMB,??OS_ClearMB??rA
    377              //for(int i=0; i < 8; i++){
    378              //	U8 RxData = UartBase[RXB];
    379              //}
    380          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    381          

   \                                 In segment CODE, align 4, keep-with-next
    382          bool ST165540Uart::HasMore(void) {
    383              int RxBytesInBuf = OS_GetMessageCnt(&RxBuf);
    384              return (bool(RxBytesInBuf));
   \                     ??HasMore:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0100A013           MOVNE    R0,#+1
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    385          }

   \                                 In segment DIFUNCT, align 4, keep-with-next, root
   \   00000000                      REQUIRE ?call_ctors
   \   00000000   ........           DC32    ??__sti__routine

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {(unsigned char *)134217728, (unsig`:
   \   00000000   000000080000       DC32 8000000H, 10000000H, 18000000H, 20000000H
   \              001000000018
   \              00000020    
   \   __vtbl_entry const __data ST165540Uart::__vtbl[10]
   \                     ??__vtbl:
   \   00000010   ............       DC32 ??EnableInt, ??Send, ??Receive, ??Receive_1, ??ClearRxBuffer
   \              ............
   \              ............
   \              ....        
   \   00000024   ............       DC32 ??ActivateTx, ??DeactivateTx, ??Transmit, ??HandleInterrupt
   \              ............
   \              ........    
   \   00000034   ........           DC32 ??HasMore

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs ST165540Uart &ST165540Uart::new ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
   \                     `??new ST165540Uart`:
   \   00000000   FF4F2DE9           PUSH     {R0-R11,LR}
   \   00000004   3C409DE5           LDR      R4,[SP, #+60]
   \   00000008   40509DE5           LDR      R5,[SP, #+64]
   \   0000000C   44609DE5           LDR      R6,[SP, #+68]
   \   00000010   4870DDE5           LDRB     R7,[SP, #+72]
   \   00000014   4C809DE5           LDR      R8,[SP, #+76]
   \   00000018   5090DDE5           LDRB     R9,[SP, #+80]
   \   0000001C   54A09DE5           LDR      R10,[SP, #+84]
   \   00000020   58B09DE5           LDR      R11,[SP, #+88]
   \   00000024   EC00A0E3           MOV      R0,#+236
   \   00000028   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   1200000A           BEQ      `??new ST165540Uart_1`
   \   00000034   00082DE9           PUSH     {R11}
   \   00000038   00042DE9           PUSH     {R10}
   \   0000003C   00022DE9           PUSH     {R9}
   \   00000040   00012DE9           PUSH     {R8}
   \   00000044   80002DE9           PUSH     {R7}
   \   00000048   40002DE9           PUSH     {R6}
   \   0000004C   20002DE9           PUSH     {R5}
   \   00000050   10002DE9           PUSH     {R4}
   \   00000054   58109DE5           LDR      R1,[SP, #+88]
   \   00000058   02002DE9           PUSH     {R1}
   \   0000005C   5810DDE5           LDRB     R1,[SP, #+88]
   \   00000060   02002DE9           PUSH     {R1}
   \   00000064   34109DE5           LDR      R1,[SP, #+52]
   \   00000068   02002DE9           PUSH     {R1}
   \   0000006C   34309DE5           LDR      R3,[SP, #+52]
   \   00000070   30209DE5           LDR      R2,[SP, #+48]
   \   00000074   2C109DE5           LDR      R1,[SP, #+44]
   \   00000078   ........           BL       ??ST165540Uart
   \   0000007C   2CD08DE2           ADD      SP,SP,#+44
   \                     `??new ST165540Uart_1`:
   \   00000080   10D08DE2           ADD      SP,SP,#+16
   \   00000084   F04FBDE8           POP      {R4-R11,LR}
   \   00000088   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   static __??Code32?? __intrinsic __code __interwork __atpcs void __sti__routine()
   \                     ??__sti__routine:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     OS_Time
    386          

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     ST165540Uart::ActivateTx()         8
     ST165540Uart::ClearRxBuffer()      4
     ST165540Uart::DeactivateTx()       0
     ST165540Uart::EnableFIFO(int)     12
     ST165540Uart::EnableInt()          0
     ST165540Uart::HandleInterrupt()
                                       12
     ST165540Uart::HasFIFO()            8
     ST165540Uart::HasMore()            0
     ST165540Uart::PhysicalHasFIFO()
                                        0
     ST165540Uart::Receive()           12
     ST165540Uart::Receive(unsigned char *, int, int)
                                       28
     ST165540Uart::ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                      100
     ST165540Uart::Send(unsigned char *, int, char, bool)
                                       32
     ST165540Uart::Transmit()          12
     ST165540Uart::new ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                       96
     __sti__routine()                   0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     ST165540Uart::ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                     488
     ST165540Uart::EnableInt()       124
     ST165540Uart::PhysicalHasFIFO()
                                      72
     ST165540Uart::HasFIFO()          52
     ST165540Uart::EnableFIFO(int)   136
     ST165540Uart::Transmit()        200
     ST165540Uart::Receive()          84
     ST165540Uart::HandleInterrupt()
                                     172
     ST165540Uart::ActivateTx()      128
     ST165540Uart::DeactivateTx()     32
     ST165540Uart::Send(unsigned char *, int, char, bool)
                                     428
     ST165540Uart::Receive(unsigned char *, int, int)
                                      76
     ST165540Uart::ClearRxBuffer()    16
     ST165540Uart::HasMore()          16
     ?<Constant {(unsigned char *)134217728, (unsig
                                      56
     ST165540Uart::new ST165540Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                     140
     __sti__routine()                  4
     ??DataTable1                      4
      Others                         248

 
 2 416 bytes in segment CODE
    56 bytes in segment DATA_C
     4 bytes in segment DIFUNCT
 
 2 176 bytes of CODE  memory (+ 244 bytes shared)
    56 bytes of CONST memory

Errors: none
Warnings: none
