##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:17:23 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\Shared\Src\SCWaterIngress.cpp              #
#    Command line    =  D:\S2Prog\Shared\Src\SCWaterIngress.cpp --fpu None   #
#                       -D OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D   #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -z9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --eec++           #
#                       --dlib_config "C:\Program Files (x86)\IAR            #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl4tpainl8n.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\SCWaterIngress.lst          #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\SCWaterIngress.r79           #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\Shared\Src\SCWaterIngress.cpp
      1          #include "TSNIncludes.h"

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs string::string(string const &)
   \                     ??string:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000018   1C009FE5           LDR      R0,??string_1    ;; ??npos
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   003090E5           LDR      R3,[R0, #+0]
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           _BLF     ??assign,??assign??rA
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   3040BDE8           POP      {R4,R5,LR}
   \   00000038   1EFF2FE1           BX       LR               ;; return
   \                     ??string_1:
   \   0000003C   ........           DC32     ??npos

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void operator+(string const &, string const &)
   \                     `??operator+`:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0250A0E1           MOV      R5,R2
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   ........           _BLF     ??string,??string??rA
   \   00000018   34109FE5           LDR      R1,`??operator+_2`  ;; ??npos
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   003091E5           LDR      R3,[R1, #+0]
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   ........           _BLF     ??append,??append??rA
   \   0000002C   0010A0E1           MOV      R1,R0
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           _BLF     ??string,??string??rA
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   0110A0E3           MOV      R1,#+1
   \   00000040   0D00A0E1           MOV      R0,SP
   \   00000044   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000048   1CD08DE2           ADD      SP,SP,#+28
   \   0000004C   3040BDE8           POP      {R4,R5,LR}
   \   00000050   1EFF2FE1           BX       LR               ;; return
   \                     `??operator+_2`:
   \   00000054   ........           DC32     ??npos

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void operator+(char const *, string const &)
   \                     `??operator+_1`:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   0020A0E3           MOV      R2,#+0
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     strlen,??strlen??rA
   \   0000002C   0020A0E1           MOV      R2,R0
   \   00000030   0510A0E1           MOV      R1,R5
   \   00000034   0D00A0E1           MOV      R0,SP
   \   00000038   ........           _BLF     ??assign_1,??assign??rA_1
   \   0000003C   38009FE5           LDR      R0,`??operator+_3`  ;; ??npos
   \   00000040   0020A0E3           MOV      R2,#+0
   \   00000044   003090E5           LDR      R3,[R0, #+0]
   \   00000048   0610A0E1           MOV      R1,R6
   \   0000004C   0D00A0E1           MOV      R0,SP
   \   00000050   ........           _BLF     ??append,??append??rA
   \   00000054   0010A0E1           MOV      R1,R0
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           _BLF     ??string,??string??rA
   \   00000060   0020A0E3           MOV      R2,#+0
   \   00000064   0110A0E3           MOV      R1,#+1
   \   00000068   0D00A0E1           MOV      R0,SP
   \   0000006C   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000070   1CD08DE2           ADD      SP,SP,#+28
   \   00000074   7040BDE8           POP      {R4-R6,LR}
   \   00000078   1EFF2FE1           BX       LR               ;; return
   \                     `??operator+_3`:
   \   0000007C   ........           DC32     ??npos
      2          #pragma hdrstop
      3          #ifdef BORLAND
      4              #pragma package(smart_init)
      5          #endif
      6          
      7          //---------------------------------------------------------------------------

   \                                 In segment DATA_I, align 4, align-sorted
      8          ValueList SCWaterIngress::SCWaterIngressValueList[] =  {
   \                     ??SCWaterIngressValueList:
   \   00000000                      DS8 84
   \   00000054                      REQUIRE `?<Initializer for SCWaterIngressValueList>`
      9          	{L_WORD304          ,L_WORD237,SVT_BLANK},                                  //    {"Unused"       ,"",SVT_BLANK},
     10          	{L_WORD24           ,L_WORD237,SVT_IO_PROG_VERSION},                        //    {"ProgVersion"  ,"",SVT_IO_PROG_VERSION},
     11          	{L_WORD390          ,L_WORD237,SVT_IO_SERIAL_NUMBER},                       //    {"Serial Number","",SVT_IO_SERIAL_NUMBER},
     12          	{L_WORD391          ,L_WORD237,SVT_IO_UNIT_STATUS},                         //    {"Unit status"  ,"",SVT_IO_UNIT_STATUS},
     13          	{L_WORD392          ,L_WORD237,SVT_IO_CARD_STATUS},                         //    {"Card status"  ,"",SVT_IO_CARD_STATUS},
     14          	{L_WORD386          ,L_WORD237,SVT_IO_FAIL_CNT_CHK},                        //    {"Fail cnt chk" ,"",SVT_IO_FAIL_CNT_CHK},
     15          	{L_WORD387          ,L_WORD237,SVT_IO_FAIL_CNT_TOT},                        //    {"Fail cnt tot" ,"",SVT_IO_FAIL_CNT_TOT},
     16          
     17          };
     18          

   \                                 In segment CODE, align 4, keep-with-next
     19          SCWaterIngress::SCWaterIngress(PROIOComponent *IOCompPtr, PRogramObject *ElementPtr,IOUnit *IOModulePtr):SignalConverter(IOCompPtr,ElementPtr,IOModulePtr)
   \                     ??SCWaterIngress:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
     20          {
   \   00000004   04729FE5           LDR      R7,??SCWaterIngress_2+0x8  ;; ??__vtbl
   \   00000008   FCD04DE2           SUB      SP,SP,#+252
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0160A0E1           MOV      R6,R1
   \   00000014   0250A0E1           MOV      R5,R2
   \   00000018   ........           _BLF     ??SignalConverter,??SignalConverter??rA
     21              IDNumber = (C_SC_W_INGRESS << 16 )+ObjectSet.size();
   \   0000001C   F0019FE5           LDR      R0,??SCWaterIngress_2+0xC  ;; ??ObjectSet + 16
   \   00000020   A47084E5           STR      R7,[R4, #+164]
   \   00000024   000090E5           LDR      R0,[R0, #+0]
   \   00000028   8016A0E3           MOV      R1,#+134217728
   \   0000002C   881981E3           ORR      R1,R1,#0x220000
   \   00000030   000081E0           ADD      R0,R1,R0
   \   00000034   9C0084E5           STR      R0,[R4, #+156]
     22              Type     = C_SC_W_INGRESS;
   \   00000038   2108A0E1           MOV      R0,R1, LSR #+16
   \   0000003C   A00084E5           STR      R0,[R4, #+160]
     23              for ( int i=0; i < MAX_W_INGR_CHANNELS; i++ ) {
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   0020A0E3           MOV      R2,#+0
     24                  ChStatus[i]    = 0;
   \                     ??SCWaterIngress_3:
   \   00000048   041080E0           ADD      R1,R0,R4
   \   0000004C   4822C1E5           STRB     R2,[R1, #+584]
     25              }
   \   00000050   010080E2           ADD      R0,R0,#+1
   \   00000054   020050E3           CMP      R0,#+2
   \   00000058   FAFFFFBA           BLT      ??SCWaterIngress_3
     26              switch ( IOCompPtr->Type ) {
   \   0000005C   A00096E5           LDR      R0,[R6, #+160]
   \   00000060   850040E2           SUB      R0,R0,#+133
   \   00000064   800E40E2           SUB      R0,R0,#+2048
   \   00000068   050050E3           CMP      R0,#+5
   \   0000006C   6200008A           BHI      ??SCWaterIngress_4
   \   00000070   011F8FE2           ADR      R1,??SCWaterIngress_1
   \   00000074   0010D1E7           LDRB     R1,[R1, R0]
   \   00000078   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??SCWaterIngress_1:
   \   0000007C   01214001           DC8      +1,+33,+64,+1
   \   00000080   21400000           DC8      +33,+64,+0,+0
     27              case C_AI_WATERINGR_TEMP:
     28              case C_AI_WATERINGRESS  :
     29                  WIType = C_AI_WATERINGRESS;
   \                     ??SCWaterIngress_5:
   \   00000084   8500A0E3           MOV      R0,#+133
   \   00000088   800E80E3           ORR      R0,R0,#0x800
   \   0000008C   4C0284E5           STR      R0,[R4, #+588]
     30                  Name = "WIngr:"+(AnsiString)(IOChannel+1);
   \   00000090   7C0194E5           LDR      R0,[R4, #+380]
   \   00000094   011080E2           ADD      R1,R0,#+1
   \   00000098   38008DE2           ADD      R0,SP,#+56
   \   0000009C   ........           _BLF     ??AnsiString,??AnsiString??rA
   \   000000A0   0020A0E1           MOV      R2,R0
   \   000000A4   941087E2           ADD      R1,R7,#+148
   \   000000A8   1C008DE2           ADD      R0,SP,#+28
   \   000000AC   ........           _BLF     `??operator+_1`,`??operator+??rA`
   \   000000B0   1C108DE2           ADD      R1,SP,#+28
   \   000000B4   0D00A0E1           MOV      R0,SP
   \   000000B8   ........           _BLF     ??AnsiString_1,??AnsiString??rA_1
   \   000000BC   0010A0E1           MOV      R1,R0
   \   000000C0   ........           LDR      R0,??DataTable3  ;; ??npos
   \   000000C4   0020A0E3           MOV      R2,#+0
   \   000000C8   003090E5           LDR      R3,[R0, #+0]
   \   000000CC   440084E2           ADD      R0,R4,#+68
   \   000000D0   ........           _BLF     ??assign,??assign??rA
   \   000000D4   0020A0E3           MOV      R2,#+0
   \   000000D8   0110A0E3           MOV      R1,#+1
   \   000000DC   0D00A0E1           MOV      R0,SP
   \   000000E0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000E4   0020A0E3           MOV      R2,#+0
   \   000000E8   0110A0E3           MOV      R1,#+1
   \   000000EC   1C008DE2           ADD      R0,SP,#+28
   \   000000F0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000F4   0020A0E3           MOV      R2,#+0
   \   000000F8   0110A0E3           MOV      R1,#+1
   \   000000FC   38008DE2           ADD      R0,SP,#+56
   \   00000100   3C0000EA           B        ??SCWaterIngress_6
     31                  break;
     32              case C_AI_WATERINGR_MAIN:
     33              case C_AI_WATERINGR_TEMP_M:
     34                  WIType = C_AI_WATERINGR_MAIN;
   \                     ??SCWaterIngress_7:
   \   00000104   8600A0E3           MOV      R0,#+134
   \   00000108   800E80E3           ORR      R0,R0,#0x800
   \   0000010C   4C0284E5           STR      R0,[R4, #+588]
     35                  Name = ElementPtr->Name+(AnsiString)"(M)";
   \   00000110   3C1F8FE2           ADR      R1,??SCWaterIngress_2  ;; "(M)"
   \   00000114   8C008DE2           ADD      R0,SP,#+140
   \   00000118   ........           _BLF     ??AnsiString_2,??AnsiString??rA_2
   \   0000011C   0020A0E1           MOV      R2,R0
   \   00000120   441085E2           ADD      R1,R5,#+68
   \   00000124   70008DE2           ADD      R0,SP,#+112
   \   00000128   ........           _BLF     `??operator+`,`??operator+??rA_1`
   \   0000012C   70108DE2           ADD      R1,SP,#+112
   \   00000130   54008DE2           ADD      R0,SP,#+84
   \   00000134   ........           _BLF     ??AnsiString_1,??AnsiString??rA_1
   \   00000138   ........           LDR      R1,??DataTable3  ;; ??npos
   \   0000013C   0020A0E3           MOV      R2,#+0
   \   00000140   003091E5           LDR      R3,[R1, #+0]
   \   00000144   0010A0E1           MOV      R1,R0
   \   00000148   440084E2           ADD      R0,R4,#+68
   \   0000014C   ........           _BLF     ??assign,??assign??rA
   \   00000150   0020A0E3           MOV      R2,#+0
   \   00000154   0110A0E3           MOV      R1,#+1
   \   00000158   54008DE2           ADD      R0,SP,#+84
   \   0000015C   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000160   0020A0E3           MOV      R2,#+0
   \   00000164   0110A0E3           MOV      R1,#+1
   \   00000168   70008DE2           ADD      R0,SP,#+112
   \   0000016C   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000170   0020A0E3           MOV      R2,#+0
   \   00000174   0110A0E3           MOV      R1,#+1
   \   00000178   8C008DE2           ADD      R0,SP,#+140
   \   0000017C   1D0000EA           B        ??SCWaterIngress_6
     36                  break;
     37              case C_AI_WATERINGR_PRE:
     38              case C_AI_WATERINGR_TEMP_P:
     39                  WIType = C_AI_WATERINGR_PRE;
   \                     ??SCWaterIngress_8:
   \   00000180   8700A0E3           MOV      R0,#+135
   \   00000184   800E80E3           ORR      R0,R0,#0x800
   \   00000188   4C0284E5           STR      R0,[R4, #+588]
     40                  Name = ElementPtr->Name+(AnsiString)"(P)";
   \   0000018C   1E1F8FE2           ADR      R1,??SCWaterIngress_2+0x4  ;; "(P)"
   \   00000190   E0008DE2           ADD      R0,SP,#+224
   \   00000194   ........           _BLF     ??AnsiString_2,??AnsiString??rA_2
   \   00000198   0020A0E1           MOV      R2,R0
   \   0000019C   441085E2           ADD      R1,R5,#+68
   \   000001A0   C4008DE2           ADD      R0,SP,#+196
   \   000001A4   ........           _BLF     `??operator+`,`??operator+??rA_1`
   \   000001A8   C4108DE2           ADD      R1,SP,#+196
   \   000001AC   A8008DE2           ADD      R0,SP,#+168
   \   000001B0   ........           _BLF     ??AnsiString_1,??AnsiString??rA_1
   \   000001B4   ........           LDR      R1,??DataTable3  ;; ??npos
   \   000001B8   0020A0E3           MOV      R2,#+0
   \   000001BC   003091E5           LDR      R3,[R1, #+0]
   \   000001C0   0010A0E1           MOV      R1,R0
   \   000001C4   440084E2           ADD      R0,R4,#+68
   \   000001C8   ........           _BLF     ??assign,??assign??rA
   \   000001CC   0020A0E3           MOV      R2,#+0
   \   000001D0   0110A0E3           MOV      R1,#+1
   \   000001D4   A8008DE2           ADD      R0,SP,#+168
   \   000001D8   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000001DC   0020A0E3           MOV      R2,#+0
   \   000001E0   0110A0E3           MOV      R1,#+1
   \   000001E4   C4008DE2           ADD      R0,SP,#+196
   \   000001E8   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000001EC   0020A0E3           MOV      R2,#+0
   \   000001F0   0110A0E3           MOV      R1,#+1
   \   000001F4   E0008DE2           ADD      R0,SP,#+224
   \                     ??SCWaterIngress_6:
   \   000001F8   ........           _BLF     ??_Tidy,??_Tidy??rA
     41                  break;
     42              }
     43          }
   \                     ??SCWaterIngress_4:
   \   000001FC   0400A0E1           MOV      R0,R4
   \   00000200   FCD08DE2           ADD      SP,SP,#+252
   \   00000204   ........           B        ?Subroutine16
   \                     ??SCWaterIngress_2:
   \   00000208   284D2900           DC8      "(M)"
   \   0000020C   28502900           DC8      "(P)"
   \   00000210   ........           DC32     ??__vtbl
   \   00000214   ........           DC32     ??ObjectSet + 16

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine16:
   \   00000000   F040BDE8           POP      {R4-R7,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
   \                     ??Subroutine16_0:
   \   00000008   00000000           DC8      "",+0,+0,+0
     44          

   \                                 In segment CODE, align 4, keep-with-next
     45          SCWaterIngress::~SCWaterIngress(void)
     46          {
   \                     `?~SCWaterIngress`:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   0500000A           BEQ      `?~SCWaterIngress_1`
     47          }
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   ........           _BLF     `?~SignalConverter`,`?~SignalConverter??rA`
   \   0000001C   010015E3           TST      R5,#0x1
   \   00000020   0100000A           BEQ      `?~SCWaterIngress_1`
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \                     `?~SCWaterIngress_1`:
   \   0000002C   ........           B        ?Subroutine17

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine17:
   \   00000000   3040BDE8           POP      {R4,R5,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
     48          //---------------------------------------------------------------------------
     49          
     50          
     51          #ifndef ANCONF
     52          ///////////////////////////////////////////////////////////////
     53          //
     54          // Routines for the librarian
     55          //
     56          ///////////////////////////////////////////////////////////////
     57          

   \                                 In segment CODE, align 4, keep-with-next
     58          int  SCWaterIngress::GetValue(int ValueId, int Index, float &MyRetValue, int &DecPnt, int &Unit)
     59          {
   \                     ??GetValue:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   18509DE5           LDR      R5,[SP, #+24]
   \   00000008   1C609DE5           LDR      R6,[SP, #+28]
   \   0000000C   0340A0E1           MOV      R4,R3
     60              int Status = GETVAL_NO_ERR;
   \   00000010   0070A0E3           MOV      R7,#+0
     61              switch ( ValueId ) {
   \   00000014   823080E0           ADD      R3,R0,R2, LSL #+1
   \   00000018   843F83E2           ADD      R3,R3,#+528
   \   0000001C   0080A0E3           MOV      R8,#+0
   \   00000020   B6E0A0E3           MOV      LR,#+182
   \   00000024   40EE8EE3           ORR      LR,LR,#0x400
   \   00000028   0E0051E1           CMP      R1,LR
   \   0000002C   0E00000A           BEQ      ??GetValue_2
   \   00000030   39E08EE2           ADD      LR,LR,#+57
   \   00000034   0E0051E1           CMP      R1,LR
   \   00000038   1600000A           BEQ      ??GetValue_3
   \   0000003C   4F0E51E3           CMP      R1,#+1264
   \   00000040   0F00000A           BEQ      ??GetValue_4
   \   00000044   02E08EE2           ADD      LR,LR,#+2
   \   00000048   0E0051E1           CMP      R1,LR
   \   0000004C   1300001A           BNE      ??GetValue_5
     62              case SVT_IO_CH_VALUE :
     63                  MyRetValue = MsrdValues[Index];
   \   00000050   020180E0           ADD      R0,R0,R2, LSL #+2
   \   00000054   D80190E5           LDR      R0,[R0, #+472]
   \   00000058   000084E5           STR      R0,[R4, #+0]
     64                  DecPnt     = 3;
   \   0000005C   0300A0E3           MOV      R0,#+3
   \   00000060   000085E5           STR      R0,[R5, #+0]
     65                  Unit       = NO_UNIT;
   \                     ??GetValue_6:
   \   00000064   008086E5           STR      R8,[R6, #+0]
   \   00000068   120000EA           B        ??GetValue_7
     66                  break;
     67              case SVT_IO_CH_STATUS :
     68                  MyRetValue = ChStatus[Index];
   \                     ??GetValue_2:
   \   0000006C   000082E0           ADD      R0,R2,R0
   \   00000070   4802D0E5           LDRB     R0,[R0, #+584]
   \                     ??GetValue_8:
   \   00000074   ........           _BLF     __ulongToFloat,??__ulongToFloat??rA
   \   00000078   000084E5           STR      R0,[R4, #+0]
     69                  DecPnt     = 0;
   \   0000007C   008085E5           STR      R8,[R5, #+0]
     70                  Unit       = NO_UNIT;
   \   00000080   F7FFFFEA           B        ??GetValue_6
     71                  break;
     72              case SVT_IO_CH_CAL_VAL :
     73                  MyRetValue = CalValues[Index];
   \                     ??GetValue_4:
   \   00000084   B000D3E1           LDRH     R0,[R3, #+0]
   \   00000088   ........           _BLF     __ulongToFloat,??__ulongToFloat??rA
   \   0000008C   000084E5           STR      R0,[R4, #+0]
     74                  DecPnt     = 0;
   \   00000090   008085E5           STR      R8,[R5, #+0]
     75                  Unit       = NO_UNIT;
   \   00000094   F2FFFFEA           B        ??GetValue_6
     76                  break;
     77              case SVT_IO_CH_RAW_VAL :
     78                  MyRetValue = RawValues[Index];
   \                     ??GetValue_3:
   \   00000098   BC01D3E1           LDRH     R0,[R3, #+28]
   \   0000009C   F4FFFFEA           B        ??GetValue_8
     79                  DecPnt     = 0;
     80                  Unit       = NO_UNIT;
     81                  break;
     82              default:
     83                  Status = SignalConverter::GetValue(ValueId,Index, MyRetValue,  DecPnt,Unit);
   \                     ??GetValue_5:
   \   000000A0   40002DE9           PUSH     {R6}
   \   000000A4   20002DE9           PUSH     {R5}
   \   000000A8   0430A0E1           MOV      R3,R4
   \   000000AC   ........           _BLF     ??GetValue_1,??GetValue??rA
   \   000000B0   0070A0E1           MOV      R7,R0
   \   000000B4   08D08DE2           ADD      SP,SP,#+8
     84                  break;
     85              }
     86              return(Status);
   \                     ??GetValue_7:
   \   000000B8   0700A0E1           MOV      R0,R7
   \   000000BC   ........           B        ?Subroutine18
     87          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine18:
   \   00000000   F041BDE8           POP      {R4-R8,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
     88          

   \                                 In segment CODE, align 4, keep-with-next
     89          int SCWaterIngress::GetStringValue(int ValueId, int Index, AnsiString &MyString)
     90          {
   \                     ??GetStringValue:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   00C0A0E1           MOV      R12,R0
   \   0000000C   0340A0E1           MOV      R4,R3
     91              int Status = GETVAL_NO_ERR;
   \   00000010   0050A0E3           MOV      R5,#+0
     92              switch ( ValueId ) {
   \   00000014   02318CE0           ADD      R3,R12,R2, LSL #+2
   \   00000018   ........           ADR      R0,??Subroutine16_0  ;; ""
   \   0000001C   68EFA0E3           MOV      LR,#+416
   \   00000020   EC6041E2           SUB      R6,R1,#+236
   \   00000024   406E46E2           SUB      R6,R6,#+1024
   \   00000028   020056E3           CMP      R6,#+2
   \   0000002C   3400008A           BHI      ??GetStringValue_3
   \   00000030   017F8FE2           ADR      R7,??GetStringValue_1
   \   00000034   0670D7E7           LDRB     R7,[R7, R6]
   \   00000038   07F18FE0           ADD      PC,PC,R7, LSL #+2
   \                     ??GetStringValue_1:
   \   0000003C   001B2400           DC8      +0,+27,+36,+0
     93              case SVT_IO_CH_NAME         :
     94                  {
     95                      AnalogInput *IOCPtr = (AnalogInput*)IOComponent[Index];
   \                     ??GetStringValue_4:
   \   00000040   03C09EE7           LDR      R12,[LR, +R3]
     96                      if ( IOCPtr ) {
   \   00000044   00005CE3           CMP      R12,#+0
   \   00000048   0900000A           BEQ      ??GetStringValue_5
     97                          Status = IOCPtr->GetStringValue(SVT_AI_PRONAME,0,MyString);
   \   0000004C   0430A0E1           MOV      R3,R4
   \   00000050   A4409CE5           LDR      R4,[R12, #+164]
   \   00000054   0020A0E3           MOV      R2,#+0
   \   00000058   284094E5           LDR      R4,[R4, #+40]
   \   0000005C   BB10A0E3           MOV      R1,#+187
   \                     ??GetStringValue_6:
   \   00000060   401E81E3           ORR      R1,R1,#0x400
   \   00000064   0C00A0E1           MOV      R0,R12
   \   00000068   0FE0A0E1           MOV      LR,PC
   \   0000006C   14FF2FE1           BX       R4
   \   00000070   260000EA           B        ??GetStringValue_7
     98                      } else {
     99                          MyString = "";
   \                     ??GetStringValue_5:
   \   00000074   0010A0E1           MOV      R1,R0
   \   00000078   0D00A0E1           MOV      R0,SP
   \   0000007C   ........           _BLF     ??AnsiString_2,??AnsiString??rA_2
   \   00000080   ........           LDR      R1,??DataTable3  ;; ??npos
   \   00000084   0020A0E3           MOV      R2,#+0
   \   00000088   003091E5           LDR      R3,[R1, #+0]
   \   0000008C   0010A0E1           MOV      R1,R0
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   ........           _BLF     ??assign,??assign??rA
   \   00000098   0520A0E1           MOV      R2,R5
   \   0000009C   0110A0E3           MOV      R1,#+1
   \   000000A0   0D00A0E1           MOV      R0,SP
   \   000000A4   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000A8   190000EA           B        ??GetStringValue_8
    100                      }
    101                  }
    102                  break;
    103              case SVT_IO_CH_LOCATION         :
    104                  {
    105                      AnalogInput *IOCPtr = (AnalogInput*)IOComponent[Index];
   \                     ??GetStringValue_9:
   \   000000AC   03C09EE7           LDR      R12,[LR, +R3]
    106                      if ( IOCPtr ) {
   \   000000B0   00005CE3           CMP      R12,#+0
   \   000000B4   EEFFFF0A           BEQ      ??GetStringValue_5
    107                          Status = IOCPtr->GetStringValue(SVT_AI_LOCATION,0,MyString);
   \   000000B8   0430A0E1           MOV      R3,R4
   \   000000BC   A4409CE5           LDR      R4,[R12, #+164]
   \   000000C0   0020A0E3           MOV      R2,#+0
   \   000000C4   284094E5           LDR      R4,[R4, #+40]
   \   000000C8   B910A0E3           MOV      R1,#+185
   \   000000CC   E3FFFFEA           B        ??GetStringValue_6
    108                      } else {
    109                          MyString = "";
    110                      }
    111                  }
    112                  break;
    113              case SVT_IO_CH_TYPE_TEXT    :
    114                  {
    115                      AnalogInput *IOCPtr = (AnalogInput*)IOComponent[Index];
   \                     ??GetStringValue_10:
   \   000000D0   03C09EE7           LDR      R12,[LR, +R3]
    116                      if ( IOCPtr ) {
   \   000000D4   00005CE3           CMP      R12,#+0
   \   000000D8   E5FFFF0A           BEQ      ??GetStringValue_5
    117                          Status = IOCPtr->GetStringValue(SVT_AI_TYPE_TEXT,0,MyString);
   \   000000DC   0430A0E1           MOV      R3,R4
   \   000000E0   A4409CE5           LDR      R4,[R12, #+164]
   \   000000E4   0020A0E3           MOV      R2,#+0
   \   000000E8   284094E5           LDR      R4,[R4, #+40]
   \   000000EC   B110A0E3           MOV      R1,#+177
   \   000000F0   401E81E3           ORR      R1,R1,#0x400
   \   000000F4   0C00A0E1           MOV      R0,R12
   \   000000F8   0FE0A0E1           MOV      LR,PC
   \   000000FC   14FF2FE1           BX       R4
   \   00000100   020000EA           B        ??GetStringValue_7
    118                      } else {
    119                          MyString = "";
    120                      }
    121                  }
    122                  break;
    123              default:
    124                  Status = SignalConverter::GetStringValue(ValueId,Index, MyString);
   \                     ??GetStringValue_3:
   \   00000104   0430A0E1           MOV      R3,R4
   \   00000108   0C00A0E1           MOV      R0,R12
   \   0000010C   ........           _BLF     ??GetStringValue_2,??GetStringValue??rA
   \                     ??GetStringValue_7:
   \   00000110   0050A0E1           MOV      R5,R0
    125                  break;
    126              }
    127              return(Status);
   \                     ??GetStringValue_8:
   \   00000114   0500A0E1           MOV      R0,R5
   \   00000118   1CD08DE2           ADD      SP,SP,#+28
   \   0000011C                      REQUIRE ?Subroutine16
   \   0000011C                      ;; // Fall through to label ?Subroutine16
    128          }
    129          

   \                                 In segment CODE, align 4, keep-with-next
    130          int SCWaterIngress::PutValue( int ValueId, int Index, AnsiString NewValue,bool Local, int *UnitId)
    131          {
   \                     ??PutValue:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   3470DDE5           LDRB     R7,[SP, #+52]
   \   0000000C   38809DE5           LDR      R8,[SP, #+56]
   \   00000010   0040A0E1           MOV      R4,R0
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0310A0E1           MOV      R1,R3
    132              return(SignalConverter::PutValue( ValueId, Index, NewValue, Local,UnitId));
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   ........           _BLF     ??string,??string??rA
   \   00000028   00012DE9           PUSH     {R8}
   \   0000002C   80002DE9           PUSH     {R7}
   \   00000030   08308DE2           ADD      R3,SP,#+8
   \   00000034   0620A0E1           MOV      R2,R6
   \   00000038   0510A0E1           MOV      R1,R5
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           _BLF     ??PutValue_1,??PutValue??rA
   \   00000044   0040A0E1           MOV      R4,R0
   \   00000048   0020A0E3           MOV      R2,#+0
   \   0000004C   0110A0E3           MOV      R1,#+1
   \   00000050   08008DE2           ADD      R0,SP,#+8
   \   00000054   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   24D08DE2           ADD      SP,SP,#+36
   \   00000060                      REQUIRE ?Subroutine18
   \   00000060                      ;; // Fall through to label ?Subroutine18
    133          }
    134          

   \                                 In segment CODE, align 4, keep-with-next
    135          int SCWaterIngress::PutFloatValue( int ValueId, float NewValue)
    136          {
   \                     ??PutFloatValue:
   \   00000000   00402DE9           PUSH     {LR}
    137              return(SignalConverter::PutFloatValue(ValueId,NewValue));
   \   00000004   ........           _BLF     ??PutFloatValue_1,??PutFloatValue??rA
   \   00000008   ........           B        ?Subroutine19
    138          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine19:
   \   00000000   0040BDE8           POP      {LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    139          
    140          

   \                                 In segment CODE, align 4, keep-with-next
    141          ValueList *SCWaterIngress::GetValueInfoTable(int &Entries, int Index)
    142          {
    143              Entries = NELEMENTS(SCWaterIngressValueList);
   \                     ??GetValueInfoTable:
   \   00000000   0700A0E3           MOV      R0,#+7
   \   00000004   000081E5           STR      R0,[R1, #+0]
    144              return(SCWaterIngressValueList);
   \   00000008   00009FE5           LDR      R0,??GetValueInfoTable_1  ;; ??SCWaterIngressValueList
   \   0000000C   1EFF2FE1           BX       LR               ;; return
   \                     ??GetValueInfoTable_1:
   \   00000010   ........           DC32     ??SCWaterIngressValueList
    145          }
    146          
    147          
    148          // For communication

   \                                 In segment CODE, align 4, keep-with-next
    149          void SCWaterIngress::SetHWFailure(bool Failure)
    150          {
   \                     ??SetHWFailure:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    151              if (Failure) {
   \   00000008   000051E3           CMP      R1,#+0
   \   0000000C   0F00000A           BEQ      ??SetHWFailure_1
    152                  for ( int i=0; i < MAX_W_INGR_CHANNELS; i++ ) {
   \   00000010   0050A0E3           MOV      R5,#+0
    153                      AnalogInput *CompPtr = (AnalogInput*)IOComponent[i];
   \                     ??SetHWFailure_2:
   \   00000014   050184E0           ADD      R0,R4,R5, LSL #+2
   \   00000018   A02190E5           LDR      R2,[R0, #+416]
    154                      if ( CompPtr ) {
   \   0000001C   000052E3           CMP      R2,#+0
   \   00000020   0700000A           BEQ      ??SetHWFailure_3
    155                          CompPtr->HWFailure = true;
   \   00000024   0100A0E3           MOV      R0,#+1
   \   00000028   0C01C2E5           STRB     R0,[R2, #+268]
    156                          CompPtr->SendData();
   \   0000002C   0200A0E1           MOV      R0,R2
   \   00000030   A42092E5           LDR      R2,[R2, #+164]
   \   00000034   6510A0E3           MOV      R1,#+101
   \   00000038   402092E5           LDR      R2,[R2, #+64]
   \   0000003C   0FE0A0E1           MOV      LR,PC
   \   00000040   12FF2FE1           BX       R2
    157                      }
    158                  }
   \                     ??SetHWFailure_3:
   \   00000044   015085E2           ADD      R5,R5,#+1
   \   00000048   020055E3           CMP      R5,#+2
   \   0000004C   F0FFFFBA           BLT      ??SetHWFailure_2
    159              }
    160          }
   \                     ??SetHWFailure_1:
   \   00000050                      REQUIRE ?Subroutine17
   \   00000050                      ;; // Fall through to label ?Subroutine17
    161          

   \                                 In segment CODE, align 4, keep-with-next
    162          bool SCWaterIngress::ANPRO10_IO_UnpackPacket(U8 *Buf)
    163          {
   \                     ??ANPRO10_IO_UnpackPacket:
   \   00000000   F74F2DE9           PUSH     {R0-R2,R4-R11,LR}
    164              bool MoreCommands = true;
    165              bool RecalcTanks  = false;
    166              ANPRO10_PacketHeading *pPH = (ANPRO10_PacketHeading*)Buf;
    167              U8 *EndPtr =  &Buf[pPH->nob];
   \   00000004   0520D1E5           LDRB     R2,[R1, #+5]
   \   00000008   0430D1E5           LDRB     R3,[R1, #+4]
   \   0000000C   0040A0E1           MOV      R4,R0
    168              Buf += sizeof(ANPRO10_PacketHeading);
   \   00000010   075081E2           ADD      R5,R1,#+7
   \   00000014   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000018   012082E0           ADD      R2,R2,R1
   \   0000001C   04208DE5           STR      R2,[SP, #+4]
    169          
    170              ANPRO10_CommandHeading *pCH;
    171              bool MyPacket= (pPH->txadr == this->IOAddress);
   \   00000020   0300D1E5           LDRB     R0,[R1, #+3]
   \   00000024   781194E5           LDR      R1,[R4, #+376]
   \   00000028   0060A0E3           MOV      R6,#+0
   \   0000002C   010050E1           CMP      R0,R1
   \   00000030   1E00001A           BNE      ??ANPRO10_IO_UnpackPacket_1
   \   00000034   0110A0E3           MOV      R1,#+1
   \   00000038   0010CDE5           STRB     R1,[SP, #+0]
   \   0000003C   76AFA0E3           MOV      R10,#+472
    172              if ( MyPacket ) {
    173                  do {
    174                      pCH = (ANPRO10_CommandHeading*)Buf;
   \                     ??ANPRO10_IO_UnpackPacket_2:
   \   00000040   0570A0E1           MOV      R7,R5
    175                      Buf += sizeof(ANPRO10_CommandHeading);  // ??
    176                      switch ( pCH->CommandNo ) {
   \   00000044   0100D7E5           LDRB     R0,[R7, #+1]
   \   00000048   0010D7E5           LDRB     R1,[R7, #+0]
   \   0000004C   045085E2           ADD      R5,R5,#+4
   \   00000050   000491E1           ORRS     R0,R1,R0, LSL #+8
   \   00000054   01005013           CMPNE    R0,#+1
   \   00000058   8300000A           BEQ      ??ANPRO10_IO_UnpackPacket_3
   \   0000005C   7510A0E3           MOV      R1,#+117
   \   00000060   401E81E3           ORR      R1,R1,#0x400
   \   00000064   010050E1           CMP      R0,R1
   \   00000068   1300000A           BEQ      ??ANPRO10_IO_UnpackPacket_4
   \   0000006C   141081E2           ADD      R1,R1,#+20
   \   00000070   010050E1           CMP      R0,R1
   \   00000074   7500001A           BNE      ??ANPRO10_IO_UnpackPacket_5
    177                      case CMD_TXU_COMPRESSED_PACKET:
    178                          //Decompress(Size,Buf,Port);
    179                          break;
    180                      case CMD_REP_RS4_ADBUF:
    181                          {
    182                              bool DataIsValid = (bool)Buf[0];
   \   00000078   0000D5E5           LDRB     R0,[R5, #+0]
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   7200000A           BEQ      ??ANPRO10_IO_UnpackPacket_5
    183                              U8 Ch = Buf[1];
    184                              if ( DataIsValid ) {
    185                                  SignalConverter *SConverter = FindSignalConverter(Ch);
   \   00000084   0110D5E5           LDRB     R1,[R5, #+1]
   \   00000088   0400A0E1           MOV      R0,R4
   \   0000008C   ........           _BLF     ??FindSignalConverter,??FindSignalConverter??rA
   \   00000090   0020B0E1           MOVS     R2,R0
    186                                  if ( SConverter ) {
   \   00000094   6D00000A           BEQ      ??ANPRO10_IO_UnpackPacket_5
    187                                      SConverter->GetEEPromData(&Buf[2]);
   \   00000098   A42090E5           LDR      R2,[R0, #+164]
   \   0000009C   021085E2           ADD      R1,R5,#+2
   \   000000A0   8C2092E5           LDR      R2,[R2, #+140]
   \   000000A4   0FE0A0E1           MOV      LR,PC
   \   000000A8   12FF2FE1           BX       R2
   \   000000AC   670000EA           B        ??ANPRO10_IO_UnpackPacket_5
    188                                  }
    189                              }
    190                          }
   \                     ??ANPRO10_IO_UnpackPacket_1:
   \   000000B0   0010A0E3           MOV      R1,#+0
   \   000000B4   0010CDE5           STRB     R1,[SP, #+0]
   \   000000B8   6F0000EA           B        ??ANPRO10_IO_UnpackPacket_6
    191          
    192                          // receive additional info. Serial number
    193                          //
    194                          break;
    195                      case CMD_REP_RS4_MDATA:
    196                          {
    197                              SgCnvMeasuredDataStruct *MsrdData = (SgCnvMeasuredDataStruct*)Buf;
    198                              if ( MsrdData->IOChannel == IOChannel ) {
   \                     ??ANPRO10_IO_UnpackPacket_4:
   \   000000BC   0000D5E5           LDRB     R0,[R5, #+0]
   \   000000C0   7C1194E5           LDR      R1,[R4, #+380]
   \   000000C4   010050E1           CMP      R0,R1
   \   000000C8   6000001A           BNE      ??ANPRO10_IO_UnpackPacket_5
    199                                  IOUnitStatus    = MsrdData->IOUnitStatus;
   \   000000CC   0110D5E5           LDRB     R1,[R5, #+1]
   \   000000D0   610FA0E3           MOV      R0,#+388
   \   000000D4   0410C0E7           STRB     R1,[R0, +R4]
    200                                  U8 TmpStatus    = IOUnitStatus >> 4;
   \   000000D8   0100A0E1           MOV      R0,R1
   \   000000DC   2002B0E1           LSRS     R0,R0,#+4
    201                                  if ( TmpStatus ) {
   \   000000E0   0500000A           BEQ      ??ANPRO10_IO_UnpackPacket_7
    202                                      ((IOUnitZB485*)IOModule)->ResetStatus = TmpStatus;
   \   000000E4   5A1FA0E3           MOV      R1,#+360
   \   000000E8   042091E7           LDR      R2,[R1, +R4]
   \   000000EC   A401C2E5           STRB     R0,[R2, #+420]
    203                                      ((IOUnitZB485*)IOModule)->Restart     = true;
   \   000000F0   040091E7           LDR      R0,[R1, +R4]
   \   000000F4   0110A0E3           MOV      R1,#+1
   \   000000F8   A511C0E5           STRB     R1,[R0, #+421]
    204                                  }
    205          
    206                                  
    207                                  FailCnt         = MsrdData->FailCnt;
   \                     ??ANPRO10_IO_UnpackPacket_7:
   \   000000FC   0300D5E5           LDRB     R0,[R5, #+3]
   \   00000100   0210D5E5           LDRB     R1,[R5, #+2]
   \   00000104   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000108   540184E5           STR      R0,[R4, #+340]
    208                                  FailCntTotal    = MsrdData->FailCntTotal;
   \   0000010C   0500D5E5           LDRB     R0,[R5, #+5]
   \   00000110   0410D5E5           LDRB     R1,[R5, #+4]
   \   00000114   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000118   500184E5           STR      R0,[R4, #+336]
    209                                  SoftwareVersion = MsrdData->TargetStatusSWVer; 
   \   0000011C   0600D5E5           LDRB     R0,[R5, #+6]
    210          
    211                                  ActiveAlarms    = CheckAlarms(AlarmSet);
   \   00000120   0010A0E3           MOV      R1,#+0
   \   00000124   5C0184E5           STR      R0,[R4, #+348]
   \   00000128   E40084E2           ADD      R0,R4,#+228
   \   0000012C   ........           _BLF     ??CheckAlarms,??CheckAlarms??rA
   \   00000130   380084E5           STR      R0,[R4, #+56]
    212                                  if ( ActiveAlarms ) {
   \   00000134   380094E5           LDR      R0,[R4, #+56]
   \   00000138   000050E3           CMP      R0,#+0
   \   0000013C   0900000A           BEQ      ??ANPRO10_IO_UnpackPacket_8
    213                                      SetHWFailure(ActiveAlarms);
   \   00000140   380094E5           LDR      R0,[R4, #+56]
   \   00000144   A42094E5           LDR      R2,[R4, #+164]
   \   00000148   000050E3           CMP      R0,#+0
   \   0000014C   842092E5           LDR      R2,[R2, #+132]
   \   00000150   0110A013           MOVNE    R1,#+1
   \   00000154   0010A003           MOVEQ    R1,#+0
   \   00000158   0400A0E1           MOV      R0,R4
   \   0000015C   0FE0A0E1           MOV      LR,PC
   \   00000160   12FF2FE1           BX       R2
   \   00000164   330000EA           B        ??ANPRO10_IO_UnpackPacket_9
    214                                  }else{
    215                                      RecalcTanks = true;
   \                     ??ANPRO10_IO_UnpackPacket_8:
   \   00000168   0160A0E3           MOV      R6,#+1
    216                                      for ( int i=0; i < MAX_W_INGR_CHANNELS; i++ ) {
   \   0000016C   0080A0E3           MOV      R8,#+0
    217                                          ChStatus[i]   = ( MsrdData->Channel[i].Status1 << 8) | MsrdData->Channel[i].Status2;
   \                     ??ANPRO10_IO_UnpackPacket_10:
   \   00000170   0610A0E3           MOV      R1,#+6
   \   00000174   915820E0           MLA      R0,R1,R8,R5
   \   00000178   0920D0E5           LDRB     R2,[R0, #+9]
   \   0000017C   041088E0           ADD      R1,R8,R4
   \   00000180   4822C1E5           STRB     R2,[R1, #+584]
    218                                          MsrdValues[i] = MsrdData->Channel[i].MsrdValue;
   \   00000184   0010A0E3           MOV      R1,#+0
   \   00000188   08208DE2           ADD      R2,SP,#+8
   \                     ??ANPRO10_IO_UnpackPacket_11:
   \   0000018C   0A3080E2           ADD      R3,R0,#+10
   \   00000190   0330D1E7           LDRB     R3,[R1, +R3]
   \   00000194   0230C1E7           STRB     R3,[R1, +R2]
   \   00000198   011081E2           ADD      R1,R1,#+1
   \   0000019C   040051E3           CMP      R1,#+4
   \   000001A0   F9FFFFBA           BLT      ??ANPRO10_IO_UnpackPacket_11
   \   000001A4   08009DE5           LDR      R0,[SP, #+8]
   \   000001A8   089184E0           ADD      R9,R4,R8, LSL #+2
   \   000001AC   09008AE7           STR      R0,[R10, +R9]
    219                                          AnalogInput *CompPtr = (AnalogInput*)IOComponent[i];
   \   000001B0   A0B199E5           LDR      R11,[R9, #+416]
    220                                          if ( CompPtr ) {
   \   000001B4   00005BE3           CMP      R11,#+0
   \   000001B8   1B00000A           BEQ      ??ANPRO10_IO_UnpackPacket_12
    221                                              CompPtr->SetStatus((U8*)&ChStatus[i]);
   \   000001BC   A4209BE5           LDR      R2,[R11, #+164]
   \   000001C0   040088E0           ADD      R0,R8,R4
   \   000001C4   642092E5           LDR      R2,[R2, #+100]
   \   000001C8   921F80E2           ADD      R1,R0,#+584
   \   000001CC   0B00A0E1           MOV      R0,R11
   \   000001D0   0FE0A0E1           MOV      LR,PC
   \   000001D4   12FF2FE1           BX       R2
    222                                              CompPtr->NewValue(MsrdValues[i]);
   \   000001D8   09109AE7           LDR      R1,[R10, +R9]
   \   000001DC   A4209BE5           LDR      R2,[R11, #+164]
   \   000001E0   0B00A0E1           MOV      R0,R11
   \   000001E4   682092E5           LDR      R2,[R2, #+104]
   \   000001E8   0FE0A0E1           MOV      LR,PC
   \   000001EC   12FF2FE1           BX       R2
    223                                              CompPtr->ActiveAlarms = CheckAlarms(CompPtr->AlarmSet);
   \   000001F0   0010A0E3           MOV      R1,#+0
   \   000001F4   C0008BE2           ADD      R0,R11,#+192
   \   000001F8   ........           _BLF     ??CheckAlarms,??CheckAlarms??rA
   \   000001FC   38008BE5           STR      R0,[R11, #+56]
    224                                              CompPtr->Calculate();
   \   00000200   A4109BE5           LDR      R1,[R11, #+164]
   \   00000204   0B00A0E1           MOV      R0,R11
   \   00000208   601091E5           LDR      R1,[R1, #+96]
   \   0000020C   0FE0A0E1           MOV      LR,PC
   \   00000210   11FF2FE1           BX       R1
    225                                              CompPtr->SendData();
   \   00000214   A4209BE5           LDR      R2,[R11, #+164]
   \   00000218   6510A0E3           MOV      R1,#+101
   \   0000021C   402092E5           LDR      R2,[R2, #+64]
   \   00000220   0B00A0E1           MOV      R0,R11
   \   00000224   0FE0A0E1           MOV      LR,PC
   \   00000228   12FF2FE1           BX       R2
    226                                          }
    227                                      }
   \                     ??ANPRO10_IO_UnpackPacket_12:
   \   0000022C   018088E2           ADD      R8,R8,#+1
   \   00000230   020058E3           CMP      R8,#+2
   \   00000234   CDFFFFBA           BLT      ??ANPRO10_IO_UnpackPacket_10
    228                                  }
    229                                  SendData();
   \                     ??ANPRO10_IO_UnpackPacket_9:
   \   00000238   A42094E5           LDR      R2,[R4, #+164]
   \   0000023C   6510A0E3           MOV      R1,#+101
   \   00000240   402092E5           LDR      R2,[R2, #+64]
   \   00000244   0400A0E1           MOV      R0,R4
   \   00000248   0FE0A0E1           MOV      LR,PC
   \   0000024C   12FF2FE1           BX       R2
    230                              }
    231                          }
    232                          break;
    233                      case CMD_REP_RS4_RDATA:
    234                          break;
    235                          //case CMD_REP_RS4_CDATA:
    236                      case ECMD_NMDWOACK:
    237                      case ECMD_NMDRQACK:
    238                          MoreCommands=false;
    239                          break;
    240                      default:
    241                          break;
    242          
    243                      }
    244                      if ( MoreCommands ) {
    245                          Buf += pCH->ndb;
   \                     ??ANPRO10_IO_UnpackPacket_5:
   \   00000250   0300D7E5           LDRB     R0,[R7, #+3]
   \   00000254   0210D7E5           LDRB     R1,[R7, #+2]
   \   00000258   000481E1           ORR      R0,R1,R0, LSL #+8
   \   0000025C   055080E0           ADD      R5,R0,R5
   \   00000260   04009DE5           LDR      R0,[SP, #+4]
   \   00000264   000055E1           CMP      R5,R0
   \   00000268   74FFFF3A           BCC      ??ANPRO10_IO_UnpackPacket_2
    246                      }
    247                  } while ( MoreCommands && ( Buf < EndPtr ) );
    248                  if ( RecalcTanks ) {
   \                     ??ANPRO10_IO_UnpackPacket_3:
   \   0000026C   000056E3           CMP      R6,#+0
   \   00000270   0100000A           BEQ      ??ANPRO10_IO_UnpackPacket_6
    249                      RecalcTanks = false;
    250                      SetDataTime(UniquePROList);
   \   00000274   620F84E2           ADD      R0,R4,#+392
   \   00000278   ........           _BLF     ??SetDataTime,??SetDataTime??rA
    251                  }
    252              }
    253              return(MyPacket);
   \                     ??ANPRO10_IO_UnpackPacket_6:
   \   0000027C   0000DDE5           LDRB     R0,[SP, #+0]
   \   00000280   FE4FBDE8           POP      {R1-R11,LR}
   \   00000284   1EFF2FE1           BX       LR               ;; return
    254              //return true;
    255          
    256          }
    257          

   \                                 In segment CODE, align 4, keep-with-next
    258          void SCWaterIngress::GetEEPromData(U8 *DataPtr)
    259          {
   \                     ??GetEEPromData:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0100A0E1           MOV      R0,R1
    260              SerialNumber = GetU32BigEndian(DataPtr);
   \   0000000C   ........           _BLF     ??GetU32BigEndian,??GetU32BigEndian??rA
   \   00000010   600184E5           STR      R0,[R4, #+352]
    261          }
   \   00000014   1040BDE8           POP      {R4,LR}
   \   00000018   1EFF2FE1           BX       LR               ;; return
    262          
    263          

   \                                 In segment CODE, align 4, keep-with-next
    264          void SCWaterIngress::RequestMeasuredData(int  DataType)
    265          {
   \                     ??RequestMeasuredData:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   14D04DE2           SUB      SP,SP,#+20
    266              NetPacket Packet;
    267              U8 Data[2]={(U8)DataType,(U8)IOChannel};
   \   00000008   0010CDE5           STRB     R1,[SP, #+0]
   \   0000000C   7C2190E5           LDR      R2,[R0, #+380]
    268              Packet.Command    = CMD_REQ_RS4_DATA;
    269              Packet.RxAddress  = IOAddress;
    270              Packet.RxTypeId   = DEVICE_ZB485;
    271              Packet.RequestAck = 0;
    272              Packet.Size       = 2;
    273              Packet.Data       = Data;
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   0120CDE5           STRB     R2,[SP, #+1]
   \   00000018   7420A0E3           MOV      R2,#+116
   \   0000001C   402E82E3           ORR      R2,R2,#0x400
   \   00000020   B420CDE1           STRH     R2,[SP, #+4]
   \   00000024   782190E5           LDR      R2,[R0, #+376]
   \   00000028   0920CDE5           STRB     R2,[SP, #+9]
   \   0000002C   1020A0E3           MOV      R2,#+16
   \   00000030   0820CDE5           STRB     R2,[SP, #+8]
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   0A20CDE5           STRB     R2,[SP, #+10]
   \   0000003C   0220A0E3           MOV      R2,#+2
   \   00000040   B620CDE1           STRH     R2,[SP, #+6]
   \   00000044   0D20A0E1           MOV      R2,SP
   \   00000048   10208DE5           STR      R2,[SP, #+16]
   \   0000004C   0B208DE2           ADD      R2,SP,#+11
   \                     ??RequestMeasuredData_1:
   \   00000050   10308DE2           ADD      R3,SP,#+16
   \   00000054   0330D1E7           LDRB     R3,[R1, +R3]
   \   00000058   0230C1E7           STRB     R3,[R1, +R2]
   \   0000005C   011081E2           ADD      R1,R1,#+1
   \   00000060   040051E3           CMP      R1,#+4
   \   00000064   F9FFFFBA           BLT      ??RequestMeasuredData_1
    274              SendPacket(Packet);
   \   00000068   04108DE2           ADD      R1,SP,#+4
   \   0000006C   ........           _BLF     ??SendPacket,??SendPacket??rA
    275          }
   \   00000070   14D08DE2           ADD      SP,SP,#+20
   \   00000074                      REQUIRE ?Subroutine19
   \   00000074                      ;; // Fall through to label ?Subroutine19
    276          

   \                                 In segment CODE, align 4, keep-with-next
    277          bool SCWaterIngress::HandleCard(int Delay)
    278          {
   \                     ??HandleCard:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    279              bool ReceivedAnswer=false;
    280              if ( Restart ) {
   \   00000008   561FA0E3           MOV      R1,#+344
   \   0000000C   0420D1E7           LDRB     R2,[R1, +R4]
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   0050A0E3           MOV      R5,#+0
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   0100000A           BEQ      ??HandleCard_1
    281                  // Should ask for sensor info for all channels here
    282                  // Should set up filters and sensor cable length etc
    283                  Restart=false;
   \                     ??HandleCard_2:
   \   00000020   0400C1E7           STRB     R0,[R1, +R4]
   \   00000024   130000EA           B        ??HandleCard_3
    284              } else if ( NewSensor ) {
   \                     ??HandleCard_1:
   \   00000028   011081E3           ORR      R1,R1,#0x1
   \   0000002C   0420D1E7           LDRB     R2,[R1, +R4]
   \   00000030   000052E3           CMP      R2,#+0
   \   00000034   F9FFFF1A           BNE      ??HandleCard_2
    285                  NewSensor = false;
    286                  // Should ask for sensor info for all channels here
    287              } else {// The normal place
    288                  RequestMeasuredData(0);
   \   00000038   A42094E5           LDR      R2,[R4, #+164]
   \   0000003C   0010A0E3           MOV      R1,#+0
   \   00000040   882092E5           LDR      R2,[R2, #+136]
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   0FE0A0E1           MOV      LR,PC
   \   0000004C   12FF2FE1           BX       R2
    289                  ReceivedAnswer = ANPRO10_IO_Receive();
   \   00000050   1E10A0E3           MOV      R1,#+30
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           _BLF     ??ANPRO10_IO_Receive,??ANPRO10_IO_Receive??rA
    290                  SetHWFailure(!ReceivedAnswer);
   \   0000005C   A42094E5           LDR      R2,[R4, #+164]
   \   00000060   0050A0E1           MOV      R5,R0
   \   00000064   842092E5           LDR      R2,[R2, #+132]
   \   00000068   011025E2           EOR      R1,R5,#0x1
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   0FE0A0E1           MOV      LR,PC
   \   00000074   12FF2FE1           BX       R2
    291              }
    292              return(ReceivedAnswer);
   \                     ??HandleCard_3:
   \   00000078   0500A0E1           MOV      R0,R5
   \   0000007C   ........           B        ?Subroutine17
    293          }
    294          

   \                                 In segment CODE, align 4, keep-with-next
    295          int SCWaterIngress::ReceiveData(U8* data)
    296          {
   \                     ??ReceiveData:
   \   00000000   31002DE9           PUSH     {R0,R4,R5}
    297              int ErrorStatus = E_OK;
    298              ANPRO10_CommandHeading *pCH = (ANPRO10_CommandHeading*)data;
    299              switch ( pCH->CommandNo ) {
   \   00000004   0120D1E5           LDRB     R2,[R1, #+1]
   \   00000008   0030D1E5           LDRB     R3,[R1, #+0]
   \   0000000C   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000010   650052E3           CMP      R2,#+101
   \   00000014   3C00001A           BNE      ??ReceiveData_1
    300              case CMD_GENERIC_REALTIME_DATA:
    301                  {
    302                      ANPRO10_COMMAND_2630  *pData = (ANPRO10_COMMAND_2630*) data;
    303                      SerialNumber    = pData->SerialNumber;
   \   00000018   0B20D1E5           LDRB     R2,[R1, #+11]
   \   0000001C   0A30D1E5           LDRB     R3,[R1, #+10]
   \   00000020   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000024   0930D1E5           LDRB     R3,[R1, #+9]
   \   00000028   022483E1           ORR      R2,R3,R2, LSL #+8
   \   0000002C   0830D1E5           LDRB     R3,[R1, #+8]
   \   00000030   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000034   602180E5           STR      R2,[R0, #+352]
    304                      IOUnitStatus    = pData->IOUnitStatus;
   \   00000038   0C20D1E5           LDRB     R2,[R1, #+12]
   \   0000003C   8421C0E5           STRB     R2,[R0, #+388]
    305                      CardStatus      = pData->CardStatus;
   \   00000040   0D20D1E5           LDRB     R2,[R1, #+13]
   \   00000044   6421C0E5           STRB     R2,[R0, #+356]
    306                      FailCnt         = pData->FailCnt;
   \   00000048   0F20D1E5           LDRB     R2,[R1, #+15]
   \   0000004C   0E30D1E5           LDRB     R3,[R1, #+14]
   \   00000050   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000054   542180E5           STR      R2,[R0, #+340]
    307                      FailCntTotal    = pData->FailCntTotal;
   \   00000058   1120D1E5           LDRB     R2,[R1, #+17]
   \   0000005C   1030D1E5           LDRB     R3,[R1, #+16]
   \   00000060   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000064   502180E5           STR      R2,[R0, #+336]
    308                      ActiveAlarms    = pData->ActiveAlarms;
   \   00000068   1520D1E5           LDRB     R2,[R1, #+21]
   \   0000006C   1430D1E5           LDRB     R3,[R1, #+20]
   \   00000070   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000074   1330D1E5           LDRB     R3,[R1, #+19]
   \   00000078   022483E1           ORR      R2,R3,R2, LSL #+8
   \   0000007C   1230D1E5           LDRB     R3,[R1, #+18]
   \   00000080   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000084   382080E5           STR      R2,[R0, #+56]
    309                      for ( int i=0; i < MAX_W_INGR_CHANNELS; i++ ) {
   \   00000088   0020A0E3           MOV      R2,#+0
    310                          MsrdValues[i] = pData->MsrdValues[i];
   \                     ??ReceiveData_2:
   \   0000008C   0030A0E3           MOV      R3,#+0
   \   00000090   0DC0A0E1           MOV      R12,SP
   \                     ??ReceiveData_3:
   \   00000094   024181E0           ADD      R4,R1,R2, LSL #+2
   \   00000098   164084E2           ADD      R4,R4,#+22
   \   0000009C   0440D3E7           LDRB     R4,[R3, +R4]
   \   000000A0   0C40C3E7           STRB     R4,[R3, +R12]
   \   000000A4   013083E2           ADD      R3,R3,#+1
   \   000000A8   040053E3           CMP      R3,#+4
   \   000000AC   F8FFFFBA           BLT      ??ReceiveData_3
   \   000000B0   00409DE5           LDR      R4,[SP, #+0]
   \   000000B4   023180E0           ADD      R3,R0,R2, LSL #+2
   \   000000B8   D84183E5           STR      R4,[R3, #+472]
    311                          ChStatus[i]   = pData->ChStatus[i];
   \   000000BC   014082E0           ADD      R4,R2,R1
   \   000000C0   1E40D4E5           LDRB     R4,[R4, #+30]
   \   000000C4   003082E0           ADD      R3,R2,R0
    312                          CalValues[i]  = pData->CalValues[i];
   \   000000C8   82C081E0           ADD      R12,R1,R2, LSL #+1
   \   000000CC   4842C3E5           STRB     R4,[R3, #+584]
   \   000000D0   2140DCE5           LDRB     R4,[R12, #+33]
   \   000000D4   2050DCE5           LDRB     R5,[R12, #+32]
   \   000000D8   823080E0           ADD      R3,R0,R2, LSL #+1
   \   000000DC   843F83E2           ADD      R3,R3,#+528
   \   000000E0   044485E1           ORR      R4,R5,R4, LSL #+8
   \   000000E4   B040C3E1           STRH     R4,[R3, #+0]
    313                          RawValues[i]  = pData->RawValues[i];
   \   000000E8   2540DCE5           LDRB     R4,[R12, #+37]
   \   000000EC   2450DCE5           LDRB     R5,[R12, #+36]
    314                      }
   \   000000F0   012082E2           ADD      R2,R2,#+1
   \   000000F4   020052E3           CMP      R2,#+2
   \   000000F8   044485E1           ORR      R4,R5,R4, LSL #+8
   \   000000FC   BC41C3E1           STRH     R4,[R3, #+28]
   \   00000100   E1FFFFBA           BLT      ??ReceiveData_2
    315                      ErrorStatus =  E_OK;
   \   00000104   0000A0E3           MOV      R0,#+0
   \   00000108   000000EA           B        ??ReceiveData_4
    316                  }
    317                  break;
    318              default:
    319                  ErrorStatus = E_UNKNOWN_COMMAND;
   \                     ??ReceiveData_1:
   \   0000010C   0100A0E3           MOV      R0,#+1
    320                  break;
    321              }
    322              return(ErrorStatus);
   \                     ??ReceiveData_4:
   \   00000110   3200BDE8           POP      {R1,R4,R5}
   \   00000114   1EFF2FE1           BX       LR               ;; return
    323          }
    324          

   \                                 In segment CODE, align 4, keep-with-next
    325          int SCWaterIngress::SendData(U16 cmd)
    326          {
   \                     ??SendData:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   30D04DE2           SUB      SP,SP,#+48
    327              int ErrorStatus = E_OK;
    328              switch ( cmd ) {
   \   00000008   650051E3           CMP      R1,#+101
   \   0000000C   3F00001A           BNE      ??SendData_1
    329              case CMD_GENERIC_REALTIME_DATA:
    330                  {
    331                      QueueANPRO10_COMMAND_2630 Cmd;
    332                      Cmd.TxInfo.Port       = NULL;
   \   00000010   0020A0E3           MOV      R2,#+0
   \   00000014   00208DE5           STR      R2,[SP, #+0]
    333                      Cmd.TxInfo.rxAddr     = DEVICE_BROADCAST_ADDR;
   \   00000018   FF20A0E3           MOV      R2,#+255
   \   0000001C   0420CDE5           STRB     R2,[SP, #+4]
    334                      Cmd.TxInfo.rxId       = DEVICE_BROADCAST_TXU;
   \   00000020   0E20A0E3           MOV      R2,#+14
   \   00000024   0520CDE5           STRB     R2,[SP, #+5]
    335                      Cmd.Data.ObjectId     = IDNumber;
   \   00000028   9C1090E5           LDR      R1,[R0, #+156]
    336                      Cmd.Data.ndb          = sizeof(Cmd)-sizeof(QueueANPRO10_CommandHeading);
   \   0000002C   2420A0E3           MOV      R2,#+36
   \   00000030   0A10CDE5           STRB     R1,[SP, #+10]
   \   00000034   2114A0E1           LSR      R1,R1,#+8
   \   00000038   0B10CDE5           STRB     R1,[SP, #+11]
   \   0000003C   2114A0E1           LSR      R1,R1,#+8
   \   00000040   0C10CDE5           STRB     R1,[SP, #+12]
   \   00000044   2114A0E1           LSR      R1,R1,#+8
   \   00000048   0D10CDE5           STRB     R1,[SP, #+13]
   \   0000004C   B820CDE1           STRH     R2,[SP, #+8]
    337                      Cmd.Data.CommandNo    = CMD_GENERIC_REALTIME_DATA;
   \   00000050   6520A0E3           MOV      R2,#+101
   \   00000054   B620CDE1           STRH     R2,[SP, #+6]
    338                      Cmd.Data.SerialNumber = SerialNumber;
   \   00000058   601190E5           LDR      R1,[R0, #+352]
   \   0000005C   0E10CDE5           STRB     R1,[SP, #+14]
   \   00000060   2114A0E1           LSR      R1,R1,#+8
   \   00000064   0F10CDE5           STRB     R1,[SP, #+15]
   \   00000068   2114A0E1           LSR      R1,R1,#+8
   \   0000006C   1010CDE5           STRB     R1,[SP, #+16]
   \   00000070   2114A0E1           LSR      R1,R1,#+8
   \   00000074   1110CDE5           STRB     R1,[SP, #+17]
    339                      Cmd.Data.IOUnitStatus = IOUnitStatus;
   \   00000078   8421D0E5           LDRB     R2,[R0, #+388]
    340                      Cmd.Data.CardStatus   = CardStatus;
    341                      Cmd.Data.FailCnt = FailCnt;
    342                      Cmd.Data.FailCntTotal = FailCntTotal;
    343                      Cmd.Data.ActiveAlarms = ActiveAlarms;
    344                      for ( int i=0; i < MAX_W_INGR_CHANNELS; i++ ) {
   \   0000007C   0010A0E3           MOV      R1,#+0
   \   00000080   1220CDE5           STRB     R2,[SP, #+18]
   \   00000084   6421D0E5           LDRB     R2,[R0, #+356]
   \   00000088   1320CDE5           STRB     R2,[SP, #+19]
   \   0000008C   542190E5           LDR      R2,[R0, #+340]
   \   00000090   B421CDE1           STRH     R2,[SP, #+20]
   \   00000094   502190E5           LDR      R2,[R0, #+336]
   \   00000098   B621CDE1           STRH     R2,[SP, #+22]
   \   0000009C   382090E5           LDR      R2,[R0, #+56]
   \   000000A0   18208DE5           STR      R2,[SP, #+24]
    345                          Cmd.Data.MsrdValues[i] = MsrdValues[i];
   \                     ??SendData_2:
   \   000000A4   013180E0           ADD      R3,R0,R1, LSL #+2
   \   000000A8   D83193E5           LDR      R3,[R3, #+472]
   \   000000AC   0D20A0E1           MOV      R2,SP
   \   000000B0   012182E0           ADD      R2,R2,R1, LSL #+2
   \   000000B4   1C3082E5           STR      R3,[R2, #+28]
    346                          Cmd.Data.ChStatus[i]   = ChStatus[i];
   \   000000B8   003081E0           ADD      R3,R1,R0
   \   000000BC   4832D3E5           LDRB     R3,[R3, #+584]
   \   000000C0   0D20A0E1           MOV      R2,SP
   \   000000C4   022081E0           ADD      R2,R1,R2
   \   000000C8   2430C2E5           STRB     R3,[R2, #+36]
    347                          Cmd.Data.CalValues[i]  = CalValues[i];
   \   000000CC   812080E0           ADD      R2,R0,R1, LSL #+1
   \   000000D0   842F82E2           ADD      R2,R2,#+528
   \   000000D4   B0C0D2E1           LDRH     R12,[R2, #+0]
   \   000000D8   0D30A0E1           MOV      R3,SP
   \   000000DC   813083E0           ADD      R3,R3,R1, LSL #+1
   \   000000E0   B6C2C3E1           STRH     R12,[R3, #+38]
    348                          Cmd.Data.RawValues[i]  = RawValues[i];
   \   000000E4   BC21D2E1           LDRH     R2,[R2, #+28]
    349                      }
   \   000000E8   011081E2           ADD      R1,R1,#+1
   \   000000EC   020051E3           CMP      R1,#+2
   \   000000F0   BA22C3E1           STRH     R2,[R3, #+42]
   \   000000F4   EAFFFFBA           BLT      ??SendData_2
    350                      bool sent = ANPRO10SendNormal(&Cmd);
    351                      if ( !sent )
   \   000000F8   0D00A0E1           MOV      R0,SP
   \   000000FC   ........           _BLF     ??ANPRO10SendNormal,??ANPRO10SendNormal??rA
   \   00000100   000050E3           CMP      R0,#+0
   \   00000104   0000A013           MOVNE    R0,#+0
    352                          ErrorStatus =  E_QUEUE_FULL;
   \   00000108   0300A003           MOVEQ    R0,#+3
   \   0000010C   000000EA           B        ??SendData_3
    353                      else
    354                          ErrorStatus =  E_OK;
    355                  }
    356                  break;
    357              default:
    358                  ErrorStatus =  E_UNKNOWN_COMMAND;
   \                     ??SendData_1:
   \   00000110   0100A0E3           MOV      R0,#+1
    359                  break;
    360              }
    361              return(ErrorStatus);
   \                     ??SendData_3:
   \   00000114   30D08DE2           ADD      SP,SP,#+48
   \   00000118   ........           B        ?Subroutine19
    362          }

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for SCWaterIngressValueList>`:
   \   00000000   30010000ED00       DC32 304, 237, 1000, 24, 237, 4502, 390, 237, 4650, 391, 237, 4653, 392
   \              0000E8030000
   \              18000000ED00
   \              000096110000
   \              86010000ED00
   \              00002A120000
   \              87010000ED00
   \              00002D120000
   \              88010000    
   \   00000034   ED0000002E12       DC32 237, 4654, 386, 237, 4655, 387, 237, 4656
   \              000082010000
   \              ED0000002F12
   \              000083010000
   \              ED0000003012
   \              0000        

   \                                 In segment DIFUNCT, align 4, keep-with-next, root
   \   00000000                      REQUIRE ?call_ctors
   \   00000000   ........           DC32    ??__sti__routine

   \                                 In segment DATA_C, align 4, align-sorted
   \   __vtbl_entry const __data SCWaterIngress::__vtbl[37]
   \                     ??__vtbl:
   \   00000000   ............       DC32 `?~SCWaterIngress`, ??WriteConfigToFile, ??LoadConfigFromFile
   \              ............
   \   0000000C   ............       DC32 ??MakeConfigString, ??LoadConfigString, ??RestoreSettings
   \              ............
   \   00000018   ............       DC32 ??GetName, ??FindPROStatus, ??GetFloatValue, ??GetValue
   \              ............
   \              ........    
   \   00000028   ............       DC32 ??GetStringValue, ??GetBitValue, ??PutValue, ??PutFloatValue
   \              ............
   \              ........    
   \   00000038   ............       DC32 ??PutBitValue, ??ReceiveData, ??SendData, ??StartTimer
   \              ............
   \              ........    
   \   00000048   ............       DC32 ??InputTimeout, ??GetValueInfoTable, ??GetServiceValueInfoTable
   \              ............
   \   00000054   ............       DC32 ??SetModifiedFlag, ??IsAvailableNewData, ??SortAnalogInputs
   \              ............
   \   00000060   ............       DC32 ??SaveSettings, ??Calculate, ??CreateAlarms, ??WriteXML
   \              ............
   \              ........    
   \   00000070   ............       DC32 ??LCWriteXML, ??RefreshData, ??IsStaticValue
   \              ............
   \   0000007C   ............       DC32 ??ANPRO10_IO_UnpackPacket, ??Add, ??SetHWFailure
   \              ............
   \   00000088   ............       DC32 ??RequestMeasuredData, ??GetEEPromData, ??HandleCard
   \              ............
   \   00000094   57496E67723A       DC8 "WIngr:"
   \              00          
   \   0000009B   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   284D2900           DC8 "(M)"

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   28502900           DC8 "(P)"

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   00                 DC8 ""

   \                                 In segment CODE, align 4, keep-with-next
   \   static __??Code32?? __intrinsic __code __interwork __atpcs void __sti__routine()
   \                     ??__sti__routine:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs SCWaterIngress &SCWaterIngress::new SCWaterIngress(PROIOComponent *, PRogramObject *, IOUnit *)
   \                     `??new SCWaterIngress`:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   940FA0E3           MOV      R0,#+592
   \   00000014   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0300000A           BEQ      `??new SCWaterIngress_1`
   \   00000020   0630A0E1           MOV      R3,R6
   \   00000024   0520A0E1           MOV      R2,R5
   \   00000028   0410A0E1           MOV      R1,R4
   \   0000002C   ........           BL       ??SCWaterIngress
   \                     `??new SCWaterIngress_1`:
   \   00000030   7040BDE8           POP      {R4-R6,LR}
   \   00000034   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     ??npos
    363          
    364          
    365          
    366          #endif

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     SCWaterIngress::ANPRO10_IO_UnpackPacket(unsigned char *)
                                       48
     SCWaterIngress::GetEEPromData(unsigned char *)
                                        8
     SCWaterIngress::GetStringValue(int, int, AnsiString &)
                                       48
     SCWaterIngress::GetValue(int, int, float &, int &, int &)
                                       32
     SCWaterIngress::GetValueInfoTable(int &, int)
                                        0
     SCWaterIngress::HandleCard(int)
                                       12
     SCWaterIngress::PutFloatValue(int, float)
                                        4
     SCWaterIngress::PutValue(int, int, AnsiString, bool, int *)
                                       60
     SCWaterIngress::ReceiveData(unsigned char *)
                                       12
     SCWaterIngress::RequestMeasuredData(int)
                                       24
     SCWaterIngress::SCWaterIngress(PROIOComponent *, PRogramObject *, IOUnit *)
                                      272
     SCWaterIngress::SendData(unsigned short)
                                       52
     SCWaterIngress::SetHWFailure(bool)
                                       12
     SCWaterIngress::new SCWaterIngress(PROIOComponent *, PRogramObject *, IOUnit *)
                                       16
     SCWaterIngress::~SCWaterIngress()
                                       12
     __sti__routine()                   0
     operator+(char const *, string const &)
                                       44
     operator+(string const &, string const &)
                                       40
     string::string(string const &)    12


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     string::string(string const &)   64
     operator+(string const &, string const &)
                                      88
     operator+(char const *, string const &)
                                     128
     SCWaterIngress::SCWaterIngressValueList
                                      84
     SCWaterIngress::SCWaterIngress(PROIOComponent *, PRogramObject *, IOUnit *)
                                     536
     ?Subroutine16                    12
     SCWaterIngress::~SCWaterIngress()
                                      48
     ?Subroutine17                     8
     SCWaterIngress::GetValue(int, int, float &, int &, int &)
                                     192
     ?Subroutine18                     8
     SCWaterIngress::GetStringValue(int, int, AnsiString &)
                                     284
     SCWaterIngress::PutValue(int, int, AnsiString, bool, int *)
                                      96
     SCWaterIngress::PutFloatValue(int, float)
                                      12
     ?Subroutine19                     8
     SCWaterIngress::GetValueInfoTable(int &, int)
                                      20
     SCWaterIngress::SetHWFailure(bool)
                                      80
     SCWaterIngress::ANPRO10_IO_UnpackPacket(unsigned char *)
                                     648
     SCWaterIngress::GetEEPromData(unsigned char *)
                                      28
     SCWaterIngress::RequestMeasuredData(int)
                                     116
     SCWaterIngress::HandleCard(int)
                                     128
     SCWaterIngress::ReceiveData(unsigned char *)
                                     280
     SCWaterIngress::SendData(unsigned short)
                                     284
     ?<Initializer for SCWaterIngressValueList>
                                      84
     SCWaterIngress::__vtbl          156
     ?<Constant "(M)">                 4
     ?<Constant "(P)">                 4
     ?<Constant "">                    1
     __sti__routine()                  4
     SCWaterIngress::new SCWaterIngress(PROIOComponent *, PRogramObject *, IOUnit *)
                                      56
     ??DataTable3                      4
      Others                         404

 
 3 520 bytes in segment CODE
   165 bytes in segment DATA_C
    84 bytes in segment DATA_I
    84 bytes in segment DATA_ID
     4 bytes in segment DIFUNCT
    12 bytes in segment INITTAB
 
 2 856 bytes of CODE  memory (+ 680 bytes shared)
   249 bytes of CONST memory
    84 bytes of DATA  memory

Errors: none
Warnings: none
