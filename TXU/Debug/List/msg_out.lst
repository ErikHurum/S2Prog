##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:20:16 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\core\snmp\msg_out.c     #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\core\snmp\msg_out.c     #
#                       --fpu None -D OS_LIBMODE_SP -D CPU_S3C2410 -D        #
#                       OS_RAMVECT=0 -D OS_UART=-1 -D S2TXU -D USE_LZO=1 -D  #
#                       __ARM_LIBRARY__ -D WATCHDOG=1 -D NETWORK=1 -lCN      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\msg_out.lst                 #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\msg_out.r79                  #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\core\snmp\msg_out.c
      1          /**
      2           * @file
      3           * SNMP output message processing (RFC1157).
      4           *
      5           * Output responses and traps are build in two passes:
      6           *
      7           * Pass 0: iterate over the output message backwards to determine encoding lengths
      8           * Pass 1: the actual forward encoding of internal form into ASN1
      9           *
     10           * The single-pass encoding method described by Comer & Stevens
     11           * requires extra buffer space and copying for reversal of the packet.
     12           * The buffer requirement can be prohibitively large for big payloads
     13           * (>= 484) therefore we use the two encoding passes.
     14           */
     15          
     16          /*
     17           * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
     18           * All rights reserved.
     19           *
     20           * Redistribution and use in source and binary forms, with or without modification,
     21           * are permitted provided that the following conditions are met:
     22           *
     23           * 1. Redistributions of source code must retain the above copyright notice,
     24           *    this list of conditions and the following disclaimer.
     25           * 2. Redistributions in binary form must reproduce the above copyright notice,
     26           *    this list of conditions and the following disclaimer in the documentation
     27           *    and/or other materials provided with the distribution.
     28           * 3. The name of the author may not be used to endorse or promote products
     29           *    derived from this software without specific prior written permission.
     30           *
     31           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     32           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     33           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     34           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     35           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     36           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     37           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     38           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     39           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     40           * OF SUCH DAMAGE.
     41           *
     42           * Author: Christiaan Simons <christiaan.simons@axon.tv>
     43           */
     44          
     45          #include "lwip/opt.h"
     46          
     47          #if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
     48          
     49          #include "lwip/udp.h"
     50          #include "lwip/netif.h"
     51          #include "lwip/snmp.h"
     52          #include "lwip/snmp_asn1.h"
     53          #include "lwip/snmp_msg.h"
     54          
     55          struct snmp_trap_dst
     56          {
     57            /* destination IP address in network order */
     58            ip_addr_t dip;
     59            /* set to 0 when disabled, >0 when enabled */
     60            u8_t enable;
     61          };
     62          struct snmp_trap_dst trap_dst[SNMP_TRAP_DESTINATIONS];
     63          
     64          /** TRAP message structure */
     65          struct snmp_msg_trap trap_msg;
     66          
     67          static u16_t snmp_resp_header_sum(struct snmp_msg_pstat *m_stat, u16_t vb_len);
     68          static u16_t snmp_trap_header_sum(struct snmp_msg_trap *m_trap, u16_t vb_len);
     69          static u16_t snmp_varbind_list_sum(struct snmp_varbind_root *root);
     70          
     71          static u16_t snmp_resp_header_enc(struct snmp_msg_pstat *m_stat, struct pbuf *p);
     72          static u16_t snmp_trap_header_enc(struct snmp_msg_trap *m_trap, struct pbuf *p);
     73          static u16_t snmp_varbind_list_enc(struct snmp_varbind_root *root, struct pbuf *p, u16_t ofs);
     74          
     75          /**
     76           * Sets enable switch for this trap destination.
     77           * @param dst_idx index in 0 .. SNMP_TRAP_DESTINATIONS-1
     78           * @param enable switch if 0 destination is disabled >0 enabled.
     79           */
     80          void
     81          snmp_trap_dst_enable(u8_t dst_idx, u8_t enable)
     82          {
     83            if (dst_idx < SNMP_TRAP_DESTINATIONS)
     84            {
     85              trap_dst[dst_idx].enable = enable;
     86            }
     87          }
     88          
     89          /**
     90           * Sets IPv4 address for this trap destination.
     91           * @param dst_idx index in 0 .. SNMP_TRAP_DESTINATIONS-1
     92           * @param dst IPv4 address in host order.
     93           */
     94          void
     95          snmp_trap_dst_ip_set(u8_t dst_idx, ip_addr_t *dst)
     96          {
     97            if (dst_idx < SNMP_TRAP_DESTINATIONS)
     98            {
     99              ip_addr_set(&trap_dst[dst_idx].dip, dst);
    100            }
    101          }
    102          
    103          /**
    104           * Sends a 'getresponse' message to the request originator.
    105           *
    106           * @param m_stat points to the current message request state source
    107           * @return ERR_OK when success, ERR_MEM if we're out of memory
    108           *
    109           * @note the caller is responsible for filling in outvb in the m_stat
    110           * and provide error-status and index (except for tooBig errors) ...
    111           */
    112          err_t
    113          snmp_send_response(struct snmp_msg_pstat *m_stat)
    114          {
    115            struct snmp_varbind_root emptyvb = {NULL, NULL, 0, 0, 0};
    116            struct pbuf *p;
    117            u16_t tot_len;
    118            err_t err;
    119          
    120            /* pass 0, calculate length fields */
    121            tot_len = snmp_varbind_list_sum(&m_stat->outvb);
    122            tot_len = snmp_resp_header_sum(m_stat, tot_len);
    123          
    124            /* try allocating pbuf(s) for complete response */
    125            p = pbuf_alloc(PBUF_TRANSPORT, tot_len, PBUF_POOL);
    126            if (p == NULL)
    127            {
    128              LWIP_DEBUGF(SNMP_MSG_DEBUG, ("snmp_snd_response() tooBig\n"));
    129          
    130              /* can't construct reply, return error-status tooBig */
    131              m_stat->error_status = SNMP_ES_TOOBIG;
    132              m_stat->error_index = 0;
    133              /* pass 0, recalculate lengths, for empty varbind-list */
    134              tot_len = snmp_varbind_list_sum(&emptyvb);
    135              tot_len = snmp_resp_header_sum(m_stat, tot_len);
    136              /* retry allocation once for header and empty varbind-list */
    137              p = pbuf_alloc(PBUF_TRANSPORT, tot_len, PBUF_POOL);
    138            }
    139            if (p != NULL)
    140            {
    141              /* first pbuf alloc try or retry alloc success */
    142              u16_t ofs;
    143          
    144              LWIP_DEBUGF(SNMP_MSG_DEBUG, ("snmp_snd_response() p != NULL\n"));
    145          
    146              /* pass 1, size error, encode packet ino the pbuf(s) */
    147              ofs = snmp_resp_header_enc(m_stat, p);
    148              snmp_varbind_list_enc(&m_stat->outvb, p, ofs);
    149          
    150              switch (m_stat->error_status)
    151              {
    152                case SNMP_ES_TOOBIG:
    153                  snmp_inc_snmpouttoobigs();
    154                  break;
    155                case SNMP_ES_NOSUCHNAME:
    156                  snmp_inc_snmpoutnosuchnames();
    157                  break;
    158                case SNMP_ES_BADVALUE:
    159                  snmp_inc_snmpoutbadvalues();
    160                  break;
    161                case SNMP_ES_GENERROR:
    162                  snmp_inc_snmpoutgenerrs();
    163                  break;
    164              }
    165              snmp_inc_snmpoutgetresponses();
    166              snmp_inc_snmpoutpkts();
    167          
    168              /** @todo do we need separate rx and tx pcbs for threaded case? */
    169              /** connect to the originating source */
    170              udp_connect(m_stat->pcb, &m_stat->sip, m_stat->sp);
    171              err = udp_send(m_stat->pcb, p);
    172              if (err == ERR_MEM)
    173              {
    174                /** @todo release some memory, retry and return tooBig? tooMuchHassle? */
    175                err = ERR_MEM;
    176              }
    177              else
    178              {
    179                err = ERR_OK;
    180              }
    181              /** disassociate remote address and port with this pcb */
    182              udp_disconnect(m_stat->pcb);
    183          
    184              pbuf_free(p);
    185              LWIP_DEBUGF(SNMP_MSG_DEBUG, ("snmp_snd_response() done\n"));
    186              return err;
    187            }
    188            else
    189            {
    190              /* first pbuf alloc try or retry alloc failed
    191                 very low on memory, couldn't return tooBig */
    192              return ERR_MEM;
    193            }
    194          }
    195          
    196          
    197          /**
    198           * Sends an generic or enterprise specific trap message.
    199           *
    200           * @param generic_trap is the trap code
    201           * @param eoid points to enterprise object identifier
    202           * @param specific_trap used for enterprise traps when generic_trap == 6
    203           * @return ERR_OK when success, ERR_MEM if we're out of memory
    204           *
    205           * @note the caller is responsible for filling in outvb in the trap_msg
    206           * @note the use of the enterpise identifier field
    207           * is per RFC1215.
    208           * Use .iso.org.dod.internet.mgmt.mib-2.snmp for generic traps
    209           * and .iso.org.dod.internet.private.enterprises.yourenterprise
    210           * (sysObjectID) for specific traps.
    211           */
    212          err_t
    213          snmp_send_trap(s8_t generic_trap, struct snmp_obj_id *eoid, s32_t specific_trap)
    214          {
    215            struct snmp_trap_dst *td;
    216            struct netif *dst_if;
    217            ip_addr_t dst_ip;
    218            struct pbuf *p;
    219            u16_t i,tot_len;
    220          
    221            for (i=0, td = &trap_dst[0]; i<SNMP_TRAP_DESTINATIONS; i++, td++)
    222            {
    223              if ((td->enable != 0) && !ip_addr_isany(&td->dip))
    224              {
    225                /* network order trap destination */
    226                ip_addr_copy(trap_msg.dip, td->dip);
    227                /* lookup current source address for this dst */
    228                dst_if = ip_route(&td->dip);
    229                ip_addr_copy(dst_ip, dst_if->ip_addr);
    230                /* @todo: what about IPv6? */
    231                trap_msg.sip_raw[0] = ip4_addr1(&dst_ip);
    232                trap_msg.sip_raw[1] = ip4_addr2(&dst_ip);
    233                trap_msg.sip_raw[2] = ip4_addr3(&dst_ip);
    234                trap_msg.sip_raw[3] = ip4_addr4(&dst_ip);
    235                trap_msg.gen_trap = generic_trap;
    236                trap_msg.spc_trap = specific_trap;
    237                if (generic_trap == SNMP_GENTRAP_ENTERPRISESPC)
    238                {
    239                  /* enterprise-Specific trap */
    240                  trap_msg.enterprise = eoid;
    241                }
    242                else
    243                {
    244                  /* generic (MIB-II) trap */
    245                  snmp_get_snmpgrpid_ptr(&trap_msg.enterprise);
    246                }
    247                snmp_get_sysuptime(&trap_msg.ts);
    248          
    249                /* pass 0, calculate length fields */
    250                tot_len = snmp_varbind_list_sum(&trap_msg.outvb);
    251                tot_len = snmp_trap_header_sum(&trap_msg, tot_len);
    252          
    253                /* allocate pbuf(s) */
    254                p = pbuf_alloc(PBUF_TRANSPORT, tot_len, PBUF_POOL);
    255                if (p != NULL)
    256                {
    257                  u16_t ofs;
    258          
    259                  /* pass 1, encode packet ino the pbuf(s) */
    260                  ofs = snmp_trap_header_enc(&trap_msg, p);
    261                  snmp_varbind_list_enc(&trap_msg.outvb, p, ofs);
    262          
    263                  snmp_inc_snmpouttraps();
    264                  snmp_inc_snmpoutpkts();
    265          
    266                  /** send to the TRAP destination */
    267                  udp_sendto(trap_msg.pcb, p, &trap_msg.dip, SNMP_TRAP_PORT);
    268          
    269                  pbuf_free(p);
    270                }
    271                else
    272                {
    273                  return ERR_MEM;
    274                }
    275              }
    276            }
    277            return ERR_OK;
    278          }
    279          
    280          void
    281          snmp_coldstart_trap(void)
    282          {
    283            trap_msg.outvb.head = NULL;
    284            trap_msg.outvb.tail = NULL;
    285            trap_msg.outvb.count = 0;
    286            snmp_send_trap(SNMP_GENTRAP_COLDSTART, NULL, 0);
    287          }
    288          
    289          void
    290          snmp_authfail_trap(void)
    291          {
    292            u8_t enable;
    293            snmp_get_snmpenableauthentraps(&enable);
    294            if (enable == 1)
    295            {
    296              trap_msg.outvb.head = NULL;
    297              trap_msg.outvb.tail = NULL;
    298              trap_msg.outvb.count = 0;
    299              snmp_send_trap(SNMP_GENTRAP_AUTHFAIL, NULL, 0);
    300            }
    301          }
    302          
    303          /**
    304           * Sums response header field lengths from tail to head and
    305           * returns resp_header_lengths for second encoding pass.
    306           *
    307           * @param vb_len varbind-list length
    308           * @param rhl points to returned header lengths
    309           * @return the required lenght for encoding the response header
    310           */
    311          static u16_t
    312          snmp_resp_header_sum(struct snmp_msg_pstat *m_stat, u16_t vb_len)
    313          {
    314            u16_t tot_len;
    315            struct snmp_resp_header_lengths *rhl;
    316          
    317            rhl = &m_stat->rhl;
    318            tot_len = vb_len;
    319            snmp_asn1_enc_s32t_cnt(m_stat->error_index, &rhl->erridxlen);
    320            snmp_asn1_enc_length_cnt(rhl->erridxlen, &rhl->erridxlenlen);
    321            tot_len += 1 + rhl->erridxlenlen + rhl->erridxlen;
    322          
    323            snmp_asn1_enc_s32t_cnt(m_stat->error_status, &rhl->errstatlen);
    324            snmp_asn1_enc_length_cnt(rhl->errstatlen, &rhl->errstatlenlen);
    325            tot_len += 1 + rhl->errstatlenlen + rhl->errstatlen;
    326          
    327            snmp_asn1_enc_s32t_cnt(m_stat->rid, &rhl->ridlen);
    328            snmp_asn1_enc_length_cnt(rhl->ridlen, &rhl->ridlenlen);
    329            tot_len += 1 + rhl->ridlenlen + rhl->ridlen;
    330          
    331            rhl->pdulen = tot_len;
    332            snmp_asn1_enc_length_cnt(rhl->pdulen, &rhl->pdulenlen);
    333            tot_len += 1 + rhl->pdulenlen;
    334          
    335            rhl->comlen = m_stat->com_strlen;
    336            snmp_asn1_enc_length_cnt(rhl->comlen, &rhl->comlenlen);
    337            tot_len += 1 + rhl->comlenlen + rhl->comlen;
    338          
    339            snmp_asn1_enc_s32t_cnt(snmp_version, &rhl->verlen);
    340            snmp_asn1_enc_length_cnt(rhl->verlen, &rhl->verlenlen);
    341            tot_len += 1 + rhl->verlen + rhl->verlenlen;
    342          
    343            rhl->seqlen = tot_len;
    344            snmp_asn1_enc_length_cnt(rhl->seqlen, &rhl->seqlenlen);
    345            tot_len += 1 + rhl->seqlenlen;
    346          
    347            return tot_len;
    348          }
    349          
    350          /**
    351           * Sums trap header field lengths from tail to head and
    352           * returns trap_header_lengths for second encoding pass.
    353           *
    354           * @param vb_len varbind-list length
    355           * @param thl points to returned header lengths
    356           * @return the required lenght for encoding the trap header
    357           */
    358          static u16_t
    359          snmp_trap_header_sum(struct snmp_msg_trap *m_trap, u16_t vb_len)
    360          {
    361            u16_t tot_len;
    362            struct snmp_trap_header_lengths *thl;
    363          
    364            thl = &m_trap->thl;
    365            tot_len = vb_len;
    366          
    367            snmp_asn1_enc_u32t_cnt(m_trap->ts, &thl->tslen);
    368            snmp_asn1_enc_length_cnt(thl->tslen, &thl->tslenlen);
    369            tot_len += 1 + thl->tslen + thl->tslenlen;
    370          
    371            snmp_asn1_enc_s32t_cnt(m_trap->spc_trap, &thl->strplen);
    372            snmp_asn1_enc_length_cnt(thl->strplen, &thl->strplenlen);
    373            tot_len += 1 + thl->strplen + thl->strplenlen;
    374          
    375            snmp_asn1_enc_s32t_cnt(m_trap->gen_trap, &thl->gtrplen);
    376            snmp_asn1_enc_length_cnt(thl->gtrplen, &thl->gtrplenlen);
    377            tot_len += 1 + thl->gtrplen + thl->gtrplenlen;
    378          
    379            thl->aaddrlen = 4;
    380            snmp_asn1_enc_length_cnt(thl->aaddrlen, &thl->aaddrlenlen);
    381            tot_len += 1 + thl->aaddrlen + thl->aaddrlenlen;
    382          
    383            snmp_asn1_enc_oid_cnt(m_trap->enterprise->len, &m_trap->enterprise->id[0], &thl->eidlen);
    384            snmp_asn1_enc_length_cnt(thl->eidlen, &thl->eidlenlen);
    385            tot_len += 1 + thl->eidlen + thl->eidlenlen;
    386          
    387            thl->pdulen = tot_len;
    388            snmp_asn1_enc_length_cnt(thl->pdulen, &thl->pdulenlen);
    389            tot_len += 1 + thl->pdulenlen;
    390          
    391            thl->comlen = sizeof(snmp_publiccommunity) - 1;
    392            snmp_asn1_enc_length_cnt(thl->comlen, &thl->comlenlen);
    393            tot_len += 1 + thl->comlenlen + thl->comlen;
    394          
    395            snmp_asn1_enc_s32t_cnt(snmp_version, &thl->verlen);
    396            snmp_asn1_enc_length_cnt(thl->verlen, &thl->verlenlen);
    397            tot_len += 1 + thl->verlen + thl->verlenlen;
    398          
    399            thl->seqlen = tot_len;
    400            snmp_asn1_enc_length_cnt(thl->seqlen, &thl->seqlenlen);
    401            tot_len += 1 + thl->seqlenlen;
    402          
    403            return tot_len;
    404          }
    405          
    406          /**
    407           * Sums varbind lengths from tail to head and
    408           * annotates lengths in varbind for second encoding pass.
    409           *
    410           * @param root points to the root of the variable binding list
    411           * @return the required lenght for encoding the variable bindings
    412           */
    413          static u16_t
    414          snmp_varbind_list_sum(struct snmp_varbind_root *root)
    415          {
    416            struct snmp_varbind *vb;
    417            u32_t *uint_ptr;
    418            s32_t *sint_ptr;
    419            u16_t tot_len;
    420          
    421            tot_len = 0;
    422            vb = root->tail;
    423            while ( vb != NULL )
    424            {
    425              /* encoded value lenght depends on type */
    426              switch (vb->value_type)
    427              {
    428                case (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG):
    429                  sint_ptr = (s32_t*)vb->value;
    430                  snmp_asn1_enc_s32t_cnt(*sint_ptr, &vb->vlen);
    431                  break;
    432                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_COUNTER):
    433                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_GAUGE):
    434                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_TIMETICKS):
    435                  uint_ptr = (u32_t*)vb->value;
    436                  snmp_asn1_enc_u32t_cnt(*uint_ptr, &vb->vlen);
    437                  break;
    438                case (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OC_STR):
    439                case (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_NUL):
    440                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_IPADDR):
    441                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_OPAQUE):
    442                  vb->vlen = vb->value_len;
    443                  break;
    444                case (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OBJ_ID):
    445                  sint_ptr = (s32_t*)vb->value;
    446                  snmp_asn1_enc_oid_cnt(vb->value_len / sizeof(s32_t), sint_ptr, &vb->vlen);
    447                  break;
    448                default:
    449                  /* unsupported type */
    450                  vb->vlen = 0;
    451                  break;
    452              };
    453              /* encoding length of value length field */
    454              snmp_asn1_enc_length_cnt(vb->vlen, &vb->vlenlen);
    455              snmp_asn1_enc_oid_cnt(vb->ident_len, vb->ident, &vb->olen);
    456              snmp_asn1_enc_length_cnt(vb->olen, &vb->olenlen);
    457          
    458              vb->seqlen = 1 + vb->vlenlen + vb->vlen;
    459              vb->seqlen += 1 + vb->olenlen + vb->olen;
    460              snmp_asn1_enc_length_cnt(vb->seqlen, &vb->seqlenlen);
    461          
    462              /* varbind seq */
    463              tot_len += 1 + vb->seqlenlen + vb->seqlen;
    464          
    465              vb = vb->prev;
    466            }
    467          
    468            /* varbind-list seq */
    469            root->seqlen = tot_len;
    470            snmp_asn1_enc_length_cnt(root->seqlen, &root->seqlenlen);
    471            tot_len += 1 + root->seqlenlen;
    472          
    473            return tot_len;
    474          }
    475          
    476          /**
    477           * Encodes response header from head to tail.
    478           */
    479          static u16_t
    480          snmp_resp_header_enc(struct snmp_msg_pstat *m_stat, struct pbuf *p)
    481          {
    482            u16_t ofs;
    483          
    484            ofs = 0;
    485            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_CONSTR | SNMP_ASN1_SEQ));
    486            ofs += 1;
    487            snmp_asn1_enc_length(p, ofs, m_stat->rhl.seqlen);
    488            ofs += m_stat->rhl.seqlenlen;
    489          
    490            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG));
    491            ofs += 1;
    492            snmp_asn1_enc_length(p, ofs, m_stat->rhl.verlen);
    493            ofs += m_stat->rhl.verlenlen;
    494            snmp_asn1_enc_s32t(p, ofs, m_stat->rhl.verlen, snmp_version);
    495            ofs += m_stat->rhl.verlen;
    496          
    497            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OC_STR));
    498            ofs += 1;
    499            snmp_asn1_enc_length(p, ofs, m_stat->rhl.comlen);
    500            ofs += m_stat->rhl.comlenlen;
    501            snmp_asn1_enc_raw(p, ofs, m_stat->rhl.comlen, m_stat->community);
    502            ofs += m_stat->rhl.comlen;
    503          
    504            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_CONTXT | SNMP_ASN1_CONSTR | SNMP_ASN1_PDU_GET_RESP));
    505            ofs += 1;
    506            snmp_asn1_enc_length(p, ofs, m_stat->rhl.pdulen);
    507            ofs += m_stat->rhl.pdulenlen;
    508          
    509            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG));
    510            ofs += 1;
    511            snmp_asn1_enc_length(p, ofs, m_stat->rhl.ridlen);
    512            ofs += m_stat->rhl.ridlenlen;
    513            snmp_asn1_enc_s32t(p, ofs, m_stat->rhl.ridlen, m_stat->rid);
    514            ofs += m_stat->rhl.ridlen;
    515          
    516            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG));
    517            ofs += 1;
    518            snmp_asn1_enc_length(p, ofs, m_stat->rhl.errstatlen);
    519            ofs += m_stat->rhl.errstatlenlen;
    520            snmp_asn1_enc_s32t(p, ofs, m_stat->rhl.errstatlen, m_stat->error_status);
    521            ofs += m_stat->rhl.errstatlen;
    522          
    523            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG));
    524            ofs += 1;
    525            snmp_asn1_enc_length(p, ofs, m_stat->rhl.erridxlen);
    526            ofs += m_stat->rhl.erridxlenlen;
    527            snmp_asn1_enc_s32t(p, ofs, m_stat->rhl.erridxlen, m_stat->error_index);
    528            ofs += m_stat->rhl.erridxlen;
    529          
    530            return ofs;
    531          }
    532          
    533          /**
    534           * Encodes trap header from head to tail.
    535           */
    536          static u16_t
    537          snmp_trap_header_enc(struct snmp_msg_trap *m_trap, struct pbuf *p)
    538          {
    539            u16_t ofs;
    540          
    541            ofs = 0;
    542            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_CONSTR | SNMP_ASN1_SEQ));
    543            ofs += 1;
    544            snmp_asn1_enc_length(p, ofs, m_trap->thl.seqlen);
    545            ofs += m_trap->thl.seqlenlen;
    546          
    547            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG));
    548            ofs += 1;
    549            snmp_asn1_enc_length(p, ofs, m_trap->thl.verlen);
    550            ofs += m_trap->thl.verlenlen;
    551            snmp_asn1_enc_s32t(p, ofs, m_trap->thl.verlen, snmp_version);
    552            ofs += m_trap->thl.verlen;
    553          
    554            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OC_STR));
    555            ofs += 1;
    556            snmp_asn1_enc_length(p, ofs, m_trap->thl.comlen);
    557            ofs += m_trap->thl.comlenlen;
    558            snmp_asn1_enc_raw(p, ofs, m_trap->thl.comlen, (u8_t *)&snmp_publiccommunity[0]);
    559            ofs += m_trap->thl.comlen;
    560          
    561            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_CONTXT | SNMP_ASN1_CONSTR | SNMP_ASN1_PDU_TRAP));
    562            ofs += 1;
    563            snmp_asn1_enc_length(p, ofs, m_trap->thl.pdulen);
    564            ofs += m_trap->thl.pdulenlen;
    565          
    566            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OBJ_ID));
    567            ofs += 1;
    568            snmp_asn1_enc_length(p, ofs, m_trap->thl.eidlen);
    569            ofs += m_trap->thl.eidlenlen;
    570            snmp_asn1_enc_oid(p, ofs, m_trap->enterprise->len, &m_trap->enterprise->id[0]);
    571            ofs += m_trap->thl.eidlen;
    572          
    573            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_IPADDR));
    574            ofs += 1;
    575            snmp_asn1_enc_length(p, ofs, m_trap->thl.aaddrlen);
    576            ofs += m_trap->thl.aaddrlenlen;
    577            snmp_asn1_enc_raw(p, ofs, m_trap->thl.aaddrlen, &m_trap->sip_raw[0]);
    578            ofs += m_trap->thl.aaddrlen;
    579          
    580            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG));
    581            ofs += 1;
    582            snmp_asn1_enc_length(p, ofs, m_trap->thl.gtrplen);
    583            ofs += m_trap->thl.gtrplenlen;
    584            snmp_asn1_enc_u32t(p, ofs, m_trap->thl.gtrplen, m_trap->gen_trap);
    585            ofs += m_trap->thl.gtrplen;
    586          
    587            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG));
    588            ofs += 1;
    589            snmp_asn1_enc_length(p, ofs, m_trap->thl.strplen);
    590            ofs += m_trap->thl.strplenlen;
    591            snmp_asn1_enc_u32t(p, ofs, m_trap->thl.strplen, m_trap->spc_trap);
    592            ofs += m_trap->thl.strplen;
    593          
    594            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_TIMETICKS));
    595            ofs += 1;
    596            snmp_asn1_enc_length(p, ofs, m_trap->thl.tslen);
    597            ofs += m_trap->thl.tslenlen;
    598            snmp_asn1_enc_u32t(p, ofs, m_trap->thl.tslen, m_trap->ts);
    599            ofs += m_trap->thl.tslen;
    600          
    601            return ofs;
    602          }
    603          
    604          /**
    605           * Encodes varbind list from head to tail.
    606           */
    607          static u16_t
    608          snmp_varbind_list_enc(struct snmp_varbind_root *root, struct pbuf *p, u16_t ofs)
    609          {
    610            struct snmp_varbind *vb;
    611            s32_t *sint_ptr;
    612            u32_t *uint_ptr;
    613            u8_t *raw_ptr;
    614          
    615            snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_CONSTR | SNMP_ASN1_SEQ));
    616            ofs += 1;
    617            snmp_asn1_enc_length(p, ofs, root->seqlen);
    618            ofs += root->seqlenlen;
    619          
    620            vb = root->head;
    621            while ( vb != NULL )
    622            {
    623              snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_CONSTR | SNMP_ASN1_SEQ));
    624              ofs += 1;
    625              snmp_asn1_enc_length(p, ofs, vb->seqlen);
    626              ofs += vb->seqlenlen;
    627          
    628              snmp_asn1_enc_type(p, ofs, (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OBJ_ID));
    629              ofs += 1;
    630              snmp_asn1_enc_length(p, ofs, vb->olen);
    631              ofs += vb->olenlen;
    632              snmp_asn1_enc_oid(p, ofs, vb->ident_len, &vb->ident[0]);
    633              ofs += vb->olen;
    634          
    635              snmp_asn1_enc_type(p, ofs, vb->value_type);
    636              ofs += 1;
    637              snmp_asn1_enc_length(p, ofs, vb->vlen);
    638              ofs += vb->vlenlen;
    639          
    640              switch (vb->value_type)
    641              {
    642                case (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_INTEG):
    643                  sint_ptr = (s32_t*)vb->value;
    644                  snmp_asn1_enc_s32t(p, ofs, vb->vlen, *sint_ptr);
    645                  break;
    646                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_COUNTER):
    647                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_GAUGE):
    648                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_TIMETICKS):
    649                  uint_ptr = (u32_t*)vb->value;
    650                  snmp_asn1_enc_u32t(p, ofs, vb->vlen, *uint_ptr);
    651                  break;
    652                case (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OC_STR):
    653                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_IPADDR):
    654                case (SNMP_ASN1_APPLIC | SNMP_ASN1_PRIMIT | SNMP_ASN1_OPAQUE):
    655                  raw_ptr = (u8_t*)vb->value;
    656                  snmp_asn1_enc_raw(p, ofs, vb->vlen, raw_ptr);
    657                  break;
    658                case (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_NUL):
    659                  break;
    660                case (SNMP_ASN1_UNIV | SNMP_ASN1_PRIMIT | SNMP_ASN1_OBJ_ID):
    661                  sint_ptr = (s32_t*)vb->value;
    662                  snmp_asn1_enc_oid(p, ofs, vb->value_len / sizeof(s32_t), sint_ptr);
    663                  break;
    664                default:
    665                  /* unsupported type */
    666                  break;
    667              };
    668              ofs += vb->vlen;
    669              vb = vb->next;
    670            }
    671            return ofs;
    672          }
    673          
    674          #endif /* LWIP_SNMP */
    675          


   Segment part sizes:

     Function/Label Bytes
     -------------- -----

 
 
 0 bytes of memory

Errors: none
Warnings: none
