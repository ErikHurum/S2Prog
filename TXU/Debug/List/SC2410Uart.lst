##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:17:18 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\src\SC2410Uart.cpp                     #
#    Command line    =  D:\S2Prog\TXU\src\SC2410Uart.cpp --fpu None -D       #
#                       OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D      #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --eec++           #
#                       --dlib_config "C:\Program Files (x86)\IAR            #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl4tpainl8n.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\SC2410Uart.lst              #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\SC2410Uart.r79               #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\src\SC2410Uart.cpp
      1          #include <string.h>
      2          #include <ctype.h>
      3          #include <stdlib.h>
      4          
      5          #include "def.h"
      6          #include "2410addr.h"
      7          #include "2410lib.h"
      8          #include "2410slib.h"
      9          #include "rtos.h"
     10          //#include "ANPro10Inc.h"
     11          #include "TSNDefines.h"
     12          #include "TSNConstants.h"
     13          #include "ANSIString.h"
     14          #include "TSNConfigString.h"
     15          #include "TsnUart.h"
     16          #include "SC2410Uart.h"
     17          
     18          
     19          extern int OS_FSys;
     20          

   \                                 In segment CODE, align 4, keep-with-next
     21          SC2410Uart::SC2410Uart(int PortNum,unsigned BdRate,unsigned WrdLength,unsigned StpBits,char Prty, unsigned BufSize, int Dev, int HWProt,int SWProt, bool IsMstr,int MaxTimeChar,bool Relax, int LogP, int LogE):
   \                     ??SC2410Uart:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
   \   00000004   2C20DDE5           LDRB     R2,[SP, #+44]
   \   00000008   4070DDE5           LDRB     R7,[SP, #+64]
   \   0000000C   4890DDE5           LDRB     R9,[SP, #+72]
   \   00000010   30509DE5           LDR      R5,[SP, #+48]
   \   00000014   34C09DE5           LDR      R12,[SP, #+52]
   \   00000018   38E09DE5           LDR      LR,[SP, #+56]
   \   0000001C   3C609DE5           LDR      R6,[SP, #+60]
   \   00000020   44809DE5           LDR      R8,[SP, #+68]
   \   00000024   4CA09DE5           LDR      R10,[SP, #+76]
   \   00000028   50B09DE5           LDR      R11,[SP, #+80]
   \   0000002C   0040A0E1           MOV      R4,R0
   \   00000030   28009DE5           LDR      R0,[SP, #+40]
     22          TSNUart(PortNum,BdRate,WrdLength, StpBits, Prty, BufSize, Dev, HWProt,SWProt, IsMstr,MaxTimeChar, Relax, LogP, LogE)
     23          {
   \   00000034   00082DE9           PUSH     {R11}
   \   00000038   00042DE9           PUSH     {R10}
   \   0000003C   00022DE9           PUSH     {R9}
   \   00000040   00012DE9           PUSH     {R8}
   \   00000044   80002DE9           PUSH     {R7}
   \   00000048   0670A0E1           MOV      R7,R6
   \   0000004C   80002DE9           PUSH     {R7}
   \   00000050   00402DE9           PUSH     {LR}
   \   00000054   00102DE9           PUSH     {R12}
   \   00000058   0570A0E1           MOV      R7,R5
   \   0000005C   80002DE9           PUSH     {R7}
   \   00000060   04002DE9           PUSH     {R2}
   \   00000064   01002DE9           PUSH     {R0}
   \   00000068   2C209DE5           LDR      R2,[SP, #+44]
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           _BLF     ??TSNUart,??TSNUart??rA
   \   00000074   44029FE5           LDR      R0,??SC2410Uart_1  ;; ??__vtbl
   \   00000078   2CD08DE2           ADD      SP,SP,#+44
   \   0000007C   DC0084E5           STR      R0,[R4, #+220]
     24          	OS_CREATERSEMA(&TxSema);
   \   00000080   700084E2           ADD      R0,R4,#+112
   \   00000084   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
     25          	Channels[PortNumber] = this;
   \   00000088   800094E5           LDR      R0,[R4, #+128]
   \   0000008C   30129FE5           LDR      R1,??SC2410Uart_1+0x4  ;; ??Channels
   \   00000090   004181E7           STR      R4,[R1, +R0, LSL #+2]
     26          
     27          	RxBufPtr=(U8*)malloc(BufSize);
   \   00000094   0500A0E1           MOV      R0,R5
   \   00000098   ........           _BLF     __data_malloc,??__data_malloc??rA
   \   0000009C   240084E5           STR      R0,[R4, #+36]
     28          	OS_CreateMB(&RxBuf,1,BufSize,(char*)RxBufPtr);
   \   000000A0   0030A0E1           MOV      R3,R0
   \   000000A4   0520A0E1           MOV      R2,R5
   \   000000A8   0110A0E3           MOV      R1,#+1
   \   000000AC   0400A0E1           MOV      R0,R4
   \   000000B0   ........           _BLF     OS_CreateMB,??OS_CreateMB??rA
     29          
     30          	switch ( PortNumber ) {
   \   000000B4   801094E5           LDR      R1,[R4, #+128]
   \   000000B8   0400A0E3           MOV      R0,#+4
   \   000000BC   0120B0E1           MOVS     R2,R1
   \   000000C0   0400000A           BEQ      ??SC2410Uart_2
   \   000000C4   012051E2           SUBS     R2,R1,#+1
   \   000000C8   0800000A           BEQ      ??SC2410Uart_3
   \   000000CC   012052E2           SUBS     R2,R2,#+1
   \   000000D0   0C00000A           BEQ      ??SC2410Uart_4
   \   000000D4   110000EA           B        ??SC2410Uart_5
     31          	case 0:
     32          		BitSubRx  = BIT_SUB_RXD0;
   \                     ??SC2410Uart_2:
   \   000000D8   0120A0E3           MOV      R2,#+1
   \   000000DC   E02084E5           STR      R2,[R4, #+224]
     33          		BitSubTx  = BIT_SUB_TXD0;
   \   000000E0   0220A0E3           MOV      R2,#+2
   \   000000E4   E42084E5           STR      R2,[R4, #+228]
     34          		BitSubErr = BIT_SUB_ERR0;
   \   000000E8   E80084E5           STR      R0,[R4, #+232]
   \   000000EC   0B0000EA           B        ??SC2410Uart_5
     35          		break;
     36          	case 1:
     37          		BitSubRx  = BIT_SUB_RXD1;
   \                     ??SC2410Uart_3:
   \   000000F0   0820A0E3           MOV      R2,#+8
   \   000000F4   E02084E5           STR      R2,[R4, #+224]
     38          		BitSubTx  = BIT_SUB_TXD1;
   \   000000F8   1020A0E3           MOV      R2,#+16
   \   000000FC   E42084E5           STR      R2,[R4, #+228]
     39          		BitSubErr = BIT_SUB_ERR1;
   \   00000100   2020A0E3           MOV      R2,#+32
   \   00000104   040000EA           B        ??SC2410Uart_6
     40          		break;
     41          	case 2:
     42          		BitSubRx  = BIT_SUB_RXD2;
   \                     ??SC2410Uart_4:
   \   00000108   4020A0E3           MOV      R2,#+64
   \   0000010C   E02084E5           STR      R2,[R4, #+224]
     43          		BitSubTx  = BIT_SUB_TXD2;
   \   00000110   8020A0E3           MOV      R2,#+128
   \   00000114   E42084E5           STR      R2,[R4, #+228]
     44          		BitSubErr = BIT_SUB_ERR2;
   \   00000118   402FA0E3           MOV      R2,#+256
   \                     ??SC2410Uart_6:
   \   0000011C   E82084E5           STR      R2,[R4, #+232]
     45          		break;
     46          	}
     47          	{
     48          		unsigned PortOffset = 0x4000*PortNumber;
   \                     ??SC2410Uart_5:
   \   00000120   0117A0E1           LSL      R1,R1,#+14
     49          		rTxReg          =(unsigned char*)(ADDR_UTXH0   + PortOffset);
   \   00000124   2020A0E3           MOV      R2,#+32
   \   00000128   502482E3           ORR      R2,R2,#0x50000000
   \   0000012C   012082E0           ADD      R2,R2,R1
   \   00000130   F82084E5           STR      R2,[R4, #+248]
     50          		rRxReg          =(unsigned char*)(ADDR_URXH0   + PortOffset);
   \   00000134   2420A0E3           MOV      R2,#+36
   \   00000138   502482E3           ORR      R2,R2,#0x50000000
   \   0000013C   012082E0           ADD      R2,R2,R1
   \   00000140   F42084E5           STR      R2,[R4, #+244]
     51          		rLineControl    =(unsigned*)(ADDR_ULCON0  + PortOffset);
   \   00000144   502481E2           ADD      R2,R1,#+1342177280
   \   00000148   FC2084E5           STR      R2,[R4, #+252]
     52          		rUartControl    =(unsigned*)(ADDR_UCON0   + PortOffset);
   \   0000014C   452281E2           ADD      R2,R1,#+1342177284
   \   00000150   002184E5           STR      R2,[R4, #+256]
     53          		rFIFOControl    =(unsigned*)(ADDR_UFCON0  + PortOffset);
   \   00000154   852281E2           ADD      R2,R1,#+1342177288
   \   00000158   042184E5           STR      R2,[R4, #+260]
     54          		rModemControl   =(unsigned*)(ADDR_UMCON0  + PortOffset);
   \   0000015C   C52281E2           ADD      R2,R1,#+1342177292
   \   00000160   082184E5           STR      R2,[R4, #+264]
     55          		rTxRxStatus     =(unsigned*)(ADDR_UTRSTAT0+ PortOffset);
   \   00000164   1020A0E3           MOV      R2,#+16
   \   00000168   502482E3           ORR      R2,R2,#0x50000000
   \   0000016C   012082E0           ADD      R2,R2,R1
   \   00000170   0C2184E5           STR      R2,[R4, #+268]
     56          		rRxErrorStatus  =(unsigned*)(ADDR_UERSTAT0+ PortOffset);
   \   00000174   1420A0E3           MOV      R2,#+20
   \   00000178   502482E3           ORR      R2,R2,#0x50000000
   \   0000017C   012082E0           ADD      R2,R2,R1
   \   00000180   102184E5           STR      R2,[R4, #+272]
     57          		rFIFOStatus     =(unsigned*)(ADDR_UFSTAT0 + PortOffset);
   \   00000184   1820A0E3           MOV      R2,#+24
   \   00000188   502482E3           ORR      R2,R2,#0x50000000
   \   0000018C   012082E0           ADD      R2,R2,R1
   \   00000190   1C2184E5           STR      R2,[R4, #+284]
     58          		rModemStatus    =(unsigned*)(ADDR_UMSTAT0 + PortOffset);
   \   00000194   1C20A0E3           MOV      R2,#+28
   \   00000198   502482E3           ORR      R2,R2,#0x50000000
   \   0000019C   012082E0           ADD      R2,R2,R1
   \   000001A0   142184E5           STR      R2,[R4, #+276]
     59          		rBaudRateDivisor=(unsigned*)(ADDR_UBRDIV0 + PortOffset);
   \   000001A4   2820A0E3           MOV      R2,#+40
   \   000001A8   502482E3           ORR      R2,R2,#0x50000000
   \   000001AC   012082E0           ADD      R2,R2,R1
   \   000001B0   182184E5           STR      R2,[R4, #+280]
     60          	}
     61          
     62          	switch ( toupper(Parity) ) {
   \   000001B4   C010D4E5           LDRB     R1,[R4, #+192]
   \   000001B8   610051E3           CMP      R1,#+97
   \   000001BC   010000BA           BLT      ??SC2410Uart_7
   \   000001C0   7B0051E3           CMP      R1,#+123
   \   000001C4   201041B2           SUBLT    R1,R1,#+32
   \                     ??SC2410Uart_7:
   \   000001C8   451051E2           SUBS     R1,R1,#+69
   \   000001CC   0200000A           BEQ      ??SC2410Uart_8
   \   000001D0   0A1051E2           SUBS     R1,R1,#+10
   \   000001D4   0300000A           BEQ      ??SC2410Uart_9
   \   000001D8   010000EA           B        ??SC2410Uart_10
     63          	case 'E':
     64          		ParityValue = 0x05;
   \                     ??SC2410Uart_8:
   \   000001DC   0500A0E3           MOV      R0,#+5
   \   000001E0   000000EA           B        ??SC2410Uart_9
     65          		break;
     66          	case 'O':
     67          		ParityValue = 0x04;
     68          		break;
     69          	default:
     70          	case 'N':
     71          		ParityValue = 0x00;
   \                     ??SC2410Uart_10:
   \   000001E4   0000A0E3           MOV      R0,#+0
   \                     ??SC2410Uart_9:
   \   000001E8   C100C4E5           STRB     R0,[R4, #+193]
     72          		break;
     73          	}
     74          	*rUartControl = 0x85;	// Rx timeout enable
   \   000001EC   000194E5           LDR      R0,[R4, #+256]
   \   000001F0   8510A0E3           MOV      R1,#+133
   \   000001F4   001080E5           STR      R1,[R0, #+0]
     75          	*rLineControl =  (ParityValue<<3) | (WordLength-5) | (StopBits-1);
   \   000001F8   C110D4E5           LDRB     R1,[R4, #+193]
   \   000001FC   B03094E5           LDR      R3,[R4, #+176]
   \   00000200   FC0094E5           LDR      R0,[R4, #+252]
   \   00000204   053043E2           SUB      R3,R3,#+5
   \   00000208   811183E1           ORR      R1,R3,R1, LSL #+3
   \   0000020C   B43094E5           LDR      R3,[R4, #+180]
   \   00000210   013043E2           SUB      R3,R3,#+1
   \   00000214   011083E1           ORR      R1,R3,R1
   \   00000218   001080E5           STR      R1,[R0, #+0]
     76          	*rBaudRateDivisor = (OS_FSys/4)/(16*BaudRate)-1;
   \   0000021C   A4009FE5           LDR      R0,??SC2410Uart_1+0x8  ;; OS_FSys
   \   00000220   000090E5           LDR      R0,[R0, #+0]
   \   00000224   C010A0E1           ASR      R1,R0,#+1
   \   00000228   210F80E0           ADD      R0,R0,R1, LSR #+30
   \   0000022C   AC1094E5           LDR      R1,[R4, #+172]
   \   00000230   4001A0E1           ASR      R0,R0,#+2
   \   00000234   0112A0E1           LSL      R1,R1,#+4
   \   00000238   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   0000023C   010041E2           SUB      R0,R1,#+1
   \   00000240   000082E5           STR      R0,[R2, #+0]
     77          	if ( HWProtocol == C_UART_HWPRO_485 ) {
   \   00000244   A00094E5           LDR      R0,[R4, #+160]
   \   00000248   4C10A0E3           MOV      R1,#+76
   \   0000024C   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000250   010050E1           CMP      R0,R1
   \   00000254   0400001A           BNE      ??SC2410Uart_11
     78          		// Turn off the RS485 if nothing to send on this interrupt
     79          		rGPHDAT &= ~2;
   \   00000258   7400A0E3           MOV      R0,#+116
   \   0000025C   560480E3           ORR      R0,R0,#0x56000000
   \   00000260   001090E5           LDR      R1,[R0, #+0]
   \   00000264   0210C1E3           BIC      R1,R1,#0x2
   \   00000268   001080E5           STR      R1,[R0, #+0]
     80          	}
     81          	switch(SWProt){
   \                     ??SC2410Uart_11:
   \   0000026C   5800A0E3           MOV      R0,#+88
   \   00000270   7C0D80E3           ORR      R0,R0,#0x1F00
   \   00000274   000056E1           CMP      R6,R0
   \   00000278   0400001A           BNE      ??SC2410Uart_12
     82          	case C_UART_SWPRO_MODBUS:
     83          		if ( BdRate > 19200 ) {
   \   0000027C   00009DE5           LDR      R0,[SP, #+0]
   \   00000280   0110A0E3           MOV      R1,#+1
   \   00000284   4B1C81E3           ORR      R1,R1,#0x4B00
   \   00000288   010050E1           CMP      R0,R1
   \   0000028C   0300003A           BCC      ??SC2410Uart_13
     84          			//Speed too high to measure time between character so better use FIFO
     85          			EnableFIFO(0,12);   
     86          			//EnableFIFO(0,0); 
     87          		}
     88          		break;
     89          	default:
     90          		EnableFIFO(0,12);
   \                     ??SC2410Uart_12:
   \   00000290   0C20A0E3           MOV      R2,#+12
   \   00000294   0010A0E3           MOV      R1,#+0
   \   00000298   0400A0E1           MOV      R0,R4
   \   0000029C   ........           BL       ??EnableFIFO
     91          		break;
     92          	}
     93          
     94          	EnableInt();
   \                     ??SC2410Uart_13:
   \   000002A0   DC1094E5           LDR      R1,[R4, #+220]
   \   000002A4   0400A0E1           MOV      R0,R4
   \   000002A8   001091E5           LDR      R1,[R1, #+0]
   \   000002AC   0FE0A0E1           MOV      LR,PC
   \   000002B0   11FF2FE1           BX       R1
     95          }
   \   000002B4   0400A0E1           MOV      R0,R4
   \   000002B8   F24FBDE8           POP      {R1,R4-R11,LR}
   \   000002BC   1EFF2FE1           BX       LR               ;; return
   \                     ??SC2410Uart_1:
   \   000002C0   ........           DC32     ??__vtbl
   \   000002C4   ........           DC32     ??Channels
   \   000002C8   ........           DC32     OS_FSys
     96          

   \                                 In segment CODE, align 4, keep-with-next
     97          void SC2410Uart::EnableInt(void)
     98          {
     99          	switch ( PortNumber ) {
   \                     ??EnableInt:
   \   00000000   800090E5           LDR      R0,[R0, #+128]
   \   00000004   1C10A0E3           MOV      R1,#+28
   \   00000008   4A1481E3           ORR      R1,R1,#0x4A000000
   \   0000000C   1420C1E3           BIC      R2,R1,#0x14
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0400000A           BEQ      ??EnableInt_1
   \   00000018   010050E2           SUBS     R0,R0,#+1
   \   0000001C   0800000A           BEQ      ??EnableInt_2
   \   00000020   010050E2           SUBS     R0,R0,#+1
   \   00000024   0D00000A           BEQ      ??EnableInt_3
   \   00000028   1EFF2FE1           BX       LR
    100          	case 0:
    101          		rINTMSK    &= ~BIT_UART0;
   \                     ??EnableInt_1:
   \   0000002C   000092E5           LDR      R0,[R2, #+0]
   \   00000030   4005C0E3           BIC      R0,R0,#0x10000000
   \   00000034   000082E5           STR      R0,[R2, #+0]
    102          		rINTSUBMSK &= ~(BIT_SUB_TXD0 | BIT_SUB_RXD0);
   \   00000038   000091E5           LDR      R0,[R1, #+0]
   \   0000003C   0300C0E3           BIC      R0,R0,#0x3
   \   00000040   040000EA           B        ??EnableInt_4
    103          		break;
    104          	case 1:
    105          		rINTMSK    &= ~BIT_UART1;
   \                     ??EnableInt_2:
   \   00000044   000092E5           LDR      R0,[R2, #+0]
   \   00000048   8008C0E3           BIC      R0,R0,#0x800000
   \   0000004C   000082E5           STR      R0,[R2, #+0]
    106          		rINTSUBMSK &= ~(BIT_SUB_TXD1 | BIT_SUB_RXD1);
   \   00000050   000091E5           LDR      R0,[R1, #+0]
   \   00000054   1800C0E3           BIC      R0,R0,#0x18
   \                     ??EnableInt_4:
   \   00000058   000081E5           STR      R0,[R1, #+0]
   \   0000005C   1EFF2FE1           BX       LR
    107          		break;
    108          	case 2:
    109          		rINTMSK    &= ~BIT_UART2;
   \                     ??EnableInt_3:
   \   00000060   000092E5           LDR      R0,[R2, #+0]
   \   00000064   800CC0E3           BIC      R0,R0,#0x8000
   \   00000068   000082E5           STR      R0,[R2, #+0]
    110          		rINTSUBMSK &= ~(BIT_SUB_TXD2 | BIT_SUB_RXD2);
   \   0000006C   000091E5           LDR      R0,[R1, #+0]
   \   00000070   C000C0E3           BIC      R0,R0,#0xC0
   \   00000074   F7FFFFEA           B        ??EnableInt_4
    111          		break;
    112          	default:
    113          		break;
    114          
    115          	}
    116          }
    117          
    118          
    119          /******************************************************************************
    120          *
    121          *   EnableFIFO
    122          */
    123          

   \                                 In segment CODE, align 4, keep-with-next
    124          void SC2410Uart::EnableFIFO(int TxTrigger, int RxTrigger)
    125          {
   \                     ??EnableFIFO:
   \   00000000   10002DE9           PUSH     {R4}
    126          	unsigned RxTmpTrigger=0,TxTmpTrigger=0;
    127          	switch ( TxTrigger ) {
   \   00000004   043051E2           SUBS     R3,R1,#+4
   \   00000008   0500000A           BEQ      ??EnableFIFO_1
   \   0000000C   043053E2           SUBS     R3,R3,#+4
   \   00000010   0500000A           BEQ      ??EnableFIFO_2
   \   00000014   043053E2           SUBS     R3,R3,#+4
   \   00000018   0330A003           MOVEQ    R3,#+3
    128          	default:
    129          	case  0: TxTmpTrigger= 0x00; break;
   \   0000001C   0030A013           MOVNE    R3,#+0
   \   00000020   020000EA           B        ??EnableFIFO_3
    130          	case  4: TxTmpTrigger= 0x01; break;
   \                     ??EnableFIFO_1:
   \   00000024   0130A0E3           MOV      R3,#+1
   \   00000028   000000EA           B        ??EnableFIFO_3
    131          	case  8: TxTmpTrigger= 0x02; break;
   \                     ??EnableFIFO_2:
   \   0000002C   0230A0E3           MOV      R3,#+2
    132          	case 12: TxTmpTrigger= 0x03; break;
    133          	}
    134          	switch ( RxTrigger ) {
   \                     ??EnableFIFO_3:
   \   00000030   08C052E2           SUBS     R12,R2,#+8
   \   00000034   0500000A           BEQ      ??EnableFIFO_4
   \   00000038   04C05CE2           SUBS     R12,R12,#+4
   \   0000003C   0500000A           BEQ      ??EnableFIFO_5
   \   00000040   04C05CE2           SUBS     R12,R12,#+4
   \   00000044   03C0A003           MOVEQ    R12,#+3
    135          	default:
    136          	case  4: RxTmpTrigger= 0x00; break;
   \   00000048   00C0A013           MOVNE    R12,#+0
   \   0000004C   020000EA           B        ??EnableFIFO_6
    137          	case  8: RxTmpTrigger= 0x01; break;
   \                     ??EnableFIFO_4:
   \   00000050   01C0A0E3           MOV      R12,#+1
   \   00000054   000000EA           B        ??EnableFIFO_6
    138          	case 12: RxTmpTrigger= 0x02; break;
   \                     ??EnableFIFO_5:
   \   00000058   02C0A0E3           MOV      R12,#+2
    139          	case 16: RxTmpTrigger= 0x03; break;
    140          	}
    141          	*rFIFOControl = (TxTmpTrigger << 6) | (RxTmpTrigger << 4 ) | 1;
   \                     ??EnableFIFO_6:
   \   0000005C   044190E5           LDR      R4,[R0, #+260]
   \   00000060   0CC2A0E1           LSL      R12,R12,#+4
   \   00000064   03338CE1           ORR      R3,R12,R3, LSL #+6
   \   00000068   013083E3           ORR      R3,R3,#0x1
   \   0000006C   003084E5           STR      R3,[R4, #+0]
    142          
    143          	TxFIFOSize = 16-TxTrigger;
   \   00000070   101061E2           RSB      R1,R1,#+16
   \   00000074   1C1080E5           STR      R1,[R0, #+28]
    144          	RxFIFOSize = RxTrigger;
   \   00000078   202080E5           STR      R2,[R0, #+32]
    145          }
   \   0000007C   1000BDE8           POP      {R4}
   \   00000080   1EFF2FE1           BX       LR               ;; return
    146          
    147          
    148          
    149          /*******************************************************************************
    150          *
    151          * IntWr - handle a transmitter interrupt
    152          *
    153          * This routine handles write interrupts from the UART. It reads a character
    154          * and puts it in the transmit holding register of the device for transfer.
    155          *
    156          * If there are no more characters to transmit, transmission is disabled by
    157          * clearing the transmit interrupt enable bit in the IER(int enable register).
    158          *
    159          * RETURNS: N/A
    160          *
    161          */
    162          

   \                                 In segment CODE, align 4, keep-with-next
    163          void SC2410Uart::Transmit(void)
    164          {
   \                     ??Transmit:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    165          
    166          	bool SomeDataSent = false;
    167          	if ( TxDataPtr ) {
   \   00000008   281094E5           LDR      R1,[R4, #+40]
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   000051E3           CMP      R1,#+0
   \   00000018   1600000A           BEQ      ??Transmit_1
    168          		for ( int i=0; i < TxFIFOSize && TxDataPos < TxDataSize; i++ ) {
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0B0000EA           B        ??Transmit_2
    169          			*rTxReg = TxDataPtr[TxDataPos++];
   \                     ??Transmit_3:
   \   00000024   400094E5           LDR      R0,[R4, #+64]
    170          			TxByteCnt++;
    171          			SomeDataSent = true;
    172          		}
   \   00000028   011081E2           ADD      R1,R1,#+1
   \   0000002C   012080E2           ADD      R2,R0,#+1
   \   00000030   402084E5           STR      R2,[R4, #+64]
   \   00000034   283094E5           LDR      R3,[R4, #+40]
   \   00000038   F82094E5           LDR      R2,[R4, #+248]
   \   0000003C   0300D0E7           LDRB     R0,[R0, +R3]
   \   00000040   0000C2E5           STRB     R0,[R2, #+0]
   \   00000044   D00094E5           LDR      R0,[R4, #+208]
   \   00000048   010080E2           ADD      R0,R0,#+1
   \   0000004C   D00084E5           STR      R0,[R4, #+208]
   \   00000050   0100A0E3           MOV      R0,#+1
   \                     ??Transmit_2:
   \   00000054   1C2094E5           LDR      R2,[R4, #+28]
   \   00000058   020051E1           CMP      R1,R2
   \   0000005C   030000AA           BGE      ??Transmit_4
   \   00000060   402094E5           LDR      R2,[R4, #+64]
   \   00000064   2C3094E5           LDR      R3,[R4, #+44]
   \   00000068   030052E1           CMP      R2,R3
   \   0000006C   ECFFFFBA           BLT      ??Transmit_3
    173          	}
    174          	if ( !SomeDataSent ) {
   \                     ??Transmit_4:
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   1800001A           BNE      ??Transmit_5
    175          		if ( HWProtocol == C_UART_HWPRO_485 ) {
   \                     ??Transmit_1:
   \   00000078   A00094E5           LDR      R0,[R4, #+160]
   \   0000007C   4C10A0E3           MOV      R1,#+76
   \   00000080   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000084   010050E1           CMP      R0,R1
   \   00000088   0A00001A           BNE      ??Transmit_6
    176          			switch (SWProtocol) {
   \   0000008C   A40094E5           LDR      R0,[R4, #+164]
   \   00000090   0B1081E2           ADD      R1,R1,#+11
   \   00000094   010050E1           CMP      R0,R1
   \   00000098   0600001A           BNE      ??Transmit_6
    177          			case C_UART_SWPRO_ANPRO10:
    178          				// Turn off the RS485 if nothing to send on this interrupt
    179          				rGPHDAT &= ~2;
   \   0000009C   7400A0E3           MOV      R0,#+116
   \   000000A0   560480E3           ORR      R0,R0,#0x56000000
   \   000000A4   001090E5           LDR      R1,[R0, #+0]
   \   000000A8   0210C1E3           BIC      R1,R1,#0x2
   \   000000AC   001080E5           STR      R1,[R0, #+0]
    180          				ProtocolState = pNew_Sync;
   \   000000B0   0400A0E3           MOV      R0,#+4
   \   000000B4   4400C4E5           STRB     R0,[R4, #+68]
    181          				break;
    182          			default:
    183          				break;
    184          			}
    185          		}
    186          		if ( TxTaskPtr ) {
   \                     ??Transmit_6:
   \   000000B8   3C1094E5           LDR      R1,[R4, #+60]
   \   000000BC   000051E3           CMP      R1,#+0
   \   000000C0   0500000A           BEQ      ??Transmit_5
    187          			if ( EventMask ) {
   \   000000C4   3800D4E5           LDRB     R0,[R4, #+56]
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   0100000A           BEQ      ??Transmit_7
    188          				OS_SignalEvent(EventMask,(TSN_TASK*)TxTaskPtr);
   \   000000D0   3800D4E5           LDRB     R0,[R4, #+56]
   \   000000D4   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
    189          			}
    190          			TxTaskPtr = NULL;
   \                     ??Transmit_7:
   \   000000D8   3C5084E5           STR      R5,[R4, #+60]
    191          		}
    192          	}
    193          }
   \                     ??Transmit_5:
   \   000000DC   3040BDE8           POP      {R4,R5,LR}
   \   000000E0   1EFF2FE1           BX       LR               ;; return
    194          
    195          /*******************************************************************************
    196          *
    197          * Tsn16550IntRd - handle a  receiver interrupt
    198          *
    199          * This routine handles read interrupts from the UART.
    200          *
    201          * RETURNS: N/A
    202          *
    203          */
    204          

   \                                 In segment CODE, align 4, keep-with-next
    205          void SC2410Uart::Receive(void){
   \                     ??Receive_1:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
    206          	/* read character from Receive Holding Reg.                 */
    207          	/* I will allways read rx register and push it on the stack */
    208          	if ( RxFIFOSize > 1 ) {
   \   0000000C   200094E5           LDR      R0,[R4, #+32]
   \   00000010   020050E3           CMP      R0,#+2
   \   00000014   180000BA           BLT      ??Receive_2
    209          		if ( *rFIFOStatus & 0x100 ) {
   \   00000018   1C0194E5           LDR      R0,[R4, #+284]
   \   0000001C   001090E5           LDR      R1,[R0, #+0]
   \   00000020   400F11E3           TST      R1,#0x100
   \   00000024   0400000A           BEQ      ??Receive_3
    210          			*rFIFOControl |= 0x2;
   \   00000028   040194E5           LDR      R0,[R4, #+260]
   \   0000002C   001090E5           LDR      R1,[R0, #+0]
   \   00000030   021081E3           ORR      R1,R1,#0x2
   \   00000034   001080E5           STR      R1,[R0, #+0]
   \   00000038   150000EA           B        ??Receive_4
    211          		} else {
    212          			int Cnt = *rFIFOStatus & 0x0F;
   \                     ??Receive_3:
   \   0000003C   0F5001E2           AND      R5,R1,#0xF
   \   00000040   010055E3           CMP      R5,#+1
   \   00000044   120000BA           BLT      ??Receive_4
    213          			while ( Cnt >0 ) {
    214          				char RxData = *rRxReg;
   \                     ??Receive_5:
   \   00000048   F41094E5           LDR      R1,[R4, #+244]
    215          				OS_PutMailCond1(&RxBuf,&RxData);
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   0010D1E5           LDRB     R1,[R1, #+0]
    216          				RxByteCnt++;
    217          				Cnt--;
   \   00000054   015045E2           SUB      R5,R5,#+1
   \   00000058   0010CDE5           STRB     R1,[SP, #+0]
   \   0000005C   0D10A0E1           MOV      R1,SP
   \   00000060   ........           _BLF     OS_PutMailCond1,??OS_PutMailCond1??rA
   \   00000064   CC0094E5           LDR      R0,[R4, #+204]
    218          			}
   \   00000068   010055E3           CMP      R5,#+1
   \   0000006C   010080E2           ADD      R0,R0,#+1
   \   00000070   CC0084E5           STR      R0,[R4, #+204]
   \   00000074   060000BA           BLT      ??Receive_4
   \   00000078   F2FFFFEA           B        ??Receive_5
    219          		}
    220          	} else {
    221          		char RxData = *rRxReg;
   \                     ??Receive_2:
   \   0000007C   F41094E5           LDR      R1,[R4, #+244]
    222          		char Status = OS_PutMailCond1(&RxBuf,&RxData);
   \   00000080   0400A0E1           MOV      R0,R4
   \   00000084   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000088   0010CDE5           STRB     R1,[SP, #+0]
   \   0000008C   0D10A0E1           MOV      R1,SP
   \   00000090   ........           _BLF     OS_PutMailCond1,??OS_PutMailCond1??rA
    223          	}
    224          	LastRxTime      = (int)OS_Time;
   \                     ??Receive_4:
   \   00000094   0C009FE5           LDR      R0,??Receive_6   ;; OS_Time
   \   00000098   000090E5           LDR      R0,[R0, #+0]
   \   0000009C   480084E5           STR      R0,[R4, #+72]
    225          }
   \   000000A0   3140BDE8           POP      {R0,R4,R5,LR}
   \   000000A4   1EFF2FE1           BX       LR               ;; return
   \                     ??Receive_6:
   \   000000A8   ........           DC32     OS_Time
    226          
    227          
    228          /*******************************************************************************
    229          *
    230          * Tsn16550Int - handle a receiver/transmitter interrupt
    231          *
    232          * This routine handles four sources of interrupts from the UART. They are
    233          * prioritized in the following order by the Interrupt Identification Register:
    234          * Receiver Line Status, Received Data Ready, Transmit Holding Register Empty
    235          * and Modem Status.
    236          *
    237          * If there is another character to be transmitted, it sends it.  If
    238          * not, or if a device has never been created for this channel, just
    239          * disable the interrupt.
    240          * When a modem status interrupt occurs, the transmit interrupt is enabled if
    241          * the CTS signal is TRUE.
    242          *
    243          * RETURNS: N/A
    244          */
    245          

   \                                 In segment CODE, align 4, keep-with-next
    246          void SC2410Uart::HandleInterrupt(void)
    247          {
   \                     ??HandleInterrupt:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    248          	unsigned IntSubSource = rSUBSRCPND;
   \   00000008   1800A0E3           MOV      R0,#+24
   \   0000000C   4A0480E3           ORR      R0,R0,#0x4A000000
   \   00000010   005090E5           LDR      R5,[R0, #+0]
    249          	unsigned InsSubMask   = rINTSUBMSK;
   \   00000014   040080E3           ORR      R0,R0,#0x4
   \   00000018   000090E5           LDR      R0,[R0, #+0]
    250          
    251          	if ( IntSubSource & BitSubErr ) {
   \   0000001C   E80094E5           LDR      R0,[R4, #+232]
   \   00000020   1860A0E3           MOV      R6,#+24
   \   00000024   4A6486E3           ORR      R6,R6,#0x4A000000
   \   00000028   050010E1           TST      R0,R5
    252          		// Do nothing for now
    253          		rSUBSRCPND = BitSubErr;
   \   0000002C   00008615           STRNE    R0,[R6, #+0]
    254          	}
    255          	if ( IntSubSource & BitSubRx ) {
   \   00000030   E00094E5           LDR      R0,[R4, #+224]
   \   00000034   050010E1           TST      R0,R5
   \   00000038   0600000A           BEQ      ??HandleInterrupt_1
    256          		// rUTXH1 = rURXH1;
    257          		Receive();
   \   0000003C   DC1094E5           LDR      R1,[R4, #+220]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   0C1091E5           LDR      R1,[R1, #+12]
   \   00000048   0FE0A0E1           MOV      LR,PC
   \   0000004C   11FF2FE1           BX       R1
    258          		rSUBSRCPND = BitSubRx;
   \   00000050   E00094E5           LDR      R0,[R4, #+224]
   \   00000054   000086E5           STR      R0,[R6, #+0]
    259          	}
    260          	if ( IntSubSource & BitSubTx ) {
   \                     ??HandleInterrupt_1:
   \   00000058   E40094E5           LDR      R0,[R4, #+228]
   \   0000005C   050010E1           TST      R0,R5
   \   00000060   0600000A           BEQ      ??HandleInterrupt_2
    261          		Transmit();
   \   00000064   DC1094E5           LDR      R1,[R4, #+220]
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   1C1091E5           LDR      R1,[R1, #+28]
   \   00000070   0FE0A0E1           MOV      LR,PC
   \   00000074   11FF2FE1           BX       R1
    262          		rSUBSRCPND = BitSubTx;
   \   00000078   E40094E5           LDR      R0,[R4, #+228]
   \   0000007C   000086E5           STR      R0,[R6, #+0]
    263          	}
    264          }
   \                     ??HandleInterrupt_2:
   \   00000080   7040BDE8           POP      {R4-R6,LR}
   \   00000084   1EFF2FE1           BX       LR               ;; return
    265          

   \                                 In segment CODE, align 4, keep-with-next
    266          void SC2410Uart::ActivateTx(void)
    267          {
   \                     ??ActivateTx:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    268          	rGPHDAT  |= 2;
   \   00000008   7400A0E3           MOV      R0,#+116
   \   0000000C   560480E3           ORR      R0,R0,#0x56000000
   \   00000010   001090E5           LDR      R1,[R0, #+0]
   \   00000014   021081E3           ORR      R1,R1,#0x2
   \   00000018   001080E5           STR      R1,[R0, #+0]
    269          	switch (SWProtocol) {
   \   0000001C   A40094E5           LDR      R0,[R4, #+164]
   \   00000020   5710A0E3           MOV      R1,#+87
   \   00000024   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000028   010050E1           CMP      R0,R1
   \   0000002C   0500001A           BNE      ??ActivateTx_1
    270          	case C_UART_SWPRO_ANPRO10:
    271          		TxDataPtr[TxDataSize++] = 0x0;
   \   00000030   2C0094E5           LDR      R0,[R4, #+44]
   \   00000034   0020A0E3           MOV      R2,#+0
   \   00000038   011080E2           ADD      R1,R0,#+1
   \   0000003C   2C1084E5           STR      R1,[R4, #+44]
   \   00000040   281094E5           LDR      R1,[R4, #+40]
   \   00000044   0120C0E7           STRB     R2,[R0, +R1]
    272          		break;
    273          	default:
    274          		break;
    275          	}
    276          	ProtocolState = pInTx;
   \                     ??ActivateTx_1:
   \   00000048   0200A0E3           MOV      R0,#+2
   \   0000004C   4400C4E5           STRB     R0,[R4, #+68]
    277          	OS_Delay(RS485_ON_DELAY);
   \   00000050   ........           _BLF     OS_Delay,??OS_Delay??rA
    278          	*rTxReg = TxDataPtr[TxDataPos++];
   \   00000054   400094E5           LDR      R0,[R4, #+64]
   \   00000058   011080E2           ADD      R1,R0,#+1
   \   0000005C   401084E5           STR      R1,[R4, #+64]
   \   00000060   282094E5           LDR      R2,[R4, #+40]
   \   00000064   F81094E5           LDR      R1,[R4, #+248]
   \   00000068   0200D0E7           LDRB     R0,[R0, +R2]
   \   0000006C   0000C1E5           STRB     R0,[R1, #+0]
    279          }
   \   00000070   1040BDE8           POP      {R4,LR}
   \   00000074   1EFF2FE1           BX       LR               ;; return
    280          

   \                                 In segment CODE, align 4, keep-with-next
    281          void SC2410Uart::DeactivateTx(void)
    282          {
    283          	// Turn off the RS485
    284              if ( HWProtocol == C_UART_HWPRO_485 ){
   \                     ??DeactivateTx:
   \   00000000   A00090E5           LDR      R0,[R0, #+160]
   \   00000004   4C10A0E3           MOV      R1,#+76
   \   00000008   7C1D81E3           ORR      R1,R1,#0x1F00
   \   0000000C   010050E1           CMP      R0,R1
   \   00000010   1EFF2F11           BXNE     LR
    285                  rGPHDAT &= ~2;
   \   00000014   7400A0E3           MOV      R0,#+116
   \   00000018   560480E3           ORR      R0,R0,#0x56000000
   \   0000001C   001090E5           LDR      R1,[R0, #+0]
   \   00000020   0210C1E3           BIC      R1,R1,#0x2
   \   00000024   001080E5           STR      R1,[R0, #+0]
    286              }
    287          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    288          
    289          

   \                                 In segment CODE, align 4, keep-with-next
    290          bool SC2410Uart::Send(U8* MyData, int Size, char EventMsk, bool Wait)
    291          {
   \                     ??Send:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   2060DDE5           LDRB     R6,[SP, #+32]
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0190A0E1           MOV      R9,R1
   \   00000010   02A0A0E1           MOV      R10,R2
   \   00000014   0350A0E1           MOV      R5,R3
    292          	bool TxOk = false;
   \   00000018   0070A0E3           MOV      R7,#+0
   \   0000001C   0080A0E3           MOV      R8,#+0
    293          	if ( !Size ) return true;
   \   00000020   00005AE3           CMP      R10,#+0
   \   00000024   0100A003           MOVEQ    R0,#+1
   \   00000028   6200000A           BEQ      ??Send_1
    294          	OS_Use(&TxSema);
   \   0000002C   700084E2           ADD      R0,R4,#+112
   \   00000030   ........           _BLF     OS_Use,??OS_Use??rA
    295          	TxDataPtr   = MyData;
    296          	TxDataSize  = Size;
    297          	TxDataPos   = 0;
    298          
    299          	if ( Size ) {
    300          		EventMask = EventMsk;
    301          		if ( EventMsk ) {
   \   00000034   000055E3           CMP      R5,#+0
    302          			TxTaskPtr = OS_GetpCurrentTask();
   \   00000038   80019F15           LDRNE    R0,??Send_2      ;; OS_pCurrentTask
   \   0000003C   289084E5           STR      R9,[R4, #+40]
   \   00000040   2CA084E5           STR      R10,[R4, #+44]
   \   00000044   407084E5           STR      R7,[R4, #+64]
   \   00000048   3850C4E5           STRB     R5,[R4, #+56]
   \   0000004C   00009015           LDRNE    R0,[R0, #+0]
    303          		} else {
    304          			TxTaskPtr = NULL;
    305          		}
    306          		int Delay=(130000*TxDataSize)/BaudRate+RS485_EXTRA_DELAY;
   \   00000050   7C1BA0E3           MOV      R1,#+126976
   \   00000054   0000A003           MOVEQ    R0,#+0
   \   00000058   3C0084E5           STR      R0,[R4, #+60]
   \   0000005C   0A00A0E1           MOV      R0,R10
   \   00000060   BD1E81E3           ORR      R1,R1,#0xBD0
   \   00000064   910000E0           MUL      R0,R1,R0
   \   00000068   AC1094E5           LDR      R1,[R4, #+172]
    307          		switch ( HWProtocol ) {
   \   0000006C   0190A0E3           MOV      R9,#+1
   \   00000070   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000074   A00094E5           LDR      R0,[R4, #+160]
   \   00000078   02A081E2           ADD      R10,R1,#+2
   \   0000007C   4B10A0E3           MOV      R1,#+75
   \   00000080   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000084   010050E1           CMP      R0,R1
   \   00000088   2400000A           BEQ      ??Send_3
   \   0000008C   011081E2           ADD      R1,R1,#+1
   \   00000090   010050E1           CMP      R0,R1
   \   00000094   2800001A           BNE      ??Send_4
    308          		case C_UART_HWPRO_485 :
    309          			switch (SWProtocol) {
   \   00000098   A40094E5           LDR      R0,[R4, #+164]
   \   0000009C   DC1094E5           LDR      R1,[R4, #+220]
   \   000000A0   5720A0E3           MOV      R2,#+87
   \   000000A4   7C2D82E3           ORR      R2,R2,#0x1F00
   \   000000A8   020050E1           CMP      R0,R2
   \   000000AC   0A00001A           BNE      ??Send_5
    310          			case C_UART_SWPRO_ANPRO10:
    311          				if ( IsMaster ) {
   \   000000B0   3000D4E5           LDRB     R0,[R4, #+48]
   \   000000B4   000050E3           CMP      R0,#+0
   \   000000B8   0E00000A           BEQ      ??Send_6
    312          					// Asume we have to force the tx if TxRequest = true!
    313          					if ( TxRequest || ProtocolState == pNew_Sync ) {
   \   000000BC   4500D4E5           LDRB     R0,[R4, #+69]
   \   000000C0   000050E3           CMP      R0,#+0
   \   000000C4   0200001A           BNE      ??Send_7
   \   000000C8   4400D4E5           LDRB     R0,[R4, #+68]
   \   000000CC   040050E3           CMP      R0,#+4
   \   000000D0   0600001A           BNE      ??Send_8
    314          						TxRequest = false;
   \                     ??Send_7:
   \   000000D4   0000A0E3           MOV      R0,#+0
   \   000000D8   4500C4E5           STRB     R0,[R4, #+69]
    315           						ActivateTx();
   \                     ??Send_5:
   \   000000DC   141091E5           LDR      R1,[R1, #+20]
   \   000000E0   0400A0E1           MOV      R0,R4
   \   000000E4   0FE0A0E1           MOV      LR,PC
   \   000000E8   11FF2FE1           BX       R1
   \   000000EC   120000EA           B        ??Send_4
    316          					} else {
    317          						TxRequest = true;
   \                     ??Send_8:
   \   000000F0   4590C4E5           STRB     R9,[R4, #+69]
   \   000000F4   100000EA           B        ??Send_4
    318          					}
    319          				} else {
    320          					TxRequest  = true;
   \                     ??Send_6:
   \   000000F8   4590C4E5           STRB     R9,[R4, #+69]
    321          					if (LastRxTime < 10 ) {
   \   000000FC   480094E5           LDR      R0,[R4, #+72]
   \   00000100   0A0050E3           CMP      R0,#+10
   \   00000104   030000AA           BGE      ??Send_9
    322          						Delay     += RS485_DELAY; // Abort Tx if not completed within this time
   \   00000108   C8A08AE2           ADD      R10,R10,#+200
    323          						ActivateIfTxRequest();
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   ........           _BLF     ??ActivateIfTxRequest,??ActivateIfTxRequest??rA
   \   00000114   080000EA           B        ??Send_4
    324          					} else {
    325          						Delay     += RS485_DELAY+1000; // Abort Tx if not completed within this time
   \                     ??Send_9:
   \   00000118   4BAE8AE2           ADD      R10,R10,#+1200
   \   0000011C   060000EA           B        ??Send_4
    326          					}
    327          				}
    328          				break;
    329          			default:
    330          				ActivateTx();
    331          				break;
    332          			}
    333          			break;
    334          		case C_UART_HWPRO_232 :
    335          			*rTxReg = TxDataPtr[TxDataPos++];
   \                     ??Send_3:
   \   00000120   400094E5           LDR      R0,[R4, #+64]
   \   00000124   011080E2           ADD      R1,R0,#+1
   \   00000128   401084E5           STR      R1,[R4, #+64]
   \   0000012C   282094E5           LDR      R2,[R4, #+40]
   \   00000130   F81094E5           LDR      R1,[R4, #+248]
   \   00000134   0200D0E7           LDRB     R0,[R0, +R2]
   \   00000138   0000C1E5           STRB     R0,[R1, #+0]
    336          			break;
    337          
    338          		}
    339          		if ( Wait && EventMsk ) {
   \                     ??Send_4:
   \   0000013C   000056E3           CMP      R6,#+0
   \   00000140   00005513           CMPNE    R5,#+0
   \   00000144   0500000A           BEQ      ??Send_10
    340          			char Status = OS_WaitEventTimed(EventMsk,Delay);
   \   00000148   0A10A0E1           MOV      R1,R10
   \   0000014C   0500A0E1           MOV      R0,R5
   \   00000150   ........           _BLF     OS_WaitEventTimed,??OS_WaitEventTimed??rA
    341          			TxTaskPtr = NULL;
   \   00000154   3C7084E5           STR      R7,[R4, #+60]
    342          			TxOk =(Status==EventMsk);
   \   00000158   050050E1           CMP      R0,R5
   \   0000015C   0000001A           BNE      ??Send_11
    343          		} else {
    344          			TxOk = true;
   \                     ??Send_10:
   \   00000160   0180A0E3           MOV      R8,#+1
    345          		}
    346          		if ( HWProtocol == C_UART_HWPRO_485 ) {
   \                     ??Send_11:
   \   00000164   A00094E5           LDR      R0,[R4, #+160]
   \   00000168   4C10A0E3           MOV      R1,#+76
   \   0000016C   7C1D81E3           ORR      R1,R1,#0x1F00
   \   00000170   010050E1           CMP      R0,R1
   \   00000174   0C00001A           BNE      ??Send_12
    347          			switch (SWProtocol) {
   \   00000178   A40094E5           LDR      R0,[R4, #+164]
   \   0000017C   0B1081E2           ADD      R1,R1,#+11
   \   00000180   010050E1           CMP      R0,R1
   \   00000184   0800000A           BEQ      ??Send_12
    348          			case C_UART_SWPRO_ANPRO10:
    349          				break;
    350          			default:
    351          				OS_Delay(2);
   \   00000188   0200A0E3           MOV      R0,#+2
   \   0000018C   ........           _BLF     OS_Delay,??OS_Delay??rA
    352                          DeactivateTx();
   \   00000190   DC1094E5           LDR      R1,[R4, #+220]
   \   00000194   0400A0E1           MOV      R0,R4
   \   00000198   181091E5           LDR      R1,[R1, #+24]
   \   0000019C   0FE0A0E1           MOV      LR,PC
   \   000001A0   11FF2FE1           BX       R1
    353          				ProtocolState = pNew_Sync;
   \   000001A4   0400A0E3           MOV      R0,#+4
   \   000001A8   4400C4E5           STRB     R0,[R4, #+68]
    354          				break;
    355          			}
    356          		}
    357          		OS_Unuse(&TxSema);
   \                     ??Send_12:
   \   000001AC   700084E2           ADD      R0,R4,#+112
   \   000001B0   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    358          	}
    359          	return(TxOk);
   \   000001B4   0800A0E1           MOV      R0,R8
   \                     ??Send_1:
   \   000001B8   F047BDE8           POP      {R4-R10,LR}
   \   000001BC   1EFF2FE1           BX       LR               ;; return
   \                     ??Send_2:
   \   000001C0   ........           DC32     OS_pCurrentTask
    360          }
    361          
    362          

   \                                 In segment CODE, align 4, keep-with-next
    363          bool SC2410Uart::Receive(U8* MyData, int Size, int TimeOut)
    364          {
   \                     ??Receive:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
    365          	int Cnt = 0;
   \   00000014   0080A0E3           MOV      R8,#+0
    366          	bool ReceivedData=true;
   \   00000018   020000EA           B        ??Receive_7
    367          
    368          	do {
    369          		ReceivedData = !OS_GetMailTimed(&RxBuf,(char*)&MyData[Cnt++],TimeOut);
   \                     ??Receive_8:
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   060058E1           CMP      R8,R6
   \   00000024   070000AA           BGE      ??Receive_9
   \                     ??Receive_7:
   \   00000028   0720A0E1           MOV      R2,R7
   \   0000002C   051088E0           ADD      R1,R8,R5
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           _BLF     OS_GetMailTimed,??OS_GetMailTimed??rA
   \   00000038   018088E2           ADD      R8,R8,#+1
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   F5FFFF0A           BEQ      ??Receive_8
   \   00000044   0000A0E3           MOV      R0,#+0
    370          	}while ( ReceivedData && Cnt < Size );
    371          	return(ReceivedData);
   \                     ??Receive_9:
   \   00000048   F041BDE8           POP      {R4-R8,LR}
   \   0000004C   1EFF2FE1           BX       LR               ;; return
    372          }
    373          
    374          

   \                                 In segment CODE, align 4, keep-with-next
    375          void SC2410Uart::ClearRxBuffer(void)
    376          {
   \                     ??ClearRxBuffer:
   \   00000000   00402DE9           PUSH     {LR}
    377          	OS_ClearMB(&RxBuf);
   \   00000004   ........           _BLF     OS_ClearMB,??OS_ClearMB??rA
    378          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    379          

   \                                 In segment CODE, align 4, keep-with-next
    380          bool SC2410Uart::HasMore(void)
    381          {
    382          	int RxBytesInBuf = OS_GetMessageCnt(&RxBuf);
    383          	return(bool(RxBytesInBuf));
   \                     ??HasMore:
   \   00000000   080090E5           LDR      R0,[R0, #+8]
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0100A013           MOVNE    R0,#+1
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    384          }

   \                                 In segment DIFUNCT, align 4, keep-with-next, root
   \   00000000                      REQUIRE ?call_ctors
   \   00000000   ........           DC32    ??__sti__routine

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs SC2410Uart &SC2410Uart::new SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
   \                     `??new SC2410Uart`:
   \   00000000   FF4F2DE9           PUSH     {R0-R11,LR}
   \   00000004   3C409DE5           LDR      R4,[SP, #+60]
   \   00000008   40509DE5           LDR      R5,[SP, #+64]
   \   0000000C   44609DE5           LDR      R6,[SP, #+68]
   \   00000010   4870DDE5           LDRB     R7,[SP, #+72]
   \   00000014   4C809DE5           LDR      R8,[SP, #+76]
   \   00000018   5090DDE5           LDRB     R9,[SP, #+80]
   \   0000001C   54A09DE5           LDR      R10,[SP, #+84]
   \   00000020   58B09DE5           LDR      R11,[SP, #+88]
   \   00000024   480FA0E3           MOV      R0,#+288
   \   00000028   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   1200000A           BEQ      `??new SC2410Uart_1`
   \   00000034   00082DE9           PUSH     {R11}
   \   00000038   00042DE9           PUSH     {R10}
   \   0000003C   00022DE9           PUSH     {R9}
   \   00000040   00012DE9           PUSH     {R8}
   \   00000044   80002DE9           PUSH     {R7}
   \   00000048   40002DE9           PUSH     {R6}
   \   0000004C   20002DE9           PUSH     {R5}
   \   00000050   10002DE9           PUSH     {R4}
   \   00000054   58109DE5           LDR      R1,[SP, #+88]
   \   00000058   02002DE9           PUSH     {R1}
   \   0000005C   5810DDE5           LDRB     R1,[SP, #+88]
   \   00000060   02002DE9           PUSH     {R1}
   \   00000064   34109DE5           LDR      R1,[SP, #+52]
   \   00000068   02002DE9           PUSH     {R1}
   \   0000006C   34309DE5           LDR      R3,[SP, #+52]
   \   00000070   30209DE5           LDR      R2,[SP, #+48]
   \   00000074   2C109DE5           LDR      R1,[SP, #+44]
   \   00000078   ........           BL       ??SC2410Uart
   \   0000007C   2CD08DE2           ADD      SP,SP,#+44
   \                     `??new SC2410Uart_1`:
   \   00000080   10D08DE2           ADD      SP,SP,#+16
   \   00000084   F04FBDE8           POP      {R4-R11,LR}
   \   00000088   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   static __??Code32?? __intrinsic __code __interwork __atpcs void __sti__routine()
   \                     ??__sti__routine:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     SC2410Uart::ActivateTx()           8
     SC2410Uart::ClearRxBuffer()        4
     SC2410Uart::DeactivateTx()         0
     SC2410Uart::EnableFIFO(int, int)
                                        4
     SC2410Uart::EnableInt()            0
     SC2410Uart::HandleInterrupt()     16
     SC2410Uart::HasMore()              0
     SC2410Uart::Receive()             16
     SC2410Uart::Receive(unsigned char *, int, int)
                                       24
     SC2410Uart::SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                       84
     SC2410Uart::Send(unsigned char *, int, char, bool)
                                       32
     SC2410Uart::Transmit()            12
     SC2410Uart::new SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                       96
     __sti__routine()                   0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     SC2410Uart::SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                     716
     SC2410Uart::EnableInt()         120
     SC2410Uart::EnableFIFO(int, int)
                                     132
     SC2410Uart::Transmit()          228
     SC2410Uart::Receive()           172
     SC2410Uart::HandleInterrupt()   136
     SC2410Uart::ActivateTx()        120
     SC2410Uart::DeactivateTx()       44
     SC2410Uart::Send(unsigned char *, int, char, bool)
                                     452
     SC2410Uart::Receive(unsigned char *, int, int)
                                      80
     SC2410Uart::ClearRxBuffer()      16
     SC2410Uart::HasMore()            16
     SC2410Uart::new SC2410Uart(int, unsigned int, unsigned int, unsigned int, char, unsigned int, int, int, int, bool, int, bool, int, int)
                                     140
     __sti__routine()                  4
      Others                         280

 
 2 612 bytes in segment CODE
    40 bytes in segment DATA_C
     4 bytes in segment DIFUNCT
 
 2 380 bytes of CODE  memory (+ 236 bytes shared)
    40 bytes of CONST memory

Errors: none
Warnings: none
