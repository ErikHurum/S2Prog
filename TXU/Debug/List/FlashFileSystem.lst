##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:13:43 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\src\FlashFileSystem.cpp                #
#    Command line    =  D:\S2Prog\TXU\src\FlashFileSystem.cpp --fpu None -D  #
#                       OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D      #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --eec++           #
#                       --dlib_config "C:\Program Files (x86)\IAR            #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl4tpainl8n.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\FlashFileSystem.lst         #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\FlashFileSystem.r79          #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\src\FlashFileSystem.cpp
      1          
      2          #ifdef ANBOOTLOADER
      3          	#include "Rtos.h"
      4          	#include "ANPRO10Inc.h"
      5          	#include "2410addr.h"
      6          	#include "2410slib.h"
      7          	#include "mx29LV160TB.h"
      8            #include "FixedVariables.h"
      9          #elif S2TXU
     10          #include "TSNIncludes.h"
     11          #endif
     12          
     13          #define BLOCK_SIZE					(0x40000-sizeof(U32))
     14          

   \                                 In segment DATA_Z, align 4, align-sorted
     15          U32 FlashStartOfFreeArea = 0;
   \                     FlashStartOfFreeArea:
   \   00000000                      DS8 4
     16          int FlashActiveSector    = 0;
   \                     FlashActiveSector:
   \   00000004                      DS8 4
     17          int FlashActiveSectorEnd = 0;
   \                     FlashActiveSectorEnd:
   \   00000008                      DS8 4
     18          bool FlashSystemInit     = false;
   \                     FlashSystemInit:
   \   0000000C                      DS8 1
     19          

   \                                 In segment CODE, align 4, keep-with-next
     20          U32 GetFlashStartAddress(void)
     21          {
     22          	return(SectorTable[FlashActiveSector]+FlashBaseAddress+sizeof(U32));
   \                     ??GetFlashStartAddress:
   \   00000000   20009FE5           LDR      R0,??GetFlashStartAddress_1  ;; FlashStartOfFreeArea + 4
   \   00000004   ........           LDR      R1,??DataTable29  ;; SectorTable
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   001091E5           LDR      R1,[R1, #+0]
   \   00000010   000191E7           LDR      R0,[R1, +R0, LSL #+2]
   \   00000014   ........           LDR      R1,??DataTable28  ;; FlashBaseAddress
   \   00000018   001091E5           LDR      R1,[R1, #+0]
   \   0000001C   000081E0           ADD      R0,R1,R0
   \   00000020   040080E2           ADD      R0,R0,#+4
   \   00000024   1EFF2FE1           BX       LR               ;; return
   \                     ??GetFlashStartAddress_1:
   \   00000028   ........           DC32     FlashStartOfFreeArea + 4
     23          }
     24          

   \                                 In segment CODE, align 4, keep-with-next
     25          U32 FlashFindFreeArea(void)
     26          {
   \                     ??FlashFindFreeArea:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     27          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R4,??DataTable34  ;; FlashSema
     28          	U32* FreePtr      = (U32*)GetFlashStartAddress();
     29          	U32 Cnt = (BLOCK_SIZE-1) >> 2;
   \   00000008   FE50A0E3           MOV      R5,#+254
   \   0000000C   0400A0E1           MOV      R0,R4
   \   00000010   ........           _BLF     OS_Use,??OS_Use??rA
   \   00000014   ........           BL       ??GetFlashStartAddress
   \   00000018   FF5C85E3           ORR      R5,R5,#0xFF00
   \                     ??FlashFindFreeArea_1:
   \   0000001C   051190E7           LDR      R1,[R0, +R5, LSL #+2]
   \   00000020   010071E3           CMN      R1,#+1
   \   00000024   0100001A           BNE      ??FlashFindFreeArea_2
     30          	// First large steps to speed the search
     31          	while ( Cnt > 0 && FreePtr[Cnt] == BLOCK_IS_UNUSED ) Cnt--;
   \   00000028   015055E2           SUBS     R5,R5,#+1
   \   0000002C   FAFFFF1A           BNE      ??FlashFindFreeArea_1
     32          	Cnt++; // We alway will go one too far
     33          	//Cnt++; // We must correct for the sector info word
     34          	OS_Unuse(&FlashSema);
   \                     ??FlashFindFreeArea_2:
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           _BLF     OS_Unuse,??OS_Unuse??rA
     35          	return(Cnt*sizeof(U32));
   \   00000038   010085E2           ADD      R0,R5,#+1
   \   0000003C   3040BDE8           POP      {R4,R5,LR}
   \   00000040   0001A0E1           LSL      R0,R0,#+2
   \   00000044   1EFF2FE1           BX       LR               ;; return
     36          }
     37          

   \                                 In segment CODE, align 4, keep-with-next
     38          bool FlashVerifyArea(U32 Size)
     39          {
   \                     ??FlashVerifyArea:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
     40          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R5,??DataTable34  ;; FlashSema
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0500A0E1           MOV      R0,R5
   \   00000010   ........           _BLF     OS_Use,??OS_Use??rA
     41          	U8* StartPtr      = (U8*)GetFlashStartAddress();
   \   00000014   ........           BL       ??GetFlashStartAddress
   \   00000018   0060A0E1           MOV      R6,R0
     42          	bool NoError =true;
   \   0000001C   0170A0E3           MOV      R7,#+1
     43          	bool NoInfo  =true;
   \   00000020   0180A0E3           MOV      R8,#+1
     44          	for(U32 Cnt=0; NoError && Cnt < Size; Cnt++){
   \   00000024   0090A0E3           MOV      R9,#+0
   \   00000028   0910A0E1           MOV      R1,R9
   \   0000002C   020000EA           B        ??FlashVerifyArea_1
   \                     ??FlashVerifyArea_2:
   \   00000030   011081E2           ADD      R1,R1,#+1
   \   00000034   000057E3           CMP      R7,#+0
   \   00000038   1400000A           BEQ      ??FlashVerifyArea_3
   \                     ??FlashVerifyArea_1:
   \   0000003C   040051E1           CMP      R1,R4
   \   00000040   0400002A           BCS      ??FlashVerifyArea_4
     45          		 NoError = ( StartPtr[Cnt] != 0xff );
   \   00000044   0620D1E7           LDRB     R2,[R1, +R6]
   \   00000048   FF0052E3           CMP      R2,#+255
   \   0000004C   0070A003           MOVEQ    R7,#+0
   \   00000050   0170A013           MOVNE    R7,#+1
   \   00000054   F5FFFFEA           B        ??FlashVerifyArea_2
     46          	}
     47          	// Check for PROProjectInfo
     48          	if ( NoError) {
     49          		for(U32 Cnt=0; NoInfo && Cnt < Size; Cnt++){
   \                     ??FlashVerifyArea_4:
   \   00000058   00A0A0E3           MOV      R10,#+0
   \                     ??FlashVerifyArea_5:
   \   0000005C   04005AE1           CMP      R10,R4
   \   00000060   0A00002A           BCS      ??FlashVerifyArea_3
     50          			 if ( StartPtr[Cnt] == 'P' ){
   \   00000064   06008AE0           ADD      R0,R10,R6
   \   00000068   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000006C   500051E3           CMP      R1,#+80
   \   00000070   0300001A           BNE      ??FlashVerifyArea_6
     51          				 if ( strcmp("PROProjectInfo",(char*)StartPtr[Cnt])){
   \   00000074   2C009FE5           LDR      R0,??FlashVerifyArea_7  ;; `?<Constant "PROProjectInfo">`
   \   00000078   ........           _BLF     strcmp,??strcmp??rA
   \   0000007C   000050E3           CMP      R0,#+0
     52          					 NoInfo = false;
   \   00000080   0080A013           MOVNE    R8,#+0
     53          				 }
     54          			 }
     55          		}
   \                     ??FlashVerifyArea_6:
   \   00000084   01A08AE2           ADD      R10,R10,#+1
   \   00000088   000058E3           CMP      R8,#+0
   \   0000008C   F2FFFF1A           BNE      ??FlashVerifyArea_5
     56          
     57          	}
     58          	OS_Unuse(&FlashSema);
   \                     ??FlashVerifyArea_3:
   \   00000090   0500A0E1           MOV      R0,R5
   \   00000094   ........           _BLF     OS_Unuse,??OS_Unuse??rA
     59          	return(NoError && !NoInfo);
   \   00000098   010028E2           EOR      R0,R8,#0x1
   \   0000009C   070000E0           AND      R0,R0,R7
   \   000000A0   F047BDE8           POP      {R4-R10,LR}
   \   000000A4   1EFF2FE1           BX       LR               ;; return
   \                     ??FlashVerifyArea_7:
   \   000000A8   ........           DC32     `?<Constant "PROProjectInfo">`
     60          }
     61          
     62          

   \                                 In segment CODE, align 4, keep-with-next
     63          bool FlashSetActiveSector(void)
     64          {
   \                     ??FlashSetActiveSector:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     65          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R4,??DataTable34  ;; FlashSema
     66          	U32* Bank1Address = (U32*)(SectorTable[SectorSettings1Start]+FlashBaseAddress);
     67          	U32* Bank2Address = (U32*)(SectorTable[SectorSettings2Start]+FlashBaseAddress);
   \   00000008   ........           LDR      R5,??DataTable30  ;; SectorSettings2Start
   \   0000000C   0400A0E1           MOV      R0,R4
   \   00000010   ........           _BLF     OS_Use,??OS_Use??rA
   \   00000014   ........           LDR      R0,??DataTable28  ;; FlashBaseAddress
   \   00000018   ........           LDR      R2,??DataTable29  ;; SectorTable
   \   0000001C   001090E5           LDR      R1,[R0, #+0]
   \   00000020   ........           LDR      R0,??DataTable24  ;; SectorSettings1Start
   \   00000024   002092E5           LDR      R2,[R2, #+0]
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   00C095E5           LDR      R12,[R5, #+0]
   \   00000030   003192E7           LDR      R3,[R2, +R0, LSL #+2]
   \   00000034   0C2192E7           LDR      R2,[R2, +R12, LSL #+2]
   \   00000038   033081E0           ADD      R3,R1,R3
   \   0000003C   021081E0           ADD      R1,R1,R2
     68          	switch ( *Bank1Address ) {
   \   00000040   002093E5           LDR      R2,[R3, #+0]
   \   00000044   040072E3           CMN      R2,#+4
   \   00000048   0200000A           BEQ      ??FlashSetActiveSector_1
   \   0000004C   010072E3           CMN      R2,#+1
   \   00000050   0300000A           BEQ      ??FlashSetActiveSector_2
   \   00000054   080000EA           B        ??FlashSetActiveSector_3
     69          		case BLOCK_IS_OK    :
     70          			// Always select sector 1 if sector 1 flagged with OK
     71          			FlashActiveSector    = SectorSettings1Start;
     72          			FlashActiveSectorEnd = SectorSettings1End;
   \                     ??FlashSetActiveSector_1:
   \   00000058   ........           LDR      R1,??DataTable26  ;; SectorSettings1End
   \                     ??FlashSetActiveSector_4:
   \   0000005C   001091E5           LDR      R1,[R1, #+0]
   \   00000060   0B0000EA           B        ??FlashSetActiveSector_5
     73          			break;
     74          		case BLOCK_IS_UNUSED:
     75          			switch ( *Bank2Address ) {
   \                     ??FlashSetActiveSector_2:
   \   00000064   001091E5           LDR      R1,[R1, #+0]
   \   00000068   040071E3           CMN      R1,#+4
   \   0000006C   F9FFFF1A           BNE      ??FlashSetActiveSector_1
     76          				case BLOCK_IS_UNUSED:
     77          					// If both sectors are unused select sector 1
     78          					FlashActiveSector 	 = SectorSettings1Start;
     79          					FlashActiveSectorEnd = SectorSettings1End;
     80          					break;
     81          				case BLOCK_IS_OK    :
     82          					// Select sector 2
     83          					FlashActiveSector    = SectorSettings2Start;
     84          					FlashActiveSectorEnd = SectorSettings2End;
   \                     ??FlashSetActiveSector_6:
   \   00000070   ........           LDR      R1,??DataTable32  ;; SectorSettings2End
   \   00000074   0C00A0E1           MOV      R0,R12
   \   00000078   F7FFFFEA           B        ??FlashSetActiveSector_4
     85          					break;
     86          				case BLOCK_IS_RESERVED:
     87          				default:
     88          					// Something is wrong with sector 2.
     89          					// Use sector 1
     90          					FlashActiveSector    = SectorSettings1Start;
     91          					FlashActiveSectorEnd = SectorSettings1End;
     92          					break;
     93          			}
     94          			break;
     95          		case BLOCK_IS_RESERVED:
     96          		default:
     97          			switch ( *Bank2Address ) {
   \                     ??FlashSetActiveSector_3:
   \   0000007C   000091E5           LDR      R0,[R1, #+0]
   \   00000080   040070E3           CMN      R0,#+4
   \   00000084   01007013           CMNNE    R0,#+1
   \   00000088   F8FFFF0A           BEQ      ??FlashSetActiveSector_6
     98          				case BLOCK_IS_UNUSED:
     99          					// Sector 1 has error, sector 2 is unused, select sector 2
    100          					FlashActiveSector    = SectorSettings2Start;
    101          					FlashActiveSectorEnd = SectorSettings2End;
    102          					break;
    103          				case BLOCK_IS_OK    :
    104          					// Select sector 2
    105          					FlashActiveSector    = SectorSettings2Start;
    106          					FlashActiveSectorEnd = SectorSettings2End;
    107          					break;
    108          				case BLOCK_IS_RESERVED:
    109          				default:
    110          					// Something is wrong with sector 1 and 2.
    111          					// Return 0 to flg that no sector was found
    112          					// Possible erase of boot sector EHSMark
    113          					FlashActiveSector    = 0;
   \   0000008C   0000A0E3           MOV      R0,#+0
    114          					FlashActiveSectorEnd = 0;
   \   00000090   0010A0E3           MOV      R1,#+0
   \                     ??FlashSetActiveSector_5:
   \   00000094   ........           LDR      R5,??DataTable25  ;; FlashStartOfFreeArea
   \   00000098   081085E5           STR      R1,[R5, #+8]
   \   0000009C   040085E5           STR      R0,[R5, #+4]
    115          					break;
    116          			}
    117          			break;
    118          	}
    119          	OS_Unuse(&FlashSema);
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    120          
    121          	return(FlashActiveSector != 0);
   \   000000A8   040095E5           LDR      R0,[R5, #+4]
   \   000000AC   3040BDE8           POP      {R4,R5,LR}
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   0100A013           MOVNE    R0,#+1
   \   000000B8   1EFF2FE1           BX       LR               ;; return
    122          }
    123          

   \                                 In segment CODE, align 4, keep-with-next
    124          bool FlashInitFileSystem(void)
    125          {
   \                     ??FlashInitFileSystem:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    126          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R4,??DataTable34  ;; FlashSema
   \   00000008   0400A0E1           MOV      R0,R4
   \   0000000C   ........           _BLF     OS_Use,??OS_Use??rA
    127          	bool Success = FlashSetActiveSector();
   \   00000010   ........           BL       ??FlashSetActiveSector
   \   00000014   0050B0E1           MOVS     R5,R0
    128          	if ( Success ) {
   \   00000018   0E00000A           BEQ      ??FlashInitFileSystem_1
    129          		FlashStartOfFreeArea = FlashFindFreeArea();
   \   0000001C   ........           LDR      R6,??DataTable35  ;; FlashStartOfFreeArea
   \   00000020   ........           BL       ??FlashFindFreeArea
   \   00000024   000086E5           STR      R0,[R6, #+0]
    130          		if (FlashStartOfFreeArea > sizeof(U32)) {
   \   00000028   050050E3           CMP      R0,#+5
   \   0000002C   0800003A           BCC      ??FlashInitFileSystem_2
    131          			if (!FlashVerifyArea(FlashStartOfFreeArea)) {
   \   00000030   ........           BL       ??FlashVerifyArea
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0500001A           BNE      ??FlashInitFileSystem_2
    132          				Success = MX29LV_EraseSectors(FlashActiveSector,FlashActiveSectorEnd);
   \   0000003C   081096E5           LDR      R1,[R6, #+8]
   \   00000040   040096E5           LDR      R0,[R6, #+4]
   \   00000044   ........           _BLF     ??MX29LV_EraseSectors,??MX29LV_EraseSectors??rA
   \   00000048   0050A0E1           MOV      R5,R0
    133          				FlashStartOfFreeArea = GetFlashStartAddress();
   \   0000004C   ........           BL       ??GetFlashStartAddress
   \   00000050   000086E5           STR      R0,[R6, #+0]
    134          			}
    135          		}
    136          		FlashSystemInit = Success;
   \                     ??FlashInitFileSystem_2:
   \   00000054   0C50C6E5           STRB     R5,[R6, #+12]
    137          	}
    138          	OS_Unuse(&FlashSema);
   \                     ??FlashInitFileSystem_1:
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    139          	return(Success);
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   7040BDE8           POP      {R4-R6,LR}
   \   00000068   1EFF2FE1           BX       LR               ;; return
    140          }
    141          

   \                                 In segment CODE, align 4, keep-with-next
    142          U32 GetFreeSize(void)
    143          {
   \                     ??GetFreeSize:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    144          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R4,??DataTable34  ;; FlashSema
    145          	if ( !FlashSystemInit ) {
   \   00000008   ........           LDR      R5,??DataTable35  ;; FlashStartOfFreeArea
   \   0000000C   0400A0E1           MOV      R0,R4
   \   00000010   ........           _BLF     OS_Use,??OS_Use??rA
   \   00000014   0C00D5E5           LDRB     R0,[R5, #+12]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0000001A           BNE      ??GetFreeSize_1
    146          		FlashInitFileSystem();
   \   00000020   ........           BL       ??FlashInitFileSystem
    147          	}
    148          	U32 Size = 0;
    149          	if ( FlashSystemInit ) {
   \                     ??GetFreeSize_1:
   \   00000024   0C00D5E5           LDRB     R0,[R5, #+12]
   \   00000028   0060A0E3           MOV      R6,#+0
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   0300000A           BEQ      ??GetFreeSize_2
    150          		Size = BLOCK_SIZE - FlashStartOfFreeArea;
   \   00000034   001095E5           LDR      R1,[R5, #+0]
   \   00000038   FF0BA0E3           MOV      R0,#+261120
   \   0000003C   FF0F80E3           ORR      R0,R0,#0x3FC
   \   00000040   016040E0           SUB      R6,R0,R1
    151          	}
    152          	OS_Unuse(&FlashSema);
   \                     ??GetFreeSize_2:
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    153          	return(Size);
   \   0000004C   0600A0E1           MOV      R0,R6
   \   00000050   7040BDE8           POP      {R4-R6,LR}
   \   00000054   1EFF2FE1           BX       LR               ;; return
    154          
    155          
    156          }
    157          

   \                                 In segment CODE, align 4, keep-with-next
    158          U32 GetUsedSize(void)
    159          {
   \                     ??GetUsedSize:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    160          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R4,??DataTable34  ;; FlashSema
    161          	if ( !FlashSystemInit ) {
   \   00000008   ........           LDR      R5,??DataTable35  ;; FlashStartOfFreeArea
   \   0000000C   0400A0E1           MOV      R0,R4
   \   00000010   ........           _BLF     OS_Use,??OS_Use??rA
   \   00000014   0C00D5E5           LDRB     R0,[R5, #+12]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0000001A           BNE      ??GetUsedSize_1
    162          		if ( FlashInitFileSystem() ) {
   \   00000020   ........           BL       ??FlashInitFileSystem
    163          
    164          		}
    165          	}
    166          	OS_Unuse(&FlashSema);
   \                     ??GetUsedSize_1:
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    167          	return(FlashStartOfFreeArea);
   \   0000002C   000095E5           LDR      R0,[R5, #+0]
   \   00000030   3040BDE8           POP      {R4,R5,LR}
   \   00000034   1EFF2FE1           BX       LR               ;; return
    168          
    169          }
    170          

   \                                 In segment CODE, align 4, keep-with-next
    171          bool ProgramFlash(U32 FirstSector,U32 targetAddress,U32 srcAddress,U32 srcSize)
    172          {
   \                     ??ProgramFlash:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    173          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R4,??DataTable34  ;; FlashSema
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0270A0E1           MOV      R7,R2
   \   00000014   0380A0E1           MOV      R8,R3
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           _BLF     OS_Use,??OS_Use??rA
    174          
    175          	// Assume that the datablock has sufficient size
    176          	U32 SrcEndAddress = srcAddress+srcSize;
    177          	char *SrcEndPtr   = (char*)SrcEndAddress;
   \   00000020   070088E0           ADD      R0,R8,R7
    178          	int  Alignment    = srcSize %4;	// Align to 4 byte boundry
   \   00000024   031018E2           ANDS     R1,R8,#0x3
    179          	if ( Alignment ) {
   \   00000028   0900000A           BEQ      ??ProgramFlash_1
    180          		Alignment = 4-Alignment;
   \   0000002C   041061E2           RSB      R1,R1,#+4
    181          		for ( int i=0; i < Alignment;  i++ ) {
   \   00000030   0020A0E3           MOV      R2,#+0
   \   00000034   010051E3           CMP      R1,#+1
   \   00000038   0A30A0E3           MOV      R3,#+10
   \   0000003C   020000AA           BGE      ??ProgramFlash_2
   \   00000040   030000EA           B        ??ProgramFlash_1
    182          			SrcEndPtr[i] = '\n';
   \                     ??ProgramFlash_3:
   \   00000044   0030C2E7           STRB     R3,[R2, +R0]
    183          		}
   \   00000048   012082E2           ADD      R2,R2,#+1
   \                     ??ProgramFlash_2:
   \   0000004C   010052E1           CMP      R2,R1
   \   00000050   FBFFFFBA           BLT      ??ProgramFlash_3
    184          	}
    185          	bool Status=ProgramMX29LV(FirstSector,targetAddress,srcAddress,srcSize);
   \                     ??ProgramFlash_1:
   \   00000054   0830A0E1           MOV      R3,R8
   \   00000058   0720A0E1           MOV      R2,R7
   \   0000005C   0610A0E1           MOV      R1,R6
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   ........           _BLF     ??ProgramMX29LV,??ProgramMX29LV??rA
   \   00000068   0050A0E1           MOV      R5,R0
    186          	OS_Unuse(&FlashSema);
   \   0000006C   0400A0E1           MOV      R0,R4
   \   00000070   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    187          	return(Status);
   \   00000074   0500A0E1           MOV      R0,R5
   \   00000078   F041BDE8           POP      {R4-R8,LR}
   \   0000007C   1EFF2FE1           BX       LR               ;; return
    188          
    189          }
    190          

   \                                 In segment CODE, align 4, keep-with-next
    191          bool FlashWrite(U32 SrcAddress, U32 Size)
    192          {
   \                     ??FlashWrite:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    193          	
    194          
    195          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R6,??DataTable34  ;; FlashSema
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    196          #if (WATCHDOG == 1)
    197              OS_SignalEvent(WD_FLASH_WRITE,&WatchDogTaskHandle);
    198          #endif
    199          	bool Success = FlashInitFileSystem();
    200          #ifndef ANBOOTLOADER
    201          	if ( Success ) {
   \   00000010   ........           LDR      R8,??DataTable33  ;; ??WriteAll
   \   00000014   0600A0E1           MOV      R0,R6
   \   00000018   ........           _BLF     OS_Use,??OS_Use??rA
   \   0000001C   ........           LDR      R1,??DataTable27  ;; WatchDogTaskHandle
   \   00000020   4000A0E3           MOV      R0,#+64
   \   00000024   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
   \   00000028   ........           BL       ??FlashInitFileSystem
   \   0000002C   0070B0E1           MOVS     R7,R0
   \   00000030   0C00000A           BEQ      ??FlashWrite_1
    202          		if ( Size < GetFreeSize() ) {
   \   00000034   ........           BL       ??GetFreeSize
   \   00000038   000055E1           CMP      R5,R0
   \   0000003C   0900002A           BCS      ??FlashWrite_1
    203          			Success = ProgramFlash(FlashActiveSector,FlashStartOfFreeArea,SrcAddress,Size);
   \   00000040   ........           LDR      R0,??DataTable35  ;; FlashStartOfFreeArea
   \   00000044   0530A0E1           MOV      R3,R5
   \   00000048   001090E5           LDR      R1,[R0, #+0]
   \   0000004C   040090E5           LDR      R0,[R0, #+4]
   \   00000050   0420A0E1           MOV      R2,R4
   \   00000054   ........           BL       ??ProgramFlash
   \   00000058   0070B0E1           MOVS     R7,R0
    204          			if ( Success ) {
    205          				PRogramObjectBase::WriteAll = false;
   \   0000005C   0000A013           MOVNE    R0,#+0
   \   00000060   0000C815           STRBNE   R0,[R8, #+0]
   \   00000064   0200001A           BNE      ??FlashWrite_2
    206          			} else {
    207          				PRogramObjectBase::WriteAll = true;
   \                     ??FlashWrite_1:
   \   00000068   0100A0E3           MOV      R0,#+1
   \   0000006C   0000C8E5           STRB     R0,[R8, #+0]
    208          				SignalSaveSettings(FLASH_SAVE_SETTINGS);
   \   00000070   ........           _BLF     ??SignalSaveSettings,??SignalSaveSettings??rA
    209          			}
    210          		} else {
    211          			PRogramObjectBase::WriteAll = true;
    212          			SignalSaveSettings(FLASH_SAVE_SETTINGS);
    213          		}
    214          	} else {
    215          		PRogramObjectBase::WriteAll = true;
    216          		SignalSaveSettings(FLASH_SAVE_SETTINGS);
    217          	}
    218          #endif
    219          	OS_Unuse(&FlashSema);
   \                     ??FlashWrite_2:
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    220          	return(Success);
   \   0000007C   0700A0E1           MOV      R0,R7
   \   00000080   F041BDE8           POP      {R4-R8,LR}
   \   00000084   1EFF2FE1           BX       LR               ;; return
    221          }
    222          
    223          
    224          // This routine assumes that the active sector shall be changed
    225          

   \                                 In segment CODE, align 4, keep-with-next
    226          bool FlashWriteAll(U32 SrcAddress, U32 Size)
    227          {
   \                     ??FlashWriteAll:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
    228          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R5,??DataTable34  ;; FlashSema
   \   00000008   04D04DE2           SUB      SP,SP,#+4
   \   0000000C   0140A0E1           MOV      R4,R1
    229          #if (WATCHDOG == 1)
    230              OS_SignalEvent(WD_FLASH_WRITE,&WatchDogTaskHandle);
    231          #endif
    232          
    233          	bool Success = true;
    234          
    235          	U32* Bank1Address = (U32*)(SectorTable[SectorSettings1Start]+FlashBaseAddress);
   \   00000010   ........           LDR      R7,??DataTable24  ;; SectorSettings1Start
    236          	U32* Bank2Address = (U32*)(SectorTable[SectorSettings2Start]+FlashBaseAddress);
    237          	switch ( *Bank1Address ) {
   \   00000014   ........           LDR      R10,??DataTable25  ;; FlashStartOfFreeArea
   \   00000018   ........           LDR      R11,??DataTable26  ;; SectorSettings1End
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   ........           _BLF     OS_Use,??OS_Use??rA
   \   00000024   ........           LDR      R1,??DataTable27  ;; WatchDogTaskHandle
   \   00000028   4000A0E3           MOV      R0,#+64
   \   0000002C   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
   \   00000030   ........           LDR      R0,??DataTable28  ;; FlashBaseAddress
   \   00000034   ........           LDR      R2,??DataTable29  ;; SectorTable
   \   00000038   001090E5           LDR      R1,[R0, #+0]
   \   0000003C   000097E5           LDR      R0,[R7, #+0]
   \   00000040   003092E5           LDR      R3,[R2, #+0]
   \   00000044   0160A0E3           MOV      R6,#+1
   \   00000048   008193E7           LDR      R8,[R3, +R0, LSL #+2]
   \   0000004C   088081E0           ADD      R8,R1,R8
   \   00000050   00808DE5           STR      R8,[SP, #+0]
   \   00000054   ........           LDR      R8,??DataTable30  ;; SectorSettings2Start
   \   00000058   002098E5           LDR      R2,[R8, #+0]
   \   0000005C   023193E7           LDR      R3,[R3, +R2, LSL #+2]
   \   00000060   039081E0           ADD      R9,R1,R3
   \   00000064   00109DE5           LDR      R1,[SP, #+0]
   \   00000068   001091E5           LDR      R1,[R1, #+0]
   \   0000006C   040071E3           CMN      R1,#+4
   \   00000070   0200000A           BEQ      ??FlashWriteAll_1
   \   00000074   010071E3           CMN      R1,#+1
   \   00000078   2700000A           BEQ      ??FlashWriteAll_2
   \   0000007C   230000EA           B        ??FlashWriteAll_3
   \                     ??FlashWriteAll_1:
   \   00000080   000099E5           LDR      R0,[R9, #+0]
   \   00000084   010070E3           CMN      R0,#+1
   \   00000088   1900001A           BNE      ??FlashWriteAll_4
   \                     ??FlashWriteAll_5:
   \   0000008C   0110E0E3           MVN      R1,#+1
   \   00000090   0900A0E1           MOV      R0,R9
    238          		case BLOCK_IS_OK    :
    239          			{
    240          				switch ( *Bank2Address ) {
    241          					case BLOCK_IS_UNUSED:
    242          						// Sector 2 is free, write to sector 2
    243          						Success = MX29LV_ProgFlash((U32)Bank2Address,BLOCK_IS_RESERVED);
   \   00000094   ........           _BLF     ??MX29LV_ProgFlash,??MX29LV_ProgFlash??rA
   \   00000098   0060B0E1           MOVS     R6,R0
    244          						if ( Success ) {
   \   0000009C   3500000A           BEQ      ??FlashWriteAll_6
    245          							Success = ProgramFlash(SectorSettings2Start,sizeof(U32),SrcAddress,Size);
   \   000000A0   04209DE5           LDR      R2,[SP, #+4]
   \   000000A4   000098E5           LDR      R0,[R8, #+0]
   \   000000A8   0430A0E1           MOV      R3,R4
   \   000000AC   0410A0E3           MOV      R1,#+4
   \   000000B0   ........           BL       ??ProgramFlash
   \   000000B4   0060B0E1           MOVS     R6,R0
    246          							if ( Success ) {
   \   000000B8   2E00000A           BEQ      ??FlashWriteAll_6
    247          								Success = MX29LV_ProgFlash((U32)Bank2Address,BLOCK_IS_OK);
   \   000000BC   0310E0E3           MVN      R1,#+3
   \   000000C0   0900A0E1           MOV      R0,R9
   \   000000C4   ........           _BLF     ??MX29LV_ProgFlash,??MX29LV_ProgFlash??rA
   \   000000C8   0060B0E1           MOVS     R6,R0
    248          								if ( Success ) {
   \   000000CC   2900000A           BEQ      ??FlashWriteAll_6
    249          									// We had success, erase sector 1.
    250          									Success = MX29LV_EraseSectors(SectorSettings1Start,SectorSettings1End);
   \   000000D0   00109BE5           LDR      R1,[R11, #+0]
   \   000000D4   000097E5           LDR      R0,[R7, #+0]
   \   000000D8   ........           _BLF     ??MX29LV_EraseSectors,??MX29LV_EraseSectors??rA
   \   000000DC   0060A0E1           MOV      R6,R0
    251          									FlashActiveSector    = SectorSettings2Start;
   \   000000E0   000098E5           LDR      R0,[R8, #+0]
   \   000000E4   04008AE5           STR      R0,[R10, #+4]
    252          									FlashActiveSectorEnd = SectorSettings2End;
   \   000000E8   ........           LDR      R0,??DataTable32  ;; SectorSettings2End
   \   000000EC   000090E5           LDR      R0,[R0, #+0]
   \   000000F0   1F0000EA           B        ??FlashWriteAll_7
    253          								}
    254          							}
    255          						}
    256          						break;
    257          					case BLOCK_IS_OK    :
    258          						// Something is not correct.
    259          						// We always select the first sector as OK and erase
    260          						// sector 2
    261          						{
    262          							// We assume that the data in sector 1 is valid and
    263          							// erase sector 2 before writing to sector 2.
    264          							// After writing, erasee sector 1.
    265          							Success = MX29LV_EraseSectors(SectorSettings2Start,SectorSettings2End);
   \                     ??FlashWriteAll_4:
   \   000000F4   ........           LDR      R0,??DataTable32  ;; SectorSettings2End
   \   000000F8   001090E5           LDR      R1,[R0, #+0]
   \   000000FC   0200A0E1           MOV      R0,R2
   \   00000100   ........           _BLF     ??MX29LV_EraseSectors,??MX29LV_EraseSectors??rA
   \   00000104   0060B0E1           MOVS     R6,R0
    266          							if ( Success ) {
   \   00000108   DFFFFF1A           BNE      ??FlashWriteAll_5
   \   0000010C   190000EA           B        ??FlashWriteAll_6
    267          								Success = MX29LV_ProgFlash((U32)Bank2Address,BLOCK_IS_RESERVED);
    268          								if ( Success ) {
    269          									Success = ProgramFlash(SectorSettings2Start,sizeof(U32),SrcAddress,Size);
    270          									if ( Success ) {
    271          										Success = MX29LV_ProgFlash((U32)Bank2Address,BLOCK_IS_OK);
    272          										if ( Success ) {
    273          											// We had success, erase sector 1.
    274          											Success = MX29LV_EraseSectors(SectorSettings1Start,SectorSettings1End);
    275          											FlashActiveSector    = SectorSettings2Start;
    276          											FlashActiveSectorEnd = SectorSettings2End;
    277          										}
    278          									}
    279          								}
    280          							}
    281          						}
    282          						break;
    283          					case BLOCK_IS_RESERVED:
    284          					default:
    285          						// Sector 2 is not OK. We write to this sector
    286          						// First erase sector 2
    287          						Success = MX29LV_EraseSectors(SectorSettings2Start,SectorSettings2End);
    288          						if ( Success ) {
    289          							// Write to sector 2
    290          							Success = MX29LV_ProgFlash((U32)Bank2Address,BLOCK_IS_RESERVED);
    291          							if ( Success ) {
    292          								Success = ProgramFlash(SectorSettings2Start,sizeof(U32),SrcAddress,Size);
    293          								if ( Success ) {
    294          									Success = MX29LV_ProgFlash((U32)Bank2Address,BLOCK_IS_OK);
    295          									if ( Success ) {
    296          										// We had success, erase sector 1.
    297          										Success = MX29LV_EraseSectors(SectorSettings1Start,SectorSettings1End);
    298          										FlashActiveSector    = SectorSettings2Start;
    299          										FlashActiveSectorEnd = SectorSettings2End;
    300          									}
    301          								}
    302          							}
    303          						}
    304          						break;
    305          				}
    306          			}
    307          			break;
    308          		case BLOCK_IS_RESERVED:
    309          		default:
    310          			// Sector 1 is not OK. We erase this sector
    311          			Success = MX29LV_EraseSectors(SectorSettings1Start,SectorSettings1End);
   \                     ??FlashWriteAll_3:
   \   00000110   00109BE5           LDR      R1,[R11, #+0]
   \   00000114   ........           _BLF     ??MX29LV_EraseSectors,??MX29LV_EraseSectors??rA
   \   00000118   0060A0E1           MOV      R6,R0
    312          			// Just fall through
    313          		case BLOCK_IS_UNUSED:
    314          			if ( Success ) {
   \                     ??FlashWriteAll_2:
   \   0000011C   000056E3           CMP      R6,#+0
   \   00000120   1400000A           BEQ      ??FlashWriteAll_6
    315          				Success = MX29LV_ProgFlash((U32)Bank1Address,BLOCK_IS_RESERVED);
   \   00000124   00809DE5           LDR      R8,[SP, #+0]
   \   00000128   0110E0E3           MVN      R1,#+1
   \   0000012C   0800A0E1           MOV      R0,R8
   \   00000130   ........           _BLF     ??MX29LV_ProgFlash,??MX29LV_ProgFlash??rA
   \   00000134   0060B0E1           MOVS     R6,R0
    316          				if ( Success ) {
   \   00000138   0E00000A           BEQ      ??FlashWriteAll_6
    317          					Success = ProgramFlash(SectorSettings1Start,sizeof(U32),SrcAddress,Size);
   \   0000013C   04209DE5           LDR      R2,[SP, #+4]
   \   00000140   000097E5           LDR      R0,[R7, #+0]
   \   00000144   0430A0E1           MOV      R3,R4
   \   00000148   0410A0E3           MOV      R1,#+4
   \   0000014C   ........           BL       ??ProgramFlash
   \   00000150   0060B0E1           MOVS     R6,R0
    318          					if ( Success ) {
   \   00000154   0700000A           BEQ      ??FlashWriteAll_6
    319          						Success = MX29LV_ProgFlash((U32)Bank1Address,BLOCK_IS_OK);
   \   00000158   0310E0E3           MVN      R1,#+3
   \   0000015C   0800A0E1           MOV      R0,R8
   \   00000160   ........           _BLF     ??MX29LV_ProgFlash,??MX29LV_ProgFlash??rA
   \   00000164   0060A0E1           MOV      R6,R0
    320          						FlashActiveSector    = SectorSettings1Start;
   \   00000168   000097E5           LDR      R0,[R7, #+0]
   \   0000016C   04008AE5           STR      R0,[R10, #+4]
    321          						FlashActiveSectorEnd = SectorSettings1End;
   \   00000170   00009BE5           LDR      R0,[R11, #+0]
   \                     ??FlashWriteAll_7:
   \   00000174   08008AE5           STR      R0,[R10, #+8]
    322          					}
    323          				}
    324          			}
    325          			break;
    326          	}
    327          #ifndef ANBOOTLOADER
    328          	if ( Success ) {
   \                     ??FlashWriteAll_6:
   \   00000178   ........           LDR      R0,??DataTable33  ;; ??WriteAll
   \   0000017C   000056E3           CMP      R6,#+0
    329          		PRogramObjectBase::WriteAll = false;
   \   00000180   0010A013           MOVNE    R1,#+0
   \   00000184   0010C015           STRBNE   R1,[R0, #+0]
   \   00000188   0300001A           BNE      ??FlashWriteAll_8
    330          	} else {
    331          		PRogramObjectBase::WriteAll = true;
   \   0000018C   0110A0E3           MOV      R1,#+1
   \   00000190   0010C0E5           STRB     R1,[R0, #+0]
    332          		SignalSaveSettings(FLASH_SAVE_SETTINGS);
   \   00000194   0100A0E3           MOV      R0,#+1
   \   00000198   ........           _BLF     ??SignalSaveSettings,??SignalSaveSettings??rA
    333          	}
    334          #endif
    335          	OS_Unuse(&FlashSema);
   \                     ??FlashWriteAll_8:
   \   0000019C   0500A0E1           MOV      R0,R5
   \   000001A0   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    336          	return(Success);
   \   000001A4   0600A0E1           MOV      R0,R6
   \   000001A8   F64FBDE8           POP      {R1,R2,R4-R11,LR}
   \   000001AC   1EFF2FE1           BX       LR               ;; return
    337          }
    338          

   \                                 In segment CODE, align 4, keep-with-next
    339          bool FlashRead(char *Destination, int &FlashSize)
    340          {
   \                     ??FlashRead:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    341          	OS_Use(&FlashSema);
   \   00000004   ........           LDR      R6,??DataTable34  ;; FlashSema
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0600A0E1           MOV      R0,R6
   \   00000014   ........           _BLF     OS_Use,??OS_Use??rA
    342          
    343          	bool Success = FlashInitFileSystem();
   \   00000018   ........           BL       ??FlashInitFileSystem
   \   0000001C   0070B0E1           MOVS     R7,R0
    344          
    345          	if ( Success ) {
   \   00000020   0B00000A           BEQ      ??FlashRead_1
    346          		int FSize = FlashStartOfFreeArea-sizeof(U32);
   \   00000024   ........           LDR      R0,??DataTable35  ;; FlashStartOfFreeArea
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   040050E2           SUBS     R0,R0,#+4
    347          		if ( FSize ) {
   \   00000030   0600000A           BEQ      ??FlashRead_2
    348          			FlashSize = FSize;
   \   00000034   000085E5           STR      R0,[R5, #+0]
    349          			char *Src = (char*)GetFlashStartAddress();
   \   00000038   ........           BL       ??GetFlashStartAddress
    350          			memcpy(Destination,Src,FlashSize);
   \   0000003C   002095E5           LDR      R2,[R5, #+0]
   \   00000040   0010A0E1           MOV      R1,R0
   \   00000044   0400A0E1           MOV      R0,R4
   \   00000048   ........           _BLF     memcpy,??memcpy??rA
   \   0000004C   000000EA           B        ??FlashRead_1
    351          		} else {
    352          			Success = false;
   \                     ??FlashRead_2:
   \   00000050   0070A0E3           MOV      R7,#+0
    353          		}
    354          	}
    355          	OS_Unuse(&FlashSema);
   \                     ??FlashRead_1:
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   ........           _BLF     OS_Unuse,??OS_Unuse??rA
    356          	return(Success);
   \   0000005C   0700A0E1           MOV      R0,R7
   \   00000060   F040BDE8           POP      {R4-R7,LR}
   \   00000064   1EFF2FE1           BX       LR               ;; return
    357          }
    358          

   \                                 In segment CODE, align 4, keep-with-next
    359          int SaveConfig(U32 SrcAddress, U32 Size)
    360          {
   \                     ??SaveConfig:
   \   00000000   F34F2DE9           PUSH     {R0,R1,R4-R11,LR}
    361          	int ErrorStatus     = FLASH_NO_ERROR;
    362          	U8  *ConfigStartPtr = NULL;
    363          	U32 ConfigSize      = 0;
   \   00000004   08619FE5           LDR      R6,??SaveConfig_1  ;; SectorConfigStart
   \   00000008   08719FE5           LDR      R7,??SaveConfig_1+0x4  ;; SectorConfigEnd
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   \   00000010   001097E5           LDR      R1,[R7, #+0]
   \   00000014   00519FE5           LDR      R5,??SaveConfig_1+0x8  ;; SectorConfigBakStart
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   00008DE5           STR      R0,[SP, #+0]
   \   00000020   04008DE5           STR      R0,[SP, #+4]
   \   00000024   000096E5           LDR      R0,[R6, #+0]
   \   00000028   0040A0E3           MOV      R4,#+0
   \   0000002C   04308DE2           ADD      R3,SP,#+4
   \   00000030   0D20A0E1           MOV      R2,SP
    364          	U32 SConfigStart    = 0;
    365          	U32 SConfigEnd      = 0;
    366          	U32 SConfigBakStart = 0;
    367          	U32 SConfigBakEnd   = 0;
    368          	bool FlashOK        = false;
    369          	// First, check if it is the main or backup which exist
    370          	if ( GetBlockInfoMX29LV(SectorConfigStart,SectorConfigEnd, &ConfigStartPtr, &ConfigSize ) ) {
   \   00000034   ........           _BLF     ??GetBlockInfoMX29LV,??GetBlockInfoMX29LV??rA
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0500000A           BEQ      ??SaveConfig_2
    371          		SConfigStart    = SectorConfigStart;
    372          		SConfigEnd      = SectorConfigEnd;
    373          		SConfigBakStart = SectorConfigBakStart;
    374          		SConfigBakEnd   = SectorConfigBakEnd;
   \   00000040   D8009FE5           LDR      R0,??SaveConfig_1+0xC  ;; SectorConfigBakEnd
   \   00000044   008096E5           LDR      R8,[R6, #+0]
   \   00000048   009097E5           LDR      R9,[R7, #+0]
   \   0000004C   00A095E5           LDR      R10,[R5, #+0]
   \   00000050   00B090E5           LDR      R11,[R0, #+0]
    375          		FlashOK         = true;
   \   00000054   0C0000EA           B        ??SaveConfig_3
    376          	} else if ( GetBlockInfoMX29LV(SectorConfigBakStart,SectorConfigBakEnd, &ConfigStartPtr, &ConfigSize ) ) {
   \                     ??SaveConfig_2:
   \   00000058   C0009FE5           LDR      R0,??SaveConfig_1+0xC  ;; SectorConfigBakEnd
   \   0000005C   04308DE2           ADD      R3,SP,#+4
   \   00000060   001090E5           LDR      R1,[R0, #+0]
   \   00000064   000095E5           LDR      R0,[R5, #+0]
   \   00000068   0D20A0E1           MOV      R2,SP
   \   0000006C   ........           _BLF     ??GetBlockInfoMX29LV,??GetBlockInfoMX29LV??rA
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   2200000A           BEQ      ??SaveConfig_4
    377          		SConfigStart    = SectorConfigBakStart;
    378          		SConfigEnd      = SectorConfigBakEnd;
   \   00000078   A0009FE5           LDR      R0,??SaveConfig_1+0xC  ;; SectorConfigBakEnd
   \   0000007C   008095E5           LDR      R8,[R5, #+0]
   \   00000080   009090E5           LDR      R9,[R0, #+0]
    379          		SConfigBakStart = SectorConfigStart;
   \   00000084   00A096E5           LDR      R10,[R6, #+0]
    380          		SConfigBakEnd   = SectorConfigEnd;
   \   00000088   00B097E5           LDR      R11,[R7, #+0]
    381          		FlashOK         = true;
    382          	} else {
    383          		// Should never get here!!!!
    384          	}
    385          	//FlashOK = false; // EHSMarkva_list
    386          	if ( FlashOK ) {
    387          		// Always erase what we consider for backup
    388          		if ( !MX29LV_EraseSectors(SConfigBakStart,SConfigBakEnd) ) {
   \                     ??SaveConfig_3:
   \   0000008C   0A00A0E1           MOV      R0,R10
   \   00000090   0B10A0E1           MOV      R1,R11
   \   00000094   ........           _BLF     ??MX29LV_EraseSectors,??MX29LV_EraseSectors??rA
   \   00000098   000050E3           CMP      R0,#+0
    389          			ErrorStatus = FLASH_ERASE_FAILURE;
   \   0000009C   0140A003           MOVEQ    R4,#+1
   \   000000A0   0C00000A           BEQ      ??SaveConfig_5
    390          		} else if ( !ProgramMX29LV(SConfigBakStart,0,SrcAddress,Size) ) {
   \   000000A4   0C309DE5           LDR      R3,[SP, #+12]
   \   000000A8   08209DE5           LDR      R2,[SP, #+8]
   \   000000AC   0010A0E3           MOV      R1,#+0
   \   000000B0   0A00A0E1           MOV      R0,R10
   \   000000B4   ........           _BLF     ??ProgramMX29LV,??ProgramMX29LV??rA
   \   000000B8   000050E3           CMP      R0,#+0
    391          			ErrorStatus = FLASH_PROGRAM_FAILURE;
   \   000000BC   0440A003           MOVEQ    R4,#+4
   \   000000C0   0400000A           BEQ      ??SaveConfig_5
    392          		} else if ( !MarkCompletedMX29LV(SConfigBakEnd,Size) ) {
   \   000000C4   0C109DE5           LDR      R1,[SP, #+12]
   \   000000C8   0B00A0E1           MOV      R0,R11
   \   000000CC   ........           _BLF     ??MarkCompletedMX29LV,??MarkCompletedMX29LV??rA
   \   000000D0   000050E3           CMP      R0,#+0
    393          			ErrorStatus = FLASH_MARK_COMPLETE_FAILURE;
   \   000000D4   0240A003           MOVEQ    R4,#+2
    394          		} if ( !MX29LV_EraseSectors(SConfigStart,SConfigEnd) ) {
   \                     ??SaveConfig_5:
   \   000000D8   0910A0E1           MOV      R1,R9
   \   000000DC   0800A0E1           MOV      R0,R8
   \   000000E0   ........           _BLF     ??MX29LV_EraseSectors,??MX29LV_EraseSectors??rA
   \   000000E4   000050E3           CMP      R0,#+0
    395          			ErrorStatus = FLASH_ERASE_FAILURE;
   \   000000E8   0140A003           MOVEQ    R4,#+1
   \   000000EC   0400000A           BEQ      ??SaveConfig_4
    396          		}else{
    397          			SectorConfigStart    = SConfigBakStart;
    398          			SectorConfigEnd      = SConfigBakEnd;
    399          			SectorConfigBakStart = SConfigStart;
    400          			SectorConfigBakEnd   = SConfigEnd;
   \   000000F0   28009FE5           LDR      R0,??SaveConfig_1+0xC  ;; SectorConfigBakEnd
   \   000000F4   00A086E5           STR      R10,[R6, #+0]
   \   000000F8   00B087E5           STR      R11,[R7, #+0]
   \   000000FC   008085E5           STR      R8,[R5, #+0]
   \   00000100   009080E5           STR      R9,[R0, #+0]
    401          		}
    402          	}
    403          	return ErrorStatus;
   \                     ??SaveConfig_4:
   \   00000104   0400A0E1           MOV      R0,R4
   \   00000108   10D08DE2           ADD      SP,SP,#+16
   \   0000010C   F04FBDE8           POP      {R4-R11,LR}
   \   00000110   1EFF2FE1           BX       LR               ;; return
   \                     ??SaveConfig_1:
   \   00000114   ........           DC32     SectorConfigStart
   \   00000118   ........           DC32     SectorConfigEnd
   \   0000011C   ........           DC32     SectorConfigBakStart
   \   00000120   ........           DC32     SectorConfigBakEnd
    404          }

   \                                 In segment DIFUNCT, align 4, keep-with-next, root
   \   00000000                      REQUIRE ?call_ctors
   \   00000000   ........           DC32    ??__sti__routine

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "PROProjectInfo">`:
   \   00000000   50524F50726F       DC8 "PROProjectInfo"
   \              6A656374496E
   \              666F00      
   \   0000000F   00                 DC8 0

   \                                 In segment CODE, align 4, keep-with-next
   \   static __??Code32?? __intrinsic __code __interwork __atpcs void __sti__routine()
   \                     ??__sti__routine:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     SectorSettings1Start

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   ........           DC32     FlashStartOfFreeArea

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   ........           DC32     SectorSettings1End

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   ........           DC32     WatchDogTaskHandle

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   ........           DC32     FlashBaseAddress

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   ........           DC32     SectorTable

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   ........           DC32     SectorSettings2Start

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   ........           DC32     SectorSettings2End

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   ........           DC32     ??WriteAll

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   ........           DC32     FlashSema

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   ........           DC32     FlashStartOfFreeArea
    405          

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     FlashFindFreeArea()               12
     FlashInitFileSystem()             16
     FlashRead(char *, int &)          20
     FlashSetActiveSector()            12
     FlashVerifyArea(unsigned long)    32
     FlashWrite(unsigned long, unsigned long)
                                       24
     FlashWriteAll(unsigned long, unsigned long)
                                       44
     GetFlashStartAddress()             0
     GetFreeSize()                     16
     GetUsedSize()                     12
     ProgramFlash(unsigned long, unsigned long, unsigned long, unsigned long)
                                       24
     SaveConfig(unsigned long, unsigned long)
                                       52
     __sti__routine()                   0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     FlashStartOfFreeArea             13
     GetFlashStartAddress()           44
     FlashFindFreeArea()              72
     FlashVerifyArea(unsigned long)  172
     FlashSetActiveSector()          188
     FlashInitFileSystem()           108
     GetFreeSize()                    88
     GetUsedSize()                    56
     ProgramFlash(unsigned long, unsigned long, unsigned long, unsigned long)
                                     128
     FlashWrite(unsigned long, unsigned long)
                                     136
     FlashWriteAll(unsigned long, unsigned long)
                                     432
     FlashRead(char *, int &)        104
     SaveConfig(unsigned long, unsigned long)
                                     292
     ?<Constant "PROProjectInfo">     16
     __sti__routine()                  4
     ??DataTable24                     4
     ??DataTable25                     4
     ??DataTable26                     4
     ??DataTable27                     4
     ??DataTable28                     4
     ??DataTable29                     4
     ??DataTable30                     4
     ??DataTable32                     4
     ??DataTable33                     4
     ??DataTable34                     4
     ??DataTable35                     4
      Others                         200

 
 2 052 bytes in segment CODE
    16 bytes in segment DATA_C
    13 bytes in segment DATA_Z
     4 bytes in segment DIFUNCT
    12 bytes in segment INITTAB
 
 1 872 bytes of CODE  memory (+ 196 bytes shared)
    16 bytes of CONST memory
    13 bytes of DATA  memory

Errors: none
Warnings: none
