##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:17:31 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\src\StartTXU.cpp                       #
#    Command line    =  D:\S2Prog\TXU\src\StartTXU.cpp --fpu None -D         #
#                       OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D      #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --eec++           #
#                       --dlib_config "C:\Program Files (x86)\IAR            #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl4tpainl8n.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\StartTXU.lst                #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\StartTXU.r79                 #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\src\StartTXU.cpp
      1          /**********************************************************
      2          *          SEGGER MICROCONTROLLER SYSTEME GmbH
      3          *   Solutions for real time microcontroller applications
      4          ***********************************************************
      5          File    : Main.c
      6          Purpose : Skeleton program for embOS
      7          --------- END-OF-HEADER ---------------------------------*/
      8          
      9          
     10          #include "TSNConstants.h"
     11          #include "2410addr.h"
     12          #include "2410lib.h"
     13          #include "lcdconf.h"
     14          #include "rtos.h"
     15          #include "def.h"
     16          #include "mmu.h"
     17          #ifdef S2TXU
     18          #include "gui.h"
     19          #include "TSNDefines.h"
     20          #include "TSNConstants.h"
     21          #include "ANPRO10Const.h"
     22          #include "ANSIString.h"
     23          #include "TSNConfigString.h"
     24          #include "TSNStruct.h"
     25          
     26          extern int EraseFlash(U8);
     27          #else
     28          #include "BootLoaderIncludes.h"
     29          #endif
     30          #include "TSNUart.h"
     31          #include "sc2410Uart.h"
     32          #include "st16554Uart.h"
     33          #include <string.h>
     34          #include <locale.h>
     35          #include <minilzo.h>
     36          #include "FixedVariables.h"

   \                                 In segment DATA_AN, at 0x31fff010
   \   unsigned int volatile __data LastOSError
   \                     LastOSError:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0x31fff014
   \   unsigned int volatile __data ProgProgress
   \                     ProgProgress:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0x31fff01c
   \   char __data LastOSErrorTask[32]
   \                     LastOSErrorTask:
   \   00000000                      DS8 32

   \                                 In segment DATA_AN, at 0x31fff03c
   \   long volatile __data LastStartTime
   \                     LastStartTime:
   \   00000000                      DS8 4
     37          OS_MAILBOX IncMailBox;
     38          extern TSN_TASK SaveSettingsTaskHandle;
     39          
     40          
     41          extern void GetRTC(void);
     42          // From mx29LV160TB.cpp
     43          extern U32 *SectorTable;
     44          extern U32 SectorBootStart;
     45          extern U32 SectorBootEnd;
     46          extern U32 SectorProgStart;
     47          extern U32 SectorProgEnd;
     48          extern U32 SectorConfigStart;
     49          extern U32 SectorConfigEnd;
     50          extern U32 SectorConfigBakStart;
     51          extern U32 SectorConfigBakEnd;
     52          extern U32 SectorSettings1Start;
     53          extern U32 SectorSettings2End;
     54          
     55          extern AnsiString ConfigWarningsString;
     56          
     57          extern void SetCpuFrequency(void);
     58          extern void TDUStartupInit(void);
     59          // From ANPRO10.cpp
     60          #if defined(ANBOOTLOADER)
     61          OS_MEMF pUnPackMem;
     62          #endif
     63          // From mx29LV160TB.cpp
     64          extern bool MX29LV_CheckId(void);
     65          extern void SetFlashSectorTable(void);
     66          extern "C"
     67          {
     68          extern void OS_COM_Send1(OS_U8 c);
     69          extern void mmu_setup(void);
     70          extern volatile U16  TXUADData[8];
     71          extern time_t* GetTimeZone(void);
     72          // Network
     73          }
     74          extern short CurrentDeviceId;
     75          // From Utilities.cpp
     76          extern void SendAlarmSilence(void);
     77          extern void WD_Set_Status(U32 Mask, U32 Flag);
     78          extern U32  WD_Get_Status(U32 Mask);
     79          
     80          
     81          extern void TDUStartupInit(void);
     82          extern bool ReadConfig(char *fileName);
     83          extern void StartWindowSystem(void);
     84          extern void StartTasks(void);
     85          extern void StartRelayTasks(void);
     86          
     87          extern void LCD_Init_Controller(void);
     88          extern void LCD_BackLightOn(void);
     89          extern void LCD_BackLightOff(void);
     90          extern void LCD_BackLightAdjust(int);
     91          
     92          extern OS_RSEMA RTCSema;
     93          extern OS_RSEMA FlashSema;
     94          extern OS_RSEMA UnpackSema;
     95          #ifndef ANBOOTLOADER
     96          extern OS_RSEMA LanguageSema;
     97          extern OS_RSEMA UnitSema;
     98          extern OS_TIMER ReceiveFlashTimer;
     99          extern OS_TIMER AlarmSilenceTimer;
    100          extern void ReceiveFlashTimeOut(void);
    101          extern void SetAlarmSoundOn(void);
    102          
    103          
    104          #endif
    105          
    106          
    107          
    108          /*
    109          OS_DEFFUNC char OS_GetMailTimed(OS_MAILBOX * pMB, void* pDest, int Timeout)
    110          {
    111              int ExitTime=OS_Time+Timeout;
    112              char NoMsgReceived;
    113              do {
    114                  NoMsgReceived=OS_GetMailCond1(pMB,(char*)pDest);
    115                  if ( NoMsgReceived ) {
    116                      OS_Delay(2);
    117                  }
    118              }while ( NoMsgReceived && (OS_Time < ExitTime ) );
    119              return (NoMsgReceived);
    120              //return(bool)!OS_GetMailTimed(&RxBuf,(char*)MyData,TimeOut);
    121          }
    122          */
    123          
    124          OS_RSEMA GPEPortSema;
    125          int TouchScreenTimeOut        = DEFAULT_SCREEN_OFF_DELAY;
    126          #ifdef ANBOOTLOADER
    127          extern "C"
    128          {
    129          extern char ProgramData[];
    130          extern int ProgramDataSize;
    131          // The following should be in a file common for all variants of the project
    132          }
    133          
    134          extern short CurrentDeviceId;
    135          extern short CurrentDeviceAddress;
    136          extern bool Master;
    137          
    138          extern void InitTDUGUI(void);
    139          
    140          
    141          #pragma data_alignment=8
    142          static OS_STACKPTR int Stack3[1024];        /* Task stacks */
    143          static OS_TASK TCB3;                                /* Task-control-blocks */
    144          #else
    145          #if (USE_EMBOS_MEM_POOL==1) 
    146          OS_MEMF pANPRO10MemPool;
    147          OS_MEMF pANPRO10IOMemPool;
    148          #endif
    149          // The main application, not the bootloader
    150          
    151          extern volatile bool PinUnlock;
    152          #endif
    153          
    154          ////////////////////////////////////////////////////////////////////////////
    155          //
    156          //  Watchdog timer
    157          //  Required, because sometimes the task with lowest priority may have
    158          //  to wait for a few seconds
    159          //
    160          ////////////////////////////////////////////////////////////////////////////
    161          
    162          OS_TIMER WatchdogTimeOutTimer;
    163          volatile int KickTheDog = 100;

   \                                 In segment CODE, align 4, keep-with-next
    164          void WatchdogTimeOutHandler(void) {
    165              if (KickTheDog) {
   \                     ??WatchdogTimeOutHandler:
   \   00000000   ........           LDR      R0,??DataTable1  ;; KickTheDog
   \   00000004   10402DE9           PUSH     {R4,LR}
   \   00000008   001090E5           LDR      R1,[R0, #+0]
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0D00000A           BEQ      ??WatchdogTimeOutHandler_1
    166                  KickTheDog--;
   \   00000014   001090E5           LDR      R1,[R0, #+0]
    167                  rWTCNT = 0xffff;    //Watch-dog count register
   \   00000018   FF20A0E3           MOV      R2,#+255
   \   0000001C   011041E2           SUB      R1,R1,#+1
   \   00000020   ........           STR      R1,[R0], #+8
   \   00000024   0810A0E3           MOV      R1,#+8
   \   00000028   531481E3           ORR      R1,R1,#0x53000000
   \   0000002C   FF2C82E3           ORR      R2,R2,#0xFF00
   \   00000030   002081E5           STR      R2,[R1, #+0]
    168                                      //Watch-dog timer enable
    169                  rWTCON |= 1;
   \   00000034   5314A0E3           MOV      R1,#+1392508928
   \   00000038   002091E5           LDR      R2,[R1, #+0]
   \   0000003C   012082E3           ORR      R2,R2,#0x1
   \   00000040   002081E5           STR      R2,[R1, #+0]
    170                  OS_RetriggerTimer(&WatchdogTimeOutTimer);
   \   00000044   ........           _BLF     OS_RetriggerTimer,??OS_RetriggerTimer??rA
   \   00000048   0D0000EA           B        ??WatchdogTimeOutHandler_2
    171              } else {
    172                  LastOSError = OS_Status;
   \                     ??WatchdogTimeOutHandler_1:
   \   0000004C   38009FE5           LDR      R0,??WatchdogTimeOutHandler_3  ;; OS_Status
   \   00000050   38409FE5           LDR      R4,??WatchdogTimeOutHandler_3+0x4  ;; 0x31fff010
   \   00000054   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000058   000084E5           STR      R0,[R4, #+0]
    173                  OS_TASKID CurrentTask;
    174                  CurrentTask = OS_GetTaskID();
   \   0000005C   30009FE5           LDR      R0,??WatchdogTimeOutHandler_3+0x8  ;; OS_pCurrentTask
   \   00000060   000090E5           LDR      R0,[R0, #+0]
    175                  if (CurrentTask) {
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   0300000A           BEQ      ??WatchdogTimeOutHandler_4
    176                      strcpy(LastOSErrorTask, CurrentTask->Name);
   \   0000006C   181090E5           LDR      R1,[R0, #+24]
   \   00000070   0C0084E2           ADD      R0,R4,#+12
   \   00000074   ........           _BLF     strcpy,??strcpy??rA
    177                  }
    178                  LastStartTime = time(NULL);
   \   00000078   0000A0E3           MOV      R0,#+0
   \                     ??WatchdogTimeOutHandler_4:
   \   0000007C   ........           _BLF     time,??time??rA
   \   00000080   2C0084E5           STR      R0,[R4, #+44]
    179              }
    180          }
   \                     ??WatchdogTimeOutHandler_2:
   \   00000084   1040BDE8           POP      {R4,LR}
   \   00000088   1EFF2FE1           BX       LR               ;; return
   \                     ??WatchdogTimeOutHandler_3:
   \   0000008C   ........           DC32     OS_Status
   \   00000090   10F0FF31           DC32     0x31fff010
   \   00000094   ........           DC32     OS_pCurrentTask
    181          
    182          
    183          ////////////////////////////////////////////////////////////////////////////
    184          //
    185          //  Watchdog task
    186          //  Required, because we only can close/delete a window from task-level
    187          //
    188          ////////////////////////////////////////////////////////////////////////////
    189          #if (WATCHDOG == 1)
    190          TSN_TASK WatchDogTaskHandle;                                                     /* Task control blocks */
    191          #pragma data_alignment=8
    192          char WatchDogTaskStack[512];
    193          //OS_MAILBOX WatchDogBuf;

   \                                 In segment CODE, align 4, keep-with-next
    194          static void WatchDogTask(void) {
   \                     ??WatchDogTask:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    195              bool AllRunning = false;
    196              time_t StartTime = time(NULL);
    197              OS_CREATETIMER(&WatchdogTimeOutTimer, WatchdogTimeOutHandler, WATCHDOG_RELOAD_DELAY);
   \   00000004   ........           LDR      R5,??DataTable1  ;; KickTheDog
   \   00000008   98919FE5           LDR      R9,??WatchDogTask_2  ;; ??WatchdogTimeOutHandler
    198              Timer_Start(3);
   \   0000000C   ........           LDR      R6,??DataTable9  ;; FlashSema
   \   00000010   ........           LDR      R11,??DataTable8  ;; 0x31fff014
   \   00000014   00A0A0E3           MOV      R10,#+0
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   0080A0E1           MOV      R8,R0
   \   00000020   ........           _BLF     time,??time??rA
   \   00000024   0040A0E1           MOV      R4,R0
   \   00000028   6420A0E3           MOV      R2,#+100
   \   0000002C   0910A0E1           MOV      R1,R9
   \   00000030   080085E2           ADD      R0,R5,#+8
   \   00000034   ........           _BLF     OS_CreateTimer,??OS_CreateTimer??rA
   \   00000038   080085E2           ADD      R0,R5,#+8
   \   0000003C   ........           _BLF     OS_StartTimer,??OS_StartTimer??rA
   \   00000040   0300A0E3           MOV      R0,#+3
   \   00000044   ........           _BLF     Timer_Start,??Timer_Start??rA
   \   00000048   6470A0E3           MOV      R7,#+100
   \   0000004C   040000EA           B        ??WatchDogTask_3
    199              while (true) {
    200                  char Status = OS_WaitEventTimed(WD_ANY_SIGNAL, WATCHDOG_TASK_DELAY);
    201                  switch (Status) {
    202                  case WD_SYSTEM_KILL   :
    203                      ProgProgress = WD_POWER_ON;
   \                     ??WatchDogTask_4:
   \   00000050   00A08BE5           STR      R10,[R11, #+0]
    204                      OS_Use(&FlashSema);  // Be sure to prevent any writing to flash
   \                     ??WatchDogTask_5:
   \   00000054   0600A0E1           MOV      R0,R6
   \   00000058   ........           _BLF     OS_Use,??OS_Use??rA
    205                      OS_StopTimer(&WatchdogTimeOutTimer);
   \   0000005C   080085E2           ADD      R0,R5,#+8
   \   00000060   ........           _BLF     OS_StopTimer,??OS_StopTimer??rA
   \                     ??WatchDogTask_3:
   \   00000064   FA1FA0E3           MOV      R1,#+1000
   \   00000068   3F00A0E3           MOV      R0,#+63
   \   0000006C   ........           _BLF     OS_WaitEventTimed,??OS_WaitEventTimed??rA
   \   00000070   200050E3           CMP      R0,#+32
   \   00000074   FAFFFF8A           BHI      ??WatchDogTask_3
   \   00000078   011F8FE2           ADR      R1,??WatchDogTask_1
   \   0000007C   D01091E1           LDRSB    R1,[R1, R0]
   \   00000080   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??WatchDogTask_1:
   \   00000084   1308F2F7           DC8      +19,+8,+242,+247
   \   00000088   21F7F7F7           DC8      +33,+247,+247,+247
   \   0000008C   2AF7F7F7           DC8      +42,+247,+247,+247
   \   00000090   F7F7F7F7           DC8      +247,+247,+247,+247
   \   00000094   3CF7F7F7           DC8      +60,+247,+247,+247
   \   00000098   F7F7F7F7           DC8      +247,+247,+247,+247
   \   0000009C   F7F7F7F7           DC8      +247,+247,+247,+247
   \   000000A0   F7F7F7F7           DC8      +247,+247,+247,+247
   \   000000A4   36000000           DC8      +54,+0,+0,+0
    206                      break;
    207                  case WD_SYSTEM_RUNNING:
    208                      ProgProgress = WD_START_OK;
   \                     ??WatchDogTask_6:
   \   000000A8   2100A0E3           MOV      R0,#+33
   \   000000AC   00008BE5           STR      R0,[R11, #+0]
    209                      KickTheDog   = 100; // EHSMark was 50
   \   000000B0   007085E5           STR      R7,[R5, #+0]
    210                      AllRunning   = true;
   \   000000B4   0180A0E3           MOV      R8,#+1
    211                      StartTime    = time(NULL);
   \   000000B8   0000A0E3           MOV      R0,#+0
   \   000000BC   ........           _BLF     time,??time??rA
   \   000000C0   0040A0E1           MOV      R4,R0
    212                      OS_SetPriority(&WatchDogTaskHandle, WATCHDOG_TASK_PRIORITY);
   \   000000C4   0510A0E3           MOV      R1,#+5
   \   000000C8   1C0085E2           ADD      R0,R5,#+28
   \   000000CC   ........           _BLF     OS_SetPriority,??OS_SetPriority??rA
   \   000000D0   E3FFFFEA           B        ??WatchDogTask_3
    213                      // Do something
    214                      break;
    215                  case WD_NO_SIGNAL:
    216                      if (!AllRunning && (difftime(time(NULL), StartTime) > 60.0)) {
   \                     ??WatchDogTask_7:
   \   000000D4   000058E3           CMP      R8,#+0
   \   000000D8   0900001A           BNE      ??WatchDogTask_8
   \   000000DC   0000A0E3           MOV      R0,#+0
   \   000000E0   ........           _BLF     time,??time??rA
   \   000000E4   0410A0E1           MOV      R1,R4
   \   000000E8   ........           _BLF     difftime,??difftime??rA
   \   000000EC   0120A0E3           MOV      R2,#+1
   \   000000F0   4034A0E3           MOV      R3,#+1073741824
   \   000000F4   4E3883E3           ORR      R3,R3,#0x4E0000
   \   000000F8   ........           _BLF     __dGreaterEqual,??__dGreaterEqual??rA
   \   000000FC   000050E3           CMP      R0,#+0
   \   00000100   D3FFFF1A           BNE      ??WatchDogTask_5
    217                          OS_Use(&FlashSema);  // Be sure to prevent any writing to flash
    218                          OS_StopTimer(&WatchdogTimeOutTimer);
    219                      } else {
    220                          KickTheDog = 100; // EHSMark was 50
   \                     ??WatchDogTask_8:
   \   00000104   007085E5           STR      R7,[R5, #+0]
   \   00000108   D5FFFFEA           B        ??WatchDogTask_3
    221                      }
    222                      break;
    223                  case WD_STOP:
    224                      ProgProgress = WD_STOP;
   \                     ??WatchDogTask_9:
   \   0000010C   0400A0E3           MOV      R0,#+4
   \   00000110   00008BE5           STR      R0,[R11, #+0]
    225                      KickTheDog = 100;
   \   00000114   007085E5           STR      R7,[R5, #+0]
    226                      OS_DeleteTimer(&WatchdogTimeOutTimer);
   \   00000118   080085E2           ADD      R0,R5,#+8
   \   0000011C   ........           _BLF     OS_DeleteTimer,??OS_DeleteTimer??rA
    227                      rWTCON  = 0x00008000;           // Disable the watchdog
   \   00000120   5304A0E3           MOV      R0,#+1392508928
   \   00000124   801CA0E3           MOV      R1,#+32768
   \   00000128   001080E5           STR      R1,[R0, #+0]
   \   0000012C   CCFFFFEA           B        ??WatchDogTask_3
    228                      break;
    229                  case WD_START:
    230                      ProgProgress = WD_START;
   \                     ??WatchDogTask_10:
   \   00000130   0800A0E3           MOV      R0,#+8
   \   00000134   00008BE5           STR      R0,[R11, #+0]
    231                      KickTheDog = 100;
   \   00000138   007085E5           STR      R7,[R5, #+0]
    232                      Timer_Start(3);
   \   0000013C   0300A0E3           MOV      R0,#+3
   \   00000140   ........           _BLF     Timer_Start,??Timer_Start??rA
    233                      OS_CREATETIMER(&WatchdogTimeOutTimer, WatchdogTimeOutHandler, WATCHDOG_RELOAD_DELAY);
   \   00000144   6420A0E3           MOV      R2,#+100
   \   00000148   0910A0E1           MOV      R1,R9
   \   0000014C   080085E2           ADD      R0,R5,#+8
   \   00000150   ........           _BLF     OS_CreateTimer,??OS_CreateTimer??rA
   \   00000154   080085E2           ADD      R0,R5,#+8
   \   00000158   ........           _BLF     OS_StartTimer,??OS_StartTimer??rA
   \   0000015C   C0FFFFEA           B        ??WatchDogTask_3
    234                      break;
    235                  case WD_FACTORY_DEFAULT:
    236                      ProgProgress = WD_ERASE_FLASH;
   \                     ??WatchDogTask_11:
   \   00000160   2200A0E3           MOV      R0,#+34
   \   00000164   00008BE5           STR      R0,[R11, #+0]
    237                      KickTheDog = 200;
   \   00000168   C800A0E3           MOV      R0,#+200
   \   0000016C   000085E5           STR      R0,[R5, #+0]
    238                      EraseFlash(FLASH_ERASE_ALL_APP_DATA);
   \   00000170   0700A0E3           MOV      R0,#+7
   \   00000174   ........           _BLF     ??EraseFlash,??EraseFlash??rA
    239          #ifdef ANBOOTLOADER
    240                      break;
    241          #endif
    242                  case WD_RESTART:
    243                      ProgProgress = WD_START_AGAIN;
   \                     ??WatchDogTask_12:
   \   00000178   2000A0E3           MOV      R0,#+32
   \   0000017C   00008BE5           STR      R0,[R11, #+0]
    244                      OS_Delay(5000);
   \   00000180   8800A0E3           MOV      R0,#+136
   \   00000184   4C0D80E3           ORR      R0,R0,#0x1300
   \   00000188   ........           _BLF     OS_Delay,??OS_Delay??rA
    245                      OS_Use(&FlashSema);  // Be sure to prevent any writing to flash
   \   0000018C   0600A0E1           MOV      R0,R6
   \   00000190   ........           _BLF     OS_Use,??OS_Use??rA
    246                      OS_StopTimer(&WatchdogTimeOutTimer);
   \   00000194   080085E2           ADD      R0,R5,#+8
   \   00000198   ........           _BLF     OS_StopTimer,??OS_StopTimer??rA
    247                      Timer_Start(0);
   \   0000019C   0000A0E3           MOV      R0,#+0
   \   000001A0   ........           _BLF     Timer_Start,??Timer_Start??rA
   \   000001A4   AEFFFFEA           B        ??WatchDogTask_3
   \                     ??WatchDogTask_2:
   \   000001A8   ........           DC32     ??WatchdogTimeOutHandler
    248                      break;
    249                  default:
    250                      break;
    251                  }
    252          
    253                  /*
    254          #ifdef OS_PROFILE
    255                  OS_TASK    *TaskPtr=OS_pTask;                           // linked list of all Tasks
    256                  while ( TaskPtr ) {
    257                      OS_TASK    *LocTaskPtr=TaskPtr;                         // linked list of all Tasks
    258                      if ( LocTaskPtr->NumActivations ) {
    259          
    260                      }
    261                      TaskPtr = TaskPtr->pNext;
    262                  }
    263          #endif
    264          */
    265              }
    266          
    267          }

   \                                 In segment DATA_I, align 4, align-sorted
   \                     TouchScreenTimeOut:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for TouchScreenTimeOut>`
   \   00000004                      DS8 1
   \   00000005                      REQUIRE `?<Initializer for IgnoreTouchEvents>`

   \                                 In segment DATA_I, align 8, align-sorted
   \                     KickTheDog:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for KickTheDog>`
    268          #endif
    269          
    270          
    271          /////////////////////////////////////////////////////////
    272          //
    273          // From TXU_TROSINIT.c
    274          //
    275          /////////////////////////////////////////////////////////
    276          
    277          TSN_STACKPTR int TouchKeyStack[128];
    278          extern "C"
    279          {
    280          TSN_TASK *ReadTouchKey = NULL;                             /* Task control blocks */
   \                     ReadTouchKey:
   \   00000004                      DS8 4
   \   00000008                      REQUIRE `?<Initializer for ReadTouchKey>`
   \                     WatchdogTimeOutTimer:
   \   00000008                      DS8 20
   \   0000001C                      REQUIRE `?<Initializer for WatchdogTimeOutTimer>`
   \                     WatchDogTaskHandle:
   \   0000001C                      DS8 64
   \   0000005C                      REQUIRE `?<Initializer for WatchDogTaskHandle>`
   \                     TouchKeyStack:
   \   0000005C                      DS8 512
   \   0000025C                      REQUIRE `?<Initializer for TouchKeyStack>`
   \   0000025C                      DS8 4
   \                     WatchDogTaskStack:
   \   00000260                      DS8 512
   \   00000460                      REQUIRE `?<Initializer for WatchDogTaskStack>`
    281          extern volatile unsigned char TouchKeyPressed;  //key status
    282          
    283          }
    284          
    285          extern int LCDXSize;
    286          OS_RSEMA    ADConSema;
    287          
    288          OS_TIMER TouchTimeOutTimer;
    289          bool BackLightIsOn = false;
    290          static bool IgnoreTouchEvents = false;
    291          

   \                                 In segment CODE, align 4, keep-with-next
    292          void TouchTimeOutTimerHandler(void) {
    293              TouchKeyPressed = 0;   //key up
   \                     ??TouchTimeOutTimerHandler:
   \   00000000   ........           LDR      R0,??DataTable6  ;; TouchKeyPressed
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0010C0E5           STRB     R1,[R0, #+0]
    294          }
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    295          
    296          int  KeyPressedSequence = 0;
    297          bool SecondKeyPressed = false;
    298          TSN_TASK StartTCB;
    299          bool ShallContinoueInBootLoader = false;
    300          

   \                                 In segment CODE, align 4, keep-with-next
    301          void TouchExec(char KeyPressed) {
    302              if (IgnoreTouchEvents) {
   \                     ??TouchExec:
   \   00000000   38109FE5           LDR      R1,??TouchExec_1  ;; TouchScreenTimeOut
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   0420D1E5           LDRB     R2,[R1, #+4]
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   0400000A           BEQ      ??TouchExec_2
    303                  if (KeyPressed) {
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0600000A           BEQ      ??TouchExec_3
    304                      IgnoreTouchEvents = false;
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   0400C1E5           STRB     R0,[R1, #+4]
   \   00000024   030000EA           B        ??TouchExec_3
    305                  }
    306              } else {
    307                  TouchKeyPressed = KeyPressed;
   \                     ??TouchExec_2:
   \   00000028   ........           LDR      R1,??DataTable6  ;; TouchKeyPressed
   \   0000002C   0000C1E5           STRB     R0,[R1, #+0]
    308                  SendAlarmSilence();
   \   00000030   ........           _BLF     ??SendAlarmSilence,??SendAlarmSilence??rA
    309                  GUI_TOUCH_Exec();
   \   00000034   ........           _BLF     GUI_TOUCH_Exec,??GUI_TOUCH_Exec??rA
    310              }
    311          
    312          #ifdef ANBOOTLOADER
    313              if (!ShallContinoueInBootLoader) {
    314                  GUI_PID_STATE pState;
    315                  int HasState = GUI_TOUCH_GetState(&pState);
    316                  /*
    317                  char Buf[80];
    318                  sprintf(Buf,"HasState:%i. X=%i. Sequence=%i",HasState,pState.x,KeyPressedSequence);
    319                  GUI_DispStringAtCEOL(Buf,1,200);
    320                  OS_Delay(2000);
    321                  */
    322                  if (HasState) {
    323                      switch (KeyPressedSequence) {
    324                      case 0:
    325                          if (pState.x < LCDXSize / 2) {
    326                              KeyPressedSequence = 1;
    327                          }
    328                          break;
    329                      case 1:
    330                          if (pState.x > LCDXSize / 2) {
    331                              KeyPressedSequence = 2;
    332                              OS_SignalEvent(BOOTLOADER_NO_START, &StartTCB);
    333                              ShallContinoueInBootLoader = true;
    334                          }
    335                          break;
    336          
    337                      }
    338                  }
    339              }
    340          #endif
    341          }
   \                     ??TouchExec_3:
   \   00000038   0040BDE8           POP      {LR}
   \   0000003C   1EFF2FE1           BX       LR               ;; return
   \                     ??TouchExec_1:
   \   00000040   ........           DC32     TouchScreenTimeOut
    342          // Screen saver
    343          // From PROSystemData

   \                                 In segment CODE, align 4, keep-with-next
    344          void ReadTouchKeyTask(void) {
   \                     ??ReadTouchKeyTask:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   74409FE5           LDR      R4,??ReadTouchKeyTask_1  ;; TouchScreenTimeOut
   \   00000008   0050A0E3           MOV      R5,#+0
   \   0000000C   050000EA           B        ??ReadTouchKeyTask_2
    345              while (1) {
    346                  char Status = OS_WaitSingleEventTimed(TOUCH_SCREEN_UP | TOUCH_SCREEN_DOWN, TouchScreenTimeOut);
    347                  if (Status) {
    348                      LCD_BackLightOn();
    349                      switch (Status) {
    350                      case TOUCH_SCREEN_DOWN_UP:
    351                          // Should not get here with WaitSingleEvent
    352                          TouchExec(0);   // Key down
    353                          TouchExec(1);   // Key up
    354                          break;
    355                      case TOUCH_SCREEN_UP:
    356                          TouchExec(0);   // Key up
    357                          TouchKeyPressed = 0;   //key up
    358                          break;
    359                      case TOUCH_SCREEN_DOWN:
    360                          TouchExec(1);   // Key down
    361                          break;
    362                      }
    363                  } else {
    364                      IgnoreTouchEvents = true;
   \                     ??ReadTouchKeyTask_3:
   \   00000010   0100A0E3           MOV      R0,#+1
   \   00000014   0400C4E5           STRB     R0,[R4, #+4]
    365                      LCD_BackLightOff();
   \   00000018   ........           _BLF     ??LCD_BackLightOff,??LCD_BackLightOff??rA
    366          #ifdef S2TXU
    367                      PinUnlock = false;
   \   0000001C   60009FE5           LDR      R0,??ReadTouchKeyTask_1+0x4  ;; PinUnlock
   \   00000020   0010A0E3           MOV      R1,#+0
   \   00000024   0010C0E5           STRB     R1,[R0, #+0]
    368          #endif
    369                  }
   \                     ??ReadTouchKeyTask_2:
   \   00000028   001094E5           LDR      R1,[R4, #+0]
   \   0000002C   0300A0E3           MOV      R0,#+3
   \   00000030   ........           _BLF     OS_WaitSingleEventTimed,??OS_WaitSingleEventTimed??rA
   \   00000034   0060B0E1           MOVS     R6,R0
   \   00000038   F4FFFF0A           BEQ      ??ReadTouchKeyTask_3
   \   0000003C   ........           _BLF     ??LCD_BackLightOn,??LCD_BackLightOn??rA
   \   00000040   016056E2           SUBS     R6,R6,#+1
   \   00000044   0800000A           BEQ      ??ReadTouchKeyTask_4
   \   00000048   016056E2           SUBS     R6,R6,#+1
   \   0000004C   0300000A           BEQ      ??ReadTouchKeyTask_5
   \   00000050   016056E2           SUBS     R6,R6,#+1
   \   00000054   F3FFFF1A           BNE      ??ReadTouchKeyTask_2
   \   00000058   0000A0E3           MOV      R0,#+0
   \   0000005C   ........           BL       ??TouchExec
   \                     ??ReadTouchKeyTask_5:
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   ........           BL       ??TouchExec
   \   00000068   EEFFFFEA           B        ??ReadTouchKeyTask_2
   \                     ??ReadTouchKeyTask_4:
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   ........           BL       ??TouchExec
   \   00000074   ........           LDR      R0,??DataTable6  ;; TouchKeyPressed
   \   00000078   0050C0E5           STRB     R5,[R0, #+0]
   \   0000007C   E9FFFFEA           B        ??ReadTouchKeyTask_2
   \                     ??ReadTouchKeyTask_1:
   \   00000080   ........           DC32     TouchScreenTimeOut
   \   00000084   ........           DC32     PinUnlock
    370              }
    371          }

   \                                 In segment DATA_Z, align 4, align-sorted
    372          
    373          
    374          #ifdef ANBOOTLOADER
    375          //////////////////////////////////////////////////////////////
    376          // This is for the Bootloader.
    377          //
    378          //
    379          ////////////////////////////////////////////////////////////////
    380          
    381          void ConfigUartsTXU(void) {
    382              for (int i = 0; i < MAX_COM_PORTS; i++) {
    383                  TSNUart::Channels[i] = NULL;
    384              }
    385              int UartCfg = OS_UART;
    386              switch (UartCfg) { // port is reserved for debugging
    387              case -1:
    388                  switch (GlobalDeviceHWId) {
    389                  case TDU_R1:
    390                  case TDU_R2:
    391                      new SC2410Uart(0, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_232, C_UART_SWPRO_ANPRO10, false);
    392                      new SC2410Uart(1, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_232, C_UART_SWPRO_ANPRO10, false);
    393                      new SC2410Uart(2, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_485, C_UART_SWPRO_ANPRO10, false);
    394                      break;
    395                  case TCU_R1:
    396                  case TCU_R2:
    397                      new SC2410Uart(0, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_232, C_UART_SWPRO_ANPRO10, false);
    398                      new SC2410Uart(1, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_232, C_UART_SWPRO_ANPRO10, false);
    399                      new SC2410Uart(2, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_232, C_UART_SWPRO_ANPRO10, false);
    400                      break;
    401                  }
    402                  break;
    403              case 0:
    404                  new SC2410Uart(1, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_232, C_UART_SWPRO_ANPRO10, false);
    405                  new SC2410Uart(2, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_485, C_UART_SWPRO_ANPRO10, false);
    406                  break;
    407              case 1:
    408                  new SC2410Uart(0, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_232, C_UART_SWPRO_ANPRO10, false);
    409                  new SC2410Uart(2, DEFAULT_BOOT_BAUDRATE, 8, 1, 'N', 32 * 1024, C_UART_DEVICE_TCU, C_UART_HWPRO_485, C_UART_SWPRO_ANPRO10, false);
    410                  break;
    411              }
    412          
    413          }
    414          #pragma data_alignment=8
    415          static TSN_STACKPTR U8 DisplayTimeTaskStack[2*1024];
    416          TSN_TASK DisplayTimeTaskHandle;
    417          void DisplayTime(void) {
    418              int Cnt = BOOTLOADER_DELAY / 1000;
    419              do {
    420                  char Buf[BUF_SIZE];
    421                  sprintf(Buf, "Start program in : %i", Cnt--);
    422                  GUI_SetColor(GUI_BLACK);
    423                  GUI_SetBkColor(GUI_LIGHTGRAY);
    424                  GUI_SetFont(&GUI_Font16B_ASCII);
    425                  GUI_DispStringAtCEOL(Buf, 1, 170);
    426                  OS_Delay(1000);
    427              }
    428              while (true);
    429          }
    430          void CheckStartMainProg(void) {
    431              switch (GlobalDeviceHWId) {
    432              case TDU_R1:
    433              case TDU_R2:
    434                  {
    435                      LCD_Init_Controller();      // Set up LCD controller
    436                      LCD_BackLightOn();
    437                      InitTDUGUI();
    438                      CREATE_TASK(&DisplayTimeTaskHandle, "Countdown",     DisplayTime,    180, DisplayTimeTaskStack);
    439          
    440                      ReadTouchKey = new TSN_TASK();
    441                      OS_CREATETASK(ReadTouchKey, "ReadTouchKey", ReadTouchKeyTask, 150, TouchKeyStack);
    442                      char Status = OS_WaitEventTimed(BOOTLOADER_NO_START, BOOTLOADER_DELAY);
    443                      OS_Terminate(&DisplayTimeTaskHandle);
    444                      GUI_ClearRect(1, 160, 300, 190);
    445                      switch (Status) {
    446                      case BOOTLOADER_START_APP:
    447                          StartMainProgram();
    448                          GUI_DispStringAtCEOL("No program or configuration found!", 1, 170);
    449                          break;
    450                      case BOOTLOADER_NO_START:
    451                          break;
    452                      }
    453                  }
    454                  break;
    455              case TCU_R1:
    456              case TCU_R2:
    457                  StartMainProgram();
    458                  break;
    459              }
    460          }
    461          
    462          
    463          
    464          
    465          #else
    466          /*
    467          void ConfigUartsTXU(void)
    468          {
    469              for ( int i = 0; i < MAX_COM_PORTS; i++ ) {
    470                  TSNUart::Channels[i] = NULL;
    471              }
    472          
    473              switch ( OS_UART ) { // port is reserved for debugging
    474                  case 0:
    475                      new SC2410Uart(1,DEFAULT_BOOT_BAUDRATE,8,1,'N',32*1024);
    476                      TSNUart::Channels[1]->Device = C_UART_DEVICE_TCU;
    477                      break;
    478                  case 1:
    479                      new SC2410Uart(0,DEFAULT_BOOT_BAUDRATE,8,1,'N',32*1024);
    480                      TSNUart::Channels[0]->Device = C_UART_DEVICE_TCU;
    481                      break;
    482              }
    483          }
    484          */
    485          #endif
    486          
    487          
    488          
    489          #ifndef ANBOOTLOADER
    490          OS_STACKPTR char *StartTxuTaskStack= NULL;
   \                     StartTxuTaskStack:
   \   00000000                      DS8 4
   \                     IncMailBox:
   \   00000004                      DS8 24
   \                     GPEPortSema:
   \   0000001C                      DS8 16
    491          OS_TASK tStartTxuTask;
   \                     tStartTxuTask:
   \   0000002C                      DS8 64

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     ADConSema:
   \   00000000                      DS8 16

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     TouchTimeOutTimer:
   \   00000000                      DS8 20

   \                                 In segment DATA_Z, align 1, align-sorted
   \                     BackLightIsOn:
   \   00000000                      DS8 1

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     KeyPressedSequence:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 1, align-sorted
   \                     SecondKeyPressed:
   \   00000000                      DS8 1

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     StartTCB:
   \   00000000                      DS8 64

   \                                 In segment DATA_Z, align 1, align-sorted
   \                     ShallContinoueInBootLoader:
   \   00000000                      DS8 1
    492          

   \                                 In segment CODE, align 4, keep-with-next
    493          void StartTxuTask(void) {
    494          
    495          #if (WATCHDOG == 1)
    496              CREATE_TASK(&WatchDogTaskHandle, "Watchdog",     WatchDogTask,    180, WatchDogTaskStack);
   \                     ??StartTxuTask:
   \   00000000   68319FE5           LDR      R3,??StartTxuTask_1  ;; ??WatchDogTask
   \   00000004   F0432DE9           PUSH     {R4-R9,LR}
   \   00000008   64419FE5           LDR      R4,??StartTxuTask_1+0x4  ;; `?<Constant "Watchdog">`
   \   0000000C   64519FE5           LDR      R5,??StartTxuTask_1+0x8  ;; KickTheDog
   \   00000010   0200A0E3           MOV      R0,#+2
   \   00000014   01002DE9           PUSH     {R0}
   \   00000018   800FA0E3           MOV      R0,#+512
   \   0000001C   01002DE9           PUSH     {R0}
   \   00000020   980F85E2           ADD      R0,R5,#+608
   \   00000024   01002DE9           PUSH     {R0}
   \   00000028   B420A0E3           MOV      R2,#+180
   \   0000002C   0410A0E1           MOV      R1,R4
    497          #endif
    498              SetFlashSectorTable();
    499          
    500              StartRelayTasks();
    501          	#if (USE_EMBOS_MEM_POOL==1) 
    502              {
    503                  void *tmpPtr = malloc(10*(MAX_ANPRO10_IO_SIZE+OS_MEMF_SIZEOF_BLOCKCONTROL));
    504                  OS_MEMF_Create(&pANPRO10IOMemPool,tmpPtr,10,MAX_ANPRO10_IO_SIZE);
    505              }
    506              #endif
    507              if (lzo_init() != LZO_E_OK) {
    508                  //MsgStr("lzo_init() failed !!!");
    509              }
    510          
    511              switch (CurrentDeviceId) {
   \   00000030   ........           LDR      R7,??DataTable8  ;; 0x31fff014
   \   00000034   1C0085E2           ADD      R0,R5,#+28
   \   00000038   ........           _BLF     OS_CreateTask_SP,??OS_CreateTask_SP??rA
   \   0000003C   ........           _BLF     ??SetFlashSectorTable,??SetFlashSectorTable??rA
   \   00000040   ........           _BLF     ??StartRelayTasks,??StartRelayTasks??rA
   \   00000044   1800A0E3           MOV      R0,#+24
   \   00000048   01002DE9           PUSH     {R0}
   \   0000004C   0400A0E3           MOV      R0,#+4
   \   00000050   01002DE9           PUSH     {R0}
   \   00000054   01002DE9           PUSH     {R0}
   \   00000058   01002DE9           PUSH     {R0}
   \   0000005C   01002DE9           PUSH     {R0}
   \   00000060   01002DE9           PUSH     {R0}
   \   00000064   0430A0E3           MOV      R3,#+4
   \   00000068   0020A0E1           MOV      R2,R0
   \   0000006C   0210A0E3           MOV      R1,#+2
   \   00000070   A000A0E3           MOV      R0,#+160
   \   00000074   800D80E3           ORR      R0,R0,#0x2000
   \   00000078   ........           _BLF     __lzo_init_v2,??__lzo_init_v2??rA
   \   0000007C   F8009FE5           LDR      R0,??StartTxuTask_1+0xC  ;; CurrentDeviceId
   \   00000080   24D08DE2           ADD      SP,SP,#+36
   \   00000084   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000088   1460A0E3           MOV      R6,#+20
   \   0000008C   1380A0E3           MOV      R8,#+19
   \   00000090   200050E2           SUBS     R0,R0,#+32
   \   00000094   0200000A           BEQ      ??StartTxuTask_2
   \   00000098   100050E2           SUBS     R0,R0,#+16
   \   0000009C   0600000A           BEQ      ??StartTxuTask_3
   \   000000A0   230000EA           B        ??StartTxuTask_4
    512              case DEVICE_TCU:    // TCU
    513                  ProgProgress = WD_READ_CONFIG;
   \                     ??StartTxuTask_2:
   \   000000A4   008087E5           STR      R8,[R7, #+0]
    514                  ReadConfig("ConfigFile.txt");
   \   000000A8   1C0084E2           ADD      R0,R4,#+28
   \   000000AC   ........           _BLF     ??ReadConfig,??ReadConfig??rA
    515                  ProgProgress = WD_START_TASKS;
   \   000000B0   006087E5           STR      R6,[R7, #+0]
    516                  StartTasks();
   \   000000B4   ........           _BLF     ??StartTasks,??StartTasks??rA
   \   000000B8   1D0000EA           B        ??StartTxuTask_4
    517                  break;
    518              case DEVICE_TDU:    // TDU
    519                  ReadTouchKey = new TSN_TASK();
   \                     ??StartTxuTask_3:
   \   000000BC   4000A0E3           MOV      R0,#+64
   \   000000C0   ........           _BLF     `??operator new`,`??operator new??rA`
   \   000000C4   0090B0E1           MOVS     R9,R0
   \   000000C8   0100000A           BEQ      ??StartTxuTask_5
   \   000000CC   4010A0E3           MOV      R1,#+64
   \   000000D0   ........           _BLF     __data_memzero,??__data_memzero??rA
    520                  OS_CREATETASK(ReadTouchKey, "ReadTouchKey", ReadTouchKeyTask, 190, TouchKeyStack);
   \                     ??StartTxuTask_5:
   \   000000D4   A4309FE5           LDR      R3,??StartTxuTask_1+0x10  ;; ??ReadTouchKeyTask
   \   000000D8   049085E5           STR      R9,[R5, #+4]
   \   000000DC   0200A0E3           MOV      R0,#+2
   \   000000E0   01002DE9           PUSH     {R0}
   \   000000E4   800FA0E3           MOV      R0,#+512
   \   000000E8   01002DE9           PUSH     {R0}
   \   000000EC   5C0085E2           ADD      R0,R5,#+92
   \   000000F0   01002DE9           PUSH     {R0}
   \   000000F4   BE20A0E3           MOV      R2,#+190
   \   000000F8   0C1084E2           ADD      R1,R4,#+12
   \   000000FC   0900A0E1           MOV      R0,R9
   \   00000100   ........           _BLF     OS_CreateTask_SP,??OS_CreateTask_SP??rA
    521                  LCD_Init_Controller();      // Set up LCD controller
   \   00000104   ........           _BLF     ??LCD_Init_Controller,??LCD_Init_Controller??rA
    522                  LCD_BackLightOn();
   \   00000108   ........           _BLF     ??LCD_BackLightOn,??LCD_BackLightOn??rA
    523                  TDUStartupInit();
   \   0000010C   ........           _BLF     ??TDUStartupInit,??TDUStartupInit??rA
    524                  ProgProgress = WD_READ_CONFIG;
   \   00000110   008087E5           STR      R8,[R7, #+0]
    525                  ReadConfig("ConfigFile.txt");
   \   00000114   1C0084E2           ADD      R0,R4,#+28
   \   00000118   ........           _BLF     ??ReadConfig,??ReadConfig??rA
    526                  ProgProgress = WD_START_EMWIN;
   \   0000011C   1200A0E3           MOV      R0,#+18
   \   00000120   000087E5           STR      R0,[R7, #+0]
    527                  StartWindowSystem();
   \   00000124   ........           _BLF     ??StartWindowSystem,??StartWindowSystem??rA
    528                  ProgProgress = WD_START_TASKS;
   \   00000128   006087E5           STR      R6,[R7, #+0]
    529                  StartTasks();
   \   0000012C   ........           _BLF     ??StartTasks,??StartTasks??rA
   \   00000130   0CD08DE2           ADD      SP,SP,#+12
    530                  break;
    531              }
    532          #if (WATCHDOG == 1)
    533              OS_SignalEvent(WD_SYSTEM_RUNNING, &WatchDogTaskHandle);
   \                     ??StartTxuTask_4:
   \   00000134   1C1085E2           ADD      R1,R5,#+28
   \   00000138   0100A0E3           MOV      R0,#+1
   \   0000013C   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
    534          #endif
    535              if (ConfigWarningsString.IsEmpty()) {
   \   00000140   3C009FE5           LDR      R0,??StartTxuTask_1+0x14  ;; ConfigWarningsString
   \   00000144   ........           _BLF     ??IsEmpty,??IsEmpty??rA
   \   00000148   000050E3           CMP      R0,#+0
   \   0000014C   0300000A           BEQ      ??StartTxuTask_6
    536                  rGPBDAT &= ~1;  // System OK
   \   00000150   560486E3           ORR      R0,R6,#0x56000000
   \   00000154   001090E5           LDR      R1,[R0, #+0]
   \   00000158   0110C1E3           BIC      R1,R1,#0x1
   \   0000015C   001080E5           STR      R1,[R0, #+0]
    537              }
    538          
    539              while (true) {
    540                  OS_Delay(100000);
   \                     ??StartTxuTask_6:
   \   00000160   600BA0E3           MOV      R0,#+98304
   \   00000164   6A0E80E3           ORR      R0,R0,#0x6A0
   \   00000168   ........           _BLF     OS_Delay,??OS_Delay??rA
   \   0000016C   FBFFFFEA           B        ??StartTxuTask_6
   \                     ??StartTxuTask_1:
   \   00000170   ........           DC32     ??WatchDogTask
   \   00000174   ........           DC32     `?<Constant "Watchdog">`
   \   00000178   ........           DC32     KickTheDog
   \   0000017C   ........           DC32     CurrentDeviceId
   \   00000180   ........           DC32     ??ReadTouchKeyTask
   \   00000184   ........           DC32     ConfigWarningsString
    541              }
    542          
    543          }
    544          
    545          #endif
    546          
    547          /**********************************************************
    548          *
    549          *       main
    550          *
    551          **********************************************************/
    552          
    553          #ifdef ANBOOTLOADER
    554          
    555          #pragma data_alignment=8
    556          static TSN_STACKPTR int ReceiveStack[ASYNC_RECEIVER_TASKS][1*1024];
    557          static TSN_STACKPTR U8 StartBootTaskStack[2*4096];
    558          TSN_TASK ReceiverTCB[3];                                                         /* Task control blocks */
    559          void StartBootTasks(void) {
    560          #if (WATCHDOG == 1)
    561              CREATE_TASK(&WatchDogTaskHandle, "Watchdog",     WatchDogTask,    180, WatchDogTaskStack);      //Alarm button blink
    562          #endif
    563              memcpy(&BootVersion, &MyProgramVersion, sizeof(ProgramVersionInfo));
    564              SetFlashSectorTable();
    565              if (CurrentDeviceAddress != 0xf) {
    566                  if (rGSTATUS2 & GSTAT_PWRST) {
    567                      rGSTATUS2        |= GSTAT_PWRST;
    568                      LastOSError       = 0;
    569                      LastErrAddress    = 0;
    570                      ProgProgress      = WD_POWER_ON;
    571                      FlashErrorStatus  = WD_SETTINGS_OK;
    572                      strcpy(LastOSErrorTask, "Power On");
    573                      LastStartTime     = time(NULL);
    574                      RestartRetryCnt   = 0;
    575                      IsPowerOn         = true;
    576                      CheckStartMainProg();
    577                  } else {
    578                      IsPowerOn         = false;
    579                      StartMainProgram(); // Can not use  rGSTATUS3
    580                      /*
    581                      switch ( ProgProgress ) {
    582                          case WD_START_OK: {
    583                                  time_t CurrentTime = time(NULL);
    584                                  float ElapsedTime = difftime(CurrentTime,LastStartTime);
    585                                  LastStartTime = CurrentTime;
    586                                  if ( ElapsedTime > 5*60 || RestartRetryCnt++ < 5 ) {
    587                                      StartMainProgram(); // No need for status. We will not return her if success
    588                                  }
    589                              }
    590                              break;
    591                          case WD_START_AGAIN:
    592                              StartMainProgram(); // No need for status. We will not return her if success
    593                              break;
    594                          default:
    595                              //StartMainProgram();   // No need for status. We will not return her if success
    596                              break;
    597                      }
    598                      */
    599                  }
    600              }
    601          #ifdef TXU_RELEASE
    602              ProgProgress = WD_BOOTLOADER_COPY;
    603              U32 Size = SectorTable[SectorBootEnd] - SectorTable[SectorBootStart];
    604              memcpy((char *)0x30000000, (char *)0x00000000, Size);   // Copy the boot loader to RAM
    605          #endif
    606              ProgProgress = WD_BOOT_MMU_INIT;
    607              MMU_Init(); // Setup the memory management unit.
    608              /*
    609              {
    610                  char *pPool = new char[6*2*MAX_ANPRO10_SIZE];
    611                  OS_MEMF_Create(&pANPRO10MemPool,pPool,6,2*MAX_ANPRO10_SIZE);
    612                  int TestSize = OS_MEMF_GetNumBlocks(&pANPRO10MemPool);
    613              }
    614              */
    615              if (lzo_init() != LZO_E_OK) {
    616                  //MsgStr("lzo_init() failed !!!");
    617              }
    618          
    619              void *tmpPtr = malloc(4 * (UNPACK_BLOCK_SIZE + OS_MEMF_SIZEOF_BLOCKCONTROL));
    620              OS_MEMF_Create(&pUnPackMem, tmpPtr, 4, UNPACK_BLOCK_SIZE);
    621              ProgProgress = WD_BOOT_INIT_COMPORTS;
    622              ConfigUartsTXU();
    623              switch (CurrentDeviceId) {
    624              case DEVICE_TCU:    // TCU
    625                  ProgProgress = WD_BOOT_START_COM_TASKS;
    626                  /* com server tasks */
    627                  OS_CREATETASK(&TCB3, "ComSendTask", TSNAsyncSender::TaskEntryPoint, COM_SEND_TASK_PRIORITY, Stack3);
    628                  OS_Delay(1000);
    629                  // create recive tasks
    630                  for (int i = 0; i < ASYNC_RECEIVER_TASKS; i++) {
    631                      const char *TaskName[ASYNC_RECEIVER_TASKS] = {
    632                          "ReceiveTask1",
    633                          "ReceiveTask2",
    634                          "ReceiveTask3",
    635                      };
    636                      if (TSNUart::Channels[i]) {
    637                          OS_CREATETASK_EX(&ReceiverTCB[i], TaskName[i], TSNAsyncReceiver::EntryPoint, 100, ReceiveStack[i], (void *)i);
    638                      }
    639                  }
    640          
    641                  break;
    642              case DEVICE_TDU:    // TDU
    643                  /*
    644                  ReadTouchKey = new TSN_TASK();
    645                  OS_CREATETASK(ReadTouchKey, "ReadTouchKey", ReadTouchKeyTask, 150, TouchKeyStack);
    646                  LCD_Init_Controller();      // Set up LCD controller
    647                  LCD_BackLightOn();
    648                  InitTDUGUI();
    649                  */
    650                  ProgProgress = WD_BOOT_START_COM_TASKS;
    651                  /* com server tasks */
    652                  OS_CREATETASK(&TCB3, "ComSendTask", TSNAsyncSender::TaskEntryPoint, COM_SEND_TASK_PRIORITY, Stack3);
    653                  OS_Delay(1000);
    654                  for (int i = 0; i < ASYNC_RECEIVER_TASKS; i++) {
    655                      const char *TaskName[ASYNC_RECEIVER_TASKS] = {
    656                          "ReceiveTask1",
    657                          "ReceiveTask2",
    658                          "ReceiveTask3",
    659                      };
    660                      if (TSNUart::Channels[i]) {
    661                          OS_CREATETASK_EX(&ReceiverTCB[i], TaskName[i], TSNAsyncReceiver::EntryPoint, 100, ReceiveStack[i], (void *)i);
    662                      }
    663                  }
    664                  break;
    665              }
    666              switch (CurrentDeviceId) {
    667              case DEVICE_TCU:    // TCU
    668                  break;
    669              case DEVICE_TDU:    // TDU
    670                  GUI_DispStringAtCEOL("Erasing Settings on the TDU", 1, 170);
    671          #if (WATCHDOG == 1)
    672                  OS_SignalEvent(WD_FACTORY_DEFAULT, &WatchDogTaskHandle);
    673          #endif
    674                  GUI_ClearRect(1, 160, 300, 190);
    675                  break;
    676              }
    677              StartUploadTask();
    678          
    679          #if (WATCHDOG == 1)
    680              OS_SignalEvent(WD_SYSTEM_RUNNING, &WatchDogTaskHandle);
    681          #endif
    682              while (true) {
    683                  OS_Delay(10000);
    684              }
    685          }
    686          
    687          int main() {
    688              Port_Init();
    689              SetCpuFrequency();
    690              //MMU_Init(MEMMAP_LOW);
    691              //MMU_DisableDCache();
    692              ProgProgress = WD_BOOT_INIT_KERNEL;
    693              OS_InitKern();              /* initialize OS                 */
    694              OS_INIT_SYS_LOCKS();
    695              OS_InitHW();                    /* initialize Hardware for OS    */
    696              OS_CREATERSEMA(&GPEPortSema);
    697              OS_CREATERSEMA(&RTCSema);
    698              OS_CREATERSEMA(&FlashSema);
    699              OS_CREATERSEMA(&UnpackSema);
    700          #ifndef ANBOOTLOADER
    701              OS_CREATERSEMA(&LanguageSema);
    702              OS_CREATERSEMA(&UnitSema);
    703              OS_CREATERSEMA(&AlarmBasic::AlarmSema);
    704              OS_CreateTimer(&ReceiveFlashTimer, ReceiveFlashTimeOut,30*1000);
    705              OS_CreateTimer(&AlarmSilenceTimer, SetAlarmSoundOn    ,8*60*60*1000);
    706          
    707          #endif
    708              GetRTC();
    709          
    710              LCD_BackLightAdjust(-1); // Adust voltage down 1 step
    711          
    712          
    713              // Check that type of flash is OK and set sector table
    714              CREATE_TASK(&StartTCB, "StartTasks", StartBootTasks, 150, StartBootTaskStack);
    715              ProgProgress = WD_BOOT_START_OS;
    716              OS_Start();         // Start multitasking
    717              return (0);
    718          }
    719          #else

   \                                 In segment DATA_C, align 4, align-sorted
    720          const U8 Patterns[4] = { 0, 0xff, 0xaa, 0x55 };
   \                     Patterns:
   \   00000000   00FFAA55           DC8 0, 255, 170, 85
    721          

   \                                 In segment CODE, align 4, keep-with-next
    722          U8* CheckMem(U8 *StartPtr, U8 *EndPtr) {
   \                     ??CheckMem:
   \   00000000   10002DE9           PUSH     {R4}
    723              bool MemOk = true;
   \   00000004   0120A0E3           MOV      R2,#+1
    724              volatile U8 *MemPtr = StartPtr;
   \   00000008   000000EA           B        ??CheckMem_1
    725              while (MemOk && (MemPtr < EndPtr)) {
    726                  U8 OrgMem = *MemPtr;
    727                  for (U8 i = 0; MemOk && i < 0x4; i++) {
    728                      U8 Pattern =  Patterns[i];
    729                      *MemPtr   = Pattern;
    730                      U8 CurrentMem = *MemPtr;
    731                      if (CurrentMem != Pattern) {
    732                          MemOk = false;
    733                      }
    734                  }
    735                  //*MemPtr = OrgMem;
    736                  if (MemOk) MemPtr++;
   \                     ??CheckMem_2:
   \   0000000C   010080E2           ADD      R0,R0,#+1
   \                     ??CheckMem_1:
   \   00000010   010050E1           CMP      R0,R1
   \   00000014   0F00002A           BCS      ??CheckMem_3
   \   00000018   0030D0E5           LDRB     R3,[R0, #+0]
   \   0000001C   0030A0E3           MOV      R3,#+0
   \                     ??CheckMem_4:
   \   00000020   040053E3           CMP      R3,#+4
   \   00000024   F8FFFF2A           BCS      ??CheckMem_2
   \   00000028   34C09FE5           LDR      R12,??CheckMem_5  ;; Patterns
   \   0000002C   0CC0D3E7           LDRB     R12,[R3, +R12]
   \   00000030   013083E2           ADD      R3,R3,#+1
   \   00000034   FF3003E2           AND      R3,R3,#0xFF
   \   00000038   00C0C0E5           STRB     R12,[R0, #+0]
   \   0000003C   0040D0E5           LDRB     R4,[R0, #+0]
   \   00000040   0C0054E1           CMP      R4,R12
   \   00000044   0020A013           MOVNE    R2,#+0
   \   00000048   000052E3           CMP      R2,#+0
   \   0000004C   F3FFFF1A           BNE      ??CheckMem_4
    737              }
    738              if (MemOk) return (0);
    739              return(U8 *)MemPtr;
   \   00000050   1000BDE8           POP      {R4}
   \   00000054   1EFF2FE1           BX       LR
   \                     ??CheckMem_3:
   \   00000058   1000BDE8           POP      {R4}
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   1EFF2FE1           BX       LR               ;; return
   \                     ??CheckMem_5:
   \   00000064   ........           DC32     Patterns
    740          }
    741          #define STARTTXU_STACK_SIZE (64*1024)
    742          
    743          /*
    744          unsigned short ReadPDataRegister(void)
    745          {
    746              // write a word (16 bits) regOffset to IO port number CS8900_PPTR
    747              U16 *RegPtr = (U16*)(CS8900_PDATA);
    748              return *RegPtr;
    749          }
    750          
    751          unsigned short ReadPPRegister(unsigned short regOffset)
    752          {
    753              // write a word (16 bits) regOffset to IO port number CS8900_PPTR
    754              U16 *RegPtr = (U16*)(CS8900_PPTR);
    755              *RegPtr = regOffset;
    756              U16 *InReg = (U16*)(CS8900_PDATA);
    757              // read a word (16 bits) from IO port number CSstrcpy_s8900_PPTR
    758              return(*InReg);
    759          }
    760          */
    761          
    762          
    763          

   \                                 In segment CODE, align 4, keep-with-next
    764          int main() {
   \                     main:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    765              Port_Init();
    766              SetCpuFrequency();
    767          
    768              ProgProgress = WD_MMU_INIT; /*
   \   00000004   ........           LDR      R4,??DataTable8  ;; 0x31fff014
    769                // Setting up Ethernet to 16 bit by one 16 bit write, forcing nWBE low
    770                U16 *RegPtr = (U16*)(CS8900_BASE);
    771                U16 Test  = *RegPtr;
    772                // Testcode for Ethernet
    773                U16 Dummy    = ReadPPRegister(0x0102);
    774                U16 ChipId1  = ReadPPRegister(0);
    775                U16 ChipId2  = ReadPPRegister(2);
    776                    U16 BaseAddr2= ReadPPRegister(0x20);
    777                    */
    778              // As the Bootloader put date in the incorrect location
    779              // due to the incorrect address lines
    780              //ProgramVersionInfo BootVersionCopy = BootVersion;
    781              MMU_Init();   // Setup the memory management unit.
    782              //BootVersion = BootVersionCopy;
    783          
    784              ProgProgress = WD_INIT_KERNEL;
    785              OS_InitKern();              /* initialize OS                 */
    786              OS_INIT_SYS_LOCKS();
    787              OS_CREATEMB(&IncMailBox, sizeof(IncMessage), ROL_MAX_INCLINOMETER_BUFFERS, malloc(ROL_MAX_INCLINOMETER_BUFFERS * sizeof(IncMessage)));
   \   00000008   04519FE5           LDR      R5,??main_0      ;; StartTxuTaskStack
   \   0000000C   ........           _BLF     Port_Init,??Port_Init??rA
   \   00000010   ........           _BLF     ??SetCpuFrequency,??SetCpuFrequency??rA
   \   00000014   1E00A0E3           MOV      R0,#+30
   \   00000018   000084E5           STR      R0,[R4, #+0]
   \   0000001C   ........           _BLF     MMU_Init,??MMU_Init??rA
   \   00000020   1F00A0E3           MOV      R0,#+31
   \   00000024   000084E5           STR      R0,[R4, #+0]
   \   00000028   ........           _BLF     OS_InitKern,??OS_InitKern??rA
   \   0000002C   ........           _BLF     OS_InitSysLocks,??OS_InitSysLocks??rA
   \   00000030   4000A0E3           MOV      R0,#+64
   \   00000034   ........           _BLF     __data_malloc,??__data_malloc??rA
   \   00000038   0030A0E1           MOV      R3,R0
   \   0000003C   0820A0E3           MOV      R2,#+8
   \   00000040   0810A0E3           MOV      R1,#+8
   \   00000044   040085E2           ADD      R0,R5,#+4
   \   00000048   ........           _BLF     OS_CreateMB,??OS_CreateMB??rA
    788              OS_InitHW();                    /* initialize Hardware for OS    */
   \   0000004C   ........           _BLF     OS_InitHW,??OS_InitHW??rA
    789              OS_CREATERSEMA(&GPEPortSema);
   \   00000050   1C0085E2           ADD      R0,R5,#+28
   \   00000054   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
    790              OS_CREATERSEMA(&RTCSema);
   \   00000058   B8009FE5           LDR      R0,??main_0+0x4  ;; RTCSema
   \   0000005C   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
    791              OS_CREATERSEMA(&FlashSema);
   \   00000060   ........           LDR      R0,??DataTable9  ;; FlashSema
   \   00000064   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
    792              OS_CREATERSEMA(&UnpackSema);
   \   00000068   AC009FE5           LDR      R0,??main_0+0x8  ;; UnpackSema
   \   0000006C   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
    793              OS_CREATERSEMA(&LanguageSema);
   \   00000070   A8009FE5           LDR      R0,??main_0+0xC  ;; LanguageSema
   \   00000074   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
    794              OS_CREATERSEMA(&UnitSema);
   \   00000078   A4009FE5           LDR      R0,??main_0+0x10  ;; UnitSema
   \   0000007C   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
    795              OS_CreateTimer(&ReceiveFlashTimer, ReceiveFlashTimeOut,30*1000);
   \   00000080   A0109FE5           LDR      R1,??main_0+0x14  ;; ??ReceiveFlashTimeOut
   \   00000084   A0009FE5           LDR      R0,??main_0+0x18  ;; ReceiveFlashTimer
   \   00000088   3020A0E3           MOV      R2,#+48
   \   0000008C   752C82E3           ORR      R2,R2,#0x7500
   \   00000090   ........           _BLF     OS_CreateTimer,??OS_CreateTimer??rA
    796              OS_CreateTimer(&AlarmSilenceTimer, SetAlarmSoundOn    ,8*60*60*1000);
   \   00000094   94109FE5           LDR      R1,??main_0+0x1C  ;; ??SetAlarmSoundOn
   \   00000098   94009FE5           LDR      R0,??main_0+0x20  ;; AlarmSilenceTimer
   \   0000009C   6D27A0E3           MOV      R2,#+28573696
   \   000000A0   DD2B82E3           ORR      R2,R2,#0x37400
   \   000000A4   ........           _BLF     OS_CreateTimer,??OS_CreateTimer??rA
    797          
    798          
    799              GetRTC();
   \   000000A8   ........           _BLF     ??GetRTC,??GetRTC??rA
    800              LCD_BackLightAdjust(-1); // Adust voltage down 1 step
   \   000000AC   0000E0E3           MVN      R0,#+0
   \   000000B0   ........           _BLF     ??LCD_BackLightAdjust,??LCD_BackLightAdjust??rA
    801          
    802          
    803          
    804              StartTxuTaskStack = new char[STARTTXU_STACK_SIZE];
   \   000000B4   400BA0E3           MOV      R0,#+65536
   \   000000B8   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   000000BC   000085E5           STR      R0,[R5, #+0]
    805              // Check that type of flash is OK and set sector table
    806              if (MX29LV_CheckId()) {
   \   000000C0   ........           _BLF     ??MX29LV_CheckId,??MX29LV_CheckId??rA
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   0D00000A           BEQ      ??main_1
    807                  OS_CreateTask(&tStartTxuTask, "StartTxu", 10, StartTxuTask, StartTxuTaskStack, STARTTXU_STACK_SIZE CTPARA_TIMESLICE);
   \   000000CC   64309FE5           LDR      R3,??main_0+0x24  ;; ??StartTxuTask
   \   000000D0   64109FE5           LDR      R1,??main_0+0x28  ;; `?<Constant "StartTxu">`
   \   000000D4   0200A0E3           MOV      R0,#+2
   \   000000D8   01002DE9           PUSH     {R0}
   \   000000DC   400BA0E3           MOV      R0,#+65536
   \   000000E0   01002DE9           PUSH     {R0}
   \   000000E4   000095E5           LDR      R0,[R5, #+0]
   \   000000E8   0A20A0E3           MOV      R2,#+10
   \   000000EC   01002DE9           PUSH     {R0}
   \   000000F0   2C0085E2           ADD      R0,R5,#+44
   \   000000F4   ........           _BLF     OS_CreateTask_SP,??OS_CreateTask_SP??rA
    808                  ProgProgress = WD_START_OS;
   \   000000F8   1100A0E3           MOV      R0,#+17
   \   000000FC   000084E5           STR      R0,[R4, #+0]
   \   00000100   0CD08DE2           ADD      SP,SP,#+12
    809              } else {
    810                  // This should never occure!!
    811              }
    812          
    813              OS_Start();     // Start multitasking
   \                     ??main_1:
   \   00000104   ........           _BLF     OS_Start,??OS_Start??rA
    814          
    815              return (0);
   \   00000108   3040BDE8           POP      {R4,R5,LR}
   \   0000010C   0000A0E3           MOV      R0,#+0
   \   00000110   1EFF2FE1           BX       LR               ;; return
   \                     ??main_0:
   \   00000114   ........           DC32     StartTxuTaskStack
   \   00000118   ........           DC32     RTCSema
   \   0000011C   ........           DC32     UnpackSema
   \   00000120   ........           DC32     LanguageSema
   \   00000124   ........           DC32     UnitSema
   \   00000128   ........           DC32     ??ReceiveFlashTimeOut
   \   0000012C   ........           DC32     ReceiveFlashTimer
   \   00000130   ........           DC32     ??SetAlarmSoundOn
   \   00000134   ........           DC32     AlarmSilenceTimer
   \   00000138   ........           DC32     ??StartTxuTask
   \   0000013C   ........           DC32     `?<Constant "StartTxu">`
    816          }

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for TouchScreenTimeOut>`:
   \   00000000   40771B00           DC32 1800000
   \                     `?<Initializer for IgnoreTouchEvents>`:
   \   00000004   00                 DC8 0

   \                                 In segment DATA_ID, align 8, align-sorted
   \                     `?<Initializer for KickTheDog>`:
   \   00000000   64000000           DC32 100
   \                     `?<Initializer for ReadTouchKey>`:
   \   00000004   00000000           DC32 0H
   \                     `?<Initializer for WatchdogTimeOutTimer>`:
   \   00000008   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              0000        
   \                     `?<Initializer for WatchDogTaskHandle>`:
   \   0000001C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000002C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000003C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000004C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     `?<Initializer for TouchKeyStack>`:
   \   0000005C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000006C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000007C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000008C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000009C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000AC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000BC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000CC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000DC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000EC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000FC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000010C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000011C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000012C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000013C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000014C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000015C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000016C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000017C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000018C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000019C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001AC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001BC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001CC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001DC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001EC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001FC   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000020C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000021C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000022C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000023C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000024C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   0000025C   00000000           DC8 0, 0, 0, 0
   \                     `?<Initializer for WatchDogTaskStack>`:
   \   00000260   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000270   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000280   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000290   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002A0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002B0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002C0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002D0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002E0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002F0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000300   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000310   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000320   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000330   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000340   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000350   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000360   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000370   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000380   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000390   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003A0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003B0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003C0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003D0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003E0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003F0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000400   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000410   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000420   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000430   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000440   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000450   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    

   \                                 In segment DIFUNCT, align 4, keep-with-next, root
   \   00000000                      REQUIRE ?call_ctors
   \   00000000   ........           DC32    ??__sti__routine

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "StartTxu">`:
   \   00000000   537461727454       DC8 "StartTxu"
   \              787500      
   \   00000009   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Watchdog">`:
   \   00000000   576174636864       DC8 "Watchdog"
   \              6F6700      
   \   00000009   000000             DC8 0, 0, 0
   \   0000000C   52656164546F       DC8 "ReadTouchKey"
   \              7563684B6579
   \              00          
   \   00000019   000000             DC8 0, 0, 0
   \   0000001C   436F6E666967       DC8 "ConfigFile.txt"
   \              46696C652E74
   \              787400      
   \   0000002B   00                 DC8 0

   \                                 In segment CODE, align 4, keep-with-next
   \   static __??Code32?? __intrinsic __code __interwork __atpcs void __sti__routine()
   \                     ??__sti__routine:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     KickTheDog

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     TouchKeyPressed

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   14F0FF31           DC32     0x31fff014

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     FlashSema
    817          
    818          #endif

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     CheckMem(unsigned char *, unsigned char *)
                                        4
     ReadTouchKeyTask()                16
     StartTxuTask()                    64
     TouchExec(char)                    4
     TouchTimeOutTimerHandler()         0
     WatchDogTask()                    36
     WatchdogTimeOutHandler()           8
     __sti__routine()                   0
     main()                            24


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     LastOSError                       4
     ProgProgress                      4
     LastOSErrorTask                  32
     LastStartTime                     4
     WatchdogTimeOutHandler()        152
     WatchDogTask()                  428
     TouchScreenTimeOut                5
     KickTheDog                     1120
     TouchTimeOutTimerHandler()       16
     TouchExec(char)                  68
     ReadTouchKeyTask()              136
     StartTxuTaskStack               108
     ADConSema                        16
     TouchTimeOutTimer                20
     BackLightIsOn                     1
     KeyPressedSequence                4
     SecondKeyPressed                  1
     StartTCB                         64
     ShallContinoueInBootLoader        1
     StartTxuTask()                  392
     Patterns                          4
     CheckMem(unsigned char *, unsigned char *)
                                     104
     main()                          320
     ?<Initializer for TouchScreenTimeOut>
                                       5
     ?<Initializer for KickTheDog>  1120
     ?<Constant "StartTxu">           12
     ?<Constant "Watchdog">           44
     __sti__routine()                  4
     ??DataTable1                      4
     ??DataTable6                      4
     ??DataTable8                      4
     ??DataTable9                      4
      Others                         628

 
 2 236 bytes in segment CODE
    44 bytes in segment DATA_AN
    60 bytes in segment DATA_C
 1 125 bytes in segment DATA_I
 1 125 bytes in segment DATA_ID
   215 bytes in segment DATA_Z
     4 bytes in segment DIFUNCT
    24 bytes in segment INITTAB
 
 1 640 bytes of CODE  memory (+ 624 bytes shared)
 1 185 bytes of CONST memory
 1 340 bytes of DATA  memory (+  44 bytes shared)

Errors: none
Warnings: none
