##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:20:13 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\core\ipv4\icmp.c        #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\core\ipv4\icmp.c --fpu  #
#                       None -D OS_LIBMODE_SP -D CPU_S3C2410 -D              #
#                       OS_RAMVECT=0 -D OS_UART=-1 -D S2TXU -D USE_LZO=1 -D  #
#                       __ARM_LIBRARY__ -D WATCHDOG=1 -D NETWORK=1 -lCN      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\icmp.lst                    #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\icmp.r79                     #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\core\ipv4\icmp.c
      1          /**
      2           * @file
      3           * ICMP - Internet Control Message Protocol
      4           *
      5           */
      6          
      7          /*
      8           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
      9           * All rights reserved.
     10           *
     11           * Redistribution and use in source and binary forms, with or without modification,
     12           * are permitted provided that the following conditions are met:
     13           *
     14           * 1. Redistributions of source code must retain the above copyright notice,
     15           *    this list of conditions and the following disclaimer.
     16           * 2. Redistributions in binary form must reproduce the above copyright notice,
     17           *    this list of conditions and the following disclaimer in the documentation
     18           *    and/or other materials provided with the distribution.
     19           * 3. The name of the author may not be used to endorse or promote products
     20           *    derived from this software without specific prior written permission.
     21           *
     22           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     23           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     24           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     25           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     26           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     27           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     28           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     29           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     30           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     31           * OF SUCH DAMAGE.
     32           *
     33           * This file is part of the lwIP TCP/IP stack.
     34           *
     35           * Author: Adam Dunkels <adam@sics.se>
     36           *
     37           */
     38          
     39          /* Some ICMP messages should be passed to the transport protocols. This
     40             is not implemented. */
     41          
     42          #include "lwip/opt.h"
     43          
     44          #if LWIP_ICMP /* don't build if not configured for use in lwipopts.h */
     45          
     46          #include "lwip/icmp.h"
     47          #include "lwip/inet_chksum.h"
     48          #include "lwip/ip.h"
     49          #include "lwip/def.h"
     50          #include "lwip/stats.h"
     51          #include "lwip/snmp.h"
     52          
     53          #include <string.h>
     54          
     55          /** Small optimization: set to 0 if incoming PBUF_POOL pbuf always can be
     56           * used to modify and send a response packet (and to 1 if this is not the case,
     57           * e.g. when link header is stripped of when receiving) */
     58          #ifndef LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
     59          #define LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN 1
     60          #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
     61          
     62          /* The amount of data from the original packet to return in a dest-unreachable */
     63          #define ICMP_DEST_UNREACH_DATASIZE 8
     64          
     65          static void icmp_send_response(struct pbuf *p, u8_t type, u8_t code);
     66          
     67          /**
     68           * Processes ICMP input packets, called from ip_input().
     69           *
     70           * Currently only processes icmp echo requests and sends
     71           * out the echo response.
     72           *
     73           * @param p the icmp echo request packet, p->payload pointing to the ip header
     74           * @param inp the netif on which this packet was received
     75           */

   \                                 In segment CODE, align 4, keep-with-next
     76          void
     77          icmp_input(struct pbuf *p, struct netif *inp)
     78          {
   \                     icmp_input:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
     79            u8_t type;
     80          #ifdef LWIP_DEBUG
     81            u8_t code;
     82          #endif /* LWIP_DEBUG */
     83            struct icmp_echo_hdr *iecho;
     84            struct ip_hdr *iphdr;
     85            s16_t hlen;
     86          
     87            ICMP_STATS_INC(icmp.recv);
   \   00000004   ........           LDR      R5,??DataTable1  ;; lwip_stats
   \   00000008   0090A0E1           MOV      R9,R0
   \   0000000C   B206D5E1           LDRH     R0,[R5, #+98]
   \   00000010   0140A0E1           MOV      R4,R1
   \   00000014   010080E2           ADD      R0,R0,#+1
   \   00000018   B206C5E1           STRH     R0,[R5, #+98]
     88            snmp_inc_icmpinmsgs();
     89          
     90          
     91            iphdr = (struct ip_hdr *)p->payload;
   \   0000001C   048099E5           LDR      R8,[R9, #+4]
     92            hlen = IPH_HL(iphdr) * 4;
   \   00000020   0000D8E5           LDRB     R0,[R8, #+0]
   \   00000024   0F0000E2           AND      R0,R0,#0xF
   \   00000028   0061A0E1           LSL      R6,R0,#+2
   \   0000002C   00A066E2           RSB      R10,R6,#+0
   \   00000030   0A18A0E1           MOV      R1,R10, LSL #+16
   \   00000034   4118A0E1           MOV      R1,R1, ASR #+16
   \   00000038   0900A0E1           MOV      R0,R9
     93            if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
   \   0000003C   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   9000001A           BNE      ??icmp_input_0
   \   00000048   B800D9E1           LDRH     R0,[R9, #+8]
   \   0000004C   040050E3           CMP      R0,#+4
   \   00000050   8D00003A           BCC      ??icmp_input_0
     94              LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
     95              goto lenerr;
     96            }
     97          
     98            type = *((u8_t *)p->payload);
     99          #ifdef LWIP_DEBUG
    100            code = *(((u8_t *)p->payload)+1);
    101          #endif /* LWIP_DEBUG */
    102            switch (type) {
   \   00000054   040099E5           LDR      R0,[R9, #+4]
   \   00000058   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   1000000A           BEQ      ??icmp_input_1
   \   00000064   080050E2           SUBS     R0,R0,#+8
   \   00000068   8000001A           BNE      ??icmp_input_2
    103            case ICMP_ER:
    104              /* This is OK, echo reply might have been parsed by a raw PCB
    105                 (as obviously, an echo request has been sent, too). */
    106              break; 
    107            case ICMP_ECHO:
    108          #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    109              {
    110                int accepted = 1;
    111          #if !LWIP_MULTICAST_PING
    112                /* multicast destination address? */
    113                if (ip_addr_ismulticast(&current_iphdr_dest)) {
   \   0000006C   48729FE5           LDR      R7,??icmp_input_3  ;; current_iphdr_dest
   \   00000070   01B0A0E3           MOV      R11,#+1
   \   00000074   000097E5           LDR      R0,[R7, #+0]
   \   00000078   F01000E2           AND      R1,R0,#0xF0
   \   0000007C   E00051E3           CMP      R1,#+224
    114                  accepted = 0;
   \   00000080   00B0A003           MOVEQ    R11,#+0
    115                }
    116          #endif /* LWIP_MULTICAST_PING */
    117          #if !LWIP_BROADCAST_PING
    118                /* broadcast destination address? */
    119                if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
   \   00000084   0410A0E1           MOV      R1,R4
   \   00000088   ........           _BLF     ip4_addr_isbroadcast,??ip4_addr_isbroadcast??rA
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   0100001A           BNE      ??icmp_input_4
    120                  accepted = 0;
    121                }
    122          #endif /* LWIP_BROADCAST_PING */
    123                /* broadcast or multicast destination address not acceptd? */
    124                if (!accepted) {
   \   00000094   00005BE3           CMP      R11,#+0
   \   00000098   0500001A           BNE      ??icmp_input_5
    125                  LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
    126                  ICMP_STATS_INC(icmp.err);
   \                     ??icmp_input_4:
   \   0000009C   B407D5E1           LDRH     R0,[R5, #+116]
   \   000000A0   010080E2           ADD      R0,R0,#+1
   \   000000A4   B407C5E1           STRH     R0,[R5, #+116]
    127                  pbuf_free(p);
   \                     ??icmp_input_1:
   \   000000A8   0900A0E1           MOV      R0,R9
   \   000000AC   ........           _BLF     pbuf_free,??pbuf_free??rA
    128                  return;
   \   000000B0   0B0000EA           B        ??icmp_input_6
    129                }
    130              }
    131          #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    132              LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    133              if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
   \                     ??icmp_input_5:
   \   000000B4   B800D9E1           LDRH     R0,[R9, #+8]
   \   000000B8   080050E3           CMP      R0,#+8
   \   000000BC   7200003A           BCC      ??icmp_input_0
    134                LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
    135                goto lenerr;
    136              }
    137              if (inet_chksum_pbuf(p) != 0) {
   \   000000C0   0900A0E1           MOV      R0,R9
   \   000000C4   ........           _BLF     inet_chksum_pbuf,??inet_chksum_pbuf??rA
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   0600000A           BEQ      ??icmp_input_7
    138                LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
    139                pbuf_free(p);
   \   000000D0   0900A0E1           MOV      R0,R9
   \   000000D4   ........           _BLF     pbuf_free,??pbuf_free??rA
    140                ICMP_STATS_INC(icmp.chkerr);
   \   000000D8   B806D5E1           LDRH     R0,[R5, #+104]
   \   000000DC   010080E2           ADD      R0,R0,#+1
   \   000000E0   B806C5E1           STRH     R0,[R5, #+104]
    141                snmp_inc_icmpinerrors();
    142                return;
   \                     ??icmp_input_6:
   \   000000E4   F04FBDE8           POP      {R4-R11,LR}
   \   000000E8   1EFF2FE1           BX       LR
    143              }
    144          #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    145              if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
   \                     ??icmp_input_7:
   \   000000EC   2210A0E3           MOV      R1,#+34
   \   000000F0   0900A0E1           MOV      R0,R9
   \   000000F4   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   1900000A           BEQ      ??icmp_input_8
    146                /* p is not big enough to contain link headers
    147                 * allocate a new one and copy p into it
    148                 */
    149                struct pbuf *r;
    150                /* switch p->payload to ip header */
    151                if (pbuf_header(p, hlen)) {
   \   00000100   0610A0E1           MOV      R1,R6
   \   00000104   0900A0E1           MOV      R0,R9
   \   00000108   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   6300001A           BNE      ??icmp_input_9
    152                  LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
    153                  goto memerr;
    154                }
    155                /* allocate new packet buffer with space for link headers */
    156                r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
   \   00000114   B810D9E1           LDRH     R1,[R9, #+8]
   \   00000118   0020A0E3           MOV      R2,#+0
   \   0000011C   0200A0E3           MOV      R0,#+2
   \   00000120   ........           _BLF     pbuf_alloc,??pbuf_alloc??rA
   \   00000124   00B0B0E1           MOVS     R11,R0
    157                if (r == NULL) {
   \   00000128   5D00000A           BEQ      ??icmp_input_9
    158                  LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
    159                  goto memerr;
    160                }
    161                LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
    162                            (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
    163                /* copy the whole packet including ip header */
    164                if (pbuf_copy(r, p) != ERR_OK) {
   \   0000012C   0910A0E1           MOV      R1,R9
   \   00000130   ........           _BLF     pbuf_copy,??pbuf_copy??rA
   \   00000134   000050E3           CMP      R0,#+0
   \   00000138   5900001A           BNE      ??icmp_input_9
    165                  LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
    166                  goto memerr;
    167                }
    168                iphdr = (struct ip_hdr *)r->payload;
   \   0000013C   04809BE5           LDR      R8,[R11, #+4]
    169                /* switch r->payload back to icmp header */
    170                if (pbuf_header(r, -hlen)) {
   \   00000140   0A18A0E1           MOV      R1,R10, LSL #+16
   \   00000144   4118A0E1           MOV      R1,R1, ASR #+16
   \   00000148   0B00A0E1           MOV      R0,R11
   \   0000014C   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   00000150   000050E3           CMP      R0,#+0
   \   00000154   5200001A           BNE      ??icmp_input_9
    171                  LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    172                  goto memerr;
    173                }
    174                /* free the original p */
    175                pbuf_free(p);
   \   00000158   0900A0E1           MOV      R0,R9
   \   0000015C   ........           _BLF     pbuf_free,??pbuf_free??rA
    176                /* we now have an identical copy of p that has room for link headers */
    177                p = r;
   \   00000160   0B90A0E1           MOV      R9,R11
   \   00000164   040000EA           B        ??icmp_input_10
    178              } else {
    179                /* restore p->payload to point to icmp header */
    180                if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
   \                     ??icmp_input_8:
   \   00000168   2110E0E3           MVN      R1,#+33
   \   0000016C   0900A0E1           MOV      R0,R9
   \   00000170   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   00000174   000050E3           CMP      R0,#+0
   \   00000178   4900001A           BNE      ??icmp_input_9
    181                  LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    182                  goto memerr;
    183                }
    184              }
    185          #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    186              /* At this point, all checks are OK. */
    187              /* We generate an answer by switching the dest and src ip addresses,
    188               * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    189              iecho = (struct icmp_echo_hdr *)p->payload;
    190              ip_addr_copy(iphdr->src, *ip_current_dest_addr());
   \                     ??icmp_input_10:
   \   0000017C   001097E5           LDR      R1,[R7, #+0]
   \   00000180   040099E5           LDR      R0,[R9, #+4]
   \   00000184   0C10C8E5           STRB     R1,[R8, #+12]
   \   00000188   2114A0E1           LSR      R1,R1,#+8
   \   0000018C   0D10C8E5           STRB     R1,[R8, #+13]
   \   00000190   2114A0E1           LSR      R1,R1,#+8
   \   00000194   0E10C8E5           STRB     R1,[R8, #+14]
   \   00000198   2114A0E1           LSR      R1,R1,#+8
   \   0000019C   0F10C8E5           STRB     R1,[R8, #+15]
    191              ip_addr_copy(iphdr->dest, *ip_current_src_addr());
   \   000001A0   18119FE5           LDR      R1,??icmp_input_3+0x4  ;; current_iphdr_src
   \   000001A4   001091E5           LDR      R1,[R1, #+0]
   \   000001A8   1010C8E5           STRB     R1,[R8, #+16]
   \   000001AC   2114A0E1           LSR      R1,R1,#+8
   \   000001B0   1110C8E5           STRB     R1,[R8, #+17]
   \   000001B4   2114A0E1           LSR      R1,R1,#+8
   \   000001B8   1210C8E5           STRB     R1,[R8, #+18]
   \   000001BC   2114A0E1           LSR      R1,R1,#+8
   \   000001C0   1310C8E5           STRB     R1,[R8, #+19]
    192              ICMPH_TYPE_SET(iecho, ICMP_ER);
   \   000001C4   0010A0E3           MOV      R1,#+0
   \   000001C8   0010C0E5           STRB     R1,[R0, #+0]
    193          #if CHECKSUM_GEN_ICMP
    194              /* adjust the checksum */
    195              if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
   \   000001CC   0320D0E5           LDRB     R2,[R0, #+3]
   \   000001D0   0230D0E5           LDRB     R3,[R0, #+2]
   \   000001D4   022483E1           ORR      R2,R3,R2, LSL #+8
   \   000001D8   F730A0E3           MOV      R3,#+247
   \   000001DC   FF3C83E3           ORR      R3,R3,#0xFF00
   \   000001E0   030052E1           CMP      R2,R3
    196                iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
   \   000001E4   09208222           ADDCS    R2,R2,#+9
    197              } else {
    198                iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
   \   000001E8   08208232           ADDCC    R2,R2,#+8
   \   000001EC   0220C0E5           STRB     R2,[R0, #+2]
   \   000001F0   2224A0E1           LSR      R2,R2,#+8
   \   000001F4   0320C0E5           STRB     R2,[R0, #+3]
    199              }
    200          #else /* CHECKSUM_GEN_ICMP */
    201              iecho->chksum = 0;
    202          #endif /* CHECKSUM_GEN_ICMP */
    203          
    204              /* Set the correct TTL and recalculate the header checksum. */
    205              IPH_TTL_SET(iphdr, ICMP_TTL);
   \   000001F8   FF00A0E3           MOV      R0,#+255
   \   000001FC   0800C8E5           STRB     R0,[R8, #+8]
    206              IPH_CHKSUM_SET(iphdr, 0);
   \   00000200   0A10C8E5           STRB     R1,[R8, #+10]
   \   00000204   0B10C8E5           STRB     R1,[R8, #+11]
    207          #if CHECKSUM_GEN_IP
    208              IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
   \   00000208   1410A0E3           MOV      R1,#+20
   \   0000020C   0800A0E1           MOV      R0,R8
   \   00000210   ........           _BLF     inet_chksum,??inet_chksum??rA
   \   00000214   0A00C8E5           STRB     R0,[R8, #+10]
   \   00000218   2004A0E1           LSR      R0,R0,#+8
   \   0000021C   0B00C8E5           STRB     R0,[R8, #+11]
    209          #endif /* CHECKSUM_GEN_IP */
    210          
    211              ICMP_STATS_INC(icmp.xmit);
   \   00000220   B006D5E1           LDRH     R0,[R5, #+96]
    212              /* increase number of messages attempted to send */
    213              snmp_inc_icmpoutmsgs();
    214              /* increase number of echo replies attempted to send */
    215              snmp_inc_icmpoutechoreps();
    216          
    217              if(pbuf_header(p, hlen)) {
   \   00000224   0610A0E1           MOV      R1,R6
   \   00000228   010080E2           ADD      R0,R0,#+1
   \   0000022C   B006C5E1           STRH     R0,[R5, #+96]
   \   00000230   0900A0E1           MOV      R0,R9
   \   00000234   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   00000238   000050E3           CMP      R0,#+0
   \   0000023C   99FFFF1A           BNE      ??icmp_input_1
    218                LWIP_ASSERT("Can't move over header in packet", 0);
    219              } else {
    220                err_t ret;
    221                /* send an ICMP packet, src addr is the dest addr of the curren packet */
    222                ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
    223                             ICMP_TTL, 0, IP_PROTO_ICMP, inp);
   \   00000240   10002DE9           PUSH     {R4}
   \   00000244   0100A0E3           MOV      R0,#+1
   \   00000248   01002DE9           PUSH     {R0}
   \   0000024C   0000A0E3           MOV      R0,#+0
   \   00000250   01002DE9           PUSH     {R0}
   \   00000254   FF30A0E3           MOV      R3,#+255
   \   00000258   0020A0E3           MOV      R2,#+0
   \   0000025C   0710A0E1           MOV      R1,R7
   \   00000260   0900A0E1           MOV      R0,R9
   \   00000264   ........           _BLF     ip_output_if,??ip_output_if??rA
    224                if (ret != ERR_OK) {
   \   00000268   0CD08DE2           ADD      SP,SP,#+12
   \   0000026C   8DFFFFEA           B        ??icmp_input_1
    225                  LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
    226                }
    227              }
    228              break;
    229            default:
    230              LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
    231                          (s16_t)type, (s16_t)code));
    232              ICMP_STATS_INC(icmp.proterr);
   \                     ??icmp_input_2:
   \   00000270   B007D5E1           LDRH     R0,[R5, #+112]
   \   00000274   010080E2           ADD      R0,R0,#+1
   \   00000278   B007C5E1           STRH     R0,[R5, #+112]
    233              ICMP_STATS_INC(icmp.drop);
   \   0000027C   B606D5E1           LDRH     R0,[R5, #+102]
   \   00000280   010080E2           ADD      R0,R0,#+1
   \   00000284   B606C5E1           STRH     R0,[R5, #+102]
    234            }
    235            pbuf_free(p);
   \   00000288   86FFFFEA           B        ??icmp_input_1
    236            return;
    237          lenerr:
    238            pbuf_free(p);
   \                     ??icmp_input_0:
   \   0000028C   0900A0E1           MOV      R0,R9
   \   00000290   ........           _BLF     pbuf_free,??pbuf_free??rA
    239            ICMP_STATS_INC(icmp.lenerr);
   \   00000294   BA06D5E1           LDRH     R0,[R5, #+106]
   \   00000298   010080E2           ADD      R0,R0,#+1
   \   0000029C   BA06C5E1           STRH     R0,[R5, #+106]
    240            snmp_inc_icmpinerrors();
    241            return;
   \   000002A0   8FFFFFEA           B        ??icmp_input_6
    242          #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    243          memerr:
    244            pbuf_free(p);
   \                     ??icmp_input_9:
   \   000002A4   0900A0E1           MOV      R0,R9
   \   000002A8   ........           _BLF     pbuf_free,??pbuf_free??rA
    245            ICMP_STATS_INC(icmp.err);
   \   000002AC   B407D5E1           LDRH     R0,[R5, #+116]
   \   000002B0   010080E2           ADD      R0,R0,#+1
   \   000002B4   B407C5E1           STRH     R0,[R5, #+116]
    246            snmp_inc_icmpinerrors();
    247            return;
   \   000002B8   89FFFFEA           B        ??icmp_input_6
   \                     ??icmp_input_3:
   \   000002BC   ........           DC32     current_iphdr_dest
   \   000002C0   ........           DC32     current_iphdr_src
    248          #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    249          }
    250          
    251          /**
    252           * Send an icmp 'destination unreachable' packet, called from ip_input() if
    253           * the transport layer protocol is unknown and from udp_input() if the local
    254           * port is not bound.
    255           *
    256           * @param p the input packet for which the 'unreachable' should be sent,
    257           *          p->payload pointing to the IP header
    258           * @param t type of the 'unreachable' packet
    259           */

   \                                 In segment CODE, align 4, keep-with-next
    260          void
    261          icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
    262          {
   \                     icmp_dest_unreach:
   \   00000000   00402DE9           PUSH     {LR}
    263            icmp_send_response(p, ICMP_DUR, t);
   \   00000004   0120A0E1           MOV      R2,R1
   \   00000008   0310A0E3           MOV      R1,#+3
   \   0000000C   ........           BL       icmp_send_response
    264          }
   \   00000010   0040BDE8           POP      {LR}
   \   00000014   1EFF2FE1           BX       LR               ;; return
    265          
    266          #if IP_FORWARD || IP_REASSEMBLY
    267          /**
    268           * Send a 'time exceeded' packet, called from ip_forward() if TTL is 0.
    269           *
    270           * @param p the input packet for which the 'time exceeded' should be sent,
    271           *          p->payload pointing to the IP header
    272           * @param t type of the 'time exceeded' packet
    273           */

   \                                 In segment CODE, align 4, keep-with-next
    274          void
    275          icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
    276          {
   \                     icmp_time_exceeded:
   \   00000000   00402DE9           PUSH     {LR}
    277            icmp_send_response(p, ICMP_TE, t);
   \   00000004   0120A0E1           MOV      R2,R1
   \   00000008   0B10A0E3           MOV      R1,#+11
   \   0000000C   ........           BL       icmp_send_response
    278          }
   \   00000010   0040BDE8           POP      {LR}
   \   00000014   1EFF2FE1           BX       LR               ;; return
    279          
    280          #endif /* IP_FORWARD || IP_REASSEMBLY */
    281          
    282          /**
    283           * Send an icmp packet in response to an incoming packet.
    284           *
    285           * @param p the input packet for which the 'unreachable' should be sent,
    286           *          p->payload pointing to the IP header
    287           * @param type Type of the ICMP header
    288           * @param code Code of the ICMP header
    289           */

   \                                 In segment CODE, align 4, keep-with-next
    290          static void
    291          icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
    292          {
   \                     icmp_send_response:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   0180A0E1           MOV      R8,R1
   \   00000010   0290A0E1           MOV      R9,R2
    293            struct pbuf *q;
    294            struct ip_hdr *iphdr;
    295            /* we can use the echo header here */
    296            struct icmp_echo_hdr *icmphdr;
    297            ip_addr_t iphdr_src;
    298          
    299            /* ICMP header + IP header + 8 bytes of data */
    300            q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
    301                           PBUF_RAM);
   \   00000014   0020A0E3           MOV      R2,#+0
   \   00000018   2410A0E3           MOV      R1,#+36
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   ........           _BLF     pbuf_alloc,??pbuf_alloc??rA
   \   00000024   0040B0E1           MOVS     R4,R0
    302            if (q == NULL) {
   \   00000028   2D00000A           BEQ      ??icmp_send_response_0
    303              LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    304              return;
    305            }
    306            LWIP_ASSERT("check that first pbuf can hold icmp message",
    307                       (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
    308          
    309            iphdr = (struct ip_hdr *)p->payload;
    310            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
    311            ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
    312            LWIP_DEBUGF(ICMP_DEBUG, (" to "));
    313            ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
    314            LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
    315          
    316            icmphdr = (struct icmp_echo_hdr *)q->payload;
   \   0000002C   046094E5           LDR      R6,[R4, #+4]
   \   00000030   045097E5           LDR      R5,[R7, #+4]
    317            icmphdr->type = type;
   \   00000034   0080C6E5           STRB     R8,[R6, #+0]
    318            icmphdr->code = code;
   \   00000038   0190C6E5           STRB     R9,[R6, #+1]
    319            icmphdr->id = 0;
   \   0000003C   0080A0E3           MOV      R8,#+0
   \   00000040   0480C6E5           STRB     R8,[R6, #+4]
   \   00000044   0580C6E5           STRB     R8,[R6, #+5]
    320            icmphdr->seqno = 0;
   \   00000048   0680C6E5           STRB     R8,[R6, #+6]
   \   0000004C   0780C6E5           STRB     R8,[R6, #+7]
    321          
    322            /* copy fields from original packet */
    323            SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    324                    IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
   \   00000050   041097E5           LDR      R1,[R7, #+4]
   \   00000054   040094E5           LDR      R0,[R4, #+4]
   \   00000058   1C20A0E3           MOV      R2,#+28
   \   0000005C   080080E2           ADD      R0,R0,#+8
   \   00000060   ........           _BLF     memcpy,??memcpy??rA
    325          
    326            /* calculate checksum */
    327            icmphdr->chksum = 0;
   \   00000064   0280C6E5           STRB     R8,[R6, #+2]
   \   00000068   0380C6E5           STRB     R8,[R6, #+3]
    328            icmphdr->chksum = inet_chksum(icmphdr, q->len);
   \   0000006C   BA10D4E1           LDRH     R1,[R4, #+10]
   \   00000070   0600A0E1           MOV      R0,R6
   \   00000074   ........           _BLF     inet_chksum,??inet_chksum??rA
   \   00000078   0200C6E5           STRB     R0,[R6, #+2]
   \   0000007C   2004A0E1           LSR      R0,R0,#+8
   \   00000080   0300C6E5           STRB     R0,[R6, #+3]
    329            ICMP_STATS_INC(icmp.xmit);
   \   00000084   ........           LDR      R0,??DataTable1  ;; lwip_stats
    330            /* increase number of messages attempted to send */
    331            snmp_inc_icmpoutmsgs();
    332            /* increase number of destination unreachable messages attempted to send */
    333            snmp_inc_icmpouttimeexcds();
    334            ip_addr_copy(iphdr_src, iphdr->src);
    335            ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
   \   00000088   FF30A0E3           MOV      R3,#+255
   \   0000008C   B016D0E1           LDRH     R1,[R0, #+96]
   \   00000090   011081E2           ADD      R1,R1,#+1
   \   00000094   B016C0E1           STRH     R1,[R0, #+96]
   \   00000098   0F10D5E5           LDRB     R1,[R5, #+15]
   \   0000009C   0E20D5E5           LDRB     R2,[R5, #+14]
   \   000000A0   0100A0E3           MOV      R0,#+1
   \   000000A4   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000000A8   0D20D5E5           LDRB     R2,[R5, #+13]
   \   000000AC   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000000B0   0C20D5E5           LDRB     R2,[R5, #+12]
   \   000000B4   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000000B8   00108DE5           STR      R1,[SP, #+0]
   \   000000BC   01002DE9           PUSH     {R0}
   \   000000C0   0000A0E3           MOV      R0,#+0
   \   000000C4   01002DE9           PUSH     {R0}
   \   000000C8   08208DE2           ADD      R2,SP,#+8
   \   000000CC   0010A0E1           MOV      R1,R0
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           _BLF     ip_output,??ip_output??rA
    336            pbuf_free(q);
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   ........           _BLF     pbuf_free,??pbuf_free??rA
    337          }
   \   000000E0   08D08DE2           ADD      SP,SP,#+8
   \                     ??icmp_send_response_0:
   \   000000E4   F143BDE8           POP      {R0,R4-R9,LR}
   \   000000E8   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     lwip_stats
    338          
    339          #endif /* LWIP_ICMP */
    340          

   Maximum stack usage in bytes:

     Function           CSTACK
     --------           ------
     icmp_dest_unreach      4
     icmp_input            48
     icmp_send_response    40
     icmp_time_exceeded     4


   Segment part sizes:

     Function/Label     Bytes
     --------------     -----
     icmp_input          708
     icmp_dest_unreach    24
     icmp_time_exceeded   24
     icmp_send_response  236
     ??DataTable1          4
      Others             136

 
 1 132 bytes in segment CODE
 
 996 bytes of CODE memory (+ 136 bytes shared)

Errors: none
Warnings: none
