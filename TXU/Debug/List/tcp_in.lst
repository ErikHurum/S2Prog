##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:20:21 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\core\tcp_in.c           #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\core\tcp_in.c --fpu     #
#                       None -D OS_LIBMODE_SP -D CPU_S3C2410 -D              #
#                       OS_RAMVECT=0 -D OS_UART=-1 -D S2TXU -D USE_LZO=1 -D  #
#                       __ARM_LIBRARY__ -D WATCHDOG=1 -D NETWORK=1 -lCN      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\tcp_in.lst                  #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\tcp_in.r79                   #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\core\tcp_in.c
      1          /**
      2           * @file
      3           * Transmission Control Protocol, incoming traffic
      4           *
      5           * The input processing functions of the TCP layer.
      6           *
      7           * These functions are generally called in the order (ip_input() ->)
      8           * tcp_input() -> * tcp_process() -> tcp_receive() (-> application).
      9           *
     10           */
     11          
     12          /*
     13           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
     14           * All rights reserved.
     15           *
     16           * Redistribution and use in source and binary forms, with or without modification,
     17           * are permitted provided that the following conditions are met:
     18           *
     19           * 1. Redistributions of source code must retain the above copyright notice,
     20           *    this list of conditions and the following disclaimer.
     21           * 2. Redistributions in binary form must reproduce the above copyright notice,
     22           *    this list of conditions and the following disclaimer in the documentation
     23           *    and/or other materials provided with the distribution.
     24           * 3. The name of the author may not be used to endorse or promote products
     25           *    derived from this software without specific prior written permission.
     26           *
     27           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     28           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     29           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     30           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     31           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     32           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     33           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     34           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     35           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     36           * OF SUCH DAMAGE.
     37           *
     38           * This file is part of the lwIP TCP/IP stack.
     39           *
     40           * Author: Adam Dunkels <adam@sics.se>
     41           *
     42           */
     43          
     44          #include "lwip/opt.h"
     45          
     46          #if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
     47          
     48          #include "lwip/tcp_impl.h"
     49          #include "lwip/def.h"
     50          #include "lwip/ip_addr.h"
     51          #include "lwip/netif.h"
     52          #include "lwip/mem.h"
     53          #include "lwip/memp.h"
     54          #include "lwip/inet_chksum.h"
     55          #include "lwip/stats.h"
     56          #include "lwip/snmp.h"
     57          #include "arch/perf.h"
     58          
     59          
     60          /* These variables are global to all functions involved in the input
     61             processing of TCP segments. They are set by the tcp_input()
     62             function. */

   \                                 In segment DATA_Z, align 4, align-sorted
     63          static struct tcp_seg inseg;
   \                     inseg:
   \   00000000                      DS8 16
   \   00000010                      DS8 2
   \   00000012                      DS8 2
   \   00000014                      DS8 4
   \   00000018                      DS8 4
   \   0000001C                      DS8 4
   \   00000020                      DS8 4
     64          static struct tcp_hdr *tcphdr;
     65          static struct ip_hdr *iphdr;
     66          static u32_t seqno, ackno;
     67          static u8_t flags;
     68          static u16_t tcplen;
     69          
     70          static u8_t recv_flags;
     71          static struct pbuf *recv_data;
     72          
     73          struct tcp_pcb *tcp_input_pcb;
   \                     tcp_input_pcb:
   \   00000024                      DS8 4
   \   00000028                      DS8 1
   \   00000029                      DS8 1
     74          
     75          /* Forward declarations. */
     76          static err_t tcp_process(struct tcp_pcb *pcb);
     77          static void tcp_receive(struct tcp_pcb *pcb);
     78          static void tcp_parseopt(struct tcp_pcb *pcb);
     79          
     80          static err_t tcp_listen_input(struct tcp_pcb_listen *pcb);
     81          static err_t tcp_timewait_input(struct tcp_pcb *pcb);
     82          
     83          /**
     84           * The initial input processing of TCP. It verifies the TCP header, demultiplexes
     85           * the segment between the PCBs and passes it on to tcp_process(), which implements
     86           * the TCP finite state machine. This function is called by the IP layer (in
     87           * ip_input()).
     88           *
     89           * @param p received TCP segment to process (p->payload pointing to the IP header)
     90           * @param inp network interface on which this segment was received
     91           */

   \                                 In segment CODE, align 4, keep-with-next
     92          void
     93          tcp_input(struct pbuf *p, struct netif *inp)
     94          {
   \                     tcp_input:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
     95            struct tcp_pcb *pcb, *prev;
     96            struct tcp_pcb_listen *lpcb;
     97          #if SO_REUSE
     98            struct tcp_pcb *lpcb_prev = NULL;
     99            struct tcp_pcb_listen *lpcb_any = NULL;
    100          #endif /* SO_REUSE */
    101            u8_t hdrlen;
    102            err_t err;
    103          
    104            PERF_START;
    105          
    106            TCP_STATS_INC(tcp.recv);
   \   00000004   ........           LDR      R8,??DataTable16  ;; lwip_stats
   \   00000008   08D04DE2           SUB      SP,SP,#+8
    107            snmp_inc_tcpinsegs();
    108          
    109            iphdr = (struct ip_hdr *)p->payload;
    110            tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
   \   0000000C   ........           LDR      R5,??DataTable1  ;; inseg
   \   00000010   0070A0E1           MOV      R7,R0
   \   00000014   B209D8E1           LDRH     R0,[R8, #+146]
   \   00000018   0040A0E3           MOV      R4,#+0
   \   0000001C   04408DE5           STR      R4,[SP, #+4]
   \   00000020   00408DE5           STR      R4,[SP, #+0]
   \   00000024   010080E2           ADD      R0,R0,#+1
   \   00000028   B209C8E1           STRH     R0,[R8, #+146]
   \   0000002C   040097E5           LDR      R0,[R7, #+4]
   \   00000030   0160A0E1           MOV      R6,R1
   \   00000034   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000038   0F1001E2           AND      R1,R1,#0xF
   \   0000003C   011180E0           ADD      R1,R0,R1, LSL #+2
   \   00000040   141085E5           STR      R1,[R5, #+20]
    111          
    112          #if TCP_INPUT_DEBUG
    113            tcp_debug_print(tcphdr);
    114          #endif
    115          
    116            /* remove header from payload */
    117            if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
   \   00000044   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000048   0F0000E2           AND      R0,R0,#0xF
   \   0000004C   0001A0E1           LSL      R0,R0,#+2
   \   00000050   001060E2           RSB      R1,R0,#+0
   \   00000054   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000058   4118A0E1           MOV      R1,R1, ASR #+16
   \   0000005C   0700A0E1           MOV      R0,R7
   \   00000060   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   00000064   000050E3           CMP      R0,#+0
   \   00000068   0200001A           BNE      ??tcp_input_0
   \   0000006C   B800D7E1           LDRH     R0,[R7, #+8]
   \   00000070   140050E3           CMP      R0,#+20
   \   00000074   0800002A           BCS      ??tcp_input_1
    118              /* drop short packets */
    119              LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    120              TCP_STATS_INC(tcp.lenerr);
   \                     ??tcp_input_0:
   \   00000078   BA09D8E1           LDRH     R0,[R8, #+154]
   \   0000007C   010080E2           ADD      R0,R0,#+1
   \   00000080   BA09C8E1           STRH     R0,[R8, #+154]
    121              goto dropped;
    122            }
    123          
    124            /* Don't even process incoming broadcasts/multicasts. */
    125            if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
    126                ip_addr_ismulticast(&current_iphdr_dest)) {
    127              TCP_STATS_INC(tcp.proterr);
    128              goto dropped;
    129            }
    130          
    131          #if CHECKSUM_CHECK_TCP
    132            /* Verify TCP checksum. */
    133            if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
    134                IP_PROTO_TCP, p->tot_len) != 0) {
    135                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
    136                  inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
    137                IP_PROTO_TCP, p->tot_len)));
    138          #if TCP_DEBUG
    139              tcp_debug_print(tcphdr);
    140          #endif /* TCP_DEBUG */
    141              TCP_STATS_INC(tcp.chkerr);
    142              goto dropped;
    143            }
    144          #endif
    145          
    146            /* Move the payload pointer in the pbuf so that it points to the
    147               TCP data instead of the TCP header. */
    148            hdrlen = TCPH_HDRLEN(tcphdr);
    149            if(pbuf_header(p, -(hdrlen * 4))){
    150              /* drop short packets */
    151              LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    152              TCP_STATS_INC(tcp.lenerr);
    153              goto dropped;
    154            }
    155          
    156            /* Convert fields in TCP header to host byte order. */
    157            tcphdr->src = ntohs(tcphdr->src);
    158            tcphdr->dest = ntohs(tcphdr->dest);
    159            seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    160            ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    161            tcphdr->wnd = ntohs(tcphdr->wnd);
    162          
    163            flags = TCPH_FLAGS(tcphdr);
    164            tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    165          
    166            /* Demultiplex an incoming segment. First, we check if it is destined
    167               for an active connection. */
    168            prev = NULL;
    169          
    170          
    171            for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    172              LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    173              LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    174              LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    175              if (pcb->remote_port == tcphdr->src &&
    176                 pcb->local_port == tcphdr->dest &&
    177                 ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    178                 ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    179          
    180                /* Move this PCB to the front of the list so that subsequent
    181                   lookups will be faster (we exploit locality in TCP segment
    182                   arrivals). */
    183                LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
    184                if (prev != NULL) {
    185                  prev->next = pcb->next;
    186                  pcb->next = tcp_active_pcbs;
    187                  tcp_active_pcbs = pcb;
    188                }
    189                LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
    190                break;
    191              }
    192              prev = pcb;
    193            }
    194          
    195            if (pcb == NULL) {
    196              /* If it did not go to an active connection, we check the connections
    197                 in the TIME-WAIT state. */
    198              for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    199                LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    200                if (pcb->remote_port == tcphdr->src &&
    201                   pcb->local_port == tcphdr->dest &&
    202                   ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    203                   ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    204                  /* We don't really care enough to move this PCB to the front
    205                     of the list since we are not very likely to receive that
    206                     many segments for connections in TIME-WAIT. */
    207                  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
    208                  tcp_timewait_input(pcb);
    209                  pbuf_free(p);
    210                  return;
    211                }
    212              }
    213          
    214              /* Finally, if we still did not get a match, we check all PCBs that
    215                 are LISTENing for incoming connections. */
    216              prev = NULL;
    217              for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    218                if (lpcb->local_port == tcphdr->dest) {
    219          #if SO_REUSE
    220                  if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
    221                    /* found an exact match */
    222                    break;
    223                  } else if(ip_addr_isany(&(lpcb->local_ip))) {
    224                    /* found an ANY-match */
    225                    lpcb_any = lpcb;
    226                    lpcb_prev = prev;
    227                  }
    228          #else /* SO_REUSE */
    229                  if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
    230                      ip_addr_isany(&(lpcb->local_ip))) {
    231                    /* found a match */
    232                    break;
    233                  }
    234          #endif /* SO_REUSE */
    235                }
    236                prev = (struct tcp_pcb *)lpcb;
    237              }
    238          #if SO_REUSE
    239              /* first try specific local IP */
    240              if (lpcb == NULL) {
    241                /* only pass to ANY if no specific local IP has been found */
    242                lpcb = lpcb_any;
    243                prev = lpcb_prev;
    244              }
    245          #endif /* SO_REUSE */
    246              if (lpcb != NULL) {
    247                /* Move this PCB to the front of the list so that subsequent
    248                   lookups will be faster (we exploit locality in TCP segment
    249                   arrivals). */
    250                if (prev != NULL) {
    251                  ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    252                        /* our successor is the remainder of the listening list */
    253                  lpcb->next = tcp_listen_pcbs.listen_pcbs;
    254                        /* put this listening pcb at the head of the listening list */
    255                  tcp_listen_pcbs.listen_pcbs = lpcb;
    256                }
    257          
    258                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
    259                tcp_listen_input(lpcb);
    260                pbuf_free(p);
    261                return;
    262              }
    263            }
    264          
    265          #if TCP_INPUT_DEBUG
    266            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
    267            tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
    268            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
    269          #endif /* TCP_INPUT_DEBUG */
    270          
    271          
    272            if (pcb != NULL) {
    273              /* The incoming segment belongs to a connection. */
    274          #if TCP_INPUT_DEBUG
    275          #if TCP_DEBUG
    276              tcp_debug_print_state(pcb->state);
    277          #endif /* TCP_DEBUG */
    278          #endif /* TCP_INPUT_DEBUG */
    279          
    280              /* Set up a tcp_seg structure. */
    281              inseg.next = NULL;
    282              inseg.len = p->tot_len;
    283              inseg.p = p;
    284              inseg.tcphdr = tcphdr;
    285          
    286              recv_data = NULL;
    287              recv_flags = 0;
    288          
    289              if (flags & TCP_PSH) {
    290                p->flags |= PBUF_FLAG_PUSH;
    291              }
    292          
    293              /* If there is data which was previously "refused" by upper layer */
    294              if (pcb->refused_data != NULL) {
    295                if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
    296                  ((pcb->refused_data != NULL) && (tcplen > 0))) {
    297                  /* pcb has been aborted or refused data is still refused and the new
    298                     segment contains data */
    299                  TCP_STATS_INC(tcp.drop);
    300                  snmp_inc_tcpinerrs();
    301                  goto aborted;
    302                }
    303              }
    304              tcp_input_pcb = pcb;
    305              err = tcp_process(pcb);
    306              /* A return value of ERR_ABRT means that tcp_abort() was called
    307                 and that the pcb has been freed. If so, we don't do anything. */
    308              if (err != ERR_ABRT) {
    309                if (recv_flags & TF_RESET) {
    310                  /* TF_RESET means that the connection was reset by the other
    311                     end. We then call the error callback to inform the
    312                     application that the connection is dead before we
    313                     deallocate the PCB. */
    314                  TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    315                  tcp_pcb_remove(&tcp_active_pcbs, pcb);
    316                  memp_free(MEMP_TCP_PCB, pcb);
    317                } else if (recv_flags & TF_CLOSED) {
    318                  /* The connection has been closed and we will deallocate the
    319                     PCB. */
    320                  if (!(pcb->flags & TF_RXCLOSED)) {
    321                    /* Connection closed although the application has only shut down the
    322                       tx side: call the PCB's err callback and indicate the closure to
    323                       ensure the application doesn't continue using the PCB. */
    324                    TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    325                  }
    326                  tcp_pcb_remove(&tcp_active_pcbs, pcb);
    327                  memp_free(MEMP_TCP_PCB, pcb);
    328                } else {
    329                  err = ERR_OK;
    330                  /* If the application has registered a "sent" function to be
    331                     called when new send buffer space is available, we call it
    332                     now. */
    333                  if (pcb->acked > 0) {
    334                    TCP_EVENT_SENT(pcb, pcb->acked, err);
    335                    if (err == ERR_ABRT) {
    336                      goto aborted;
    337                    }
    338                  }
    339          
    340                  if (recv_data != NULL) {
    341                    LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
    342                    if (pcb->flags & TF_RXCLOSED) {
    343                      /* received data although already closed -> abort (send RST) to
    344                         notify the remote host that not all data has been processed */
    345                      pbuf_free(recv_data);
    346                      tcp_abort(pcb);
    347                      goto aborted;
    348                    }
    349          
    350                    /* Notify application that data has been received. */
    351                    TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    352                    if (err == ERR_ABRT) {
    353                      goto aborted;
    354                    }
    355          
    356                    /* If the upper layer can't receive this data, store it */
    357                    if (err != ERR_OK) {
    358                      pcb->refused_data = recv_data;
    359                      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
    360                    }
    361                  }
    362          
    363                  /* If a FIN segment was received, we call the callback
    364                     function with a NULL buffer to indicate EOF. */
    365                  if (recv_flags & TF_GOT_FIN) {
    366                    if (pcb->refused_data != NULL) {
    367                      /* Delay this if we have refused data. */
    368                      pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    369                    } else {
    370                      /* correct rcv_wnd as the application won't call tcp_recved()
    371                         for the FIN's seqno */
    372                      if (pcb->rcv_wnd != TCP_WND) {
    373                        pcb->rcv_wnd++;
    374                      }
    375                      TCP_EVENT_CLOSED(pcb, err);
    376                      if (err == ERR_ABRT) {
    377                        goto aborted;
    378                      }
    379                    }
    380                  }
    381          
    382                  tcp_input_pcb = NULL;
    383                  /* Try to send something out. */
    384                  tcp_output(pcb);
    385          #if TCP_INPUT_DEBUG
    386          #if TCP_DEBUG
    387                  tcp_debug_print_state(pcb->state);
    388          #endif /* TCP_DEBUG */
    389          #endif /* TCP_INPUT_DEBUG */
    390                }
    391              }
    392              /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
    393                 Below this line, 'pcb' may not be dereferenced! */
    394          aborted:
    395              tcp_input_pcb = NULL;
    396              recv_data = NULL;
    397          
    398              /* give up our reference to inseg.p */
    399              if (inseg.p != NULL)
    400              {
    401                pbuf_free(inseg.p);
    402                inseg.p = NULL;
    403              }
    404            } else {
    405          
    406              /* If no matching PCB was found, send a TCP RST (reset) to the
    407                 sender. */
    408              LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    409              if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    410                TCP_STATS_INC(tcp.proterr);
    411                TCP_STATS_INC(tcp.drop);
    412                tcp_rst(ackno, seqno + tcplen,
    413                  ip_current_dest_addr(), ip_current_src_addr(),
    414                  tcphdr->dest, tcphdr->src);
    415              }
    416              pbuf_free(p);
    417            }
    418          
    419            LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
    420            PERF_STOP("tcp_input");
    421            return;
    422          dropped:
    423            TCP_STATS_INC(tcp.drop);
   \                     ??tcp_input_2:
   \   00000084   B609D8E1           LDRH     R0,[R8, #+150]
   \   00000088   010080E2           ADD      R0,R0,#+1
   \   0000008C   B609C8E1           STRH     R0,[R8, #+150]
    424            snmp_inc_tcpinerrs();
    425            pbuf_free(p);
   \                     ??tcp_input_3:
   \   00000090   0700A0E1           MOV      R0,R7
   \   00000094   ........           _BLF     pbuf_free,??pbuf_free??rA
    426          }
   \                     ??tcp_input_4:
   \   00000098   670100EA           B        ??tcp_input_5
   \                     ??tcp_input_1:
   \   0000009C   ........           LDR      R9,??DataTable20  ;; current_iphdr_dest
   \   000000A0   0610A0E1           MOV      R1,R6
   \   000000A4   000099E5           LDR      R0,[R9, #+0]
   \   000000A8   ........           _BLF     ip4_addr_isbroadcast,??ip4_addr_isbroadcast??rA
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0300001A           BNE      ??tcp_input_6
   \   000000B4   000099E5           LDR      R0,[R9, #+0]
   \   000000B8   F00000E2           AND      R0,R0,#0xF0
   \   000000BC   E00050E3           CMP      R0,#+224
   \   000000C0   0300001A           BNE      ??tcp_input_7
   \                     ??tcp_input_6:
   \   000000C4   B00AD8E1           LDRH     R0,[R8, #+160]
   \   000000C8   010080E2           ADD      R0,R0,#+1
   \   000000CC   B00AC8E1           STRH     R0,[R8, #+160]
   \   000000D0   EBFFFFEA           B        ??tcp_input_2
   \                     ??tcp_input_7:
   \   000000D4   B800D7E1           LDRH     R0,[R7, #+8]
   \   000000D8   ........           LDR      R1,??DataTable21  ;; current_iphdr_src
   \   000000DC   0630A0E3           MOV      R3,#+6
   \   000000E0   01002DE9           PUSH     {R0}
   \   000000E4   0920A0E1           MOV      R2,R9
   \   000000E8   0700A0E1           MOV      R0,R7
   \   000000EC   ........           _BLF     inet_chksum_pseudo,??inet_chksum_pseudo??rA
   \   000000F0   000050E3           CMP      R0,#+0
   \   000000F4   04D08DE2           ADD      SP,SP,#+4
   \   000000F8   0300000A           BEQ      ??tcp_input_8
   \   000000FC   B809D8E1           LDRH     R0,[R8, #+152]
   \   00000100   010080E2           ADD      R0,R0,#+1
   \   00000104   B809C8E1           STRH     R0,[R8, #+152]
   \   00000108   DDFFFFEA           B        ??tcp_input_2
   \                     ??tcp_input_8:
   \   0000010C   140095E5           LDR      R0,[R5, #+20]
   \   00000110   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000114   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000118   010480E1           ORR      R0,R0,R1, LSL #+8
   \   0000011C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000120   2006A0E1           LSR      R0,R0,#+12
   \   00000124   0001A0E1           LSL      R0,R0,#+2
   \   00000128   001060E2           RSB      R1,R0,#+0
   \   0000012C   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000130   4118A0E1           MOV      R1,R1, ASR #+16
   \   00000134   0700A0E1           MOV      R0,R7
   \   00000138   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   0000013C   000050E3           CMP      R0,#+0
   \   00000140   CCFFFF1A           BNE      ??tcp_input_0
   \   00000144   140095E5           LDR      R0,[R5, #+20]
   \   00000148   0110D0E5           LDRB     R1,[R0, #+1]
   \   0000014C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000150   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000154   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000158   141095E5           LDR      R1,[R5, #+20]
   \   0000015C   0000C1E5           STRB     R0,[R1, #+0]
   \   00000160   2004A0E1           LSR      R0,R0,#+8
   \   00000164   0100C1E5           STRB     R0,[R1, #+1]
   \   00000168   0300D1E5           LDRB     R0,[R1, #+3]
   \   0000016C   0210D1E5           LDRB     R1,[R1, #+2]
   \   00000170   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000174   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000178   141095E5           LDR      R1,[R5, #+20]
   \   0000017C   0200C1E5           STRB     R0,[R1, #+2]
   \   00000180   2004A0E1           LSR      R0,R0,#+8
   \   00000184   0300C1E5           STRB     R0,[R1, #+3]
   \   00000188   0700D1E5           LDRB     R0,[R1, #+7]
   \   0000018C   0620D1E5           LDRB     R2,[R1, #+6]
   \   00000190   000482E1           ORR      R0,R2,R0, LSL #+8
   \   00000194   0520D1E5           LDRB     R2,[R1, #+5]
   \   00000198   0410D1E5           LDRB     R1,[R1, #+4]
   \   0000019C   000482E1           ORR      R0,R2,R0, LSL #+8
   \   000001A0   000481E1           ORR      R0,R1,R0, LSL #+8
   \   000001A4   ........           _BLF     lwip_ntohl,??lwip_ntohl??rA
   \   000001A8   141095E5           LDR      R1,[R5, #+20]
   \   000001AC   2024A0E1           LSR      R2,R0,#+8
   \   000001B0   0400C1E5           STRB     R0,[R1, #+4]
   \   000001B4   0520C1E5           STRB     R2,[R1, #+5]
   \   000001B8   2224A0E1           LSR      R2,R2,#+8
   \   000001BC   0620C1E5           STRB     R2,[R1, #+6]
   \   000001C0   2224A0E1           LSR      R2,R2,#+8
   \   000001C4   0720C1E5           STRB     R2,[R1, #+7]
   \   000001C8   180085E5           STR      R0,[R5, #+24]
   \   000001CC   0B00D1E5           LDRB     R0,[R1, #+11]
   \   000001D0   0A20D1E5           LDRB     R2,[R1, #+10]
   \   000001D4   000482E1           ORR      R0,R2,R0, LSL #+8
   \   000001D8   0920D1E5           LDRB     R2,[R1, #+9]
   \   000001DC   0810D1E5           LDRB     R1,[R1, #+8]
   \   000001E0   000482E1           ORR      R0,R2,R0, LSL #+8
   \   000001E4   000481E1           ORR      R0,R1,R0, LSL #+8
   \   000001E8   ........           _BLF     lwip_ntohl,??lwip_ntohl??rA
   \   000001EC   141095E5           LDR      R1,[R5, #+20]
   \   000001F0   2024A0E1           LSR      R2,R0,#+8
   \   000001F4   0800C1E5           STRB     R0,[R1, #+8]
   \   000001F8   0920C1E5           STRB     R2,[R1, #+9]
   \   000001FC   2224A0E1           LSR      R2,R2,#+8
   \   00000200   0A20C1E5           STRB     R2,[R1, #+10]
   \   00000204   2224A0E1           LSR      R2,R2,#+8
   \   00000208   0B20C1E5           STRB     R2,[R1, #+11]
   \   0000020C   1C0085E5           STR      R0,[R5, #+28]
   \   00000210   0F00D1E5           LDRB     R0,[R1, #+15]
   \   00000214   0E10D1E5           LDRB     R1,[R1, #+14]
   \   00000218   000481E1           ORR      R0,R1,R0, LSL #+8
   \   0000021C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000220   141095E5           LDR      R1,[R5, #+20]
   \   00000224   0E00C1E5           STRB     R0,[R1, #+14]
   \   00000228   2004A0E1           LSR      R0,R0,#+8
   \   0000022C   0F00C1E5           STRB     R0,[R1, #+15]
   \   00000230   0D00D1E5           LDRB     R0,[R1, #+13]
   \   00000234   0C10D1E5           LDRB     R1,[R1, #+12]
   \   00000238   000481E1           ORR      R0,R1,R0, LSL #+8
   \   0000023C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000240   3F0000E2           AND      R0,R0,#0x3F
   \   00000244   2800C5E5           STRB     R0,[R5, #+40]
   \   00000248   B810D7E1           LDRH     R1,[R7, #+8]
   \   0000024C   030010E3           TST      R0,#0x3
   \   00000250   0100A013           MOVNE    R0,#+1
   \   00000254   0000A003           MOVEQ    R0,#+0
   \   00000258   010080E0           ADD      R0,R0,R1
   \   0000025C   ........           LDR      R1,??DataTable22  ;; tcp_active_pcbs
   \   00000260   B001C5E1           STRH     R0,[R5, #+16]
   \   00000264   006091E5           LDR      R6,[R1, #+0]
   \   00000268   00C0A0E3           MOV      R12,#+0
   \   0000026C   010000EA           B        ??tcp_input_9
   \                     ??tcp_input_10:
   \   00000270   06C0A0E1           MOV      R12,R6
   \   00000274   0C6096E5           LDR      R6,[R6, #+12]
   \                     ??tcp_input_9:
   \   00000278   141095E5           LDR      R1,[R5, #+20]
   \   0000027C   0120D1E5           LDRB     R2,[R1, #+1]
   \   00000280   0030D1E5           LDRB     R3,[R1, #+0]
   \   00000284   000056E3           CMP      R6,#+0
   \   00000288   02E483E1           ORR      LR,R3,R2, LSL #+8
   \   0000028C   0320D1E5           LDRB     R2,[R1, #+3]
   \   00000290   0230D1E5           LDRB     R3,[R1, #+2]
   \   00000294   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000298   ........           LDR      R3,??DataTable21  ;; current_iphdr_src
   \   0000029C   00A093E5           LDR      R10,[R3, #+0]
   \   000002A0   003099E5           LDR      R3,[R9, #+0]
   \   000002A4   2E00000A           BEQ      ??tcp_input_11
   \   000002A8   BCB1D6E1           LDRH     R11,[R6, #+28]
   \   000002AC   0E005BE1           CMP      R11,LR
   \   000002B0   BAB1D601           LDRHEQ   R11,[R6, #+26]
   \   000002B4   02005B01           CMPEQ    R11,R2
   \   000002B8   04209605           LDREQ    R2,[R6, #+4]
   \   000002BC   0A005201           CMPEQ    R2,R10
   \   000002C0   00209605           LDREQ    R2,[R6, #+0]
   \   000002C4   03005201           CMPEQ    R2,R3
   \   000002C8   E8FFFF1A           BNE      ??tcp_input_10
   \   000002CC   00005CE3           CMP      R12,#+0
   \   000002D0   0600000A           BEQ      ??tcp_input_12
   \   000002D4   0C0096E5           LDR      R0,[R6, #+12]
   \   000002D8   0C008CE5           STR      R0,[R12, #+12]
   \   000002DC   ........           LDR      R0,??DataTable22  ;; tcp_active_pcbs
   \   000002E0   000090E5           LDR      R0,[R0, #+0]
   \   000002E4   0C0086E5           STR      R0,[R6, #+12]
   \   000002E8   ........           LDR      R0,??DataTable22  ;; tcp_active_pcbs
   \   000002EC   006080E5           STR      R6,[R0, #+0]
   \                     ??tcp_input_12:
   \   000002F0   004085E5           STR      R4,[R5, #+0]
   \   000002F4   B800D7E1           LDRH     R0,[R7, #+8]
   \   000002F8   047085E5           STR      R7,[R5, #+4]
   \   000002FC   0C1085E5           STR      R1,[R5, #+12]
   \   00000300   B800C5E1           STRH     R0,[R5, #+8]
   \   00000304   2800D5E5           LDRB     R0,[R5, #+40]
   \   00000308   204085E5           STR      R4,[R5, #+32]
   \   0000030C   2940C5E5           STRB     R4,[R5, #+41]
   \   00000310   080010E3           TST      R0,#0x8
   \   00000314   0D00D715           LDRBNE   R0,[R7, #+13]
   \   00000318   01008013           ORRNE    R0,R0,#0x1
   \   0000031C   0D00C715           STRBNE   R0,[R7, #+13]
   \   00000320   780096E5           LDR      R0,[R6, #+120]
   \   00000324   0970E0E3           MVN      R7,#+9
   \   00000328   000050E3           CMP      R0,#+0
   \   0000032C   5B00000A           BEQ      ??tcp_input_13
   \   00000330   0600A0E1           MOV      R0,R6
   \   00000334   ........           _BLF     tcp_process_refused_data,??tcp_process_refused_data??rA
   \   00000338   070050E1           CMP      R0,R7
   \   0000033C   0400000A           BEQ      ??tcp_input_14
   \   00000340   780096E5           LDR      R0,[R6, #+120]
   \   00000344   000050E3           CMP      R0,#+0
   \   00000348   B001D511           LDRHNE   R0,[R5, #+16]
   \   0000034C   00005013           CMPNE    R0,#+0
   \   00000350   5200000A           BEQ      ??tcp_input_13
   \                     ??tcp_input_14:
   \   00000354   B609D8E1           LDRH     R0,[R8, #+150]
   \   00000358   010080E2           ADD      R0,R0,#+1
   \   0000035C   B609C8E1           STRH     R0,[R8, #+150]
   \   00000360   AE0000EA           B        ??tcp_input_15
   \                     ??tcp_input_11:
   \   00000364   ........           LDR      R6,??DataTable25  ;; tcp_tw_pcbs
   \   00000368   006096E5           LDR      R6,[R6, #+0]
   \   0000036C   000000EA           B        ??tcp_input_16
   \                     ??tcp_input_17:
   \   00000370   0C6096E5           LDR      R6,[R6, #+12]
   \                     ??tcp_input_16:
   \   00000374   000056E3           CMP      R6,#+0
   \   00000378   2900000A           BEQ      ??tcp_input_18
   \   0000037C   BCB1D6E1           LDRH     R11,[R6, #+28]
   \   00000380   0E005BE1           CMP      R11,LR
   \   00000384   BAB1D601           LDRHEQ   R11,[R6, #+26]
   \   00000388   02005B01           CMPEQ    R11,R2
   \   0000038C   04B09605           LDREQ    R11,[R6, #+4]
   \   00000390   0A005B01           CMPEQ    R11,R10
   \   00000394   00B09605           LDREQ    R11,[R6, #+0]
   \   00000398   03005B01           CMPEQ    R11,R3
   \   0000039C   F3FFFF1A           BNE      ??tcp_input_17
   \   000003A0   2810D5E5           LDRB     R1,[R5, #+40]
   \   000003A4   040011E3           TST      R1,#0x4
   \   000003A8   38FFFF1A           BNE      ??tcp_input_3
   \   000003AC   020011E3           TST      R1,#0x2
   \   000003B0   0F00000A           BEQ      ??tcp_input_19
   \   000003B4   181095E5           LDR      R1,[R5, #+24]
   \   000003B8   283096E5           LDR      R3,[R6, #+40]
   \   000003BC   033051E0           SUBS     R3,R1,R3
   \   000003C0   0F00004A           BMI      ??tcp_input_20
   \   000003C4   BC42D6E1           LDRH     R4,[R6, #+44]
   \   000003C8   043043E0           SUB      R3,R3,R4
   \   000003CC   010053E3           CMP      R3,#+1
   \   000003D0   0B0000AA           BGE      ??tcp_input_20
   \   000003D4   ........           LDR      R3,??DataTable21  ;; current_iphdr_src
   \   000003D8   00402DE9           PUSH     {LR}
   \   000003DC   04002DE9           PUSH     {R2}
   \   000003E0   0920A0E1           MOV      R2,R9
   \   000003E4   0008A0E1           MOV      R0,R0, LSL #+16
   \   000003E8   2008A0E1           MOV      R0,R0, LSR #+16
   \   000003EC   011080E0           ADD      R1,R0,R1
   \   000003F0   AD0000EA           B        ??tcp_input_21
   \                     ??tcp_input_19:
   \   000003F4   010011E3           TST      R1,#0x1
   \   000003F8   ........           LDRNE    R1,??DataTable23  ;; tcp_ticks
   \   000003FC   00109115           LDRNE    R1,[R1, #+0]
   \   00000400   24108615           STRNE    R1,[R6, #+36]
   \                     ??tcp_input_20:
   \   00000404   0008B0E1           LSLS     R0,R0,#+16
   \   00000408   20FFFF0A           BEQ      ??tcp_input_3
   \   0000040C   1E00D6E5           LDRB     R0,[R6, #+30]
   \   00000410   020080E3           ORR      R0,R0,#0x2
   \   00000414   1E00C6E5           STRB     R0,[R6, #+30]
   \   00000418   0600A0E1           MOV      R0,R6
   \   0000041C   ........           _BLF     tcp_output,??tcp_output??rA
   \   00000420   1AFFFFEA           B        ??tcp_input_3
   \                     ??tcp_input_18:
   \   00000424   90429FE5           LDR      R4,??tcp_input_22  ;; tcp_listen_pcbs
   \   00000428   00C0A0E3           MOV      R12,#+0
   \   0000042C   000094E5           LDR      R0,[R4, #+0]
   \   00000430   0B0000EA           B        ??tcp_input_23
   \                     ??tcp_input_24:
   \   00000434   BA61D0E1           LDRH     R6,[R0, #+26]
   \   00000438   020056E1           CMP      R6,R2
   \   0000043C   0600001A           BNE      ??tcp_input_25
   \   00000440   006090E5           LDR      R6,[R0, #+0]
   \   00000444   030056E1           CMP      R6,R3
   \   00000448   0B00000A           BEQ      ??tcp_input_26
   \   0000044C   000050E3           CMP      R0,#+0
   \   00000450   00005613           CMPNE    R6,#+0
   \   00000454   00008D05           STREQ    R0,[SP, #+0]
   \   00000458   04C08D05           STREQ    R12,[SP, #+4]
   \                     ??tcp_input_25:
   \   0000045C   00C0A0E1           MOV      R12,R0
   \   00000460   0C0090E5           LDR      R0,[R0, #+12]
   \                     ??tcp_input_23:
   \   00000464   000050E3           CMP      R0,#+0
   \   00000468   F1FFFF1A           BNE      ??tcp_input_24
   \   0000046C   00009DE5           LDR      R0,[SP, #+0]
   \   00000470   04C09DE5           LDR      R12,[SP, #+4]
   \   00000474   000050E3           CMP      R0,#+0
   \   00000478   7100000A           BEQ      ??tcp_input_27
   \                     ??tcp_input_26:
   \   0000047C   00005CE3           CMP      R12,#+0
   \   00000480   0400000A           BEQ      ??tcp_input_28
   \   00000484   0C1090E5           LDR      R1,[R0, #+12]
   \   00000488   0C108CE5           STR      R1,[R12, #+12]
   \   0000048C   001094E5           LDR      R1,[R4, #+0]
   \   00000490   0C1080E5           STR      R1,[R0, #+12]
   \   00000494   000084E5           STR      R0,[R4, #+0]
   \                     ??tcp_input_28:
   \   00000498   ........           BL       tcp_listen_input
   \   0000049C   FBFEFFEA           B        ??tcp_input_3
   \                     ??tcp_input_13:
   \   000004A0   246085E5           STR      R6,[R5, #+36]
   \   000004A4   0600A0E1           MOV      R0,R6
   \   000004A8   ........           BL       tcp_process
   \   000004AC   070050E1           CMP      R0,R7
   \   000004B0   5A00000A           BEQ      ??tcp_input_15
   \   000004B4   2910D5E5           LDRB     R1,[R5, #+41]
   \   000004B8   100096E5           LDR      R0,[R6, #+16]
   \   000004BC   8C2096E5           LDR      R2,[R6, #+140]
   \   000004C0   080011E3           TST      R1,#0x8
   \   000004C4   0B00000A           BEQ      ??tcp_input_29
   \   000004C8   000052E3           CMP      R2,#+0
   \   000004CC   0200000A           BEQ      ??tcp_input_30
   \   000004D0   011047E2           SUB      R1,R7,#+1
   \                     ??tcp_input_31:
   \   000004D4   0FE0A0E1           MOV      LR,PC
   \   000004D8   12FF2FE1           BX       R2
   \                     ??tcp_input_30:
   \   000004DC   ........           LDR      R0,??DataTable22  ;; tcp_active_pcbs
   \   000004E0   0610A0E1           MOV      R1,R6
   \   000004E4   ........           _BLF     tcp_pcb_remove,??tcp_pcb_remove??rA
   \   000004E8   0610A0E1           MOV      R1,R6
   \   000004EC   0200A0E3           MOV      R0,#+2
   \   000004F0   ........           _BLF     memp_free,??memp_free??rA
   \   000004F4   490000EA           B        ??tcp_input_15
   \                     ??tcp_input_29:
   \   000004F8   100011E3           TST      R1,#0x10
   \   000004FC   0600000A           BEQ      ??tcp_input_32
   \   00000500   1E10D6E5           LDRB     R1,[R6, #+30]
   \   00000504   100011E3           TST      R1,#0x10
   \   00000508   F3FFFF1A           BNE      ??tcp_input_30
   \   0000050C   000052E3           CMP      R2,#+0
   \   00000510   F1FFFF0A           BEQ      ??tcp_input_30
   \   00000514   0210C7E3           BIC      R1,R7,#0x2
   \   00000518   EDFFFFEA           B        ??tcp_input_31
   \                     ??tcp_input_32:
   \   0000051C   B426D6E1           LDRH     R2,[R6, #+100]
   \   00000520   000052E3           CMP      R2,#+0
   \   00000524   7C309615           LDRNE    R3,[R6, #+124]
   \   00000528   00005313           CMPNE    R3,#+0
   \   0000052C   0400000A           BEQ      ??tcp_input_33
   \   00000530   0610A0E1           MOV      R1,R6
   \   00000534   0FE0A0E1           MOV      LR,PC
   \   00000538   13FF2FE1           BX       R3
   \   0000053C   070050E1           CMP      R0,R7
   \   00000540   3600000A           BEQ      ??tcp_input_15
   \                     ??tcp_input_33:
   \   00000544   202095E5           LDR      R2,[R5, #+32]
   \   00000548   000052E3           CMP      R2,#+0
   \   0000054C   1700000A           BEQ      ??tcp_input_34
   \   00000550   1E00D6E5           LDRB     R0,[R6, #+30]
   \   00000554   100010E3           TST      R0,#0x10
   \   00000558   0400000A           BEQ      ??tcp_input_35
   \   0000055C   0200A0E1           MOV      R0,R2
   \   00000560   ........           _BLF     pbuf_free,??pbuf_free??rA
   \   00000564   0600A0E1           MOV      R0,R6
   \   00000568   ........           _BLF     tcp_abort,??tcp_abort??rA
   \   0000056C   2B0000EA           B        ??tcp_input_15
   \                     ??tcp_input_35:
   \   00000570   808096E5           LDR      R8,[R6, #+128]
   \   00000574   0030A0E3           MOV      R3,#+0
   \   00000578   000058E3           CMP      R8,#+0
   \   0000057C   0610A0E1           MOV      R1,R6
   \   00000580   0300000A           BEQ      ??tcp_input_36
   \   00000584   100096E5           LDR      R0,[R6, #+16]
   \   00000588   0FE0A0E1           MOV      LR,PC
   \   0000058C   18FF2FE1           BX       R8
   \   00000590   010000EA           B        ??tcp_input_37
   \                     ??tcp_input_36:
   \   00000594   0000A0E3           MOV      R0,#+0
   \   00000598   ........           _BLF     tcp_recv_null,??tcp_recv_null??rA
   \                     ??tcp_input_37:
   \   0000059C   070050E1           CMP      R0,R7
   \   000005A0   1E00000A           BEQ      ??tcp_input_15
   \   000005A4   000050E3           CMP      R0,#+0
   \   000005A8   20009515           LDRNE    R0,[R5, #+32]
   \   000005AC   78008615           STRNE    R0,[R6, #+120]
   \                     ??tcp_input_34:
   \   000005B0   2900D5E5           LDRB     R0,[R5, #+41]
   \   000005B4   200010E3           TST      R0,#0x20
   \   000005B8   1500000A           BEQ      ??tcp_input_38
   \   000005BC   780096E5           LDR      R0,[R6, #+120]
   \   000005C0   000050E3           CMP      R0,#+0
   \   000005C4   0300000A           BEQ      ??tcp_input_39
   \   000005C8   0D10D0E5           LDRB     R1,[R0, #+13]
   \   000005CC   201081E3           ORR      R1,R1,#0x20
   \   000005D0   0D10C0E5           STRB     R1,[R0, #+13]
   \   000005D4   0E0000EA           B        ??tcp_input_38
   \                     ??tcp_input_39:
   \   000005D8   BC02D6E1           LDRH     R0,[R6, #+44]
   \   000005DC   860E50E3           CMP      R0,#+2144
   \   000005E0   01008012           ADDNE    R0,R0,#+1
   \   000005E4   BC02C611           STRHNE   R0,[R6, #+44]
   \   000005E8   808096E5           LDR      R8,[R6, #+128]
   \   000005EC   000058E3           CMP      R8,#+0
   \   000005F0   0700000A           BEQ      ??tcp_input_38
   \   000005F4   100096E5           LDR      R0,[R6, #+16]
   \   000005F8   0030A0E3           MOV      R3,#+0
   \   000005FC   0320A0E1           MOV      R2,R3
   \   00000600   0610A0E1           MOV      R1,R6
   \   00000604   0FE0A0E1           MOV      LR,PC
   \   00000608   18FF2FE1           BX       R8
   \   0000060C   070050E1           CMP      R0,R7
   \   00000610   0200000A           BEQ      ??tcp_input_15
   \                     ??tcp_input_38:
   \   00000614   244085E5           STR      R4,[R5, #+36]
   \   00000618   0600A0E1           MOV      R0,R6
   \   0000061C   ........           _BLF     tcp_output,??tcp_output??rA
   \                     ??tcp_input_15:
   \   00000620   040095E5           LDR      R0,[R5, #+4]
   \   00000624   244085E5           STR      R4,[R5, #+36]
   \   00000628   204085E5           STR      R4,[R5, #+32]
   \   0000062C   000050E3           CMP      R0,#+0
   \   00000630   0100000A           BEQ      ??tcp_input_5
   \   00000634   ........           _BLF     pbuf_free,??pbuf_free??rA
   \   00000638   044085E5           STR      R4,[R5, #+4]
   \                     ??tcp_input_5:
   \   0000063C   F34FBDE8           POP      {R0,R1,R4-R11,LR}
   \   00000640   1EFF2FE1           BX       LR
   \                     ??tcp_input_27:
   \   00000644   0D00D1E5           LDRB     R0,[R1, #+13]
   \   00000648   0C10D1E5           LDRB     R1,[R1, #+12]
   \   0000064C   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000650   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000654   040010E3           TST      R0,#0x4
   \   00000658   8CFEFF1A           BNE      ??tcp_input_3
   \   0000065C   B00AD8E1           LDRH     R0,[R8, #+160]
   \   00000660   ........           LDR      R3,??DataTable21  ;; current_iphdr_src
   \   00000664   010080E2           ADD      R0,R0,#+1
   \   00000668   B00AC8E1           STRH     R0,[R8, #+160]
   \   0000066C   B609D8E1           LDRH     R0,[R8, #+150]
   \   00000670   010080E2           ADD      R0,R0,#+1
   \   00000674   B609C8E1           STRH     R0,[R8, #+150]
   \   00000678   140095E5           LDR      R0,[R5, #+20]
   \   0000067C   0110D0E5           LDRB     R1,[R0, #+1]
   \   00000680   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000684   011482E1           ORR      R1,R2,R1, LSL #+8
   \   00000688   02002DE9           PUSH     {R1}
   \   0000068C   0310D0E5           LDRB     R1,[R0, #+3]
   \   00000690   0200D0E5           LDRB     R0,[R0, #+2]
   \   00000694   0920A0E1           MOV      R2,R9
   \   00000698   010480E1           ORR      R0,R0,R1, LSL #+8
   \   0000069C   01002DE9           PUSH     {R0}
   \   000006A0   B011D5E1           LDRH     R1,[R5, #+16]
   \   000006A4   180095E5           LDR      R0,[R5, #+24]
   \   000006A8   001081E0           ADD      R1,R1,R0
   \                     ??tcp_input_21:
   \   000006AC   1C0095E5           LDR      R0,[R5, #+28]
   \   000006B0   ........           _BLF     tcp_rst,??tcp_rst??rA
   \   000006B4   08D08DE2           ADD      SP,SP,#+8
   \   000006B8   74FEFFEA           B        ??tcp_input_3
   \                     ??tcp_input_22:
   \   000006BC   ........           DC32     tcp_listen_pcbs
    427          
    428          /**
    429           * Called by tcp_input() when a segment arrives for a listening
    430           * connection (from tcp_input()).
    431           *
    432           * @param pcb the tcp_pcb_listen for which a segment arrived
    433           * @return ERR_OK if the segment was processed
    434           *         another err_t on error
    435           *
    436           * @note the return value is not (yet?) used in tcp_input()
    437           * @note the segment which arrived is saved in global variables, therefore only the pcb
    438           *       involved is passed as a parameter to this function
    439           */

   \                                 In segment CODE, align 4, keep-with-next
    440          static err_t
    441          tcp_listen_input(struct tcp_pcb_listen *pcb)
    442          {
   \                     tcp_listen_input:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    443            struct tcp_pcb *npcb;
    444            err_t rc;
    445          
    446            if (flags & TCP_RST) {
   \   00000004   ........           LDR      R6,??DataTable19  ;; inseg
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   2800D6E5           LDRB     R0,[R6, #+40]
   \   00000010   040010E3           TST      R0,#0x4
   \   00000014   0000000A           BEQ      ??tcp_listen_input_0
    447              /* An incoming RST should be ignored. Return. */
    448              return ERR_OK;
   \                     ??tcp_listen_input_1:
   \   00000018   140000EA           B        ??tcp_listen_input_2
    449            }
    450          
    451            /* In the LISTEN state, we check for incoming SYN segments,
    452               creates a new PCB, and responds with a SYN|ACK. */
    453            if (flags & TCP_ACK) {
   \                     ??tcp_listen_input_0:
   \   0000001C   ........           LDR      R7,??DataTable20  ;; current_iphdr_dest
   \   00000020   ........           LDR      R8,??DataTable21  ;; current_iphdr_src
   \   00000024   100010E3           TST      R0,#0x10
   \   00000028   1300000A           BEQ      ??tcp_listen_input_3
    454              /* For incoming segments with the ACK flag set, respond with a
    455                 RST. */
    456              LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    457              tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
    458                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
   \   0000002C   140096E5           LDR      R0,[R6, #+20]
   \   00000030   0110D0E5           LDRB     R1,[R0, #+1]
   \   00000034   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000038   0830A0E1           MOV      R3,R8
   \   0000003C   011482E1           ORR      R1,R2,R1, LSL #+8
   \   00000040   02002DE9           PUSH     {R1}
   \   00000044   0310D0E5           LDRB     R1,[R0, #+3]
   \   00000048   0200D0E5           LDRB     R0,[R0, #+2]
   \   0000004C   0720A0E1           MOV      R2,R7
   \   00000050   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000054   01002DE9           PUSH     {R0}
   \   00000058   B011D6E1           LDRH     R1,[R6, #+16]
   \   0000005C   180096E5           LDR      R0,[R6, #+24]
   \   00000060   001081E0           ADD      R1,R1,R0
   \   00000064   1C0096E5           LDR      R0,[R6, #+28]
   \   00000068   ........           _BLF     tcp_rst,??tcp_rst??rA
   \   0000006C   08D08DE2           ADD      SP,SP,#+8
   \                     ??tcp_listen_input_2:
   \   00000070   F041BDE8           POP      {R4-R8,LR}
   \   00000074   0000A0E3           MOV      R0,#+0
   \   00000078   1EFF2FE1           BX       LR
    459            } else if (flags & TCP_SYN) {
   \                     ??tcp_listen_input_3:
   \   0000007C   020010E3           TST      R0,#0x2
   \   00000080   FAFFFF0A           BEQ      ??tcp_listen_input_2
    460              LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
    461          #if TCP_LISTEN_BACKLOG
    462              if (pcb->accepts_pending >= pcb->backlog) {
    463                LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
    464                return ERR_ABRT;
    465              }
    466          #endif /* TCP_LISTEN_BACKLOG */
    467              npcb = tcp_alloc(pcb->prio);
   \   00000084   1900D4E5           LDRB     R0,[R4, #+25]
   \   00000088   ........           _BLF     tcp_alloc,??tcp_alloc??rA
   \   0000008C   0050B0E1           MOVS     R5,R0
    468              /* If a new PCB could not be created (probably due to lack of memory),
    469                 we don't do anything, but rely on the sender will retransmit the
    470                 SYN at a time when we have more memory available. */
    471              if (npcb == NULL) {
   \   00000090   0600001A           BNE      ??tcp_listen_input_4
    472                LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
    473                TCP_STATS_INC(tcp.memerr);
   \   00000094   ........           LDR      R0,??DataTable16  ;; lwip_stats
   \   00000098   BC19D0E1           LDRH     R1,[R0, #+156]
   \   0000009C   011081E2           ADD      R1,R1,#+1
   \   000000A0   BC19C0E1           STRH     R1,[R0, #+156]
    474                return ERR_MEM;
   \   000000A4   F041BDE8           POP      {R4-R8,LR}
   \   000000A8   0000E0E3           MVN      R0,#+0
   \   000000AC   1EFF2FE1           BX       LR
    475              }
    476          #if TCP_LISTEN_BACKLOG
    477              pcb->accepts_pending++;
    478          #endif /* TCP_LISTEN_BACKLOG */
    479              /* Set up the new PCB. */
    480              ip_addr_copy(npcb->local_ip, current_iphdr_dest);
   \                     ??tcp_listen_input_4:
   \   000000B0   000097E5           LDR      R0,[R7, #+0]
   \   000000B4   000085E5           STR      R0,[R5, #+0]
    481              npcb->local_port = pcb->local_port;
   \   000000B8   BA01D4E1           LDRH     R0,[R4, #+26]
   \   000000BC   BA01C5E1           STRH     R0,[R5, #+26]
    482              ip_addr_copy(npcb->remote_ip, current_iphdr_src);
   \   000000C0   000098E5           LDR      R0,[R8, #+0]
   \   000000C4   040085E5           STR      R0,[R5, #+4]
    483              npcb->remote_port = tcphdr->src;
   \   000000C8   140096E5           LDR      R0,[R6, #+20]
   \   000000CC   0110D0E5           LDRB     R1,[R0, #+1]
   \   000000D0   0020D0E5           LDRB     R2,[R0, #+0]
   \   000000D4   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000000D8   BC11C5E1           STRH     R1,[R5, #+28]
    484              npcb->state = SYN_RCVD;
   \   000000DC   0310A0E3           MOV      R1,#+3
   \   000000E0   1810C5E5           STRB     R1,[R5, #+24]
    485              npcb->rcv_nxt = seqno + 1;
   \   000000E4   181096E5           LDR      R1,[R6, #+24]
   \   000000E8   012081E2           ADD      R2,R1,#+1
   \   000000EC   282085E5           STR      R2,[R5, #+40]
    486              npcb->rcv_ann_right_edge = npcb->rcv_nxt;
   \   000000F0   302085E5           STR      R2,[R5, #+48]
    487              npcb->snd_wnd = tcphdr->wnd;
   \   000000F4   0F20D0E5           LDRB     R2,[R0, #+15]
   \   000000F8   0E30D0E5           LDRB     R3,[R0, #+14]
   \   000000FC   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000100   B026C5E1           STRH     R2,[R5, #+96]
    488              npcb->snd_wnd_max = tcphdr->wnd;
   \   00000104   0F20D0E5           LDRB     R2,[R0, #+15]
   \   00000108   0E00D0E5           LDRB     R0,[R0, #+14]
   \   0000010C   020480E1           ORR      R0,R0,R2, LSL #+8
   \   00000110   B206C5E1           STRH     R0,[R5, #+98]
    489              npcb->ssthresh = npcb->snd_wnd;
   \   00000114   B006D5E1           LDRH     R0,[R5, #+96]
   \   00000118   BE04C5E1           STRH     R0,[R5, #+78]
    490              npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
   \   0000011C   010041E2           SUB      R0,R1,#+1
   \   00000120   540085E5           STR      R0,[R5, #+84]
    491              npcb->callback_arg = pcb->callback_arg;
   \   00000124   100094E5           LDR      R0,[R4, #+16]
   \   00000128   100085E5           STR      R0,[R5, #+16]
    492          #if LWIP_CALLBACK_API
    493              npcb->accept = pcb->accept;
   \   0000012C   140094E5           LDR      R0,[R4, #+20]
   \   00000130   140085E5           STR      R0,[R5, #+20]
    494          #endif /* LWIP_CALLBACK_API */
    495              /* inherit socket options */
    496              npcb->so_options = pcb->so_options & SOF_INHERITED;
   \   00000134   0800D4E5           LDRB     R0,[R4, #+8]
   \   00000138   8C0000E2           AND      R0,R0,#0x8C
   \   0000013C   0800C5E5           STRB     R0,[R5, #+8]
    497              /* Register the new PCB so that we can begin receiving segments
    498                 for it. */
    499              TCP_REG_ACTIVE(npcb);
   \   00000140   ........           LDR      R0,??DataTable22  ;; tcp_active_pcbs
   \   00000144   001090E5           LDR      R1,[R0, #+0]
   \   00000148   0C1085E5           STR      R1,[R5, #+12]
   \   0000014C   005080E5           STR      R5,[R0, #+0]
   \   00000150   ........           _BLF     tcp_timer_needed,??tcp_timer_needed??rA
   \   00000154   ........           LDR      R0,??DataTable24  ;; tcp_active_pcbs_changed
   \   00000158   0110A0E3           MOV      R1,#+1
   \   0000015C   0010C0E5           STRB     R1,[R0, #+0]
    500          
    501              /* Parse any options in the SYN. */
    502              tcp_parseopt(npcb);
   \   00000160   0500A0E1           MOV      R0,R5
   \   00000164   ........           BL       tcp_parseopt
    503          #if TCP_CALCULATE_EFF_SEND_MSS
    504              npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
   \   00000168   B603D5E1           LDRH     R0,[R5, #+54]
   \   0000016C   041085E2           ADD      R1,R5,#+4
   \   00000170   ........           _BLF     tcp_eff_send_mss,??tcp_eff_send_mss??rA
   \   00000174   B603C5E1           STRH     R0,[R5, #+54]
    505          #endif /* TCP_CALCULATE_EFF_SEND_MSS */
    506          
    507              snmp_inc_tcppassiveopens();
    508          
    509              /* Send a SYN|ACK together with the MSS option. */
    510              rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
   \   00000178   1210A0E3           MOV      R1,#+18
   \   0000017C   0500A0E1           MOV      R0,R5
   \   00000180   ........           _BLF     tcp_enqueue_flags,??tcp_enqueue_flags??rA
   \   00000184   0040B0E1           MOVS     R4,R0
    511              if (rc != ERR_OK) {
   \   00000188   0400000A           BEQ      ??tcp_listen_input_5
    512                tcp_abandon(npcb, 0);
   \   0000018C   0010A0E3           MOV      R1,#+0
   \   00000190   0500A0E1           MOV      R0,R5
   \   00000194   ........           _BLF     tcp_abandon,??tcp_abandon??rA
    513                return rc;
   \   00000198   0400A0E1           MOV      R0,R4
   \   0000019C   010000EA           B        ??tcp_listen_input_6
    514              }
    515              return tcp_output(npcb);
   \                     ??tcp_listen_input_5:
   \   000001A0   0500A0E1           MOV      R0,R5
   \   000001A4   ........           _BLF     tcp_output,??tcp_output??rA
   \                     ??tcp_listen_input_6:
   \   000001A8   F041BDE8           POP      {R4-R8,LR}
   \   000001AC   1EFF2FE1           BX       LR               ;; return
    516            }
    517            return ERR_OK;
    518          }
    519          
    520          /**
    521           * Called by tcp_input() when a segment arrives for a connection in
    522           * TIME_WAIT.
    523           *
    524           * @param pcb the tcp_pcb for which a segment arrived
    525           *
    526           * @note the segment which arrived is saved in global variables, therefore only the pcb
    527           *       involved is passed as a parameter to this function
    528           */
    529          static err_t
    530          tcp_timewait_input(struct tcp_pcb *pcb)
    531          {
    532            /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
    533            /* RFC 793 3.9 Event Processing - Segment Arrives:
    534             * - first check sequence number - we skip that one in TIME_WAIT (always
    535             *   acceptable since we only send ACKs)
    536             * - second check the RST bit (... return) */
    537            if (flags & TCP_RST)  {
    538              return ERR_OK;
    539            }
    540            /* - fourth, check the SYN bit, */
    541            if (flags & TCP_SYN) {
    542              /* If an incoming segment is not acceptable, an acknowledgment
    543                 should be sent in reply */
    544              if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
    545                /* If the SYN is in the window it is an error, send a reset */
    546                tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    547                  tcphdr->dest, tcphdr->src);
    548                return ERR_OK;
    549              }
    550            } else if (flags & TCP_FIN) {
    551              /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
    552                   Restart the 2 MSL time-wait timeout.*/
    553              pcb->tmr = tcp_ticks;
    554            }
    555          
    556            if ((tcplen > 0))  {
    557              /* Acknowledge data, FIN or out-of-window SYN */
    558              pcb->flags |= TF_ACK_NOW;
    559              return tcp_output(pcb);
    560            }
    561            return ERR_OK;
    562          }
    563          
    564          /**
    565           * Implements the TCP state machine. Called by tcp_input. In some
    566           * states tcp_receive() is called to receive data. The tcp_seg
    567           * argument will be freed by the caller (tcp_input()) unless the
    568           * recv_data pointer in the pcb is set.
    569           *
    570           * @param pcb the tcp_pcb for which a segment arrived
    571           *
    572           * @note the segment which arrived is saved in global variables, therefore only the pcb
    573           *       involved is passed as a parameter to this function
    574           */

   \                                 In segment CODE, align 4, keep-with-next
    575          static err_t
    576          tcp_process(struct tcp_pcb *pcb)
    577          {
   \                     tcp_process:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    578            struct tcp_seg *rseg;
    579            u8_t acceptable = 0;
    580            err_t err;
    581          
    582            err = ERR_OK;
    583          
    584            /* Process incoming RST segments. */
    585            if (flags & TCP_RST) {
   \   00000004   ........           LDR      R6,??DataTable19  ;; inseg
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   2810D6E5           LDRB     R1,[R6, #+40]
   \   00000010   1800D4E5           LDRB     R0,[R4, #+24]
   \   00000014   040011E3           TST      R1,#0x4
   \   00000018   1700000A           BEQ      ??tcp_process_1
    586              /* First, determine if the reset is acceptable. */
    587              if (pcb->state == SYN_SENT) {
   \   0000001C   020050E3           CMP      R0,#+2
   \   00000020   0400001A           BNE      ??tcp_process_2
    588                if (ackno == pcb->snd_nxt) {
   \   00000024   1C0096E5           LDR      R0,[R6, #+28]
   \   00000028   501094E5           LDR      R1,[R4, #+80]
   \   0000002C   010050E1           CMP      R0,R1
   \   00000030   0800000A           BEQ      ??tcp_process_3
    589                  acceptable = 1;
    590                }
    591              } else {
    592                if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
    593                                    pcb->rcv_nxt+pcb->rcv_wnd)) {
    594                  acceptable = 1;
    595                }
    596              }
    597          
    598              if (acceptable) {
    599                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
    600                LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
    601                recv_flags |= TF_RESET;
    602                pcb->flags &= ~TF_ACK_DELAY;
    603                return ERR_RST;
    604              } else {
    605                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
    606                 seqno, pcb->rcv_nxt));
    607                LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
    608                 seqno, pcb->rcv_nxt));
    609                return ERR_OK;
   \                     ??tcp_process_4:
   \   00000034   820000EA           B        ??tcp_process_5
    610              }
   \                     ??tcp_process_2:
   \   00000038   180096E5           LDR      R0,[R6, #+24]
   \   0000003C   281094E5           LDR      R1,[R4, #+40]
   \   00000040   010050E0           SUBS     R0,R0,R1
   \   00000044   7E00004A           BMI      ??tcp_process_5
   \   00000048   BC12D4E1           LDRH     R1,[R4, #+44]
   \   0000004C   010040E0           SUB      R0,R0,R1
   \   00000050   010050E3           CMP      R0,#+1
   \   00000054   7A0000AA           BGE      ??tcp_process_5
   \                     ??tcp_process_3:
   \   00000058   2900D6E5           LDRB     R0,[R6, #+41]
   \   0000005C   080080E3           ORR      R0,R0,#0x8
   \   00000060   2900C6E5           STRB     R0,[R6, #+41]
   \   00000064   1E00D4E5           LDRB     R0,[R4, #+30]
   \   00000068   FE0000E2           AND      R0,R0,#0xFE
   \   0000006C   1E00C4E5           STRB     R0,[R4, #+30]
   \   00000070   F04FBDE8           POP      {R4-R11,LR}
   \   00000074   0A00E0E3           MVN      R0,#+10
   \   00000078   1EFF2FE1           BX       LR
    611            }
    612          
    613            if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
   \                     ??tcp_process_1:
   \   0000007C   1E20D4E5           LDRB     R2,[R4, #+30]
   \   00000080   020011E3           TST      R1,#0x2
   \   00000084   02005013           CMPNE    R0,#+2
   \   00000088   03005013           CMPNE    R0,#+3
    614              /* Cope with new connection attempt after remote end crashed */
    615              tcp_ack_now(pcb);
   \   0000008C   02008213           ORRNE    R0,R2,#0x2
   \   00000090   1E00C415           STRBNE   R0,[R4, #+30]
    616              return ERR_OK;
   \   00000094   6A00001A           BNE      ??tcp_process_5
    617            }
    618          
    619            if ((pcb->flags & TF_RXCLOSED) == 0) {
    620              /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    621              pcb->tmr = tcp_ticks;
    622            }
    623            pcb->keep_cnt_sent = 0;
    624          
    625            tcp_parseopt(pcb);
   \   00000098   ........           LDR      R8,??DataTable20  ;; current_iphdr_dest
   \   0000009C   ........           LDR      R9,??DataTable21  ;; current_iphdr_src
   \   000000A0   10A59FE5           LDR      R10,??tcp_process_6  ;; tcp_tmp_pcb
   \   000000A4   ........           LDR      R11,??DataTable22  ;; tcp_active_pcbs
   \   000000A8   100012E3           TST      R2,#0x10
   \   000000AC   ........           LDREQ    R0,??DataTable23  ;; tcp_ticks
   \   000000B0   0070A0E3           MOV      R7,#+0
   \   000000B4   00009005           LDREQ    R0,[R0, #+0]
   \   000000B8   0950E0E3           MVN      R5,#+9
   \   000000BC   24008405           STREQ    R0,[R4, #+36]
   \   000000C0   9E70C4E5           STRB     R7,[R4, #+158]
   \   000000C4   0400A0E1           MOV      R0,R4
   \   000000C8   ........           BL       tcp_parseopt
   \   000000CC   1800D4E5           LDRB     R0,[R4, #+24]
   \   000000D0   020040E2           SUB      R0,R0,#+2
   \   000000D4   070050E3           CMP      R0,#+7
   \   000000D8   5900008A           BHI      ??tcp_process_5
   \   000000DC   021F8FE2           ADR      R1,??tcp_process_0
   \   000000E0   8000A0E1           MOV      R0,R0, LSL #+1
   \   000000E4   B01091E1           LDRH     R1,[R1, R0]
   \   000000E8   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??tcp_process_0:
   \   000000EC   03006D00BB00       DC16     +3,+109,+187,+193
   \              C100        
   \   000000F4   FB00BB001001       DC16     +251,+187,+272,+294
   \              2601        
    626          
    627            /* Do different things depending on the TCP state. */
    628            switch (pcb->state) {
    629            case SYN_SENT:
    630              LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
    631               pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    632              /* received SYN ACK with expected sequence number? */
    633              if ((flags & TCP_ACK) && (flags & TCP_SYN)
    634                  && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
   \                     ??tcp_process_7:
   \   000000FC   2800D6E5           LDRB     R0,[R6, #+40]
   \   00000100   120000E2           AND      R0,R0,#0x12
   \   00000104   120050E3           CMP      R0,#+18
   \   00000108   5000001A           BNE      ??tcp_process_8
   \   0000010C   700094E5           LDR      R0,[R4, #+112]
   \   00000110   0C1090E5           LDR      R1,[R0, #+12]
   \   00000114   0C2090E5           LDR      R2,[R0, #+12]
   \   00000118   0710D1E5           LDRB     R1,[R1, #+7]
   \   0000011C   0620D2E5           LDRB     R2,[R2, #+6]
   \   00000120   011482E1           ORR      R1,R2,R1, LSL #+8
   \   00000124   0C2090E5           LDR      R2,[R0, #+12]
   \   00000128   0C0090E5           LDR      R0,[R0, #+12]
   \   0000012C   0520D2E5           LDRB     R2,[R2, #+5]
   \   00000130   0400D0E5           LDRB     R0,[R0, #+4]
   \   00000134   011482E1           ORR      R1,R2,R1, LSL #+8
   \   00000138   010480E1           ORR      R0,R0,R1, LSL #+8
   \   0000013C   ........           _BLF     lwip_ntohl,??lwip_ntohl??rA
   \   00000140   1C1096E5           LDR      R1,[R6, #+28]
   \   00000144   010080E2           ADD      R0,R0,#+1
   \   00000148   000051E1           CMP      R1,R0
   \   0000014C   3F00001A           BNE      ??tcp_process_8
    635                pcb->snd_buf++;
   \   00000150   B606D4E1           LDRH     R0,[R4, #+102]
   \   00000154   010080E2           ADD      R0,R0,#+1
   \   00000158   B606C4E1           STRH     R0,[R4, #+102]
    636                pcb->rcv_nxt = seqno + 1;
   \   0000015C   180096E5           LDR      R0,[R6, #+24]
   \   00000160   012080E2           ADD      R2,R0,#+1
   \   00000164   282084E5           STR      R2,[R4, #+40]
    637                pcb->rcv_ann_right_edge = pcb->rcv_nxt;
   \   00000168   302084E5           STR      R2,[R4, #+48]
    638                pcb->lastack = ackno;
   \   0000016C   481084E5           STR      R1,[R4, #+72]
    639                pcb->snd_wnd = tcphdr->wnd;
   \   00000170   141096E5           LDR      R1,[R6, #+20]
   \   00000174   0F20D1E5           LDRB     R2,[R1, #+15]
   \   00000178   0E30D1E5           LDRB     R3,[R1, #+14]
    640                pcb->snd_wnd_max = tcphdr->wnd;
    641                pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
   \   0000017C   010040E2           SUB      R0,R0,#+1
   \   00000180   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000184   B026C4E1           STRH     R2,[R4, #+96]
   \   00000188   0F20D1E5           LDRB     R2,[R1, #+15]
   \   0000018C   0E10D1E5           LDRB     R1,[R1, #+14]
   \   00000190   021481E1           ORR      R1,R1,R2, LSL #+8
   \   00000194   B216C4E1           STRH     R1,[R4, #+98]
   \   00000198   540084E5           STR      R0,[R4, #+84]
    642                pcb->state = ESTABLISHED;
   \   0000019C   0400A0E3           MOV      R0,#+4
   \   000001A0   1800C4E5           STRB     R0,[R4, #+24]
    643          
    644          #if TCP_CALCULATE_EFF_SEND_MSS
    645                pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
   \   000001A4   B603D4E1           LDRH     R0,[R4, #+54]
   \   000001A8   041084E2           ADD      R1,R4,#+4
   \   000001AC   ........           _BLF     tcp_eff_send_mss,??tcp_eff_send_mss??rA
   \   000001B0   B603C4E1           STRH     R0,[R4, #+54]
    646          #endif /* TCP_CALCULATE_EFF_SEND_MSS */
    647          
    648                /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
    649                 * but for the default value of pcb->mss) */
    650                pcb->ssthresh = pcb->mss * 10;
   \   000001B4   0A10A0E3           MOV      R1,#+10
   \   000001B8   910000E0           MUL      R0,R1,R0
   \   000001BC   BE04C4E1           STRH     R0,[R4, #+78]
    651          
    652                pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
   \   000001C0   BC04D4E1           LDRH     R0,[R4, #+76]
    653                LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
    654                --pcb->snd_queuelen;
   \   000001C4   2518A0E1           MOV      R1,R5, LSR #+16
   \   000001C8   010050E3           CMP      R0,#+1
   \   000001CC   B603D4E1           LDRH     R0,[R4, #+54]
   \   000001D0   8000A001           LSLEQ    R0,R0,#+1
   \   000001D4   BC04C4E1           STRH     R0,[R4, #+76]
   \   000001D8   B806D4E1           LDRH     R0,[R4, #+104]
   \   000001DC   000081E0           ADD      R0,R1,R0
   \   000001E0   B806C4E1           STRH     R0,[R4, #+104]
    655                LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
    656                rseg = pcb->unacked;
   \   000001E4   700094E5           LDR      R0,[R4, #+112]
    657                pcb->unacked = rseg->next;
   \   000001E8   001090E5           LDR      R1,[R0, #+0]
   \   000001EC   701084E5           STR      R1,[R4, #+112]
    658                tcp_seg_free(rseg);
   \   000001F0   ........           _BLF     tcp_seg_free,??tcp_seg_free??rA
    659          
    660                /* If there's nothing left to acknowledge, stop the retransmit
    661                   timer, otherwise reset it to start again */
    662                if(pcb->unacked == NULL)
   \   000001F4   700094E5           LDR      R0,[R4, #+112]
   \   000001F8   000050E3           CMP      R0,#+0
    663                  pcb->rtime = -1;
   \   000001FC   09008503           ORREQ    R0,R5,#0x9
   \   00000200   B403C401           STRHEQ   R0,[R4, #+52]
    664                else {
    665                  pcb->rtime = 0;
   \   00000204   B473C411           STRHNE   R7,[R4, #+52]
    666                  pcb->nrtx = 0;
   \   00000208   4670C415           STRBNE   R7,[R4, #+70]
    667                }
    668          
    669                /* Call the user specified function to call when sucessfully
    670                 * connected. */
    671                TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
   \   0000020C   843094E5           LDR      R3,[R4, #+132]
   \   00000210   000053E3           CMP      R3,#+0
   \   00000214   0700000A           BEQ      ??tcp_process_9
    672                if (err == ERR_ABRT) {
   \   00000218   100094E5           LDR      R0,[R4, #+16]
   \   0000021C   0020A0E3           MOV      R2,#+0
   \   00000220   0410A0E1           MOV      R1,R4
   \   00000224   0FE0A0E1           MOV      LR,PC
   \   00000228   13FF2FE1           BX       R3
   \   0000022C   050050E1           CMP      R0,R5
   \   00000230   0000001A           BNE      ??tcp_process_9
    673                  return ERR_ABRT;
   \                     ??tcp_process_10:
   \   00000234   370000EA           B        ??tcp_process_11
    674                }
    675                tcp_ack_now(pcb);
   \                     ??tcp_process_9:
   \   00000238   1E00D4E5           LDRB     R0,[R4, #+30]
   \   0000023C   020080E3           ORR      R0,R0,#0x2
   \   00000240   1E00C4E5           STRB     R0,[R4, #+30]
   \                     ??tcp_process_5:
   \   00000244   F04FBDE8           POP      {R4-R11,LR}
   \   00000248   0000A0E3           MOV      R0,#+0
   \   0000024C   1EFF2FE1           BX       LR
    676              }
    677              /* received ACK? possibly a half-open connection */
    678              else if (flags & TCP_ACK) {
   \                     ??tcp_process_8:
   \   00000250   2800D6E5           LDRB     R0,[R6, #+40]
   \   00000254   100010E3           TST      R0,#0x10
   \   00000258   F9FFFF0A           BEQ      ??tcp_process_5
    679                /* send a RST to bring the other side in a non-synchronized state. */
    680                tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    681                  tcphdr->dest, tcphdr->src);
   \   0000025C   140096E5           LDR      R0,[R6, #+20]
   \   00000260   0110D0E5           LDRB     R1,[R0, #+1]
   \   00000264   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000268   0930A0E1           MOV      R3,R9
   \   0000026C   011482E1           ORR      R1,R2,R1, LSL #+8
   \   00000270   02002DE9           PUSH     {R1}
   \   00000274   0310D0E5           LDRB     R1,[R0, #+3]
   \   00000278   0200D0E5           LDRB     R0,[R0, #+2]
   \   0000027C   0820A0E1           MOV      R2,R8
   \   00000280   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000284   01002DE9           PUSH     {R0}
   \   00000288   B011D6E1           LDRH     R1,[R6, #+16]
   \   0000028C   180096E5           LDR      R0,[R6, #+24]
   \   00000290   001081E0           ADD      R1,R1,R0
   \   00000294   1C0096E5           LDR      R0,[R6, #+28]
   \                     ??tcp_process_12:
   \   00000298   ........           _BLF     tcp_rst,??tcp_rst??rA
   \   0000029C   08D08DE2           ADD      SP,SP,#+8
   \   000002A0   E7FFFFEA           B        ??tcp_process_5
    682              }
    683              break;
    684            case SYN_RCVD:
    685              if (flags & TCP_ACK) {
   \                     ??tcp_process_13:
   \   000002A4   2800D6E5           LDRB     R0,[R6, #+40]
   \   000002A8   181096E5           LDR      R1,[R6, #+24]
   \   000002AC   100010E3           TST      R0,#0x10
   \   000002B0   4000000A           BEQ      ??tcp_process_14
    686                /* expected ACK number? */
    687                if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
   \   000002B4   1C0096E5           LDR      R0,[R6, #+28]
   \   000002B8   482094E5           LDR      R2,[R4, #+72]
   \   000002BC   022040E0           SUB      R2,R0,R2
   \   000002C0   012052E2           SUBS     R2,R2,#+1
   \   000002C4   2D00004A           BMI      ??tcp_process_15
   \   000002C8   502094E5           LDR      R2,[R4, #+80]
   \   000002CC   022040E0           SUB      R2,R0,R2
   \   000002D0   010052E3           CMP      R2,#+1
   \   000002D4   290000AA           BGE      ??tcp_process_15
    688                  u16_t old_cwnd;
    689                  pcb->state = ESTABLISHED;
   \   000002D8   0400A0E3           MOV      R0,#+4
   \   000002DC   1800C4E5           STRB     R0,[R4, #+24]
    690                  LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
    691          #if LWIP_CALLBACK_API
    692                  LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
    693          #endif
    694                  /* Call the accept function. */
    695                  TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
   \   000002E0   143094E5           LDR      R3,[R4, #+20]
   \   000002E4   000053E3           CMP      R3,#+0
   \   000002E8   0800000A           BEQ      ??tcp_process_16
   \   000002EC   100094E5           LDR      R0,[R4, #+16]
   \   000002F0   0020A0E3           MOV      R2,#+0
   \   000002F4   0410A0E1           MOV      R1,R4
   \   000002F8   0FE0A0E1           MOV      LR,PC
   \   000002FC   13FF2FE1           BX       R3
    696                  if (err != ERR_OK) {
   \   00000300   000050E3           CMP      R0,#+0
   \   00000304   0600000A           BEQ      ??tcp_process_17
    697                    /* If the accept function returns with an error, we abort
    698                     * the connection. */
    699                    /* Already aborted? */
    700                    if (err != ERR_ABRT) {
   \   00000308   050050E1           CMP      R0,R5
   \   0000030C   0100000A           BEQ      ??tcp_process_11
    701                      tcp_abort(pcb);
   \                     ??tcp_process_16:
   \   00000310   0400A0E1           MOV      R0,R4
   \   00000314   ........           _BLF     tcp_abort,??tcp_abort??rA
   \                     ??tcp_process_11:
   \   00000318   0500A0E1           MOV      R0,R5
   \   0000031C   F04FBDE8           POP      {R4-R11,LR}
   \   00000320   1EFF2FE1           BX       LR
    702                    }
    703                    return ERR_ABRT;
    704                  }
    705                  old_cwnd = pcb->cwnd;
   \                     ??tcp_process_17:
   \   00000324   BC54D4E1           LDRH     R5,[R4, #+76]
    706                  /* If there was any data contained within this ACK,
    707                   * we'd better pass it on to the application as well. */
    708                  tcp_receive(pcb);
   \   00000328   0400A0E1           MOV      R0,R4
   \   0000032C   ........           BL       tcp_receive
    709          
    710                  /* Prevent ACK for SYN to generate a sent event */
    711                  if (pcb->acked != 0) {
   \   00000330   B406D4E1           LDRH     R0,[R4, #+100]
   \   00000334   000050E3           CMP      R0,#+0
   \   00000338   0300000A           BEQ      ??tcp_process_18
    712                    pcb->acked--;
   \   0000033C   FF10A0E3           MOV      R1,#+255
   \   00000340   FF1C81E3           ORR      R1,R1,#0xFF00
   \   00000344   000081E0           ADD      R0,R1,R0
   \   00000348   B406C4E1           STRH     R0,[R4, #+100]
    713                  }
    714          
    715                  pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
   \                     ??tcp_process_18:
   \   0000034C   B603D4E1           LDRH     R0,[R4, #+54]
   \   00000350   010055E3           CMP      R5,#+1
   \   00000354   8000A001           LSLEQ    R0,R0,#+1
   \   00000358   BC04C4E1           STRH     R0,[R4, #+76]
    716          
    717                  if (recv_flags & TF_GOT_FIN) {
   \   0000035C   2900D6E5           LDRB     R0,[R6, #+41]
   \   00000360   200010E3           TST      R0,#0x20
   \   00000364   B6FFFF0A           BEQ      ??tcp_process_5
    718                    tcp_ack_now(pcb);
   \                     ??tcp_process_19:
   \   00000368   1E00D4E5           LDRB     R0,[R4, #+30]
   \   0000036C   020080E3           ORR      R0,R0,#0x2
   \   00000370   1E00C4E5           STRB     R0,[R4, #+30]
    719                    pcb->state = CLOSE_WAIT;
   \   00000374   0700A0E3           MOV      R0,#+7
   \                     ??tcp_process_20:
   \   00000378   1800C4E5           STRB     R0,[R4, #+24]
   \   0000037C   B0FFFFEA           B        ??tcp_process_5
    720                  }
    721                } else {
    722                  /* incorrect ACK number, send RST */
    723                  tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    724                          tcphdr->dest, tcphdr->src);
   \                     ??tcp_process_15:
   \   00000380   142096E5           LDR      R2,[R6, #+20]
   \   00000384   0130D2E5           LDRB     R3,[R2, #+1]
   \   00000388   0040D2E5           LDRB     R4,[R2, #+0]
   \   0000038C   033484E1           ORR      R3,R4,R3, LSL #+8
   \   00000390   08002DE9           PUSH     {R3}
   \   00000394   0330D2E5           LDRB     R3,[R2, #+3]
   \   00000398   0220D2E5           LDRB     R2,[R2, #+2]
   \   0000039C   032482E1           ORR      R2,R2,R3, LSL #+8
   \   000003A0   04002DE9           PUSH     {R2}
   \   000003A4   B041D6E1           LDRH     R4,[R6, #+16]
   \   000003A8   0930A0E1           MOV      R3,R9
   \   000003AC   0820A0E1           MOV      R2,R8
   \   000003B0   011084E0           ADD      R1,R4,R1
   \   000003B4   B7FFFFEA           B        ??tcp_process_12
    725                }
    726              } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
   \                     ??tcp_process_14:
   \   000003B8   020010E3           TST      R0,#0x2
   \   000003BC   A0FFFF0A           BEQ      ??tcp_process_5
   \   000003C0   280094E5           LDR      R0,[R4, #+40]
   \   000003C4   010040E2           SUB      R0,R0,#+1
   \   000003C8   000051E1           CMP      R1,R0
   \   000003CC   9CFFFF1A           BNE      ??tcp_process_5
    727                /* Looks like another copy of the SYN - retransmit our SYN-ACK */
    728                tcp_rexmit(pcb);
   \   000003D0   0400A0E1           MOV      R0,R4
   \   000003D4   ........           _BLF     tcp_rexmit,??tcp_rexmit??rA
   \   000003D8   99FFFFEA           B        ??tcp_process_5
    729              }
    730              break;
    731            case CLOSE_WAIT:
    732              /* FALLTHROUGH */
    733            case ESTABLISHED:
    734              tcp_receive(pcb);
   \                     ??tcp_process_21:
   \   000003DC   0400A0E1           MOV      R0,R4
   \   000003E0   ........           BL       tcp_receive
    735              if (recv_flags & TF_GOT_FIN) { /* passive close */
   \   000003E4   2900D6E5           LDRB     R0,[R6, #+41]
   \   000003E8   200010E3           TST      R0,#0x20
   \   000003EC   DDFFFF1A           BNE      ??tcp_process_19
   \   000003F0   93FFFFEA           B        ??tcp_process_5
    736                tcp_ack_now(pcb);
    737                pcb->state = CLOSE_WAIT;
    738              }
    739              break;
    740            case FIN_WAIT_1:
    741              tcp_receive(pcb);
   \                     ??tcp_process_22:
   \   000003F4   0400A0E1           MOV      R0,R4
   \   000003F8   ........           BL       tcp_receive
    742              if (recv_flags & TF_GOT_FIN) {
   \   000003FC   2900D6E5           LDRB     R0,[R6, #+41]
   \   00000400   200010E3           TST      R0,#0x20
   \   00000404   2B00000A           BEQ      ??tcp_process_23
    743                if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
   \   00000408   1E00D4E5           LDRB     R0,[R4, #+30]
   \   0000040C   2810D6E5           LDRB     R1,[R6, #+40]
   \   00000410   020080E3           ORR      R0,R0,#0x2
   \   00000414   100011E3           TST      R1,#0x10
   \   00000418   2300000A           BEQ      ??tcp_process_24
   \   0000041C   1C1096E5           LDR      R1,[R6, #+28]
   \   00000420   502094E5           LDR      R2,[R4, #+80]
   \   00000424   020051E1           CMP      R1,R2
   \   00000428   1F00001A           BNE      ??tcp_process_24
    744                  LWIP_DEBUGF(TCP_DEBUG,
    745                    ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
    746                  tcp_ack_now(pcb);
   \   0000042C   1E00C4E5           STRB     R0,[R4, #+30]
    747                  tcp_pcb_purge(pcb);
   \   00000430   0400A0E1           MOV      R0,R4
   \   00000434   ........           _BLF     tcp_pcb_purge,??tcp_pcb_purge??rA
    748                  TCP_RMV_ACTIVE(pcb);
   \   00000438   00009BE5           LDR      R0,[R11, #+0]
   \   0000043C   040050E1           CMP      R0,R4
   \   00000440   0300001A           BNE      ??tcp_process_25
   \                     ??tcp_process_26:
   \   00000444   00009BE5           LDR      R0,[R11, #+0]
   \   00000448   0C0090E5           LDR      R0,[R0, #+12]
   \   0000044C   00008BE5           STR      R0,[R11, #+0]
   \   00000450   090000EA           B        ??tcp_process_27
   \                     ??tcp_process_25:
   \   00000454   00008AE5           STR      R0,[R10, #+0]
   \   00000458   00009AE5           LDR      R0,[R10, #+0]
   \   0000045C   000050E3           CMP      R0,#+0
   \   00000460   0500000A           BEQ      ??tcp_process_27
   \   00000464   0C0090E5           LDR      R0,[R0, #+12]
   \   00000468   040050E1           CMP      R0,R4
   \   0000046C   F8FFFF1A           BNE      ??tcp_process_25
   \                     ??tcp_process_28:
   \   00000470   00009AE5           LDR      R0,[R10, #+0]
   \   00000474   0C1094E5           LDR      R1,[R4, #+12]
   \   00000478   0C1080E5           STR      R1,[R0, #+12]
   \                     ??tcp_process_27:
   \   0000047C   ........           LDR      R0,??DataTable24  ;; tcp_active_pcbs_changed
   \   00000480   0C7084E5           STR      R7,[R4, #+12]
   \   00000484   0110A0E3           MOV      R1,#+1
   \   00000488   0010C0E5           STRB     R1,[R0, #+0]
    749                  pcb->state = TIME_WAIT;
   \   0000048C   0A00A0E3           MOV      R0,#+10
   \   00000490   1800C4E5           STRB     R0,[R4, #+24]
    750                  TCP_REG(&tcp_tw_pcbs, pcb);
   \   00000494   ........           LDR      R0,??DataTable25  ;; tcp_tw_pcbs
   \   00000498   001090E5           LDR      R1,[R0, #+0]
   \   0000049C   0C1084E5           STR      R1,[R4, #+12]
   \   000004A0   004080E5           STR      R4,[R0, #+0]
   \   000004A4   ........           _BLF     tcp_timer_needed,??tcp_timer_needed??rA
   \   000004A8   65FFFFEA           B        ??tcp_process_5
    751                } else {
    752                  tcp_ack_now(pcb);
   \                     ??tcp_process_24:
   \   000004AC   1E00C4E5           STRB     R0,[R4, #+30]
    753                  pcb->state = CLOSING;
   \   000004B0   0800A0E3           MOV      R0,#+8
   \   000004B4   AFFFFFEA           B        ??tcp_process_20
    754                }
    755              } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
   \                     ??tcp_process_23:
   \   000004B8   2800D6E5           LDRB     R0,[R6, #+40]
   \   000004BC   100010E3           TST      R0,#0x10
   \   000004C0   5FFFFF0A           BEQ      ??tcp_process_5
   \   000004C4   1C0096E5           LDR      R0,[R6, #+28]
   \   000004C8   501094E5           LDR      R1,[R4, #+80]
   \   000004CC   010050E1           CMP      R0,R1
   \   000004D0   5BFFFF1A           BNE      ??tcp_process_5
    756                pcb->state = FIN_WAIT_2;
   \   000004D4   0600A0E3           MOV      R0,#+6
   \   000004D8   A6FFFFEA           B        ??tcp_process_20
    757              }
    758              break;
    759            case FIN_WAIT_2:
    760              tcp_receive(pcb);
   \                     ??tcp_process_29:
   \   000004DC   0400A0E1           MOV      R0,R4
   \   000004E0   ........           BL       tcp_receive
    761              if (recv_flags & TF_GOT_FIN) {
   \   000004E4   2900D6E5           LDRB     R0,[R6, #+41]
   \   000004E8   200010E3           TST      R0,#0x20
   \   000004EC   54FFFF0A           BEQ      ??tcp_process_5
    762                LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
    763                tcp_ack_now(pcb);
   \   000004F0   1E00D4E5           LDRB     R0,[R4, #+30]
   \   000004F4   020080E3           ORR      R0,R0,#0x2
   \   000004F8   1E00C4E5           STRB     R0,[R4, #+30]
    764                tcp_pcb_purge(pcb);
   \   000004FC   0400A0E1           MOV      R0,R4
   \   00000500   ........           _BLF     tcp_pcb_purge,??tcp_pcb_purge??rA
    765                TCP_RMV_ACTIVE(pcb);
   \   00000504   00009BE5           LDR      R0,[R11, #+0]
   \   00000508   040050E1           CMP      R0,R4
   \   0000050C   CCFFFF0A           BEQ      ??tcp_process_26
   \                     ??tcp_process_30:
   \   00000510   00008AE5           STR      R0,[R10, #+0]
   \   00000514   00009AE5           LDR      R0,[R10, #+0]
   \   00000518   000050E3           CMP      R0,#+0
   \   0000051C   D6FFFF0A           BEQ      ??tcp_process_27
   \   00000520   0C0090E5           LDR      R0,[R0, #+12]
   \   00000524   040050E1           CMP      R0,R4
   \   00000528   D0FFFF0A           BEQ      ??tcp_process_28
   \   0000052C   F7FFFFEA           B        ??tcp_process_30
    766                pcb->state = TIME_WAIT;
    767                TCP_REG(&tcp_tw_pcbs, pcb);
    768              }
    769              break;
    770            case CLOSING:
    771              tcp_receive(pcb);
   \                     ??tcp_process_31:
   \   00000530   0400A0E1           MOV      R0,R4
   \   00000534   ........           BL       tcp_receive
    772              if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
   \   00000538   2800D6E5           LDRB     R0,[R6, #+40]
   \   0000053C   100010E3           TST      R0,#0x10
   \   00000540   3FFFFF0A           BEQ      ??tcp_process_5
   \   00000544   1C0096E5           LDR      R0,[R6, #+28]
   \   00000548   501094E5           LDR      R1,[R4, #+80]
   \   0000054C   010050E1           CMP      R0,R1
   \   00000550   3BFFFF1A           BNE      ??tcp_process_5
    773                LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
    774                tcp_pcb_purge(pcb);
   \   00000554   0400A0E1           MOV      R0,R4
   \   00000558   ........           _BLF     tcp_pcb_purge,??tcp_pcb_purge??rA
    775                TCP_RMV_ACTIVE(pcb);
   \   0000055C   00009BE5           LDR      R0,[R11, #+0]
   \   00000560   040050E1           CMP      R0,R4
   \   00000564   B6FFFF0A           BEQ      ??tcp_process_26
   \                     ??tcp_process_32:
   \   00000568   00008AE5           STR      R0,[R10, #+0]
   \   0000056C   00009AE5           LDR      R0,[R10, #+0]
   \   00000570   000050E3           CMP      R0,#+0
   \   00000574   C0FFFF0A           BEQ      ??tcp_process_27
   \   00000578   0C0090E5           LDR      R0,[R0, #+12]
   \   0000057C   040050E1           CMP      R0,R4
   \   00000580   BAFFFF0A           BEQ      ??tcp_process_28
   \   00000584   F7FFFFEA           B        ??tcp_process_32
    776                pcb->state = TIME_WAIT;
    777                TCP_REG(&tcp_tw_pcbs, pcb);
    778              }
    779              break;
    780            case LAST_ACK:
    781              tcp_receive(pcb);
   \                     ??tcp_process_33:
   \   00000588   0400A0E1           MOV      R0,R4
   \   0000058C   ........           BL       tcp_receive
    782              if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
   \   00000590   2800D6E5           LDRB     R0,[R6, #+40]
   \   00000594   100010E3           TST      R0,#0x10
   \   00000598   29FFFF0A           BEQ      ??tcp_process_5
   \   0000059C   1C0096E5           LDR      R0,[R6, #+28]
   \   000005A0   501094E5           LDR      R1,[R4, #+80]
   \   000005A4   010050E1           CMP      R0,R1
    783                LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
    784                /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
    785                recv_flags |= TF_CLOSED;
   \   000005A8   2900D605           LDRBEQ   R0,[R6, #+41]
   \   000005AC   10008003           ORREQ    R0,R0,#0x10
   \   000005B0   2900C605           STRBEQ   R0,[R6, #+41]
    786              }
    787              break;
    788            default:
    789              break;
    790            }
    791            return ERR_OK;
   \                     ??tcp_process_34:
   \   000005B4   22FFFFEA           B        ??tcp_process_5
   \                     ??tcp_process_6:
   \   000005B8   ........           DC32     tcp_tmp_pcb
    792          }
    793          
    794          #if TCP_QUEUE_OOSEQ
    795          /**
    796           * Insert segment into the list (segments covered with new one will be deleted)
    797           *
    798           * Called from tcp_receive()
    799           */

   \                                 In segment CODE, align 4, keep-with-next
    800          static void
    801          tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
    802          {
   \                     tcp_oos_insert_segment:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    803            struct tcp_seg *old_seg;
    804          
    805            if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
   \   00000008   0C0094E5           LDR      R0,[R4, #+12]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000014   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000018   010480E1           ORR      R0,R0,R1, LSL #+8
   \   0000001C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000020   010010E3           TST      R0,#0x1
   \   00000024   1700000A           BEQ      ??tcp_oos_insert_segment_0
    806              /* received segment overlaps all following segments */
    807              tcp_segs_free(next);
   \   00000028   0500A0E1           MOV      R0,R5
   \   0000002C   ........           _BLF     tcp_segs_free,??tcp_segs_free??rA
    808              next = NULL;
   \   00000030   0050A0E3           MOV      R5,#+0
   \   00000034   370000EA           B        ??tcp_oos_insert_segment_1
    809            }
    810            else {
    811              /* delete some following segments
    812                 oos queue may have segments with FIN flag */
    813              while (next &&
    814                     TCP_SEQ_GEQ((seqno + cseg->len),
    815                                (next->tcphdr->seqno + next->len))) {
    816                /* cseg with FIN already processed */
    817                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
   \                     ??tcp_oos_insert_segment_2:
   \   00000038   0D00D2E5           LDRB     R0,[R2, #+13]
   \   0000003C   0C10D2E5           LDRB     R1,[R2, #+12]
   \   00000040   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000044   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000048   010010E3           TST      R0,#0x1
   \   0000004C   0A00000A           BEQ      ??tcp_oos_insert_segment_3
    818                  TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
   \   00000050   0100A0E3           MOV      R0,#+1
   \   00000054   ........           _BLF     lwip_htons,??lwip_htons??rA
   \   00000058   0C1094E5           LDR      R1,[R4, #+12]
   \   0000005C   0D20D1E5           LDRB     R2,[R1, #+13]
   \   00000060   0C30D1E5           LDRB     R3,[R1, #+12]
   \   00000064   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000068   020080E1           ORR      R0,R0,R2
   \   0000006C   0C00C1E5           STRB     R0,[R1, #+12]
   \   00000070   0C1094E5           LDR      R1,[R4, #+12]
   \   00000074   2004A0E1           LSR      R0,R0,#+8
   \   00000078   0D00C1E5           STRB     R0,[R1, #+13]
    819                }
    820                old_seg = next;
   \                     ??tcp_oos_insert_segment_3:
   \   0000007C   0500A0E1           MOV      R0,R5
    821                next = next->next;
   \   00000080   005095E5           LDR      R5,[R5, #+0]
    822                tcp_seg_free(old_seg);
   \   00000084   ........           _BLF     tcp_seg_free,??tcp_seg_free??rA
    823              }
   \                     ??tcp_oos_insert_segment_0:
   \   00000088   000055E3           CMP      R5,#+0
   \   0000008C   2100000A           BEQ      ??tcp_oos_insert_segment_1
   \   00000090   0C2095E5           LDR      R2,[R5, #+12]
   \   00000094   0730D2E5           LDRB     R3,[R2, #+7]
   \   00000098   06C0D2E5           LDRB     R12,[R2, #+6]
   \   0000009C   80009FE5           LDR      R0,??tcp_oos_insert_segment_4  ;; inseg + 24
   \   000000A0   B810D4E1           LDRH     R1,[R4, #+8]
   \   000000A4   000090E5           LDR      R0,[R0, #+0]
   \   000000A8   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   000000AC   05C0D2E5           LDRB     R12,[R2, #+5]
   \   000000B0   001081E0           ADD      R1,R1,R0
   \   000000B4   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   000000B8   04C0D2E5           LDRB     R12,[R2, #+4]
   \   000000BC   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   000000C0   B8C0D5E1           LDRH     R12,[R5, #+8]
   \   000000C4   033041E0           SUB      R3,R1,R3
   \   000000C8   0C3053E0           SUBS     R3,R3,R12
   \   000000CC   D9FFFF5A           BPL      ??tcp_oos_insert_segment_2
   \   000000D0   0730D2E5           LDRB     R3,[R2, #+7]
   \   000000D4   06C0D2E5           LDRB     R12,[R2, #+6]
   \   000000D8   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   000000DC   05C0D2E5           LDRB     R12,[R2, #+5]
   \   000000E0   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   000000E4   04C0D2E5           LDRB     R12,[R2, #+4]
   \   000000E8   03348CE1           ORR      R3,R12,R3, LSL #+8
   \   000000EC   031041E0           SUB      R1,R1,R3
   \   000000F0   010051E3           CMP      R1,#+1
   \   000000F4   070000BA           BLT      ??tcp_oos_insert_segment_1
    824              if (next &&
    825                  TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    826                /* We need to trim the incoming segment. */
    827                cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
   \   000000F8   0510D2E5           LDRB     R1,[R2, #+5]
   \   000000FC   01148CE1           ORR      R1,R12,R1, LSL #+8
   \   00000100   001041E0           SUB      R1,R1,R0
   \   00000104   B810C4E1           STRH     R1,[R4, #+8]
    828                pbuf_realloc(cseg->p, cseg->len);
   \   00000108   040094E5           LDR      R0,[R4, #+4]
   \   0000010C   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000110   2118A0E1           MOV      R1,R1, LSR #+16
   \   00000114   ........           _BLF     pbuf_realloc,??pbuf_realloc??rA
    829              }
    830            }
    831            cseg->next = next;
   \                     ??tcp_oos_insert_segment_1:
   \   00000118   005084E5           STR      R5,[R4, #+0]
    832          }
   \   0000011C   3040BDE8           POP      {R4,R5,LR}
   \   00000120   1EFF2FE1           BX       LR               ;; return
   \                     ??tcp_oos_insert_segment_4:
   \   00000124   ........           DC32     inseg + 24
    833          #endif /* TCP_QUEUE_OOSEQ */
    834          
    835          /**
    836           * Called by tcp_process. Checks if the given segment is an ACK for outstanding
    837           * data, and if so frees the memory of the buffered data. Next, is places the
    838           * segment on any of the receive queues (pcb->recved or pcb->ooseq). If the segment
    839           * is buffered, the pbuf is referenced by pbuf_ref so that it will not be freed until
    840           * it has been removed from the buffer.
    841           *
    842           * If the incoming segment constitutes an ACK for a segment that was used for RTT
    843           * estimation, the RTT is estimated here as well.
    844           *
    845           * Called from tcp_process().
    846           */

   \                                 In segment CODE, align 4, keep-with-next
    847          static void
    848          tcp_receive(struct tcp_pcb *pcb)
    849          {
   \                     tcp_receive:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    850            struct tcp_seg *next;
    851          #if TCP_QUEUE_OOSEQ
    852            struct tcp_seg *prev, *cseg;
    853          #endif /* TCP_QUEUE_OOSEQ */
    854            struct pbuf *p;
    855            s32_t off;
    856            s16_t m;
    857            u32_t right_wnd_edge;
    858            u16_t new_tot_len;
    859            int found_dupack = 0;
    860          #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
    861            u32_t ooseq_blen;
    862            u16_t ooseq_qlen;
    863          #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
    864          
    865            LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
    866          
    867            if (flags & TCP_ACK) {
   \   00000004   ........           LDR      R7,??DataTable26  ;; inseg
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   2800D7E5           LDRB     R0,[R7, #+40]
   \   00000010   FF50A0E3           MOV      R5,#+255
   \   00000014   FF5C85E3           ORR      R5,R5,#0xFF00
   \   00000018   0160A0E3           MOV      R6,#+1
   \   0000001C   0080A0E3           MOV      R8,#+0
   \   00000020   100010E3           TST      R0,#0x10
   \   00000024   1701000A           BEQ      ??tcp_receive_0
    868              right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    869          
    870              /* Update window. */
    871              if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    872                 (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    873                 (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
   \   00000028   149097E5           LDR      R9,[R7, #+20]
   \   0000002C   B036D4E1           LDRH     R3,[R4, #+96]
   \   00000030   0F10D9E5           LDRB     R1,[R9, #+15]
   \   00000034   0EA0D9E5           LDRB     R10,[R9, #+14]
   \   00000038   582094E5           LDR      R2,[R4, #+88]
   \   0000003C   18B097E5           LDR      R11,[R7, #+24]
   \   00000040   54C094E5           LDR      R12,[R4, #+84]
   \   00000044   030082E0           ADD      R0,R2,R3
   \   00000048   01A48AE1           ORR      R10,R10,R1, LSL #+8
   \   0000004C   1C1097E5           LDR      R1,[R7, #+28]
   \   00000050   0BE05CE0           SUBS     LR,R12,R11
   \   00000054   0700004A           BMI      ??tcp_receive_1
   \   00000058   0B005CE1           CMP      R12,R11
   \   0000005C   0100001A           BNE      ??tcp_receive_2
   \   00000060   01C052E0           SUBS     R12,R2,R1
   \   00000064   0300004A           BMI      ??tcp_receive_1
   \                     ??tcp_receive_2:
   \   00000068   010052E1           CMP      R2,R1
   \   0000006C   1400001A           BNE      ??tcp_receive_3
   \   00000070   0A0053E1           CMP      R3,R10
   \   00000074   1200002A           BCS      ??tcp_receive_3
    874                pcb->snd_wnd = tcphdr->wnd;
   \                     ??tcp_receive_1:
   \   00000078   B0A6C4E1           STRH     R10,[R4, #+96]
    875                /* keep track of the biggest window announced by the remote host to calculate
    876                   the maximum segment size */
    877                if (pcb->snd_wnd_max < tcphdr->wnd) {
   \   0000007C   0F20D9E5           LDRB     R2,[R9, #+15]
   \   00000080   0E30D9E5           LDRB     R3,[R9, #+14]
   \   00000084   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000088   B236D4E1           LDRH     R3,[R4, #+98]
   \   0000008C   020053E1           CMP      R3,R2
    878                  pcb->snd_wnd_max = tcphdr->wnd;
   \   00000090   B226C431           STRHCC   R2,[R4, #+98]
    879                }
    880                pcb->snd_wl1 = seqno;
   \   00000094   54B084E5           STR      R11,[R4, #+84]
    881                pcb->snd_wl2 = ackno;
   \   00000098   581084E5           STR      R1,[R4, #+88]
    882                if (pcb->snd_wnd == 0) {
   \   0000009C   9D20D4E5           LDRB     R2,[R4, #+157]
   \   000000A0   00005AE3           CMP      R10,#+0
   \   000000A4   0400001A           BNE      ??tcp_receive_4
    883                  if (pcb->persist_backoff == 0) {
   \   000000A8   000052E3           CMP      R2,#+0
   \   000000AC   0400001A           BNE      ??tcp_receive_3
    884                    /* start persist timer */
    885                    pcb->persist_cnt = 0;
   \   000000B0   9C80C4E5           STRB     R8,[R4, #+156]
    886                    pcb->persist_backoff = 1;
   \   000000B4   9D60C4E5           STRB     R6,[R4, #+157]
   \   000000B8   010000EA           B        ??tcp_receive_3
    887                  }
    888                } else if (pcb->persist_backoff > 0) {
   \                     ??tcp_receive_4:
   \   000000BC   000052E3           CMP      R2,#+0
    889                  /* stop persist timer */
    890                    pcb->persist_backoff = 0;
   \   000000C0   9D80C415           STRBNE   R8,[R4, #+157]
    891                }
    892                LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
    893          #if TCP_WND_DEBUG
    894              } else {
    895                if (pcb->snd_wnd != tcphdr->wnd) {
    896                  LWIP_DEBUGF(TCP_WND_DEBUG,
    897                              ("tcp_receive: no window update lastack %"U32_F" ackno %"
    898                               U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
    899                               pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
    900                }
    901          #endif /* TCP_WND_DEBUG */
    902              }
    903          
    904              /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
    905               * duplicate ack if:
    906               * 1) It doesn't ACK new data
    907               * 2) length of received packet is zero (i.e. no payload)
    908               * 3) the advertised window hasn't changed
    909               * 4) There is outstanding unacknowledged data (retransmission timer running)
    910               * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
    911               *
    912               * If it passes all five, should process as a dupack:
    913               * a) dupacks < 3: do nothing
    914               * b) dupacks == 3: fast retransmit
    915               * c) dupacks > 3: increase cwnd
    916               *
    917               * If it only passes 1-3, should reset dupack counter (and add to
    918               * stats, which we don't do in lwIP)
    919               *
    920               * If it only passes 1, should reset dupack counter
    921               *
    922               */
    923          
    924              /* Clause 1 */
    925              if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
   \                     ??tcp_receive_3:
   \   000000C4   482094E5           LDR      R2,[R4, #+72]
   \   000000C8   023041E0           SUB      R3,R1,R2
   \   000000CC   010053E3           CMP      R3,#+1
   \   000000D0   250000AA           BGE      ??tcp_receive_5
    926                pcb->acked = 0;
   \   000000D4   B486C4E1           STRH     R8,[R4, #+100]
    927                /* Clause 2 */
    928                if (tcplen == 0) {
   \   000000D8   B031D7E1           LDRH     R3,[R7, #+16]
   \   000000DC   000053E3           CMP      R3,#+0
   \   000000E0   1F00001A           BNE      ??tcp_receive_6
    929                  /* Clause 3 */
    930                  if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
   \   000000E4   B096D4E1           LDRH     R9,[R4, #+96]
   \   000000E8   583094E5           LDR      R3,[R4, #+88]
   \   000000EC   033089E0           ADD      R3,R9,R3
   \   000000F0   000053E1           CMP      R3,R0
   \   000000F4   1A00001A           BNE      ??tcp_receive_6
    931                    /* Clause 4 */
    932                    if (pcb->rtime >= 0) {
   \   000000F8   F403D4E1           LDRSH    R0,[R4, #+52]
   \   000000FC   000050E3           CMP      R0,#+0
   \   00000100   1700004A           BMI      ??tcp_receive_6
    933                      /* Clause 5 */
    934                      if (pcb->lastack == ackno) {
   \   00000104   010052E1           CMP      R2,R1
   \   00000108   1500001A           BNE      ??tcp_receive_6
    935                        found_dupack = 1;
    936                        if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
   \   0000010C   4700D4E5           LDRB     R0,[R4, #+71]
   \   00000110   011080E2           ADD      R1,R0,#+1
   \   00000114   FF1001E2           AND      R1,R1,#0xFF
   \   00000118   010050E1           CMP      R0,R1
    937                          ++pcb->dupacks;
   \   0000011C   4710C435           STRBCC   R1,[R4, #+71]
    938                        }
    939                        if (pcb->dupacks > 3) {
   \   00000120   4700D4E5           LDRB     R0,[R4, #+71]
   \   00000124   040050E3           CMP      R0,#+4
   \   00000128   0800003A           BCC      ??tcp_receive_7
    940                          /* Inflate the congestion window, but not if it means that
    941                             the value overflows. */
    942                          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
   \   0000012C   BC04D4E1           LDRH     R0,[R4, #+76]
   \   00000130   B613D4E1           LDRH     R1,[R4, #+54]
   \   00000134   001081E0           ADD      R1,R1,R0
   \   00000138   0118A0E1           MOV      R1,R1, LSL #+16
   \   0000013C   2118A0E1           MOV      R1,R1, LSR #+16
   \   00000140   010050E1           CMP      R0,R1
   \   00000144   8B00002A           BCS      ??tcp_receive_8
    943                            pcb->cwnd += pcb->mss;
   \   00000148   BC14C4E1           STRH     R1,[R4, #+76]
   \   0000014C   890000EA           B        ??tcp_receive_8
    944                          }
    945                        } else if (pcb->dupacks == 3) {
   \                     ??tcp_receive_7:
   \   00000150   030050E3           CMP      R0,#+3
   \   00000154   8700001A           BNE      ??tcp_receive_8
    946                          /* Do fast retransmit */
    947                          tcp_rexmit_fast(pcb);
   \   00000158   0400A0E1           MOV      R0,R4
   \   0000015C   ........           _BLF     tcp_rexmit_fast,??tcp_rexmit_fast??rA
   \   00000160   840000EA           B        ??tcp_receive_8
    948                        }
    949                      }
    950                    }
    951                  }
    952                }
    953                /* If Clause (1) or more is true, but not a duplicate ack, reset
    954                 * count of consecutive duplicate acks */
    955                if (!found_dupack) {
    956                  pcb->dupacks = 0;
   \                     ??tcp_receive_6:
   \   00000164   4780C4E5           STRB     R8,[R4, #+71]
   \   00000168   820000EA           B        ??tcp_receive_8
    957                }
    958              } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
   \                     ??tcp_receive_5:
   \   0000016C   6800004A           BMI      ??tcp_receive_9
   \   00000170   500094E5           LDR      R0,[R4, #+80]
   \   00000174   000041E0           SUB      R0,R1,R0
   \   00000178   010050E3           CMP      R0,#+1
   \   0000017C   640000AA           BGE      ??tcp_receive_9
    959                /* We come here when the ACK acknowledges new data. */
    960          
    961                /* Reset the "IN Fast Retransmit" flag, since we are no longer
    962                   in fast retransmit. Also reset the congestion window to the
    963                   slow start threshold. */
    964                if (pcb->flags & TF_INFR) {
   \   00000180   1E00D4E5           LDRB     R0,[R4, #+30]
   \   00000184   040010E3           TST      R0,#0x4
   \   00000188   0300000A           BEQ      ??tcp_receive_10
    965                  pcb->flags &= ~TF_INFR;
   \   0000018C   FB0000E2           AND      R0,R0,#0xFB
   \   00000190   1E00C4E5           STRB     R0,[R4, #+30]
    966                  pcb->cwnd = pcb->ssthresh;
   \   00000194   BE04D4E1           LDRH     R0,[R4, #+78]
   \   00000198   BC04C4E1           STRH     R0,[R4, #+76]
    967                }
    968          
    969                /* Reset the number of retransmissions. */
    970                pcb->nrtx = 0;
   \                     ??tcp_receive_10:
   \   0000019C   4680C4E5           STRB     R8,[R4, #+70]
    971          
    972                /* Reset the retransmission time-out. */
    973                pcb->rto = (pcb->sa >> 3) + pcb->sv;
   \   000001A0   F004D4E1           LDRSH    R0,[R4, #+64]
   \   000001A4   F224D4E1           LDRSH    R2,[R4, #+66]
   \   000001A8   C00182E0           ADD      R0,R2,R0, ASR #+3
   \   000001AC   B404C4E1           STRH     R0,[R4, #+68]
    974          
    975                /* Update the send buffer space. Diff between the two can never exceed 64K? */
    976                pcb->acked = (u16_t)(ackno - pcb->lastack);
   \   000001B0   482094E5           LDR      R2,[R4, #+72]
   \   000001B4   020041E0           SUB      R0,R1,R2
   \   000001B8   B406C4E1           STRH     R0,[R4, #+100]
    977          
    978                pcb->snd_buf += pcb->acked;
   \   000001BC   B626D4E1           LDRH     R2,[R4, #+102]
   \   000001C0   020080E0           ADD      R0,R0,R2
   \   000001C4   B606C4E1           STRH     R0,[R4, #+102]
    979          
    980                /* Reset the fast retransmit variables. */
    981                pcb->dupacks = 0;
   \   000001C8   4780C4E5           STRB     R8,[R4, #+71]
    982                pcb->lastack = ackno;
   \   000001CC   481084E5           STR      R1,[R4, #+72]
    983          
    984                /* Update the congestion control variables (cwnd and
    985                   ssthresh). */
    986                if (pcb->state >= ESTABLISHED) {
   \   000001D0   1800D4E5           LDRB     R0,[R4, #+24]
   \   000001D4   040050E3           CMP      R0,#+4
   \   000001D8   2400003A           BCC      ??tcp_receive_11
    987                  if (pcb->cwnd < pcb->ssthresh) {
   \   000001DC   BC24D4E1           LDRH     R2,[R4, #+76]
   \   000001E0   BE04D4E1           LDRH     R0,[R4, #+78]
   \   000001E4   B613D4E1           LDRH     R1,[R4, #+54]
   \   000001E8   000052E1           CMP      R2,R0
   \   000001EC   0600002A           BCS      ??tcp_receive_12
    988                    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
   \                     ??tcp_receive_13:
   \   000001F0   020081E0           ADD      R0,R1,R2
   \   000001F4   0008A0E1           MOV      R0,R0, LSL #+16
   \   000001F8   2008A0E1           MOV      R0,R0, LSR #+16
   \   000001FC   000052E1           CMP      R2,R0
   \   00000200   1A00002A           BCS      ??tcp_receive_11
    989                      pcb->cwnd += pcb->mss;
   \   00000204   BC04C4E1           STRH     R0,[R4, #+76]
   \   00000208   180000EA           B        ??tcp_receive_11
    990                    }
    991                    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
    992                  } else {
    993                    u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
   \                     ??tcp_receive_12:
   \   0000020C   910100E0           MUL      R0,R1,R1
   \   00000210   0210A0E1           MOV      R1,R2
   \   00000214   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000218   F4FFFFEA           B        ??tcp_receive_13
    994                    if (new_cwnd > pcb->cwnd) {
    995                      pcb->cwnd = new_cwnd;
    996                    }
    997                    LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
    998                  }
    999                }
   1000                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
   1001                                              ackno,
   1002                                              pcb->unacked != NULL?
   1003                                              ntohl(pcb->unacked->tcphdr->seqno): 0,
   1004                                              pcb->unacked != NULL?
   1005                                              ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
   1006          
   1007                /* Remove segment from the unacknowledged list if the incoming
   1008                   ACK acknowlegdes them. */
   1009                while (pcb->unacked != NULL &&
   1010                       TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
   1011                                   TCP_TCPLEN(pcb->unacked), ackno)) {
   1012                  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
   1013                                                ntohl(pcb->unacked->tcphdr->seqno),
   1014                                                ntohl(pcb->unacked->tcphdr->seqno) +
   1015                                                TCP_TCPLEN(pcb->unacked)));
   1016          
   1017                  next = pcb->unacked;
   1018                  pcb->unacked = pcb->unacked->next;
   \                     ??tcp_receive_14:
   \   0000021C   000099E5           LDR      R0,[R9, #+0]
   \   00000220   700084E5           STR      R0,[R4, #+112]
   1019          
   1020                  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
   1021                  LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
   1022                  /* Prevent ACK for FIN to generate a sent event */
   1023                  if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
   \   00000224   B406D4E1           LDRH     R0,[R4, #+100]
   \   00000228   000050E3           CMP      R0,#+0
   \   0000022C   0800000A           BEQ      ??tcp_receive_15
   \   00000230   0C0099E5           LDR      R0,[R9, #+12]
   \   00000234   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000238   0C00D0E5           LDRB     R0,[R0, #+12]
   \   0000023C   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000240   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000244   010010E3           TST      R0,#0x1
   1024                    pcb->acked--;
   \   00000248   B406D411           LDRHNE   R0,[R4, #+100]
   \   0000024C   00008510           ADDNE    R0,R5,R0
   \   00000250   B406C411           STRHNE   R0,[R4, #+100]
   1025                  }
   1026          
   1027                  pcb->snd_queuelen -= pbuf_clen(next->p);
   \                     ??tcp_receive_15:
   \   00000254   040099E5           LDR      R0,[R9, #+4]
   \   00000258   ........           _BLF     pbuf_clen,??pbuf_clen??rA
   \   0000025C   B816D4E1           LDRH     R1,[R4, #+104]
   \   00000260   000041E0           SUB      R0,R1,R0
   \   00000264   B806C4E1           STRH     R0,[R4, #+104]
   1028                  tcp_seg_free(next);
   \   00000268   0900A0E1           MOV      R0,R9
   \   0000026C   ........           _BLF     tcp_seg_free,??tcp_seg_free??rA
   1029          
   1030                  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
   1031                  if (pcb->snd_queuelen != 0) {
   1032                    LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
   1033                                pcb->unsent != NULL);
   1034                  }
   1035                }
   \                     ??tcp_receive_11:
   \   00000270   700094E5           LDR      R0,[R4, #+112]
   \   00000274   000050E3           CMP      R0,#+0
   \   00000278   1E00000A           BEQ      ??tcp_receive_16
   \   0000027C   0C1090E5           LDR      R1,[R0, #+12]
   \   00000280   0C2090E5           LDR      R2,[R0, #+12]
   \   00000284   0710D1E5           LDRB     R1,[R1, #+7]
   \   00000288   0620D2E5           LDRB     R2,[R2, #+6]
   \   0000028C   011482E1           ORR      R1,R2,R1, LSL #+8
   \   00000290   0C2090E5           LDR      R2,[R0, #+12]
   \   00000294   0C0090E5           LDR      R0,[R0, #+12]
   \   00000298   0520D2E5           LDRB     R2,[R2, #+5]
   \   0000029C   0400D0E5           LDRB     R0,[R0, #+4]
   \   000002A0   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000002A4   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000002A8   ........           _BLF     lwip_ntohl,??lwip_ntohl??rA
   \   000002AC   00A0A0E1           MOV      R10,R0
   \   000002B0   700094E5           LDR      R0,[R4, #+112]
   \   000002B4   0C1090E5           LDR      R1,[R0, #+12]
   \   000002B8   0C0090E5           LDR      R0,[R0, #+12]
   \   000002BC   0D10D1E5           LDRB     R1,[R1, #+13]
   \   000002C0   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000002C4   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000002C8   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000002CC   709094E5           LDR      R9,[R4, #+112]
   \   000002D0   030010E3           TST      R0,#0x3
   \   000002D4   B810D9E1           LDRH     R1,[R9, #+8]
   \   000002D8   0100A013           MOVNE    R0,#+1
   \   000002DC   0000A003           MOVEQ    R0,#+0
   \   000002E0   010080E0           ADD      R0,R0,R1
   \   000002E4   1C1097E5           LDR      R1,[R7, #+28]
   \   000002E8   0A0080E0           ADD      R0,R0,R10
   \   000002EC   010040E0           SUB      R0,R0,R1
   \   000002F0   010050E3           CMP      R0,#+1
   \   000002F4   C8FFFFBA           BLT      ??tcp_receive_14
   1036          
   1037                /* If there's nothing left to acknowledge, stop the retransmit
   1038                   timer, otherwise reset it to start again */
   1039                if(pcb->unacked == NULL)
   \                     ??tcp_receive_16:
   \   000002F8   700094E5           LDR      R0,[R4, #+112]
   \   000002FC   000050E3           CMP      R0,#+0
   1040                  pcb->rtime = -1;
   \   00000300   00006602           RSBEQ    R0,R6,#+0
   1041                else
   1042                  pcb->rtime = 0;
   \   00000304   0000A013           MOVNE    R0,#+0
   \   00000308   B403C4E1           STRH     R0,[R4, #+52]
   1043          
   1044                pcb->polltmr = 0;
   \   0000030C   1F80C4E5           STRB     R8,[R4, #+31]
   \   00000310   180000EA           B        ??tcp_receive_8
   1045              } else {
   1046                /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
   1047                pcb->acked = 0;
   \                     ??tcp_receive_9:
   \   00000314   B486C4E1           STRH     R8,[R4, #+100]
   \   00000318   160000EA           B        ??tcp_receive_8
   1048              }
   1049          
   1050              /* We go through the ->unsent list to see if any of the segments
   1051                 on the list are acknowledged by the ACK. This may seem
   1052                 strange since an "unsent" segment shouldn't be acked. The
   1053                 rationale is that lwIP puts all outstanding segments on the
   1054                 ->unsent list after a retransmission, so these segments may
   1055                 in fact have been sent once. */
   1056              while (pcb->unsent != NULL &&
   1057                     TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) +
   1058                                     TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
   1059                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
   1060                                              ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
   1061                                              TCP_TCPLEN(pcb->unsent)));
   1062          
   1063                next = pcb->unsent;
   1064                pcb->unsent = pcb->unsent->next;
   \                     ??tcp_receive_17:
   \   0000031C   000099E5           LDR      R0,[R9, #+0]
   \   00000320   6C0084E5           STR      R0,[R4, #+108]
   1065          #if TCP_OVERSIZE
   1066                if (pcb->unsent == NULL) {
   \   00000324   000050E3           CMP      R0,#+0
   1067                  pcb->unsent_oversize = 0;
   \   00000328   BA86C401           STRHEQ   R8,[R4, #+106]
   1068                }
   1069          #endif /* TCP_OVERSIZE */
   1070                LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
   1071                LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
   1072                /* Prevent ACK for FIN to generate a sent event */
   1073                if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
   \   0000032C   B406D4E1           LDRH     R0,[R4, #+100]
   \   00000330   000050E3           CMP      R0,#+0
   \   00000334   0800000A           BEQ      ??tcp_receive_18
   \   00000338   0C0099E5           LDR      R0,[R9, #+12]
   \   0000033C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000340   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000344   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000348   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   0000034C   010010E3           TST      R0,#0x1
   1074                  pcb->acked--;
   \   00000350   B406D411           LDRHNE   R0,[R4, #+100]
   \   00000354   00008510           ADDNE    R0,R5,R0
   \   00000358   B406C411           STRHNE   R0,[R4, #+100]
   1075                }
   1076                pcb->snd_queuelen -= pbuf_clen(next->p);
   \                     ??tcp_receive_18:
   \   0000035C   040099E5           LDR      R0,[R9, #+4]
   \   00000360   ........           _BLF     pbuf_clen,??pbuf_clen??rA
   \   00000364   B816D4E1           LDRH     R1,[R4, #+104]
   \   00000368   000041E0           SUB      R0,R1,R0
   \   0000036C   B806C4E1           STRH     R0,[R4, #+104]
   1077                tcp_seg_free(next);
   \   00000370   0900A0E1           MOV      R0,R9
   \   00000374   ........           _BLF     tcp_seg_free,??tcp_seg_free??rA
   1078                LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
   1079                if (pcb->snd_queuelen != 0) {
   1080                  LWIP_ASSERT("tcp_receive: valid queue length",
   1081                    pcb->unacked != NULL || pcb->unsent != NULL);
   1082                }
   1083              }
   \                     ??tcp_receive_8:
   \   00000378   6C0094E5           LDR      R0,[R4, #+108]
   \   0000037C   000050E3           CMP      R0,#+0
   \   00000380   2100000A           BEQ      ??tcp_receive_19
   \   00000384   0C1090E5           LDR      R1,[R0, #+12]
   \   00000388   0C2090E5           LDR      R2,[R0, #+12]
   \   0000038C   0710D1E5           LDRB     R1,[R1, #+7]
   \   00000390   0620D2E5           LDRB     R2,[R2, #+6]
   \   00000394   011482E1           ORR      R1,R2,R1, LSL #+8
   \   00000398   0C2090E5           LDR      R2,[R0, #+12]
   \   0000039C   0C0090E5           LDR      R0,[R0, #+12]
   \   000003A0   0520D2E5           LDRB     R2,[R2, #+5]
   \   000003A4   0400D0E5           LDRB     R0,[R0, #+4]
   \   000003A8   011482E1           ORR      R1,R2,R1, LSL #+8
   \   000003AC   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000003B0   ........           _BLF     lwip_ntohl,??lwip_ntohl??rA
   \   000003B4   00A0A0E1           MOV      R10,R0
   \   000003B8   6C0094E5           LDR      R0,[R4, #+108]
   \   000003BC   0C1090E5           LDR      R1,[R0, #+12]
   \   000003C0   0C0090E5           LDR      R0,[R0, #+12]
   \   000003C4   0D10D1E5           LDRB     R1,[R1, #+13]
   \   000003C8   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000003CC   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000003D0   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000003D4   6C9094E5           LDR      R9,[R4, #+108]
   \   000003D8   1C1097E5           LDR      R1,[R7, #+28]
   \   000003DC   B830D9E1           LDRH     R3,[R9, #+8]
   \   000003E0   030010E3           TST      R0,#0x3
   \   000003E4   0100A013           MOVNE    R0,#+1
   \   000003E8   0000A003           MOVEQ    R0,#+0
   \   000003EC   0A2041E0           SUB      R2,R1,R10
   \   000003F0   032042E0           SUB      R2,R2,R3
   \   000003F4   000052E0           SUBS     R0,R2,R0
   \   000003F8   0300004A           BMI      ??tcp_receive_19
   \   000003FC   500094E5           LDR      R0,[R4, #+80]
   \   00000400   000041E0           SUB      R0,R1,R0
   \   00000404   010050E3           CMP      R0,#+1
   \   00000408   C3FFFFBA           BLT      ??tcp_receive_17
   1084              /* End of ACK for new data processing. */
   1085          
   1086              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
   1087                                          pcb->rttest, pcb->rtseq, ackno));
   1088          
   1089              /* RTT estimation calculations. This is done by checking if the
   1090                 incoming segment acknowledges the segment we use to take a
   1091                 round-trip time measurement. */
   1092              if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
   \                     ??tcp_receive_19:
   \   0000040C   380094E5           LDR      R0,[R4, #+56]
   \   00000410   000050E3           CMP      R0,#+0
   \   00000414   1B00000A           BEQ      ??tcp_receive_0
   \   00000418   3C1094E5           LDR      R1,[R4, #+60]
   \   0000041C   1C2097E5           LDR      R2,[R7, #+28]
   \   00000420   021051E0           SUBS     R1,R1,R2
   \   00000424   1700005A           BPL      ??tcp_receive_0
   1093                /* diff between this shouldn't exceed 32K since this are tcp timer ticks
   1094                   and a round-trip shouldn't be that long... */
   1095                m = (s16_t)(tcp_ticks - pcb->rttest);
   1096          
   1097                LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
   1098                                            m, m * TCP_SLOW_INTERVAL));
   1099          
   1100                /* This is taken directly from VJs original code in his paper */
   1101                m = m - (pcb->sa >> 3);
   \   00000428   F014D4E1           LDRSH    R1,[R4, #+64]
   \   0000042C   ........           LDR      R2,??DataTable27  ;; tcp_ticks
   \   00000430   002092E5           LDR      R2,[R2, #+0]
   \   00000434   000042E0           SUB      R0,R2,R0
   \   00000438   C10140E0           SUB      R0,R0,R1, ASR #+3
   \   0000043C   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000440   4008A0E1           MOV      R0,R0, ASR #+16
   1102                pcb->sa += m;
   \   00000444   011080E0           ADD      R1,R0,R1
   \   00000448   B014C4E1           STRH     R1,[R4, #+64]
   1103                if (m < 0) {
   1104                  m = -m;
   1105                }
   1106                m = m - (pcb->sv >> 2);
   1107                pcb->sv += m;
   \   0000044C   F224D4E1           LDRSH    R2,[R4, #+66]
   \   00000450   000050E3           CMP      R0,#+0
   \   00000454   00006042           RSBMI    R0,R0,#+0
   \   00000458   0008A041           MOVMI    R0,R0, LSL #+16
   \   0000045C   4008A041           MOVMI    R0,R0, ASR #+16
   \   00000460   020080E0           ADD      R0,R0,R2
   \   00000464   420140E0           SUB      R0,R0,R2, ASR #+2
   \   00000468   B204C4E1           STRH     R0,[R4, #+66]
   1108                pcb->rto = (pcb->sa >> 3) + pcb->sv;
   \   0000046C   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000470   4118A0E1           MOV      R1,R1, ASR #+16
   \   00000474   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000478   4008A0E1           MOV      R0,R0, ASR #+16
   \   0000047C   C10180E0           ADD      R0,R0,R1, ASR #+3
   \   00000480   B404C4E1           STRH     R0,[R4, #+68]
   1109          
   1110                LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
   1111                                            pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));
   1112          
   1113                pcb->rttest = 0;
   \   00000484   388084E5           STR      R8,[R4, #+56]
   1114              }
   1115            }
   1116          
   1117            /* If the incoming segment contains data, we must process it
   1118               further unless the pcb already received a FIN.
   1119               (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
   1120               LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
   1121            if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
   \                     ??tcp_receive_0:
   \   00000488   1E00D4E5           LDRB     R0,[R4, #+30]
   \   0000048C   B091D7E1           LDRH     R9,[R7, #+16]
   \   00000490   282094E5           LDR      R2,[R4, #+40]
   \   00000494   183097E5           LDR      R3,[R7, #+24]
   \   00000498   020080E3           ORR      R0,R0,#0x2
   \   0000049C   021043E0           SUB      R1,R3,R2
   \   000004A0   000059E3           CMP      R9,#+0
   \   000004A4   4A02000A           BEQ      ??tcp_receive_20
   \   000004A8   18A0D4E5           LDRB     R10,[R4, #+24]
   \   000004AC   07005AE3           CMP      R10,#+7
   \   000004B0   4702002A           BCS      ??tcp_receive_20
   1122              /* This code basically does three things:
   1123          
   1124              +) If the incoming segment contains data that is the next
   1125              in-sequence data, this data is passed to the application. This
   1126              might involve trimming the first edge of the data. The rcv_nxt
   1127              variable and the advertised window are adjusted.
   1128          
   1129              +) If the incoming segment has data that is above the next
   1130              sequence number expected (->rcv_nxt), the segment is placed on
   1131              the ->ooseq queue. This is done by finding the appropriate
   1132              place in the ->ooseq queue (which is ordered by sequence
   1133              number) and trim the segment in both ends if needed. An
   1134              immediate ACK is sent to indicate that we received an
   1135              out-of-sequence segment.
   1136          
   1137              +) Finally, we check if the first segment on the ->ooseq queue
   1138              now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
   1139              rcv_nxt > ooseq->seqno, we must trim the first edge of the
   1140              segment on ->ooseq before we adjust rcv_nxt. The data in the
   1141              segments that are now on sequence are chained onto the
   1142              incoming segment so that we only need to call the application
   1143              once.
   1144              */
   1145          
   1146              /* First, we check if we must trim the first edge. We have to do
   1147                 this if the sequence number of the incoming segment is less
   1148                 than rcv_nxt, and the sequence number plus the length of the
   1149                 segment is larger than rcv_nxt. */
   1150              /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
   1151                    if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
   1152              if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
   \   000004B4   033042E0           SUB      R3,R2,R3
   \   000004B8   012053E2           SUBS     R2,R3,#+1
   \   000004BC   2E00004A           BMI      ??tcp_receive_21
   \   000004C0   092043E0           SUB      R2,R3,R9
   \   000004C4   012082E2           ADD      R2,R2,#+1
   \   000004C8   010052E3           CMP      R2,#+1
   \   000004CC   2A0000AA           BGE      ??tcp_receive_21
   1153                /* Trimming the first edge is done by pushing the payload
   1154                   pointer in the pbuf downwards. This is somewhat tricky since
   1155                   we do not want to discard the full contents of the pbuf up to
   1156                   the new starting point of the data since we have to keep the
   1157                   TCP header which is present in the first pbuf in the chain.
   1158          
   1159                   What is done is really quite a nasty hack: the first pbuf in
   1160                   the pbuf chain is pointed to by inseg.p. Since we need to be
   1161                   able to deallocate the whole pbuf, we cannot change this
   1162                   inseg.p pointer to point to any of the later pbufs in the
   1163                   chain. Instead, we point the ->payload pointer in the first
   1164                   pbuf to data in one of the later pbufs. We also set the
   1165                   inseg.data pointer to point to the right place. This way, the
   1166                   ->p pointer will still point to the first pbuf, but the
   1167                   ->p->payload pointer will point to data in another pbuf.
   1168          
   1169                   After we are done with adjusting the pbuf pointers we must
   1170                   adjust the ->data pointer in the seg and the segment
   1171                   length.*/
   1172          
   1173                off = pcb->rcv_nxt - seqno;
   1174                p = inseg.p;
   \   000004D0   042097E5           LDR      R2,[R7, #+4]
   \   000004D4   0200A0E1           MOV      R0,R2
   1175                LWIP_ASSERT("inseg.p != NULL", inseg.p);
   1176                LWIP_ASSERT("insane offset!", (off < 0x7fff));
   1177                if (inseg.p->len < off) {
   \   000004D8   BA10D2E1           LDRH     R1,[R2, #+10]
   \   000004DC   030051E1           CMP      R1,R3
   \   000004E0   0E0000AA           BGE      ??tcp_receive_22
   1178                  LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
   1179                  new_tot_len = (u16_t)(inseg.p->tot_len - off);
   \   000004E4   B810D2E1           LDRH     R1,[R2, #+8]
   \   000004E8   BA20D0E1           LDRH     R2,[R0, #+10]
   \   000004EC   031041E0           SUB      R1,R1,R3
   \   000004F0   0118A0E1           MOV      R1,R1, LSL #+16
   \   000004F4   2118A0E1           MOV      R1,R1, LSR #+16
   \   000004F8   030052E1           CMP      R2,R3
   \   000004FC   070000AA           BGE      ??tcp_receive_22
   1180                  while (p->len < off) {
   1181                    off -= p->len;
   \                     ??tcp_receive_23:
   \   00000500   BA20D0E1           LDRH     R2,[R0, #+10]
   1182                    /* KJM following line changed (with addition of new_tot_len var)
   1183                       to fix bug #9076
   1184                       inseg.p->tot_len -= p->len; */
   1185                    p->tot_len = new_tot_len;
   \   00000504   B810C0E1           STRH     R1,[R0, #+8]
   1186                    p->len = 0;
   \   00000508   BA80C0E1           STRH     R8,[R0, #+10]
   1187                    p = p->next;
   \   0000050C   000090E5           LDR      R0,[R0, #+0]
   \   00000510   023043E0           SUB      R3,R3,R2
   1188                  }
   \   00000514   BA20D0E1           LDRH     R2,[R0, #+10]
   \   00000518   030052E1           CMP      R2,R3
   \   0000051C   F7FFFFBA           BLT      ??tcp_receive_23
   1189                  if(pbuf_header(p, (s16_t)-off)) {
   1190                    /* Do we need to cope with this failing?  Assert for now */
   1191                    LWIP_ASSERT("pbuf_header failed", 0);
   1192                  }
   1193                } else {
   1194                  if(pbuf_header(inseg.p, (s16_t)-off)) {
   \                     ??tcp_receive_22:
   \   00000520   001063E2           RSB      R1,R3,#+0
   \   00000524   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000528   4118A0E1           MOV      R1,R1, ASR #+16
   \   0000052C   ........           _BLF     pbuf_header,??pbuf_header??rA
   1195                    /* Do we need to cope with this failing?  Assert for now */
   1196                    LWIP_ASSERT("pbuf_header failed", 0);
   1197                  }
   1198                }
   1199                inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
   \   00000530   B810D7E1           LDRH     R1,[R7, #+8]
   \   00000534   280094E5           LDR      R0,[R4, #+40]
   \   00000538   182097E5           LDR      R2,[R7, #+24]
   \   0000053C   001041E0           SUB      R1,R1,R0
   \   00000540   011082E0           ADD      R1,R2,R1
   \   00000544   B810C7E1           STRH     R1,[R7, #+8]
   1200                inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
   \   00000548   0C1097E5           LDR      R1,[R7, #+12]
   \   0000054C   180087E5           STR      R0,[R7, #+24]
   \   00000550   0400C1E5           STRB     R0,[R1, #+4]
   \   00000554   0C1097E5           LDR      R1,[R7, #+12]
   \   00000558   2004A0E1           LSR      R0,R0,#+8
   \   0000055C   0500C1E5           STRB     R0,[R1, #+5]
   \   00000560   0C1097E5           LDR      R1,[R7, #+12]
   \   00000564   2004A0E1           LSR      R0,R0,#+8
   \   00000568   0600C1E5           STRB     R0,[R1, #+6]
   \   0000056C   0C1097E5           LDR      R1,[R7, #+12]
   \   00000570   2004A0E1           LSR      R0,R0,#+8
   \   00000574   0700C1E5           STRB     R0,[R1, #+7]
   \   00000578   010000EA           B        ??tcp_receive_24
   1201              }
   1202              else {
   1203                if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
   \                     ??tcp_receive_21:
   \   0000057C   000051E3           CMP      R1,#+0
   1204                  /* the whole segment is < rcv_nxt */
   1205                  /* must be a duplicate of a packet that has already been correctly handled */
   1206          
   1207                  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
   1208                  tcp_ack_now(pcb);
   \   00000580   1E00C445           STRBMI   R0,[R4, #+30]
   1209                }
   1210              }
   1211          
   1212              /* The sequence number must be within the window (above rcv_nxt
   1213                 and below rcv_nxt + rcv_wnd) in order to be further
   1214                 processed. */
   1215              if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
   1216                                  pcb->rcv_nxt + pcb->rcv_wnd - 1)){
   \                     ??tcp_receive_24:
   \   00000584   280094E5           LDR      R0,[R4, #+40]
   \   00000588   181097E5           LDR      R1,[R7, #+24]
   \   0000058C   002051E0           SUBS     R2,R1,R0
   \   00000590   0C02004A           BMI      ??tcp_receive_25
   \   00000594   BC32D4E1           LDRH     R3,[R4, #+44]
   \   00000598   032042E0           SUB      R2,R2,R3
   \   0000059C   012082E2           ADD      R2,R2,#+1
   \   000005A0   010052E3           CMP      R2,#+1
   \   000005A4   070200AA           BGE      ??tcp_receive_25
   1217                if (pcb->rcv_nxt == seqno) {
   \   000005A8   FCBDC5E3           BIC      R11,R5,#0x3F00
   \   000005AC   010050E1           CMP      R0,R1
   \   000005B0   2601001A           BNE      ??tcp_receive_26
   1218                  /* The incoming segment is the next in sequence. We check if
   1219                     we have to trim the end of the segment and update rcv_nxt
   1220                     and pass the data to the application. */
   1221                  tcplen = TCP_TCPLEN(&inseg);
   \   000005B4   0C0097E5           LDR      R0,[R7, #+12]
   \   000005B8   0D10D0E5           LDRB     R1,[R0, #+13]
   \   000005BC   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000005C0   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000005C4   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000005C8   B810D7E1           LDRH     R1,[R7, #+8]
   \   000005CC   030010E3           TST      R0,#0x3
   \   000005D0   0100A013           MOVNE    R0,#+1
   \   000005D4   0000A003           MOVEQ    R0,#+0
   \   000005D8   010080E0           ADD      R0,R0,R1
   \   000005DC   B001C7E1           STRH     R0,[R7, #+16]
   1222          
   1223                  if (tcplen > pcb->rcv_wnd) {
   \   000005E0   BC12D4E1           LDRH     R1,[R4, #+44]
   \   000005E4   0008A0E1           MOV      R0,R0, LSL #+16
   \   000005E8   200851E1           CMP      R1,R0, LSR #+16
   \   000005EC   3000002A           BCS      ??tcp_receive_27
   1224                    LWIP_DEBUGF(TCP_INPUT_DEBUG,
   1225                                ("tcp_receive: other end overran receive window"
   1226                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
   1227                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
   1228                    if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   \   000005F0   0C0097E5           LDR      R0,[R7, #+12]
   \   000005F4   0D10D0E5           LDRB     R1,[R0, #+13]
   \   000005F8   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000005FC   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000600   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000604   010010E3           TST      R0,#0x1
   \   00000608   1000000A           BEQ      ??tcp_receive_28
   1229                      /* Must remove the FIN from the header as we're trimming
   1230                       * that byte of sequence-space from the packet */
   1231                      TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
   \   0000060C   0C0097E5           LDR      R0,[R7, #+12]
   \   00000610   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000614   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000618   010480E1           ORR      R0,R0,R1, LSL #+8
   \   0000061C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000620   3E0000E2           AND      R0,R0,#0x3E
   \   00000624   ........           _BLF     lwip_htons,??lwip_htons??rA
   \   00000628   0C1097E5           LDR      R1,[R7, #+12]
   \   0000062C   0D20D1E5           LDRB     R2,[R1, #+13]
   \   00000630   0C30D1E5           LDRB     R3,[R1, #+12]
   \   00000634   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000638   02200BE0           AND      R2,R11,R2
   \   0000063C   020080E1           ORR      R0,R0,R2
   \   00000640   0C00C1E5           STRB     R0,[R1, #+12]
   \   00000644   0C1097E5           LDR      R1,[R7, #+12]
   \   00000648   2004A0E1           LSR      R0,R0,#+8
   \   0000064C   0D00C1E5           STRB     R0,[R1, #+13]
   1232                    }
   1233                    /* Adjust length of segment to fit in the window. */
   1234                    inseg.len = pcb->rcv_wnd;
   \                     ??tcp_receive_28:
   \   00000650   BC02D4E1           LDRH     R0,[R4, #+44]
   \   00000654   B800C7E1           STRH     R0,[R7, #+8]
   1235                    if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   \   00000658   0C0097E5           LDR      R0,[R7, #+12]
   \   0000065C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000660   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000664   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000668   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   0000066C   020010E3           TST      R0,#0x2
   1236                      inseg.len -= 1;
   \   00000670   B800D711           LDRHNE   R0,[R7, #+8]
   \   00000674   00008510           ADDNE    R0,R5,R0
   \   00000678   B800C711           STRHNE   R0,[R7, #+8]
   1237                    }
   1238                    pbuf_realloc(inseg.p, inseg.len);
   \   0000067C   B810D7E1           LDRH     R1,[R7, #+8]
   \   00000680   040097E5           LDR      R0,[R7, #+4]
   \   00000684   ........           _BLF     pbuf_realloc,??pbuf_realloc??rA
   1239                    tcplen = TCP_TCPLEN(&inseg);
   \   00000688   0C0097E5           LDR      R0,[R7, #+12]
   \   0000068C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000690   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000694   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000698   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   0000069C   B810D7E1           LDRH     R1,[R7, #+8]
   \   000006A0   030010E3           TST      R0,#0x3
   \   000006A4   0100A013           MOVNE    R0,#+1
   \   000006A8   0000A003           MOVEQ    R0,#+0
   \   000006AC   010080E0           ADD      R0,R0,R1
   \   000006B0   B001C7E1           STRH     R0,[R7, #+16]
   1240                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
   1241                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
   1242                  }
   1243          #if TCP_QUEUE_OOSEQ
   1244                  /* Received in-sequence data, adjust ooseq data if:
   1245                     - FIN has been received or
   1246                     - inseq overlaps with ooseq */
   1247                  if (pcb->ooseq != NULL) {
   \                     ??tcp_receive_27:
   \   000006B4   740094E5           LDR      R0,[R4, #+116]
   \   000006B8   000050E3           CMP      R0,#+0
   \   000006BC   6E00000A           BEQ      ??tcp_receive_29
   1248                    if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   \   000006C0   0C0097E5           LDR      R0,[R7, #+12]
   \   000006C4   0D10D0E5           LDRB     R1,[R0, #+13]
   \   000006C8   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000006CC   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000006D0   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000006D4   010010E3           TST      R0,#0x1
   \   000006D8   0600000A           BEQ      ??tcp_receive_30
   1249                      LWIP_DEBUGF(TCP_INPUT_DEBUG,
   1250                                  ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
   1251                      /* Received in-order FIN means anything that was received
   1252                       * out of order must now have been received in-order, so
   1253                       * bin the ooseq queue */
   1254                      while (pcb->ooseq != NULL) {
   \                     ??tcp_receive_31:
   \   000006DC   740094E5           LDR      R0,[R4, #+116]
   \   000006E0   000050E3           CMP      R0,#+0
   \   000006E4   6400000A           BEQ      ??tcp_receive_29
   1255                        struct tcp_seg *old_ooseq = pcb->ooseq;
   1256                        pcb->ooseq = pcb->ooseq->next;
   \   000006E8   001090E5           LDR      R1,[R0, #+0]
   \   000006EC   741084E5           STR      R1,[R4, #+116]
   1257                        tcp_seg_free(old_ooseq);
   \   000006F0   ........           _BLF     tcp_seg_free,??tcp_seg_free??rA
   \   000006F4   F8FFFFEA           B        ??tcp_receive_31
   1258                      }
   1259                    } else {
   1260                      next = pcb->ooseq;
   \                     ??tcp_receive_30:
   \   000006F8   749094E5           LDR      R9,[R4, #+116]
   \   000006FC   060000EA           B        ??tcp_receive_32
   1261                      /* Remove all segments on ooseq that are covered by inseg already.
   1262                       * FIN is copied from ooseq to inseg if present. */
   1263                      while (next &&
   1264                             TCP_SEQ_GEQ(seqno + tcplen,
   1265                                         next->tcphdr->seqno + next->len)) {
   1266                        /* inseg cannot have FIN here (already processed above) */
   1267                        if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
   1268                            (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
   1269                          TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
   1270                          tcplen = TCP_TCPLEN(&inseg);
   \                     ??tcp_receive_33:
   \   00000700   B810D7E1           LDRH     R1,[R7, #+8]
   \   00000704   010080E0           ADD      R0,R0,R1
   \   00000708   B001C7E1           STRH     R0,[R7, #+16]
   1271                        }
   1272                        prev = next;
   \                     ??tcp_receive_34:
   \   0000070C   09A0A0E1           MOV      R10,R9
   1273                        next = next->next;
   \   00000710   009099E5           LDR      R9,[R9, #+0]
   1274                        tcp_seg_free(prev);
   \   00000714   0A00A0E1           MOV      R0,R10
   \   00000718   ........           _BLF     tcp_seg_free,??tcp_seg_free??rA
   \                     ??tcp_receive_32:
   \   0000071C   000059E3           CMP      R9,#+0
   \   00000720   5400000A           BEQ      ??tcp_receive_35
   \   00000724   0C2099E5           LDR      R2,[R9, #+12]
   \   00000728   0730D2E5           LDRB     R3,[R2, #+7]
   \   0000072C   06A0D2E5           LDRB     R10,[R2, #+6]
   \   00000730   B011D7E1           LDRH     R1,[R7, #+16]
   \   00000734   180097E5           LDR      R0,[R7, #+24]
   \   00000738   03348AE1           ORR      R3,R10,R3, LSL #+8
   \   0000073C   05A0D2E5           LDRB     R10,[R2, #+5]
   \   00000740   001081E0           ADD      R1,R1,R0
   \   00000744   03348AE1           ORR      R3,R10,R3, LSL #+8
   \   00000748   04A0D2E5           LDRB     R10,[R2, #+4]
   \   0000074C   03348AE1           ORR      R3,R10,R3, LSL #+8
   \   00000750   B8A0D9E1           LDRH     R10,[R9, #+8]
   \   00000754   033041E0           SUB      R3,R1,R3
   \   00000758   0A3053E0           SUBS     R3,R3,R10
   \   0000075C   2000004A           BMI      ??tcp_receive_36
   \   00000760   0D00D2E5           LDRB     R0,[R2, #+13]
   \   00000764   0C10D2E5           LDRB     R1,[R2, #+12]
   \   00000768   000481E1           ORR      R0,R1,R0, LSL #+8
   \   0000076C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000770   010010E3           TST      R0,#0x1
   \   00000774   E4FFFF0A           BEQ      ??tcp_receive_34
   \   00000778   0C0097E5           LDR      R0,[R7, #+12]
   \   0000077C   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000780   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000784   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000788   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   0000078C   020010E3           TST      R0,#0x2
   \   00000790   DDFFFF1A           BNE      ??tcp_receive_34
   \   00000794   0100A0E3           MOV      R0,#+1
   \   00000798   ........           _BLF     lwip_htons,??lwip_htons??rA
   \   0000079C   0C1097E5           LDR      R1,[R7, #+12]
   \   000007A0   0D20D1E5           LDRB     R2,[R1, #+13]
   \   000007A4   0C30D1E5           LDRB     R3,[R1, #+12]
   \   000007A8   022483E1           ORR      R2,R3,R2, LSL #+8
   \   000007AC   020080E1           ORR      R0,R0,R2
   \   000007B0   0C00C1E5           STRB     R0,[R1, #+12]
   \   000007B4   0C1097E5           LDR      R1,[R7, #+12]
   \   000007B8   2004A0E1           LSR      R0,R0,#+8
   \   000007BC   0D00C1E5           STRB     R0,[R1, #+13]
   \   000007C0   0C0097E5           LDR      R0,[R7, #+12]
   \   000007C4   0D10D0E5           LDRB     R1,[R0, #+13]
   \   000007C8   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000007CC   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000007D0   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000007D4   030010E3           TST      R0,#0x3
   \   000007D8   0000A003           MOVEQ    R0,#+0
   \   000007DC   0100A013           MOVNE    R0,#+1
   \   000007E0   C6FFFFEA           B        ??tcp_receive_33
   1275                      }
   \                     ??tcp_receive_36:
   \   000007E4   0730D2E5           LDRB     R3,[R2, #+7]
   \   000007E8   06A0D2E5           LDRB     R10,[R2, #+6]
   \   000007EC   03348AE1           ORR      R3,R10,R3, LSL #+8
   \   000007F0   05A0D2E5           LDRB     R10,[R2, #+5]
   \   000007F4   03348AE1           ORR      R3,R10,R3, LSL #+8
   \   000007F8   04A0D2E5           LDRB     R10,[R2, #+4]
   \   000007FC   03348AE1           ORR      R3,R10,R3, LSL #+8
   \   00000800   031041E0           SUB      R1,R1,R3
   \   00000804   010051E3           CMP      R1,#+1
   \   00000808   1A0000BA           BLT      ??tcp_receive_35
   1276                      /* Now trim right side of inseg if it overlaps with the first
   1277                       * segment on ooseq */
   1278                      if (next &&
   1279                          TCP_SEQ_GT(seqno + tcplen,
   1280                                     next->tcphdr->seqno)) {
   1281                        /* inseg cannot have FIN here (already processed above) */
   1282                        inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
   \   0000080C   0510D2E5           LDRB     R1,[R2, #+5]
   \   00000810   01148AE1           ORR      R1,R10,R1, LSL #+8
   \   00000814   000041E0           SUB      R0,R1,R0
   \   00000818   B800C7E1           STRH     R0,[R7, #+8]
   1283                        if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   \   0000081C   0C0097E5           LDR      R0,[R7, #+12]
   \   00000820   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000824   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000828   010480E1           ORR      R0,R0,R1, LSL #+8
   \   0000082C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000830   020010E3           TST      R0,#0x2
   1284                          inseg.len -= 1;
   \   00000834   B800D711           LDRHNE   R0,[R7, #+8]
   \   00000838   00008510           ADDNE    R0,R5,R0
   \   0000083C   B800C711           STRHNE   R0,[R7, #+8]
   1285                        }
   1286                        pbuf_realloc(inseg.p, inseg.len);
   \   00000840   B810D7E1           LDRH     R1,[R7, #+8]
   \   00000844   040097E5           LDR      R0,[R7, #+4]
   \   00000848   ........           _BLF     pbuf_realloc,??pbuf_realloc??rA
   1287                        tcplen = TCP_TCPLEN(&inseg);
   \   0000084C   0C0097E5           LDR      R0,[R7, #+12]
   \   00000850   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000854   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000858   010480E1           ORR      R0,R0,R1, LSL #+8
   \   0000085C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000860   B810D7E1           LDRH     R1,[R7, #+8]
   \   00000864   030010E3           TST      R0,#0x3
   \   00000868   0100A013           MOVNE    R0,#+1
   \   0000086C   0000A003           MOVEQ    R0,#+0
   \   00000870   010080E0           ADD      R0,R0,R1
   \   00000874   B001C7E1           STRH     R0,[R7, #+16]
   1288                        LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
   1289                                    (seqno + tcplen) == next->tcphdr->seqno);
   1290                      }
   1291                      pcb->ooseq = next;
   \                     ??tcp_receive_35:
   \   00000878   749084E5           STR      R9,[R4, #+116]
   1292                    }
   1293                  }
   1294          #endif /* TCP_QUEUE_OOSEQ */
   1295          
   1296                  pcb->rcv_nxt = seqno + tcplen;
   \                     ??tcp_receive_29:
   \   0000087C   B001D7E1           LDRH     R0,[R7, #+16]
   \   00000880   181097E5           LDR      R1,[R7, #+24]
   \   00000884   011080E0           ADD      R1,R0,R1
   \   00000888   281084E5           STR      R1,[R4, #+40]
   1297          
   1298                  /* Update the receiver's (our) window. */
   1299                  LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
   1300                  pcb->rcv_wnd -= tcplen;
   \   0000088C   BC12D4E1           LDRH     R1,[R4, #+44]
   \   00000890   000041E0           SUB      R0,R1,R0
   \   00000894   BC02C4E1           STRH     R0,[R4, #+44]
   1301          
   1302                  tcp_update_rcv_ann_wnd(pcb);
   \   00000898   0400A0E1           MOV      R0,R4
   \   0000089C   ........           _BLF     tcp_update_rcv_ann_wnd,??tcp_update_rcv_ann_wnd??rA
   1303          
   1304                  /* If there is data in the segment, we make preparations to
   1305                     pass this up to the application. The ->recv_data variable
   1306                     is used for holding the pbuf that goes to the
   1307                     application. The code for reassembling out-of-sequence data
   1308                     chains its data on this pbuf as well.
   1309          
   1310                     If the segment was a FIN, we set the TF_GOT_FIN flag that will
   1311                     be used to indicate to the application that the remote side has
   1312                     closed its end of the connection. */
   1313                  if (inseg.p->tot_len > 0) {
   \   000008A0   040097E5           LDR      R0,[R7, #+4]
   \   000008A4   B810D0E1           LDRH     R1,[R0, #+8]
   \   000008A8   000051E3           CMP      R1,#+0
   1314                    recv_data = inseg.p;
   \   000008AC   20008715           STRNE    R0,[R7, #+32]
   1315                    /* Since this pbuf now is the responsibility of the
   1316                       application, we delete our reference to it so that we won't
   1317                       (mistakingly) deallocate it. */
   1318                    inseg.p = NULL;
   1319                  }
   1320                  if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   \   000008B0   0C0097E5           LDR      R0,[R7, #+12]
   \   000008B4   04808715           STRNE    R8,[R7, #+4]
   \   000008B8   0D10D0E5           LDRB     R1,[R0, #+13]
   \   000008BC   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000008C0   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000008C4   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000008C8   010010E3           TST      R0,#0x1
   \   000008CC   1700000A           BEQ      ??tcp_receive_37
   1321                    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
   1322                    recv_flags |= TF_GOT_FIN;
   \   000008D0   2900D7E5           LDRB     R0,[R7, #+41]
   \   000008D4   200080E3           ORR      R0,R0,#0x20
   \   000008D8   2900C7E5           STRB     R0,[R7, #+41]
   \   000008DC   130000EA           B        ??tcp_receive_37
   1323                  }
   1324          
   1325          #if TCP_QUEUE_OOSEQ
   1326                  /* We now check if we have segments on the ->ooseq queue that
   1327                     are now in sequence. */
   1328                  while (pcb->ooseq != NULL &&
   1329                         pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
   1330          
   1331                    cseg = pcb->ooseq;
   1332                    seqno = pcb->ooseq->tcphdr->seqno;
   1333          
   1334                    pcb->rcv_nxt += TCP_TCPLEN(cseg);
   1335                    LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
   1336                                pcb->rcv_wnd >= TCP_TCPLEN(cseg));
   1337                    pcb->rcv_wnd -= TCP_TCPLEN(cseg);
   1338          
   1339                    tcp_update_rcv_ann_wnd(pcb);
   1340          
   1341                    if (cseg->p->tot_len > 0) {
   1342                      /* Chain this pbuf onto the pbuf that we will pass to
   1343                         the application. */
   1344                      if (recv_data) {
   1345                        pbuf_cat(recv_data, cseg->p);
   1346                      } else {
   1347                        recv_data = cseg->p;
   \                     ??tcp_receive_38:
   \   000008E0   201087E5           STR      R1,[R7, #+32]
   1348                      }
   1349                      cseg->p = NULL;
   \                     ??tcp_receive_39:
   \   000008E4   048085E5           STR      R8,[R5, #+4]
   1350                    }
   1351                    if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
   \                     ??tcp_receive_40:
   \   000008E8   0C0095E5           LDR      R0,[R5, #+12]
   \   000008EC   0D10D0E5           LDRB     R1,[R0, #+13]
   \   000008F0   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000008F4   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000008F8   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000008FC   010010E3           TST      R0,#0x1
   \   00000900   0600000A           BEQ      ??tcp_receive_41
   1352                      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
   1353                      recv_flags |= TF_GOT_FIN;
   \   00000904   2900D7E5           LDRB     R0,[R7, #+41]
   \   00000908   200080E3           ORR      R0,R0,#0x20
   \   0000090C   2900C7E5           STRB     R0,[R7, #+41]
   1354                      if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
   \   00000910   1800D4E5           LDRB     R0,[R4, #+24]
   \   00000914   040050E3           CMP      R0,#+4
   1355                        pcb->state = CLOSE_WAIT;
   \   00000918   0700A003           MOVEQ    R0,#+7
   \   0000091C   1800C405           STRBEQ   R0,[R4, #+24]
   1356                      }
   1357                    }
   1358          
   1359                    pcb->ooseq = cseg->next;
   \                     ??tcp_receive_41:
   \   00000920   000095E5           LDR      R0,[R5, #+0]
   \   00000924   740084E5           STR      R0,[R4, #+116]
   1360                    tcp_seg_free(cseg);
   \   00000928   0500A0E1           MOV      R0,R5
   \   0000092C   ........           _BLF     tcp_seg_free,??tcp_seg_free??rA
   \                     ??tcp_receive_37:
   \   00000930   745094E5           LDR      R5,[R4, #+116]
   \   00000934   000055E3           CMP      R5,#+0
   \   00000938   3E00000A           BEQ      ??tcp_receive_42
   \   0000093C   0C0095E5           LDR      R0,[R5, #+12]
   \   00000940   0C1095E5           LDR      R1,[R5, #+12]
   \   00000944   0700D0E5           LDRB     R0,[R0, #+7]
   \   00000948   0610D1E5           LDRB     R1,[R1, #+6]
   \   0000094C   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000950   0C1095E5           LDR      R1,[R5, #+12]
   \   00000954   0510D1E5           LDRB     R1,[R1, #+5]
   \   00000958   000481E1           ORR      R0,R1,R0, LSL #+8
   \   0000095C   0C1095E5           LDR      R1,[R5, #+12]
   \   00000960   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000964   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000968   281094E5           LDR      R1,[R4, #+40]
   \   0000096C   010050E1           CMP      R0,R1
   \   00000970   3000001A           BNE      ??tcp_receive_42
   \   00000974   0C0095E5           LDR      R0,[R5, #+12]
   \   00000978   0C1095E5           LDR      R1,[R5, #+12]
   \   0000097C   0700D0E5           LDRB     R0,[R0, #+7]
   \   00000980   0610D1E5           LDRB     R1,[R1, #+6]
   \   00000984   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000988   0C1095E5           LDR      R1,[R5, #+12]
   \   0000098C   0510D1E5           LDRB     R1,[R1, #+5]
   \   00000990   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000994   0C1095E5           LDR      R1,[R5, #+12]
   \   00000998   0410D1E5           LDRB     R1,[R1, #+4]
   \   0000099C   000481E1           ORR      R0,R1,R0, LSL #+8
   \   000009A0   180087E5           STR      R0,[R7, #+24]
   \   000009A4   0C0095E5           LDR      R0,[R5, #+12]
   \   000009A8   0D10D0E5           LDRB     R1,[R0, #+13]
   \   000009AC   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000009B0   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000009B4   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000009B8   B820D5E1           LDRH     R2,[R5, #+8]
   \   000009BC   281094E5           LDR      R1,[R4, #+40]
   \   000009C0   030010E3           TST      R0,#0x3
   \   000009C4   0100A013           MOVNE    R0,#+1
   \   000009C8   0000A003           MOVEQ    R0,#+0
   \   000009CC   020080E0           ADD      R0,R0,R2
   \   000009D0   010080E0           ADD      R0,R0,R1
   \   000009D4   280084E5           STR      R0,[R4, #+40]
   \   000009D8   0C0095E5           LDR      R0,[R5, #+12]
   \   000009DC   0D10D0E5           LDRB     R1,[R0, #+13]
   \   000009E0   0C00D0E5           LDRB     R0,[R0, #+12]
   \   000009E4   010480E1           ORR      R0,R0,R1, LSL #+8
   \   000009E8   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000009EC   BC12D4E1           LDRH     R1,[R4, #+44]
   \   000009F0   B820D5E1           LDRH     R2,[R5, #+8]
   \   000009F4   030010E3           TST      R0,#0x3
   \   000009F8   0100A013           MOVNE    R0,#+1
   \   000009FC   0000A003           MOVEQ    R0,#+0
   \   00000A00   021041E0           SUB      R1,R1,R2
   \   00000A04   000041E0           SUB      R0,R1,R0
   \   00000A08   BC02C4E1           STRH     R0,[R4, #+44]
   \   00000A0C   0400A0E1           MOV      R0,R4
   \   00000A10   ........           _BLF     tcp_update_rcv_ann_wnd,??tcp_update_rcv_ann_wnd??rA
   \   00000A14   041095E5           LDR      R1,[R5, #+4]
   \   00000A18   B800D1E1           LDRH     R0,[R1, #+8]
   \   00000A1C   000050E3           CMP      R0,#+0
   \   00000A20   B0FFFF0A           BEQ      ??tcp_receive_40
   \   00000A24   200097E5           LDR      R0,[R7, #+32]
   \   00000A28   000050E3           CMP      R0,#+0
   \   00000A2C   ABFFFF0A           BEQ      ??tcp_receive_38
   \   00000A30   ........           _BLF     pbuf_cat,??pbuf_cat??rA
   \   00000A34   AAFFFFEA           B        ??tcp_receive_39
   1361                  }
   1362          #endif /* TCP_QUEUE_OOSEQ */
   1363          
   1364          
   1365                  /* Acknowledge the segment(s). */
   1366                  tcp_ack(pcb);
   \                     ??tcp_receive_42:
   \   00000A38   1E00D4E5           LDRB     R0,[R4, #+30]
   \   00000A3C   010010E3           TST      R0,#0x1
   \   00000A40   01008003           ORREQ    R0,R0,#0x1
   \   00000A44   FE000012           ANDNE    R0,R0,#0xFE
   \   00000A48   02008013           ORRNE    R0,R0,#0x2
   \   00000A4C   E70000EA           B        ??tcp_receive_43
   1367          
   1368                } else {
   1369                  /* We get here if the incoming segment is out-of-sequence. */
   1370                  tcp_send_empty_ack(pcb);
   \                     ??tcp_receive_26:
   \   00000A50   0400A0E1           MOV      R0,R4
   \   00000A54   ........           _BLF     tcp_send_empty_ack,??tcp_send_empty_ack??rA
   1371          #if TCP_QUEUE_OOSEQ
   1372                  /* We queue the segment on the ->ooseq queue. */
   1373                  if (pcb->ooseq == NULL) {
   \   00000A58   749094E5           LDR      R9,[R4, #+116]
   \   00000A5C   000059E3           CMP      R9,#+0
   \   00000A60   0300001A           BNE      ??tcp_receive_44
   1374                    pcb->ooseq = tcp_seg_copy(&inseg);
   \   00000A64   0700A0E1           MOV      R0,R7
   \   00000A68   ........           _BLF     tcp_seg_copy,??tcp_seg_copy??rA
   \   00000A6C   740084E5           STR      R0,[R4, #+116]
   \   00000A70   620000EA           B        ??tcp_receive_45
   1375                  } else {
   1376                    /* If the queue is not empty, we walk through the queue and
   1377                       try to find a place where the sequence number of the
   1378                       incoming segment is between the sequence numbers of the
   1379                       previous and the next segment on the ->ooseq queue. That is
   1380                       the place where we put the incoming segment. If needed, we
   1381                       trim the second edges of the previous and the incoming
   1382                       segment so that it will fit into the sequence.
   1383          
   1384                       If the incoming segment has the same sequence number as a
   1385                       segment on the ->ooseq queue, we discard the segment that
   1386                       contains less data. */
   1387          
   1388                    prev = NULL;
   \                     ??tcp_receive_44:
   \   00000A74   00A0A0E3           MOV      R10,#+0
   1389                    for(next = pcb->ooseq; next != NULL; next = next->next) {
   \   00000A78   020000EA           B        ??tcp_receive_46
   1390                      if (seqno == next->tcphdr->seqno) {
   1391                        /* The sequence number of the incoming segment is the
   1392                           same as the sequence number of the segment on
   1393                           ->ooseq. We check the lengths to see which one to
   1394                           discard. */
   1395                        if (inseg.len > next->len) {
   1396                          /* The incoming segment is larger than the old
   1397                             segment. We replace some segments with the new
   1398                             one. */
   1399                          cseg = tcp_seg_copy(&inseg);
   1400                          if (cseg != NULL) {
   1401                            if (prev != NULL) {
   1402                              prev->next = cseg;
   1403                            } else {
   1404                              pcb->ooseq = cseg;
   1405                            }
   1406                            tcp_oos_insert_segment(cseg, next);
   1407                          }
   1408                          break;
   1409                        } else {
   1410                          /* Either the lenghts are the same or the incoming
   1411                             segment was smaller than the old one; in either
   1412                             case, we ditch the incoming segment. */
   1413                          break;
   1414                        }
   1415                      } else {
   1416                        if (prev == NULL) {
   1417                          if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
   1418                            /* The sequence number of the incoming segment is lower
   1419                               than the sequence number of the first segment on the
   1420                               queue. We put the incoming segment first on the
   1421                               queue. */
   1422                            cseg = tcp_seg_copy(&inseg);
   1423                            if (cseg != NULL) {
   1424                              pcb->ooseq = cseg;
   1425                              tcp_oos_insert_segment(cseg, next);
   1426                            }
   1427                            break;
   1428                          }
   1429                        } else {
   1430                          /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
   1431                            TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
   1432                          if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
   1433                            /* The sequence number of the incoming segment is in
   1434                               between the sequence numbers of the previous and
   1435                               the next segment on ->ooseq. We trim trim the previous
   1436                               segment, delete next segments that included in received segment
   1437                               and trim received, if needed. */
   1438                            cseg = tcp_seg_copy(&inseg);
   1439                            if (cseg != NULL) {
   1440                              if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
   1441                                /* We need to trim the prev segment. */
   1442                                prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
   1443                                pbuf_realloc(prev->p, prev->len);
   1444                              }
   1445                              prev->next = cseg;
   1446                              tcp_oos_insert_segment(cseg, next);
   1447                            }
   1448                            break;
   1449                          }
   1450                        }
   1451                        /* If the "next" segment is the last segment on the
   1452                           ooseq queue, we add the incoming segment to the end
   1453                           of the list. */
   1454                        if (next->next == NULL &&
   1455                            TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
   1456                          if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
   1457                            /* segment "next" already contains all data */
   1458                            break;
   1459                          }
   1460                          next->next = tcp_seg_copy(&inseg);
   1461                          if (next->next != NULL) {
   1462                            if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
   1463                              /* We need to trim the last segment. */
   1464                              next->len = (u16_t)(seqno - next->tcphdr->seqno);
   1465                              pbuf_realloc(next->p, next->len);
   1466                            }
   1467                            /* check if the remote side overruns our receive window */
   1468                            if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
   1469                              LWIP_DEBUGF(TCP_INPUT_DEBUG,
   1470                                          ("tcp_receive: other end overran receive window"
   1471                                           "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
   1472                                           seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
   1473                              if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
   1474                                /* Must remove the FIN from the header as we're trimming
   1475                                 * that byte of sequence-space from the packet */
   1476                                TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
   1477                              }
   1478                              /* Adjust length of segment to fit in the window. */
   1479                              next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
   1480                              pbuf_realloc(next->next->p, next->next->len);
   1481                              tcplen = TCP_TCPLEN(next->next);
   1482                              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
   1483                                          (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
   1484                            }
   1485                          }
   1486                          break;
   1487                        }
   1488                      }
   1489                      prev = next;
   \                     ??tcp_receive_47:
   \   00000A7C   09A0A0E1           MOV      R10,R9
   \   00000A80   0290B0E1           MOVS     R9,R2
   \   00000A84   5D00000A           BEQ      ??tcp_receive_45
   \                     ??tcp_receive_46:
   \   00000A88   0C0099E5           LDR      R0,[R9, #+12]
   \   00000A8C   0720D0E5           LDRB     R2,[R0, #+7]
   \   00000A90   0630D0E5           LDRB     R3,[R0, #+6]
   \   00000A94   181097E5           LDR      R1,[R7, #+24]
   \   00000A98   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000A9C   0530D0E5           LDRB     R3,[R0, #+5]
   \   00000AA0   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000AA4   0430D0E5           LDRB     R3,[R0, #+4]
   \   00000AA8   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000AAC   020051E1           CMP      R1,R2
   \   00000AB0   0C00001A           BNE      ??tcp_receive_48
   \   00000AB4   B800D9E1           LDRH     R0,[R9, #+8]
   \   00000AB8   B810D7E1           LDRH     R1,[R7, #+8]
   \   00000ABC   010050E1           CMP      R0,R1
   \   00000AC0   4E00002A           BCS      ??tcp_receive_45
   \   00000AC4   0700A0E1           MOV      R0,R7
   \   00000AC8   ........           _BLF     tcp_seg_copy,??tcp_seg_copy??rA
   \   00000ACC   0050B0E1           MOVS     R5,R0
   \   00000AD0   4A00000A           BEQ      ??tcp_receive_45
   \   00000AD4   00005AE3           CMP      R10,#+0
   \   00000AD8   00508A15           STRNE    R5,[R10, #+0]
   \   00000ADC   74508405           STREQ    R5,[R4, #+116]
   \                     ??tcp_receive_49:
   \   00000AE0   0910A0E1           MOV      R1,R9
   \   00000AE4   440000EA           B        ??tcp_receive_50
   \                     ??tcp_receive_48:
   \   00000AE8   00005AE3           CMP      R10,#+0
   \   00000AEC   0E00001A           BNE      ??tcp_receive_51
   \   00000AF0   0720D0E5           LDRB     R2,[R0, #+7]
   \   00000AF4   0630D0E5           LDRB     R3,[R0, #+6]
   \   00000AF8   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000AFC   0530D0E5           LDRB     R3,[R0, #+5]
   \   00000B00   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000B04   0430D0E5           LDRB     R3,[R0, #+4]
   \   00000B08   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000B0C   022051E0           SUBS     R2,R1,R2
   \   00000B10   3C00005A           BPL      ??tcp_receive_52
   \   00000B14   0700A0E1           MOV      R0,R7
   \   00000B18   ........           _BLF     tcp_seg_copy,??tcp_seg_copy??rA
   \   00000B1C   0050B0E1           MOVS     R5,R0
   \   00000B20   3600000A           BEQ      ??tcp_receive_45
   \   00000B24   745084E5           STR      R5,[R4, #+116]
   \   00000B28   ECFFFFEA           B        ??tcp_receive_49
   \                     ??tcp_receive_51:
   \   00000B2C   0C209AE5           LDR      R2,[R10, #+12]
   \   00000B30   0730D2E5           LDRB     R3,[R2, #+7]
   \   00000B34   0650D2E5           LDRB     R5,[R2, #+6]
   \   00000B38   033485E1           ORR      R3,R5,R3, LSL #+8
   \   00000B3C   0550D2E5           LDRB     R5,[R2, #+5]
   \   00000B40   0420D2E5           LDRB     R2,[R2, #+4]
   \   00000B44   033485E1           ORR      R3,R5,R3, LSL #+8
   \   00000B48   032482E1           ORR      R2,R2,R3, LSL #+8
   \   00000B4C   022041E0           SUB      R2,R1,R2
   \   00000B50   012052E2           SUBS     R2,R2,#+1
   \   00000B54   2B00004A           BMI      ??tcp_receive_52
   \   00000B58   0720D0E5           LDRB     R2,[R0, #+7]
   \   00000B5C   0630D0E5           LDRB     R3,[R0, #+6]
   \   00000B60   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000B64   0530D0E5           LDRB     R3,[R0, #+5]
   \   00000B68   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000B6C   0430D0E5           LDRB     R3,[R0, #+4]
   \   00000B70   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000B74   022041E0           SUB      R2,R1,R2
   \   00000B78   012082E2           ADD      R2,R2,#+1
   \   00000B7C   010052E3           CMP      R2,#+1
   \   00000B80   200000AA           BGE      ??tcp_receive_52
   \   00000B84   0700A0E1           MOV      R0,R7
   \   00000B88   ........           _BLF     tcp_seg_copy,??tcp_seg_copy??rA
   \   00000B8C   0050B0E1           MOVS     R5,R0
   \   00000B90   1A00000A           BEQ      ??tcp_receive_45
   \   00000B94   0C109AE5           LDR      R1,[R10, #+12]
   \   00000B98   0720D1E5           LDRB     R2,[R1, #+7]
   \   00000B9C   0630D1E5           LDRB     R3,[R1, #+6]
   \   00000BA0   180097E5           LDR      R0,[R7, #+24]
   \   00000BA4   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000BA8   0530D1E5           LDRB     R3,[R1, #+5]
   \   00000BAC   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000BB0   0430D1E5           LDRB     R3,[R1, #+4]
   \   00000BB4   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000BB8   B830DAE1           LDRH     R3,[R10, #+8]
   \   00000BBC   022083E0           ADD      R2,R3,R2
   \   00000BC0   002042E0           SUB      R2,R2,R0
   \   00000BC4   010052E3           CMP      R2,#+1
   \   00000BC8   080000BA           BLT      ??tcp_receive_53
   \   00000BCC   0520D1E5           LDRB     R2,[R1, #+5]
   \   00000BD0   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000BD4   021481E1           ORR      R1,R1,R2, LSL #+8
   \   00000BD8   011040E0           SUB      R1,R0,R1
   \   00000BDC   B810CAE1           STRH     R1,[R10, #+8]
   \   00000BE0   04009AE5           LDR      R0,[R10, #+4]
   \   00000BE4   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000BE8   2118A0E1           MOV      R1,R1, LSR #+16
   \   00000BEC   ........           _BLF     pbuf_realloc,??pbuf_realloc??rA
   \                     ??tcp_receive_53:
   \   00000BF0   00508AE5           STR      R5,[R10, #+0]
   \   00000BF4   0910A0E1           MOV      R1,R9
   \   00000BF8   0500A0E1           MOV      R0,R5
   \                     ??tcp_receive_50:
   \   00000BFC   ........           BL       tcp_oos_insert_segment
   \                     ??tcp_receive_45:
   \   00000C00   F04FBDE8           POP      {R4-R11,LR}
   \   00000C04   1EFF2FE1           BX       LR
   \                     ??tcp_receive_52:
   \   00000C08   002099E5           LDR      R2,[R9, #+0]
   \   00000C0C   000052E3           CMP      R2,#+0
   \   00000C10   99FFFF1A           BNE      ??tcp_receive_47
   \   00000C14   0730D0E5           LDRB     R3,[R0, #+7]
   \   00000C18   0650D0E5           LDRB     R5,[R0, #+6]
   \   00000C1C   033485E1           ORR      R3,R5,R3, LSL #+8
   \   00000C20   0550D0E5           LDRB     R5,[R0, #+5]
   \   00000C24   0400D0E5           LDRB     R0,[R0, #+4]
   \   00000C28   033485E1           ORR      R3,R5,R3, LSL #+8
   \   00000C2C   030480E1           ORR      R0,R0,R3, LSL #+8
   \   00000C30   000041E0           SUB      R0,R1,R0
   \   00000C34   010050E3           CMP      R0,#+1
   \   00000C38   8FFFFFBA           BLT      ??tcp_receive_47
   \   00000C3C   0C0099E5           LDR      R0,[R9, #+12]
   \   00000C40   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000C44   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000C48   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000C4C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000C50   010010E3           TST      R0,#0x1
   \   00000C54   E9FFFF1A           BNE      ??tcp_receive_45
   \   00000C58   0700A0E1           MOV      R0,R7
   \   00000C5C   ........           _BLF     tcp_seg_copy,??tcp_seg_copy??rA
   \   00000C60   000089E5           STR      R0,[R9, #+0]
   \   00000C64   000050E3           CMP      R0,#+0
   \   00000C68   E4FFFF0A           BEQ      ??tcp_receive_45
   \   00000C6C   0C1099E5           LDR      R1,[R9, #+12]
   \   00000C70   0720D1E5           LDRB     R2,[R1, #+7]
   \   00000C74   0630D1E5           LDRB     R3,[R1, #+6]
   \   00000C78   180097E5           LDR      R0,[R7, #+24]
   \   00000C7C   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000C80   0530D1E5           LDRB     R3,[R1, #+5]
   \   00000C84   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000C88   0430D1E5           LDRB     R3,[R1, #+4]
   \   00000C8C   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000C90   B830D9E1           LDRH     R3,[R9, #+8]
   \   00000C94   022083E0           ADD      R2,R3,R2
   \   00000C98   002042E0           SUB      R2,R2,R0
   \   00000C9C   010052E3           CMP      R2,#+1
   \   00000CA0   080000BA           BLT      ??tcp_receive_54
   \   00000CA4   0520D1E5           LDRB     R2,[R1, #+5]
   \   00000CA8   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000CAC   021481E1           ORR      R1,R1,R2, LSL #+8
   \   00000CB0   011040E0           SUB      R1,R0,R1
   \   00000CB4   B810C9E1           STRH     R1,[R9, #+8]
   \   00000CB8   040099E5           LDR      R0,[R9, #+4]
   \   00000CBC   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000CC0   2118A0E1           MOV      R1,R1, LSR #+16
   \   00000CC4   ........           _BLF     pbuf_realloc,??pbuf_realloc??rA
   \                     ??tcp_receive_54:
   \   00000CC8   BC12D4E1           LDRH     R1,[R4, #+44]
   \   00000CCC   280094E5           LDR      R0,[R4, #+40]
   \   00000CD0   182097E5           LDR      R2,[R7, #+24]
   \   00000CD4   000081E0           ADD      R0,R1,R0
   \   00000CD8   B011D7E1           LDRH     R1,[R7, #+16]
   \   00000CDC   011082E0           ADD      R1,R2,R1
   \   00000CE0   010050E1           CMP      R0,R1
   \   00000CE4   C5FFFF2A           BCS      ??tcp_receive_45
   \   00000CE8   000099E5           LDR      R0,[R9, #+0]
   \   00000CEC   0C1090E5           LDR      R1,[R0, #+12]
   \   00000CF0   0C0090E5           LDR      R0,[R0, #+12]
   \   00000CF4   0D10D1E5           LDRB     R1,[R1, #+13]
   \   00000CF8   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000CFC   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000D00   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000D04   010010E3           TST      R0,#0x1
   \   00000D08   1600000A           BEQ      ??tcp_receive_55
   \   00000D0C   000099E5           LDR      R0,[R9, #+0]
   \   00000D10   0C1090E5           LDR      R1,[R0, #+12]
   \   00000D14   0C0090E5           LDR      R0,[R0, #+12]
   \   00000D18   0D10D1E5           LDRB     R1,[R1, #+13]
   \   00000D1C   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000D20   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000D24   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000D28   3E0000E2           AND      R0,R0,#0x3E
   \   00000D2C   ........           _BLF     lwip_htons,??lwip_htons??rA
   \   00000D30   001099E5           LDR      R1,[R9, #+0]
   \   00000D34   0C2091E5           LDR      R2,[R1, #+12]
   \   00000D38   0C3091E5           LDR      R3,[R1, #+12]
   \   00000D3C   0D20D2E5           LDRB     R2,[R2, #+13]
   \   00000D40   0C30D3E5           LDRB     R3,[R3, #+12]
   \   00000D44   0C1091E5           LDR      R1,[R1, #+12]
   \   00000D48   022483E1           ORR      R2,R3,R2, LSL #+8
   \   00000D4C   02200BE0           AND      R2,R11,R2
   \   00000D50   020080E1           ORR      R0,R0,R2
   \   00000D54   0C00C1E5           STRB     R0,[R1, #+12]
   \   00000D58   001099E5           LDR      R1,[R9, #+0]
   \   00000D5C   2004A0E1           LSR      R0,R0,#+8
   \   00000D60   0C1091E5           LDR      R1,[R1, #+12]
   \   00000D64   0D00C1E5           STRB     R0,[R1, #+13]
   \                     ??tcp_receive_55:
   \   00000D68   BC22D4E1           LDRH     R2,[R4, #+44]
   \   00000D6C   281094E5           LDR      R1,[R4, #+40]
   \   00000D70   000099E5           LDR      R0,[R9, #+0]
   \   00000D74   011082E0           ADD      R1,R2,R1
   \   00000D78   182097E5           LDR      R2,[R7, #+24]
   \   00000D7C   021041E0           SUB      R1,R1,R2
   \   00000D80   B810C0E1           STRH     R1,[R0, #+8]
   \   00000D84   B810D0E1           LDRH     R1,[R0, #+8]
   \   00000D88   040090E5           LDR      R0,[R0, #+4]
   \   00000D8C   ........           _BLF     pbuf_realloc,??pbuf_realloc??rA
   \   00000D90   000099E5           LDR      R0,[R9, #+0]
   \   00000D94   0C1090E5           LDR      R1,[R0, #+12]
   \   00000D98   0C0090E5           LDR      R0,[R0, #+12]
   \   00000D9C   0D10D1E5           LDRB     R1,[R1, #+13]
   \   00000DA0   0C00D0E5           LDRB     R0,[R0, #+12]
   \   00000DA4   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000DA8   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000DAC   030010E3           TST      R0,#0x3
   \   00000DB0   000099E5           LDR      R0,[R9, #+0]
   \   00000DB4   0060A003           MOVEQ    R6,#+0
   \   00000DB8   B800D0E1           LDRH     R0,[R0, #+8]
   \   00000DBC   000086E0           ADD      R0,R6,R0
   \   00000DC0   B001C7E1           STRH     R0,[R7, #+16]
   \   00000DC4   8DFFFFEA           B        ??tcp_receive_45
   1490                    }
   1491                  }
   1492          #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
   1493                  /* Check that the data on ooseq doesn't exceed one of the limits
   1494                     and throw away everything above that limit. */
   1495                  ooseq_blen = 0;
   1496                  ooseq_qlen = 0;
   1497                  prev = NULL;
   1498                  for(next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
   1499                    struct pbuf *p = next->p;
   1500                    ooseq_blen += p->tot_len;
   1501                    ooseq_qlen += pbuf_clen(p);
   1502                    if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
   1503                        (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
   1504                       /* too much ooseq data, dump this and everything after it */
   1505                       tcp_segs_free(next);
   1506                       if (prev == NULL) {
   1507                         /* first ooseq segment is too much, dump the whole queue */
   1508                         pcb->ooseq = NULL;
   1509                       } else {
   1510                         /* just dump 'next' and everything after it */
   1511                         prev->next = NULL;
   1512                       }
   1513                       break;
   1514                    }
   1515                  }
   1516          #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
   1517          #endif /* TCP_QUEUE_OOSEQ */
   1518                }
   1519              } else {
   1520                /* The incoming segment is not withing the window. */
   1521                tcp_send_empty_ack(pcb);
   \                     ??tcp_receive_25:
   \   00000DC8   0400A0E1           MOV      R0,R4
   \   00000DCC   ........           _BLF     tcp_send_empty_ack,??tcp_send_empty_ack??rA
   \   00000DD0   8AFFFFEA           B        ??tcp_receive_45
   1522              }
   1523            } else {
   1524              /* Segments with length 0 is taken care of here. Segments that
   1525                 fall out of the window are ACKed. */
   1526              /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
   1527                TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
   1528              if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
   \                     ??tcp_receive_20:
   \   00000DD4   000051E3           CMP      R1,#+0
   \   00000DD8   0400004A           BMI      ??tcp_receive_43
   \   00000DDC   BC22D4E1           LDRH     R2,[R4, #+44]
   \   00000DE0   021041E0           SUB      R1,R1,R2
   \   00000DE4   011081E2           ADD      R1,R1,#+1
   \   00000DE8   010051E3           CMP      R1,#+1
   \   00000DEC   83FFFFBA           BLT      ??tcp_receive_45
   1529                tcp_ack_now(pcb);
   \                     ??tcp_receive_43:
   \   00000DF0   1E00C4E5           STRB     R0,[R4, #+30]
   1530              }
   1531            }
   1532          }
   \                     ??tcp_receive_56:
   \   00000DF4   81FFFFEA           B        ??tcp_receive_45
   1533          
   1534          /**
   1535           * Parses the options contained in the incoming segment.
   1536           *
   1537           * Called from tcp_listen_input() and tcp_process().
   1538           * Currently, only the MSS option is supported!
   1539           *
   1540           * @param pcb the tcp_pcb for which a segment arrived
   1541           */

   \                                 In segment CODE, align 4, keep-with-next
   1542          static void
   1543          tcp_parseopt(struct tcp_pcb *pcb)
   1544          {
   \                     tcp_parseopt:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   1545            u16_t c, max_c;
   1546            u16_t mss;
   1547            u8_t *opts, opt;
   1548          #if LWIP_TCP_TIMESTAMPS
   1549            u32_t tsval;
   1550          #endif
   1551          
   1552            opts = (u8_t *)tcphdr + TCP_HLEN;
   \   00000004   ........           LDR      R6,??DataTable28  ;; inseg
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   140096E5           LDR      R0,[R6, #+20]
   \   00000010   145080E2           ADD      R5,R0,#+20
   1553          
   1554            /* Parse the TCP MSS option, if present. */
   1555            if(TCPH_HDRLEN(tcphdr) > 0x5) {
   \   00000014   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000018   0C00D0E5           LDRB     R0,[R0, #+12]
   \   0000001C   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000020   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000024   2006A0E1           LSR      R0,R0,#+12
   \   00000028   060050E3           CMP      R0,#+6
   \   0000002C   2F00003A           BCC      ??tcp_parseopt_0
   1556              max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
   \   00000030   140096E5           LDR      R0,[R6, #+20]
   \   00000034   0D10D0E5           LDRB     R1,[R0, #+13]
   \   00000038   0C00D0E5           LDRB     R0,[R0, #+12]
   \   0000003C   010480E1           ORR      R0,R0,R1, LSL #+8
   \   00000040   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   00000044   FB10A0E3           MOV      R1,#+251
   \   00000048   FF1C81E3           ORR      R1,R1,#0xFF00
   \   0000004C   200681E0           ADD      R0,R1,R0, LSR #+12
   \   00000050   0009A0E1           LSL      R0,R0,#+18
   \   00000054   2008A0E1           LSR      R0,R0,#+16
   1557              for (c = 0; c < max_c; ) {
   \   00000058   0010A0E3           MOV      R1,#+0
   \   0000005C   020000EA           B        ??tcp_parseopt_1
   1558                opt = opts[c];
   1559                switch (opt) {
   1560                case 0x00:
   1561                  /* End of options. */
   1562                  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
   1563                  return;
   1564                case 0x01:
   1565                  /* NOP option. */
   1566                  ++c;
   \                     ??tcp_parseopt_2:
   \   00000060   011081E2           ADD      R1,R1,#+1
   \                     ??tcp_parseopt_3:
   \   00000064   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000068   2118A0E1           MOV      R1,R1, LSR #+16
   \                     ??tcp_parseopt_1:
   \   0000006C   000051E1           CMP      R1,R0
   \   00000070   1E00002A           BCS      ??tcp_parseopt_0
   \   00000074   053081E0           ADD      R3,R1,R5
   \   00000078   0060D3E5           LDRB     R6,[R3, #+0]
   \   0000007C   000056E3           CMP      R6,#+0
   \   00000080   1A00000A           BEQ      ??tcp_parseopt_0
   \   00000084   016056E2           SUBS     R6,R6,#+1
   \   00000088   F4FFFF0A           BEQ      ??tcp_parseopt_2
   \   0000008C   016056E2           SUBS     R6,R6,#+1
   \   00000090   1200001A           BNE      ??tcp_parseopt_4
   1567                  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
   1568                  break;
   1569                case 0x02:
   1570                  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
   1571                  if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
   \   00000094   0160D3E5           LDRB     R6,[R3, #+1]
   \   00000098   040056E3           CMP      R6,#+4
   \   0000009C   1300001A           BNE      ??tcp_parseopt_0
   \   000000A0   042081E2           ADD      R2,R1,#+4
   \   000000A4   020050E1           CMP      R0,R2
   \   000000A8   100000BA           BLT      ??tcp_parseopt_0
   1572                    /* Bad length */
   1573                    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
   1574                    return;
   1575                  }
   1576                  /* An MSS option with the right option length. */
   1577                  mss = (opts[c + 2] << 8) | opts[c + 3];
   \   000000AC   0220D3E5           LDRB     R2,[R3, #+2]
   \   000000B0   0330D3E5           LDRB     R3,[R3, #+3]
   1578                  /* Limit the mss to the configured TCP_MSS and prevent division by zero */
   1579                  pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
   \   000000B4   1960A0E3           MOV      R6,#+25
   \   000000B8   806F86E3           ORR      R6,R6,#0x200
   \   000000BC   022483E1           ORR      R2,R3,R2, LSL #+8
   \   000000C0   060052E1           CMP      R2,R6
   \   000000C4   0100002A           BCS      ??tcp_parseopt_5
   \   000000C8   0230B0E1           MOVS     R3,R2
   \   000000CC   0000001A           BNE      ??tcp_parseopt_6
   \                     ??tcp_parseopt_5:
   \   000000D0   862FA0E3           MOV      R2,#+536
   \                     ??tcp_parseopt_6:
   \   000000D4   B623C4E1           STRH     R2,[R4, #+54]
   1580                  /* Advance to next option */
   1581                  c += 0x04;
   \   000000D8   041081E2           ADD      R1,R1,#+4
   \   000000DC   E0FFFFEA           B        ??tcp_parseopt_3
   1582                  break;
   1583          #if LWIP_TCP_TIMESTAMPS
   1584                case 0x08:
   1585                  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
   1586                  if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
   1587                    /* Bad length */
   1588                    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
   1589                    return;
   1590                  }
   1591                  /* TCP timestamp option with valid length */
   1592                  tsval = (opts[c+2]) | (opts[c+3] << 8) |
   1593                    (opts[c+4] << 16) | (opts[c+5] << 24);
   1594                  if (flags & TCP_SYN) {
   1595                    pcb->ts_recent = ntohl(tsval);
   1596                    pcb->flags |= TF_TIMESTAMP;
   1597                  } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
   1598                    pcb->ts_recent = ntohl(tsval);
   1599                  }
   1600                  /* Advance to next option */
   1601                  c += 0x0A;
   1602                  break;
   1603          #endif
   1604                default:
   1605                  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
   1606                  if (opts[c + 1] == 0) {
   \                     ??tcp_parseopt_4:
   \   000000E0   0120D3E5           LDRB     R2,[R3, #+1]
   \   000000E4   000052E3           CMP      R2,#+0
   1607                    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
   1608                    /* If the length field is zero, the options are malformed
   1609                       and we don't process them further. */
   1610                    return;
   1611                  }
   1612                  /* All other options have a length field, so that we easily
   1613                     can skip past them. */
   1614                  c += opts[c + 1];
   \   000000E8   01108210           ADDNE    R1,R2,R1
   \   000000EC   DCFFFF1A           BNE      ??tcp_parseopt_3
   \                     ??tcp_parseopt_0:
   \   000000F0   7040BDE8           POP      {R4-R6,LR}
   \   000000F4   1EFF2FE1           BX       LR               ;; return
   1615                }
   1616              }
   1617            }
   1618          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     inseg

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     lwip_stats

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   ........           DC32     inseg

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   ........           DC32     current_iphdr_dest

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   ........           DC32     current_iphdr_src

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   ........           DC32     tcp_active_pcbs

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     tcp_ticks

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     tcp_active_pcbs_changed

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   ........           DC32     tcp_tw_pcbs

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   ........           DC32     inseg

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   ........           DC32     tcp_ticks

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   ........           DC32     inseg
   1619          
   1620          #endif /* LWIP_TCP */
   1621          

   Maximum stack usage in bytes:

     Function               CSTACK
     --------               ------
     tcp_input                 52
     tcp_listen_input          32
     tcp_oos_insert_segment    12
     tcp_parseopt              16
     tcp_process               44
     tcp_receive               36


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     inseg                    42
     tcp_input              1728
     tcp_listen_input        432
     tcp_process            1468
     tcp_oos_insert_segment  296
     tcp_receive            3576
     tcp_parseopt            248
     ??DataTable1              4
     ??DataTable16             4
     ??DataTable19             4
     ??DataTable20             4
     ??DataTable21             4
     ??DataTable22             4
     ??DataTable23             4
     ??DataTable24             4
     ??DataTable25             4
     ??DataTable26             4
     ??DataTable27             4
     ??DataTable28             4
      Others                 408

 
 8 192 bytes in segment CODE
    42 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 7 796 bytes of CODE memory (+ 408 bytes shared)
    42 bytes of DATA memory

Errors: none
Warnings: none
