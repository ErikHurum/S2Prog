##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  14:41:49 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\api\netbuf.c            #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\api\netbuf.c --fpu      #
#                       None -D OS_LIBMODE_SP -D CPU_S3C2410 -D              #
#                       OS_RAMVECT=0 -D OS_UART=-1 -D S2TXU -D USE_LZO=1 -D  #
#                       __ARM_LIBRARY__ -D WATCHDOG=1 -D NETWORK=1 -lCN      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\netbuf.lst                  #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\netbuf.r79                   #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\api\netbuf.c
      1          /**
      2           * @file
      3           * Network buffer management
      4           *
      5           */
      6           
      7          /*
      8           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
      9           * All rights reserved. 
     10           * 
     11           * Redistribution and use in source and binary forms, with or without modification, 
     12           * are permitted provided that the following conditions are met:
     13           *
     14           * 1. Redistributions of source code must retain the above copyright notice,
     15           *    this list of conditions and the following disclaimer.
     16           * 2. Redistributions in binary form must reproduce the above copyright notice,
     17           *    this list of conditions and the following disclaimer in the documentation
     18           *    and/or other materials provided with the distribution.
     19           * 3. The name of the author may not be used to endorse or promote products
     20           *    derived from this software without specific prior written permission. 
     21           *
     22           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
     23           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
     24           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
     25           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
     26           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
     27           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
     28           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
     29           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
     30           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
     31           * OF SUCH DAMAGE.
     32           *
     33           * This file is part of the lwIP TCP/IP stack.
     34           * 
     35           * Author: Adam Dunkels <adam@sics.se>
     36           *
     37           */
     38          
     39          #include "lwip/opt.h"
     40          
     41          #if LWIP_NETCONN /* don't build if not configured for use in lwipopts.h */
     42          
     43          #include "lwip/netbuf.h"
     44          #include "lwip/memp.h"
     45          
     46          #include <string.h>
     47          
     48          /**
     49           * Create (allocate) and initialize a new netbuf.
     50           * The netbuf doesn't yet contain a packet buffer!
     51           *
     52           * @return a pointer to a new netbuf
     53           *         NULL on lack of memory
     54           */

   \                                 In segment CODE, align 4, keep-with-next
     55          struct
     56          netbuf *netbuf_new(void)
     57          {
   \                     netbuf_new:
   \   00000000   00402DE9           PUSH     {LR}
     58            struct netbuf *buf;
     59          
     60            buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
   \   00000004   0700A0E3           MOV      R0,#+7
   \   00000008   ........           _BLF     memp_malloc,??memp_malloc??rA
     61            if (buf != NULL) {
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0400000A           BEQ      ??netbuf_new_0
     62              buf->p = NULL;
   \   00000014   0010A0E3           MOV      R1,#+0
   \   00000018   001080E5           STR      R1,[R0, #+0]
     63              buf->ptr = NULL;
   \   0000001C   041080E5           STR      R1,[R0, #+4]
     64              ip_addr_set_any(&buf->addr);
   \   00000020   081080E5           STR      R1,[R0, #+8]
     65              buf->port = 0;
   \   00000024   BC10C0E1           STRH     R1,[R0, #+12]
     66          #if LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY
     67          #if LWIP_CHECKSUM_ON_COPY
     68              buf->flags = 0;
     69          #endif /* LWIP_CHECKSUM_ON_COPY */
     70              buf->toport_chksum = 0;
     71          #if LWIP_NETBUF_RECVINFO
     72              ip_addr_set_any(&buf->toaddr);
     73          #endif /* LWIP_NETBUF_RECVINFO */
     74          #endif /* LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY */
     75              return buf;
     76            } else {
     77              return NULL;
   \                     ??netbuf_new_0:
   \   00000028   0040BDE8           POP      {LR}
   \   0000002C   1EFF2FE1           BX       LR               ;; return
     78            }
     79          }
     80          
     81          /**
     82           * Deallocate a netbuf allocated by netbuf_new().
     83           *
     84           * @param buf pointer to a netbuf allocated by netbuf_new()
     85           */

   \                                 In segment CODE, align 4, keep-with-next
     86          void
     87          netbuf_delete(struct netbuf *buf)
     88          {
   \                     netbuf_delete:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
     89            if (buf != NULL) {
   \   00000008   0900000A           BEQ      ??netbuf_delete_0
     90              if (buf->p != NULL) {
   \   0000000C   000094E5           LDR      R0,[R4, #+0]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0300000A           BEQ      ??netbuf_delete_1
     91                pbuf_free(buf->p);
   \   00000018   ........           _BLF     pbuf_free,??pbuf_free??rA
     92                buf->p = buf->ptr = NULL;
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   040084E5           STR      R0,[R4, #+4]
   \   00000024   000084E5           STR      R0,[R4, #+0]
     93              }
     94              memp_free(MEMP_NETBUF, buf);
   \                     ??netbuf_delete_1:
   \   00000028   0410A0E1           MOV      R1,R4
   \   0000002C   0700A0E3           MOV      R0,#+7
   \   00000030   ........           _BLF     memp_free,??memp_free??rA
     95            }
     96          }
   \                     ??netbuf_delete_0:
   \   00000034   1040BDE8           POP      {R4,LR}
   \   00000038   1EFF2FE1           BX       LR               ;; return
     97          
     98          /**
     99           * Allocate memory for a packet buffer for a given netbuf.
    100           *
    101           * @param buf the netbuf for which to allocate a packet buffer
    102           * @param size the size of the packet buffer to allocate
    103           * @return pointer to the allocated memory
    104           *         NULL if no memory could be allocated
    105           */

   \                                 In segment CODE, align 4, keep-with-next
    106          void *
    107          netbuf_alloc(struct netbuf *buf, u16_t size)
    108          {
   \                     netbuf_alloc:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    109            //LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
    110          
    111            /* Deallocate any previously allocated memory. */
    112            if (buf->p != NULL) {
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0000000A           BEQ      ??netbuf_alloc_0
    113              pbuf_free(buf->p);
   \   00000018   ........           _BLF     pbuf_free,??pbuf_free??rA
    114            }
    115            buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
   \                     ??netbuf_alloc_0:
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   ........           _BLF     pbuf_alloc,??pbuf_alloc??rA
   \   0000002C   000084E5           STR      R0,[R4, #+0]
    116            if (buf->p == NULL) {
   \   00000030   000050E3           CMP      R0,#+0
    117               return NULL;
    118            }
    119            LWIP_ASSERT("check that first pbuf can hold size",
    120                       (buf->p->len >= size));
    121            buf->ptr = buf->p;
   \   00000034   04008415           STRNE    R0,[R4, #+4]
    122            return buf->p->payload;
   \   00000038   04009015           LDRNE    R0,[R0, #+4]
   \   0000003C   3040BDE8           POP      {R4,R5,LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return
    123          }
    124          
    125          /**
    126           * Free the packet buffer included in a netbuf
    127           *
    128           * @param buf pointer to the netbuf which contains the packet buffer to free
    129           */

   \                                 In segment CODE, align 4, keep-with-next
    130          void
    131          netbuf_free(struct netbuf *buf)
    132          {
   \                     netbuf_free:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    133            //LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
    134            if (buf->p != NULL) {
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0100000A           BEQ      ??netbuf_free_0
    135              pbuf_free(buf->p);
   \   00000014   ........           _BLF     pbuf_free,??pbuf_free??rA
    136            }
    137            buf->p = buf->ptr = NULL;
   \   00000018   0000A0E3           MOV      R0,#+0
   \                     ??netbuf_free_0:
   \   0000001C   040084E5           STR      R0,[R4, #+4]
   \   00000020   000084E5           STR      R0,[R4, #+0]
    138          }
   \   00000024   1040BDE8           POP      {R4,LR}
   \   00000028   1EFF2FE1           BX       LR               ;; return
    139          
    140          /**
    141           * Let a netbuf reference existing (non-volatile) data.
    142           *
    143           * @param buf netbuf which should reference the data
    144           * @param dataptr pointer to the data to reference
    145           * @param size size of the data
    146           * @return ERR_OK if data is referenced
    147           *         ERR_MEM if data couldn't be referenced due to lack of memory
    148           */

   \                                 In segment CODE, align 4, keep-with-next
    149          err_t
    150          netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
    151          {
   \                     netbuf_ref:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    152            //LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
    153            if (buf->p != NULL) {
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0000000A           BEQ      ??netbuf_ref_0
    154              pbuf_free(buf->p);
   \   0000001C   ........           _BLF     pbuf_free,??pbuf_free??rA
    155            }
    156            buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
   \                     ??netbuf_ref_0:
   \   00000020   0220A0E3           MOV      R2,#+2
   \   00000024   0010A0E3           MOV      R1,#+0
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   ........           _BLF     pbuf_alloc,??pbuf_alloc??rA
   \   00000030   000084E5           STR      R0,[R4, #+0]
    157            if (buf->p == NULL) {
   \   00000034   000050E3           CMP      R0,#+0
    158              buf->ptr = NULL;
   \   00000038   04008405           STREQ    R0,[R4, #+4]
    159              return ERR_MEM;
   \   0000003C   0000E003           MVNEQ    R0,#+0
   \   00000040   0500000A           BEQ      ??netbuf_ref_1
    160            }
    161            buf->p->payload = (void*)dataptr;
   \   00000044   045080E5           STR      R5,[R0, #+4]
    162            buf->p->len = buf->p->tot_len = size;
   \   00000048   B860C0E1           STRH     R6,[R0, #+8]
   \   0000004C   0610A0E1           MOV      R1,R6
   \   00000050   BA10C0E1           STRH     R1,[R0, #+10]
    163            buf->ptr = buf->p;
   \   00000054   040084E5           STR      R0,[R4, #+4]
    164            return ERR_OK;
   \   00000058   0000A0E3           MOV      R0,#+0
   \                     ??netbuf_ref_1:
   \   0000005C   7040BDE8           POP      {R4-R6,LR}
   \   00000060   1EFF2FE1           BX       LR               ;; return
    165          }
    166          
    167          /**
    168           * Chain one netbuf to another (@see pbuf_chain)
    169           *
    170           * @param head the first netbuf
    171           * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
    172           */

   \                                 In segment CODE, align 4, keep-with-next
    173          void
    174          netbuf_chain(struct netbuf *head, struct netbuf *tail)
    175          {
   \                     netbuf_chain:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    176            //LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
    177            //LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
    178            pbuf_cat(head->p, tail->p);
   \   00000008   000094E5           LDR      R0,[R4, #+0]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   001095E5           LDR      R1,[R5, #+0]
   \   00000014   ........           _BLF     pbuf_cat,??pbuf_cat??rA
    179            head->ptr = head->p;
   \   00000018   000094E5           LDR      R0,[R4, #+0]
    180            memp_free(MEMP_NETBUF, tail);
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   040084E5           STR      R0,[R4, #+4]
   \   00000024   0700A0E3           MOV      R0,#+7
   \   00000028   ........           _BLF     memp_free,??memp_free??rA
    181          }
   \   0000002C   3040BDE8           POP      {R4,R5,LR}
   \   00000030   1EFF2FE1           BX       LR               ;; return
    182          
    183          /**
    184           * Get the data pointer and length of the data inside a netbuf.
    185           *
    186           * @param buf netbuf to get the data from
    187           * @param dataptr pointer to a void pointer where to store the data pointer
    188           * @param len pointer to an u16_t where the length of the data is stored
    189           * @return ERR_OK if the information was retreived,
    190           *         ERR_BUF on error.
    191           */

   \                                 In segment CODE, align 4, keep-with-next
    192          err_t
    193          netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
    194          {
    195            //LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
    196            //LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
    197            //LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
    198          
    199            if (buf->ptr == NULL) {
   \                     netbuf_data:
   \   00000000   040090E5           LDR      R0,[R0, #+4]
   \   00000004   000050E3           CMP      R0,#+0
    200              return ERR_BUF;
   \   00000008   0100E003           MVNEQ    R0,#+1
   \   0000000C   1EFF2F01           BXEQ     LR
    201            }
    202            *dataptr = buf->ptr->payload;
   \   00000010   043090E5           LDR      R3,[R0, #+4]
   \   00000014   003081E5           STR      R3,[R1, #+0]
    203            *len = buf->ptr->len;
   \   00000018   BA00D0E1           LDRH     R0,[R0, #+10]
   \   0000001C   B000C2E1           STRH     R0,[R2, #+0]
    204            return ERR_OK;
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   1EFF2FE1           BX       LR               ;; return
    205          }
    206          
    207          /**
    208           * Move the current data pointer of a packet buffer contained in a netbuf
    209           * to the next part.
    210           * The packet buffer itself is not modified.
    211           *
    212           * @param buf the netbuf to modify
    213           * @return -1 if there is no next part
    214           *         1  if moved to the next part but now there is no next part
    215           *         0  if moved to the next part and there are still more parts
    216           */

   \                                 In segment CODE, align 4, keep-with-next
    217          s8_t
    218          netbuf_next(struct netbuf *buf)
    219          {
    220            //LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
    221            if (buf->ptr->next == NULL) {
   \                     netbuf_next:
   \   00000000   041090E5           LDR      R1,[R0, #+4]
   \   00000004   002091E5           LDR      R2,[R1, #+0]
   \   00000008   000052E3           CMP      R2,#+0
    222              return -1;
   \   0000000C   0000E003           MVNEQ    R0,#+0
   \   00000010   1EFF2F01           BXEQ     LR
    223            }
    224            buf->ptr = buf->ptr->next;
   \   00000014   0210A0E1           MOV      R1,R2
   \   00000018   041080E5           STR      R1,[R0, #+4]
    225            if (buf->ptr->next == NULL) {
   \   0000001C   000091E5           LDR      R0,[R1, #+0]
   \   00000020   000050E3           CMP      R0,#+0
    226              return 1;
   \   00000024   0100A003           MOVEQ    R0,#+1
   \   00000028   1EFF2F01           BXEQ     LR
    227            }
    228            return 0;
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   1EFF2FE1           BX       LR               ;; return
    229          }
    230          
    231          /**
    232           * Move the current data pointer of a packet buffer contained in a netbuf
    233           * to the beginning of the packet.
    234           * The packet buffer itself is not modified.
    235           *
    236           * @param buf the netbuf to modify
    237           */

   \                                 In segment CODE, align 4, keep-with-next
    238          void
    239          netbuf_first(struct netbuf *buf)
    240          {
    241            //LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
    242            buf->ptr = buf->p;
   \                     netbuf_first:
   \   00000000   001090E5           LDR      R1,[R0, #+0]
   \   00000004   041080E5           STR      R1,[R0, #+4]
    243          }
   \   00000008   1EFF2FE1           BX       LR               ;; return
    244          
    245          #endif /* LWIP_NETCONN */
    246          

   Maximum stack usage in bytes:

     Function      CSTACK
     --------      ------
     netbuf_alloc     12
     netbuf_chain     12
     netbuf_data       0
     netbuf_delete     8
     netbuf_first      0
     netbuf_free       8
     netbuf_new        4
     netbuf_next       0
     netbuf_ref       16


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     netbuf_new       48
     netbuf_delete    60
     netbuf_alloc     68
     netbuf_free      44
     netbuf_ref      100
     netbuf_chain     52
     netbuf_data      40
     netbuf_next      52
     netbuf_first     12
      Others          96

 
 572 bytes in segment CODE
 
 476 bytes of CODE memory (+ 96 bytes shared)

Errors: none
Warnings: none
