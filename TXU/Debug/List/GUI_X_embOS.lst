##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:13:44 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\Config\GUI_X_embOS.c                   #
#    Command line    =  D:\S2Prog\TXU\Config\GUI_X_embOS.c --fpu None -D     #
#                       OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D      #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\GUI_X_embOS.lst             #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\GUI_X_embOS.r79              #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\Config\GUI_X_embOS.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER SYSTEME GmbH                 *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2007  SEGGER Microcontroller Systeme GmbH        *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V4.14 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUI_X.c
     19          Purpose     : Config / System dependent externals for GUI
     20          ---------------------------END-OF-HEADER------------------------------
     21          */
     22          
     23          #include <stdio.h>
     24          #include "RTOS.h"               /* embOS include */
     25          #include "GUI.h"
     26          #include "GUI_X.h"
     27          
     28          
     29          
     30          /*********************************************************************
     31          *
     32          *      Timing:
     33          *                 GUI_GetTime()
     34          *                 GUI_Delay(int)
     35          
     36            Some timing dependent routines require a GetTime
     37            and delay funtion. Default time unit (tick), normally is
     38            1 ms.
     39          */
     40          

   \                                 In segment CODE, align 4, keep-with-next
     41          int GUI_X_GetTime(void) {
     42            return OS_GetTime();
   \                     GUI_X_GetTime:
   \   00000000   04009FE5           LDR      R0,??GUI_X_GetTime_0  ;; OS_Time
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
   \                     ??GUI_X_GetTime_0:
   \   0000000C   ........           DC32     OS_Time
     43          }
     44          

   \                                 In segment CODE, align 4, keep-with-next
     45          void GUI_X_Delay(int Period) {
   \                     GUI_X_Delay:
   \   00000000   00402DE9           PUSH     {LR}
     46            OS_Delay(Period);
   \   00000004   ........           _BLF     OS_Delay,??OS_Delay??rA
     47          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return
     48          
     49          /*********************************************************************
     50          *
     51          *       GUI_X_ExecIdle()
     52          *
     53          */

   \                                 In segment CODE, align 4, keep-with-next
     54          void GUI_X_ExecIdle(void) {
   \                     GUI_X_ExecIdle:
   \   00000000   00402DE9           PUSH     {LR}
     55            OS_Delay(1);
   \   00000004   0100A0E3           MOV      R0,#+1
   \   00000008   ........           _BLF     OS_Delay,??OS_Delay??rA
     56          }
   \   0000000C   0040BDE8           POP      {LR}
   \   00000010   1EFF2FE1           BX       LR               ;; return
     57          
     58          /*********************************************************************
     59          *
     60          *      Multitasking:
     61          *
     62          *                 GUI_X_InitOS()
     63          *                 GUI_X_GetTaskId()
     64          *                 GUI_X_Lock()
     65          *                 GUI_X_Unlock()
     66          *
     67          * Note:
     68          *   The following routines are required only if emWin is used in a
     69          *   true multi task environment, which means you have more than one
     70          *   thread using the emWin API.
     71          *   In this case the
     72          *                       #define GUI_OS 1
     73          *  needs to be in GUIConf.h
     74          */
     75          
     76          

   \                                 In segment DATA_Z, align 4, align-sorted
     77          static OS_RSEMA RSema;
   \                     RSema:
   \   00000000                      DS8 16
     78          

   \                                 In segment CODE, align 4, keep-with-next
     79          void GUI_X_InitOS(void)    { OS_CreateRSema(&RSema);    }
   \                     GUI_X_InitOS:
   \   00000000   ........           LDR      R0,??DataTable2  ;; RSema
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
   \   0000000C   0040BDE8           POP      {LR}
   \   00000010   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     80          void GUI_X_Unlock(void)    { OS_Unuse(&RSema); }
   \                     GUI_X_Unlock:
   \   00000000   ........           LDR      R0,??DataTable2  ;; RSema
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           _BLF     OS_Unuse,??OS_Unuse??rA
   \   0000000C   0040BDE8           POP      {LR}
   \   00000010   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     81          void GUI_X_Lock(void)      { OS_Use(&RSema);  }
   \                     GUI_X_Lock:
   \   00000000   ........           LDR      R0,??DataTable2  ;; RSema
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           _BLF     OS_Use,??OS_Use??rA
   \   0000000C   0040BDE8           POP      {LR}
   \   00000010   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
     82          U32  GUI_X_GetTaskId(void) { return (U32)OS_GetTaskID(); }
   \                     GUI_X_GetTaskId:
   \   00000000   ........           LDR      R0,??DataTable4  ;; OS_pCurrentTask
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
     83          
     84          
     85          /*********************************************************************
     86          *
     87          *      Event driving (optional with multitasking)
     88          *
     89          *                 GUI_X_WaitEvent()
     90          *                 GUI_X_SignalEvent()
     91          */
     92          
     93          

   \                                 In segment DATA_Z, align 4, align-sorted
     94          static OS_TASK* _pGUITask;
   \                     _pGUITask:
   \   00000000                      DS8 4
     95          

   \                                 In segment CODE, align 4, keep-with-next
     96          void GUI_X_WaitEvent(void)    {
     97            _pGUITask = OS_GetpCurrentTask();
   \                     GUI_X_WaitEvent:
   \   00000000   ........           LDR      R1,??DataTable4  ;; OS_pCurrentTask
   \   00000004   ........           LDR      R0,??DataTable6  ;; _pGUITask
   \   00000008   00402DE9           PUSH     {LR}
   \   0000000C   001091E5           LDR      R1,[R1, #+0]
   \   00000010   001080E5           STR      R1,[R0, #+0]
     98            OS_WaitEvent(1);
   \   00000014   0100A0E3           MOV      R0,#+1
   \   00000018   ........           _BLF     OS_WaitEvent,??OS_WaitEvent??rA
     99          }
   \   0000001C   0040BDE8           POP      {LR}
   \   00000020   1EFF2FE1           BX       LR               ;; return
    100          

   \                                 In segment CODE, align 4, keep-with-next
    101          void GUI_X_SignalEvent(void)    {
    102            if (_pGUITask) {
   \                     GUI_X_SignalEvent:
   \   00000000   ........           LDR      R0,??DataTable6  ;; _pGUITask
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   001090E5           LDR      R1,[R0, #+0]
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0100000A           BEQ      ??GUI_X_SignalEvent_0
    103              OS_SignalEvent(1, _pGUITask);
   \   00000014   0100A0E3           MOV      R0,#+1
   \   00000018   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
    104            }
    105          }
   \                     ??GUI_X_SignalEvent_0:
   \   0000001C   0040BDE8           POP      {LR}
   \   00000020   1EFF2FE1           BX       LR               ;; return
    106          
    107          /*********************************************************************
    108          *
    109          *      Keyboard input from serial input
    110          *
    111          * Note:
    112          *   If embOS is used, characters typed into the log window will be placed
    113          *   in the keyboard buffer. This is a neat feature which allows you to
    114          *   operate your target system without having to use or even to have
    115          *   a keyboard connected to it. (nice for demos !)
    116          */
    117          

   \                                 In segment CODE, align 4, keep-with-next
    118          static void _OnRx(OS_U8 Data) {
   \                     _OnRx:
   \   00000000   00402DE9           PUSH     {LR}
    119            #if 0
    120              int Key;
    121              switch (Data) {
    122              case 'y':
    123                Key = GUI_KEY_LEFT;
    124                break;
    125              case 'x':
    126                Key = GUI_KEY_RIGHT;
    127                break;
    128              case 'q':
    129                Key = GUI_KEY_UP;
    130                break;
    131              case 'a':
    132                Key = GUI_KEY_DOWN;
    133                break;
    134              case 'w':
    135                Key = GUI_KEY_BACKSPACE;
    136                break;
    137              default:
    138                Key = Data;
    139              }
    140              GUI_StoreKeyMsg(Key, 1);
    141            #else
    142              GUI_StoreKeyMsg(Data, 1);
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   ........           _BLF     GUI_StoreKeyMsg,??GUI_StoreKeyMsg??rA
    143            #endif
    144          }
   \   0000000C   0040BDE8           POP      {LR}
   \   00000010   1EFF2FE1           BX       LR               ;; return
    145          

   \                                 In segment CODE, align 4, keep-with-next
    146          void GUI_X_Init(void) {
    147            OS_SetRxCallback(_OnRx);
   \                     GUI_X_Init:
   \   00000000   0C009FE5           LDR      R0,??GUI_X_Init_0  ;; _OnRx
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   ........           _BLF     OS_SetRxCallback,??OS_SetRxCallback??rA
    148          }
   \   0000000C   0040BDE8           POP      {LR}
   \   00000010   1EFF2FE1           BX       LR               ;; return
   \                     ??GUI_X_Init_0:
   \   00000014   ........           DC32     _OnRx
    149          
    150          /*********************************************************************
    151          *
    152          *      Logging: OS dependent
    153          
    154          Note:
    155            Logging is used in higher debug levels only. The typical target
    156            build does not use logging and does therefor not require any of
    157            the logging routines below. For a release build without logging
    158            the routines below may be eliminated to save some space.
    159            (If the linker is not function aware and eliminates unreferenced
    160            functions automatically)
    161          
    162          */
    163          

   \                                 In segment CODE, align 4, keep-with-next
    164          void GUI_X_Log     (const char *s) { OS_SendString(s); }
   \                     GUI_X_Log:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   ........           _BLF     OS_SendString,??OS_SendString??rA
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
    165          void GUI_X_Warn    (const char *s) { OS_SendString(s); }
   \                     GUI_X_Warn:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   ........           _BLF     OS_SendString,??OS_SendString??rA
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
    166          void GUI_X_ErrorOut(const char *s) { OS_SendString(s); }
   \                     GUI_X_ErrorOut:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   ........           _BLF     OS_SendString,??OS_SendString??rA
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     RSema

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     OS_pCurrentTask

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     _pGUITask
    167          
    168          
    169          
    170          
    171          
    172          
    173          

   Maximum stack usage in bytes:

     Function          CSTACK
     --------          ------
     GUI_X_Delay           4
     GUI_X_ErrorOut        4
     GUI_X_ExecIdle        4
     GUI_X_GetTaskId       0
     GUI_X_GetTime         0
     GUI_X_Init            4
     GUI_X_InitOS          4
     GUI_X_Lock            4
     GUI_X_Log             4
     GUI_X_SignalEvent     4
     GUI_X_Unlock          4
     GUI_X_WaitEvent       4
     GUI_X_Warn            4
     _OnRx                 4


   Segment part sizes:

     Function/Label    Bytes
     --------------    -----
     GUI_X_GetTime       16
     GUI_X_Delay         16
     GUI_X_ExecIdle      20
     RSema               16
     GUI_X_InitOS        20
     GUI_X_Unlock        20
     GUI_X_Lock          20
     GUI_X_GetTaskId     12
     _pGUITask            4
     GUI_X_WaitEvent     36
     GUI_X_SignalEvent   36
     _OnRx               20
     GUI_X_Init          24
     GUI_X_Log           16
     GUI_X_Warn          16
     GUI_X_ErrorOut      16
     ??DataTable2         4
     ??DataTable4         4
     ??DataTable6         4
      Others            176

 
 464 bytes in segment CODE
  20 bytes in segment DATA_Z
  12 bytes in segment INITTAB
 
 300 bytes of CODE memory (+ 176 bytes shared)
  20 bytes of DATA memory

Errors: none
Warnings: none
