##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:20:17 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\app\sg_timer.c          #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\app\sg_timer.c --fpu    #
#                       None -D OS_LIBMODE_SP -D CPU_S3C2410 -D              #
#                       OS_RAMVECT=0 -D OS_UART=-1 -D S2TXU -D USE_LZO=1 -D  #
#                       __ARM_LIBRARY__ -D WATCHDOG=1 -D NETWORK=1 -lCN      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\sg_timer.lst                #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\sg_timer.r79                 #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\app\sg_timer.c
      1          ////////////////////////////////////////////////////////////////////////////////
      2          //
      3          // an old invention of hkim and open nature of the internet
      4          //
      5          ////////////////////////////////////////////////////////////////////////////////
      6          #include <stdlib.h>
      7          #include <stdio.h>
      8          #include "sg_timer.h"
      9          
     10          /**
     11           * initialize a timer manager
     12           *
     13           * @param timer timer manager context block
     14           * @param tick_rate desired tick rate
     15           * @param n_buckets number of buckets desired
     16           * @return 0 on success, -1 on failure
     17           */

   \                                 In segment CODE, align 4, keep-with-next
     18          int
     19          init_timer(SGTimer* timer, int tick_rate, int n_buckets)
     20          {  
   \                     init_timer:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     21             int i;
     22          
     23             timer->num_buckets         = n_buckets;
   \   00000008   002084E5           STR      R2,[R4, #+0]
     24             timer->tick_rate           = tick_rate;
   \   0000000C   041084E5           STR      R1,[R4, #+4]
     25             timer->tick                = 0;
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   080084E5           STR      R0,[R4, #+8]
     26          
     27             timer->buckets = (struct list_head*)malloc(sizeof(struct list_head) * timer->num_buckets);
   \   00000018   0200A0E1           MOV      R0,R2
   \   0000001C   8001A0E1           LSL      R0,R0,#+3
   \   00000020   ........           _BLF     __data_malloc,??__data_malloc??rA
   \   00000024   0C0084E5           STR      R0,[R4, #+12]
     28             if(timer->buckets == NULL)
   \   00000028   000050E3           CMP      R0,#+0
     29             {
     30                return -1;
   \   0000002C   0000E003           MVNEQ    R0,#+0
   \   00000030   0C00000A           BEQ      ??init_timer_0
     31             }
     32          
     33             for(i = 0; i < timer->num_buckets; i++)
   \   00000034   001094E5           LDR      R1,[R4, #+0]
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   010051E3           CMP      R1,#+1
   \   00000040   050000AA           BGE      ??init_timer_1
   \   00000044   060000EA           B        ??init_timer_2
     34             {
     35                INIT_LIST_HEAD(&timer->buckets[i]);
   \                     ??init_timer_3:
   \   00000048   0C2094E5           LDR      R2,[R4, #+12]
   \   0000004C   802182E0           ADD      R2,R2,R0, LSL #+3
   \   00000050   002082E5           STR      R2,[R2, #+0]
   \   00000054   042082E5           STR      R2,[R2, #+4]
     36             }
   \   00000058   010080E2           ADD      R0,R0,#+1
   \                     ??init_timer_1:
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   F8FFFFBA           BLT      ??init_timer_3
     37          
     38             return 0; 
   \                     ??init_timer_2:
   \   00000064   0000A0E3           MOV      R0,#+0
   \                     ??init_timer_0:
   \   00000068   1040BDE8           POP      {R4,LR}
   \   0000006C   1EFF2FE1           BX       LR               ;; return
     39          }  
     40          
     41          /**
     42           * deinitialize a timer manager
     43           *
     44           * @param timer timer context block
     45           */

   \                                 In segment CODE, align 4, keep-with-next
     46          void
     47          deinit_timer(SGTimer* timer)
     48          {
   \                     deinit_timer:
   \   00000000   00402DE9           PUSH     {LR}
     49             free(timer->buckets);
   \   00000004   0C0090E5           LDR      R0,[R0, #+12]
   \   00000008   ........           _BLF     __data_free,??__data_free??rA
     50          }
   \   0000000C   0040BDE8           POP      {LR}
   \   00000010   1EFF2FE1           BX       LR               ;; return
     51          
     52          /**
     53           * initialize a timer element before using it
     54           *
     55           * @param elem timer element to initialize
     56           */

   \                                 In segment CODE, align 4, keep-with-next
     57          void
     58          init_timer_elem(SGTimerElem* elem)
     59          {
     60             INIT_LIST_HEAD(&elem->next);
   \                     init_timer_elem:
   \   00000000   000080E5           STR      R0,[R0, #+0]
   \   00000004   040080E5           STR      R0,[R0, #+4]
     61          }
   \   00000008   1EFF2FE1           BX       LR               ;; return
     62          
     63          /**
     64           * start a stopped timer element by adding it to timer manager
     65           *
     66           * @param timer timer manager context block
     67           * @param elem new timer element to add to timer manager
     68           * @param expires desired timeout value in milliseconds
     69           */

   \                                 In segment CODE, align 4, keep-with-next
     70          void
     71          add_timer(SGTimer* timer, SGTimerElem* elem, int expires)
     72          {
   \                     add_timer:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0130A0E1           MOV      R3,R1
     73             int target;
     74          
     75             if(is_timer_running(elem))
   \   0000000C   000093E5           LDR      R0,[R3, #+0]
   \   00000010   030050E1           CMP      R0,R3
   \   00000014   04009305           LDREQ    R0,[R3, #+4]
   \   00000018   03005001           CMPEQ    R0,R3
     76             {
     77                char* crash = NULL;
     78                *crash = 0;
   \   0000001C   0000A013           MOVNE    R0,#+0
   \   00000020   0000C015           STRBNE   R0,[R0, #+0]
     79             }
     80          
     81             INIT_LIST_HEAD(&elem->next);
   \   00000024   003083E5           STR      R3,[R3, #+0]
   \   00000028   043083E5           STR      R3,[R3, #+4]
     82          
     83             elem->tick     = timer->tick + get_tick_from_milsec(timer, expires);
   \   0000002C   045094E5           LDR      R5,[R4, #+4]
   \   00000030   0200A0E1           MOV      R0,R2
   \   00000034   0510A0E1           MOV      R1,R5
   \   00000038   ........           _BLF     ??div32_a,??rA??div32_a
   \   0000003C   0160A0E1           MOV      R6,R1
   \   00000040   0200A0E1           MOV      R0,R2
   \   00000044   0510A0E1           MOV      R1,R5
   \   00000048   ........           _BLF     ??div32_a,??rA??div32_a
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   080094E5           LDR      R0,[R4, #+8]
   \   00000054   01608612           ADDNE    R6,R6,#+1
   \   00000058   000086E0           ADD      R0,R6,R0
   \   0000005C   0C0083E5           STR      R0,[R3, #+12]
     84             target         = elem->tick % timer->num_buckets;
     85          
     86             list_add_tail(&elem->next, &timer->buckets[target]);
   \   00000060   001094E5           LDR      R1,[R4, #+0]
   \   00000064   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000068   0C1094E5           LDR      R1,[R4, #+12]
   \   0000006C   800181E0           ADD      R0,R1,R0, LSL #+3
   \   00000070   041090E5           LDR      R1,[R0, #+4]
   \   00000074   043080E5           STR      R3,[R0, #+4]
   \   00000078   000083E5           STR      R0,[R3, #+0]
   \   0000007C   041083E5           STR      R1,[R3, #+4]
   \   00000080   003081E5           STR      R3,[R1, #+0]
     87          }
   \   00000084   7040BDE8           POP      {R4-R6,LR}
   \   00000088   1EFF2FE1           BX       LR               ;; return
     88          
     89          /**
     90           * stop a running timer element by deleting it from timer manager
     91           *
     92           * @param timer tmier manager context block
     93           * @param elem timer elemen to delete
     94           */

   \                                 In segment CODE, align 4, keep-with-next
     95          void
     96          del_timer(SGTimer* timer, SGTimerElem* elem)
     97          {
     98             if(!is_timer_running(elem))
   \                     del_timer:
   \   00000000   040091E5           LDR      R0,[R1, #+4]
   \   00000004   002091E5           LDR      R2,[R1, #+0]
   \   00000008   010052E1           CMP      R2,R1
   \   0000000C   01005001           CMPEQ    R0,R1
   \   00000010   1EFF2F01           BXEQ     LR
     99             {
    100                return;
    101             }
    102             list_del_init(&elem->next);
   \   00000014   040082E5           STR      R0,[R2, #+4]
   \   00000018   002080E5           STR      R2,[R0, #+0]
   \   0000001C   001081E5           STR      R1,[R1, #+0]
   \   00000020   041081E5           STR      R1,[R1, #+4]
    103          }
   \   00000024   1EFF2FE1           BX       LR               ;; return
    104          

   \                                 In segment CODE, align 4, keep-with-next
    105          static void
    106          timer_tick(SGTimer* timer)
    107          {
   \                     timer_tick:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0020A0E1           MOV      R2,R0
    108             int               current;
    109             SGTimerElem       *p, *n;
    110             struct list_head  timeout_list = LIST_HEAD_INIT(timeout_list);
   \   0000000C   0D10A0E1           MOV      R1,SP
   \   00000010   00108DE5           STR      R1,[SP, #+0]
   \   00000014   04108DE5           STR      R1,[SP, #+4]
    111          
    112             timer->tick++;
   \   00000018   080092E5           LDR      R0,[R2, #+8]
   \   0000001C   010080E2           ADD      R0,R0,#+1
   \   00000020   080082E5           STR      R0,[R2, #+8]
    113          
    114             current = timer->tick % timer->num_buckets;
   \   00000024   001092E5           LDR      R1,[R2, #+0]
   \   00000028   ........           _BLF     ??divu32_a,??rA??divu32_a
    115          
    116             //
    117             // be careful with this code..
    118             // Here is the logic behind this
    119             // 1. once timer expires, it should be able to re-add the same timer again
    120             // 2. when a timer expires, it should be able to remove
    121             //    other timers including ones timed out inside the timeout handler
    122             //
    123             list_for_each_entry_safe(p, n, &timer->buckets[current], next, SGTimerElem)
   \   0000002C   0C1092E5           LDR      R1,[R2, #+12]
   \   00000030   80C181E0           ADD      R12,R1,R0, LSL #+3
   \   00000034   00109CE5           LDR      R1,[R12, #+0]
   \   00000038   003091E5           LDR      R3,[R1, #+0]
   \   0000003C   0C0051E1           CMP      R1,R12
   \   00000040   1600000A           BEQ      ??timer_tick_0
    124             {
    125                if(p->tick == timer->tick)
   \                     ??timer_tick_1:
   \   00000044   0CC091E5           LDR      R12,[R1, #+12]
   \   00000048   08E092E5           LDR      LR,[R2, #+8]
   \   0000004C   0E005CE1           CMP      R12,LR
   \   00000050   0C00001A           BNE      ??timer_tick_2
    126                {
    127                   list_del(&p->next);
   \   00000054   00C091E5           LDR      R12,[R1, #+0]
   \   00000058   04E091E5           LDR      LR,[R1, #+4]
   \   0000005C   04E08CE5           STR      LR,[R12, #+4]
   \   00000060   00C08EE5           STR      R12,[LR, #+0]
   \   00000064   00C0A0E3           MOV      R12,#+0
   \   00000068   00C081E5           STR      R12,[R1, #+0]
   \   0000006C   04C081E5           STR      R12,[R1, #+4]
    128                   list_add_tail(&p->next, &timeout_list);
   \   00000070   04C09DE5           LDR      R12,[SP, #+4]
   \   00000074   04108DE5           STR      R1,[SP, #+4]
   \   00000078   0DE0A0E1           MOV      LR,SP
   \   0000007C   00E081E5           STR      LR,[R1, #+0]
   \   00000080   04C081E5           STR      R12,[R1, #+4]
   \   00000084   00108CE5           STR      R1,[R12, #+0]
    129                }
    130             }
   \                     ??timer_tick_2:
   \   00000088   0CC092E5           LDR      R12,[R2, #+12]
   \   0000008C   0310A0E1           MOV      R1,R3
   \   00000090   003093E5           LDR      R3,[R3, #+0]
   \   00000094   80C18CE0           ADD      R12,R12,R0, LSL #+3
   \   00000098   0C0051E1           CMP      R1,R12
   \   0000009C   E8FFFF1A           BNE      ??timer_tick_1
    131          
    132             while(!list_empty(&timeout_list))
   \                     ??timer_tick_0:
   \   000000A0   00009DE5           LDR      R0,[SP, #+0]
   \   000000A4   0D10A0E1           MOV      R1,SP
   \   000000A8   010050E1           CMP      R0,R1
   \   000000AC   0100001A           BNE      ??timer_tick_3
    133             {
    134                p = list_first_entry(&timeout_list, SGTimerElem, next);
    135                list_del_init(&p->next);
    136                p->cb(p);
    137             }
    138          }
   \   000000B0   0340BDE8           POP      {R0,R1,LR}
   \   000000B4   1EFF2FE1           BX       LR               ;; return
   \                     ??timer_tick_3:
   \   000000B8   0010A0E1           MOV      R1,R0
   \   000000BC   000091E5           LDR      R0,[R1, #+0]
   \   000000C0   042091E5           LDR      R2,[R1, #+4]
   \   000000C4   042080E5           STR      R2,[R0, #+4]
   \   000000C8   000082E5           STR      R0,[R2, #+0]
   \   000000CC   001081E5           STR      R1,[R1, #+0]
   \   000000D0   041081E5           STR      R1,[R1, #+4]
   \   000000D4   0100A0E1           MOV      R0,R1
   \   000000D8   081091E5           LDR      R1,[R1, #+8]
   \   000000DC   0FE0A0E1           MOV      LR,PC
   \   000000E0   11FF2FE1           BX       R1
   \   000000E4   EDFFFFEA           B        ??timer_tick_0
    139          
    140          /**
    141           * drive a given timer manager
    142           * this routine should be called every tick rate as close as possible
    143           * On non-realtime systems,  some late timeout is just inevitable
    144           *
    145           * @param timer timer manager context block
    146           */

   \                                 In segment CODE, align 4, keep-with-next
    147          void
    148          drive_timer(SGTimer* timer)
    149          {
   \                     drive_timer:
   \   00000000   00402DE9           PUSH     {LR}
    150             timer_tick(timer);
   \   00000004   ........           BL       timer_tick
    151          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return

   Maximum stack usage in bytes:

     Function        CSTACK
     --------        ------
     add_timer          16
     deinit_timer        4
     del_timer           0
     drive_timer         4
     init_timer          8
     init_timer_elem     0
     timer_tick         12


   Segment part sizes:

     Function/Label  Bytes
     --------------  -----
     init_timer       112
     deinit_timer      20
     init_timer_elem   12
     add_timer        140
     del_timer         40
     timer_tick       232
     drive_timer       16
      Others           76

 
 648 bytes in segment CODE
 
 572 bytes of CODE memory (+ 76 bytes shared)

Errors: none
Warnings: none
