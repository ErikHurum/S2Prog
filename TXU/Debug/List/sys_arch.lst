##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  14:42:35 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\arch\sys_arch.c         #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\arch\sys_arch.c --fpu   #
#                       None -D OS_LIBMODE_SP -D CPU_S3C2410 -D              #
#                       OS_RAMVECT=0 -D OS_UART=-1 -D S2TXU -D USE_LZO=1 -D  #
#                       __ARM_LIBRARY__ -D WATCHDOG=1 -D NETWORK=1 -lCN      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\sys_arch.lst                #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\sys_arch.r79                 #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\arch\sys_arch.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              lwIP TCP/IP Stack
      4          *                                        port for uC/OS-II RTOS on TIC6711 DSK
      5          *
      6          * File : sys_arch.c
      7          * By   : ZengMing @ DEP,Tsinghua University,Beijing,China
      8          * Reference: YangYe's source code for SkyEye project
      9          *********************************************************************************************************
     10          */
     11          
     12          //#include "lwip/debug.h"
     13          #include <stdlib.h>
     14          #include "lwip/debug.h"
     15          #include "lwip/def.h"
     16          #include "lwip/sys.h"
     17          #include "lwip/mem.h"
     18          #include "lwip/stats.h"
     19          
     20          #include "arch/sys_arch.h"
     21          #include "rtos.h"
     22          
     23          #ifdef __cplusplus
     24          extern "C" {
     25          #endif
     26          
     27          /** Create a new mutex
     28           * @param mutex pointer to the mutex to create
     29           * @return a new mutex */

   \                                 In segment CODE, align 4, keep-with-next
     30          err_t
     31          sys_mutex_new(sys_mutex_t *mutex)
     32          {
   \                     sys_mutex_new:
   \   00000000   00402DE9           PUSH     {LR}
     33            OS_CREATERSEMA(mutex);
   \   00000004   ........           _BLF     OS_CreateRSema,??OS_CreateRSema??rA
     34            return ERR_OK;
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   1EFF2FE1           BX       LR               ;; return
     35          }
     36          
     37          /** Lock a mutex
     38           * @param mutex the mutex to lock */

   \                                 In segment CODE, align 4, keep-with-next
     39          void
     40          sys_mutex_lock(sys_mutex_t *mutex)
     41          {
   \                     sys_mutex_lock:
   \   00000000   00402DE9           PUSH     {LR}
     42            OS_Use(mutex);
   \   00000004   ........           _BLF     OS_Use,??OS_Use??rA
     43          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return
     44          
     45          /** Unlock a mutex
     46           * @param mutex the mutex to unlock */

   \                                 In segment CODE, align 4, keep-with-next
     47          void
     48          sys_mutex_unlock(sys_mutex_t *mutex)
     49          {
   \                     sys_mutex_unlock:
   \   00000000   00402DE9           PUSH     {LR}
     50            OS_Unuse(mutex);
   \   00000004   ........           _BLF     OS_Unuse,??OS_Unuse??rA
     51          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return
     52          
     53          /** Delete a semaphore
     54           * @param mutex the mutex to delete */

   \                                 In segment CODE, align 4, keep-with-next
     55          void
     56          sys_mutex_free(sys_mutex_t *mutex)
     57          {
   \                     sys_mutex_free:
   \   00000000   00402DE9           PUSH     {LR}
     58            OS_DeleteRSema(mutex);
   \   00000004   ........           _BLF     OS_DeleteRSema,??OS_DeleteRSema??rA
     59          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return
     60          
     61          
     62          /* Semaphore functions: */
     63          
     64          /** Create a new semaphore
     65           * @param sem pointer to the semaphore to create
     66           * @param count initial count of the semaphore
     67           * @return ERR_OK if successful, another err_t otherwise */

   \                                 In segment CODE, align 4, keep-with-next
     68          err_t
     69          sys_sem_new(sys_sem_t *sem, u8_t count)
     70          {
   \                     sys_sem_new:
   \   00000000   10402DE9           PUSH     {R4,LR}
     71            err_t err_sem = ERR_MEM;
   \   00000004   0040E0E3           MVN      R4,#+0
     72          
     73            /* Sanity check */
     74            if (sem != NULL) {
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   0F00000A           BEQ      ??sys_sem_new_0
     75          
     76              OS_EnterRegion();
   \   00000010   ........           LDR      R2,??DataTable5  ;; OS_Counters
     77              OS_CreateCSema(sem, count);
     78          
     79          #if SYS_STATS
     80              lwip_stats.sys.sem.used++;
     81              if (lwip_stats.sys.sem.used > lwip_stats.sys.sem.max) {
     82                lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
     83              }
     84          
     85          #endif /* SYS_STATS */
     86          
     87          #if 0
     88              if (0 == count) { /* Means we want the sem to be
     89                                   unavailable at init state. */
     90                OS_SignalCSema(sem);
     91          
     92              }
     93          #endif
     94          
     95              err_sem = ERR_OK;
   \   00000014   0040A0E3           MOV      R4,#+0
   \   00000018   0030D2E5           LDRB     R3,[R2, #+0]
   \   0000001C   013083E2           ADD      R3,R3,#+1
   \   00000020   0030C2E5           STRB     R3,[R2, #+0]
   \   00000024   ........           _BLF     OS_CreateCSema,??OS_CreateCSema??rA
   \   00000028   2C009FE5           LDR      R0,??sys_sem_new_1  ;; lwip_stats + 408
   \   0000002C   B010D0E1           LDRH     R1,[R0, #+0]
   \   00000030   B220D0E1           LDRH     R2,[R0, #+2]
   \   00000034   011081E2           ADD      R1,R1,#+1
   \   00000038   B010C0E1           STRH     R1,[R0, #+0]
   \   0000003C   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000040   2118A0E1           MOV      R1,R1, LSR #+16
   \   00000044   010052E1           CMP      R2,R1
   \   00000048   B210C031           STRHCC   R1,[R0, #+2]
     96          
     97              OS_LeaveRegion();
   \   0000004C   ........           _BLF     OS_LeaveRegion,??OS_LeaveRegion??rA
     98            }
     99          
    100            return err_sem;
   \                     ??sys_sem_new_0:
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   1040BDE8           POP      {R4,LR}
   \   00000058   1EFF2FE1           BX       LR               ;; return
   \                     ??sys_sem_new_1:
   \   0000005C   ........           DC32     lwip_stats + 408
    101          }
    102          
    103          /** Signals a semaphore
    104           * @param sem the semaphore to signal */

   \                                 In segment CODE, align 4, keep-with-next
    105          void
    106          sys_sem_signal(sys_sem_t *sem)
    107          {
   \                     sys_sem_signal:
   \   00000000   00402DE9           PUSH     {LR}
    108            OS_SignalCSema(sem);
   \   00000004   ........           _BLF     OS_SignalCSema,??OS_SignalCSema??rA
    109          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    110          
    111          /** Wait for a semaphore for the specified timeout
    112           * @param sem the semaphore to wait for
    113           * @param timeout timeout in milliseconds to wait (0 = wait forever)
    114           * @return time (in milliseconds) waited for the semaphore
    115           *         or SYS_ARCH_TIMEOUT on timeout */

   \                                 In segment CODE, align 4, keep-with-next
    116          u32_t
    117          sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
    118          {
   \                     sys_arch_sem_wait:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    119            if ( timeout )
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   0800000A           BEQ      ??sys_arch_sem_wait_0
    120            {
    121              OS_I32 Wtime = OS_Time;
   \   0000000C   ........           LDR      R4,??DataTable4  ;; OS_Time
   \   00000010   005094E5           LDR      R5,[R4, #+0]
    122              if ( OS_WaitCSemaTimed(sem,timeout) )
   \   00000014   ........           _BLF     OS_WaitCSemaTimed,??OS_WaitCSemaTimed??rA
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0000E003           MVNEQ    R0,#+0
    123              {
    124                return OS_Time - Wtime;
   \   00000020   00009415           LDRNE    R0,[R4, #+0]
   \   00000024   05004010           SUBNE    R0,R0,R5
   \   00000028   3040BDE8           POP      {R4,R5,LR}
   \   0000002C   1EFF2FE1           BX       LR
    125              }
    126              else
    127              {
    128                return SYS_ARCH_TIMEOUT;
    129              }
    130            }
    131            else
    132            {
    133              OS_WaitCSema(sem);
   \                     ??sys_arch_sem_wait_0:
   \   00000030   ........           _BLF     OS_WaitCSema,??OS_WaitCSema??rA
    134              return ERR_OK;
   \   00000034   3040BDE8           POP      {R4,R5,LR}
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   1EFF2FE1           BX       LR               ;; return
    135            }
    136          }
    137          
    138          
    139          /** Delete a semaphore
    140           * @param sem semaphore to delete */

   \                                 In segment CODE, align 4, keep-with-next
    141          void
    142          sys_sem_free(sys_sem_t *sem)
    143          {
   \                     sys_sem_free:
   \   00000000   00402DE9           PUSH     {LR}
    144            /* Sanity check */
    145            if (sem != NULL)
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0000000A           BEQ      ??sys_sem_free_0
    146            {
    147              OS_DeleteCSema(sem);
   \   0000000C   ........           _BLF     OS_DeleteCSema,??OS_DeleteCSema??rA
    148            }
    149          }
   \                     ??sys_sem_free_0:
   \   00000010   0040BDE8           POP      {LR}
   \   00000014   1EFF2FE1           BX       LR               ;; return
    150          
    151          /** Check if a sempahore is valid/allocated: return 1 for valid, 0 for invalid */

   \                                 In segment CODE, align 4, keep-with-next
    152          int
    153          sys_sem_valid(sys_sem_t *sem)
    154          {
    155            int isValid = 0;
   \                     sys_sem_valid:
   \   00000000   0010A0E3           MOV      R1,#+0
    156          
    157            if (sem)
   \   00000004   000050E3           CMP      R0,#+0
    158            {
    159              isValid = 1;
   \   00000008   0110A013           MOVNE    R1,#+1
    160            }
    161            return isValid;
   \   0000000C   0100A0E1           MOV      R0,R1
   \   00000010   1EFF2FE1           BX       LR               ;; return
    162          }
    163          
    164          /** Set a semaphore invalid so that sys_sem_valid returns 0 */

   \                                 In segment CODE, align 4, keep-with-next
    165          void
    166          sys_sem_set_invalid(sys_sem_t *sem)
    167          {
    168            if (sem)
    169            {
    170              //OS_DeleteCSema(sem);
    171              //sem->WaitObj = NULL;
    172            }
    173          }
   \                     sys_sem_set_invalid:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    174          
    175          
    176          /* Time functions. */

   \                                 In segment CODE, align 4, keep-with-next
    177          void
    178          sys_msleep(u32_t ms) /* only has a (close to) 1 jiffy resolution. */
    179          {
   \                     sys_msleep:
   \   00000000   00402DE9           PUSH     {LR}
    180            OS_Delay(ms);
   \   00000004   ........           _BLF     OS_Delay,??OS_Delay??rA
    181          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    182          
    183          
    184          /* Mailbox functions. */
    185          
    186          /** Create a new mbox of specified size
    187           * @param mbox pointer to the mbox to create
    188           * @param size (miminum) number of messages in this mbox
    189           * @return ERR_OK if successful, another err_t otherwise */

   \                                 In segment CODE, align 4, keep-with-next
    190          err_t
    191          sys_mbox_new(sys_mbox_t *mbox, int size)
    192          {
   \                     sys_mbox_new:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    193            unsigned *Ptr = malloc(size*sizeof(void *));
   \   0000000C   0501A0E1           LSL      R0,R5,#+2
   \   00000010   ........           _BLF     __data_malloc,??__data_malloc??rA
    194          
    195            OS_CREATEMB(mbox,sizeof(void *),size,Ptr);
   \   00000014   0030A0E1           MOV      R3,R0
   \   00000018   0520A0E1           MOV      R2,R5
   \   0000001C   0410A0E3           MOV      R1,#+4
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           _BLF     OS_CreateMB,??OS_CreateMB??rA
    196            return ERR_OK;
   \   00000028   3040BDE8           POP      {R4,R5,LR}
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   1EFF2FE1           BX       LR               ;; return
    197          }
    198          
    199          /** Post a message to an mbox - may not fail
    200           * -> blocks if full, only used from tasks not from ISR
    201           * @param mbox mbox to posts the message
    202           * @param msg message to post (ATTENTION: can be NULL) */

   \                                 In segment CODE, align 4, keep-with-next
    203          void
    204          sys_mbox_post(sys_mbox_t *mbox, void *msg)
    205          {
   \                     sys_mbox_post:
   \   00000000   02402DE9           PUSH     {R1,LR}
    206            OS_PutMail(mbox,&msg);
   \   00000004   0D10A0E1           MOV      R1,SP
   \   00000008   ........           _BLF     OS_PutMail,??OS_PutMail??rA
    207          }
   \   0000000C   0140BDE8           POP      {R0,LR}
   \   00000010   1EFF2FE1           BX       LR               ;; return
    208          
    209          /** Try to post a message to an mbox - may fail if full or ISR
    210           * @param mbox mbox to posts the message
    211           * @param msg message to post (ATTENTION: can be NULL) */

   \                                 In segment CODE, align 4, keep-with-next
    212          err_t
    213          sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
    214          {
   \                     sys_mbox_trypost:
   \   00000000   02402DE9           PUSH     {R1,LR}
    215            char HasSendt;
    216          
    217            HasSendt = OS_PutMailCond(mbox,&msg);
   \   00000004   0D10A0E1           MOV      R1,SP
   \   00000008   ........           _BLF     OS_PutMailCond,??OS_PutMailCond??rA
    218          
    219            if (HasSendt == 0)
    220            { 
    221              return ERR_OK;
    222            }
    223            else
    224            {
    225              return ERR_INPROGRESS;
   \   0000000C   0240BDE8           POP      {R1,LR}
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0400E013           MVNNE    R0,#+4
   \   00000018   1EFF2FE1           BX       LR               ;; return
    226            }
    227          }
    228          
    229          /** Wait for a new message to arrive in the mbox
    230           * @param mbox mbox to get a message from
    231           * @param msg pointer where the message is storeuuuud
    232           * @param timeout maximum time (in milliseconds) to wait for a message
    233           * @return time (in milliseconds) waited for a message, may be 0 if not waited
    234                     or SYS_ARCH_TIMEOUT on timeout
    235           *         The returned time has to be accurate to prevent timer jitter! */

   \                                 In segment CODE, align 4, keep-with-next
    236          u32_t
    237          sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
    238          {
   \                     sys_arch_mbox_fetch:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    239            OS_I32 Wtime1 = OS_Time;
   \   00000004   ........           LDR      R6,??DataTable4  ;; OS_Time
   \   00000008   08D04DE2           SUB      SP,SP,#+8
   \   0000000C   004096E5           LDR      R4,[R6, #+0]
   \   00000010   0150B0E1           MOVS     R5,R1
    240            u32_t tmpMsg;
    241            void* dummyptr;
    242          
    243            if(msg == NULL)
    244            {
    245              msg = &dummyptr;
   \   00000014   04508D02           ADDEQ    R5,SP,#+4
    246            }
    247          
    248            if(timeout == 0)
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   0D10A0E1           MOV      R1,SP
   \   00000020   0600001A           BNE      ??sys_arch_mbox_fetch_0
    249            {
    250              // block forever
    251              OS_GetMail(mbox,&tmpMsg);
   \   00000024   ........           _BLF     OS_GetMail,??OS_GetMail??rA
    252              *msg = (void*)tmpMsg;
   \                     ??sys_arch_mbox_fetch_1:
   \   00000028   00009DE5           LDR      R0,[SP, #+0]
   \   0000002C   000085E5           STR      R0,[R5, #+0]
    253              OS_I32 Wtime2 = OS_Time - Wtime1;
   \   00000030   000096E5           LDR      R0,[R6, #+0]
   \   00000034   040040E0           SUB      R0,R0,R4
    254              return Wtime2;
   \   00000038   7640BDE8           POP      {R1,R2,R4-R6,LR}
   \   0000003C   1EFF2FE1           BX       LR
    255            }
    256            else
    257            {
    258              if(!OS_GetMailTimed(mbox,&tmpMsg,timeout))
   \                     ??sys_arch_mbox_fetch_0:
   \   00000040   ........           _BLF     OS_GetMailTimed,??OS_GetMailTimed??rA
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   F6FFFF0A           BEQ      ??sys_arch_mbox_fetch_1
    259              {
    260                *msg = (void*)tmpMsg;
    261                OS_I32 Wtime2 = OS_Time - Wtime1;
    262                return Wtime2;
    263              }
    264              else
    265              {
    266                return SYS_ARCH_TIMEOUT;
   \   0000004C   7640BDE8           POP      {R1,R2,R4-R6,LR}
   \   00000050   0000E0E3           MVN      R0,#+0
   \   00000054   1EFF2FE1           BX       LR               ;; return
    267              }
    268            }
    269          }
    270          
    271          /* Allow port to override with a macro, e.g. special timout for sys_arch_mbox_fetch() */
    272          #ifndef sys_arch_mbox_tryfetch
    273          /** Wait for a new message to arrive in the mbox
    274           * @param mbox mbox to get a message from
    275           * @param msg pointer where the message is stored
    276           * @param timeout maximum time (in milliseconds) to wait for a message
    277           * @return 0 (milliseconds) if a message has been received
    278           *         or SYS_MBOX_EMPTY if the mailbox is empty */

   \                                 In segment CODE, align 4, keep-with-next
    279          u32_t
    280          sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
    281          {
   \                     sys_arch_mbox_tryfetch:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0140B0E1           MOVS     R4,R1
    282            u32_t tmpMsg;
    283            void* dummyptr;
    284          
    285            if(msg == NULL)
    286            {
    287              msg = &dummyptr;
   \   0000000C   04408D02           ADDEQ    R4,SP,#+4
    288            }
    289          
    290            if(OS_GetMailCond(mbox,&tmpMsg) == 0)
   \   00000010   0D10A0E1           MOV      R1,SP
   \   00000014   ........           _BLF     OS_GetMailCond,??OS_GetMailCond??rA
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0400001A           BNE      ??sys_arch_mbox_tryfetch_0
    291            {
    292              *msg = (void*)tmpMsg;
   \   00000020   00009DE5           LDR      R0,[SP, #+0]
   \   00000024   000084E5           STR      R0,[R4, #+0]
    293              return ERR_OK;
   \   00000028   1640BDE8           POP      {R1,R2,R4,LR}
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   1EFF2FE1           BX       LR
    294            }
    295            else
    296            {
    297              return SYS_MBOX_EMPTY;
   \                     ??sys_arch_mbox_tryfetch_0:
   \   00000034   1640BDE8           POP      {R1,R2,R4,LR}
   \   00000038   0000E0E3           MVN      R0,#+0
   \   0000003C   1EFF2FE1           BX       LR               ;; return
    298            }
    299          }
    300          
    301          #endif
    302          
    303          /** For now, we map straight to sys_arch implementation. */
    304          #define sys_mbox_tryfetch(mbox, msg) sys_arch_mbox_tryfetch(mbox, msg)
    305          /** Delete an mbox
    306           * @param mbox mbox to delete */

   \                                 In segment CODE, align 4, keep-with-next
    307          void
    308          sys_mbox_free(sys_mbox_t *mbox)
    309          {
   \                     sys_mbox_free:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    310            char *DataPtr = mbox->pData;
   \   00000008   040094E5           LDR      R0,[R4, #+4]
    311          
    312            if (DataPtr )
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0500000A           BEQ      ??sys_mbox_free_0
    313            {
    314              free(DataPtr);
   \   00000014   ........           _BLF     __data_free,??__data_free??rA
    315              OS_DeleteMB(mbox);
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           _BLF     OS_DeleteMB,??OS_DeleteMB??rA
    316              mbox->sizeofMsg = 0;
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   1400C4E5           STRB     R0,[R4, #+20]
    317              mbox->pData     = NULL;
   \   00000028   040084E5           STR      R0,[R4, #+4]
    318            }
    319          }
   \                     ??sys_mbox_free_0:
   \   0000002C   1040BDE8           POP      {R4,LR}
   \   00000030   1EFF2FE1           BX       LR               ;; return
    320          #define sys_mbox_fetch(mbox, msg) sys_arch_mbox_fetch(mbox, msg, 0)
    321          
    322          /** Check if an mbox is valid/allocated: return 1 for valid, 0 for invalid */

   \                                 In segment CODE, align 4, keep-with-next
    323          int
    324          sys_mbox_valid(sys_mbox_t *mbox)
    325          {
    326            if (mbox->sizeofMsg)
   \                     sys_mbox_valid:
   \   00000000   1400D0E5           LDRB     R0,[R0, #+20]
   \   00000004   000050E3           CMP      R0,#+0
    327            {
    328              return 1;
   \   00000008   0100A013           MOVNE    R0,#+1
    329            }
    330            else
    331            {
    332              return 0;
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    333            }
    334          }
    335          
    336          /** Set an mbox invalid so that sys_mbox_valid returns 0 */

   \                                 In segment CODE, align 4, keep-with-next
    337          void
    338          sys_mbox_set_invalid(sys_mbox_t *mbox)
    339          {
    340            char *DataPtr = mbox->pData;
    341          
    342            if (DataPtr )
    343            {
    344              /* bullshit, -hkim-
    345              free(DataPtr);
    346              OS_DeleteMB(mbox);
    347              mbox->sizeofMsg = 0;
    348              mbox->pData     = NULL;
    349              */
    350            }
    351          }
   \                     sys_mbox_set_invalid:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    352          
    353          /** The only thread function:
    354           * Creates a new thread
    355           * @param name human-readable name for the thread (used for debugging purposes)
    356           * @param thread thread-function
    357           * @param arg parameter passed to 'thread'
    358           * @param stacksize stack size in bytes for the new thread (may be ignored by ports)
    359           * @param prio priority of the new thread (may be ignored by ports) */
    360          static int TaskCnt = 0;
    361          static OS_TASK TaskList[LWIP_TASK_MAX];
    362          static OS_STACKPTR char NetworkStack[LWIP_TASK_MAX][LWIP_STK_SIZE];
    363          

   \                                 In segment CODE, align 4, keep-with-next
    364          sys_thread_t
    365          sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
    366          {
   \                     sys_thread_new:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
    367            OS_TASK *pTask = NULL;
    368            
    369            OS_IncDI();
   \   00000004   BC909FE5           LDR      R9,??sys_thread_new_0  ;; OS_Counters
   \   00000008   24809DE5           LDR      R8,[SP, #+36]
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   0370A0E1           MOV      R7,R3
   \   0000001C   ........           _BLF     OS_DisableInt,??OS_DisableInt??rA
   \   00000020   0100D9E5           LDRB     R0,[R9, #+1]
   \   00000024   010080E2           ADD      R0,R0,#+1
   \   00000028   0100C9E5           STRB     R0,[R9, #+1]
    370            if (TaskCnt >= LWIP_TASK_MAX)
   \   0000002C   98009FE5           LDR      R0,??sys_thread_new_0+0x4  ;; TaskCnt
   \   00000030   001090E5           LDR      R1,[R0, #+0]
   \   00000034   050051E3           CMP      R1,#+5
   \   00000038   030000BA           BLT      ??sys_thread_new_1
    371            {
    372              static OS_TASK DummyTask;
    373              pTask = &DummyTask;
   \   0000003C   4410A0E3           MOV      R1,#+68
   \   00000040   A11C81E3           ORR      R1,R1,#0xA100
   \   00000044   00A081E0           ADD      R10,R1,R0
   \   00000048   110000EA           B        ??sys_thread_new_2
    374            }
    375            else
    376            {
    377              pTask = &TaskList[TaskCnt];
   \                     ??sys_thread_new_1:
   \   0000004C   012380E0           ADD      R2,R0,R1, LSL #+6
   \   00000050   04A082E2           ADD      R10,R2,#+4
    378              OS_STACKPTR char *StackPtr = NetworkStack[TaskCnt++];
   \   00000054   812680E0           ADD      R2,R0,R1, LSL #+13
   \   00000058   512F82E2           ADD      R2,R2,#+324
   \   0000005C   011081E2           ADD      R1,R1,#+1
   \   00000060   001080E5           STR      R1,[R0, #+0]
    379              OS_CreateTaskEx(pTask,(const char*)name,(unsigned char)prio,thread,StackPtr,LWIP_STK_SIZE,2,arg);
   \   00000064   80002DE9           PUSH     {R7}
   \   00000068   0200A0E3           MOV      R0,#+2
   \   0000006C   01002DE9           PUSH     {R0}
   \   00000070   800DA0E3           MOV      R0,#+8192
   \   00000074   01002DE9           PUSH     {R0}
   \   00000078   04002DE9           PUSH     {R2}
   \   0000007C   0630A0E1           MOV      R3,R6
   \   00000080   FF2008E2           AND      R2,R8,#0xFF
   \   00000084   0510A0E1           MOV      R1,R5
   \   00000088   0A00A0E1           MOV      R0,R10
   \   0000008C   ........           _BLF     OS_CreateTaskEx_SP,??OS_CreateTaskEx_SP??rA
   \   00000090   10D08DE2           ADD      SP,SP,#+16
    380            }
    381            OS_DecRI();
   \                     ??sys_thread_new_2:
   \   00000094   0100D9E5           LDRB     R0,[R9, #+1]
   \   00000098   010040E2           SUB      R0,R0,#+1
   \   0000009C   0100C9E5           STRB     R0,[R9, #+1]
   \   000000A0   000CB0E1           LSLS     R0,R0,#+24
   \   000000A4   0000001A           BNE      ??sys_thread_new_3
   \   000000A8   ........           _BLF     OS_EnableInt,??OS_EnableInt??rA
    382            return *pTask;
   \                     ??sys_thread_new_3:
   \   000000AC   EF01BAE8           LDM      R10!,{R0-R3,R5-R8}
   \   000000B0   EF01A4E8           STM      R4!,{R0-R3,R5-R8}
   \   000000B4   EF019AE8           LDM      R10,{R0-R3,R5-R8}
   \   000000B8   EF0184E8           STM      R4,{R0-R3,R5-R8}
   \   000000BC   200044E2           SUB      R0,R4,#+32
   \   000000C0   F047BDE8           POP      {R4-R10,LR}
   \   000000C4   1EFF2FE1           BX       LR               ;; return
   \                     ??sys_thread_new_0:
   \   000000C8   ........           DC32     OS_Counters
   \   000000CC   ........           DC32     TaskCnt
    383          }

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     TaskCnt:
   \   00000000                      DS8 4
   \   00000004                      DS8 320
   \   00000144                      DS8 40960
   \   0000A144                      DS8 64
    384          
    385          /* sys_init() must be called before anthing else. */

   \                                 In segment CODE, align 4, keep-with-next
    386          void
    387          sys_init(void)
    388          {
    389          }
   \                     sys_init:
   \   00000000   1EFF2FE1           BX       LR               ;; return
    390          
    391          #ifndef sys_jiffies
    392          /** Ticks/jiffies since power up. */

   \                                 In segment CODE, align 4, keep-with-next
    393          u32_t
    394          sys_jiffies(void)
    395          {
    396            return OS_Time;
   \                     sys_jiffies:
   \   00000000   ........           LDR      R0,??DataTable4  ;; OS_Time
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    397          }
    398          #endif
    399          
    400          /** Returns the current time in milliseconds,
    401           * may be the same as sys_jiffies or at least based on it. */

   \                                 In segment CODE, align 4, keep-with-next
    402          u32_t
    403          sys_now(void)
    404          {
    405            return OS_Time;
   \                     sys_now:
   \   00000000   ........           LDR      R0,??DataTable4  ;; OS_Time
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    406          }
    407          

   \                                 In segment CODE, align 4, keep-with-next
    408          sys_prot_t
    409          sys_arch_protect(void)
    410          {
    411            OS_EnterRegion();
   \                     sys_arch_protect:
   \   00000000   ........           LDR      R0,??DataTable5  ;; OS_Counters
   \   00000004   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000008   011081E2           ADD      R1,R1,#+1
   \   0000000C   0010C0E5           STRB     R1,[R0, #+0]
    412            return 1;
   \   00000010   0100A0E3           MOV      R0,#+1
   \   00000014   1EFF2FE1           BX       LR               ;; return
    413          }
    414          
    415          /**
    416           * Leaves a critical section.
    417           *
    418           * @param the preivous protection level
    419           */

   \                                 In segment CODE, align 4, keep-with-next
    420          void
    421          sys_arch_unprotect(sys_prot_t val)
    422          {
   \                     sys_arch_unprotect:
   \   00000000   00402DE9           PUSH     {LR}
    423            (void)val;
    424            OS_LeaveRegion();
   \   00000004   ........           _BLF     OS_LeaveRegion,??OS_LeaveRegion??rA
    425          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     OS_Time

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     OS_Counters
    426          
    427          #ifdef __cplusplus
    428          }
    429          #endif

   Maximum stack usage in bytes:

     Function               CSTACK
     --------               ------
     sys_arch_mbox_fetch       24
     sys_arch_mbox_tryfetch    16
     sys_arch_protect           0
     sys_arch_sem_wait         12
     sys_arch_unprotect         4
     sys_init                   0
     sys_jiffies                0
     sys_mbox_free              8
     sys_mbox_new              12
     sys_mbox_post              8
     sys_mbox_set_invalid       0
     sys_mbox_trypost           8
     sys_mbox_valid             0
     sys_msleep                 4
     sys_mutex_free             4
     sys_mutex_lock             4
     sys_mutex_new              4
     sys_mutex_unlock           4
     sys_now                    0
     sys_sem_free               4
     sys_sem_new                8
     sys_sem_set_invalid        0
     sys_sem_signal             4
     sys_sem_valid              0
     sys_thread_new            48


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     sys_mutex_new             20
     sys_mutex_lock            16
     sys_mutex_unlock          16
     sys_mutex_free            16
     sys_sem_new               96
     sys_sem_signal            16
     sys_arch_sem_wait         64
     sys_sem_free              24
     sys_sem_valid             20
     sys_sem_set_invalid        4
     sys_msleep                16
     sys_mbox_new              52
     sys_mbox_post             20
     sys_mbox_trypost          28
     sys_arch_mbox_fetch       88
     sys_arch_mbox_tryfetch    64
     sys_mbox_free             52
     sys_mbox_valid            16
     sys_mbox_set_invalid       4
     sys_thread_new           208
     TaskCnt                41348
     sys_init                   4
     sys_jiffies               12
     sys_now                   12
     sys_arch_protect          24
     sys_arch_unprotect        16
     ??DataTable4               4
     ??DataTable5               4
      Others                  388

 
  1 292 bytes in segment CODE
 41 348 bytes in segment DATA_Z
     12 bytes in segment INITTAB
 
    916 bytes of CODE memory (+ 388 bytes shared)
 41 348 bytes of DATA memory

Errors: none
Warnings: none
