##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:20:21 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\app\tftp_server.c       #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\app\tftp_server.c       #
#                       --fpu None -D OS_LIBMODE_SP -D CPU_S3C2410 -D        #
#                       OS_RAMVECT=0 -D OS_UART=-1 -D S2TXU -D USE_LZO=1 -D  #
#                       __ARM_LIBRARY__ -D WATCHDOG=1 -D NETWORK=1 -lCN      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\tftp_server.lst             #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\tftp_server.r79              #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\app\tftp_server.c
      1          //*****************************************************************************
      2          //
      3          // tftp.c - A very simple lwIP TFTP server.
      4          //
      5          // Copyright (c) 2009-2015 Texas Instruments Incorporated.  All rights reserved.
      6          // Software License Agreement
      7          // 
      8          // Texas Instruments (TI) is supplying this software for use solely and
      9          // exclusively on TI's microcontroller products. The software is owned by
     10          // TI and/or its suppliers, and is protected under applicable copyright
     11          // laws. You may not combine this software with "viral" open-source
     12          // software in order to form a larger program.
     13          // 
     14          // THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
     15          // NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
     16          // NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     17          // A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
     18          // CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
     19          // DAMAGES, FOR ANY REASON WHATSOEVER.
     20          // 
     21          // This is part of revision 2.1.2.111 of the Tiva Utility Library.
     22          //
     23          //*****************************************************************************
     24          
     25          #include <stdbool.h>
     26          #include <stdint.h>
     27          #include <string.h>
     28          #include <stdlib.h>
     29          #include "lwip/opt.h"
     30          
     31          #if LWIP_NETCONN
     32          
     33          #include <string.h>
     34          #include <stdio.h>
     35          
     36          #include "lwip/mem.h"
     37          #include "lwip/debug.h"
     38          #include "lwip/def.h"
     39          #include "lwip/api.h"
     40          #include "lwip/udp.h"
     41          
     42          //*****************************************************************************
     43          //
     44          //! \addtogroup tftp_api
     45          //! @{
     46          //
     47          //*****************************************************************************
     48          #include "tftp_server.h"
     49          #include "lwip_lib.h"
     50          
     51          //*****************************************************************************
     52          //
     53          // The TFTP commands.
     54          //
     55          //*****************************************************************************
     56          #define TFTP_RRQ                1
     57          #define TFTP_WRQ                2
     58          #define TFTP_DATA               3
     59          #define TFTP_ACK                4
     60          #define TFTP_ERROR              5
     61          
     62          //*****************************************************************************
     63          //
     64          // The UDP port for the TFTP server.
     65          //
     66          //*****************************************************************************
     67          #define TFTP_PORT               69
     68          
     69          //*****************************************************************************
     70          //
     71          // Application connection notification callback.
     72          //
     73          //*****************************************************************************

   \                                 In segment DATA_Z, align 4, align-sorted
     74          static tTFTPRequest g_pfnRequest;
   \                     g_pfnRequest:
   \   00000000                      DS8 4
   \   00000004                      DS8 16
   \   00000014                      DS8 4
     75          
     76          //*****************************************************************************
     77          //
     78          // for udp netconn management.
     79          // problem with tftp is there is no way to shut down an existing udp connection
     80          // when clients give up tftp due to timeout.
     81          // In worst case, these stale connections can suck up all the system resources.
     82          //
     83          //*****************************************************************************
     84          static void TFTPClose(tTFTPConnection *psTFTP);
     85          
     86          #define TFTP_MAX_TRANSFERS          4
     87          static tTFTPConnection* _tftp_transfers[TFTP_MAX_TRANSFERS];
     88          static int              _tftp_num_transfers = 0;
     89          
     90          static void
     91          TFTP_Connection_shift(int from)
     92          {
     93            int i;
     94          
     95            for(i = from + 1; i < TFTP_MAX_TRANSFERS; i++)
     96            {
     97              _tftp_transfers[from] = _tftp_transfers[i];
     98              from++;
     99            }
    100          }
    101          
    102          static void
    103          TFTP_Connection_uncache(tTFTPConnection* psTFTP)
    104          {
    105            int   i;
    106          
    107            for(i = 0; i < _tftp_num_transfers; i++)
    108            {
    109              if(_tftp_transfers[i] == psTFTP)
    110              {
    111                TFTP_Connection_shift(i);
    112                _tftp_num_transfers--;
    113                return;
    114              }
    115            }
    116          }
    117          
    118          static void
    119          TFTP_Connection_cache(tTFTPConnection* psTFTP)
    120          {
    121            if(_tftp_num_transfers >= TFTP_MAX_TRANSFERS)
    122            {
    123              //
    124              // sacrifice the first one
    125              //
    126              TFTPClose(_tftp_transfers[0]);
    127            }
    128          
    129            _tftp_transfers[_tftp_num_transfers] = psTFTP;
    130            _tftp_num_transfers++;
    131          }
    132          
    133          //*****************************************************************************
    134          //
    135          // Close the TFTP connection and free associated resources.
    136          //
    137          //*****************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
    138          static void
    139          TFTPClose(tTFTPConnection *psTFTP)
    140          {
   \                     TFTPClose:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    141            //
    142            // Tell the application we are closing the connection.
    143            //
    144            if(psTFTP->pfnClose)
   \   00000008   141094E5           LDR      R1,[R4, #+20]
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0100000A           BEQ      ??TFTPClose_0
    145            {
    146              psTFTP->pfnClose(psTFTP);
   \   00000014   0FE0A0E1           MOV      LR,PC
   \   00000018   11FF2FE1           BX       R1
    147            }
    148          
    149            TFTP_Connection_uncache(psTFTP);
   \                     ??TFTPClose_0:
   \   0000001C   ........           LDR      R1,??DataTable2  ;; g_pfnRequest
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   142091E5           LDR      R2,[R1, #+20]
   \   00000028   000000EA           B        ??TFTPClose_1
   \                     ??TFTPClose_2:
   \   0000002C   0300A0E1           MOV      R0,R3
   \                     ??TFTPClose_1:
   \   00000030   020050E1           CMP      R0,R2
   \   00000034   100000AA           BGE      ??TFTPClose_3
   \   00000038   00C181E0           ADD      R12,R1,R0, LSL #+2
   \   0000003C   04C09CE5           LDR      R12,[R12, #+4]
   \   00000040   013080E2           ADD      R3,R0,#+1
   \   00000044   04005CE1           CMP      R12,R4
   \   00000048   F7FFFF1A           BNE      ??TFTPClose_2
   \   0000004C   040053E3           CMP      R3,#+4
   \   00000050   070000AA           BGE      ??TFTPClose_4
   \                     ??TFTPClose_5:
   \   00000054   03E181E0           ADD      LR,R1,R3, LSL #+2
   \   00000058   04E09EE5           LDR      LR,[LR, #+4]
   \   0000005C   00C181E0           ADD      R12,R1,R0, LSL #+2
   \   00000060   04E08CE5           STR      LR,[R12, #+4]
   \   00000064   010080E2           ADD      R0,R0,#+1
   \   00000068   013083E2           ADD      R3,R3,#+1
   \   0000006C   040053E3           CMP      R3,#+4
   \   00000070   F7FFFFBA           BLT      ??TFTPClose_5
   \                     ??TFTPClose_4:
   \   00000074   010042E2           SUB      R0,R2,#+1
   \   00000078   140081E5           STR      R0,[R1, #+20]
    150          
    151            //
    152            // Close the underlying UDP connection.
    153            //
    154            udp_remove(psTFTP->psPCB);
   \                     ??TFTPClose_3:
   \   0000007C   200094E5           LDR      R0,[R4, #+32]
   \   00000080   ........           _BLF     udp_remove,??udp_remove??rA
    155          
    156            //
    157            // Free the instance data structure.
    158            //
    159            mem_free(psTFTP);
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           _BLF     mem_free,??mem_free??rA
    160          }
   \   0000008C   1040BDE8           POP      {R4,LR}
   \   00000090   1EFF2FE1           BX       LR               ;; return
    161          
    162          //*****************************************************************************
    163          //
    164          // Sends a TFTP error packet.
    165          //
    166          //*****************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
    167          static void
    168          TFTPErrorSend(tTFTPConnection *psTFTP, tTFTPError eError)
    169          {
   \                     TFTPErrorSend:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    170            uint32_t ui32Length;
    171            uint8_t *pui8Data;
    172            struct pbuf *p;
    173          
    174            //
    175            // How big is this packet going to be?
    176            //
    177            ui32Length = 5 + strlen(psTFTP->pcErrorString);
   \   00000008   1C0094E5           LDR      R0,[R4, #+28]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   ........           _BLF     strlen,??strlen??rA
   \   00000014   056080E2           ADD      R6,R0,#+5
    178          
    179            //
    180            // Allocate a pbuf for this data packet.
    181            //
    182            p = pbuf_alloc(PBUF_TRANSPORT, ui32Length, PBUF_RAM);
   \   00000018   0020A0E3           MOV      R2,#+0
   \   0000001C   0618A0E1           MOV      R1,R6, LSL #+16
   \   00000020   2118A0E1           MOV      R1,R1, LSR #+16
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   ........           _BLF     pbuf_alloc,??pbuf_alloc??rA
   \   0000002C   0070B0E1           MOVS     R7,R0
    183            if(!p)
   \   00000030   1100000A           BEQ      ??TFTPErrorSend_0
    184            {
    185              return;
    186            }
    187          
    188            //
    189            // Get a pointer to the data packet.
    190            //
    191            pui8Data = (uint8_t *)p->payload;
   \   00000034   040097E5           LDR      R0,[R7, #+4]
    192          
    193            //
    194            // Fill in the packet.
    195            //
    196            pui8Data[0] = (TFTP_ERROR >> 8) & 0xff;
   \   00000038   0010A0E3           MOV      R1,#+0
   \   0000003C   0010C0E5           STRB     R1,[R0, #+0]
    197            pui8Data[1] = TFTP_ERROR & 0xff;
   \   00000040   0510A0E3           MOV      R1,#+5
   \   00000044   0110C0E5           STRB     R1,[R0, #+1]
    198            pui8Data[2] = ((uint32_t)eError >> 8) & 0xff;
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   2114A0E1           LSR      R1,R1,#+8
   \   00000050   0210C0E5           STRB     R1,[R0, #+2]
    199            pui8Data[3] = (uint32_t)eError & 0xff;
   \   00000054   0350C0E5           STRB     R5,[R0, #+3]
    200            memcpy(&pui8Data[4], psTFTP->pcErrorString, ui32Length - 5);
   \   00000058   1C1094E5           LDR      R1,[R4, #+28]
   \   0000005C   052046E2           SUB      R2,R6,#+5
   \   00000060   040080E2           ADD      R0,R0,#+4
   \   00000064   ........           _BLF     memcpy,??memcpy??rA
    201          
    202            //
    203            // Send the data packet.
    204            //
    205            udp_send(psTFTP->psPCB, p);
   \   00000068   200094E5           LDR      R0,[R4, #+32]
   \   0000006C   0710A0E1           MOV      R1,R7
   \   00000070   ........           _BLF     udp_send,??udp_send??rA
    206          
    207            //
    208            // Free the pbuf.
    209            //
    210            pbuf_free(p);
   \   00000074   0700A0E1           MOV      R0,R7
   \   00000078   ........           _BLF     pbuf_free,??pbuf_free??rA
    211          }
   \                     ??TFTPErrorSend_0:
   \   0000007C   F040BDE8           POP      {R4-R7,LR}
   \   00000080   1EFF2FE1           BX       LR               ;; return
    212          
    213          //*****************************************************************************
    214          //
    215          // Sends a TFTP data packet.
    216          //
    217          //*****************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
    218          static void
    219          TFTPDataSend(tTFTPConnection *psTFTP)
    220          {
   \                     TFTPDataSend:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    221            uint32_t ui32Length;
    222            uint8_t *pui8Data;
    223            tTFTPError eError;
    224            struct pbuf *p;
    225          
    226            //
    227            // Determine the number of bytes to place into this packet.
    228            //
    229            if(psTFTP->ui32DataRemaining < (psTFTP->ui32BlockNum * TFTP_BLOCK_SIZE))
   \   00000008   080094E5           LDR      R0,[R4, #+8]
   \   0000000C   241094E5           LDR      R1,[R4, #+36]
    230            {
    231              ui32Length = psTFTP->ui32DataRemaining & (TFTP_BLOCK_SIZE - 1);
    232            }
    233            else
    234            {
    235              ui32Length = TFTP_BLOCK_SIZE;
    236            }
    237          
    238            //
    239            // Allocate a pbuf for this data packet.
    240            //
    241            p = pbuf_alloc(PBUF_TRANSPORT, ui32Length + 4, PBUF_RAM);
   \   00000010   0020A0E3           MOV      R2,#+0
   \   00000014   810450E1           CMP      R0,R1, LSL #+9
   \   00000018   800BA031           LSLCC    R0,R0,#+23
   \   0000001C   A05BA031           LSRCC    R5,R0,#+23
   \   00000020   805FA023           MOVCS    R5,#+512
   \   00000024   041085E2           ADD      R1,R5,#+4
   \   00000028   0118A0E1           MOV      R1,R1, LSL #+16
   \   0000002C   2118A0E1           MOV      R1,R1, LSR #+16
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   ........           _BLF     pbuf_alloc,??pbuf_alloc??rA
   \   00000038   0060B0E1           MOVS     R6,R0
    242            if(!p)
   \   0000003C   1D00000A           BEQ      ??TFTPDataSend_0
    243            {
    244              return;
    245            }
    246          
    247            //
    248            // Get a pointer to the data packet.
    249            //
    250            pui8Data = (uint8_t *)p->payload;
   \   00000040   040096E5           LDR      R0,[R6, #+4]
    251          
    252            //
    253            // Fill in the packet header.
    254            //
    255            pui8Data[0] = (TFTP_DATA >> 8) & 0xff;
   \   00000044   0010A0E3           MOV      R1,#+0
   \   00000048   0010C0E5           STRB     R1,[R0, #+0]
    256            pui8Data[1] = TFTP_DATA & 0xff;
   \   0000004C   0310A0E3           MOV      R1,#+3
   \   00000050   0110C0E5           STRB     R1,[R0, #+1]
    257            pui8Data[2] = (psTFTP->ui32BlockNum >> 8) & 0xff;
   \   00000054   241094E5           LDR      R1,[R4, #+36]
   \   00000058   2114A0E1           LSR      R1,R1,#+8
   \   0000005C   0210C0E5           STRB     R1,[R0, #+2]
    258            pui8Data[3] = psTFTP->ui32BlockNum & 0xff;
   \   00000060   241094E5           LDR      R1,[R4, #+36]
   \   00000064   0310C0E5           STRB     R1,[R0, #+3]
    259          
    260            //
    261            // Ask the application to provide the data we need.
    262            //
    263            psTFTP->pui8Data = pui8Data + 4;
   \   00000068   040080E2           ADD      R0,R0,#+4
   \   0000006C   000084E5           STR      R0,[R4, #+0]
    264            psTFTP->ui32DataLength = ui32Length;
   \   00000070   045084E5           STR      R5,[R4, #+4]
    265            eError = psTFTP->pfnGetData(psTFTP);
   \   00000074   0C1094E5           LDR      R1,[R4, #+12]
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   0FE0A0E1           MOV      LR,PC
   \   00000080   11FF2FE1           BX       R1
    266          
    267            //
    268            // Send the data packet or, if an error was reported, send an error.
    269            //
    270            if(eError == TFTP_OK)
   \   00000084   010070E3           CMN      R0,#+1
   \   00000088   0300001A           BNE      ??TFTPDataSend_1
    271            {
    272              udp_send(psTFTP->psPCB, p);
   \   0000008C   200094E5           LDR      R0,[R4, #+32]
   \   00000090   0610A0E1           MOV      R1,R6
   \   00000094   ........           _BLF     udp_send,??udp_send??rA
   \   00000098   040000EA           B        ??TFTPDataSend_2
    273            }
    274            else
    275            {
    276              TFTPErrorSend(psTFTP, eError);
   \                     ??TFTPDataSend_1:
   \   0000009C   0010A0E1           MOV      R1,R0
   \   000000A0   0400A0E1           MOV      R0,R4
   \   000000A4   ........           BL       TFTPErrorSend
    277              TFTPClose(psTFTP);
   \   000000A8   0400A0E1           MOV      R0,R4
   \   000000AC   ........           BL       TFTPClose
    278            }
    279          
    280            //
    281            // Free the pbuf.
    282            //
    283            pbuf_free(p);
   \                     ??TFTPDataSend_2:
   \   000000B0   0600A0E1           MOV      R0,R6
   \   000000B4   ........           _BLF     pbuf_free,??pbuf_free??rA
    284          }
   \                     ??TFTPDataSend_0:
   \   000000B8   7040BDE8           POP      {R4-R6,LR}
   \   000000BC   1EFF2FE1           BX       LR               ;; return
    285          
    286          //*****************************************************************************
    287          //
    288          // Send an ACK packet back to the TFTP client.
    289          //
    290          //*****************************************************************************
    291          static void
    292          TFTPDataAck(tTFTPConnection *psTFTP)
    293          {
    294            uint8_t *pui8Data;
    295            struct pbuf *p;
    296          
    297            //
    298            // Allocate a pbuf for this data packet.
    299            //
    300            p = pbuf_alloc(PBUF_TRANSPORT, 4, PBUF_RAM);
    301            if(!p)
    302            {
    303              return;
    304            }
    305          
    306            //
    307            // Get a pointer to the data packet.
    308            //
    309            pui8Data = (uint8_t *)p->payload;
    310          
    311            //
    312            // Fill in the packet header.
    313            //
    314            pui8Data[0] = (TFTP_ACK >> 8) & 0xff;
    315            pui8Data[1] = TFTP_ACK & 0xff;
    316            pui8Data[2] = (psTFTP->ui32BlockNum >> 8) & 0xff;
    317            pui8Data[3] = psTFTP->ui32BlockNum & 0xff;
    318          
    319            //
    320            // Send the data packet.
    321            //
    322            udp_send(psTFTP->psPCB, p);
    323          
    324            //
    325            // Free the pbuf.
    326            //
    327            pbuf_free(p);
    328          }
    329          
    330          //*****************************************************************************
    331          //
    332          // Handles datagrams received from the TFTP data connection.
    333          //
    334          //*****************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
    335          static void
    336          TFTPDataRecv(void *arg, struct udp_pcb *upcb, struct pbuf *p,
    337                       struct ip_addr *addr, u16_t port)
    338          {
   \                     TFTPDataRecv:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0250A0E1           MOV      R5,R2
    339            uint8_t *pui8Data;
    340            uint32_t ui32Block;
    341            struct pbuf *pBuf;
    342            tTFTPConnection *psTFTP;
    343            tTFTPError eRetcode;
    344          
    345            //
    346            // Initialize our return code.
    347            //
    348            eRetcode = TFTP_ERR_NOT_DEFINED;
    349          
    350            //
    351            // Get a pointer to the connection instance data.
    352            //
    353            psTFTP = (tTFTPConnection *)arg;
    354          
    355            //
    356            // Get a pointer to the TFTP packet.
    357            //
    358            pui8Data = (uint8_t *)(p->payload);
   \   00000008   041095E5           LDR      R1,[R5, #+4]
   \   0000000C   0040A0E1           MOV      R4,R0
    359          
    360            //
    361            // If this is an ACK packet, send back the next block to satisfy an
    362            // ongoing GET (read) request.
    363            //
    364            if((pui8Data[0] == ((TFTP_ACK >> 8) & 0xff)) &&
    365                (pui8Data[1] == (TFTP_ACK & 0xff)))
   \   00000010   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   000052E3           CMP      R2,#+0
   \   0000001C   0120D105           LDRBEQ   R2,[R1, #+1]
   \   00000020   04005203           CMPEQ    R2,#+4
   \   00000024   0A00001A           BNE      ??TFTPDataRecv_0
    366            {
    367              //
    368              // Extract the block number from the acknowledge.
    369              //
    370              ui32Block = (pui8Data[2] << 8) + pui8Data[3];
   \   00000028   0200D1E5           LDRB     R0,[R1, #+2]
   \   0000002C   0310D1E5           LDRB     R1,[R1, #+3]
   \   00000030   000481E0           ADD      R0,R1,R0, LSL #+8
    371          
    372              //
    373              // See if there is more data to be sent.  Note that we need the "<="
    374              // here to ensure that we send back a zero length packet in the case
    375              // that the file is a multiple of 512 bytes (in other words, the last
    376              // packet of valid data was a full packet).
    377              //
    378              if((ui32Block * TFTP_BLOCK_SIZE) <= psTFTP->ui32DataRemaining)
   \   00000034   081094E5           LDR      R1,[R4, #+8]
   \   00000038   800451E1           CMP      R1,R0, LSL #+9
   \   0000003C   4E00003A           BCC      ??TFTPDataRecv_1
    379              {
    380                //
    381                // Send the next block of the file.
    382                //
    383                psTFTP->ui32BlockNum = ui32Block + 1;
   \   00000040   010080E2           ADD      R0,R0,#+1
   \   00000044   240084E5           STR      R0,[R4, #+36]
    384                TFTPDataSend(psTFTP);
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           BL       TFTPDataSend
   \   00000050   4B0000EA           B        ??TFTPDataRecv_2
    385              }
    386              else
    387              {
    388                //
    389                // The transfer is complete, so close the data connection.
    390                //
    391                TFTPClose(psTFTP);
    392                psTFTP = NULL;
    393              }
    394            }
    395            else
    396            {
    397              //
    398              // If this is a DATA packet, get the payload and write it to the
    399              // appropriate location in the serial flash.
    400              //
    401              if((pui8Data[0] == ((TFTP_DATA >> 8) & 0xff)) &&
    402                  (pui8Data[1] == (TFTP_DATA & 0xff)))
   \                     ??TFTPDataRecv_0:
   \   00000054   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000058   000052E3           CMP      R2,#+0
   \   0000005C   0120D105           LDRBEQ   R2,[R1, #+1]
   \   00000060   03005203           CMPEQ    R2,#+3
   \   00000064   3F00001A           BNE      ??TFTPDataRecv_3
    403              {
    404                //
    405                // This is a data packet.  Extract the block number from the packet
    406                // and set the offset within the block (stored in
    407                // ui32DataRemaining) to zero.
    408                //
    409                psTFTP->ui32BlockNum = (pui8Data[2] << 8) + pui8Data[3];
   \   00000068   0220D1E5           LDRB     R2,[R1, #+2]
   \   0000006C   0330D1E5           LDRB     R3,[R1, #+3]
    410                psTFTP->ui32DataRemaining = 0;
   \   00000070   0060A0E3           MOV      R6,#+0
    411                psTFTP->ui32DataLength = p->len - 4;
    412          
    413                //
    414                // Pass the data back to the application for handling.  Remember
    415                // that the data may be stored across several pbufs in the chain.
    416                // We can't assume it is in a contiguous block.
    417                //
    418                psTFTP->pui8Data = pui8Data + 4;
   \   00000074   041081E2           ADD      R1,R1,#+4
   \   00000078   022483E0           ADD      R2,R3,R2, LSL #+8
   \   0000007C   242084E5           STR      R2,[R4, #+36]
   \   00000080   086084E5           STR      R6,[R4, #+8]
   \   00000084   BA20D5E1           LDRH     R2,[R5, #+10]
    419                pBuf = p;
   \   00000088   0570A0E1           MOV      R7,R5
   \   0000008C   0080E0E1           MVN      R8,R0
   \   00000090   042042E2           SUB      R2,R2,#+4
   \   00000094   042084E5           STR      R2,[R4, #+4]
   \   00000098   001084E5           STR      R1,[R4, #+0]
    420          
    421                //
    422                // Keep writing until we run out of data.
    423                //
    424                while(pBuf)
   \                     ??TFTPDataRecv_4:
   \   0000009C   000057E3           CMP      R7,#+0
   \   000000A0   1100000A           BEQ      ??TFTPDataRecv_5
   \   000000A4   0A0000EA           B        ??TFTPDataRecv_6
    425                {
    426                  //
    427                  // Pass this block to the application.
    428                  //
    429                  eRetcode = psTFTP->pfnPutData(psTFTP);
    430          
    431                  //
    432                  // Was the data written successfully?
    433                  //
    434                  if(eRetcode != TFTP_OK)
    435                  {
    436                    //
    437                    // No - drop out.
    438                    //
    439                    break;
    440                  }
    441          
    442                  //
    443                  // Update the offset so that it is correct for the next pbuf
    444                  // in the chain.
    445                  //
    446                  psTFTP->ui32DataRemaining += psTFTP->ui32DataLength;
   \                     ??TFTPDataRecv_7:
   \   000000A8   081094E5           LDR      R1,[R4, #+8]
   \   000000AC   042094E5           LDR      R2,[R4, #+4]
   \   000000B0   011082E0           ADD      R1,R2,R1
   \   000000B4   081084E5           STR      R1,[R4, #+8]
    447          
    448                  //
    449                  // Move to the next pbuf in the chain
    450                  //
    451                  pBuf = pBuf->next;
   \   000000B8   007097E5           LDR      R7,[R7, #+0]
    452                  if(pBuf)
   \   000000BC   000057E3           CMP      R7,#+0
   \   000000C0   F5FFFF0A           BEQ      ??TFTPDataRecv_4
    453                  {
    454                    psTFTP->pui8Data = pBuf->payload;
   \   000000C4   040097E5           LDR      R0,[R7, #+4]
   \   000000C8   000084E5           STR      R0,[R4, #+0]
    455                    psTFTP->ui32DataLength = pBuf->len;
   \   000000CC   BA00D7E1           LDRH     R0,[R7, #+10]
   \   000000D0   040084E5           STR      R0,[R4, #+4]
    456                  }
   \                     ??TFTPDataRecv_6:
   \   000000D4   101094E5           LDR      R1,[R4, #+16]
   \   000000D8   0400A0E1           MOV      R0,R4
   \   000000DC   0FE0A0E1           MOV      LR,PC
   \   000000E0   11FF2FE1           BX       R1
   \   000000E4   080050E1           CMP      R0,R8
   \   000000E8   EEFFFF0A           BEQ      ??TFTPDataRecv_7
    457                }
    458          
    459                //
    460                // If we get here and there was an error reported, pass the error
    461                // back to the TFTP client.
    462                //
    463                if(psTFTP && (eRetcode != TFTP_OK))
   \                     ??TFTPDataRecv_5:
   \   000000EC   000054E3           CMP      R4,#+0
   \   000000F0   08005011           CMPNE    R0,R8
   \   000000F4   0300000A           BEQ      ??TFTPDataRecv_8
    464                {
    465                  //
    466                  // Send the error code to the client.
    467                  //
    468                  TFTPErrorSend(psTFTP, eRetcode);
   \   000000F8   0010A0E1           MOV      R1,R0
   \   000000FC   0400A0E1           MOV      R0,R4
   \   00000100   ........           BL       TFTPErrorSend
    469          
    470                  //
    471                  // Close the connection.
    472                  //
    473                  TFTPClose(psTFTP);
   \   00000104   1C0000EA           B        ??TFTPDataRecv_1
    474                  psTFTP = NULL;
    475                }
    476                else
    477                {
    478                  //
    479                  // Acknowledge this block.
    480                  //
    481                  TFTPDataAck(psTFTP);
   \                     ??TFTPDataRecv_8:
   \   00000108   0020A0E3           MOV      R2,#+0
   \   0000010C   0410A0E3           MOV      R1,#+4
   \   00000110   0200A0E1           MOV      R0,R2
   \   00000114   ........           _BLF     pbuf_alloc,??pbuf_alloc??rA
   \   00000118   0070B0E1           MOVS     R7,R0
   \   0000011C   0D00000A           BEQ      ??TFTPDataRecv_9
   \   00000120   040097E5           LDR      R0,[R7, #+4]
   \   00000124   0410A0E3           MOV      R1,#+4
   \   00000128   0060C0E5           STRB     R6,[R0, #+0]
   \   0000012C   0110C0E5           STRB     R1,[R0, #+1]
   \   00000130   241094E5           LDR      R1,[R4, #+36]
   \   00000134   2114A0E1           LSR      R1,R1,#+8
   \   00000138   0210C0E5           STRB     R1,[R0, #+2]
   \   0000013C   241094E5           LDR      R1,[R4, #+36]
   \   00000140   0310C0E5           STRB     R1,[R0, #+3]
   \   00000144   200094E5           LDR      R0,[R4, #+32]
   \   00000148   0710A0E1           MOV      R1,R7
   \   0000014C   ........           _BLF     udp_send,??udp_send??rA
   \   00000150   0700A0E1           MOV      R0,R7
   \   00000154   ........           _BLF     pbuf_free,??pbuf_free??rA
    482          
    483                  //
    484                  // Is the transfer finished?
    485                  //
    486                  if(p->tot_len < (TFTP_BLOCK_SIZE + 4))
   \                     ??TFTPDataRecv_9:
   \   00000158   B800D5E1           LDRH     R0,[R5, #+8]
   \   0000015C   810F50E3           CMP      R0,#+516
   \   00000160   0700002A           BCS      ??TFTPDataRecv_2
    487                  {
    488                    //
    489                    // We got a short packet so the transfer is complete.
    490                    // Close the connection.
    491                    //
    492                    TFTPClose(psTFTP);
   \   00000164   040000EA           B        ??TFTPDataRecv_1
    493                    psTFTP = NULL;
    494                  }
    495                }
    496              }
    497              else
    498              {
    499                //
    500                // Is the client reporting an error?
    501                //
    502                if((pui8Data[0] == ((TFTP_ERROR >> 8) & 0xff)) &&
    503                    (pui8Data[1] == (TFTP_ERROR & 0xff)))
   \                     ??TFTPDataRecv_3:
   \   00000168   0000D1E5           LDRB     R0,[R1, #+0]
   \   0000016C   000050E3           CMP      R0,#+0
   \   00000170   0100D105           LDRBEQ   R0,[R1, #+1]
   \   00000174   05005003           CMPEQ    R0,#+5
   \   00000178   0100001A           BNE      ??TFTPDataRecv_2
    504                {
    505                  //
    506                  // Yes - we got an error so close the connection.
    507                  //
    508                  TFTPClose(psTFTP);
   \                     ??TFTPDataRecv_1:
   \   0000017C   0400A0E1           MOV      R0,R4
   \   00000180   ........           BL       TFTPClose
    509                  psTFTP = NULL;
    510                }
    511              }
    512            }
    513          
    514            //
    515            // Free the pbuf.
    516            //
    517            pbuf_free(p);
   \                     ??TFTPDataRecv_2:
   \   00000184   0500A0E1           MOV      R0,R5
   \   00000188   ........           _BLF     pbuf_free,??pbuf_free??rA
    518          }
   \   0000018C   F041BDE8           POP      {R4-R8,LR}
   \   00000190   1EFF2FE1           BX       LR               ;; return
    519          
    520          //*****************************************************************************
    521          //
    522          // Parses the request string to determine the transfer mode, netascii, octet or
    523          // mail, for this request.
    524          //
    525          //*****************************************************************************
    526          static tTFTPMode
    527          TFTPModeGet(uint8_t *pui8Request, uint32_t ui32Len)
    528          {
    529            uint32_t ui32Loop, ui32Max;
    530          
    531            //
    532            // Look for the first zero after the start of the filename string (skipping
    533            // the first two bytes of the request packet).
    534            //
    535            for(ui32Loop = 2; ui32Loop < ui32Len; ui32Loop++)
    536            {
    537              if(pui8Request[ui32Loop] == (uint8_t)0)
    538              {
    539                break;
    540              }
    541            }
    542          
    543            //
    544            // Skip past the zero.
    545            //
    546            ui32Loop++;
    547          
    548            //
    549            // Did we run off the end of the string?
    550            //
    551            if(ui32Loop >= ui32Len)
    552            {
    553              //
    554              // Yes - this appears to be an invalid request.
    555              //
    556              return(TFTP_MODE_INVALID);
    557            }
    558          
    559            //
    560            // How much data do we have left to look for the mode string?
    561            //
    562            ui32Max = ui32Len - ui32Loop;
    563          
    564            //
    565            // Now determine which of the modes this request asks for.  Is it ASCII?
    566            //
    567            if(!strncasecmp("netascii", (char *)&pui8Request[ui32Loop], ui32Max))
    568            {
    569              //
    570              // This is an ASCII file transfer.
    571              //
    572              return(TFTP_MODE_NETASCII);
    573            }
    574          
    575            //
    576            // Binary transfer?
    577            //
    578            if(!strncasecmp("octet", (char *)&pui8Request[ui32Loop], ui32Max))
    579            {
    580              //
    581              // This is a binary file transfer.
    582              //
    583              return(TFTP_MODE_OCTET);
    584            }
    585          
    586            //
    587            // All other strings are invalid or obsolete ("mail" for example).
    588            //
    589            return(TFTP_MODE_INVALID);
    590          }
    591          
    592          //*****************************************************************************
    593          //
    594          // Handles datagrams received on the TFTP server port.
    595          //
    596          //*****************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
    597          static void
    598          TFTPRecv(void *arg, struct udp_pcb *upcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
    599          {
   \                     TFTPRecv:
   \   00000000   F84F2DE9           PUSH     {R3-R11,LR}
   \   00000004   0240A0E1           MOV      R4,R2
    600            uint8_t *pui8Data;
    601            bool bGetRequest;
    602            tTFTPMode eMode;
    603            tTFTPError eRetcode;
    604            tTFTPConnection *psTFTP;
    605          
    606            //
    607            // Get a pointer to the TFTP packet.
    608            //
    609            pui8Data = (uint8_t *)(p->payload);
   \   00000008   045094E5           LDR      R5,[R4, #+4]
    610          
    611            //
    612            // Is this a read (GET) request?
    613            //
    614            if((pui8Data[0] == ((TFTP_RRQ >> 8) & 0xff)) &&
    615                (pui8Data[1] == (TFTP_RRQ & 0xff)))
   \   0000000C   0160A0E3           MOV      R6,#+1
   \   00000010   0000D5E5           LDRB     R0,[R5, #+0]
   \   00000014   0070A0E3           MOV      R7,#+0
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0100D505           LDRBEQ   R0,[R5, #+1]
   \   00000020   01005003           CMPEQ    R0,#+1
   \   00000024   0300001A           BNE      ??TFTPRecv_0
    616            {
    617              //
    618              // Yes - remember that this is a GET request.
    619              //
    620              bGetRequest = true;
   \   00000028   0180A0E3           MOV      R8,#+1
    621            }
    622          
    623            //
    624            // Is this a write (PUT) request?
    625            //
    626            else if((pui8Data[0] == ((TFTP_WRQ >> 8) & 0xff)) &&
    627                (pui8Data[1] == (TFTP_WRQ & 0xff)))
    628            {
    629              //
    630              // Yes - remember that this is a PUT request.
    631              //
    632              bGetRequest = false;
    633            }
    634            else
    635            {
    636              //
    637              // The request is neither GET nor PUT so just ignore it.
    638              //
    639              pbuf_free(p);
    640              return;
    641            }
    642          
    643            //
    644            // What is the mode for this request?
    645            //
    646            eMode = TFTPModeGet(pui8Data, p->len);
   \                     ??TFTPRecv_1:
   \   0000002C   BA00D4E1           LDRH     R0,[R4, #+10]
   \   00000030   0210A0E3           MOV      R1,#+2
   \   00000034   070000EA           B        ??TFTPRecv_2
   \                     ??TFTPRecv_0:
   \   00000038   0000D5E5           LDRB     R0,[R5, #+0]
   \   0000003C   000050E3           CMP      R0,#+0
   \   00000040   0100D505           LDRBEQ   R0,[R5, #+1]
   \   00000044   02005003           CMPEQ    R0,#+2
   \   00000048   4600001A           BNE      ??TFTPRecv_3
   \   0000004C   0080A0E3           MOV      R8,#+0
   \   00000050   F5FFFFEA           B        ??TFTPRecv_1
   \                     ??TFTPRecv_4:
   \   00000054   0210A0E1           MOV      R1,R2
   \                     ??TFTPRecv_2:
   \   00000058   012081E2           ADD      R2,R1,#+1
   \   0000005C   000051E1           CMP      R1,R0
   \   00000060   0200002A           BCS      ??TFTPRecv_5
   \   00000064   0510D1E7           LDRB     R1,[R1, +R5]
   \   00000068   000051E3           CMP      R1,#+0
   \   0000006C   F8FFFF1A           BNE      ??TFTPRecv_4
   \                     ??TFTPRecv_5:
   \   00000070   000052E1           CMP      R2,R0
   \   00000074   3B00002A           BCS      ??TFTPRecv_3
   \   00000078   68919FE5           LDR      R9,??TFTPRecv_6  ;; `?<Constant "netascii">`
   \   0000007C   02A040E0           SUB      R10,R0,R2
   \   00000080   05B082E0           ADD      R11,R2,R5
   \   00000084   0A20A0E1           MOV      R2,R10
   \   00000088   0B10A0E1           MOV      R1,R11
   \   0000008C   0900A0E1           MOV      R0,R9
   \   00000090   ........           _BLF     strncasecmp,??strncasecmp??rA
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   00A0A003           MOVEQ    R10,#+0
   \   0000009C   0600000A           BEQ      ??TFTPRecv_7
   \   000000A0   0A20A0E1           MOV      R2,R10
   \   000000A4   0B10A0E1           MOV      R1,R11
   \   000000A8   0C0089E2           ADD      R0,R9,#+12
   \   000000AC   ........           _BLF     strncasecmp,??strncasecmp??rA
   \   000000B0   000050E3           CMP      R0,#+0
   \   000000B4   2B00001A           BNE      ??TFTPRecv_3
   \   000000B8   01A0A0E3           MOV      R10,#+1
    647          
    648            //
    649            // Was the transfer mode valid?
    650            //
    651            if(eMode != TFTP_MODE_INVALID)
    652            {
    653              //
    654              // The transfer mode is valid so allocate a new connection instance
    655              // and pass this to the client to have it tell us how to proceed.
    656              //
    657              psTFTP = (tTFTPConnection *)mem_malloc(sizeof(tTFTPConnection));
   \                     ??TFTPRecv_7:
   \   000000BC   2800A0E3           MOV      R0,#+40
   \   000000C0   ........           _BLF     mem_malloc,??mem_malloc??rA
   \   000000C4   00B0B0E1           MOVS     R11,R0
    658          
    659              //
    660              // If we can't allocate the connection instance, all we can do is
    661              // ignore the datagram.
    662              //
    663              if(!psTFTP)
   \   000000C8   2600000A           BEQ      ??TFTPRecv_3
    664              {
    665                pbuf_free(p);
    666                return;
    667              }
    668          
    669              //
    670              // Clear out the structure and initialize a few fields.
    671              //
    672              memset(psTFTP, 0, sizeof(tTFTPConnection));
   \   000000CC   2820A0E3           MOV      R2,#+40
   \   000000D0   0010A0E3           MOV      R1,#+0
   \   000000D4   ........           _BLF     memset,??memset??rA
    673              psTFTP->pcErrorString = "Unknown error";
   \   000000D8   140089E2           ADD      R0,R9,#+20
    674          
    675              //
    676              // Yes - create the new UDP connection and set things up to
    677              // handle this request.
    678              //
    679              psTFTP->psPCB = udp_new();
    680              udp_recv(psTFTP->psPCB, TFTPDataRecv, psTFTP);
    681              udp_connect(psTFTP->psPCB, addr, port);
    682          
    683              TFTP_Connection_cache(psTFTP);
   \   000000DC   ........           LDR      R9,??DataTable2  ;; g_pfnRequest
   \   000000E0   1C008BE5           STR      R0,[R11, #+28]
   \   000000E4   ........           _BLF     udp_new,??udp_new??rA
   \   000000E8   FC109FE5           LDR      R1,??TFTPRecv_6+0x4  ;; TFTPDataRecv
   \   000000EC   20008BE5           STR      R0,[R11, #+32]
   \   000000F0   0B20A0E1           MOV      R2,R11
   \   000000F4   ........           _BLF     udp_recv,??udp_recv??rA
   \   000000F8   B822DDE1           LDRH     R2,[SP, #+40]
   \   000000FC   00109DE5           LDR      R1,[SP, #+0]
   \   00000100   20009BE5           LDR      R0,[R11, #+32]
   \   00000104   ........           _BLF     udp_connect,??udp_connect??rA
   \   00000108   140099E5           LDR      R0,[R9, #+20]
   \   0000010C   040050E3           CMP      R0,#+4
   \   00000110   010000BA           BLT      ??TFTPRecv_8
   \   00000114   040099E5           LDR      R0,[R9, #+4]
   \   00000118   ........           BL       TFTPClose
   \                     ??TFTPRecv_8:
   \   0000011C   140099E5           LDR      R0,[R9, #+20]
    684              //
    685              // Ask the application if it wants to proceed with this request.
    686              //
    687              eRetcode = g_pfnRequest(psTFTP, bGetRequest, (int8_t *)(pui8Data + 2),
    688                  eMode);
   \   00000120   022085E2           ADD      R2,R5,#+2
   \   00000124   001189E0           ADD      R1,R9,R0, LSL #+2
   \   00000128   04B081E5           STR      R11,[R1, #+4]
   \   0000012C   005099E5           LDR      R5,[R9, #+0]
   \   00000130   010080E2           ADD      R0,R0,#+1
   \   00000134   140089E5           STR      R0,[R9, #+20]
   \   00000138   0A30A0E1           MOV      R3,R10
   \   0000013C   0810A0E1           MOV      R1,R8
   \   00000140   0B00A0E1           MOV      R0,R11
   \   00000144   0FE0A0E1           MOV      LR,PC
   \   00000148   15FF2FE1           BX       R5
    689          
    690              //
    691              // Does it want to go on?
    692              //
    693              if(eRetcode == TFTP_OK)
   \   0000014C   010070E3           CMN      R0,#+1
   \   00000150   1E00001A           BNE      ??TFTPRecv_9
    694              {
    695                //
    696                // Yes - what kind of request is this?
    697                //
    698                if(bGetRequest)
   \   00000154   000058E3           CMP      R8,#+0
   \   00000158   0600000A           BEQ      ??TFTPRecv_10
    699                {
    700                  //
    701                  // For a GET request, we send back the first block of data.
    702                  //
    703                  psTFTP->ui32BlockNum = 1;
   \   0000015C   24608BE5           STR      R6,[R11, #+36]
    704                  TFTPDataSend(psTFTP);
   \   00000160   0B00A0E1           MOV      R0,R11
   \   00000164   ........           BL       TFTPDataSend
    705                }
   \                     ??TFTPRecv_3:
   \   00000168   0400A0E1           MOV      R0,R4
   \   0000016C   ........           _BLF     pbuf_free,??pbuf_free??rA
   \   00000170   F14FBDE8           POP      {R0,R4-R11,LR}
   \   00000174   1EFF2FE1           BX       LR               ;; return
    706                else
    707                {
    708                  //
    709                  // For a PUT request, we acknowledge the transfer which tells
    710                  // the TFTP client that it can start sending us data.
    711                  //
    712                  psTFTP->ui32BlockNum = 0;
   \                     ??TFTPRecv_10:
   \   00000178   24708BE5           STR      R7,[R11, #+36]
    713                  TFTPDataAck(psTFTP);
   \   0000017C   0020A0E3           MOV      R2,#+0
   \   00000180   0410A0E3           MOV      R1,#+4
   \   00000184   0200A0E1           MOV      R0,R2
   \   00000188   ........           _BLF     pbuf_alloc,??pbuf_alloc??rA
   \   0000018C   0050B0E1           MOVS     R5,R0
   \   00000190   F4FFFF0A           BEQ      ??TFTPRecv_3
   \   00000194   040095E5           LDR      R0,[R5, #+4]
   \   00000198   0410A0E3           MOV      R1,#+4
   \   0000019C   0070C0E5           STRB     R7,[R0, #+0]
   \   000001A0   0110C0E5           STRB     R1,[R0, #+1]
   \   000001A4   24109BE5           LDR      R1,[R11, #+36]
   \   000001A8   2114A0E1           LSR      R1,R1,#+8
   \   000001AC   0210C0E5           STRB     R1,[R0, #+2]
   \   000001B0   24109BE5           LDR      R1,[R11, #+36]
   \   000001B4   0310C0E5           STRB     R1,[R0, #+3]
   \   000001B8   20009BE5           LDR      R0,[R11, #+32]
   \   000001BC   0510A0E1           MOV      R1,R5
   \   000001C0   ........           _BLF     udp_send,??udp_send??rA
   \   000001C4   0500A0E1           MOV      R0,R5
   \   000001C8   ........           _BLF     pbuf_free,??pbuf_free??rA
   \   000001CC   E5FFFFEA           B        ??TFTPRecv_3
    714                }
    715              }
    716              else
    717              {
    718                //
    719                // The application indicated that there was an error.  Send the
    720                // error report and close the connection.
    721                //
    722                TFTPErrorSend(psTFTP, eRetcode);
   \                     ??TFTPRecv_9:
   \   000001D0   0010A0E1           MOV      R1,R0
   \   000001D4   0B00A0E1           MOV      R0,R11
   \   000001D8   ........           BL       TFTPErrorSend
    723                TFTPClose(psTFTP);
   \   000001DC   0B00A0E1           MOV      R0,R11
   \   000001E0   ........           BL       TFTPClose
    724                psTFTP = NULL;
   \   000001E4   DFFFFFEA           B        ??TFTPRecv_3
   \                     ??TFTPRecv_6:
   \   000001E8   ........           DC32     `?<Constant "netascii">`
   \   000001EC   ........           DC32     TFTPDataRecv
    725              }
    726            }
    727          
    728            //
    729            // Free the pbuf.
    730            //
    731            pbuf_free(p);
    732          }
    733          
    734          //*****************************************************************************
    735          //
    736          //! Initializes the TFTP server module.
    737          //!
    738          //! \param pfnRequest - A pointer to the function which the server will call
    739          //! whenever a new incoming TFTP request is received.  This function must
    740          //! determine whether the request can be handled and return a value telling the
    741          //! server whether to continue processing the request or ignore it.
    742          //!
    743          //! This function initializes the lwIP TFTP server and starts listening for
    744          //! incoming requests from clients.  It must be called after the network stack
    745          //! is initialized using a call to lwIPInit().
    746          //!
    747          //! \return None.
    748          //
    749          //*****************************************************************************

   \                                 In segment CODE, align 4, keep-with-next
    750          void
    751          TFTPServerInit(tTFTPRequest pfnRequest)
    752          {
    753            void *pcb;
    754          
    755            //
    756            // Remember the application's notification callback.
    757            //
    758            g_pfnRequest = pfnRequest;
   \                     TFTPServerInit:
   \   00000000   ........           LDR      R1,??DataTable2  ;; g_pfnRequest
   \   00000004   10402DE9           PUSH     {R4,LR}
   \   00000008   000081E5           STR      R0,[R1, #+0]
    759          
    760            //
    761            // Start listening for incoming TFTP requests.
    762            //
    763            pcb = udp_new();
   \   0000000C   ........           _BLF     udp_new,??udp_new??rA
    764            udp_recv(pcb, TFTPRecv, NULL);
   \   00000010   20109FE5           LDR      R1,??TFTPServerInit_0  ;; TFTPRecv
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   0020A0E3           MOV      R2,#+0
   \   0000001C   ........           _BLF     udp_recv,??udp_recv??rA
    765            udp_bind(pcb, IP_ADDR_ANY, TFTP_PORT);
   \   00000020   14109FE5           LDR      R1,??TFTPServerInit_0+0x4  ;; ip_addr_any
   \   00000024   4520A0E3           MOV      R2,#+69
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           _BLF     udp_bind,??udp_bind??rA
    766          }
   \   00000030   1040BDE8           POP      {R4,LR}
   \   00000034   1EFF2FE1           BX       LR               ;; return
   \                     ??TFTPServerInit_0:
   \   00000038   ........           DC32     TFTPRecv
   \   0000003C   ........           DC32     ip_addr_any

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     g_pfnRequest

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "netascii">`:
   \   00000000   6E6574617363       DC8 "netascii"
   \              696900      
   \   00000009   000000             DC8 0, 0, 0
   \   0000000C   6F6374657400       DC8 "octet"
   \   00000012   0000               DC8 0, 0
   \   00000014   556E6B6E6F77       DC8 "Unknown error"
   \              6E206572726F
   \              7200        
   \   00000022   0000               DC8 0, 0
    767          
    768          //*****************************************************************************
    769          //
    770          // Close the Doxygen group.
    771          //! @}
    772          //
    773          //*****************************************************************************
    774          #endif

   Maximum stack usage in bytes:

     Function       CSTACK
     --------       ------
     TFTPClose          8
     TFTPDataRecv      24
     TFTPDataSend      16
     TFTPErrorSend     20
     TFTPRecv          40
     TFTPServerInit     8


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     g_pfnRequest             24
     TFTPClose               148
     TFTPErrorSend           132
     TFTPDataSend            192
     TFTPDataRecv            404
     TFTPRecv                496
     TFTPServerInit           64
     ??DataTable2              4
     ?<Constant "netascii">   36
      Others                 204

 
 1 632 bytes in segment CODE
    36 bytes in segment DATA_C
    24 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 1 440 bytes of CODE  memory (+ 204 bytes shared)
    36 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: none
