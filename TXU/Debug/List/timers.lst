##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:20:22 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\core\timers.c           #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\core\timers.c --fpu     #
#                       None -D OS_LIBMODE_SP -D CPU_S3C2410 -D              #
#                       OS_RAMVECT=0 -D OS_UART=-1 -D S2TXU -D USE_LZO=1 -D  #
#                       __ARM_LIBRARY__ -D WATCHDOG=1 -D NETWORK=1 -lCN      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\timers.lst                  #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\timers.r79                   #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\core\timers.c
      1          /**
      2           * @file
      3           * Stack-internal timers implementation.
      4           * This file includes timer callbacks for stack-internal timers as well as
      5           * functions to set up or stop timers and check for expired timers.
      6           *
      7           */
      8          
      9          /*
     10           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
     11           * All rights reserved.
     12           *
     13           * Redistribution and use in source and binary forms, with or without modification,
     14           * are permitted provided that the following conditions are met:
     15           *
     16           * 1. Redistributions of source code must retain the above copyright notice,
     17           *    this list of conditions and the following disclaimer.
     18           * 2. Redistributions in binary form must reproduce the above copyright notice,
     19           *    this list of conditions and the following disclaimer in the documentation
     20           *    and/or other materials provided with the distribution.
     21           * 3. The name of the author may not be used to endorse or promote products
     22           *    derived from this software without specific prior written permission.
     23           *
     24           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     25           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     26           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     27           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     28           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     29           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     30           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     31           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     32           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     33           * OF SUCH DAMAGE.
     34           *
     35           * This file is part of the lwIP TCP/IP stack.
     36           *
     37           * Author: Adam Dunkels <adam@sics.se>
     38           *         Simon Goldschmidt
     39           *
     40           */
     41          
     42          #include "lwip/opt.h"
     43          
     44          #include "lwip/timers.h"
     45          #include "lwip/tcp_impl.h"
     46          
     47          #if LWIP_TIMERS
     48          
     49          #include "lwip/def.h"
     50          #include "lwip/memp.h"
     51          #include "lwip/tcpip.h"
     52          
     53          #include "lwip/ip_frag.h"
     54          #include "netif/etharp.h"
     55          #include "lwip/dhcp.h"
     56          #include "lwip/autoip.h"
     57          #include "lwip/igmp.h"
     58          #include "lwip/dns.h"
     59          #include "lwip/sys.h"
     60          #include "lwip/pbuf.h"
     61          
     62          
     63          /** The one and only timeout list */

   \                                 In segment DATA_Z, align 4, align-sorted
     64          static struct sys_timeo *next_timeout;
   \                     next_timeout:
   \   00000000                      DS8 4
     65          #if NO_SYS
     66          static u32_t timeouts_last_time;
     67          #endif /* NO_SYS */
     68          
     69          #if LWIP_TCP
     70          /** global variable that shows if the tcp timer is currently scheduled or not */

   \                                 In segment DATA_Z, align 4, align-sorted
     71          static int tcpip_tcp_timer_active;
   \                     tcpip_tcp_timer_active:
   \   00000000                      DS8 4
     72          
     73          /**
     74           * Timer callback function that calls tcp_tmr() and reschedules itself.
     75           *
     76           * @param arg unused argument
     77           */

   \                                 In segment CODE, align 4, keep-with-next
     78          static void
     79          tcpip_tcp_timer(void *arg)
     80          {
   \                     tcpip_tcp_timer:
   \   00000000   00402DE9           PUSH     {LR}
     81            LWIP_UNUSED_ARG(arg);
     82          
     83            /* call TCP timer handler */
     84            tcp_tmr();
   \   00000004   ........           _BLF     tcp_tmr,??tcp_tmr??rA
     85            /* timer still needed? */
     86            if (tcp_active_pcbs || tcp_tw_pcbs) {
   \   00000008   ........           LDR      R0,??DataTable5  ;; tcp_active_pcbs
   \   0000000C   000090E5           LDR      R0,[R0, #+0]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0300001A           BNE      ??tcpip_tcp_timer_0
   \   00000018   ........           LDR      R0,??DataTable6  ;; tcp_tw_pcbs
   \   0000001C   000090E5           LDR      R0,[R0, #+0]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   0400000A           BEQ      ??tcpip_tcp_timer_1
     87              /* restart timer */
     88              sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
   \                     ??tcpip_tcp_timer_0:
   \   00000028   ........           LDR      R1,??DataTable7  ;; tcpip_tcp_timer
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   FA00A0E3           MOV      R0,#+250
   \   00000034   ........           BL       sys_timeout
   \   00000038   020000EA           B        ??tcpip_tcp_timer_2
     89            } else {
     90              /* disable timer */
     91              tcpip_tcp_timer_active = 0;
   \                     ??tcpip_tcp_timer_1:
   \   0000003C   ........           LDR      R0,??DataTable4  ;; tcpip_tcp_timer_active
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   001080E5           STR      R1,[R0, #+0]
     92            }
     93          }
   \                     ??tcpip_tcp_timer_2:
   \   00000048   0040BDE8           POP      {LR}
   \   0000004C   1EFF2FE1           BX       LR               ;; return
     94          
     95          /**
     96           * Called from TCP_REG when registering a new PCB:
     97           * the reason is to have the TCP timer only running when
     98           * there are active (or time-wait) PCBs.
     99           */

   \                                 In segment CODE, align 4, keep-with-next
    100          void
    101          tcp_timer_needed(void)
    102          {
    103            /* timer is off but needed again? */
    104            if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
   \                     tcp_timer_needed:
   \   00000000   ........           LDR      R0,??DataTable4  ;; tcpip_tcp_timer_active
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   001090E5           LDR      R1,[R0, #+0]
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   0D00001A           BNE      ??tcp_timer_needed_0
   \   00000014   ........           LDR      R1,??DataTable5  ;; tcp_active_pcbs
   \   00000018   001091E5           LDR      R1,[R1, #+0]
   \   0000001C   000051E3           CMP      R1,#+0
   \   00000020   0300001A           BNE      ??tcp_timer_needed_1
   \   00000024   ........           LDR      R1,??DataTable6  ;; tcp_tw_pcbs
   \   00000028   001091E5           LDR      R1,[R1, #+0]
   \   0000002C   000051E3           CMP      R1,#+0
   \   00000030   0500000A           BEQ      ??tcp_timer_needed_0
    105              /* enable and start timer */
    106              tcpip_tcp_timer_active = 1;
   \                     ??tcp_timer_needed_1:
   \   00000034   0110A0E3           MOV      R1,#+1
   \   00000038   001080E5           STR      R1,[R0, #+0]
    107              sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
   \   0000003C   ........           LDR      R1,??DataTable7  ;; tcpip_tcp_timer
   \   00000040   0020A0E3           MOV      R2,#+0
   \   00000044   FA00A0E3           MOV      R0,#+250
   \   00000048   ........           BL       sys_timeout
    108            }
    109          }
   \                     ??tcp_timer_needed_0:
   \   0000004C   0040BDE8           POP      {LR}
   \   00000050   1EFF2FE1           BX       LR               ;; return
    110          #endif /* LWIP_TCP */
    111          
    112          #if IP_REASSEMBLY
    113          /**
    114           * Timer callback function that calls ip_reass_tmr() and reschedules itself.
    115           *
    116           * @param arg unused argument
    117           */

   \                                 In segment CODE, align 4, keep-with-next
    118          static void
    119          ip_reass_timer(void *arg)
    120          {
   \                     ip_reass_timer:
   \   00000000   00402DE9           PUSH     {LR}
    121            LWIP_UNUSED_ARG(arg);
    122            LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
    123            ip_reass_tmr();
   \   00000004   ........           _BLF     ip_reass_tmr,??ip_reass_tmr??rA
    124            sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
   \   00000008   ........           LDR      R1,??DataTable10  ;; ip_reass_timer
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   FA0FA0E3           MOV      R0,#+1000
   \   00000014   ........           BL       sys_timeout
    125          }
   \   00000018   0040BDE8           POP      {LR}
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    126          #endif /* IP_REASSEMBLY */
    127          
    128          #if LWIP_ARP
    129          /**
    130           * Timer callback function that calls etharp_tmr() and reschedules itself.
    131           *
    132           * @param arg unused argument
    133           */

   \                                 In segment CODE, align 4, keep-with-next
    134          static void
    135          arp_timer(void *arg)
    136          {
   \                     arp_timer:
   \   00000000   00402DE9           PUSH     {LR}
    137            LWIP_UNUSED_ARG(arg);
    138            LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
    139            etharp_tmr();
   \   00000004   ........           _BLF     etharp_tmr,??etharp_tmr??rA
    140            sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
   \   00000008   ........           LDR      R1,??DataTable11  ;; arp_timer
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   8800A0E3           MOV      R0,#+136
   \   00000014   4C0D80E3           ORR      R0,R0,#0x1300
   \   00000018   ........           BL       sys_timeout
    141          }
   \   0000001C   0040BDE8           POP      {LR}
   \   00000020   1EFF2FE1           BX       LR               ;; return
    142          #endif /* LWIP_ARP */
    143          
    144          #if LWIP_DHCP
    145          /**
    146           * Timer callback function that calls dhcp_coarse_tmr() and reschedules itself.
    147           *
    148           * @param arg unused argument
    149           */
    150          static void
    151          dhcp_timer_coarse(void *arg)
    152          {
    153            LWIP_UNUSED_ARG(arg);
    154            LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
    155            dhcp_coarse_tmr();
    156            sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    157          }
    158          
    159          /**
    160           * Timer callback function that calls dhcp_fine_tmr() and reschedules itself.
    161           *
    162           * @param arg unused argument
    163           */
    164          static void
    165          dhcp_timer_fine(void *arg)
    166          {
    167            LWIP_UNUSED_ARG(arg);
    168            LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
    169            dhcp_fine_tmr();
    170            sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    171          }
    172          #endif /* LWIP_DHCP */
    173          
    174          #if LWIP_AUTOIP
    175          /**
    176           * Timer callback function that calls autoip_tmr() and reschedules itself.
    177           *
    178           * @param arg unused argument
    179           */
    180          static void
    181          autoip_timer(void *arg)
    182          {
    183            LWIP_UNUSED_ARG(arg);
    184            LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: autoip_tmr()\n"));
    185            autoip_tmr();
    186            sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
    187          }
    188          #endif /* LWIP_AUTOIP */
    189          
    190          #if LWIP_IGMP
    191          /**
    192           * Timer callback function that calls igmp_tmr() and reschedules itself.
    193           *
    194           * @param arg unused argument
    195           */
    196          static void
    197          igmp_timer(void *arg)
    198          {
    199            LWIP_UNUSED_ARG(arg);
    200            LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: igmp_tmr()\n"));
    201            igmp_tmr();
    202            sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
    203          }
    204          #endif /* LWIP_IGMP */
    205          
    206          #if LWIP_DNS
    207          /**
    208           * Timer callback function that calls dns_tmr() and reschedules itself.
    209           *
    210           * @param arg unused argument
    211           */
    212          static void
    213          dns_timer(void *arg)
    214          {
    215            LWIP_UNUSED_ARG(arg);
    216            LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dns_tmr()\n"));
    217            dns_tmr();
    218            sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
    219          }
    220          #endif /* LWIP_DNS */
    221          
    222          /** Initialize this module */

   \                                 In segment CODE, align 4, keep-with-next
    223          void sys_timeouts_init(void)
    224          {
    225          #if IP_REASSEMBLY
    226            sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
   \                     sys_timeouts_init:
   \   00000000   ........           LDR      R1,??DataTable10  ;; ip_reass_timer
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   0020A0E3           MOV      R2,#+0
   \   0000000C   FA0FA0E3           MOV      R0,#+1000
   \   00000010   ........           BL       sys_timeout
    227          #endif /* IP_REASSEMBLY */
    228          #if LWIP_ARP
    229            sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
   \   00000014   ........           LDR      R1,??DataTable11  ;; arp_timer
   \   00000018   0020A0E3           MOV      R2,#+0
   \   0000001C   8800A0E3           MOV      R0,#+136
   \   00000020   4C0D80E3           ORR      R0,R0,#0x1300
   \   00000024   ........           BL       sys_timeout
    230          #endif /* LWIP_ARP */
    231          #if LWIP_DHCP
    232            sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    233            sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    234          #endif /* LWIP_DHCP */
    235          #if LWIP_AUTOIP
    236            sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
    237          #endif /* LWIP_AUTOIP */
    238          #if LWIP_IGMP
    239            sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
    240          #endif /* LWIP_IGMP */
    241          #if LWIP_DNS
    242            sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
    243          #endif /* LWIP_DNS */
    244          
    245          #if NO_SYS
    246            /* Initialise timestamp for sys_check_timeouts */
    247            timeouts_last_time = sys_now();
    248          #endif
    249          }
   \   00000028   0040BDE8           POP      {LR}
   \   0000002C   1EFF2FE1           BX       LR               ;; return
    250          
    251          /**
    252           * Create a one-shot timer (aka timeout). Timeouts are processed in the
    253           * following cases:
    254           * - while waiting for a message using sys_timeouts_mbox_fetch()
    255           * - by calling sys_check_timeouts() (NO_SYS==1 only)
    256           *
    257           * @param msecs time in milliseconds after that the timer should expire
    258           * @param handler callback function to call when msecs have elapsed
    259           * @param arg argument to pass to the callback function
    260           */
    261          #if LWIP_DEBUG_TIMERNAMES
    262          void
    263          sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
    264          #else /* LWIP_DEBUG_TIMERNAMES */

   \                                 In segment CODE, align 4, keep-with-next
    265          void
    266          sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
    267          #endif /* LWIP_DEBUG_TIMERNAMES */
    268          {
   \                     sys_timeout:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    269            struct sys_timeo *timeout, *t;
    270          
    271            timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
   \   00000010   0B00A0E3           MOV      R0,#+11
   \   00000014   ........           _BLF     memp_malloc,??memp_malloc??rA
    272            if (timeout == NULL) {
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0F00000A           BEQ      ??sys_timeout_0
    273              LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    274              return;
    275            }
    276            timeout->next = NULL;
   \   00000020   0010A0E3           MOV      R1,#+0
   \   00000024   001080E5           STR      R1,[R0, #+0]
    277            timeout->h = handler;
    278            timeout->arg = arg;
    279            timeout->time = msecs;
    280          #if LWIP_DEBUG_TIMERNAMES
    281            timeout->handler_name = handler_name;
    282            LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    283              (void *)timeout, msecs, handler_name, (void *)arg));
    284          #endif /* LWIP_DEBUG_TIMERNAMES */
    285          
    286            if (next_timeout == NULL) {
   \   00000028   ........           LDR      R1,??DataTable14  ;; next_timeout
   \   0000002C   085080E5           STR      R5,[R0, #+8]
   \   00000030   0C6080E5           STR      R6,[R0, #+12]
   \   00000034   044080E5           STR      R4,[R0, #+4]
   \   00000038   002091E5           LDR      R2,[R1, #+0]
   \   0000003C   000052E3           CMP      R2,#+0
   \   00000040   0500000A           BEQ      ??sys_timeout_1
    287              next_timeout = timeout;
    288              return;
    289            }
    290          
    291            if (next_timeout->time > msecs) {
   \                     ??sys_timeout_2:
   \   00000044   043092E5           LDR      R3,[R2, #+4]
   \   00000048   030054E1           CMP      R4,R3
   \   0000004C   0600002A           BCS      ??sys_timeout_3
    292              next_timeout->time -= msecs;
   \   00000050   043043E0           SUB      R3,R3,R4
   \   00000054   043082E5           STR      R3,[R2, #+4]
    293              timeout->next = next_timeout;
   \   00000058   002080E5           STR      R2,[R0, #+0]
    294              next_timeout = timeout;
   \                     ??sys_timeout_1:
   \   0000005C   000081E5           STR      R0,[R1, #+0]
   \                     ??sys_timeout_0:
   \   00000060   7040BDE8           POP      {R4-R6,LR}
   \   00000064   1EFF2FE1           BX       LR
    295            } else {
    296              for(t = next_timeout; t != NULL; t = t->next) {
   \                     ??sys_timeout_4:
   \   00000068   0120A0E1           MOV      R2,R1
    297                timeout->time -= t->time;
   \                     ??sys_timeout_3:
   \   0000006C   041090E5           LDR      R1,[R0, #+4]
   \   00000070   043092E5           LDR      R3,[R2, #+4]
   \   00000074   033041E0           SUB      R3,R1,R3
   \   00000078   043080E5           STR      R3,[R0, #+4]
    298                if (t->next == NULL || t->next->time > timeout->time) {
   \   0000007C   001092E5           LDR      R1,[R2, #+0]
   \   00000080   000051E3           CMP      R1,#+0
   \   00000084   0200000A           BEQ      ??sys_timeout_5
   \   00000088   044091E5           LDR      R4,[R1, #+4]
   \   0000008C   040053E1           CMP      R3,R4
   \   00000090   F4FFFF2A           BCS      ??sys_timeout_4
    299                  if (t->next != NULL) {
   \                     ??sys_timeout_5:
   \   00000094   000051E3           CMP      R1,#+0
    300                    t->next->time -= timeout->time;
   \   00000098   04409115           LDRNE    R4,[R1, #+4]
   \   0000009C   03304410           SUBNE    R3,R4,R3
   \   000000A0   04308115           STRNE    R3,[R1, #+4]
    301                  }
    302                  timeout->next = t->next;
   \   000000A4   001080E5           STR      R1,[R0, #+0]
    303                  t->next = timeout;
   \   000000A8   000082E5           STR      R0,[R2, #+0]
    304                  break;
   \                     ??sys_timeout_6:
   \   000000AC   EBFFFFEA           B        ??sys_timeout_0
    305                }
    306              }
    307            }
    308          }
    309          
    310          /**
    311           * Go through timeout list (for this task only) and remove the first matching
    312           * entry, even though the timeout has not triggered yet.
    313           *
    314           * @note This function only works as expected if there is only one timeout
    315           * calling 'handler' in the list of timeouts.
    316           *
    317           * @param handler callback function that would be called by the timeout
    318           * @param arg callback argument that would be passed to handler
    319          */

   \                                 In segment CODE, align 4, keep-with-next
    320          void
    321          sys_untimeout(sys_timeout_handler handler, void *arg)
    322          {
    323            struct sys_timeo *prev_t, *t;
    324          
    325            if (next_timeout == NULL) {
   \                     sys_untimeout:
   \   00000000   ........           LDR      R3,??DataTable14  ;; next_timeout
   \   00000004   10402DE9           PUSH     {R4,LR}
   \   00000008   002093E5           LDR      R2,[R3, #+0]
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   1800000A           BEQ      ??sys_untimeout_0
    326              return;
    327            }
    328          
    329            for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
   \   00000014   00C0A0E3           MOV      R12,#+0
    330              if ((t->h == handler) && (t->arg == arg)) {
   \                     ??sys_untimeout_1:
   \   00000018   084092E5           LDR      R4,[R2, #+8]
   \   0000001C   000054E1           CMP      R4,R0
   \   00000020   0C409205           LDREQ    R4,[R2, #+12]
   \   00000024   01005401           CMPEQ    R4,R1
   \   00000028   0E00001A           BNE      ??sys_untimeout_2
    331                /* We have a match */
    332                /* Unlink from previous in list */
    333                if (prev_t == NULL) {
   \   0000002C   000092E5           LDR      R0,[R2, #+0]
   \   00000030   00005CE3           CMP      R12,#+0
    334                  next_timeout = t->next;
   \   00000034   00008305           STREQ    R0,[R3, #+0]
    335                } else {
    336                  prev_t->next = t->next;
   \   00000038   00008C15           STRNE    R0,[R12, #+0]
    337                }
    338                /* If not the last one, add time of this one back to next */
    339                if (t->next != NULL) {
   \   0000003C   000092E5           LDR      R0,[R2, #+0]
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0300000A           BEQ      ??sys_untimeout_3
    340                  t->next->time += t->time;
   \   00000048   041090E5           LDR      R1,[R0, #+4]
   \   0000004C   043092E5           LDR      R3,[R2, #+4]
   \   00000050   011083E0           ADD      R1,R3,R1
   \   00000054   041080E5           STR      R1,[R0, #+4]
    341                }
    342                memp_free(MEMP_SYS_TIMEOUT, t);
   \                     ??sys_untimeout_3:
   \   00000058   0210A0E1           MOV      R1,R2
   \   0000005C   0B00A0E3           MOV      R0,#+11
   \   00000060   ........           _BLF     memp_free,??memp_free??rA
    343                return;
   \   00000064   030000EA           B        ??sys_untimeout_0
    344              }
    345            }
   \                     ??sys_untimeout_2:
   \   00000068   02C0A0E1           MOV      R12,R2
   \   0000006C   002092E5           LDR      R2,[R2, #+0]
   \   00000070   000052E3           CMP      R2,#+0
   \   00000074   E7FFFF1A           BNE      ??sys_untimeout_1
   \                     ??sys_untimeout_0:
   \   00000078   1040BDE8           POP      {R4,LR}
   \   0000007C   1EFF2FE1           BX       LR               ;; return
    346            return;
    347          }
    348          
    349          #if NO_SYS
    350          
    351          /** Handle timeouts for NO_SYS==1 (i.e. without using
    352           * tcpip_thread/sys_timeouts_mbox_fetch(). Uses sys_now() to call timeout
    353           * handler functions when timeouts expire.
    354           *
    355           * Must be called periodically from your main loop.
    356           */
    357          void
    358          sys_check_timeouts(void)
    359          {
    360            if (next_timeout) {
    361              struct sys_timeo *tmptimeout;
    362              u32_t diff;
    363              sys_timeout_handler handler;
    364              void *arg;
    365              u8_t had_one;
    366              u32_t now;
    367          
    368              now = sys_now();
    369              /* this cares for wraparounds */
    370              diff = now - timeouts_last_time;
    371              do
    372              {
    373          #if PBUF_POOL_FREE_OOSEQ
    374                PBUF_CHECK_FREE_OOSEQ();
    375          #endif /* PBUF_POOL_FREE_OOSEQ */
    376                had_one = 0;
    377                tmptimeout = next_timeout;
    378                if (tmptimeout && (tmptimeout->time <= diff)) {
    379                  /* timeout has expired */
    380                  had_one = 1;
    381                  timeouts_last_time = now;
    382                  diff -= tmptimeout->time;
    383                  next_timeout = tmptimeout->next;
    384                  handler = tmptimeout->h;
    385                  arg = tmptimeout->arg;
    386          #if LWIP_DEBUG_TIMERNAMES
    387                  if (handler != NULL) {
    388                    LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s arg=%p\n",
    389                      tmptimeout->handler_name, arg));
    390                  }
    391          #endif /* LWIP_DEBUG_TIMERNAMES */
    392                  memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
    393                  if (handler != NULL) {
    394                    handler(arg);
    395                  }
    396                }
    397              /* repeat until all expired timers have been called */
    398              }while(had_one);
    399            }
    400          }
    401          
    402          /** Set back the timestamp of the last call to sys_check_timeouts()
    403           * This is necessary if sys_check_timeouts() hasn't been called for a long
    404           * time (e.g. while saving energy) to prevent all timer functions of that
    405           * period being called.
    406           */
    407          void
    408          sys_restart_timeouts(void)
    409          {
    410            timeouts_last_time = sys_now();
    411          }
    412          
    413          #else /* NO_SYS */
    414          
    415          /**
    416           * Wait (forever) for a message to arrive in an mbox.
    417           * While waiting, timeouts are processed.
    418           *
    419           * @param mbox the mbox to fetch the message from
    420           * @param msg the place to store the message
    421           */

   \                                 In segment CODE, align 4, keep-with-next
    422          void
    423          sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
    424          {
   \                     sys_timeouts_mbox_fetch:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   ........           LDR      R6,??DataTable14  ;; next_timeout
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0B0000EA           B        ??sys_timeouts_mbox_fetch_0
    425            u32_t time_needed;
    426            struct sys_timeo *tmptimeout;
    427            sys_timeout_handler handler;
    428            void *arg;
    429          
    430           again:
    431            if (!next_timeout) {
    432              time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    433            } else {
    434              if (next_timeout->time > 0) {
    435                time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    436              } else {
    437                time_needed = SYS_ARCH_TIMEOUT;
    438              }
    439          
    440              if (time_needed == SYS_ARCH_TIMEOUT) {
    441                /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
    442                   could be fetched. We should now call the timeout handler and
    443                   deallocate the memory allocated for the timeout. */
    444                tmptimeout = next_timeout;
   \                     ??sys_timeouts_mbox_fetch_1:
   \   00000014   001096E5           LDR      R1,[R6, #+0]
    445                next_timeout = tmptimeout->next;
   \   00000018   000091E5           LDR      R0,[R1, #+0]
   \   0000001C   000086E5           STR      R0,[R6, #+0]
    446                handler = tmptimeout->h;
   \   00000020   087091E5           LDR      R7,[R1, #+8]
    447                arg = tmptimeout->arg;
   \   00000024   0C8091E5           LDR      R8,[R1, #+12]
    448          #if LWIP_DEBUG_TIMERNAMES
    449                if (handler != NULL) {
    450                  LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
    451                    tmptimeout->handler_name, arg));
    452                }
    453          #endif /* LWIP_DEBUG_TIMERNAMES */
    454                memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
   \   00000028   0B00A0E3           MOV      R0,#+11
   \   0000002C   ........           _BLF     memp_free,??memp_free??rA
    455                if (handler != NULL) {
   \   00000030   000057E3           CMP      R7,#+0
   \   00000034   0200000A           BEQ      ??sys_timeouts_mbox_fetch_0
    456                  /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
    457                     timeout handler function. */
    458                  LOCK_TCPIP_CORE();
    459                  handler(arg);
   \   00000038   0800A0E1           MOV      R0,R8
   \   0000003C   0FE0A0E1           MOV      LR,PC
   \   00000040   17FF2FE1           BX       R7
    460                  UNLOCK_TCPIP_CORE();
    461                }
    462                LWIP_TCPIP_THREAD_ALIVE();
    463          
    464                /* We try again to fetch a message from the mbox. */
    465                goto again;
    466              } else {
   \                     ??sys_timeouts_mbox_fetch_0:
   \   00000044   000096E5           LDR      R0,[R6, #+0]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0400001A           BNE      ??sys_timeouts_mbox_fetch_2
   \   00000050   0020A0E3           MOV      R2,#+0
   \   00000054   0510A0E1           MOV      R1,R5
   \   00000058   0400A0E1           MOV      R0,R4
   \   0000005C   ........           _BLF     sys_arch_mbox_fetch,??sys_arch_mbox_fetch??rA
   \   00000060   0D0000EA           B        ??sys_timeouts_mbox_fetch_3
   \                     ??sys_timeouts_mbox_fetch_2:
   \   00000064   042090E5           LDR      R2,[R0, #+4]
   \   00000068   000052E3           CMP      R2,#+0
   \   0000006C   E8FFFF0A           BEQ      ??sys_timeouts_mbox_fetch_1
   \   00000070   0510A0E1           MOV      R1,R5
   \   00000074   0400A0E1           MOV      R0,R4
   \   00000078   ........           _BLF     sys_arch_mbox_fetch,??sys_arch_mbox_fetch??rA
   \   0000007C   010070E3           CMN      R0,#+1
   \   00000080   E3FFFF0A           BEQ      ??sys_timeouts_mbox_fetch_1
    467                /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
    468                   occured. The time variable is set to the number of
    469                   milliseconds we waited for the message. */
    470                if (time_needed < next_timeout->time) {
   \   00000084   001096E5           LDR      R1,[R6, #+0]
   \   00000088   042091E5           LDR      R2,[R1, #+4]
   \   0000008C   020050E1           CMP      R0,R2
    471                  next_timeout->time -= time_needed;
   \   00000090   00004230           SUBCC    R0,R2,R0
    472                } else {
    473                  next_timeout->time = 0;
   \   00000094   0000A023           MOVCS    R0,#+0
   \   00000098   040081E5           STR      R0,[R1, #+4]
    474                }
    475              }
    476            }
    477          }
   \                     ??sys_timeouts_mbox_fetch_3:
   \   0000009C   F041BDE8           POP      {R4-R8,LR}
   \   000000A0   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     tcpip_tcp_timer_active

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     tcp_active_pcbs

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     tcp_tw_pcbs

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     tcpip_tcp_timer

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     ip_reass_timer

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     arp_timer

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   ........           DC32     next_timeout
    478          
    479          #endif /* NO_SYS */
    480          
    481          #else /* LWIP_TIMERS */
    482          /* Satisfy the TCP code which calls this function */
    483          void
    484          tcp_timer_needed(void)
    485          {
    486          }
    487          #endif /* LWIP_TIMERS */
    488          

   Maximum stack usage in bytes:

     Function                CSTACK
     --------                ------
     arp_timer                   4
     ip_reass_timer              4
     sys_timeout                16
     sys_timeouts_init           4
     sys_timeouts_mbox_fetch    24
     sys_untimeout               8
     tcp_timer_needed            4
     tcpip_tcp_timer             4


   Segment part sizes:

     Function/Label          Bytes
     --------------          -----
     next_timeout               4
     tcpip_tcp_timer_active     4
     tcpip_tcp_timer           80
     tcp_timer_needed          84
     ip_reass_timer            32
     arp_timer                 36
     sys_timeouts_init         48
     sys_timeout              176
     sys_untimeout            128
     sys_timeouts_mbox_fetch  164
     ??DataTable4               4
     ??DataTable5               4
     ??DataTable6               4
     ??DataTable7               4
     ??DataTable10              4
     ??DataTable11              4
     ??DataTable14              4
      Others                  116

 
 880 bytes in segment CODE
   8 bytes in segment DATA_Z
  12 bytes in segment INITTAB
 
 776 bytes of CODE memory (+ 116 bytes shared)
   8 bytes of DATA memory

Errors: none
Warnings: none
