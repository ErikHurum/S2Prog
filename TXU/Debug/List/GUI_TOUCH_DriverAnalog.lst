##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               13/Sep/2016  09:48:28 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\VMShare\working\trunk\TXU\Config\GUI_TOUCH_Driver #
#                       Analog.c                                             #
#    Command line    =  E:\VMShare\working\trunk\TXU\Config\GUI_TOUCH_Driver #
#                       Analog.c --fpu None -D OS_LIBMODE_DT -D CPU_S3C2410  #
#                       -D OS_UART=-1 -D OS_SEGGER -D S2TXUBOOTLOADER -lCN   #
#                       E:\VMShare\working\trunk\TXU\Debug\List\ -o          #
#                       E:\VMShare\working\trunk\TXU\Debug\Obj\ -s2          #
#                       --no_cse --no_unroll --no_inline --no_code_motion    #
#                       --no_tbaa --no_clustering --no_scheduling --debug    #
#                       --cpu_mode arm --endian little --cpu ARM920T         #
#                       --stack_align 4 --interwork -e --eec++               #
#                       --dlib_config "C:\Program Files (x86)\IAR            #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl4tpainl8n.h" -I                        #
#                       E:\VMShare\working\trunk\TXU\INC\ -I                 #
#                       E:\VMShare\working\trunk\TXU\..\Shared\INC\ -I       #
#                       E:\VMShare\working\trunk\TXU\..\SHARED\SRC\ -I       #
#                       E:\VMShare\working\trunk\TXU\GUI\CORE\ -I            #
#                       E:\VMShare\working\trunk\TXU\GUI\WM\ -I              #
#                       E:\VMShare\working\trunk\TXU\GUI\WIDGET\ -I          #
#                       E:\VMShare\working\trunk\TXU\CONFIG\ -I "C:\Program  #
#                       Files (x86)\IAR Systems\Embedded Workbench           #
#                       4.0\arm\INC\"                                        #
#    List file       =  E:\VMShare\working\trunk\TXU\Debug\List\GUI_TOUCH_Dr #
#                       iverAnalog.lst                                       #
#    Object file     =  E:\VMShare\working\trunk\TXU\Debug\Obj\GUI_TOUCH_Dri #
#                       verAnalog.r79                                        #
#                                                                            #
#                                                                            #
##############################################################################

E:\VMShare\working\trunk\TXU\Config\GUI_TOUCH_DriverAnalog.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER SYSTEME GmbH                 *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          *                                                                    *
      6          *        (c) 1996 - 2006  SEGGER Microcontroller Systeme GmbH        *
      7          *                                                                    *
      8          *        Internet: www.segger.com    Support:  support@segger.com    *
      9          *                                                                    *
     10          **********************************************************************
     11          
     12          ** emWin V4.06 - Graphical user interface for embedded applications **
     13          emWin is protected by international copyright laws.   Knowledge of the
     14          source code may not be used to write a similar product.  This file may
     15          only be used in accordance with a license and should not be re-
     16          distributed in any way. We appreciate your understanding and fairness.
     17          ----------------------------------------------------------------------
     18          File        : GUITOUCH.C
     19          Purpose     : Touch screen manager
     20          ----------------------------------------------------------------------
     21          This module handles the touch screen. It is configured in the file
     22          GUITouch.conf.h (Should be located in the Config\ directory).
     23          ----------------------------------------------------------------------
     24          */
     25          
     26          #include <stdio.h>
     27          #include <stdlib.h>

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __intrinsic __code __interwork __atpcs int abs(int)
   \                     abs:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   0100005A           BPL      ??abs_0
   \   00000008   000070E2           RSBS     R0,R0,#+0
   \   0000000C   FFFFFFEA           B        ??abs_1
   \                     ??abs_0:
   \                     ??abs_1:
   \   00000010   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __intrinsic __code __interwork __atpcs long labs(long)
   \                     labs:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   0100005A           BPL      ??labs_0
   \   00000008   000070E2           RSBS     R0,R0,#+0
   \   0000000C   FFFFFFEA           B        ??labs_1
   \                     ??labs_0:
   \                     ??labs_1:
   \   00000010   1EFF2FE1           BX       LR               ;; return
     28          #include <string.h>
     29          #include "LCD_Private.h"      /* private modul definitions & config */
     30          //#include "GUI_Protected.h"
     31          #include "2410addr.h"       // inserted by TSN
     32          
     33          
     34          /////////////////////////////////////////////////////////
     35          //
     36          // From TXU_TROSINIT.c
     37          //
     38          /////////////////////////////////////////////////////////
     39          extern volatile unsigned char TouchKeyPressed ;	 //key status

   \                                 In segment DATA_Z, align 1, align-sorted
     40          unsigned volatile char PhysKeyPressed=0;
   \                     PhysKeyPressed:
   \   00000000                      DS8 1
     41          
     42          extern volatile U16  TXUADData[];
     43          
     44          /* Generate code only if configuration says so ! */
     45          #if GUI_SUPPORT_TOUCH
     46          
     47          	#include "GUITouchConf.h"    /* Located in GUIx, will include GUITouchConf.h */
     48          
     49          /*********************************************************************
     50          *
     51          *       Defines, config defaults
     52          *
     53          **********************************************************************
     54          */
     55          	#ifndef GUI_TOUCH_AD_MAX_DIFF
     56          		#define GUI_TOUCH_AD_MAX_DIFF 30
     57          	#endif
     58          	#ifndef GUI_TOUCH_AD_LEFT         /* max value returned by AD-converter */
     59          		#define GUI_TOUCH_AD_LEFT 30
     60          	#endif
     61          
     62          	#ifndef GUI_TOUCH_AD_RIGHT        /* min value returned by AD-converter */
     63          		#define GUI_TOUCH_AD_RIGHT 220
     64          	#endif
     65          
     66          	#ifndef GUI_TOUCH_AD_TOP          /* max value returned by AD-converter */
     67          		#define GUI_TOUCH_AD_TOP 30
     68          	#endif
     69          
     70          	#ifndef GUI_TOUCH_AD_BOTTOM       /* min value returned by AD-converter */
     71          		#define GUI_TOUCH_AD_BOTTOM 220
     72          	#endif
     73          
     74          	#ifndef GUI_TOUCH_SWAP_XY         /* Is XY of touch swapped ? */
     75          		#define GUI_TOUCH_SWAP_XY 0
     76          	#endif
     77          
     78          	#ifndef GUI_TOUCH_MIRROR_X
     79          		#define GUI_TOUCH_MIRROR_X 0
     80          	#endif
     81          
     82          	#ifndef GUI_TOUCH_MIRROR_Y
     83          		#define GUI_TOUCH_MIRROR_Y 0
     84          	#endif
     85          
     86          	#ifndef GUI_TOUCH_YSIZE
     87          		#define GUI_TOUCH_YSIZE LCD_YSIZE
     88          	#endif
     89          
     90          	#ifndef GUI_TOUCH_XSIZE
     91          		#define GUI_TOUCH_XSIZE LCD_XSIZE
     92          	#endif
     93          
     94          /*********************************************************************
     95          *
     96          *       Types
     97          *
     98          **********************************************************************
     99          */
    100          
    101          typedef struct {
    102          	int Min; int Max;
    103          } tMinMax;
    104          
    105          /*********************************************************************
    106          *
    107          *       Static data
    108          *
    109          **********************************************************************
    110          */
    111          

   \                                 In segment DATA_Z, align 4, align-sorted
    112          static int xPhys, yPhys;
   \                     xPhys:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     yPhys:
   \   00000000                      DS8 4
    113          

   \                                 In segment DATA_I, align 4, align-sorted
    114          static tMinMax xyMinMax[2] = {
   \                     xyMinMax:
   \   00000000                      DS8 16
   \   00000010                      REQUIRE `?<Initializer for xyMinMax>`
    115          #if ((GUI_TOUCH_SWAP_XY==0) && (GUI_TOUCH_MIRROR_X==0)) || ((GUI_TOUCH_SWAP_XY) && (GUI_TOUCH_MIRROR_Y==0))
    116          	{ GUI_TOUCH_AD_LEFT, GUI_TOUCH_AD_RIGHT},
    117          #else
    118          	{ GUI_TOUCH_AD_RIGHT, GUI_TOUCH_AD_LEFT},
    119          #endif
    120          #if ((GUI_TOUCH_SWAP_XY==0) && (GUI_TOUCH_MIRROR_Y==0)) || ((GUI_TOUCH_SWAP_XY) && (GUI_TOUCH_MIRROR_X==0))
    121          	{ GUI_TOUCH_AD_TOP,  GUI_TOUCH_AD_BOTTOM}
    122          #else
    123          	{ GUI_TOUCH_AD_BOTTOM,  GUI_TOUCH_AD_TOP}
    124          #endif
    125          };

   \                                 In segment DATA_I, align 4, align-sorted
    126          static tMinMax xyMinMaxDefault[2] = {
   \                     xyMinMaxDefault:
   \   00000000                      DS8 16
   \   00000010                      REQUIRE `?<Initializer for xyMinMaxDefault>`
    127          #if ((GUI_TOUCH_SWAP_XY==0) && (GUI_TOUCH_MIRROR_X==0)) || ((GUI_TOUCH_SWAP_XY) && (GUI_TOUCH_MIRROR_Y==0))
    128          	{ GUI_TOUCH_AD_LEFT, GUI_TOUCH_AD_RIGHT},
    129          #else
    130          	{ GUI_TOUCH_AD_RIGHT, GUI_TOUCH_AD_LEFT},
    131          #endif
    132          #if ((GUI_TOUCH_SWAP_XY==0) && (GUI_TOUCH_MIRROR_Y==0)) || ((GUI_TOUCH_SWAP_XY) && (GUI_TOUCH_MIRROR_X==0))
    133          	{ GUI_TOUCH_AD_TOP,  GUI_TOUCH_AD_BOTTOM}
    134          #else
    135          	{ GUI_TOUCH_AD_BOTTOM,  GUI_TOUCH_AD_TOP}
    136          #endif
    137          };
    138          
    139          
    140          	#ifndef WIN32

   \                                 In segment DATA_Z, align 4, align-sorted
    141          static int xMin;
   \                     xMin:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
    142          static int xMax;
   \                     xMax:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
    143          static int yMin;
   \                     yMin:
   \   00000000                      DS8 4

   \                                 In segment DATA_Z, align 4, align-sorted
    144          static int yMax;
   \                     yMax:
   \   00000000                      DS8 4
    145          	#endif
    146          
    147          /*********************************************************************
    148          *
    149          *       Static code
    150          *
    151          **********************************************************************
    152          */
    153          /*********************************************************************
    154          *
    155          *       _AD2X
    156          *
    157          * Purpose:
    158          *   Convert physical value into (logical) coordinates.
    159          */
    160          	#ifndef WIN32

   \                                 In segment CODE, align 4, keep-with-next
    161          static int _AD2X(int adx) {
   \                     ??_AD2X:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0020B0E1           MOVS     R2,R0
    162          	I32 r = adx - xyMinMax[GUI_COORD_X].Min;
   \   00000008   ........           LDR      R1,??DataTable27  ;; xyMinMax
   \   0000000C   001091E5           LDR      R1,[R1, #+0]
   \   00000010   011052E0           SUBS     R1,R2,R1
   \   00000014   0100B0E1           MOVS     R0,R1
    163          	r *= GUI_TOUCH_XSIZE - 1;
   \   00000018   3F10A0E3           MOV      R1,#+63
   \   0000001C   401F81E3           ORR      R1,R1,#0x100
   \   00000020   910010E0           MULS     R0,R1,R0
    164          	return r / (xyMinMax[GUI_COORD_X].Max - xyMinMax[GUI_COORD_X].Min);
   \   00000024   ........           LDR      R1,??DataTable28  ;; xyMinMax + 4
   \   00000028   001091E5           LDR      R1,[R1, #+0]
   \   0000002C   ........           LDR      R3,??DataTable27  ;; xyMinMax
   \   00000030   003093E5           LDR      R3,[R3, #+0]
   \   00000034   031051E0           SUBS     R1,R1,R3
   \   00000038   ........           _BLF     ??div32_a,??rA??div32_a
   \   0000003C   0100B0E1           MOVS     R0,R1
   \   00000040   0040BDE8           POP      {LR}
   \   00000044   1EFF2FE1           BX       LR               ;; return
    165          }
    166          
    167          /*********************************************************************
    168          *
    169          *       _AD2Y
    170          *
    171          * Purpose:
    172          *   Convert physical value into (logical) coordinates.
    173          */

   \                                 In segment CODE, align 4, keep-with-next
    174          static int _AD2Y(int ady) {
   \                     ??_AD2Y:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0020B0E1           MOVS     R2,R0
    175          	I32 r = ady - xyMinMax[GUI_COORD_Y].Min;
   \   00000008   ........           LDR      R1,??DataTable33  ;; xyMinMax + 8
   \   0000000C   001091E5           LDR      R1,[R1, #+0]
   \   00000010   011052E0           SUBS     R1,R2,R1
   \   00000014   0100B0E1           MOVS     R0,R1
    176          	r *= GUI_TOUCH_YSIZE - 1;
   \   00000018   EF10A0E3           MOV      R1,#+239
   \   0000001C   910010E0           MULS     R0,R1,R0
    177          	return r/(xyMinMax[GUI_COORD_Y].Max - xyMinMax[GUI_COORD_Y].Min);
   \   00000020   ........           LDR      R1,??DataTable34  ;; xyMinMax + 12
   \   00000024   001091E5           LDR      R1,[R1, #+0]
   \   00000028   ........           LDR      R3,??DataTable33  ;; xyMinMax + 8
   \   0000002C   003093E5           LDR      R3,[R3, #+0]
   \   00000030   031051E0           SUBS     R1,R1,R3
   \   00000034   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000038   0100B0E1           MOVS     R0,R1
   \   0000003C   0040BDE8           POP      {LR}
   \   00000040   1EFF2FE1           BX       LR               ;; return
    178          }
    179          	#endif
    180          
    181          /*********************************************************************
    182          *
    183          *       _Log2Phys
    184          */

   \                                 In segment CODE, align 4, keep-with-next
    185          static int _Log2Phys(int l, I32 l0, I32 l1, I32 p0, I32 p1) {
   \                     ??_Log2Phys:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   08C09DE5           LDR      R12,[SP, #+8]
    186          	return p0+ ((p1 - p0) * (l - l0)) / (l1 - l0);
   \   00000008   03C05CE0           SUBS     R12,R12,R3
   \   0000000C   014050E0           SUBS     R4,R0,R1
   \   00000010   940C10E0           MULS     R0,R4,R12
   \   00000014   011052E0           SUBS     R1,R2,R1
   \   00000018   ........           _BLF     ??div32_a,??rA??div32_a
   \   0000001C   030091E0           ADDS     R0,R1,R3
   \   00000020   1040BDE8           POP      {R4,LR}
   \   00000024   1EFF2FE1           BX       LR               ;; return
    187          }
    188          
    189          /*********************************************************************
    190          *
    191          *       Public code
    192          *
    193          **********************************************************************
    194          */
    195          /*********************************************************************
    196          *
    197          *       GUI_TOUCH_GetxPhys
    198          */

   \                                 In segment CODE, align 4, keep-with-next
    199          int  GUI_TOUCH_GetxPhys(void) {
    200          	return xPhys;
   \                     GUI_TOUCH_GetxPhys:
   \   00000000   ........           LDR      R0,??DataTable39  ;; xPhys
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    201          }
    202          
    203          /*********************************************************************
    204          *
    205          *       GUI_TOUCH_GetyPhys
    206          */

   \                                 In segment CODE, align 4, keep-with-next
    207          int  GUI_TOUCH_GetyPhys(void) {
    208          	return yPhys;
   \                     GUI_TOUCH_GetyPhys:
   \   00000000   ........           LDR      R0,??DataTable40  ;; yPhys
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    209          }
    210          
    211          /*********************************************************************
    212          *
    213          *       GUI_TOUCH_SetDefaultCalibration
    214          */

   \                                 In segment CODE, align 4, keep-with-next
    215          void GUI_TOUCH_SetDefaultCalibration(void) {
    216          	xyMinMax[0].Min = xyMinMaxDefault[0].Min;
   \                     GUI_TOUCH_SetDefaultCalibration:
   \   00000000   ........           LDR      R0,??DataTable27  ;; xyMinMax
   \   00000004   ........           LDR      R1,??DataTable20  ;; xyMinMaxDefault
   \   00000008   001091E5           LDR      R1,[R1, #+0]
   \   0000000C   001080E5           STR      R1,[R0, #+0]
    217          	xyMinMax[0].Max = xyMinMaxDefault[0].Max;
   \   00000010   ........           LDR      R0,??DataTable28  ;; xyMinMax + 4
   \   00000014   28109FE5           LDR      R1,??GUI_TOUCH_SetDefaultCalibration_0  ;; xyMinMaxDefault + 4
   \   00000018   001091E5           LDR      R1,[R1, #+0]
   \   0000001C   001080E5           STR      R1,[R0, #+0]
    218          	xyMinMax[1].Min = xyMinMaxDefault[1].Min;
   \   00000020   ........           LDR      R0,??DataTable33  ;; xyMinMax + 8
   \   00000024   1C109FE5           LDR      R1,??GUI_TOUCH_SetDefaultCalibration_0+0x4  ;; xyMinMaxDefault + 8
   \   00000028   001091E5           LDR      R1,[R1, #+0]
   \   0000002C   001080E5           STR      R1,[R0, #+0]
    219          	xyMinMax[1].Max = xyMinMaxDefault[1].Max;
   \   00000030   ........           LDR      R0,??DataTable34  ;; xyMinMax + 12
   \   00000034   10109FE5           LDR      R1,??GUI_TOUCH_SetDefaultCalibration_0+0x8  ;; xyMinMaxDefault + 12
   \   00000038   001091E5           LDR      R1,[R1, #+0]
   \   0000003C   001080E5           STR      R1,[R0, #+0]
    220          }
   \   00000040   1EFF2FE1           BX       LR               ;; return
   \                     ??GUI_TOUCH_SetDefaultCalibration_0:
   \   00000044   ........           DC32     xyMinMaxDefault + 4
   \   00000048   ........           DC32     xyMinMaxDefault + 8
   \   0000004C   ........           DC32     xyMinMaxDefault + 12
    221          
    222          /*********************************************************************
    223          *
    224          *       GUI_TOUCH_Calibrate
    225          */

   \                                 In segment CODE, align 4, keep-with-next
    226          int GUI_TOUCH_Calibrate(int Coord, int Log0, int Log1, int Phys0, int Phys1) {
   \                     GUI_TOUCH_Calibrate:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
   \   00000010   0370B0E1           MOVS     R7,R3
   \   00000014   20809DE5           LDR      R8,[SP, #+32]
    227          	int l0 = 0;
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   0090B0E1           MOVS     R9,R0
    228          	int l1 = (Coord == GUI_COORD_X) ? LCD_XSIZE - 1 : LCD_YSIZE - 1;
   \   00000020   000054E3           CMP      R4,#+0
   \   00000024   0200001A           BNE      ??GUI_TOUCH_Calibrate_0
   \   00000028   3FA0A0E3           MOV      R10,#+63
   \   0000002C   40AF8AE3           ORR      R10,R10,#0x100
   \   00000030   000000EA           B        ??GUI_TOUCH_Calibrate_1
   \                     ??GUI_TOUCH_Calibrate_0:
   \   00000034   EFA0A0E3           MOV      R10,#+239
    229          	if (labs(Phys0 - Phys1) < 20) {
   \                     ??GUI_TOUCH_Calibrate_1:
   \   00000038   080057E0           SUBS     R0,R7,R8
   \   0000003C   ........           _BLF     labs,??labs??rA
   \   00000040   140050E3           CMP      R0,#+20
   \   00000044   010000AA           BGE      ??GUI_TOUCH_Calibrate_2
    230          		return 1;
   \   00000048   0100A0E3           MOV      R0,#+1
   \   0000004C   1E0000EA           B        ??GUI_TOUCH_Calibrate_3
    231          	}
    232          	if (labs(Log0 - Log1) < 20) {
   \                     ??GUI_TOUCH_Calibrate_2:
   \   00000050   060055E0           SUBS     R0,R5,R6
   \   00000054   ........           _BLF     labs,??labs??rA
   \   00000058   140050E3           CMP      R0,#+20
   \   0000005C   010000AA           BGE      ??GUI_TOUCH_Calibrate_4
    233          		return 1;
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   180000EA           B        ??GUI_TOUCH_Calibrate_3
    234          	}
    235          	xyMinMax[Coord].Min = _Log2Phys(l0, Log0, Log1, Phys0, Phys1);
   \                     ??GUI_TOUCH_Calibrate_4:
   \   00000068   0800B0E1           MOVS     R0,R8
   \   0000006C   01002DE9           PUSH     {R0}
   \   00000070   0730B0E1           MOVS     R3,R7
   \   00000074   0620B0E1           MOVS     R2,R6
   \   00000078   0510B0E1           MOVS     R1,R5
   \   0000007C   0900B0E1           MOVS     R0,R9
   \   00000080   ........           BL       ??_Log2Phys
   \   00000084   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   00000088   0810A0E3           MOV      R1,#+8
   \   0000008C   ........           LDR      R2,??DataTable27  ;; xyMinMax
   \   00000090   912422E0           MLA      R2,R1,R4,R2
   \   00000094   000082E5           STR      R0,[R2, #+0]
    236          	xyMinMax[Coord].Max = _Log2Phys(l1, Log0, Log1, Phys0, Phys1);
   \   00000098   0800B0E1           MOVS     R0,R8
   \   0000009C   01002DE9           PUSH     {R0}
   \   000000A0   0730B0E1           MOVS     R3,R7
   \   000000A4   0620B0E1           MOVS     R2,R6
   \   000000A8   0510B0E1           MOVS     R1,R5
   \   000000AC   0A00B0E1           MOVS     R0,R10
   \   000000B0   ........           BL       ??_Log2Phys
   \   000000B4   04D08DE2           ADD      SP,SP,#+4        ;; stack cleaning
   \   000000B8   0810A0E3           MOV      R1,#+8
   \   000000BC   ........           LDR      R2,??DataTable27  ;; xyMinMax
   \   000000C0   912422E0           MLA      R2,R1,R4,R2
   \   000000C4   040082E5           STR      R0,[R2, #+4]
    237          	return 0;
   \   000000C8   0000A0E3           MOV      R0,#+0
   \                     ??GUI_TOUCH_Calibrate_3:
   \   000000CC   F047BDE8           POP      {R4-R10,LR}
   \   000000D0   1EFF2FE1           BX       LR               ;; return
    238          }
    239          
    240          /*********************************************************************
    241          *
    242          *       GUI_TOUCH_GetCalData
    243          */

   \                                 In segment CODE, align 4, keep-with-next
    244          void GUI_TOUCH_GetCalData(int Coord, int* pMin,int* pMax) {
    245          	*pMin = xyMinMax[Coord].Min;
   \                     GUI_TOUCH_GetCalData:
   \   00000000   0830A0E3           MOV      R3,#+8
   \   00000004   ........           LDR      R12,??DataTable27  ;; xyMinMax
   \   00000008   93C02CE0           MLA      R12,R3,R0,R12
   \   0000000C   00309CE5           LDR      R3,[R12, #+0]
   \   00000010   003081E5           STR      R3,[R1, #+0]
    246          	*pMax = xyMinMax[Coord].Max;
   \   00000014   0830A0E3           MOV      R3,#+8
   \   00000018   ........           LDR      R12,??DataTable27  ;; xyMinMax
   \   0000001C   93C02CE0           MLA      R12,R3,R0,R12
   \   00000020   04309CE5           LDR      R3,[R12, #+4]
   \   00000024   003082E5           STR      R3,[R2, #+0]
    247          }
   \   00000028   1EFF2FE1           BX       LR               ;; return
    248          
    249          /*********************************************************************
    250          *
    251          *       GUI_TOUCH_SetCalData
    252          */

   \                                 In segment CODE, align 4, keep-with-next
    253          void GUI_TOUCH_SetCalData(int Coord, int pMin,int pMax) {
   \                     GUI_TOUCH_SetCalData:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
    254          	if ( abs(pMin - xyMinMaxDefault[Coord].Min)> GUI_TOUCH_AD_MAX_DIFF ) {
   \   00000010   0800A0E3           MOV      R0,#+8
   \   00000014   ........           LDR      R1,??DataTable20  ;; xyMinMaxDefault
   \   00000018   901421E0           MLA      R1,R0,R4,R1
   \   0000001C   000091E5           LDR      R0,[R1, #+0]
   \   00000020   000055E0           SUBS     R0,R5,R0
   \   00000024   ........           _BLF     abs,??abs??rA
   \   00000028   1F0050E3           CMP      R0,#+31
   \   0000002C   040000BA           BLT      ??GUI_TOUCH_SetCalData_0
    255          	   pMin = xyMinMaxDefault[Coord].Min;
   \   00000030   0800A0E3           MOV      R0,#+8
   \   00000034   ........           LDR      R1,??DataTable20  ;; xyMinMaxDefault
   \   00000038   901421E0           MLA      R1,R0,R4,R1
   \   0000003C   000091E5           LDR      R0,[R1, #+0]
   \   00000040   0050B0E1           MOVS     R5,R0
    256          	}
    257          	if ( abs(pMax - xyMinMaxDefault[Coord].Max)> GUI_TOUCH_AD_MAX_DIFF ) {
   \                     ??GUI_TOUCH_SetCalData_0:
   \   00000044   0800A0E3           MOV      R0,#+8
   \   00000048   ........           LDR      R1,??DataTable20  ;; xyMinMaxDefault
   \   0000004C   901421E0           MLA      R1,R0,R4,R1
   \   00000050   040091E5           LDR      R0,[R1, #+4]
   \   00000054   000056E0           SUBS     R0,R6,R0
   \   00000058   ........           _BLF     abs,??abs??rA
   \   0000005C   1F0050E3           CMP      R0,#+31
   \   00000060   040000BA           BLT      ??GUI_TOUCH_SetCalData_1
    258          	   pMax = xyMinMaxDefault[Coord].Max;
   \   00000064   0800A0E3           MOV      R0,#+8
   \   00000068   ........           LDR      R1,??DataTable20  ;; xyMinMaxDefault
   \   0000006C   901421E0           MLA      R1,R0,R4,R1
   \   00000070   040091E5           LDR      R0,[R1, #+4]
   \   00000074   0060B0E1           MOVS     R6,R0
    259          	}
    260          	xyMinMax[Coord].Min =pMin;
   \                     ??GUI_TOUCH_SetCalData_1:
   \   00000078   0800A0E3           MOV      R0,#+8
   \   0000007C   ........           LDR      R1,??DataTable27  ;; xyMinMax
   \   00000080   901421E0           MLA      R1,R0,R4,R1
   \   00000084   005081E5           STR      R5,[R1, #+0]
    261          	xyMinMax[Coord].Max =pMax;
   \   00000088   0800A0E3           MOV      R0,#+8
   \   0000008C   ........           LDR      R1,??DataTable27  ;; xyMinMax
   \   00000090   901421E0           MLA      R1,R0,R4,R1
   \   00000094   046081E5           STR      R6,[R1, #+4]
    262          }
   \   00000098   7040BDE8           POP      {R4-R6,LR}
   \   0000009C   1EFF2FE1           BX       LR               ;; return
    263          
    264          /*********************************************************************
    265          *
    266          *       GUI_TOUCH_Exec
    267          */

   \                                 In segment CODE, align 4, keep-with-next
    268          void GUI_TOUCH_Exec(void) {
   \                     GUI_TOUCH_Exec:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    269          #ifndef WIN32
    270          	int x,y;
    271          	/* calculate Min / Max values */
    272          	if ( xyMinMax[GUI_COORD_X].Min < xyMinMax[GUI_COORD_X].Max ) {
   \   00000004   ........           LDR      R0,??DataTable27  ;; xyMinMax
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   ........           LDR      R1,??DataTable28  ;; xyMinMax + 4
   \   00000010   001091E5           LDR      R1,[R1, #+0]
   \   00000014   010050E1           CMP      R0,R1
   \   00000018   080000AA           BGE      ??GUI_TOUCH_Exec_0
    273          		xMin = xyMinMax[GUI_COORD_X].Min;
   \   0000001C   CC019FE5           LDR      R0,??GUI_TOUCH_Exec_1  ;; xMin
   \   00000020   ........           LDR      R1,??DataTable27  ;; xyMinMax
   \   00000024   001091E5           LDR      R1,[R1, #+0]
   \   00000028   001080E5           STR      R1,[R0, #+0]
    274          		xMax = xyMinMax[GUI_COORD_X].Max;
   \   0000002C   C0019FE5           LDR      R0,??GUI_TOUCH_Exec_1+0x4  ;; xMax
   \   00000030   ........           LDR      R1,??DataTable28  ;; xyMinMax + 4
   \   00000034   001091E5           LDR      R1,[R1, #+0]
   \   00000038   001080E5           STR      R1,[R0, #+0]
   \   0000003C   070000EA           B        ??GUI_TOUCH_Exec_2
    275          	} else {
    276          		xMax = xyMinMax[GUI_COORD_X].Min;
   \                     ??GUI_TOUCH_Exec_0:
   \   00000040   AC019FE5           LDR      R0,??GUI_TOUCH_Exec_1+0x4  ;; xMax
   \   00000044   ........           LDR      R1,??DataTable27  ;; xyMinMax
   \   00000048   001091E5           LDR      R1,[R1, #+0]
   \   0000004C   001080E5           STR      R1,[R0, #+0]
    277          		xMin = xyMinMax[GUI_COORD_X].Max;
   \   00000050   98019FE5           LDR      R0,??GUI_TOUCH_Exec_1  ;; xMin
   \   00000054   ........           LDR      R1,??DataTable28  ;; xyMinMax + 4
   \   00000058   001091E5           LDR      R1,[R1, #+0]
   \   0000005C   001080E5           STR      R1,[R0, #+0]
    278          	}
    279          	if ( xyMinMax[GUI_COORD_Y].Min < xyMinMax[GUI_COORD_Y].Max ) {
   \                     ??GUI_TOUCH_Exec_2:
   \   00000060   ........           LDR      R0,??DataTable33  ;; xyMinMax + 8
   \   00000064   000090E5           LDR      R0,[R0, #+0]
   \   00000068   ........           LDR      R1,??DataTable34  ;; xyMinMax + 12
   \   0000006C   001091E5           LDR      R1,[R1, #+0]
   \   00000070   010050E1           CMP      R0,R1
   \   00000074   080000AA           BGE      ??GUI_TOUCH_Exec_3
    280          		yMin = xyMinMax[GUI_COORD_Y].Min;
   \   00000078   78019FE5           LDR      R0,??GUI_TOUCH_Exec_1+0x8  ;; yMin
   \   0000007C   ........           LDR      R1,??DataTable33  ;; xyMinMax + 8
   \   00000080   001091E5           LDR      R1,[R1, #+0]
   \   00000084   001080E5           STR      R1,[R0, #+0]
    281          		yMax = xyMinMax[GUI_COORD_Y].Max;
   \   00000088   6C019FE5           LDR      R0,??GUI_TOUCH_Exec_1+0xC  ;; yMax
   \   0000008C   ........           LDR      R1,??DataTable34  ;; xyMinMax + 12
   \   00000090   001091E5           LDR      R1,[R1, #+0]
   \   00000094   001080E5           STR      R1,[R0, #+0]
   \   00000098   070000EA           B        ??GUI_TOUCH_Exec_4
    282          	} else {
    283          		yMax = xyMinMax[GUI_COORD_Y].Min;
   \                     ??GUI_TOUCH_Exec_3:
   \   0000009C   58019FE5           LDR      R0,??GUI_TOUCH_Exec_1+0xC  ;; yMax
   \   000000A0   ........           LDR      R1,??DataTable33  ;; xyMinMax + 8
   \   000000A4   001091E5           LDR      R1,[R1, #+0]
   \   000000A8   001080E5           STR      R1,[R0, #+0]
    284          		yMin = xyMinMax[GUI_COORD_Y].Max;
   \   000000AC   44019FE5           LDR      R0,??GUI_TOUCH_Exec_1+0x8  ;; yMin
   \   000000B0   ........           LDR      R1,??DataTable34  ;; xyMinMax + 12
   \   000000B4   001091E5           LDR      R1,[R1, #+0]
   \   000000B8   001080E5           STR      R1,[R0, #+0]
    285          	}
    286          	if ( !TouchKeyPressed ) {		 // touched release (finger off)
   \                     ??GUI_TOUCH_Exec_4:
   \   000000BC   3C019FE5           LDR      R0,??GUI_TOUCH_Exec_1+0x10  ;; TouchKeyPressed
   \   000000C0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   0600001A           BNE      ??GUI_TOUCH_Exec_5
    287          		xPhys = -1 ;	// Was 0
   \   000000CC   ........           LDR      R0,??DataTable39  ;; xPhys
   \   000000D0   0010E0E3           MVN      R1,#+0
   \   000000D4   001080E5           STR      R1,[R0, #+0]
    288          		yPhys = -1 ;
   \   000000D8   ........           LDR      R0,??DataTable40  ;; yPhys
   \   000000DC   0010E0E3           MVN      R1,#+0
   \   000000E0   001080E5           STR      R1,[R0, #+0]
   \   000000E4   0A0000EA           B        ??GUI_TOUCH_Exec_6
    289          	} else {
    290          		xPhys = TXUADData[7] ; // XP
   \                     ??GUI_TOUCH_Exec_5:
   \   000000E8   ........           LDR      R0,??DataTable39  ;; xPhys
   \   000000EC   10119FE5           LDR      R1,??GUI_TOUCH_Exec_1+0x14  ;; TXUADData + 14
   \   000000F0   B010D1E1           LDRH     R1,[R1, #+0]
   \   000000F4   001080E5           STR      R1,[R0, #+0]
    291          		yPhys = TXUADData[5] ; // YP
   \   000000F8   ........           LDR      R0,??DataTable40  ;; yPhys
   \   000000FC   04119FE5           LDR      R1,??GUI_TOUCH_Exec_1+0x18  ;; TXUADData + 10
   \   00000100   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000104   001080E5           STR      R1,[R0, #+0]
    292          		PhysKeyPressed = 0xff;
   \   00000108   FC009FE5           LDR      R0,??GUI_TOUCH_Exec_1+0x1C  ;; PhysKeyPressed
   \   0000010C   FF10A0E3           MOV      R1,#+255
   \   00000110   0010C0E5           STRB     R1,[R0, #+0]
    293          	}
    294          	/* Convert values into logical values */
    295          #if !GUI_TOUCH_SWAP_XY   /* Is X/Y swapped ? */
    296          	x = xPhys;
   \                     ??GUI_TOUCH_Exec_6:
   \   00000114   ........           LDR      R0,??DataTable39  ;; xPhys
   \   00000118   000090E5           LDR      R0,[R0, #+0]
   \   0000011C   0040B0E1           MOVS     R4,R0
    297          	y = yPhys;
   \   00000120   ........           LDR      R0,??DataTable40  ;; yPhys
   \   00000124   000090E5           LDR      R0,[R0, #+0]
   \   00000128   0050B0E1           MOVS     R5,R0
    298          #else
    299          	x = yPhys;
    300          	y = xPhys;
    301          #endif
    302          
    303          	if ( (x <xMin) | (x>xMax)  | (y <yMin) | (y>yMax) ) {
   \   0000012C   BC009FE5           LDR      R0,??GUI_TOUCH_Exec_1  ;; xMin
   \   00000130   000090E5           LDR      R0,[R0, #+0]
   \   00000134   000054E1           CMP      R4,R0
   \   00000138   010000AA           BGE      ??GUI_TOUCH_Exec_7
   \   0000013C   0100A0E3           MOV      R0,#+1
   \   00000140   000000EA           B        ??GUI_TOUCH_Exec_8
   \                     ??GUI_TOUCH_Exec_7:
   \   00000144   0000A0E3           MOV      R0,#+0
   \                     ??GUI_TOUCH_Exec_8:
   \   00000148   A4109FE5           LDR      R1,??GUI_TOUCH_Exec_1+0x4  ;; xMax
   \   0000014C   001091E5           LDR      R1,[R1, #+0]
   \   00000150   040051E1           CMP      R1,R4
   \   00000154   010000AA           BGE      ??GUI_TOUCH_Exec_9
   \   00000158   0110A0E3           MOV      R1,#+1
   \   0000015C   000000EA           B        ??GUI_TOUCH_Exec_10
   \                     ??GUI_TOUCH_Exec_9:
   \   00000160   0010A0E3           MOV      R1,#+0
   \                     ??GUI_TOUCH_Exec_10:
   \   00000164   8C209FE5           LDR      R2,??GUI_TOUCH_Exec_1+0x8  ;; yMin
   \   00000168   002092E5           LDR      R2,[R2, #+0]
   \   0000016C   020055E1           CMP      R5,R2
   \   00000170   010000AA           BGE      ??GUI_TOUCH_Exec_11
   \   00000174   0120A0E3           MOV      R2,#+1
   \   00000178   000000EA           B        ??GUI_TOUCH_Exec_12
   \                     ??GUI_TOUCH_Exec_11:
   \   0000017C   0020A0E3           MOV      R2,#+0
   \                     ??GUI_TOUCH_Exec_12:
   \   00000180   74309FE5           LDR      R3,??GUI_TOUCH_Exec_1+0xC  ;; yMax
   \   00000184   003093E5           LDR      R3,[R3, #+0]
   \   00000188   050053E1           CMP      R3,R5
   \   0000018C   010000AA           BGE      ??GUI_TOUCH_Exec_13
   \   00000190   0130A0E3           MOV      R3,#+1
   \   00000194   000000EA           B        ??GUI_TOUCH_Exec_14
   \                     ??GUI_TOUCH_Exec_13:
   \   00000198   0030A0E3           MOV      R3,#+0
   \                     ??GUI_TOUCH_Exec_14:
   \   0000019C   000091E1           ORRS     R0,R1,R0
   \   000001A0   000092E1           ORRS     R0,R2,R0
   \   000001A4   000093E1           ORRS     R0,R3,R0
   \   000001A8   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000001AC   000050E3           CMP      R0,#+0
   \   000001B0   0300000A           BEQ      ??GUI_TOUCH_Exec_15
    304          		GUI_TOUCH_StoreUnstable(-1,-1);
   \   000001B4   0010E0E3           MVN      R1,#+0
   \   000001B8   0000E0E3           MVN      R0,#+0
   \   000001BC   ........           _BLF     GUI_TOUCH_StoreUnstable,??GUI_TOUCH_StoreUnstable??rA
   \   000001C0   080000EA           B        ??GUI_TOUCH_Exec_16
    305          	} else {
    306          		x = _AD2X(x);
   \                     ??GUI_TOUCH_Exec_15:
   \   000001C4   0400B0E1           MOVS     R0,R4
   \   000001C8   ........           BL       ??_AD2X
   \   000001CC   0040B0E1           MOVS     R4,R0
    307          		y = _AD2Y(y);
   \   000001D0   0500B0E1           MOVS     R0,R5
   \   000001D4   ........           BL       ??_AD2Y
   \   000001D8   0050B0E1           MOVS     R5,R0
    308          		GUI_TOUCH_StoreUnstable(x,y);
   \   000001DC   0510B0E1           MOVS     R1,R5
   \   000001E0   0400B0E1           MOVS     R0,R4
   \   000001E4   ........           _BLF     GUI_TOUCH_StoreUnstable,??GUI_TOUCH_StoreUnstable??rA
    309          	}
    310          	/* Reset state machine */
    311          #endif /* WIN32 */
    312          }
   \                     ??GUI_TOUCH_Exec_16:
   \   000001E8   3040BDE8           POP      {R4,R5,LR}
   \   000001EC   1EFF2FE1           BX       LR               ;; return
   \                     ??GUI_TOUCH_Exec_1:
   \   000001F0   ........           DC32     xMin
   \   000001F4   ........           DC32     xMax
   \   000001F8   ........           DC32     yMin
   \   000001FC   ........           DC32     yMax
   \   00000200   ........           DC32     TouchKeyPressed
   \   00000204   ........           DC32     TXUADData + 14
   \   00000208   ........           DC32     TXUADData + 10
   \   0000020C   ........           DC32     PhysKeyPressed

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   ........           DC32     xyMinMaxDefault

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   ........           DC32     xyMinMax

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   ........           DC32     xyMinMax + 4

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   ........           DC32     xyMinMax + 8

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   ........           DC32     xyMinMax + 12

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable39:
   \   00000000   ........           DC32     xPhys

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable40:
   \   00000000   ........           DC32     yPhys

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for xyMinMax>`:
   \   00000000   A20300005000       DC32 930, 80, 920, 100
   \              000098030000
   \              64000000    

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for xyMinMaxDefault>`:
   \   00000000   A20300005000       DC32 930, 80, 920, 100
   \              000098030000
   \              64000000    
    313          
    314          
    315          #else
    316          
    317          void GUI_TOUCH_DriverAnalog_C(void);	/* Avoid "no prototype" warnings */
    318          void GUI_TOUCH_DriverAnalog_C(void) {}
    319          
    320          #endif    /* defined(GUI_SUPPORT_TOUCH) && GUI_SUPPORT_TOUCH */
    321          
    322          
    323          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     GUI_TOUCH_Calibrate               36
     GUI_TOUCH_Exec                    12
     GUI_TOUCH_GetCalData               0
     GUI_TOUCH_GetxPhys                 0
     GUI_TOUCH_GetyPhys                 0
     GUI_TOUCH_SetCalData              16
     GUI_TOUCH_SetDefaultCalibration
                                        0
     _AD2X(int)                         4
     _AD2Y(int)                         4
     _Log2Phys(int, signed long, signed long, signed long, signed long)
                                        8
     abs                                0
     labs                               0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     abs                              20
     labs                             20
     PhysKeyPressed                    1
     xPhys                             4
     yPhys                             4
     xyMinMax                         16
     xyMinMaxDefault                  16
     xMin                              4
     xMax                              4
     yMin                              4
     yMax                              4
     _AD2X(int)                       72
     _AD2Y(int)                       68
     _Log2Phys(int, signed long, signed long, signed long, signed long)
                                      40
     GUI_TOUCH_GetxPhys               12
     GUI_TOUCH_GetyPhys               12
     GUI_TOUCH_SetDefaultCalibration
                                      80
     GUI_TOUCH_Calibrate             212
     GUI_TOUCH_GetCalData             44
     GUI_TOUCH_SetCalData            160
     GUI_TOUCH_Exec                  528
     ??DataTable20                     4
     ??DataTable27                     4
     ??DataTable28                     4
     ??DataTable33                     4
     ??DataTable34                     4
     ??DataTable39                     4
     ??DataTable40                     4
     ?<Initializer for xyMinMax>      16
     ?<Initializer for xyMinMaxDefault>
                                      16
      Others                         112

 
 1 384 bytes in segment CODE
    32 bytes in segment DATA_I
    32 bytes in segment DATA_ID
    25 bytes in segment DATA_Z
    24 bytes in segment INITTAB
 
 1 256 bytes of CODE  memory (+ 152 bytes shared)
    32 bytes of CONST memory
    57 bytes of DATA  memory

Errors: none
Warnings: none
