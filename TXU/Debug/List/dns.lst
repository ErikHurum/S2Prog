##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:20:12 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\core\dns.c              #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\core\dns.c --fpu None   #
#                       -D OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D   #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\dns.lst                     #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\dns.r79                      #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\core\dns.c
      1          /**
      2           * @file
      3           * DNS - host name to IP address resolver.
      4           *
      5           */
      6          
      7          /**
      8          
      9           * This file implements a DNS host name to IP address resolver.
     10          
     11           * Port to lwIP from uIP
     12           * by Jim Pettinato April 2007
     13          
     14           * uIP version Copyright (c) 2002-2003, Adam Dunkels.
     15           * All rights reserved.
     16           *
     17           * Redistribution and use in source and binary forms, with or without
     18           * modification, are permitted provided that the following conditions
     19           * are met:
     20           * 1. Redistributions of source code must retain the above copyright
     21           *    notice, this list of conditions and the following disclaimer.
     22           * 2. Redistributions in binary form must reproduce the above copyright
     23           *    notice, this list of conditions and the following disclaimer in the
     24           *    documentation and/or other materials provided with the distribution.
     25           * 3. The name of the author may not be used to endorse or promote
     26           *    products derived from this software without specific prior
     27           *    written permission.
     28           *
     29           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
     30           * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     31           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     32           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
     33           * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     34           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
     35           * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     36           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
     37           * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     38           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     39           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     40           *
     41           *
     42           * DNS.C
     43           *
     44           * The lwIP DNS resolver functions are used to lookup a host name and
     45           * map it to a numerical IP address. It maintains a list of resolved
     46           * hostnames that can be queried with the dns_lookup() function.
     47           * New hostnames can be resolved using the dns_query() function.
     48           *
     49           * The lwIP version of the resolver also adds a non-blocking version of
     50           * gethostbyname() that will work with a raw API application. This function
     51           * checks for an IP address string first and converts it if it is valid.
     52           * gethostbyname() then does a dns_lookup() to see if the name is
     53           * already in the table. If so, the IP is returned. If not, a query is
     54           * issued and the function returns with a ERR_INPROGRESS status. The app
     55           * using the dns client must then go into a waiting state.
     56           *
     57           * Once a hostname has been resolved (or found to be non-existent),
     58           * the resolver code calls a specified callback function (which
     59           * must be implemented by the module that uses the resolver).
     60           */
     61          
     62          /*-----------------------------------------------------------------------------
     63           * RFC 1035 - Domain names - implementation and specification
     64           * RFC 2181 - Clarifications to the DNS Specification
     65           *----------------------------------------------------------------------------*/
     66          
     67          /** @todo: define good default values (rfc compliance) */
     68          /** @todo: improve answer parsing, more checkings... */
     69          /** @todo: check RFC1035 - 7.3. Processing responses */
     70          
     71          /*-----------------------------------------------------------------------------
     72           * Includes
     73           *----------------------------------------------------------------------------*/
     74          
     75          #include "lwip/opt.h"
     76          
     77          #if LWIP_DNS /* don't build if not configured for use in lwipopts.h */
     78          
     79          #include "lwip/udp.h"
     80          #include "lwip/mem.h"
     81          #include "lwip/memp.h"
     82          #include "lwip/dns.h"
     83          
     84          #include <string.h>
     85          
     86          /** DNS server IP address */
     87          #ifndef DNS_SERVER_ADDRESS
     88          #define DNS_SERVER_ADDRESS(ipaddr)        (ip4_addr_set_u32(ipaddr, ipaddr_addr("208.67.222.222"))) /* resolver1.opendns.com */
     89          #endif
     90          
     91          /** DNS server port address */
     92          #ifndef DNS_SERVER_PORT
     93          #define DNS_SERVER_PORT           53
     94          #endif
     95          
     96          /** DNS maximum number of retries when asking for a name, before "timeout". */
     97          #ifndef DNS_MAX_RETRIES
     98          #define DNS_MAX_RETRIES           4
     99          #endif
    100          
    101          /** DNS resource record max. TTL (one week as default) */
    102          #ifndef DNS_MAX_TTL
    103          #define DNS_MAX_TTL               604800
    104          #endif
    105          
    106          /* DNS protocol flags */
    107          #define DNS_FLAG1_RESPONSE        0x80
    108          #define DNS_FLAG1_OPCODE_STATUS   0x10
    109          #define DNS_FLAG1_OPCODE_INVERSE  0x08
    110          #define DNS_FLAG1_OPCODE_STANDARD 0x00
    111          #define DNS_FLAG1_AUTHORATIVE     0x04
    112          #define DNS_FLAG1_TRUNC           0x02
    113          #define DNS_FLAG1_RD              0x01
    114          #define DNS_FLAG2_RA              0x80
    115          #define DNS_FLAG2_ERR_MASK        0x0f
    116          #define DNS_FLAG2_ERR_NONE        0x00
    117          #define DNS_FLAG2_ERR_NAME        0x03
    118          
    119          /* DNS protocol states */
    120          #define DNS_STATE_UNUSED          0
    121          #define DNS_STATE_NEW             1
    122          #define DNS_STATE_ASKING          2
    123          #define DNS_STATE_DONE            3
    124          
    125          #ifdef PACK_STRUCT_USE_INCLUDES
    126          #  include "arch/bpstruct.h"
    127          #endif
    128          #pragma pack(push,1)
    129          /** DNS message header */
    130          struct dns_hdr {
    131            PACK_STRUCT_FIELD(u16_t id);
    132            PACK_STRUCT_FIELD(u8_t flags1);
    133            PACK_STRUCT_FIELD(u8_t flags2);
    134            PACK_STRUCT_FIELD(u16_t numquestions);
    135            PACK_STRUCT_FIELD(u16_t numanswers);
    136            PACK_STRUCT_FIELD(u16_t numauthrr);
    137            PACK_STRUCT_FIELD(u16_t numextrarr);
    138          } PACK_STRUCT_STRUCT;
    139          #pragma pack(pop)
    140          #ifdef PACK_STRUCT_USE_INCLUDES
    141          #  include "arch/epstruct.h"
    142          #endif
    143          #define SIZEOF_DNS_HDR 12
    144          
    145          /** DNS query message structure.
    146              No packing needed: only used locally on the stack. */
    147          struct dns_query {
    148            /* DNS query record starts with either a domain name or a pointer
    149               to a name already present somewhere in the packet. */
    150            u16_t type;
    151            u16_t cls;
    152          };
    153          #define SIZEOF_DNS_QUERY 4
    154          
    155          /** DNS answer message structure.
    156              No packing needed: only used locally on the stack. */
    157          struct dns_answer {
    158            /* DNS answer record starts with either a domain name or a pointer
    159               to a name already present somewhere in the packet. */
    160            u16_t type;
    161            u16_t cls;
    162            u32_t ttl;
    163            u16_t len;
    164          };
    165          #define SIZEOF_DNS_ANSWER 10
    166          
    167          /** DNS table entry */
    168          struct dns_table_entry {
    169            u8_t  state;
    170            u8_t  numdns;
    171            u8_t  tmr;
    172            u8_t  retries;
    173            u8_t  seqno;
    174            u8_t  err;
    175            u32_t ttl;
    176            char name[DNS_MAX_NAME_LENGTH];
    177            ip_addr_t ipaddr;
    178            /* pointer to callback on DNS query done */
    179            dns_found_callback found;
    180            void *arg;
    181          };
    182          
    183          #if DNS_LOCAL_HOSTLIST
    184          
    185          #if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
    186          /** Local host-list. For hostnames in this list, no
    187           *  external name resolution is performed */
    188          static struct local_hostlist_entry *local_hostlist_dynamic;
    189          #else /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
    190          
    191          /** Defining this allows the local_hostlist_static to be placed in a different
    192           * linker section (e.g. FLASH) */
    193          #ifndef DNS_LOCAL_HOSTLIST_STORAGE_PRE
    194          #define DNS_LOCAL_HOSTLIST_STORAGE_PRE static
    195          #endif /* DNS_LOCAL_HOSTLIST_STORAGE_PRE */
    196          /** Defining this allows the local_hostlist_static to be placed in a different
    197           * linker section (e.g. FLASH) */
    198          #ifndef DNS_LOCAL_HOSTLIST_STORAGE_POST
    199          #define DNS_LOCAL_HOSTLIST_STORAGE_POST
    200          #endif /* DNS_LOCAL_HOSTLIST_STORAGE_POST */
    201          DNS_LOCAL_HOSTLIST_STORAGE_PRE struct local_hostlist_entry local_hostlist_static[]
    202            DNS_LOCAL_HOSTLIST_STORAGE_POST = DNS_LOCAL_HOSTLIST_INIT;
    203          
    204          #endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
    205          
    206          static void dns_init_local();
    207          #endif /* DNS_LOCAL_HOSTLIST */
    208          
    209          
    210          /* forward declarations */
    211          static void dns_recv(void *s, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port);
    212          static void dns_check_entries(void);
    213          
    214          /*-----------------------------------------------------------------------------
    215           * Globales
    216           *----------------------------------------------------------------------------*/
    217          
    218          /* DNS variables */
    219          static struct udp_pcb        *dns_pcb;
    220          static u8_t                   dns_seqno;
    221          static struct dns_table_entry dns_table[DNS_TABLE_SIZE];
    222          static ip_addr_t              dns_servers[DNS_MAX_SERVERS];
    223          /** Contiguous buffer for processing responses */
    224          static u8_t                   dns_payload_buffer[LWIP_MEM_ALIGN_BUFFER(DNS_MSG_SIZE)];
    225          static u8_t*                  dns_payload;
    226          
    227          /**
    228           * Initialize the resolver: set up the UDP pcb and configure the default server
    229           * (DNS_SERVER_ADDRESS).
    230           */
    231          void
    232          dns_init()
    233          {
    234            ip_addr_t dnsserver;
    235          
    236            dns_payload = (u8_t *)LWIP_MEM_ALIGN(dns_payload_buffer);
    237          
    238            /* initialize default DNS server address */
    239            DNS_SERVER_ADDRESS(&dnsserver);
    240          
    241            LWIP_DEBUGF(DNS_DEBUG, ("dns_init: initializing\n"));
    242          
    243            /* if dns client not yet initialized... */
    244            if (dns_pcb == NULL) {
    245              dns_pcb = udp_new();
    246          
    247              if (dns_pcb != NULL) {
    248                /* initialize DNS table not needed (initialized to zero since it is a
    249                 * global variable) */
    250                LWIP_ASSERT("For implicit initialization to work, DNS_STATE_UNUSED needs to be 0",
    251                  DNS_STATE_UNUSED == 0);
    252          
    253                /* initialize DNS client */
    254                udp_bind(dns_pcb, IP_ADDR_ANY, 0);
    255                udp_recv(dns_pcb, dns_recv, NULL);
    256          
    257                /* initialize default DNS primary server */
    258                dns_setserver(0, &dnsserver);
    259              }
    260            }
    261          #if DNS_LOCAL_HOSTLIST
    262            dns_init_local();
    263          #endif
    264          }
    265          
    266          /**
    267           * Initialize one of the DNS servers.
    268           *
    269           * @param numdns the index of the DNS server to set must be < DNS_MAX_SERVERS
    270           * @param dnsserver IP address of the DNS server to set
    271           */
    272          void
    273          dns_setserver(u8_t numdns, ip_addr_t *dnsserver)
    274          {
    275            if ((numdns < DNS_MAX_SERVERS) && (dns_pcb != NULL) &&
    276                (dnsserver != NULL) && !ip_addr_isany(dnsserver)) {
    277              dns_servers[numdns] = (*dnsserver);
    278            }
    279          }
    280          
    281          /**
    282           * Obtain one of the currently configured DNS server.
    283           *
    284           * @param numdns the index of the DNS server
    285           * @return IP address of the indexed DNS server or "ip_addr_any" if the DNS
    286           *         server has not been configured.
    287           */
    288          ip_addr_t
    289          dns_getserver(u8_t numdns)
    290          {
    291            if (numdns < DNS_MAX_SERVERS) {
    292              return dns_servers[numdns];
    293            } else {
    294              return *IP_ADDR_ANY;
    295            }
    296          }
    297          
    298          /**
    299           * The DNS resolver client timer - handle retries and timeouts and should
    300           * be called every DNS_TMR_INTERVAL milliseconds (every second by default).
    301           */
    302          void
    303          dns_tmr(void)
    304          {
    305            if (dns_pcb != NULL) {
    306              LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
    307              dns_check_entries();
    308            }
    309          }
    310          
    311          #if DNS_LOCAL_HOSTLIST
    312          static void
    313          dns_init_local()
    314          {
    315          #if DNS_LOCAL_HOSTLIST_IS_DYNAMIC && defined(DNS_LOCAL_HOSTLIST_INIT)
    316            int i;
    317            struct local_hostlist_entry *entry;
    318            /* Dynamic: copy entries from DNS_LOCAL_HOSTLIST_INIT to list */
    319            struct local_hostlist_entry local_hostlist_init[] = DNS_LOCAL_HOSTLIST_INIT;
    320            size_t namelen;
    321            for (i = 0; i < sizeof(local_hostlist_init) / sizeof(struct local_hostlist_entry); i++) {
    322              struct local_hostlist_entry *init_entry = &local_hostlist_init[i];
    323              LWIP_ASSERT("invalid host name (NULL)", init_entry->name != NULL);
    324              namelen = strlen(init_entry->name);
    325              LWIP_ASSERT("namelen <= DNS_LOCAL_HOSTLIST_MAX_NAMELEN", namelen <= DNS_LOCAL_HOSTLIST_MAX_NAMELEN);
    326              entry = (struct local_hostlist_entry *)memp_malloc(MEMP_LOCALHOSTLIST);
    327              LWIP_ASSERT("mem-error in dns_init_local", entry != NULL);
    328              if (entry != NULL) {
    329                entry->name = (char*)entry + sizeof(struct local_hostlist_entry);
    330                MEMCPY((char*)entry->name, init_entry->name, namelen);
    331                ((char*)entry->name)[namelen] = 0;
    332                entry->addr = init_entry->addr;
    333                entry->next = local_hostlist_dynamic;
    334                local_hostlist_dynamic = entry;
    335              }
    336            }
    337          #endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC && defined(DNS_LOCAL_HOSTLIST_INIT) */
    338          }
    339          
    340          /**
    341           * Scans the local host-list for a hostname.
    342           *
    343           * @param hostname Hostname to look for in the local host-list
    344           * @return The first IP address for the hostname in the local host-list or
    345           *         IPADDR_NONE if not found.
    346           */
    347          static u32_t
    348          dns_lookup_local(const char *hostname)
    349          {
    350          #if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
    351            struct local_hostlist_entry *entry = local_hostlist_dynamic;
    352            while(entry != NULL) {
    353              if(strcmp(entry->name, hostname) == 0) {
    354                return ip4_addr_get_u32(&entry->addr);
    355              }
    356              entry = entry->next;
    357            }
    358          #else /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
    359            int i;
    360            for (i = 0; i < sizeof(local_hostlist_static) / sizeof(struct local_hostlist_entry); i++) {
    361              if(strcmp(local_hostlist_static[i].name, hostname) == 0) {
    362                return ip4_addr_get_u32(&local_hostlist_static[i].addr);
    363              }
    364            }
    365          #endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
    366            return IPADDR_NONE;
    367          }
    368          
    369          #if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
    370          /** Remove all entries from the local host-list for a specific hostname
    371           * and/or IP addess
    372           *
    373           * @param hostname hostname for which entries shall be removed from the local
    374           *                 host-list
    375           * @param addr address for which entries shall be removed from the local host-list
    376           * @return the number of removed entries
    377           */
    378          int
    379          dns_local_removehost(const char *hostname, const ip_addr_t *addr)
    380          {
    381            int removed = 0;
    382            struct local_hostlist_entry *entry = local_hostlist_dynamic;
    383            struct local_hostlist_entry *last_entry = NULL;
    384            while (entry != NULL) {
    385              if (((hostname == NULL) || !strcmp(entry->name, hostname)) &&
    386                  ((addr == NULL) || ip_addr_cmp(&entry->addr, addr))) {
    387                struct local_hostlist_entry *free_entry;
    388                if (last_entry != NULL) {
    389                  last_entry->next = entry->next;
    390                } else {
    391                  local_hostlist_dynamic = entry->next;
    392                }
    393                free_entry = entry;
    394                entry = entry->next;
    395                memp_free(MEMP_LOCALHOSTLIST, free_entry);
    396                removed++;
    397              } else {
    398                last_entry = entry;
    399                entry = entry->next;
    400              }
    401            }
    402            return removed;
    403          }
    404          
    405          /**
    406           * Add a hostname/IP address pair to the local host-list.
    407           * Duplicates are not checked.
    408           *
    409           * @param hostname hostname of the new entry
    410           * @param addr IP address of the new entry
    411           * @return ERR_OK if succeeded or ERR_MEM on memory error
    412           */
    413          err_t
    414          dns_local_addhost(const char *hostname, const ip_addr_t *addr)
    415          {
    416            struct local_hostlist_entry *entry;
    417            size_t namelen;
    418            LWIP_ASSERT("invalid host name (NULL)", hostname != NULL);
    419            namelen = strlen(hostname);
    420            LWIP_ASSERT("namelen <= DNS_LOCAL_HOSTLIST_MAX_NAMELEN", namelen <= DNS_LOCAL_HOSTLIST_MAX_NAMELEN);
    421            entry = (struct local_hostlist_entry *)memp_malloc(MEMP_LOCALHOSTLIST);
    422            if (entry == NULL) {
    423              return ERR_MEM;
    424            }
    425            entry->name = (char*)entry + sizeof(struct local_hostlist_entry);
    426            MEMCPY((char*)entry->name, hostname, namelen);
    427            ((char*)entry->name)[namelen] = 0;
    428            ip_addr_copy(entry->addr, *addr);
    429            entry->next = local_hostlist_dynamic;
    430            local_hostlist_dynamic = entry;
    431            return ERR_OK;
    432          }
    433          #endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC*/
    434          #endif /* DNS_LOCAL_HOSTLIST */
    435          
    436          /**
    437           * Look up a hostname in the array of known hostnames.
    438           *
    439           * @note This function only looks in the internal array of known
    440           * hostnames, it does not send out a query for the hostname if none
    441           * was found. The function dns_enqueue() can be used to send a query
    442           * for a hostname.
    443           *
    444           * @param name the hostname to look up
    445           * @return the hostname's IP address, as u32_t (instead of ip_addr_t to
    446           *         better check for failure: != IPADDR_NONE) or IPADDR_NONE if the hostname
    447           *         was not found in the cached dns_table.
    448           */
    449          static u32_t
    450          dns_lookup(const char *name)
    451          {
    452            u8_t i;
    453          #if DNS_LOCAL_HOSTLIST || defined(DNS_LOOKUP_LOCAL_EXTERN)
    454            u32_t addr;
    455          #endif /* DNS_LOCAL_HOSTLIST || defined(DNS_LOOKUP_LOCAL_EXTERN) */
    456          #if DNS_LOCAL_HOSTLIST
    457            if ((addr = dns_lookup_local(name)) != IPADDR_NONE) {
    458              return addr;
    459            }
    460          #endif /* DNS_LOCAL_HOSTLIST */
    461          #ifdef DNS_LOOKUP_LOCAL_EXTERN
    462            if((addr = DNS_LOOKUP_LOCAL_EXTERN(name)) != IPADDR_NONE) {
    463              return addr;
    464            }
    465          #endif /* DNS_LOOKUP_LOCAL_EXTERN */
    466          
    467            /* Walk through name list, return entry if found. If not, return NULL. */
    468            for (i = 0; i < DNS_TABLE_SIZE; ++i) {
    469              if ((dns_table[i].state == DNS_STATE_DONE) &&
    470                  (strcmp(name, dns_table[i].name) == 0)) {
    471                LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
    472                ip_addr_debug_print(DNS_DEBUG, &(dns_table[i].ipaddr));
    473                LWIP_DEBUGF(DNS_DEBUG, ("\n"));
    474                return ip4_addr_get_u32(&dns_table[i].ipaddr);
    475              }
    476            }
    477          
    478            return IPADDR_NONE;
    479          }
    480          
    481          #if DNS_DOES_NAME_CHECK
    482          /**
    483           * Compare the "dotted" name "query" with the encoded name "response"
    484           * to make sure an answer from the DNS server matches the current dns_table
    485           * entry (otherwise, answers might arrive late for hostname not on the list
    486           * any more).
    487           *
    488           * @param query hostname (not encoded) from the dns_table
    489           * @param response encoded hostname in the DNS response
    490           * @return 0: names equal; 1: names differ
    491           */
    492          static u8_t
    493          dns_compare_name(unsigned char *query, unsigned char *response)
    494          {
    495            unsigned char n;
    496          
    497            do {
    498              n = *response++;
    499              /** @see RFC 1035 - 4.1.4. Message compression */
    500              if ((n & 0xc0) == 0xc0) {
    501                /* Compressed name */
    502                break;
    503              } else {
    504                /* Not compressed name */
    505                while (n > 0) {
    506                  if ((*query) != (*response)) {
    507                    return 1;
    508                  }
    509                  ++response;
    510                  ++query;
    511                  --n;
    512                };
    513                ++query;
    514              }
    515            } while (*response != 0);
    516          
    517            return 0;
    518          }
    519          #endif /* DNS_DOES_NAME_CHECK */
    520          
    521          /**
    522           * Walk through a compact encoded DNS name and return the end of the name.
    523           *
    524           * @param query encoded DNS name in the DNS server response
    525           * @return end of the name
    526           */
    527          static unsigned char *
    528          dns_parse_name(unsigned char *query)
    529          {
    530            unsigned char n;
    531          
    532            do {
    533              n = *query++;
    534              /** @see RFC 1035 - 4.1.4. Message compression */
    535              if ((n & 0xc0) == 0xc0) {
    536                /* Compressed name */
    537                break;
    538              } else {
    539                /* Not compressed name */
    540                while (n > 0) {
    541                  ++query;
    542                  --n;
    543                };
    544              }
    545            } while (*query != 0);
    546          
    547            return query + 1;
    548          }
    549          
    550          /**
    551           * Send a DNS query packet.
    552           *
    553           * @param numdns index of the DNS server in the dns_servers table
    554           * @param name hostname to query
    555           * @param id index of the hostname in dns_table, used as transaction ID in the
    556           *        DNS query packet
    557           * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise
    558           */
    559          static err_t
    560          dns_send(u8_t numdns, const char* name, u8_t id)
    561          {
    562            err_t err;
    563            struct dns_hdr *hdr;
    564            struct dns_query qry;
    565            struct pbuf *p;
    566            char *query, *nptr;
    567            const char *pHostname;
    568            u8_t n;
    569          
    570            LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
    571                        (u16_t)(numdns), name));
    572            LWIP_ASSERT("dns server out of array", numdns < DNS_MAX_SERVERS);
    573            LWIP_ASSERT("dns server has no IP address set", !ip_addr_isany(&dns_servers[numdns]));
    574          
    575            /* if here, we have either a new query or a retry on a previous query to process */
    576            p = pbuf_alloc(PBUF_TRANSPORT, SIZEOF_DNS_HDR + DNS_MAX_NAME_LENGTH +
    577                           SIZEOF_DNS_QUERY, PBUF_RAM);
    578            if (p != NULL) {
    579              LWIP_ASSERT("pbuf must be in one piece", p->next == NULL);
    580              /* fill dns header */
    581              hdr = (struct dns_hdr*)p->payload;
    582              memset(hdr, 0, SIZEOF_DNS_HDR);
    583              hdr->id = htons(id);
    584              hdr->flags1 = DNS_FLAG1_RD;
    585              hdr->numquestions = PP_HTONS(1);
    586              query = (char*)hdr + SIZEOF_DNS_HDR;
    587              pHostname = name;
    588              --pHostname;
    589          
    590              /* convert hostname into suitable query format. */
    591              do {
    592                ++pHostname;
    593                nptr = query;
    594                ++query;
    595                for(n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {
    596                  *query = *pHostname;
    597                  ++query;
    598                  ++n;
    599                }
    600                *nptr = n;
    601              } while(*pHostname != 0);
    602              *query++='\0';
    603          
    604              /* fill dns query */
    605              qry.type = PP_HTONS(DNS_RRTYPE_A);
    606              qry.cls = PP_HTONS(DNS_RRCLASS_IN);
    607              SMEMCPY(query, &qry, SIZEOF_DNS_QUERY);
    608          
    609              /* resize pbuf to the exact dns query */
    610              pbuf_realloc(p, (u16_t)((query + SIZEOF_DNS_QUERY) - ((char*)(p->payload))));
    611          
    612              /* connect to the server for faster receiving */
    613              udp_connect(dns_pcb, &dns_servers[numdns], DNS_SERVER_PORT);
    614              /* send dns packet */
    615              err = udp_sendto(dns_pcb, p, &dns_servers[numdns], DNS_SERVER_PORT);
    616          
    617              /* free pbuf */
    618              pbuf_free(p);
    619            } else {
    620              err = ERR_MEM;
    621            }
    622          
    623            return err;
    624          }
    625          
    626          /**
    627           * dns_check_entry() - see if pEntry has not yet been queried and, if so, sends out a query.
    628           * Check an entry in the dns_table:
    629           * - send out query for new entries
    630           * - retry old pending entries on timeout (also with different servers)
    631           * - remove completed entries from the table if their TTL has expired
    632           *
    633           * @param i index of the dns_table entry to check
    634           */
    635          static void
    636          dns_check_entry(u8_t i)
    637          {
    638            err_t err;
    639            struct dns_table_entry *pEntry = &dns_table[i];
    640          
    641            LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
    642          
    643            switch(pEntry->state) {
    644          
    645              case DNS_STATE_NEW: {
    646                /* initialize new entry */
    647                pEntry->state   = DNS_STATE_ASKING;
    648                pEntry->numdns  = 0;
    649                pEntry->tmr     = 1;
    650                pEntry->retries = 0;
    651          
    652                /* send DNS packet for this entry */
    653                err = dns_send(pEntry->numdns, pEntry->name, i);
    654                if (err != ERR_OK) {
    655                  LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
    656                              ("dns_send returned error: %s\n", lwip_strerr(err)));
    657                }
    658                break;
    659              }
    660          
    661              case DNS_STATE_ASKING: {
    662                if (--pEntry->tmr == 0) {
    663                  if (++pEntry->retries == DNS_MAX_RETRIES) {
    664                    if ((pEntry->numdns+1<DNS_MAX_SERVERS) && !ip_addr_isany(&dns_servers[pEntry->numdns+1])) {
    665                      /* change of server */
    666                      pEntry->numdns++;
    667                      pEntry->tmr     = 1;
    668                      pEntry->retries = 0;
    669                      break;
    670                    } else {
    671                      LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", pEntry->name));
    672                      /* call specified callback function if provided */
    673                      if (pEntry->found)
    674                        (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
    675                      /* flush this entry */
    676                      pEntry->state   = DNS_STATE_UNUSED;
    677                      pEntry->found   = NULL;
    678                      break;
    679                    }
    680                  }
    681          
    682                  /* wait longer for the next retry */
    683                  pEntry->tmr = pEntry->retries;
    684          
    685                  /* send DNS packet for this entry */
    686                  err = dns_send(pEntry->numdns, pEntry->name, i);
    687                  if (err != ERR_OK) {
    688                    LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
    689                                ("dns_send returned error: %s\n", lwip_strerr(err)));
    690                  }
    691                }
    692                break;
    693              }
    694          
    695              case DNS_STATE_DONE: {
    696                /* if the time to live is nul */
    697                if (--pEntry->ttl == 0) {
    698                  LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", pEntry->name));
    699                  /* flush this entry */
    700                  pEntry->state = DNS_STATE_UNUSED;
    701                  pEntry->found = NULL;
    702                }
    703                break;
    704              }
    705              case DNS_STATE_UNUSED:
    706                /* nothing to do */
    707                break;
    708              default:
    709                LWIP_ASSERT("unknown dns_table entry state:", 0);
    710                break;
    711            }
    712          }
    713          
    714          /**
    715           * Call dns_check_entry for each entry in dns_table - check all entries.
    716           */
    717          static void
    718          dns_check_entries(void)
    719          {
    720            u8_t i;
    721          
    722            for (i = 0; i < DNS_TABLE_SIZE; ++i) {
    723              dns_check_entry(i);
    724            }
    725          }
    726          
    727          /**
    728           * Receive input function for DNS response packets arriving for the dns UDP pcb.
    729           *
    730           * @params see udp.h
    731           */
    732          static void
    733          dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
    734          {
    735            u16_t i;
    736            char *pHostname;
    737            struct dns_hdr *hdr;
    738            struct dns_answer ans;
    739            struct dns_table_entry *pEntry;
    740            u16_t nquestions, nanswers;
    741          
    742            LWIP_UNUSED_ARG(arg);
    743            LWIP_UNUSED_ARG(pcb);
    744            LWIP_UNUSED_ARG(addr);
    745            LWIP_UNUSED_ARG(port);
    746          
    747            /* is the dns message too big ? */
    748            if (p->tot_len > DNS_MSG_SIZE) {
    749              LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too big\n"));
    750              /* free pbuf and return */
    751              goto memerr;
    752            }
    753          
    754            /* is the dns message big enough ? */
    755            if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY + SIZEOF_DNS_ANSWER)) {
    756              LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too small\n"));
    757              /* free pbuf and return */
    758              goto memerr;
    759            }
    760          
    761            /* copy dns payload inside static buffer for processing */
    762            if (pbuf_copy_partial(p, dns_payload, p->tot_len, 0) == p->tot_len) {
    763              /* The ID in the DNS header should be our entry into the name table. */
    764              hdr = (struct dns_hdr*)dns_payload;
    765              i = htons(hdr->id);
    766              if (i < DNS_TABLE_SIZE) {
    767                pEntry = &dns_table[i];
    768                if(pEntry->state == DNS_STATE_ASKING) {
    769                  /* This entry is now completed. */
    770                  pEntry->state = DNS_STATE_DONE;
    771                  pEntry->err   = hdr->flags2 & DNS_FLAG2_ERR_MASK;
    772          
    773                  /* We only care about the question(s) and the answers. The authrr
    774                     and the extrarr are simply discarded. */
    775                  nquestions = htons(hdr->numquestions);
    776                  nanswers   = htons(hdr->numanswers);
    777          
    778                  /* Check for error. If so, call callback to inform. */
    779                  if (((hdr->flags1 & DNS_FLAG1_RESPONSE) == 0) || (pEntry->err != 0) || (nquestions != 1)) {
    780                    LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", pEntry->name));
    781                    /* call callback to indicate error, clean up memory and return */
    782                    goto responseerr;
    783                  }
    784          
    785          #if DNS_DOES_NAME_CHECK
    786                  /* Check if the name in the "question" part match with the name in the entry. */
    787                  if (dns_compare_name((unsigned char *)(pEntry->name), (unsigned char *)dns_payload + SIZEOF_DNS_HDR) != 0) {
    788                    LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", pEntry->name));
    789                    /* call callback to indicate error, clean up memory and return */
    790                    goto responseerr;
    791                  }
    792          #endif /* DNS_DOES_NAME_CHECK */
    793          
    794                  /* Skip the name in the "question" part */
    795                  pHostname = (char *) dns_parse_name((unsigned char *)dns_payload + SIZEOF_DNS_HDR) + SIZEOF_DNS_QUERY;
    796          
    797                  while (nanswers > 0) {
    798                    /* skip answer resource record's host name */
    799                    pHostname = (char *) dns_parse_name((unsigned char *)pHostname);
    800          
    801                    /* Check for IP address type and Internet class. Others are discarded. */
    802                    SMEMCPY(&ans, pHostname, SIZEOF_DNS_ANSWER);
    803                    if((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) &&
    804                       (ans.len == PP_HTONS(sizeof(ip_addr_t))) ) {
    805                      /* read the answer resource record's TTL, and maximize it if needed */
    806                      pEntry->ttl = ntohl(ans.ttl);
    807                      if (pEntry->ttl > DNS_MAX_TTL) {
    808                        pEntry->ttl = DNS_MAX_TTL;
    809                      }
    810                      /* read the IP address after answer resource record's header */
    811                      SMEMCPY(&(pEntry->ipaddr), (pHostname+SIZEOF_DNS_ANSWER), sizeof(ip_addr_t));
    812                      LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", pEntry->name));
    813                      ip_addr_debug_print(DNS_DEBUG, (&(pEntry->ipaddr)));
    814                      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
    815                      /* call specified callback function if provided */
    816                      if (pEntry->found) {
    817                        (*pEntry->found)(pEntry->name, &pEntry->ipaddr, pEntry->arg);
    818                      }
    819                      /* deallocate memory and return */
    820                      goto memerr;
    821                    } else {
    822                      pHostname = pHostname + SIZEOF_DNS_ANSWER + htons(ans.len);
    823                    }
    824                    --nanswers;
    825                  }
    826                  LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", pEntry->name));
    827                  /* call callback to indicate error, clean up memory and return */
    828                  goto responseerr;
    829                }
    830              }
    831            }
    832          
    833            /* deallocate memory and return */
    834            goto memerr;
    835          
    836          responseerr:
    837            /* ERROR: call specified callback function with NULL as name to indicate an error */
    838            if (pEntry->found) {
    839              (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
    840            }
    841            /* flush this entry */
    842            pEntry->state = DNS_STATE_UNUSED;
    843            pEntry->found = NULL;
    844          
    845          memerr:
    846            /* free pbuf */
    847            pbuf_free(p);
    848            return;
    849          }
    850          
    851          /**
    852           * Queues a new hostname to resolve and sends out a DNS query for that hostname
    853           *
    854           * @param name the hostname that is to be queried
    855           * @param found a callback founction to be called on success, failure or timeout
    856           * @param callback_arg argument to pass to the callback function
    857           * @return @return a err_t return code.
    858           */
    859          static err_t
    860          dns_enqueue(const char *name, dns_found_callback found, void *callback_arg)
    861          {
    862            u8_t i;
    863            u8_t lseq, lseqi;
    864            struct dns_table_entry *pEntry = NULL;
    865            size_t namelen;
    866          
    867            /* search an unused entry, or the oldest one */
    868            lseq = lseqi = 0;
    869            for (i = 0; i < DNS_TABLE_SIZE; ++i) {
    870              pEntry = &dns_table[i];
    871              /* is it an unused entry ? */
    872              if (pEntry->state == DNS_STATE_UNUSED)
    873                break;
    874          
    875              /* check if this is the oldest completed entry */
    876              if (pEntry->state == DNS_STATE_DONE) {
    877                if ((dns_seqno - pEntry->seqno) > lseq) {
    878                  lseq = dns_seqno - pEntry->seqno;
    879                  lseqi = i;
    880                }
    881              }
    882            }
    883          
    884            /* if we don't have found an unused entry, use the oldest completed one */
    885            if (i == DNS_TABLE_SIZE) {
    886              if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
    887                /* no entry can't be used now, table is full */
    888                LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
    889                return ERR_MEM;
    890              } else {
    891                /* use the oldest completed one */
    892                i = lseqi;
    893                pEntry = &dns_table[i];
    894              }
    895            }
    896          
    897            /* use this entry */
    898            LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));
    899          
    900            /* fill the entry */
    901            pEntry->state = DNS_STATE_NEW;
    902            pEntry->seqno = dns_seqno++;
    903            pEntry->found = found;
    904            pEntry->arg   = callback_arg;
    905            namelen = LWIP_MIN(strlen(name), DNS_MAX_NAME_LENGTH-1);
    906            MEMCPY(pEntry->name, name, namelen);
    907            pEntry->name[namelen] = 0;
    908          
    909            /* force to send query without waiting timer */
    910            dns_check_entry(i);
    911          
    912            /* dns query is enqueued */
    913            return ERR_INPROGRESS;
    914          }
    915          
    916          /**
    917           * Resolve a hostname (string) into an IP address.
    918           * NON-BLOCKING callback version for use with raw API!!!
    919           *
    920           * Returns immediately with one of err_t return codes:
    921           * - ERR_OK if hostname is a valid IP address string or the host
    922           *   name is already in the local names table.
    923           * - ERR_INPROGRESS enqueue a request to be sent to the DNS server
    924           *   for resolution if no errors are present.
    925           * - ERR_ARG: dns client not initialized or invalid hostname
    926           *
    927           * @param hostname the hostname that is to be queried
    928           * @param addr pointer to a ip_addr_t where to store the address if it is already
    929           *             cached in the dns_table (only valid if ERR_OK is returned!)
    930           * @param found a callback function to be called on success, failure or timeout (only if
    931           *              ERR_INPROGRESS is returned!)
    932           * @param callback_arg argument to pass to the callback function
    933           * @return a err_t return code.
    934           */
    935          err_t
    936          dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
    937                            void *callback_arg)
    938          {
    939            u32_t ipaddr;
    940            /* not initialized or no valid server yet, or invalid addr pointer
    941             * or invalid hostname or invalid hostname length */
    942            if ((dns_pcb == NULL) || (addr == NULL) ||
    943                (!hostname) || (!hostname[0]) ||
    944                (strlen(hostname) >= DNS_MAX_NAME_LENGTH)) {
    945              return ERR_ARG;
    946            }
    947          
    948          #if LWIP_HAVE_LOOPIF
    949            if (strcmp(hostname, "localhost")==0) {
    950              ip_addr_set_loopback(addr);
    951              return ERR_OK;
    952            }
    953          #endif /* LWIP_HAVE_LOOPIF */
    954          
    955            /* host name already in octet notation? set ip addr and return ERR_OK */
    956            ipaddr = ipaddr_addr(hostname);
    957            if (ipaddr == IPADDR_NONE) {
    958              /* already have this address cached? */
    959              ipaddr = dns_lookup(hostname);
    960            }
    961            if (ipaddr != IPADDR_NONE) {
    962              ip4_addr_set_u32(addr, ipaddr);
    963              return ERR_OK;
    964            }
    965          
    966            /* queue query with specified callback */
    967            return dns_enqueue(hostname, found, callback_arg);
    968          }
    969          
    970          #endif /* LWIP_DNS */
    971          


   Segment part sizes:

     Function/Label Bytes
     -------------- -----

 
 
 0 bytes of memory

Errors: none
Warnings: none
