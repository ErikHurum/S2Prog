##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:19:26 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\Shared\Src\TSNConfigString.cpp             #
#    Command line    =  D:\S2Prog\Shared\Src\TSNConfigString.cpp --fpu None  #
#                       -D OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D   #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -z9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --eec++           #
#                       --dlib_config "C:\Program Files (x86)\IAR            #
#                       Systems\Embedded Workbench                           #
#                       4.0\arm\LIB\dl4tpainl8n.h" -I                        #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\TSNConfigString.lst         #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\TSNConfigString.r79          #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\Shared\Src\TSNConfigString.cpp
      1          #ifndef S2BOOTLOADER
      2              #include "TSNIncludes.h"

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs char const *string::c_str() const
   \                     ??c_str:
   \   00000000   181090E5           LDR      R1,[R0, #+24]
   \   00000004   100051E3           CMP      R1,#+16
   \   00000008   04009025           LDRCS    R0,[R0, #+4]
   \   0000000C   1EFF2F21           BXCS     LR
   \   00000010   040080E2           ADD      R0,R0,#+4
   \   00000014   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs AnsiString::AnsiString(AnsiString const &)
   \                     ??AnsiString:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000018   1C009FE5           LDR      R0,??AnsiString_5  ;; ??npos
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   003090E5           LDR      R3,[R0, #+0]
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           _BLF     ??assign,??assign??rA
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   3040BDE8           POP      {R4,R5,LR}
   \   00000038   1EFF2FE1           BX       LR               ;; return
   \                     ??AnsiString_5:
   \   0000003C   ........           DC32     ??npos
      3              #pragma hdrstop
      4              #ifdef BORLAND
      5                  #pragma package(smart_init)
      6              #endif
      7          
      8              #ifdef BORLAND
      9                  #include <fstream.h>
     10              #endif
     11          #else
     12              #include "BootloaderIncludes.h"
     13          #endif
     14          
     15          //---------------------------------------------------------------------------
     16          

   \                                 In segment CODE, align 4, keep-with-next
     17          TSNConfigString::TSNConfigString(void):
   \                     ??TSNConfigString:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     18          LineCount(1),PreviousLineCnt(1),Size(0),NumberOfBytes(0)
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   040084E5           STR      R0,[R4, #+4]
   \   00000010   080084E5           STR      R0,[R4, #+8]
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   181084E5           STR      R1,[R4, #+24]
   \   0000001C   1C1084E5           STR      R1,[R4, #+28]
     19          {
     20              NoMemory = false;
   \   00000020   0000C4E5           STRB     R0,[R4, #+0]
     21              DataPtr  = new char[Size+1];
   \   00000024   010080E2           ADD      R0,R0,#+1
   \   00000028   ........           B        ?Subroutine30
     22              memset(DataPtr,0,Size);
     23              CurrentPlace    = DataPtr;
     24              OldPlace = DataPtr;
     25          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine30:
   \   00000000   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   00000004   0C0084E5           STR      R0,[R4, #+12]
   \   00000008   042094E5           LDR      R2,[R4, #+4]
   \   0000000C   0010A0E3           MOV      R1,#+0
   \   00000010   ........           _BLF     memset,??memset??rA
   \   00000014   0C0094E5           LDR      R0,[R4, #+12]
   \   00000018   100084E5           STR      R0,[R4, #+16]
   \   0000001C   140084E5           STR      R0,[R4, #+20]
   \   00000020   0400A0E1           MOV      R0,R4
   \                     ??Subroutine30_0:
   \   00000024   1040BDE8           POP      {R4,LR}
   \   00000028   1EFF2FE1           BX       LR               ;; return
     26          

   \                                 In segment CODE, align 4, keep-with-next
     27          TSNConfigString::TSNConfigString(int NewSize):
   \                     ??TSNConfigString_1:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     28          LineCount(1),PreviousLineCnt(1),Size(NewSize),NumberOfBytes(0)
   \   00000008   041084E5           STR      R1,[R4, #+4]
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   080084E5           STR      R0,[R4, #+8]
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   181084E5           STR      R1,[R4, #+24]
   \   0000001C   1C1084E5           STR      R1,[R4, #+28]
     29          {
     30              NoMemory = false;
   \   00000020   0000C4E5           STRB     R0,[R4, #+0]
     31              DataPtr  = new char[Size];
   \   00000024   040094E5           LDR      R0,[R4, #+4]
   \   00000028                      REQUIRE ?Subroutine30
   \   00000028                      ;; // Fall through to label ?Subroutine30
     32              memset(DataPtr,0,Size);
     33              CurrentPlace    = DataPtr;
     34              OldPlace = DataPtr;
     35          }
     36          

   \                                 In segment CODE, align 4, keep-with-next
     37          TSNConfigString::TSNConfigString(AnsiString buff):
   \                     ??TSNConfigString_2:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     38          LineCount(1),PreviousLineCnt(1),NumberOfBytes(0)
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   080084E5           STR      R0,[R4, #+8]
   \   00000014   0110A0E3           MOV      R1,#+1
   \   00000018   181084E5           STR      R1,[R4, #+24]
   \   0000001C   1C1084E5           STR      R1,[R4, #+28]
     39          {
     40              NoMemory = false;
   \   00000020   0000C4E5           STRB     R0,[R4, #+0]
     41              Size = buff.Length();
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     ??Length,??Length??rA
   \   0000002C   040084E5           STR      R0,[R4, #+4]
     42              DataPtr  = new char[Size+1];
   \   00000030   010080E2           ADD      R0,R0,#+1
   \   00000034   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   00000038   0C0084E5           STR      R0,[R4, #+12]
     43              memset(DataPtr,0,Size+1);
   \   0000003C   040094E5           LDR      R0,[R4, #+4]
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   012080E2           ADD      R2,R0,#+1
   \   00000048   0C0094E5           LDR      R0,[R4, #+12]
   \   0000004C   ........           _BLF     memset,??memset??rA
     44              CurrentPlace    = DataPtr;
   \   00000050   0C0094E5           LDR      R0,[R4, #+12]
   \   00000054   100084E5           STR      R0,[R4, #+16]
     45              OldPlace = DataPtr;
   \   00000058   140084E5           STR      R0,[R4, #+20]
     46              strcpy(DataPtr,buff.c_str());
   \   0000005C   0500A0E1           MOV      R0,R5
   \   00000060   ........           _BLF     ??c_str,??c_str??rA
   \   00000064   0010A0E1           MOV      R1,R0
   \   00000068   0C0094E5           LDR      R0,[R4, #+12]
   \   0000006C   ........           _BLF     strcpy,??strcpy??rA
     47          }
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           B        ?Subroutine35

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine35:
   \   00000000   3040BDE8           POP      {R4,R5,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
   \                     ??Subroutine35_0:
   \   00000008   ........           DC32     `?<Constant "Settings.s2s">`
     48          

   \                                 In segment CODE, align 4, keep-with-next
     49          TSNConfigString::TSNConfigString(char* Buff, int NewSize, bool pNoMemory):
   \                     ??TSNConfigString_3:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     50          LineCount(1),PreviousLineCnt(1),Size(NewSize),NumberOfBytes(0),NoMemory(pNoMemory)
   \   0000000C   0030C4E5           STRB     R3,[R4, #+0]
   \   00000010   042084E5           STR      R2,[R4, #+4]
   \   00000014   0060A0E3           MOV      R6,#+0
   \   00000018   086084E5           STR      R6,[R4, #+8]
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   180084E5           STR      R0,[R4, #+24]
   \   00000024   1C0084E5           STR      R0,[R4, #+28]
     51          {
     52              if (NoMemory) {
   \   00000028   000053E3           CMP      R3,#+0
     53                  DataPtr = Buff;
   \   0000002C   0C508415           STRNE    R5,[R4, #+12]
   \   00000030   0500001A           BNE      ??TSNConfigString_4
     54              }else{
     55                  DataPtr  = new char[Size + 1];
   \   00000034   010082E2           ADD      R0,R2,#+1
   \   00000038   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   0000003C   0C0084E5           STR      R0,[R4, #+12]
     56                  memcpy(DataPtr,Buff,Size);
   \   00000040   042094E5           LDR      R2,[R4, #+4]
   \   00000044   0510A0E1           MOV      R1,R5
   \   00000048   ........           _BLF     memcpy,??memcpy??rA
     57              }
     58              DataPtr[Size] = 0;
   \                     ??TSNConfigString_4:
   \   0000004C   040094E5           LDR      R0,[R4, #+4]
   \   00000050   0C1094E5           LDR      R1,[R4, #+12]
   \   00000054   0160C0E7           STRB     R6,[R0, +R1]
     59              CurrentPlace  = DataPtr;
   \   00000058   0C0094E5           LDR      R0,[R4, #+12]
   \   0000005C   100084E5           STR      R0,[R4, #+16]
     60              OldPlace      = DataPtr;
   \   00000060   140084E5           STR      R0,[R4, #+20]
     61          }
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068                      REQUIRE ?Subroutine34
   \   00000068                      ;; // Fall through to label ?Subroutine34

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine34:
   \   00000000   7040BDE8           POP      {R4-R6,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
     62          
     63          

   \                                 In segment CODE, align 4, keep-with-next
     64          TSNConfigString::~TSNConfigString(void)
     65          {
   \                     `?~TSNConfigString`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     66              if (DataPtr && !NoMemory) {
   \   00000008   0C0094E5           LDR      R0,[R4, #+12]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0500000A           BEQ      `?~TSNConfigString_1`
   \   00000014   0010D4E5           LDRB     R1,[R4, #+0]
   \   00000018   000051E3           CMP      R1,#+0
   \   0000001C   0200001A           BNE      `?~TSNConfigString_1`
     67                  delete[] DataPtr;
   \   00000020   ........           _BLF     `??operator delete[]`,`??operator delete[]??rA`
     68                  DataPtr = NULL;
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   0C0084E5           STR      R0,[R4, #+12]
     69              }
     70          }
   \                     `?~TSNConfigString_1`:
   \   0000002C   ........           B        ??Subroutine30_0
     71          
     72          #ifdef S2TXU

   \                                 In segment CODE, align 4, keep-with-next
     73          bool TSNConfigString::ReadFile(char* FileName)
     74          {
   \                     ??ReadFile:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     75          	bool Success = false;
     76          	if ( !stricmp("Settings.s2s",(char*)FileName) ) {
   \   00000008   ........           LDR      R0,??Subroutine35_0  ;; `?<Constant "Settings.s2s">`
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   ........           _BLF     ??stricmp,??stricmp??rA
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0300001A           BNE      ??ReadFile_1
     77          		Success = FlashRead(DataPtr,NumberOfBytes);
   \   0000001C   0C0094E5           LDR      R0,[R4, #+12]
   \   00000020   081084E2           ADD      R1,R4,#+8
   \   00000024   ........           _BLF     ??FlashRead,??FlashRead??rA
   \   00000028   0050A0E1           MOV      R5,R0
     78          	}
     79          	return(Success);
   \                     ??ReadFile_1:
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030                      REQUIRE ?Subroutine35
   \   00000030                      ;; // Fall through to label ?Subroutine35
     80          }
     81          #else
     82          bool TSNConfigString::ReadFile(char* FileName)
     83          {
     84              ifstream ConfigStream;
     85              ConfigStream.open(FileName,ios::in | ios::binary);
     86              if ( ConfigStream ) {
     87                  LineCount= 1;
     88                  PreviousLineCnt = 1;
     89                  CurrentPlace    = DataPtr;
     90                  OldPlace = DataPtr;
     91                  // get length of file:
     92                  ConfigStream.seekg (0, ios::end);
     93                  NumberOfBytes = ConfigStream.tellg();
     94                  ConfigStream.seekg (0, ios::beg);
     95          
     96                  ConfigStream.read(DataPtr,long(NumberOfBytes));
     97                  //NumberOfBytes = ConfigStream.gcount();
     98                  // Ignore Ctrl Z as terminator
     99                  int Ptr = NumberOfBytes-1;
    100                  while ( Ptr && (DataPtr[Ptr] != 26 ) ) Ptr--;
    101                  if ( Ptr ) {
    102                      NumberOfBytes = Ptr;
    103                  }
    104                  DataPtr[NumberOfBytes] = 0;
    105                  ConfigStream.clear();
    106                  ConfigStream.close();
    107                  return(true);
    108              }
    109              return(false);
    110          }
    111          #endif
    112          
    113          #ifdef S2TXU

   \                                 In segment CODE, align 4, keep-with-next
    114          bool TSNConfigString::WriteFile(char* FileName, bool Reset)
    115          {
   \                     ??WriteFile:
   \   00000000   F3402DE9           PUSH     {R0,R1,R4-R7,LR}
   \   00000004   0150A0E1           MOV      R5,R1
    116              const char *FName[2] = {"Settings.s2s","Config.s2c"};
   \   00000008   94109FE5           LDR      R1,??WriteFile_1  ;; `?<Constant {&"Settings.s2s", &"Config.s2c"}>`
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0C0091E8           LDM      R1,{R2,R3}
   \   00000014   0040A0E1           MOV      R4,R0
   \   00000018   0D00A0E1           MOV      R0,SP
    117              bool Success = false;
   \   0000001C   0070A0E3           MOV      R7,#+0
   \   00000020   0C0080E8           STM      R0,{R2,R3}
    118              if ( !stricmp((char*)FName[0],(char*)FileName) ) {
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0200A0E1           MOV      R0,R2
   \   0000002C   ........           _BLF     ??stricmp,??stricmp??rA
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0D00001A           BNE      ??WriteFile_2
    119                  if ( Reset ) {
   \   00000038   000056E3           CMP      R6,#+0
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   0500000A           BEQ      ??WriteFile_3
    120                      Success =  FlashWriteAll((U32)DataPtr, GetSize());
   \   00000044   ........           BL       ??GetSize
   \   00000048   0010A0E1           MOV      R1,R0
   \   0000004C   0C0094E5           LDR      R0,[R4, #+12]
   \   00000050   ........           _BLF     ??FlashWriteAll,??FlashWriteAll??rA
   \                     ??WriteFile_4:
   \   00000054   0070A0E1           MOV      R7,R0
   \   00000058   0E0000EA           B        ??WriteFile_5
    121                  } else {
    122                      Success =  FlashWrite((U32)DataPtr, GetSize());
   \                     ??WriteFile_3:
   \   0000005C   ........           BL       ??GetSize
   \   00000060   0010A0E1           MOV      R1,R0
   \   00000064   0C0094E5           LDR      R0,[R4, #+12]
   \   00000068   ........           _BLF     ??FlashWrite,??FlashWrite??rA
   \   0000006C   F8FFFFEA           B        ??WriteFile_4
    123                  }
    124              } else if ( !stricmp((char*)FName[1],(char*)FileName) ) {
   \                     ??WriteFile_2:
   \   00000070   04009DE5           LDR      R0,[SP, #+4]
   \   00000074   0510A0E1           MOV      R1,R5
   \   00000078   ........           _BLF     ??stricmp,??stricmp??rA
   \   0000007C   000050E3           CMP      R0,#+0
   \   00000080   0400001A           BNE      ??WriteFile_5
    125                  SaveConfig((U32)DataPtr, GetSize());
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   ........           BL       ??GetSize
   \   0000008C   0010A0E1           MOV      R1,R0
   \   00000090   0C0094E5           LDR      R0,[R4, #+12]
   \   00000094   ........           _BLF     ??SaveConfig,??SaveConfig??rA
    126              }
    127              return(Success);
   \                     ??WriteFile_5:
   \   00000098   0700A0E1           MOV      R0,R7
   \   0000009C   F640BDE8           POP      {R1,R2,R4-R7,LR}
   \   000000A0   1EFF2FE1           BX       LR               ;; return
   \                     ??WriteFile_1:
   \   000000A4   ........           DC32     `?<Constant {&"Settings.s2s", &"Config.s2c"}>`
    128          }
    129          #else
    130          bool TSNConfigString::WriteFile(char* FileName, bool Reset=false)
    131          {
    132              ofstream ConfigStream;
    133              if ( Reset ) {
    134                  ConfigStream.open(FileName,ios::out | ios::binary | ios::trunc);
    135              } else {
    136                  ConfigStream.open(FileName,ios::out | ios::binary);
    137              }
    138              bool StreamStatus = (bool)ConfigStream;
    139              if ( StreamStatus ) {
    140                  int Size = GetSize();
    141                  //DataPtr[Size++] = 26; // EOF mark
    142                  //DataPtr[Size++] = 0;
    143          		ConfigStream.write(DataPtr,Size);
    144                  ConfigStream.clear();
    145                  ConfigStream.close();
    146          
    147              }
    148              return(StreamStatus);
    149          }
    150          #endif
    151          

   \                                 In segment CODE, align 4, keep-with-next
    152          void TSNConfigString::SetToPreviousWord(void)
    153          {
    154              LineCount = PreviousLineCnt;
   \                     ??SetToPreviousWord:
   \   00000000   181090E5           LDR      R1,[R0, #+24]
   \   00000004   1C1080E5           STR      R1,[R0, #+28]
    155              CurrentPlace    = OldPlace;
   \   00000008   141090E5           LDR      R1,[R0, #+20]
   \   0000000C   101080E5           STR      R1,[R0, #+16]
    156          }
   \   00000010   1EFF2FE1           BX       LR               ;; return
    157          
    158          
    159          // Advance to next token, delimited by s:

   \                                 In segment CODE, align 4, keep-with-next
    160          AnsiString TSNConfigString::NextW(int &CommentErrorLine)
    161          {
   \                     ??NextW:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
    162              // Can at maximum return to previous word
    163              PreviousLineCnt = LineCount;
   \   0000000C   1C0094E5           LDR      R0,[R4, #+28]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   180084E5           STR      R0,[R4, #+24]
    164              CommentErrorLine = 0;
   \   0000001C   00A0A0E3           MOV      R10,#+0
   \   00000020   00A086E5           STR      R10,[R6, #+0]
    165              AnsiString TempString;
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     ??AnsiString_1,??AnsiString??rA
    166              // Are we at the end of the AnsiString??
    167              if ( *CurrentPlace ) {
   \   0000002C   100094E5           LDR      R0,[R4, #+16]
   \   00000030   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000034   000051E3           CMP      R1,#+0
   \   00000038   7800000A           BEQ      ??NextW_1
    168                  OldPlace       = CurrentPlace;
   \   0000003C   140084E5           STR      R0,[R4, #+20]
    169                  char *StartPtr = CurrentPlace;
   \   00000040   0070A0E1           MOV      R7,R0
   \   00000044   040000EA           B        ??NextW_2
    170                  while ( *StartPtr && isspace(*StartPtr ) ) {
    171                      if ( *StartPtr == '\n' ) {
   \                     ??NextW_3:
   \   00000048   0A0050E3           CMP      R0,#+10
    172                          LineCount++;
   \   0000004C   1C009405           LDREQ    R0,[R4, #+28]
    173                      }
    174                      StartPtr++;
   \   00000050   017087E2           ADD      R7,R7,#+1
   \   00000054   01008002           ADDEQ    R0,R0,#+1
   \   00000058   1C008405           STREQ    R0,[R4, #+28]
    175                  }
   \                     ??NextW_2:
   \   0000005C   0000D7E5           LDRB     R0,[R7, #+0]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0500000A           BEQ      ??NextW_4
   \   00000068   090050E3           CMP      R0,#+9
   \   0000006C   010000BA           BLT      ??NextW_5
   \   00000070   0E0050E3           CMP      R0,#+14
   \   00000074   F3FFFFBA           BLT      ??NextW_3
   \                     ??NextW_5:
   \   00000078   200050E3           CMP      R0,#+32
   \   0000007C   F1FFFF0A           BEQ      ??NextW_3
    176                  if ( *StartPtr ) {
   \                     ??NextW_4:
   \   00000080   000050E3           CMP      R0,#+0
   \   00000084   6500000A           BEQ      ??NextW_1
    177                      int NextPtr    = 0;
   \   00000088   0090A0E3           MOV      R9,#+0
    178                      int CommentPtr = 0;
   \   0000008C   0980A0E1           MOV      R8,R9
    179                      bool Complete = false;
   \   00000090   100000EA           B        ??NextW_6
    180                      while ( StartPtr[NextPtr+CommentPtr] && !Complete ) {
    181          				switch ( StartPtr[NextPtr+CommentPtr] ) {
    182          					case '\r':
    183          					case ' ' :   // ANSI White spaces
    184          					case '\t':
    185          					case '\v':
    186          					case '\n':
    187          					case '\f':
    188          						Complete = true;
    189          						break;
    190          					case '/':
    191          						// Checking next one without updating Commentptr
    192          						switch ( StartPtr[NextPtr+CommentPtr+1] ) {
    193          							case '/':
    194          								{
    195          									while ( StartPtr[NextPtr+CommentPtr]  && ( StartPtr[NextPtr+CommentPtr] != '\n') ) {
    196          										CommentPtr++;
    197          									}
    198          									if ( StartPtr[NextPtr+CommentPtr] != '\n'){
    199          										LineCount++;
    200          									}
    201          									Complete = true;
    202          								}
    203          								break;
    204          							case '*':
    205          								{
    206          									int CommentStartLine = LineCount;
    207          									int CommentCnt=1;
    208          									CommentPtr+=2;  // We have allready checked the 2 previous without step
    209                                              while ( CommentCnt && StartPtr[NextPtr+CommentPtr] ) {
    210                                                  switch ( StartPtr[NextPtr+CommentPtr] ) {
    211                                                      case '*':
    212                                                          if ( StartPtr[NextPtr+CommentPtr+1] == '/' ) {
    213                                                              CommentPtr++;
    214                                                              CommentCnt--;
    215                                                          }
    216                                                          break;
    217                                                      case '/':
    218                                                          if ( StartPtr[NextPtr+CommentPtr+1] == '*' ) {
    219                                                              CommentPtr++;
    220                                                              CommentCnt++;
    221                                                          }
    222                                                          break;
    223                                                      case '\n':
    224          												LineCount++;
    225                                                          break;
    226                                                  }
    227                                                  CommentPtr++;
    228                                              }
    229                                              if ( !StartPtr[NextPtr+CommentPtr] ) {
    230                                                  CommentErrorLine = CommentStartLine;
    231                                              }
    232                                              Complete = true;
    233                                          }
    234                                          break;
    235                                      default:
    236                                          TempString += StartPtr[NextPtr+CommentPtr];
   \                     ??NextW_7:
   \   00000094   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000098   0110A0E3           MOV      R1,#+1
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   ........           _BLF     ??append,??append??rA
    237                                          NextPtr++;
   \   000000A4   019089E2           ADD      R9,R9,#+1
   \   000000A8   0A0000EA           B        ??NextW_6
   \                     ??NextW_8:
   \   000000AC   018088E2           ADD      R8,R8,#+1
   \                     ??NextW_9:
   \   000000B0   091088E0           ADD      R1,R8,R9
   \   000000B4   071081E0           ADD      R1,R1,R7
   \   000000B8   0020D1E5           LDRB     R2,[R1, #+0]
   \   000000BC   000052E3           CMP      R2,#+0
   \   000000C0   0A005213           CMPNE    R2,#+10
   \   000000C4   F8FFFF1A           BNE      ??NextW_8
   \   000000C8   0A0052E3           CMP      R2,#+10
   \   000000CC   01008012           ADDNE    R0,R0,#+1
   \   000000D0   1C008415           STRNE    R0,[R4, #+28]
   \                     ??NextW_10:
   \   000000D4   01A0A0E3           MOV      R10,#+1
   \                     ??NextW_6:
   \   000000D8   090088E0           ADD      R0,R8,R9
   \   000000DC   071080E0           ADD      R1,R0,R7
   \   000000E0   0000D1E5           LDRB     R0,[R1, #+0]
   \   000000E4   000050E3           CMP      R0,#+0
   \   000000E8   3700000A           BEQ      ??NextW_11
   \   000000EC   00005AE3           CMP      R10,#+0
   \   000000F0   3500001A           BNE      ??NextW_11
   \   000000F4   090040E2           SUB      R0,R0,#+9
   \   000000F8   040050E3           CMP      R0,#+4
   \   000000FC   F4FFFF9A           BLS      ??NextW_10
   \   00000100   170050E2           SUBS     R0,R0,#+23
   \   00000104   F2FFFF0A           BEQ      ??NextW_10
   \   00000108   0F0050E2           SUBS     R0,R0,#+15
   \   0000010C   E0FFFF1A           BNE      ??NextW_7
   \   00000110   0120D1E5           LDRB     R2,[R1, #+1]
   \   00000114   1C0094E5           LDR      R0,[R4, #+28]
   \   00000118   2A2052E2           SUBS     R2,R2,#+42
   \   0000011C   0200000A           BEQ      ??NextW_12
   \   00000120   052052E2           SUBS     R2,R2,#+5
   \   00000124   E1FFFF0A           BEQ      ??NextW_9
   \   00000128   D9FFFFEA           B        ??NextW_7
   \                     ??NextW_12:
   \   0000012C   0110A0E3           MOV      R1,#+1
   \   00000130   028088E2           ADD      R8,R8,#+2
   \                     ??NextW_13:
   \   00000134   092088E0           ADD      R2,R8,R9
   \   00000138   072082E0           ADD      R2,R2,R7
   \   0000013C   0030D2E5           LDRB     R3,[R2, #+0]
   \   00000140   000053E3           CMP      R3,#+0
   \   00000144   1A00000A           BEQ      ??NextW_14
   \   00000148   00A0D2E5           LDRB     R10,[R2, #+0]
   \   0000014C   013088E2           ADD      R3,R8,#+1
   \   00000150   0AA05AE2           SUBS     R10,R10,#+10
   \   00000154   1000000A           BEQ      ??NextW_15
   \   00000158   20A05AE2           SUBS     R10,R10,#+32
   \   0000015C   0200000A           BEQ      ??NextW_16
   \   00000160   05A05AE2           SUBS     R10,R10,#+5
   \   00000164   0600000A           BEQ      ??NextW_17
   \   00000168   0E0000EA           B        ??NextW_18
   \                     ??NextW_16:
   \   0000016C   0120D2E5           LDRB     R2,[R2, #+1]
   \   00000170   2F0052E3           CMP      R2,#+47
   \   00000174   0B00001A           BNE      ??NextW_18
   \   00000178   0380A0E1           MOV      R8,R3
   \   0000017C   011041E2           SUB      R1,R1,#+1
   \   00000180   080000EA           B        ??NextW_18
   \                     ??NextW_17:
   \   00000184   0120D2E5           LDRB     R2,[R2, #+1]
   \   00000188   2A0052E3           CMP      R2,#+42
   \   0000018C   0500001A           BNE      ??NextW_18
   \   00000190   0380A0E1           MOV      R8,R3
   \   00000194   011081E2           ADD      R1,R1,#+1
   \   00000198   020000EA           B        ??NextW_18
   \                     ??NextW_15:
   \   0000019C   1C2094E5           LDR      R2,[R4, #+28]
   \   000001A0   012082E2           ADD      R2,R2,#+1
   \   000001A4   1C2084E5           STR      R2,[R4, #+28]
   \                     ??NextW_18:
   \   000001A8   018088E2           ADD      R8,R8,#+1
   \   000001AC   000051E3           CMP      R1,#+0
   \   000001B0   DFFFFF1A           BNE      ??NextW_13
   \                     ??NextW_14:
   \   000001B4   091088E0           ADD      R1,R8,R9
   \   000001B8   0710D1E7           LDRB     R1,[R1, +R7]
   \   000001BC   000051E3           CMP      R1,#+0
   \   000001C0   C3FFFF1A           BNE      ??NextW_10
   \   000001C4   000086E5           STR      R0,[R6, #+0]
   \   000001C8   C1FFFFEA           B        ??NextW_10
    238                                          break;
    239                                  }
    240                                  break;
    241                              default:
    242                                  TempString += StartPtr[NextPtr+CommentPtr];
    243                                  NextPtr++;
    244                                  break;
    245                          }
    246                      }
    247                      CurrentPlace      = &StartPtr[NextPtr+CommentPtr];
   \                     ??NextW_11:
   \   000001CC   101084E5           STR      R1,[R4, #+16]
    248                      // Did we find any word??
    249                      if ( !CommentErrorLine && !NextPtr ) {
   \   000001D0   000096E5           LDR      R0,[R6, #+0]
   \   000001D4   000050E3           CMP      R0,#+0
   \   000001D8   00005903           CMPEQ    R9,#+0
   \   000001DC   1100001A           BNE      ??NextW_19
    250                          TempString = NextWord(CommentErrorLine);
   \   000001E0   0030A0E3           MOV      R3,#+0
   \   000001E4   0620A0E1           MOV      R2,R6
   \   000001E8   0D10A0E1           MOV      R1,SP
   \   000001EC   0400A0E1           MOV      R0,R4
   \   000001F0   ........           BL       ??NextWord
   \   000001F4   ........           LDR      R0,??DataTable6  ;; ??npos
   \   000001F8   0020A0E3           MOV      R2,#+0
   \   000001FC   003090E5           LDR      R3,[R0, #+0]
   \   00000200   0D10A0E1           MOV      R1,SP
   \   00000204   0500A0E1           MOV      R0,R5
   \   00000208   ........           _BLF     ??assign,??assign??rA
   \   0000020C   0020A0E3           MOV      R2,#+0
   \   00000210   0110A0E3           MOV      R1,#+1
   \   00000214   0D00A0E1           MOV      R0,SP
   \   00000218   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   0000021C   010000EA           B        ??NextW_19
    251                      }
    252                  } else {
    253                      CommentErrorLine = EOF;
   \                     ??NextW_1:
   \   00000220   0A00E0E1           MVN      R0,R10
   \   00000224   000086E5           STR      R0,[R6, #+0]
    254                  }
    255              } else {
    256                  CommentErrorLine = EOF;
    257              }
    258              return(TempString);
   \                     ??NextW_19:
   \   00000228   ........           B        ?Subroutine32
    259          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine32:
   \   00000000   1CD08DE2           ADD      SP,SP,#+28
   \   00000004   F047BDE8           POP      {R4-R10,LR}
   \   00000008   1EFF2FE1           BX       LR               ;; return
    260          
    261          // Advance to next token, delimited by s:

   \                                 In segment CODE, align 4, keep-with-next
    262          AnsiString TSNConfigString::NextWord(int &CommentErrorLine, int EndKey)
    263          {
   \                     ??NextWord:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   38D04DE2           SUB      SP,SP,#+56
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0380A0E1           MOV      R8,R3
    264              AnsiString tmpStr = NextW(CommentErrorLine);
   \   00000018   ........           BL       ??NextW
    265              if (EndKey) {
   \   0000001C   000058E3           CMP      R8,#+0
   \   00000020   3000000A           BEQ      ??NextWord_1
    266                  if (CommentErrorLine) {
   \   00000024   000095E5           LDR      R0,[R5, #+0]
   \   00000028   ........           ADR      R6,??DataTable1  ;; ""
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   1000000A           BEQ      ??NextWord_2
    267                      CommentErrorLine = LineCount;
   \   00000034   1C0097E5           LDR      R0,[R7, #+28]
   \   00000038   000085E5           STR      R0,[R5, #+0]
    268                      SetToPreviousWord();
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           BL       ??SetToPreviousWord
    269                      tmpStr = "";
   \   00000044   0610A0E1           MOV      R1,R6
   \   00000048   0D00A0E1           MOV      R0,SP
   \   0000004C   ........           _BLF     ??AnsiString_2,??AnsiString??rA_1
   \   00000050   ........           LDR      R1,??DataTable6  ;; ??npos
   \   00000054   0020A0E3           MOV      R2,#+0
   \   00000058   003091E5           LDR      R3,[R1, #+0]
   \   0000005C   0010A0E1           MOV      R1,R0
   \   00000060   0400A0E1           MOV      R0,R4
   \   00000064   ........           _BLF     ??assign,??assign??rA
   \   00000068   0020A0E3           MOV      R2,#+0
   \   0000006C   0110A0E3           MOV      R1,#+1
   \   00000070   0D00A0E1           MOV      R0,SP
   \   00000074   1A0000EA           B        ??NextWord_3
    270                  } else {
    271                      if ( EndKey == FindConfigKey(tmpStr) ) {
   \                     ??NextWord_2:
   \   00000078   0410A0E1           MOV      R1,R4
   \   0000007C   0D00A0E1           MOV      R0,SP
   \   00000080   ........           _BLF     ??AnsiString,??AnsiString??rA_2
   \   00000084   ........           _BLF     ??FindConfigKey,??FindConfigKey??rA
   \   00000088   000058E1           CMP      R8,R0
   \   0000008C   0170A003           MOVEQ    R7,#+1
   \   00000090   0070A013           MOVNE    R7,#+0
   \   00000094   0020A0E3           MOV      R2,#+0
   \   00000098   0110A0E3           MOV      R1,#+1
   \   0000009C   0D00A0E1           MOV      R0,SP
   \   000000A0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000A4   000057E3           CMP      R7,#+0
   \   000000A8   0E00000A           BEQ      ??NextWord_1
    272                          CommentErrorLine = END_FOUND;
   \   000000AC   0100E0E3           MVN      R0,#+1
   \   000000B0   000085E5           STR      R0,[R5, #+0]
    273                          tmpStr = "";
   \   000000B4   0610A0E1           MOV      R1,R6
   \   000000B8   1C008DE2           ADD      R0,SP,#+28
   \   000000BC   ........           _BLF     ??AnsiString_2,??AnsiString??rA_1
   \   000000C0   0010A0E1           MOV      R1,R0
   \   000000C4   ........           LDR      R0,??DataTable6  ;; ??npos
   \   000000C8   0020A0E3           MOV      R2,#+0
   \   000000CC   003090E5           LDR      R3,[R0, #+0]
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   ........           _BLF     ??assign,??assign??rA
   \   000000D8   0020A0E3           MOV      R2,#+0
   \   000000DC   0110A0E3           MOV      R1,#+1
   \   000000E0   1C008DE2           ADD      R0,SP,#+28
   \                     ??NextWord_3:
   \   000000E4   ........           _BLF     ??_Tidy,??_Tidy??rA
    274                      }
    275                  }
    276              }
    277              return tmpStr;
   \                     ??NextWord_1:
   \   000000E8   38D08DE2           ADD      SP,SP,#+56
   \   000000EC   ........           B        ?Subroutine36
    278          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine36:
   \   00000000   F041BDE8           POP      {R4-R8,LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
   \                     ??Subroutine36_0:
   \   00000008   ........           DC32     EndConfRevText
    279          

   \                                 In segment CODE, align 4, keep-with-next
    280          AnsiString TSNConfigString::GetRemainingLine(int &CommentErrorLine)
    281          {
   \                     ??GetRemainingLine:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
    282              // Can at maximum return to previous word
    283          	PreviousLineCnt = LineCount;
   \   0000000C   1C0094E5           LDR      R0,[R4, #+28]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   180084E5           STR      R0,[R4, #+24]
    284              CommentErrorLine = 0;
   \   0000001C   0090A0E3           MOV      R9,#+0
   \   00000020   009086E5           STR      R9,[R6, #+0]
    285              AnsiString TempString;
   \   00000024   0500A0E1           MOV      R0,R5
   \   00000028   ........           _BLF     ??AnsiString_1,??AnsiString??rA
    286              // Are we at the end of the String??
    287              if ( *CurrentPlace ) {
   \   0000002C   100094E5           LDR      R0,[R4, #+16]
   \   00000030   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000034   000051E3           CMP      R1,#+0
   \   00000038   7B00000A           BEQ      ??GetRemainingLine_1
    288                  OldPlace   = CurrentPlace;
   \   0000003C   140084E5           STR      R0,[R4, #+20]
    289                  char *StartPtr   = CurrentPlace;
   \   00000040   0070A0E1           MOV      R7,R0
    290                  while ( *StartPtr && isspace(*StartPtr ) ) {
   \                     ??GetRemainingLine_2:
   \   00000044   0000D7E5           LDRB     R0,[R7, #+0]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0C00000A           BEQ      ??GetRemainingLine_3
   \   00000050   090050E3           CMP      R0,#+9
   \   00000054   010000BA           BLT      ??GetRemainingLine_4
   \   00000058   0E0050E3           CMP      R0,#+14
   \   0000005C   010000BA           BLT      ??GetRemainingLine_5
   \                     ??GetRemainingLine_4:
   \   00000060   200050E3           CMP      R0,#+32
   \   00000064   0600001A           BNE      ??GetRemainingLine_3
    291                      if ( *StartPtr == '\n' ) {
   \                     ??GetRemainingLine_5:
   \   00000068   ........           LDRB     R0,[R7], #+1
   \   0000006C   0A0050E3           CMP      R0,#+10
   \   00000070   F3FFFF1A           BNE      ??GetRemainingLine_2
    292                          LineCount++;
   \   00000074   1C0094E5           LDR      R0,[R4, #+28]
   \   00000078   010080E2           ADD      R0,R0,#+1
   \   0000007C   1C0084E5           STR      R0,[R4, #+28]
    293                          return(TempString); // Return an empty String
   \   00000080   6B0000EA           B        ??GetRemainingLine_6
    294                      } else {
    295                          StartPtr++;
    296                      }
    297          
    298                  }
    299                  if ( *StartPtr ) {
   \                     ??GetRemainingLine_3:
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   6700000A           BEQ      ??GetRemainingLine_1
    300                      int NextPtr    = 0;
   \   0000008C   0000A0E3           MOV      R0,#+0
    301                      int CommentPtr = 0;
   \   00000090   0080A0E1           MOV      R8,R0
    302                      bool Complete = false;
   \   00000094   00A0A0E1           MOV      R10,R0
   \   00000098   110000EA           B        ??GetRemainingLine_7
    303                      while ( StartPtr[NextPtr+CommentPtr] && !Complete ) {
    304                          switch ( StartPtr[NextPtr+CommentPtr] ) {
    305                              case '\r':
    306                              case '\n':
    307                                  Complete = true;
    308                                  break;
    309                              case '/':
    310                                  // Checking next one without updating Commentptr
    311                                  switch ( StartPtr[NextPtr+CommentPtr+1] ) {
    312                                      case '/':
    313                                          {
    314          
    315                                              while ( StartPtr[NextPtr+CommentPtr]  && ( StartPtr[NextPtr+CommentPtr] != '\n') ) {
    316          										CommentPtr++;
    317                                              }
    318          									if ( StartPtr[NextPtr+CommentPtr] == '\n'){
    319          										//CommentPtr++;
    320          										LineCount++;
    321          										NextPtr++;
    322          									}
    323          									Complete = true;
    324                                          }
    325                                          break;
    326                                      case '*':
    327                                          {
    328                                              int CommentStartLine = LineCount;
    329          									int CommentCnt=1;
    330                                              CommentPtr+=2;  // We have allready checked the 2 previous without step
    331                                              while ( CommentCnt && StartPtr[NextPtr+CommentPtr] ) {
    332                                                  switch ( StartPtr[NextPtr+CommentPtr] ) {
    333                                                      case '*':
    334                                                          if ( StartPtr[NextPtr+CommentPtr+1] == '/' ) {
    335                                                              CommentPtr++;
    336                                                              CommentCnt--;
    337                                                          }
    338                                                          break;
    339                                                      case '/':
    340                                                          if ( StartPtr[NextPtr+CommentPtr+1] == '*' ) {
    341                                                              CommentPtr++;
    342                                                              CommentCnt++;
    343                                                          }
    344                                                          break;
    345                                                      case '\n':
    346                                                          LineCount++;
    347                                                          break;
    348                                                  }
    349                                                  CommentPtr++;
    350          
    351          
    352                                              }
    353                                              if ( !StartPtr[NextPtr+CommentPtr] ) {
    354                                                  CommentErrorLine = CommentStartLine;
    355                                              }
    356                                              Complete = true;
    357                                          }
    358                                          break;
    359                                      case '\r':
    360          								NextPtr++;
    361          								break;
    362                                      default:
    363                                          TempString += StartPtr[NextPtr+CommentPtr];
   \                     ??GetRemainingLine_8:
   \   0000009C   0020D2E5           LDRB     R2,[R2, #+0]
   \   000000A0   0110A0E3           MOV      R1,#+1
   \   000000A4   0500A0E1           MOV      R0,R5
   \   000000A8   ........           _BLF     ??append,??append??rA
   \                     ??GetRemainingLine_9:
   \   000000AC   0900A0E1           MOV      R0,R9
   \   000000B0   0B0000EA           B        ??GetRemainingLine_7
   \                     ??GetRemainingLine_10:
   \   000000B4   018088E2           ADD      R8,R8,#+1
   \                     ??GetRemainingLine_11:
   \   000000B8   002088E0           ADD      R2,R8,R0
   \   000000BC   072082E0           ADD      R2,R2,R7
   \   000000C0   0030D2E5           LDRB     R3,[R2, #+0]
   \   000000C4   000053E3           CMP      R3,#+0
   \   000000C8   0A005313           CMPNE    R3,#+10
   \   000000CC   F8FFFF1A           BNE      ??GetRemainingLine_10
   \   000000D0   0A0053E3           CMP      R3,#+10
   \   000000D4   01008102           ADDEQ    R0,R1,#+1
   \   000000D8   1C008405           STREQ    R0,[R4, #+28]
   \   000000DC   0900A001           MOVEQ    R0,R9
   \                     ??GetRemainingLine_12:
   \   000000E0   01A0A0E3           MOV      R10,#+1
   \                     ??GetRemainingLine_7:
   \   000000E4   001088E0           ADD      R1,R8,R0
   \   000000E8   072081E0           ADD      R2,R1,R7
   \   000000EC   0010D2E5           LDRB     R1,[R2, #+0]
   \   000000F0   000051E3           CMP      R1,#+0
   \   000000F4   3800000A           BEQ      ??GetRemainingLine_13
   \   000000F8   00005AE3           CMP      R10,#+0
   \   000000FC   3600001A           BNE      ??GetRemainingLine_13
   \   00000100   019080E2           ADD      R9,R0,#+1
   \   00000104   0A1051E2           SUBS     R1,R1,#+10
   \   00000108   03105112           SUBSNE   R1,R1,#+3
   \   0000010C   F3FFFF0A           BEQ      ??GetRemainingLine_12
   \   00000110   221051E2           SUBS     R1,R1,#+34
   \   00000114   E0FFFF1A           BNE      ??GetRemainingLine_8
   \   00000118   0130D2E5           LDRB     R3,[R2, #+1]
   \   0000011C   1C1094E5           LDR      R1,[R4, #+28]
   \   00000120   0D3053E2           SUBS     R3,R3,#+13
   \   00000124   E0FFFF0A           BEQ      ??GetRemainingLine_9
   \   00000128   1D3053E2           SUBS     R3,R3,#+29
   \   0000012C   0200000A           BEQ      ??GetRemainingLine_14
   \   00000130   053053E2           SUBS     R3,R3,#+5
   \   00000134   DFFFFF0A           BEQ      ??GetRemainingLine_11
   \   00000138   D7FFFFEA           B        ??GetRemainingLine_8
   \                     ??GetRemainingLine_14:
   \   0000013C   0120A0E3           MOV      R2,#+1
   \   00000140   028088E2           ADD      R8,R8,#+2
   \                     ??GetRemainingLine_15:
   \   00000144   003088E0           ADD      R3,R8,R0
   \   00000148   073083E0           ADD      R3,R3,R7
   \   0000014C   0090D3E5           LDRB     R9,[R3, #+0]
   \   00000150   000059E3           CMP      R9,#+0
   \   00000154   1A00000A           BEQ      ??GetRemainingLine_16
   \   00000158   00A0D3E5           LDRB     R10,[R3, #+0]
   \   0000015C   019088E2           ADD      R9,R8,#+1
   \   00000160   0AA05AE2           SUBS     R10,R10,#+10
   \   00000164   1000000A           BEQ      ??GetRemainingLine_17
   \   00000168   20A05AE2           SUBS     R10,R10,#+32
   \   0000016C   0200000A           BEQ      ??GetRemainingLine_18
   \   00000170   05A05AE2           SUBS     R10,R10,#+5
   \   00000174   0600000A           BEQ      ??GetRemainingLine_19
   \   00000178   0E0000EA           B        ??GetRemainingLine_20
   \                     ??GetRemainingLine_18:
   \   0000017C   0130D3E5           LDRB     R3,[R3, #+1]
   \   00000180   2F0053E3           CMP      R3,#+47
   \   00000184   0B00001A           BNE      ??GetRemainingLine_20
   \   00000188   0980A0E1           MOV      R8,R9
   \   0000018C   012042E2           SUB      R2,R2,#+1
   \   00000190   080000EA           B        ??GetRemainingLine_20
   \                     ??GetRemainingLine_19:
   \   00000194   0130D3E5           LDRB     R3,[R3, #+1]
   \   00000198   2A0053E3           CMP      R3,#+42
   \   0000019C   0500001A           BNE      ??GetRemainingLine_20
   \   000001A0   0980A0E1           MOV      R8,R9
   \   000001A4   012082E2           ADD      R2,R2,#+1
   \   000001A8   020000EA           B        ??GetRemainingLine_20
   \                     ??GetRemainingLine_17:
   \   000001AC   1C3094E5           LDR      R3,[R4, #+28]
   \   000001B0   013083E2           ADD      R3,R3,#+1
   \   000001B4   1C3084E5           STR      R3,[R4, #+28]
   \                     ??GetRemainingLine_20:
   \   000001B8   018088E2           ADD      R8,R8,#+1
   \   000001BC   000052E3           CMP      R2,#+0
   \   000001C0   DFFFFF1A           BNE      ??GetRemainingLine_15
   \                     ??GetRemainingLine_16:
   \   000001C4   002088E0           ADD      R2,R8,R0
   \   000001C8   0720D2E7           LDRB     R2,[R2, +R7]
   \   000001CC   000052E3           CMP      R2,#+0
   \   000001D0   C2FFFF1A           BNE      ??GetRemainingLine_12
   \   000001D4   001086E5           STR      R1,[R6, #+0]
   \   000001D8   C0FFFFEA           B        ??GetRemainingLine_12
    364                                          NextPtr++;
    365                                          break;
    366                                  }
    367                                  break;
    368                              default:
    369                                  TempString += StartPtr[NextPtr+CommentPtr];
    370                                  NextPtr++;
    371                                  break;
    372                          }
    373                      }
    374          			CurrentPlace      = &StartPtr[NextPtr+CommentPtr];
   \                     ??GetRemainingLine_13:
   \   000001DC   102084E5           STR      R2,[R4, #+16]
    375                      if ( !CommentErrorLine && !NextPtr ) {
   \   000001E0   001096E5           LDR      R1,[R6, #+0]
   \   000001E4   000051E3           CMP      R1,#+0
   \   000001E8   00005003           CMPEQ    R0,#+0
   \   000001EC   1000001A           BNE      ??GetRemainingLine_6
    376                          TempString = GetRemainingLine(CommentErrorLine);
   \   000001F0   0620A0E1           MOV      R2,R6
   \   000001F4   0D10A0E1           MOV      R1,SP
   \   000001F8   0400A0E1           MOV      R0,R4
   \   000001FC   7FFFFFEB           BL       ??GetRemainingLine
   \   00000200   ........           LDR      R0,??DataTable6  ;; ??npos
   \   00000204   0020A0E3           MOV      R2,#+0
   \   00000208   003090E5           LDR      R3,[R0, #+0]
   \   0000020C   0D10A0E1           MOV      R1,SP
   \   00000210   0500A0E1           MOV      R0,R5
   \   00000214   ........           _BLF     ??assign,??assign??rA
   \   00000218   0020A0E3           MOV      R2,#+0
   \   0000021C   0110A0E3           MOV      R1,#+1
   \   00000220   0D00A0E1           MOV      R0,SP
   \   00000224   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000228   010000EA           B        ??GetRemainingLine_6
    377                      }
    378                  } else {
    379                      CommentErrorLine = EOF;
   \                     ??GetRemainingLine_1:
   \   0000022C   0900E0E1           MVN      R0,R9
   \   00000230   000086E5           STR      R0,[R6, #+0]
   \                     ??GetRemainingLine_6:
   \   00000234                      REQUIRE ?Subroutine32
   \   00000234                      ;; // Fall through to label ?Subroutine32
    380                  }
    381              } else {
    382                  CommentErrorLine = EOF;
    383              }
    384              return(TempString);
    385          }
    386          

   \                                 In segment CODE, align 4, keep-with-next
    387          AnsiString TSNConfigString::GetConfigRevisionText(int &CommentErrorLine)
    388          {
   \                     ??GetConfigRevisionText:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
    389              // Can at maximum return to previous word
    390              PreviousLineCnt = LineCount;
   \   0000000C   1C0094E5           LDR      R0,[R4, #+28]
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   180084E5           STR      R0,[R4, #+24]
    391              CommentErrorLine = 0;
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   000086E5           STR      R0,[R6, #+0]
    392              // Are we at the end of the String??
    393              if ( *CurrentPlace ) {
   \   00000020   100094E5           LDR      R0,[R4, #+16]
   \   00000024   0150A0E1           MOV      R5,R1
   \   00000028   0010D0E5           LDRB     R1,[R0, #+0]
   \   0000002C   000051E3           CMP      R1,#+0
   \   00000030   2100000A           BEQ      ??GetConfigRevisionText_1
    394                  OldPlace   = CurrentPlace;
    395                  char *EndOfTextPtr = strstr(CurrentPlace,EndConfRevText.c_str());
   \   00000034   ........           LDR      R7,??Subroutine36_0  ;; EndConfRevText
   \   00000038   140084E5           STR      R0,[R4, #+20]
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   ........           _BLF     ??c_str,??c_str??rA
   \   00000044   0010A0E1           MOV      R1,R0
   \   00000048   100094E5           LDR      R0,[R4, #+16]
   \   0000004C   ........           _BLF     _Strstr,??_Strstr??rA
   \   00000050   0080B0E1           MOVS     R8,R0
    396                  if ( EndOfTextPtr) {
   \   00000054   1800000A           BEQ      ??GetConfigRevisionText_1
    397                      char *tmpPtr       = CurrentPlace;
   \   00000058   101094E5           LDR      R1,[R4, #+16]
   \   0000005C   0100A0E1           MOV      R0,R1
   \   00000060   040000EA           B        ??GetConfigRevisionText_2
    398                      while (tmpPtr < EndOfTextPtr ) {
    399                          switch (*tmpPtr++) {
   \                     ??GetConfigRevisionText_3:
   \   00000064   ........           LDRB     R3,[R0], #+1
   \   00000068   0A0053E3           CMP      R3,#+10
    400                              case '\n':
    401                                  LineCount++;
   \   0000006C   1C309405           LDREQ    R3,[R4, #+28]
   \   00000070   01308302           ADDEQ    R3,R3,#+1
   \   00000074   1C308405           STREQ    R3,[R4, #+28]
    402                                  break;
    403                              default:
    404                                  break;
    405                          }
    406                      }
   \                     ??GetConfigRevisionText_2:
   \   00000078   080050E1           CMP      R0,R8
   \   0000007C   F8FFFF3A           BCC      ??GetConfigRevisionText_3
    407                      AnsiString TempString(CurrentPlace,EndOfTextPtr-CurrentPlace);
   \   00000080   012048E0           SUB      R2,R8,R1
   \   00000084   0D00A0E1           MOV      R0,SP
   \   00000088   ........           _BLF     ??AnsiString_3,??AnsiString??rA_3
    408                      CurrentPlace = EndOfTextPtr+EndConfRevText.Length();
   \   0000008C   0700A0E1           MOV      R0,R7
   \   00000090   ........           _BLF     ??Length,??Length??rA
   \   00000094   080080E0           ADD      R0,R0,R8
   \   00000098   100084E5           STR      R0,[R4, #+16]
    409                      return TempString;
   \   0000009C   0D10A0E1           MOV      R1,SP
   \   000000A0   0500A0E1           MOV      R0,R5
   \   000000A4   ........           _BLF     ??AnsiString,??AnsiString??rA_2
   \   000000A8   0020A0E3           MOV      R2,#+0
   \   000000AC   0110A0E3           MOV      R1,#+1
   \   000000B0   0D00A0E1           MOV      R0,SP
   \   000000B4   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000B8   040000EA           B        ??GetConfigRevisionText_4
    410                  } else {
    411                      CommentErrorLine = EOF;
   \                     ??GetConfigRevisionText_1:
   \   000000BC   0000E0E3           MVN      R0,#+0
   \   000000C0   000086E5           STR      R0,[R6, #+0]
    412                  }
    413              } else {
    414                  CommentErrorLine = EOF;
    415              }
    416              return("");
   \   000000C4   ........           ADR      R1,??DataTable5  ;; ""
   \   000000C8   0500A0E1           MOV      R0,R5
   \   000000CC   ........           _BLF     ??AnsiString_2,??AnsiString??rA_1
   \                     ??GetConfigRevisionText_4:
   \   000000D0   1CD08DE2           ADD      SP,SP,#+28
   \   000000D4                      REQUIRE ?Subroutine36
   \   000000D4                      ;; // Fall through to label ?Subroutine36
    417          }
    418          
    419          // Find word

   \                                 In segment CODE, align 4, keep-with-next
    420          bool TSNConfigString::FindWord(AnsiString myWord)
    421          {
   \                     ??FindWord:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   3CD04DE2           SUB      SP,SP,#+60
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    422              int CommentErrorLine;
    423              AnsiString TempString;
   \   00000010   20008DE2           ADD      R0,SP,#+32
   \   00000014   ........           _BLF     ??AnsiString_1,??AnsiString??rA
    424              do {
    425                  TempString = NextWord(CommentErrorLine);
   \                     ??FindWord_1:
   \   00000018   0030A0E3           MOV      R3,#+0
   \   0000001C   0D20A0E1           MOV      R2,SP
   \   00000020   04108DE2           ADD      R1,SP,#+4
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       ??NextWord
   \   0000002C   ........           LDR      R0,??DataTable6  ;; ??npos
   \   00000030   0020A0E3           MOV      R2,#+0
   \   00000034   003090E5           LDR      R3,[R0, #+0]
   \   00000038   04108DE2           ADD      R1,SP,#+4
   \   0000003C   20008DE2           ADD      R0,SP,#+32
   \   00000040   ........           _BLF     ??assign,??assign??rA
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   0110A0E3           MOV      R1,#+1
   \   0000004C   04008DE2           ADD      R0,SP,#+4
   \   00000050   ........           _BLF     ??_Tidy,??_Tidy??rA
    426              }while ( !CommentErrorLine && (TempString == myWord) );
   \   00000054   00009DE5           LDR      R0,[SP, #+0]
   \   00000058   000050E3           CMP      R0,#+0
   \   0000005C   0C00001A           BNE      ??FindWord_2
   \   00000060   180095E5           LDR      R0,[R5, #+24]
   \   00000064   0010A0E3           MOV      R1,#+0
   \   00000068   100050E3           CMP      R0,#+16
   \   0000006C   140095E5           LDR      R0,[R5, #+20]
   \   00000070   04309525           LDRCS    R3,[R5, #+4]
   \   00000074   01002DE9           PUSH     {R0}
   \   00000078   38209DE5           LDR      R2,[SP, #+56]
   \   0000007C   04308532           ADDCC    R3,R5,#+4
   \   00000080   24008DE2           ADD      R0,SP,#+36
   \   00000084   ........           _BLF     ??compare,??compare??rA
   \   00000088   000050E3           CMP      R0,#+0
   \   0000008C   04D08DE2           ADD      SP,SP,#+4
   \   00000090   E0FFFF0A           BEQ      ??FindWord_1
    427              return(!CommentErrorLine);
   \                     ??FindWord_2:
   \   00000094   00009DE5           LDR      R0,[SP, #+0]
   \   00000098   0020A0E3           MOV      R2,#+0
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   0140A003           MOVEQ    R4,#+1
   \   000000A4   0040A013           MOVNE    R4,#+0
   \   000000A8   0110A0E3           MOV      R1,#+1
   \   000000AC   20008DE2           ADD      R0,SP,#+32
   \   000000B0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000B4   0400A0E1           MOV      R0,R4
   \   000000B8   3CD08DE2           ADD      SP,SP,#+60
   \   000000BC   ........           B        ?Subroutine35
    428          }
    429          
    430          // Find First Word

   \                                 In segment CODE, align 4, keep-with-next
    431          bool TSNConfigString::FindFirstWord(AnsiString myWord)
    432          {
   \                     ??FindFirstWord:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
    433              LineCount= 1;
   \   0000000C   0100A0E3           MOV      R0,#+1
   \   00000010   1C0084E5           STR      R0,[R4, #+28]
    434              PreviousLineCnt = 1;
   \   00000014   180084E5           STR      R0,[R4, #+24]
    435              CurrentPlace    = DataPtr;
   \   00000018   0C0094E5           LDR      R0,[R4, #+12]
   \   0000001C   100084E5           STR      R0,[R4, #+16]
    436              OldPlace = DataPtr;
   \   00000020   140084E5           STR      R0,[R4, #+20]
    437              return(FindWord(myWord));
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   ........           _BLF     ??AnsiString,??AnsiString??rA_2
   \   0000002C   0010A0E1           MOV      R1,R0
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   ........           BL       ??FindWord
   \   00000038   0040A0E1           MOV      R4,R0
   \   0000003C   0020A0E3           MOV      R2,#+0
   \   00000040   0110A0E3           MOV      R1,#+1
   \   00000044   0D00A0E1           MOV      R0,SP
   \   00000048   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   1CD08DE2           ADD      SP,SP,#+28
   \   00000054   ........           B        ??Subroutine30_0
    438          }
    439          
    440          // Find word

   \                                 In segment CODE, align 4, keep-with-next
    441          bool TSNConfigString::FindBeforeWord(AnsiString myWord)
    442          {
   \                     ??FindBeforeWord:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0040A0E1           MOV      R4,R0
    443              bool Found = FindWord(myWord);
   \   0000000C   0D00A0E1           MOV      R0,SP
   \   00000010   ........           _BLF     ??AnsiString,??AnsiString??rA_2
   \   00000014   0010A0E1           MOV      R1,R0
   \   00000018   0400A0E1           MOV      R0,R4
   \   0000001C   ........           BL       ??FindWord
   \   00000020   0050A0E1           MOV      R5,R0
   \   00000024   0020A0E3           MOV      R2,#+0
   \   00000028   0110A0E3           MOV      R1,#+1
   \   0000002C   0D00A0E1           MOV      R0,SP
   \   00000030   ........           _BLF     ??_Tidy,??_Tidy??rA
    444              if ( Found ) {
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   0100000A           BEQ      ??FindBeforeWord_1
    445                  SetToPreviousWord();
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       ??SetToPreviousWord
    446              }
    447              return(Found);
   \                     ??FindBeforeWord_1:
   \   00000044   0500A0E1           MOV      R0,R5
   \   00000048   1CD08DE2           ADD      SP,SP,#+28
   \   0000004C   ........           B        ?Subroutine35
    448          }
    449          
    450          

   \                                 In segment CODE, align 4, keep-with-next
    451          int TSNConfigString::GetSize(void)
    452          {
    453              int Size=0;
   \                     ??GetSize:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   000000EA           B        ??GetSize_1
    454              while ( DataPtr[Size] ) Size++;
   \                     ??GetSize_2:
   \   00000008   011081E2           ADD      R1,R1,#+1
   \                     ??GetSize_1:
   \   0000000C   0C2090E5           LDR      R2,[R0, #+12]
   \   00000010   0220D1E7           LDRB     R2,[R1, +R2]
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   FAFFFF1A           BNE      ??GetSize_2
    455              return(Size);
   \   0000001C   0100A0E1           MOV      R0,R1
   \   00000020   1EFF2FE1           BX       LR               ;; return
    456          }

   \                                 In segment CODE, align 4, keep-with-next
    457          int  TSNConfigString::GetCurrentLine(void)
    458          {
    459              return LineCount;
   \                     ??GetCurrentLine:
   \   00000000   1C0090E5           LDR      R0,[R0, #+28]
   \   00000004   1EFF2FE1           BX       LR               ;; return
    460          }

   \                                 In segment CODE, align 4, keep-with-next
    461          AnsiString  TSNConfigString::GetCurrentLineStr(void)
    462          {
   \                     ??GetCurrentLineStr:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   0120A0E1           MOV      R2,R1
    463              return AnsiString(LineCount);
   \   00000008   1C1090E5           LDR      R1,[R0, #+28]
   \   0000000C   0200A0E1           MOV      R0,R2
   \   00000010   ........           _BLF     ??AnsiString_4,??AnsiString??rA_4
   \   00000014                      REQUIRE ?Subroutine33
   \   00000014                      ;; // Fall through to label ?Subroutine33
    464          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine33:
   \   00000000   0040BDE8           POP      {LR}
   \   00000004   1EFF2FE1           BX       LR               ;; return
    465          
    466          

   \                                 In segment CODE, align 4, keep-with-next
    467          double TSNConfigString::ReadDouble(int &CommentErrorLine, int EndKey )
    468          {
   \                     ??ReadDouble:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   3CD04DE2           SUB      SP,SP,#+60
   \   00000008   0060A0E1           MOV      R6,R0
   \   0000000C   0170A0E1           MOV      R7,R1
   \   00000010   0280A0E1           MOV      R8,R2
    469              double DoubleValue;
    470              AnsiString InputKeyWord = NextWord(CommentErrorLine);
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018   0720A0E1           MOV      R2,R7
   \   0000001C   20108DE2           ADD      R1,SP,#+32
   \   00000020   ........           BL       ??NextWord
    471              if ( CommentErrorLine ) {
   \   00000024   000097E5           LDR      R0,[R7, #+0]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   2500001A           BNE      ??ReadDouble_1
    472                  DoubleValue = 0.0;
    473              } else {
    474                  char *EndPtr;
    475                  DoubleValue = strtod(InputKeyWord.c_str(), &EndPtr);
   \   00000030   20008DE2           ADD      R0,SP,#+32
   \   00000034   ........           _BLF     ??c_str,??c_str??rA
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   0D10A0E1           MOV      R1,SP
   \   00000040   ........           _BLF     _Stod,??_Stod??rA
   \   00000044   0040A0E1           MOV      R4,R0
    476          
    477                  // Did we reach the end of the word?
    478                  if ( *EndPtr ) {
   \   00000048   00009DE5           LDR      R0,[SP, #+0]
   \   0000004C   0150A0E1           MOV      R5,R1
   \   00000050   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   1C00000A           BEQ      ??ReadDouble_2
    479                      // If Read until end, check if we have the END
    480                      if ( EndKey && (EndKey == FindConfigKey(InputKeyWord) ) ) {
   \   0000005C   0040A0E3           MOV      R4,#+0
   \   00000060   000058E3           CMP      R8,#+0
   \   00000064   0900000A           BEQ      ??ReadDouble_3
   \   00000068   20108DE2           ADD      R1,SP,#+32
   \   0000006C   04008DE2           ADD      R0,SP,#+4
   \   00000070   ........           _BLF     ??AnsiString,??AnsiString??rA_2
   \   00000074   0140A0E3           MOV      R4,#+1
   \   00000078   04008DE2           ADD      R0,SP,#+4
   \   0000007C   ........           _BLF     ??FindConfigKey,??FindConfigKey??rA
   \   00000080   000058E1           CMP      R8,R0
   \   00000084   0180A003           MOVEQ    R8,#+1
   \   00000088   0200000A           BEQ      ??ReadDouble_4
   \   0000008C   0080A0E3           MOV      R8,#+0
   \                     ??ReadDouble_3:
   \   00000090   000054E3           CMP      R4,#+0
   \   00000094   0700000A           BEQ      ??ReadDouble_5
   \                     ??ReadDouble_4:
   \   00000098   0020A0E3           MOV      R2,#+0
   \   0000009C   0110A0E3           MOV      R1,#+1
   \   000000A0   04008DE2           ADD      R0,SP,#+4
   \   000000A4   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000A8   000058E3           CMP      R8,#+0
    481                          CommentErrorLine = END_FOUND;
   \   000000AC   0100E013           MVNNE    R0,#+1
   \   000000B0   00008715           STRNE    R0,[R7, #+0]
    482                          DoubleValue = 0;
   \   000000B4   0300001A           BNE      ??ReadDouble_1
    483                      } else {
    484                          CommentErrorLine = LineCount;
   \                     ??ReadDouble_5:
   \   000000B8   1C0096E5           LDR      R0,[R6, #+28]
   \   000000BC   000087E5           STR      R0,[R7, #+0]
    485                          SetToPreviousWord();
   \   000000C0   0600A0E1           MOV      R0,R6
   \   000000C4   ........           BL       ??SetToPreviousWord
    486                          DoubleValue = 0;
   \                     ??ReadDouble_1:
   \   000000C8   0040A0E3           MOV      R4,#+0
   \   000000CC   0050A0E3           MOV      R5,#+0
    487                      }
    488                  }
    489          
    490              }
    491              return(DoubleValue);
   \                     ??ReadDouble_2:
   \   000000D0   0020A0E3           MOV      R2,#+0
   \   000000D4   0110A0E3           MOV      R1,#+1
   \   000000D8   20008DE2           ADD      R0,SP,#+32
   \   000000DC   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000E0   0400A0E1           MOV      R0,R4
   \   000000E4   0510A0E1           MOV      R1,R5
   \   000000E8   3CD08DE2           ADD      SP,SP,#+60
   \   000000EC   ........           B        ?Subroutine36
    492          }
    493          
    494          

   \                                 In segment CODE, align 4, keep-with-next
    495          long TSNConfigString::ReadLong(int &CommentErrorLine, int EndKey)
    496          {
   \                     ??ReadLong:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   3CD04DE2           SUB      SP,SP,#+60
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
    497              long LongValue;
    498              AnsiString InputKeyWord = NextWord(CommentErrorLine);
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018   0520A0E1           MOV      R2,R5
   \   0000001C   20108DE2           ADD      R1,SP,#+32
   \   00000020   ........           BL       ??NextWord
    499              if ( CommentErrorLine ) {
   \   00000024   000095E5           LDR      R0,[R5, #+0]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   2400001A           BNE      ??ReadLong_1
    500                  LongValue = 0;
    501              } else {
    502                  char *EndPtr;
    503                  LongValue = strtol(InputKeyWord.c_str(), &EndPtr, 10);
   \   00000030   20008DE2           ADD      R0,SP,#+32
   \   00000034   ........           _BLF     ??c_str,??c_str??rA
   \   00000038   0A20A0E3           MOV      R2,#+10
   \   0000003C   0D10A0E1           MOV      R1,SP
   \   00000040   ........           _BLF     strtol,??strtol??rA
   \   00000044   0070A0E1           MOV      R7,R0
    504                  // Did we reach the end of the word?
    505                  if ( *EndPtr ) {
   \   00000048   00009DE5           LDR      R0,[SP, #+0]
   \   0000004C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   1B00000A           BEQ      ??ReadLong_2
    506                      // If Read until end, check if we have the END
    507                      if ( EndKey && (EndKey == FindConfigKey(InputKeyWord) ) ) {
   \   00000058   0070A0E3           MOV      R7,#+0
   \   0000005C   000056E3           CMP      R6,#+0
   \   00000060   0900000A           BEQ      ??ReadLong_3
   \   00000064   20108DE2           ADD      R1,SP,#+32
   \   00000068   04008DE2           ADD      R0,SP,#+4
   \   0000006C   ........           _BLF     ??AnsiString,??AnsiString??rA_2
   \   00000070   0170A0E3           MOV      R7,#+1
   \   00000074   04008DE2           ADD      R0,SP,#+4
   \   00000078   ........           _BLF     ??FindConfigKey,??FindConfigKey??rA
   \   0000007C   000056E1           CMP      R6,R0
   \   00000080   0160A003           MOVEQ    R6,#+1
   \   00000084   0200000A           BEQ      ??ReadLong_4
   \   00000088   0060A0E3           MOV      R6,#+0
   \                     ??ReadLong_3:
   \   0000008C   000057E3           CMP      R7,#+0
   \   00000090   0700000A           BEQ      ??ReadLong_5
   \                     ??ReadLong_4:
   \   00000094   0020A0E3           MOV      R2,#+0
   \   00000098   0110A0E3           MOV      R1,#+1
   \   0000009C   04008DE2           ADD      R0,SP,#+4
   \   000000A0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000A4   000056E3           CMP      R6,#+0
    508                          CommentErrorLine = END_FOUND;
   \   000000A8   0100E013           MVNNE    R0,#+1
   \   000000AC   00008515           STRNE    R0,[R5, #+0]
    509                          LongValue = 0;
   \   000000B0   0300001A           BNE      ??ReadLong_1
    510                      } else {
    511                          CommentErrorLine = LineCount;
   \                     ??ReadLong_5:
   \   000000B4   1C0094E5           LDR      R0,[R4, #+28]
   \   000000B8   000085E5           STR      R0,[R5, #+0]
    512                          SetToPreviousWord();
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   ........           BL       ??SetToPreviousWord
    513                          LongValue = 0;
   \                     ??ReadLong_1:
   \   000000C4   0070A0E3           MOV      R7,#+0
    514                      }
    515                  }
    516              }
    517              return(LongValue);
   \                     ??ReadLong_2:
   \   000000C8   ........           B        ?Subroutine31
    518          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ?Subroutine31:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   20008DE2           ADD      R0,SP,#+32
   \   0000000C   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   00000010   0700A0E1           MOV      R0,R7
   \   00000014   3CD08DE2           ADD      SP,SP,#+60
   \                     ??Subroutine31_0:
   \   00000018   F040BDE8           POP      {R4-R7,LR}
   \   0000001C   1EFF2FE1           BX       LR               ;; return
    519          
    520          

   \                                 In segment CODE, align 4, keep-with-next
    521          long TSNConfigString::ReadHex(int &CommentErrorLine, int EndKey)
    522          {
   \                     ??ReadHex:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   3CD04DE2           SUB      SP,SP,#+60
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
    523              long LongValue;
    524              AnsiString InputKeyWord = NextWord(CommentErrorLine);
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018   0520A0E1           MOV      R2,R5
   \   0000001C   20108DE2           ADD      R1,SP,#+32
   \   00000020   ........           BL       ??NextWord
    525              if ( CommentErrorLine ) {
   \   00000024   000095E5           LDR      R0,[R5, #+0]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   2400001A           BNE      ??ReadHex_1
    526                  LongValue = 0;
    527              } else {
    528                  char *EndPtr;
    529                  LongValue = strtol(InputKeyWord.c_str(), &EndPtr, 16);
   \   00000030   20008DE2           ADD      R0,SP,#+32
   \   00000034   ........           _BLF     ??c_str,??c_str??rA
   \   00000038   1020A0E3           MOV      R2,#+16
   \   0000003C   0D10A0E1           MOV      R1,SP
   \   00000040   ........           _BLF     strtol,??strtol??rA
   \   00000044   0070A0E1           MOV      R7,R0
    530                  // Did we reach the end of the word?
    531                  if ( *EndPtr ) {
   \   00000048   00009DE5           LDR      R0,[SP, #+0]
   \   0000004C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   1B00000A           BEQ      ??ReadHex_2
    532                      // If Read until end, check if we have the END
    533                      if ( EndKey && (EndKey == FindConfigKey(InputKeyWord) ) ) {
   \   00000058   0070A0E3           MOV      R7,#+0
   \   0000005C   000056E3           CMP      R6,#+0
   \   00000060   0900000A           BEQ      ??ReadHex_3
   \   00000064   20108DE2           ADD      R1,SP,#+32
   \   00000068   04008DE2           ADD      R0,SP,#+4
   \   0000006C   ........           _BLF     ??AnsiString,??AnsiString??rA_2
   \   00000070   0170A0E3           MOV      R7,#+1
   \   00000074   04008DE2           ADD      R0,SP,#+4
   \   00000078   ........           _BLF     ??FindConfigKey,??FindConfigKey??rA
   \   0000007C   000056E1           CMP      R6,R0
   \   00000080   0160A003           MOVEQ    R6,#+1
   \   00000084   0200000A           BEQ      ??ReadHex_4
   \   00000088   0060A0E3           MOV      R6,#+0
   \                     ??ReadHex_3:
   \   0000008C   000057E3           CMP      R7,#+0
   \   00000090   0700000A           BEQ      ??ReadHex_5
   \                     ??ReadHex_4:
   \   00000094   0020A0E3           MOV      R2,#+0
   \   00000098   0110A0E3           MOV      R1,#+1
   \   0000009C   04008DE2           ADD      R0,SP,#+4
   \   000000A0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000A4   000056E3           CMP      R6,#+0
    534                          CommentErrorLine = END_FOUND;
   \   000000A8   0100E013           MVNNE    R0,#+1
   \   000000AC   00008515           STRNE    R0,[R5, #+0]
    535                          LongValue = 0;
   \   000000B0   0300001A           BNE      ??ReadHex_1
    536                      } else {
    537                          CommentErrorLine = LineCount;
   \                     ??ReadHex_5:
   \   000000B4   1C0094E5           LDR      R0,[R4, #+28]
   \   000000B8   000085E5           STR      R0,[R5, #+0]
    538                          SetToPreviousWord();
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   ........           BL       ??SetToPreviousWord
    539                          LongValue = 0;
   \                     ??ReadHex_1:
   \   000000C4   0070A0E3           MOV      R7,#+0
    540                      }
    541                  }
    542              }
    543              return(LongValue);
   \                     ??ReadHex_2:
   \   000000C8                      REQUIRE ?Subroutine31
   \   000000C8                      ;; // Fall through to label ?Subroutine31
    544          }
    545          

   \                                 In segment CODE, align 4, keep-with-next
    546          long TSNConfigString::ReadInteger(int &CommentErrorLine, int EndKey)
    547          {
   \                     ??ReadInteger:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   3CD04DE2           SUB      SP,SP,#+60
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
    548              long LongValue;
    549              AnsiString InputKeyWord = NextWord(CommentErrorLine);
   \   00000014   0030A0E3           MOV      R3,#+0
   \   00000018   0520A0E1           MOV      R2,R5
   \   0000001C   20108DE2           ADD      R1,SP,#+32
   \   00000020   ........           BL       ??NextWord
    550              if ( CommentErrorLine ) {
   \   00000024   000095E5           LDR      R0,[R5, #+0]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   2400001A           BNE      ??ReadInteger_1
    551                  LongValue = 0;
    552              } else {
    553                  char *EndPtr;
    554                  LongValue = strtol(InputKeyWord.c_str(), &EndPtr, 0);
   \   00000030   20008DE2           ADD      R0,SP,#+32
   \   00000034   ........           _BLF     ??c_str,??c_str??rA
   \   00000038   0020A0E3           MOV      R2,#+0
   \   0000003C   0D10A0E1           MOV      R1,SP
   \   00000040   ........           _BLF     strtol,??strtol??rA
   \   00000044   0070A0E1           MOV      R7,R0
    555                  // Did we reach the end of the word?
    556                  if ( *EndPtr ) {
   \   00000048   00009DE5           LDR      R0,[SP, #+0]
   \   0000004C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   1B00000A           BEQ      ??ReadInteger_2
    557                      // If Read until end, check if we have the END
    558                      if ( EndKey && (EndKey == FindConfigKey(InputKeyWord) ) ) {
   \   00000058   0070A0E3           MOV      R7,#+0
   \   0000005C   000056E3           CMP      R6,#+0
   \   00000060   0900000A           BEQ      ??ReadInteger_3
   \   00000064   20108DE2           ADD      R1,SP,#+32
   \   00000068   04008DE2           ADD      R0,SP,#+4
   \   0000006C   ........           _BLF     ??AnsiString,??AnsiString??rA_2
   \   00000070   0170A0E3           MOV      R7,#+1
   \   00000074   04008DE2           ADD      R0,SP,#+4
   \   00000078   ........           _BLF     ??FindConfigKey,??FindConfigKey??rA
   \   0000007C   000056E1           CMP      R6,R0
   \   00000080   0160A003           MOVEQ    R6,#+1
   \   00000084   0200000A           BEQ      ??ReadInteger_4
   \   00000088   0060A0E3           MOV      R6,#+0
   \                     ??ReadInteger_3:
   \   0000008C   000057E3           CMP      R7,#+0
   \   00000090   0700000A           BEQ      ??ReadInteger_5
   \                     ??ReadInteger_4:
   \   00000094   0020A0E3           MOV      R2,#+0
   \   00000098   0110A0E3           MOV      R1,#+1
   \   0000009C   04008DE2           ADD      R0,SP,#+4
   \   000000A0   ........           _BLF     ??_Tidy,??_Tidy??rA
   \   000000A4   000056E3           CMP      R6,#+0
    559                          CommentErrorLine = END_FOUND;
   \   000000A8   0100E013           MVNNE    R0,#+1
   \   000000AC   00008515           STRNE    R0,[R5, #+0]
    560                          LongValue = 0;
   \   000000B0   0300001A           BNE      ??ReadInteger_1
    561                      } else {
    562                          CommentErrorLine = LineCount;
   \                     ??ReadInteger_5:
   \   000000B4   1C0094E5           LDR      R0,[R4, #+28]
   \   000000B8   000085E5           STR      R0,[R5, #+0]
    563                          SetToPreviousWord();
   \   000000BC   0400A0E1           MOV      R0,R4
   \   000000C0   ........           BL       ??SetToPreviousWord
    564                          LongValue = 0;
   \                     ??ReadInteger_1:
   \   000000C4   0070A0E3           MOV      R7,#+0
    565                      }
    566                  }
    567              }
    568              return(LongValue);
   \                     ??ReadInteger_2:
   \   000000C8   ........           B        ?Subroutine31
    569          }
    570          

   \                                 In segment CODE, align 4, keep-with-next
    571          void TSNConfigString::AddString(AnsiString NewString)
    572          {
   \                     ??AddString:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0170A0E1           MOV      R7,R1
    573              int Size =(int) NewString.Length();
   \   0000000C   0700A0E1           MOV      R0,R7
   \   00000010   ........           _BLF     ??Length,??Length??rA
    574              char *InsertPlace = CurrentPlace;
   \   00000014   106094E5           LDR      R6,[R4, #+16]
   \   00000018   0050A0E1           MOV      R5,R0
    575              memcpy((void*)CurrentPlace,NewString.c_str(),Size);
   \   0000001C   0700A0E1           MOV      R0,R7
   \   00000020   ........           _BLF     ??c_str,??c_str??rA
   \   00000024   0520A0E1           MOV      R2,R5
   \   00000028   0010A0E1           MOV      R1,R0
   \   0000002C   0600A0E1           MOV      R0,R6
   \   00000030   ........           _BLF     memcpy,??memcpy??rA
    576              CurrentPlace += Size;
   \   00000034   100094E5           LDR      R0,[R4, #+16]
   \   00000038   000085E0           ADD      R0,R5,R0
   \   0000003C   100084E5           STR      R0,[R4, #+16]
    577              for ( int i = 0; i < Size; i++ ) {
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   050000EA           B        ??AddString_1
    578                  if ( InsertPlace[i] == '\n' ) {
   \                     ??AddString_2:
   \   00000048   0610D0E7           LDRB     R1,[R0, +R6]
    579                      LineCount++;
    580                  }
    581              }
   \   0000004C   010080E2           ADD      R0,R0,#+1
   \   00000050   0A0051E3           CMP      R1,#+10
   \   00000054   1C109405           LDREQ    R1,[R4, #+28]
   \   00000058   01108102           ADDEQ    R1,R1,#+1
   \   0000005C   1C108405           STREQ    R1,[R4, #+28]
   \                     ??AddString_1:
   \   00000060   050050E1           CMP      R0,R5
   \   00000064   F7FFFFBA           BLT      ??AddString_2
    582          }
   \   00000068   ........           B        ??Subroutine31_0
    583          

   \                                 In segment CODE, align 4, keep-with-next
    584          bool TSNConfigString::Write(char *fmt, ...)
    585          {
   \                     ??Write:
   \   00000000   0C002DE9           PUSH     {R2,R3}
   \   00000004   70402DE9           PUSH     {R4-R6,LR}
   \   00000008   50D04DE2           SUB      SP,SP,#+80
   \   0000000C   0040A0E1           MOV      R4,R0
    586              va_list argptr;
    587              char TempBuf[BUF_SIZE];
    588              va_start(argptr, fmt);
   \   00000010   60208DE2           ADD      R2,SP,#+96
    589              int Cnt = vsprintf(TempBuf, fmt, argptr);
   \   00000014   0D00A0E1           MOV      R0,SP
   \   00000018   ........           _BLF     vsprintf,??vsprintf??rA
   \   0000001C   0050A0E1           MOV      R5,R0
    590              va_end(argptr);
    591              if ( Cnt != EOF ) {
   \   00000020   010075E3           CMN      R5,#+1
   \   00000024   1100000A           BEQ      ??Write_1
    592                  char *InsertPlace = CurrentPlace;
   \   00000028   106094E5           LDR      R6,[R4, #+16]
    593                  memcpy((void*)CurrentPlace,TempBuf,Cnt);
   \   0000002C   0520A0E1           MOV      R2,R5
   \   00000030   0D10A0E1           MOV      R1,SP
   \   00000034   0600A0E1           MOV      R0,R6
   \   00000038   ........           _BLF     memcpy,??memcpy??rA
    594                  CurrentPlace += Cnt;
   \   0000003C   100094E5           LDR      R0,[R4, #+16]
   \   00000040   000085E0           ADD      R0,R5,R0
   \   00000044   100084E5           STR      R0,[R4, #+16]
    595                  for ( int i = 0; i < Cnt; i++ ) {
   \   00000048   0000A0E3           MOV      R0,#+0
   \                     ??Write_2:
   \   0000004C   050050E1           CMP      R0,R5
   \   00000050   080000AA           BGE      ??Write_3
    596                      if ( InsertPlace[i] == '\n' ) {
   \   00000054   0610D0E7           LDRB     R1,[R0, +R6]
    597                          LineCount++;
    598                      }
    599                  }
   \   00000058   010080E2           ADD      R0,R0,#+1
   \   0000005C   0A0051E3           CMP      R1,#+10
   \   00000060   1C109405           LDREQ    R1,[R4, #+28]
   \   00000064   01108102           ADDEQ    R1,R1,#+1
   \   00000068   1C108405           STREQ    R1,[R4, #+28]
   \   0000006C   F6FFFFEA           B        ??Write_2
    600              }
    601              return( Cnt != EOF );
   \                     ??Write_1:
   \   00000070   0000A0E3           MOV      R0,#+0
   \   00000074   000000EA           B        ??Write_4
   \                     ??Write_3:
   \   00000078   0100A0E3           MOV      R0,#+1
   \                     ??Write_4:
   \   0000007C   50D08DE2           ADD      SP,SP,#+80
   \   00000080   7040BDE8           POP      {R4-R6,LR}
   \   00000084   08D08DE2           ADD      SP,SP,#+8
   \   00000088   1EFF2FE1           BX       LR               ;; return
    602          }

   \                                 In segment DIFUNCT, align 4, keep-with-next, root
   \   00000000                      REQUIRE ?call_ctors
   \   00000000   ........           DC32    ??__sti__routine

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Settings.s2s">`:
   \   00000000   53657474696E       DC8 "Settings.s2s"
   \              67732E733273
   \              00          
   \   0000000D   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "Config.s2c">`:
   \   00000000   436F6E666967       DC8 "Config.s2c"
   \              2E73326300  
   \   0000000B   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {&"Settings.s2s", &"Config.s2c"}>`:
   \   00000000   ............       DC32 `?<Constant "Settings.s2s">`, `?<Constant "Config.s2c">`
   \              ....        

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   00                 DC8 ""

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs TSNConfigString &TSNConfigString::new TSNConfigString(int)
   \                     `??new TSNConfigString`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   2000A0E3           MOV      R0,#+32
   \   0000000C   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0100000A           BEQ      `??new TSNConfigString_4`
   \   00000018   0410A0E1           MOV      R1,R4
   \   0000001C   ........           BL       ??TSNConfigString_1
   \                     `??new TSNConfigString_4`:
   \   00000020   ........           B        ??Subroutine30_0

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs TSNConfigString &TSNConfigString::new TSNConfigString()
   \                     `??new TSNConfigString_1`:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   2000A0E3           MOV      R0,#+32
   \   00000008   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0000000A           BEQ      `??new TSNConfigString_5`
   \   00000014   ........           BL       ??TSNConfigString
   \                     `??new TSNConfigString_5`:
   \   00000018   ........           B        ?Subroutine33

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs TSNConfigString &TSNConfigString::new TSNConfigString(AnsiString)
   \                     `??new TSNConfigString_2`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   2000A0E3           MOV      R0,#+32
   \   0000000C   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0100000A           BEQ      `??new TSNConfigString_6`
   \   00000018   0410A0E1           MOV      R1,R4
   \   0000001C   ........           BL       ??TSNConfigString_2
   \                     `??new TSNConfigString_6`:
   \   00000020   ........           B        ??Subroutine30_0

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs TSNConfigString &TSNConfigString::new TSNConfigString(char *, int, bool)
   \                     `??new TSNConfigString_3`:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   2000A0E3           MOV      R0,#+32
   \   00000014   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0300000A           BEQ      `??new TSNConfigString_7`
   \   00000020   0630A0E1           MOV      R3,R6
   \   00000024   0520A0E1           MOV      R2,R5
   \   00000028   0410A0E1           MOV      R1,R4
   \   0000002C   ........           BL       ??TSNConfigString_3
   \                     `??new TSNConfigString_7`:
   \   00000030   ........           B        ?Subroutine34

   \                                 In segment CODE, align 4, keep-with-next
   \   __??Code32?? __code __interwork __atpcs void TSNConfigString::delete ~TSNConfigString(TSNConfigString *)
   \                     `??delete ~TSNConfigString`:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0200000A           BEQ      `??delete ~TSNConfigString_1`
   \   0000000C   ........           BL       `?~TSNConfigString`
   \   00000010   0400A0E1           MOV      R0,R4
   \   00000014   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \                     `??delete ~TSNConfigString_1`:
   \   00000018   ........           B        ??Subroutine30_0

   \                                 In segment CODE, align 4, keep-with-next
   \   static __??Code32?? __intrinsic __code __interwork __atpcs void __sti__routine()
   \                     ??__sti__routine:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   00000000           DC8      "",+0,+0,+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   00000000           DC8      "",+0,+0,+0

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     ??npos
    603          
    604          

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     AnsiString::AnsiString(AnsiString const &)
                                       12
     TSNConfigString::AddString(AnsiString)
                                       20
     TSNConfigString::FindBeforeWord(AnsiString)
                                       40
     TSNConfigString::FindFirstWord(AnsiString)
                                       36
     TSNConfigString::FindWord(AnsiString)
                                       76
     TSNConfigString::GetConfigRevisionText(int &)
                                       52
     TSNConfigString::GetCurrentLine()
                                        0
     TSNConfigString::GetCurrentLineStr()
                                        4
     TSNConfigString::GetRemainingLine(int &)
                                       60
     TSNConfigString::GetSize()         0
     TSNConfigString::NextW(int &)     60
     TSNConfigString::NextWord(int &, int)
                                       80
     TSNConfigString::ReadDouble(int &, int)
                                       84
     TSNConfigString::ReadFile(char *)
                                       12
     TSNConfigString::ReadHex(int &, int)
                                       80
     TSNConfigString::ReadInteger(int &, int)
                                       80
     TSNConfigString::ReadLong(int &, int)
                                       80
     TSNConfigString::SetToPreviousWord()
                                        0
     TSNConfigString::TSNConfigString()
                                        8
     TSNConfigString::TSNConfigString(AnsiString)
                                       12
     TSNConfigString::TSNConfigString(char *, int, bool)
                                       16
     TSNConfigString::TSNConfigString(int)
                                        8
     TSNConfigString::Write(char *, ...)
                                       96
     TSNConfigString::WriteFile(char *, bool)
                                       28
     TSNConfigString::delete ~TSNConfigString(TSNConfigString *)
                                        8
     TSNConfigString::new TSNConfigString()
                                        4
     TSNConfigString::new TSNConfigString(AnsiString)
                                        8
     TSNConfigString::new TSNConfigString(char *, int, bool)
                                       16
     TSNConfigString::new TSNConfigString(int)
                                        8
     TSNConfigString::~TSNConfigString()
                                        8
     __sti__routine()                   0
     string::c_str() const              0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     string::c_str() const            24
     AnsiString::AnsiString(AnsiString const &)
                                      64
     TSNConfigString::TSNConfigString()
                                      44
     ?Subroutine30                    44
     TSNConfigString::TSNConfigString(int)
                                      40
     TSNConfigString::TSNConfigString(AnsiString)
                                     120
     ?Subroutine35                    12
     TSNConfigString::TSNConfigString(char *, int, bool)
                                     104
     ?Subroutine34                     8
     TSNConfigString::~TSNConfigString()
                                      48
     TSNConfigString::ReadFile(char *)
                                      48
     TSNConfigString::WriteFile(char *, bool)
                                     168
     TSNConfigString::SetToPreviousWord()
                                      20
     TSNConfigString::NextW(int &)   556
     ?Subroutine32                    12
     TSNConfigString::NextWord(int &, int)
                                     240
     ?Subroutine36                    12
     TSNConfigString::GetRemainingLine(int &)
                                     564
     TSNConfigString::GetConfigRevisionText(int &)
                                     212
     TSNConfigString::FindWord(AnsiString)
                                     192
     TSNConfigString::FindFirstWord(AnsiString)
                                      88
     TSNConfigString::FindBeforeWord(AnsiString)
                                      80
     TSNConfigString::GetSize()       36
     TSNConfigString::GetCurrentLine()
                                       8
     TSNConfigString::GetCurrentLineStr()
                                      20
     ?Subroutine33                     8
     TSNConfigString::ReadDouble(int &, int)
                                     240
     TSNConfigString::ReadLong(int &, int)
                                     204
     ?Subroutine31                    32
     TSNConfigString::ReadHex(int &, int)
                                     200
     TSNConfigString::ReadInteger(int &, int)
                                     204
     TSNConfigString::AddString(AnsiString)
                                     108
     TSNConfigString::Write(char *, ...)
                                     140
     ?<Constant "Settings.s2s">       16
     ?<Constant "Config.s2c">         12
     ?<Constant {&"Settings.s2s", &"Config.s2c"}>
                                       8
     ?<Constant "">                    1
     TSNConfigString::new TSNConfigString(int)
                                      36
     TSNConfigString::new TSNConfigString()
                                      28
     TSNConfigString::new TSNConfigString(AnsiString)
                                      36
     TSNConfigString::new TSNConfigString(char *, int, bool)
                                      52
     TSNConfigString::delete ~TSNConfigString(TSNConfigString *)
                                      28
     __sti__routine()                  4
     ??DataTable1                      4
     ??DataTable5                      4
     ??DataTable6                      4
      Others                         460

 
 4 552 bytes in segment CODE
    37 bytes in segment DATA_C
     4 bytes in segment DIFUNCT
 
 4 012 bytes of CODE  memory (+ 544 bytes shared)
    37 bytes of CONST memory

Errors: none
Warnings: none
