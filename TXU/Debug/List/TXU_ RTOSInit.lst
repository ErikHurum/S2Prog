##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:19:57 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\src\TXU_ RTOSInit.c                    #
#    Command line    =  "D:\S2Prog\TXU\src\TXU_ RTOSInit.c" --fpu None -D    #
#                       OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D      #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\TXU_ RTOSInit.lst           #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\TXU_ RTOSInit.r79            #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\src\TXU_ RTOSInit.c
      1          /*********************************************************************
      2          *                SEGGER MICROCONTROLLER SYSTEME GmbH                 *
      3          *        Solutions for real time microcontroller applications        *
      4          **********************************************************************
      5          
      6          File        : RTOSInit.c
      7          Purpose     : Initializes and handles the hardware for embOS as far
      8                          as required by embOS.
      9                          Feel free to modify this file acc. to your
     10                          target system.
     11          ---------------------------END-OF-HEADER------------------------------
     12          */
     13          
     14          /*
     15              Please note:
     16              We do automatic release tests for embOS. These tests are done with the
     17              CPU_KS32C50100. You will find drivers for additional CPUs, which are used
     18              by our customers. These drivers have also been   tested at least one time,
     19              but they are not part of our periodic automatic release tests. Therefore
     20              it might happen, that you encounter a problem with these additional drivers.
     21          */
     22          
     23          #include "RTOS.H"
     24          #include "2410addr.h"
     25          #include "2410lib.h"
     26          #include "ANPRO10Const.h"
     27          #include "TSNConstants.h"
     28          #include "Def.h"
     29          #include "FixedVariables.h"

   \                                 In segment DATA_AN, at 0x31fff010
   \   unsigned int volatile __data LastOSError
   \                     LastOSError:
   \   00000000                      DS8 4

   \                                 In segment DATA_AN, at 0x31fff01c
   \   char __data LastOSErrorTask[32]
   \                     LastOSErrorTask:
   \   00000000                      DS8 32
     30          #if NETWORK==1
     31          #include "netif\cs8900if.h"
     32          #endif
     33          #include <time.h>
     34          typedef struct {
     35              int   IncNum;
     36              U16   IncCntUp;
     37              U16   IncCntDown;
     38          } IncMessage;
     39          
     40          extern short CurrentDeviceId;
     41          extern int OS_FSys;
     42          volatile U16  TXUADData[8];
     43          U8    ADChannel = 0 ;
     44          extern OS_MAILBOX IncMailBox;
     45          volatile U16   Inc1CntUp   =0;
     46          volatile U16   Inc1CntDown =0;
     47          volatile U16   Inc2CntUp   =0;
     48          volatile U16   Inc2CntDown =0;
     49          
     50          
     51          typedef struct {
     52              unsigned EnableStart:1;
     53              unsigned ReadStart:1;
     54              unsigned StdBM:1;
     55              unsigned SelMux:3;
     56              unsigned PrScVl:8;
     57              unsigned PrScEn:1;
     58              unsigned ECFlg:1;
     59              //unsigned Dummy:16;
     60          }ADCConStruct;
     61          
     62          unsigned KbdIntCnt = 0;
     63          unsigned ADIntCnt = 0;

   \                                 In segment DATA_Z, align 1, align-sorted
     64          volatile unsigned char TouchKeyPressed = 0;                 //status for the touch key
   \                     TouchKeyPressed:
   \   00000000                      DS8 1
     65          ADCConStruct *ADCCon = (ADCConStruct*)&rADCCON;
     66          
     67          extern void HandleUARTInterrupt(int Port);
     68          //#ifndef ANBOOTLOADER
     69          extern OS_TASK *ReadTouchKey;                           /* Task control blocks */
     70          extern OS_TASK *ExternAlarmSilence;                     /* Task control blocks */
     71          #if (NETWORK==1)
     72          extern OS_TASK *HandleCS8900;                           /* Task control blocks */
     73          #endif
     74          //#endif
     75          
     76          void OS_USER_irq_func(void);
     77          
     78          
     79          /*
     80          **********************************************************************
     81          *
     82          *                    Configuration
     83          *
     84          **********************************************************************
     85          */
     86          
     87          /* Select UART for embOSView, set baudrate,
     88               define clock frequency for CPU used
     89          
     90               If you do not want (or can not due to hardware limitations) to dedicate
     91               a UART to embOSView, please define OS_UART to -1
     92          */
     93          
     94          #ifndef CPU_S3C2410
     95          //#error "This file is for S3C2410 CPU"
     96          #endif
     97          
     98          
     99          /*********************************************************************
    100          *
    101          *         Non HW dependent configuration defaults
    102          *
    103          **********************************************************************
    104          */
    105          
    106          #ifndef OS_TICK_FREQ
    107              #define OS_TICK_FREQ 1000
    108          #endif
    109          
    110          #ifndef USE_CACHE
    111              #define USE_CACHE 1   /* 0: No chache */
    112          #endif
    113          
    114          
    115          
    116          #ifndef OS_BAUDRATE
    117              #define OS_BAUDRATE 38400
    118          #endif
    119          
    120          #ifndef OS_RAMVECT
    121              #define OS_RAMVECT 0
    122          #endif
    123          
    124          
    125          
    126          #define TIMER_PRESCALE0  1              /* prescaler for timer frequency */
    127          #define TIMER_PRESCALE1  5            /* prescaler for timer frequency */
    128          #define TIMER_RELOAD       (OS_FSys/8/(TIMER_PRESCALE0+1)/OS_TICK_FREQ)
    129          #define TIMER0_START  ( ( 1 << 3 ) | 1 ) // Reload and start
    130          #define TIMER0_UPDATE ( ( 1 << 1 ) )
    131          
    132          
    133          #define TIMER2_START  ( ( 0 << 15 ) | (1 << 12 )) // One shot and start
    134          #define TIMER2_UPDATE ( ( 1 << 13 ) )
    135          #define TIMER3_START  ( ( 0 << 19 ) | (1 << 16 )) // One shot and start
    136          #define TIMER3_UPDATE ( ( 1 << 17 ) )
    137          
    138          /*
    139          **********************************************************************
    140          *
    141          *                    OS_InitHW
    142          *
    143          **********************************************************************
    144          
    145          Initialize the hardware required for the OS to run. This will work
    146          on any target hardware, but may have to be tailored a little
    147          (regarding the clock frequency). Of course the same holds true
    148          if for some reason you choose to use an other timer.
    149          */
    150          

   \                                 In segment CODE, align 4, keep-with-next
    151          void OS_InitHW(void) {
   \                     OS_InitHW:
   \   00000000   70002DE9           PUSH     {R4-R6}
    152              rINTMSK    = 0xffffffff;     // Mask timer interrupt
   \   00000004   0800A0E3           MOV      R0,#+8
   \   00000008   4A0480E3           ORR      R0,R0,#0x4A000000
   \   0000000C   0010E0E3           MVN      R1,#+0
   \   00000010   001080E5           STR      R1,[R0, #+0]
    153              rINTSUBMSK = 0x7ff;
   \   00000014   141080E3           ORR      R1,R0,#0x14
   \   00000018   FF20A0E3           MOV      R2,#+255
   \   0000001C   702E82E3           ORR      R2,R2,#0x700
   \   00000020   002081E5           STR      R2,[R1, #+0]
    154              rSUBSRCPND = 0;
   \   00000024   0020A0E3           MOV      R2,#+0
   \   00000028   103080E3           ORR      R3,R0,#0x10
   \   0000002C   002083E5           STR      R2,[R3, #+0]
    155          
    156          
    157          
    158          
    159          #if OS_RAMVECT
    160              {
    161                  unsigned int vec;
    162                  unsigned int *vector;
    163                  extern void OS_IRQ_SERVICE(void);
    164                  OS_DI();
    165                  vector = (unsigned int*) 0x18;
    166                  vec = (((unsigned int)&OS_IRQ_SERVICE - (unsigned int)vector - 8) >> 2);
    167                  vec |= 0xea000000; /* add opcode for B instruction */
    168                  *vector = vec;
    169                  OS_EI();
    170              }
    171          #endif
    172          
    173          
    174          
    175              rTCFG0  = TIMER_PRESCALE0 | ( TIMER_PRESCALE1 << 8 ) | ( 0 << 16 );
   \   00000030   5134A0E3           MOV      R3,#+1358954496
    176              rTCNTB0 = TIMER_RELOAD;
   \   00000034   ........           LDR      R4,??DataTable4  ;; 0x10624dd3
   \   00000038   01C0A0E3           MOV      R12,#+1
   \   0000003C   50CE8CE3           ORR      R12,R12,#0x500
   \   00000040   00C083E5           STR      R12,[R3, #+0]
   \   00000044   ........           LDR      R3,??DataTable5  ;; OS_FSys
   \   00000048   003093E5           LDR      R3,[R3, #+0]
   \   0000004C   43C1A0E1           ASR      R12,R3,#+2
   \   00000050   AC3E83E0           ADD      R3,R3,R12, LSR #+29
   \   00000054   C331A0E1           ASR      R3,R3,#+3
   \   00000058   0CC0A0E3           MOV      R12,#+12
   \   0000005C   51C48CE3           ORR      R12,R12,#0x51000000
   \   00000060   A33F83E0           ADD      R3,R3,R3, LSR #+31
   \   00000064   C330A0E1           ASR      R3,R3,#+1
   \   00000068   9453C6E0           SMULL    R5,R6,R4,R3
   \   0000006C   4663A0E1           ASR      R6,R6,#+6
   \   00000070   A33F86E0           ADD      R3,R6,R3, LSR #+31
   \   00000074   00308CE5           STR      R3,[R12, #+0]
    177              rTCNTB2 = 0xFFFF;
   \   00000078   FF30A0E3           MOV      R3,#+255
   \   0000007C   FF3C83E3           ORR      R3,R3,#0xFF00
   \   00000080   18408CE2           ADD      R4,R12,#+24
   \   00000084   ........           STR      R3,[R4], #+4
    178              rTCMPB2 = 0xFFFF;
   \   00000088   ........           STR      R3,[R4], #+8
    179              rTCNTB3 = 0xFFFF;
   \   0000008C   003084E5           STR      R3,[R4, #+0]
    180              rTCMPB3 = 0xFFFF;
   \   00000090   044084E3           ORR      R4,R4,#0x4
   \   00000094   003084E5           STR      R3,[R4, #+0]
    181              //rTCMPB0 = TIMER_RELOAD;
    182              switch ( CurrentDeviceId ) {
   \   00000098   0C419FE5           LDR      R4,??OS_InitHW_0  ;; CurrentDeviceId
   \   0000009C   703680E2           ADD      R3,R0,#+117440512
   \   000000A0   F040D4E1           LDRSH    R4,[R4, #+0]
   \   000000A4   204054E2           SUBS     R4,R4,#+32
   \   000000A8   0200000A           BEQ      ??OS_InitHW_1
   \   000000AC   104054E2           SUBS     R4,R4,#+16
   \   000000B0   0600000A           BEQ      ??OS_InitHW_2
   \   000000B4   090000EA           B        ??OS_InitHW_3
    183              case DEVICE_TCU:    // TCU
    184                  rTCON   = TIMER0_UPDATE | TIMER2_UPDATE | TIMER3_UPDATE;
   \                     ??OS_InitHW_1:
   \   000000B8   0240A0E3           MOV      R4,#+2
   \   000000BC   884B84E3           ORR      R4,R4,#0x22000
   \   000000C0   004083E5           STR      R4,[R3, #+0]
    185                  rTCON   = TIMER0_START | TIMER2_START | TIMER3_START;   // Start timer 0,2,3.  0 shall be in reload mode
   \   000000C4   0940A0E3           MOV      R4,#+9
   \   000000C8   444B84E3           ORR      R4,R4,#0x11000
   \   000000CC   020000EA           B        ??OS_InitHW_4
    186                  break;
    187              case DEVICE_TDU:    // TDU
    188                  rTCON   = TIMER0_UPDATE;
   \                     ??OS_InitHW_2:
   \   000000D0   0240A0E3           MOV      R4,#+2
   \   000000D4   004083E5           STR      R4,[R3, #+0]
    189                  rTCON   = TIMER0_START; // Start timer 0 in reload mode
   \   000000D8   0940A0E3           MOV      R4,#+9
   \                     ??OS_InitHW_4:
   \   000000DC   004083E5           STR      R4,[R3, #+0]
    190                  break;
    191              }
    192          
    193          
    194              rINTPND = 0x00000000;    /* Clear pending interrupts */
   \                     ??OS_InitHW_3:
   \   000000E0   083080E2           ADD      R3,R0,#+8
   \   000000E4   002083E5           STR      R2,[R3, #+0]
    195          
    196          
    197              //*((unsigned*)0x1c) = (unsigned)OS_fiq_handler;                   //Timer0 FIQ interrupt
    198          
    199              //*((unsigned*)0x1c) |= 0xea000000; /* add opcode for B instruction */
    200              rINTMOD = 0x00000000;
   \   000000E8   043040E2           SUB      R3,R0,#+4
   \   000000EC   002083E5           STR      R2,[R3, #+0]
    201              //rINTMOD |= BIT_TIMER0;
    202              rINTMSK &= ~(BIT_TIMER0);   // Mask timer interrupt
   \   000000F0   003090E5           LDR      R3,[R0, #+0]
   \   000000F4   402EE0E3           MVN      R2,#+1024
   \   000000F8   033002E0           AND      R3,R2,R3
   \   000000FC   003080E5           STR      R3,[R0, #+0]
    203          
    204              // Start con to embOSView
    205              OS_COM_Init();
    206              // start AD for touchscreen //AStmark ADU/TCU must be checked for int setup AD/touch
    207              //rADCDLY=(50000);  // ADC Start or Interval Delay
    208              rADCDLY= 50000; // ADC Start or Interval Delay
   \   00000100   E03680E2           ADD      R3,R0,#+234881024
   \   00000104   5040A0E3           MOV      R4,#+80
   \   00000108   C34C84E3           ORR      R4,R4,#0xC300
   \   0000010C   ........           STR      R4,[R3], #-4
    209              // Enable Prescaler,Prescaler,AIN5/7 fix,Normal,Disable read start,No operation
    210              rADCTSC = (0<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(0<<2)|3;//Original
   \   00000110   D340A0E3           MOV      R4,#+211
   \   00000114   004083E5           STR      R4,[R3, #+0]
    211              rADCCON = (1<<14)|(255<<6)|(0<<3)|(0<<2)|(0<<1)|(1); // Was befor rADCTSC
   \   00000118   5834A0E3           MOV      R3,#+1476395008
   \   0000011C   C140A0E3           MOV      R4,#+193
   \   00000120   7F4C84E3           ORR      R4,R4,#0x7F00
   \   00000124   004083E5           STR      R4,[R3, #+0]
    212          
    213          
    214              // Down,YM:GND,YP:AIN5,XM:Hi-z,XP:AIN7,XP pullup En,Normal,Waiting for interrupt mode
    215              //pISR_ADC=(unsigned)Adc_or_TsAuto;
    216              rINTMSK &= ~(BIT_ADC);
   \   00000128   003090E5           LDR      R3,[R0, #+0]
    217              switch ( GlobalDeviceHWId ) {
   \   0000012C   7C409FE5           LDR      R4,??OS_InitHW_0+0x4  ;; GlobalDeviceHWId
   \   00000130   8330A0E1           LSL      R3,R3,#+1
   \   00000134   A330A0E1           LSR      R3,R3,#+1
   \   00000138   003080E5           STR      R3,[R0, #+0]
   \   0000013C   F040D4E1           LDRSH    R4,[R4, #+0]
   \   00000140   A430A0E3           MOV      R3,#+164
   \   00000144   563483E3           ORR      R3,R3,#0x56000000
   \   00000148   010054E3           CMP      R4,#+1
   \   0000014C   0900009A           BLS      ??OS_InitHW_5
   \   00000150   024044E2           SUB      R4,R4,#+2
   \   00000154   010054E3           CMP      R4,#+1
   \   00000158   0E00008A           BHI      ??OS_InitHW_6
    218              case TDU_R1:
    219              case TDU_R2:
    220          #if (NETWORK == 1)
    221                  rEINTMASK  &= ~(BIT_SUB_EINT16 );// original EINT4
   \   0000015C   002093E5           LDR      R2,[R3, #+0]
   \   00000160   402BC2E3           BIC      R2,R2,#0x10000
   \   00000164   002083E5           STR      R2,[R3, #+0]
    222          #endif
    223                  rINTSUBMSK &= ~(BIT_SUB_TC | BIT_SUB_ADC);
   \   00000168   002091E5           LDR      R2,[R1, #+0]
   \   0000016C   602EC2E3           BIC      R2,R2,#0x600
   \   00000170   002081E5           STR      R2,[R1, #+0]
   \   00000174   070000EA           B        ??OS_InitHW_6
    224                  break;
    225              case TCU_R1:
    226              case TCU_R2:
    227                  rINTSUBMSK &= ~BIT_SUB_ADC;
   \                     ??OS_InitHW_5:
   \   00000178   004091E5           LDR      R4,[R1, #+0]
   \   0000017C   042002E0           AND      R2,R2,R4
   \   00000180   002081E5           STR      R2,[R1, #+0]
    228          #if (NETWORK == 1)
    229                  rEINTMASK  &= ~(BIT_SUB_EINT4 | BIT_SUB_EINT16 );// original EINT4
   \   00000184   001093E5           LDR      R1,[R3, #+0]
   \   00000188   1020E0E3           MVN      R2,#+16
   \   0000018C   402BC2E3           BIC      R2,R2,#0x10000
   \   00000190   011002E0           AND      R1,R2,R1
   \   00000194   001083E5           STR      R1,[R3, #+0]
    230          #else
    231                  rEINTMASK  &= ~(BIT_SUB_EINT4 );
    232          #endif
    233              }
    234              rINTMSK &= ~(BIT_EINT4_7 | BIT_EINT8_23);
   \                     ??OS_InitHW_6:
   \   00000198   001090E5           LDR      R1,[R0, #+0]
   \   0000019C   3010C1E3           BIC      R1,R1,#0x30
   \   000001A0   001080E5           STR      R1,[R0, #+0]
    235          
    236          }
   \   000001A4   7000BDE8           POP      {R4-R6}
   \   000001A8   1EFF2FE1           BX       LR               ;; return
   \                     ??OS_InitHW_0:
   \   000001AC   ........           DC32     CurrentDeviceId
   \   000001B0   ........           DC32     GlobalDeviceHWId
    237          
    238          
    239          
    240          /*
    241          **********************************************************************
    242          *
    243          *                     Idle task  (OS_Idle)
    244          *
    245          *
    246          **********************************************************************
    247          
    248           Please note:
    249           This is basically the "core" of the idle task.
    250           This core loop can be changed, but:
    251           The idle task does not have a stack of its own, therefor no
    252           functionality should be implemented that relies on the stack
    253           to be preserved. However, a simple program loop can be programmed
    254           (like toggeling an output or incrementing a counter)
    255          */

   \                                 In segment CODE, align 4, keep-with-next
    256          void OS_Idle(void) {     // Idle task: No task is ready to exec
    257              while ( 1 ) {
   \                     OS_Idle:
   \                     ??OS_Idle_0:
   \   00000000   FEFFFFEA           B        ??OS_Idle_0
    258              }
    259          }
    260          
    261          /*
    262          **********************************************************************
    263          *
    264          *                    Get time [cycles]
    265          *
    266          **********************************************************************
    267          
    268              This routine is required for task-info via embOS Viewer.
    269              It returns the system time in clock cycles.
    270          */
    271          
    272          #define HW_TIMER rTCNTB0
    273          #define HW_TIMER_INTERRUPT_PENDING() (rINTPND & BIT_TIMER0)
    274          

   \                                 In segment CODE, align 4, keep-with-next
    275          OS_U32 OS_GetTime_Cycles(void) {
   \                     OS_GetTime_Cycles:
   \   00000000   30002DE9           PUSH     {R4,R5}
    276              unsigned int t_cnt = TIMER_RELOAD - HW_TIMER;
   \   00000004   ........           LDR      R12,??DataTable4  ;; 0x10624dd3
   \   00000008   0C00A0E3           MOV      R0,#+12
   \   0000000C   510480E3           ORR      R0,R0,#0x51000000
   \   00000010   002090E5           LDR      R2,[R0, #+0]
   \   00000014   ........           LDR      R0,??DataTable5  ;; OS_FSys
   \   00000018   000090E5           LDR      R0,[R0, #+0]
   \   0000001C   4011A0E1           ASR      R1,R0,#+2
   \   00000020   A11E80E0           ADD      R1,R0,R1, LSR #+29
   \   00000024   C111A0E1           ASR      R1,R1,#+3
   \   00000028   A13F81E0           ADD      R3,R1,R1, LSR #+31
   \   0000002C   C330A0E1           ASR      R3,R3,#+1
   \   00000030   9C43C5E0           SMULL    R4,R5,R12,R3
    277              OS_U32 time = OS_Time;
   \   00000034   50409FE5           LDR      R4,??OS_GetTime_Cycles_0  ;; OS_Time
   \   00000038   4553A0E1           ASR      R5,R5,#+6
   \   0000003C   00C094E5           LDR      R12,[R4, #+0]
    278              if ( HW_TIMER_INTERRUPT_PENDING() ) {
   \   00000040   1040A0E3           MOV      R4,#+16
   \   00000044   4A4484E3           ORR      R4,R4,#0x4A000000
   \   00000048   004094E5           LDR      R4,[R4, #+0]
   \   0000004C   A33F85E0           ADD      R3,R5,R3, LSR #+31
   \   00000050   022043E0           SUB      R2,R3,R2
   \   00000054   400E14E3           TST      R4,#0x400
   \   00000058   0400000A           BEQ      ??OS_GetTime_Cycles_1
    279                  t_cnt = TIMER_RELOAD - HW_TIMER;
   \   0000005C   0C20A0E3           MOV      R2,#+12
   \   00000060   512482E3           ORR      R2,R2,#0x51000000
   \   00000064   002092E5           LDR      R2,[R2, #+0]
    280                  time++;
   \   00000068   01C08CE2           ADD      R12,R12,#+1
   \   0000006C   022043E0           SUB      R2,R3,R2
    281              }
    282              return(OS_FSys/TIMER_PRESCALE0/OS_TICK_FREQ)*time  + t_cnt;
   \                     ??OS_GetTime_Cycles_1:
   \   00000070   ........           LDR      R1,??DataTable4  ;; 0x10624dd3
   \   00000074   9130C4E0           SMULL    R3,R4,R1,R0
   \   00000078   4443A0E1           ASR      R4,R4,#+6
   \   0000007C   A00F84E0           ADD      R0,R4,R0, LSR #+31
   \   00000080   3000BDE8           POP      {R4,R5}
   \   00000084   9C2020E0           MLA      R0,R12,R0,R2
   \   00000088   1EFF2FE1           BX       LR               ;; return
   \                     ??OS_GetTime_Cycles_0:
   \   0000008C   ........           DC32     OS_Time
    283          }
    284          
    285          
    286          /*
    287          **********************************************************************
    288          *
    289          *                    OS_ConvertCycles2us
    290          *
    291          **********************************************************************
    292          
    293          Purpose:
    294               Convert Cycles into micro seconds. (For profiling only)
    295          
    296               If you have a clock frequency which is not a multiple of 1 MHz,
    297               you may have to modify this routine in order to get proper
    298               diagonstics.
    299          Please note:
    300               This routine is required for profiling only.
    301               It does not affect operation of the OS.
    302          */
    303          

   \                                 In segment CODE, align 4, keep-with-next
    304          OS_U32 OS_ConvertCycles2us(OS_U32 Cycles) {
    305              Cycles *= TIMER_PRESCALE0;              /* eliminate effect of prescaler */
    306              return(Cycles/(OS_FSys/1000000));
   \                     OS_ConvertCycles2us:
   \   00000000   ........           LDR      R1,??DataTable5  ;; OS_FSys
   \   00000004   20209FE5           LDR      R2,??OS_ConvertCycles2us_0  ;; 0x431bde83
   \   00000008   00402DE9           PUSH     {LR}
   \   0000000C   001091E5           LDR      R1,[R1, #+0]
   \   00000010   9231CCE0           SMULL    R3,R12,R2,R1
   \   00000014   4CC9A0E1           ASR      R12,R12,#+18
   \   00000018   A11F8CE0           ADD      R1,R12,R1, LSR #+31
   \   0000001C   ........           _BLF     ??divu32_a,??rA??divu32_a
   \   00000020   0040BDE8           POP      {LR}
   \   00000024   0100A0E1           MOV      R0,R1
   \   00000028   1EFF2FE1           BX       LR               ;; return
   \                     ??OS_ConvertCycles2us_0:
   \   0000002C   83DE1B43           DC32     0x431bde83
    307          }
    308          
    309          /*********************************************************************
    310          *
    311          *          Communication (UART)
    312          *
    313          **********************************************************************
    314          */
    315          
    316          #if (OS_UART!=-1)
    317              #if (OS_UART==1)
    318                  #define INTOFF_UART      INTOFF_UART1
    319                  #define UART_PENDING     BIT_UART1
    320                  #define UART_SUBMASK     (BIT_SUB_TXD1 | BIT_SUB_RXD1)
    321                  #define UART_SUB_RX      BIT_SUB_RXD1
    322                  #define UART_SUB_TX      BIT_SUB_TXD1
    323                  #define UART_STATUS      rUTRSTAT1
    324                  #define UART_RXBUF       rURXH1
    325                  #define UART_TXBUF       rUTXH1
    326                  #define UART_LINECON     rULCON1
    327                  #define UART_CONTROL     rUCON1
    328                  #define UART_BAUD        rUBRDIV1
    329              #elif (OS_UART==0)
    330                  #define INTOFF_UART      INTOFF_UART0
    331                  #define UART_PENDING     BIT_UART0
    332                  #define UART_SUBMASK     (BIT_SUB_TXD0 | BIT_SUB_RXD0)
    333                  #define UART_SUB_RX      BIT_SUB_RXD0
    334                  #define UART_SUB_TX      BIT_SUB_TXD0
    335                  #define UART_STATUS      rUTRSTAT0
    336                  #define UART_RXBUF       rURXH0
    337                  #define UART_TXBUF       rUTXH0
    338                  #define UART_LINECON     rULCON0
    339                  #define UART_CONTROL     rUCON0
    340                  #define UART_BAUD        rUBRDIV0
    341              #endif
    342          
    343          void OS_COM_Init(void) {
    344              UART_CONTROL = 0x00;
    345              UART_LINECON = 0x03;
    346              UART_CONTROL = 0x85; // RxTimeout and Interrupt request or polling mode
    347              UART_BAUD = (OS_FSys/4)/(16*OS_BAUDRATE)-1 ;
    348              rINTMSK    &= ~UART_PENDING;
    349              rINTSUBMSK &= ~UART_SUBMASK;
    350          }
    351          
    352          void OS_ISR_rx(void) {
    353              unsigned UartStatus = UART_STATUS;
    354              if ( UartStatus & 0x01 ) {
    355                  unsigned char RxBuf = UART_RXBUF;
    356                  OS_OnRx(RxBuf);
    357                  //UART_TXBUF = RxBuf;
    358              }
    359          }
    360          
    361          void OS_ISR_tx(void) {
    362              OS_OnTx();
    363          }
    364          
    365          void OS_COM_Send1(OS_U8 c) {
    366              UART_TXBUF = c;
    367          }
    368          
    369          #else  /* UART handlers not defined, using dummys */
    370          

   \                                 In segment CODE, align 4, keep-with-next
    371          void OS_COM_Init(void) {}
   \                     OS_COM_Init:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   \                                 In segment CODE, align 4, keep-with-next
    372          void OS_COM_Send1(OS_U8 c) {
   \                     OS_COM_Send1:
   \   00000000   00402DE9           PUSH     {LR}
    373              OS_USEPARA(c);
    374              OS_COM_ClearTxActive();  /* let OS know that transmitter is not busy */
   \   00000004   ........           _BLF     OS_COM_ClearTxActive,??OS_COM_ClearTxActive??rA
    375          }
   \   00000008   0040BDE8           POP      {LR}
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    376          
    377          #endif
    378          

   \                                 In segment CODE, align 4, keep-with-next
    379          __swi __arm int swi_handler(int a, int b)
    380          {
    381          #ifdef S2TXU
    382              static OS_TASKID CurrentTask;
    383              CurrentTask = OS_GetTaskID();
   \                     swi_handler:
   \   00000000   30009FE5           LDR      R0,??swi_handler_0  ;; OS_pCurrentTask
   \   00000004   10402DE9           PUSH     {R4,LR}
   \   00000008   000090E5           LDR      R0,[R0, #+0]
    384              if ( CurrentTask ) {
   \   0000000C   28409FE5           LDR      R4,??swi_handler_0+0x4  ;; 0x31fff010
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0300000A           BEQ      ??swi_handler_1
    385                  strncpy(LastOSErrorTask,CurrentTask->Name,TASK_NAME_LENGTH);
   \   00000018   181090E5           LDR      R1,[R0, #+24]
   \   0000001C   2020A0E3           MOV      R2,#+32
   \   00000020   0C0084E2           ADD      R0,R4,#+12
   \   00000024   ........           _BLF     strncpy,??strncpy??rA
    386              }
    387              LastOSError = 0xf1;
   \                     ??swi_handler_1:
   \   00000028   F100A0E3           MOV      R0,#+241
   \   0000002C   000084E5           STR      R0,[R4, #+0]
    388              return 0;
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   1080FDE8           LDM      SP!,{R4,PC}^     ;; return
   \                     ??swi_handler_0:
   \   00000038   ........           DC32     OS_pCurrentTask
   \   0000003C   10F0FF31           DC32     0x31fff010
    389              //asm ("MOVS pc, lr");
    390          #endif
    391          }
    392          
    393          #if 0 // hkim
    394          __irq __arm void undef_handler(void)
    395          {
    396          #ifdef S2TXU
    397              static OS_TASKID CurrentTask;
    398              CurrentTask = OS_GetTaskID();
    399              if ( CurrentTask ) {
    400                  strncpy(LastOSErrorTask,CurrentTask->Name,TASK_NAME_LENGTH);
    401              }
    402              LastOSError = 0xf2;
    403              asm ("MOVS pc, lr");
    404          #endif
    405          }
    406          __irq __arm void prefetch_handler(void)
    407          {
    408          #ifdef S2TXU
    409              static OS_TASKID CurrentTask;
    410              CurrentTask = OS_GetTaskID();
    411              if ( CurrentTask ) {
    412                  strncpy(LastOSErrorTask,CurrentTask->Name,TASK_NAME_LENGTH);
    413              }
    414              LastOSError = 0xf3;
    415              asm ("SUBS pc,lr,#4");
    416          #endif
    417          }
    418          
    419          __irq __arm void data_handler(void)
    420          {
    421          #ifdef S2TXU
    422              static OS_TASKID CurrentTask;
    423              CurrentTask = OS_GetTaskID();
    424              if ( CurrentTask ) {
    425                  strncpy(LastOSErrorTask,CurrentTask->Name,TASK_NAME_LENGTH);
    426              }
    427              LastOSError = 0xf4;
    428              asm ("SUBS pc,lr,#8");
    429          #endif
    430          }
    431          #endif // hkim
    432          

   \                                 In segment CODE, align 4, keep-with-next
    433          __irq __arm void fiq_handler(void)
    434          {
    435          }
   \                     fiq_handler:
   \   00000000   04F05EE2           SUBS     PC,LR,#+4        ;; return
    436          
    437          
    438          volatile  time_t FastTime   =0;
    439          volatile  time_t CurrentTime=0;
    440          volatile  time_t RunningTime=0;
    441          
    442          
    443          /*
    444          **********************************************************************
    445          *
    446          *                    OS_irq_handler
    447          *
    448          **********************************************************************
    449          
    450          Purpose:
    451               Detect reason for IRQ and call correspondig service routine.
    452          
    453          Please note:
    454               If you allow nesting, bits in __INTPND must be cleared before
    455               calling OS_EnterNestableInterrupt.
    456          */
    457          #define rTEST     (*(volatile unsigned *)(0x30000040))
    458          volatile int IrqCnt = 0;
    459          volatile int DefaultIrqCnt = 0;

   \                                 In segment DATA_Z, align 4, align-sorted
    460          volatile int InTimerFlag = 0;
   \                     InTimerFlag:
   \   00000000                      DS8 4

   \                                 In segment DATA_I, align 4, align-sorted
   \                     TXUADData:
   \   00000000                      DS8 16
   \   00000010                      REQUIRE `?<Initializer for TXUADData>`
   \                     Inc1CntUp:
   \   00000010                      DS8 2
   \   00000012                      REQUIRE `?<Initializer for Inc1CntUp>`
   \                     Inc1CntDown:
   \   00000012                      DS8 2
   \   00000014                      REQUIRE `?<Initializer for Inc1CntDown>`
   \                     Inc2CntUp:
   \   00000014                      DS8 2
   \   00000016                      REQUIRE `?<Initializer for Inc2CntUp>`
   \                     Inc2CntDown:
   \   00000016                      DS8 2
   \   00000018                      REQUIRE `?<Initializer for Inc2CntDown>`
   \                     KbdIntCnt:
   \   00000018                      DS8 4
   \   0000001C                      REQUIRE `?<Initializer for KbdIntCnt>`
   \                     ADIntCnt:
   \   0000001C                      DS8 4
   \   00000020                      REQUIRE `?<Initializer for ADIntCnt>`
   \                     ADCCon:
   \   00000020                      DS8 4
   \   00000024                      REQUIRE `?<Initializer for ADCCon>`
   \                     FastTime:
   \   00000024                      DS8 4
   \   00000028                      REQUIRE `?<Initializer for FastTime>`
   \                     CurrentTime:
   \   00000028                      DS8 4
   \   0000002C                      REQUIRE `?<Initializer for CurrentTime>`
   \                     RunningTime:
   \   0000002C                      DS8 4
   \   00000030                      REQUIRE `?<Initializer for RunningTime>`
   \                     IrqCnt:
   \   00000030                      DS8 4
   \   00000034                      REQUIRE `?<Initializer for IrqCnt>`
   \                     DefaultIrqCnt:
   \   00000034                      DS8 4
   \   00000038                      REQUIRE `?<Initializer for DefaultIrqCnt>`
    461          volatile int IsDown      = 0;
   \                     IsDown:
   \   00000038                      DS8 4
   \   0000003C                      REQUIRE `?<Initializer for IsDown>`
    462          volatile int TCCnt           = 0;
   \                     TCCnt:
   \   0000003C                      DS8 4
   \   00000040                      REQUIRE `?<Initializer for TCCnt>`
   \                     ADChannel:
   \   00000040                      DS8 1
   \   00000041                      REQUIRE `?<Initializer for ADChannel>`

   \                                 In segment CODE, align 4, keep-with-next
    463          void OS_irq_handler(void) {
   \                     OS_irq_handler:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    464              unsigned IntSource;
    465              unsigned IntOffset;
    466              OS_EnterInterrupt();
   \   00000004   2C469FE5           LDR      R4,??OS_irq_handler_2  ;; OS_Counters
    467              IntSource    = rINTPND;
    468              IntOffset    = rINTOFFSET;
    469          
    470              //OS_USER_irq_func();
    471          
    472              IrqCnt++;
   \   00000008   2C569FE5           LDR      R5,??OS_irq_handler_2+0x4  ;; TXUADData
   \   0000000C   10D04DE2           SUB      SP,SP,#+16
   \   00000010   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000014   1020A0E3           MOV      R2,#+16
   \   00000018   4A2482E3           ORR      R2,R2,#0x4A000000
   \   0000001C   010080E2           ADD      R0,R0,#+1
   \   00000020   0000C4E5           STRB     R0,[R4, #+0]
   \   00000024   0100D4E5           LDRB     R0,[R4, #+1]
    473              switch ( IntOffset ) {
   \   00000028   407EA0E3           MOV      R7,#+1024
   \   0000002C   4A84A0E3           MOV      R8,#+1241513984
   \   00000030   011080E2           ADD      R1,R0,#+1
   \   00000034   0110C4E5           STRB     R1,[R4, #+1]
   \   00000038   002092E5           LDR      R2,[R2, #+0]
   \   0000003C   1400A0E3           MOV      R0,#+20
   \   00000040   00208DE5           STR      R2,[SP, #+0]
   \   00000044   4A0480E3           ORR      R0,R0,#0x4A000000
   \   00000048   002090E5           LDR      R2,[R0, #+0]
   \   0000004C   300095E5           LDR      R0,[R5, #+48]
   \   00000050   109088E3           ORR      R9,R8,#0x10
   \   00000054   010080E2           ADD      R0,R0,#+1
   \   00000058   300085E5           STR      R0,[R5, #+48]
   \   0000005C   0400A0E3           MOV      R0,#+4
   \   00000060   0060A0E3           MOV      R6,#+0
   \   00000064   1F0052E3           CMP      R2,#+31
   \   00000068   6901008A           BHI      ??OS_irq_handler_3
   \   0000006C   023F8FE2           ADR      R3,??OS_irq_handler_0
   \   00000070   8220A0E1           MOV      R2,R2, LSL #+1
   \   00000074   B23093E1           LDRH     R3,[R3, R2]
   \   00000078   03F18FE0           ADD      PC,PC,R3, LSL #+2
   \                     ??OS_irq_handler_0:
   \   0000007C   4E0154015A01       DC16     +334,+340,+346,+351
   \              5F01        
   \   00000084   450045006501       DC16     +69,+69,+357,+357
   \              6501        
   \   0000008C   650165012800       DC16     +357,+357,+40,+357
   \              6501        
   \   00000094   650165016501       DC16     +357,+357,+357,+34
   \              2200        
   \   0000009C   650165016501       DC16     +357,+357,+357,+357
   \              6501        
   \   000000A4   650165016501       DC16     +357,+357,+357,+28
   \              1C00        
   \   000000AC   650165016501       DC16     +357,+357,+357,+357
   \              6501        
   \   000000B4   0F0065016501       DC16     +15,+357,+357,+200
   \              C800        
    474          #if (OS_UART != 0)
    475              case INTOFF_UART0:
    476                  ClearPending(BIT_UART0);
   \                     ??OS_irq_handler_4:
   \   000000BC   4005A0E3           MOV      R0,#+268435456
   \   000000C0   000088E5           STR      R0,[R8, #+0]
   \   000000C4   000089E5           STR      R0,[R9, #+0]
   \   000000C8   000099E5           LDR      R0,[R9, #+0]
    477                  HandleUARTInterrupt(0);
   \   000000CC   0000A0E3           MOV      R0,#+0
   \                     ??OS_irq_handler_5:
   \   000000D0   ........           _BLF     HandleUARTInterrupt,??HandleUARTInterrupt??rA
    478                  //OS_LeaveInterrupt();
    479                  //return;
    480                  break;
    481          #endif
    482          #if (OS_UART != 1)
    483              case INTOFF_UART1:
    484                  ClearPending(BIT_UART1);
    485                  HandleUARTInterrupt(1);
    486                  //OS_LeaveInterrupt();
    487                  //return;
    488                  break;
    489          #endif
    490              case INTOFF_UART2:
    491                  ClearPending(BIT_UART2);
    492                  HandleUARTInterrupt(2);
    493                  //OS_LeaveInterrupt();
    494                  //return;
    495                  break;
    496          #if ((OS_UART == 0) || (OS_UART == 1))
    497              case INTOFF_UART:               // UART for embOSView
    498                  ClearPending(UART_PENDING);
    499                  {
    500                      unsigned IntSubSource = rSUBSRCPND;
    501                      unsigned InsSubMask   = rINTSUBMSK;
    502                      if ( IntSubSource & UART_SUB_RX ) {
    503                          rSUBSRCPND = UART_SUB_RX;
    504                          OS_ISR_rx();
    505                      }
    506                      if ( IntSubSource & UART_SUB_TX ) {
    507                          rSUBSRCPND = UART_SUB_TX;
    508                          OS_ISR_tx();
    509                      }
    510                  }
    511                  // OS_LeaveInterruptNoSwitch();
    512                  // return;
    513                  OS_LeaveInterrupt();
    514                  return;
    515          #endif
    516              case INTOFF_TIMER0:             // Timer for OS
    517                  // Clear interrupt controller service pending bit.
    518                  ClearPending(BIT_TIMER0);
    519                  if ( FastTime++ >= 1000 ) {
    520                      FastTime = 0;
    521                      CurrentTime++;
    522                      RunningTime++;
    523                  }
    524                  OS_HandleTick();
    525                  OS_LeaveInterrupt();
    526                  return;
    527              case INTOFF_4_7:
    528              case INTOFF_8_23:
    529                  {
    530                      U32 IntRequest = rEINTPEND;
    531                      rEINTPEND = IntRequest;
    532          
    533                      for (U32 BitOffset=4; BitOffset <= 23; BitOffset++ ) {
    534                          U32 BitMask = (1 << BitOffset) & IntRequest;
    535                          if ( BitMask ) {
    536                              switch ( BitOffset ) {
    537                              case INTOFF_SILENCE:
    538                                  // For external silence
    539                                  if ( ExternAlarmSilence ) {
    540                                      OS_SignalEvent(EXTERNAL_ALARM_SILENCE,ExternAlarmSilence);
    541                                  }
    542                                  break;
    543                              case INTOFF_IC1_UP  :
    544                                  rTCON   &= ~TIMER2_START;   // Stop timer 2
    545                                  Inc1CntUp = 0xffff - rTCNTO2;
    546                                  rTCNTO2   = 0;
    547                                  rTCON   |= TIMER2_UPDATE;
    548                                  rTCON   &= ~TIMER2_UPDATE;
    549                                  rTCON   |= TIMER2_START;    // Start timer 2
    550                                  break;
    551                              case INTOFF_IC1_DOWN:
    552                                  rTCON   &= ~TIMER2_START;   // Stop timer 2
    553                                  Inc1CntDown = 0xffff - rTCNTO2;
    554                                  rTCNTO2 = 0;
    555                                  rTCON   |= TIMER2_UPDATE;
    556                                  rTCON   &= ~TIMER2_UPDATE;
    557                                  rTCON   |= TIMER2_START;    // Start timer 2
    558                                  {
    559                                      IncMessage Msg;
    560                                      Msg.IncNum      = 1;
    561                                      Msg.IncCntUp    = Inc1CntUp;
    562                                      Msg.IncCntDown  = Inc1CntDown;
    563                                      OS_PutMailCond(&IncMailBox,&Msg);
    564                                  }
    565                                  break;
    566                              case INTOFF_IC2_UP  :
    567                                  rTCON   &= ~TIMER3_START;   // Stop timer 3
    568                                  Inc2CntUp = 0xffff - rTCNTO3;
    569                                  rTCNTO3   = 0;
    570                                  rTCON   |= TIMER3_UPDATE;
    571                                  rTCON   &= ~TIMER3_UPDATE;
    572                                  rTCON   |= TIMER3_START;    // Start timer 3
    573                                  break;
    574                              case INTOFF_IC2_DOWN:
    575                                  rTCON   &= ~TIMER3_START;   // Stop timer 3
    576                                  Inc2CntDown = 0xffff - rTCNTO3;
    577                                  rTCNTO3 = 0;
    578                                  rTCON   |= TIMER3_UPDATE;
    579                                  rTCON   &= ~TIMER3_UPDATE;
    580                                  rTCON   |= TIMER3_START;    // Start timer 3
    581                                  {
    582                                      IncMessage Msg;
    583                                      Msg.IncNum      = 2;
    584                                      Msg.IncCntUp    = Inc2CntUp;
    585                                      Msg.IncCntDown  = Inc2CntDown;
    586                                      OS_PutMailCond(&IncMailBox,&Msg);
    587                                  }
    588                                  break;
    589                              case INTOFF_CS8900:
    590          #if (NETWORK==1)
    591                                  if (HandleCS8900) {
    592                                      OS_SignalEvent(NETWORK_IRQ_SIGNAL,HandleCS8900);
    593                                  }
    594          #ifdef __NET_USE_ACTIVE_HIGH_INTERRUPT__
    595                                  rEINTMASK |= BIT_SUB_EINT16; // mask
    596          #endif
    597          #endif
    598                                  break;
    599                              }
    600                          }
    601                      }
    602                      ClearPending(IntSource);
    603                  }
    604                  break;
    605              case    INTOFF_ADC:            //ADC / Touchscreen
    606                  ClearPending(BIT_ADC);
    607                  {
    608                      unsigned IntSubSource = rSUBSRCPND;
    609          
    610                      if ( IntSubSource &  BIT_SUB_TC ) {          // TC(Touch screen Control) Interrupt
    611                          ADIntCnt = 0;
    612                          rSUBSRCPND = BIT_SUB_TC;
    613                          if ( rADCTSC & 0x100 ) {
    614                              //TouchKeyPressed = 0 ; //key up
    615                              //OS_RetriggerTimer(&TouchTimeOutTimer);
    616                              rADCTSC &= 0xff;    // Set stylus down interrupt
    617                              if ( ReadTouchKey ) {
    618                                  OS_SignalEvent(TOUCH_SCREEN_UP,ReadTouchKey);
    619                              }
    620                          } else {
    621                              //rADCTSC &= 0xff;  // Set stylus down interrupt
    622                              // <Auto X-Position and Y-Position Read>
    623                              rADCTSC=(0<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(1<<2)|(0);
    624                              // Stylus Down,Don't care,Don't care,Don't care,Don't care,XP pullup Dis,Auto,No operation
    625          
    626                              rADCCON |= 0x1; // Start Auto conversion
    627          
    628                              while ( rADCCON & 0x1 );         //check if Enable_start is low
    629                              while ( !(0x8000 & rADCCON) ); // Check ECFLG
    630          
    631                              TXUADData[7] = (0x3ff & rADCDAT0) ; // Catch the position
    632                              TXUADData[5] = (0x3ff & rADCDAT1) ;
    633                              rADCTSC=(1<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(0<<2)|(1<<1) | 1;
    634                              // Stylus Up,Don't care,Don't care,Don't care,Don't care,XP pullup En,Normal,Waiting mode
    635                              rADCCON |= 0x1;                                                         // Start Auto conversion
    636          
    637                              if ( ReadTouchKey ) {
    638                                  OS_SignalEvent(TOUCH_SCREEN_DOWN,ReadTouchKey);
    639                              }
    640                              KbdIntCnt++;
    641                              TCCnt = 5;
    642                              OS_LeaveInterruptNoSwitch();
    643                              return;
    644                          }
    645                      }
    646                      if ( IntSubSource &  BIT_SUB_ADC ) {    // AD converter
    647                          rSUBSRCPND = BIT_SUB_ADC;
    648                          U16 ADVal  = rADCDAT0;
    649                          // Is not normal ADC?
    650                          if ( ADVal & 0x4000 ) {
    651                              TCCnt = 5;
    652                              TXUADData[7] = (0x3ff & ADVal) ;    // Catch the possition
    653                              TXUADData[5] = (0x3ff & rADCDAT1) ;
    654                              // Stylus up = 1
    655                              if ( ADVal & 0x8000 ) {
    656                                  if ( IsDown ) {
    657                                      IsDown = 0;
    658                                      if ( ReadTouchKey ) {
    659                                          OS_SignalEvent(TOUCH_SCREEN_UP,ReadTouchKey);
    660                                      }
    661                                  }
    662                              } else {
    663                                  if ( !IsDown ) {
    664                                      IsDown = 1;
    665                                      if ( ReadTouchKey ) {
    666                                          OS_SignalEvent(TOUCH_SCREEN_DOWN,ReadTouchKey);
    667                                      }
    668                                  }
    669                              }
    670                              // rADCTSC=(1<<8)|(1<<7)|(1<<6)|(0<<5)|(1<<4)|(0<<3)|(0<<2)|(1<<1) | 1;
    671                              // Stylus Up,Don't care,Don't care,Don't care,Don't care,XP pullup En,Normal,Waiting mode
    672                              //rADCCON |= 0x1;                                                           // Start Auto conversion
    673                          } else {
    674                              if ( TCCnt ) {
    675                                  TCCnt--;
    676                              } else {
    677                                  TXUADData[ADChannel] = (ADVal & 0x3ff);
    678                                  if ( ++ADChannel == 5 ) {                                           // skip touchscreen
    679                                      ADChannel++;                                                            // go to channel 6
    680                                  } else if ( ADChannel > 6 ) {                                   // finished one round
    681                                      ADChannel = 0;
    682                                  }
    683                                  ADCCon->SelMux  = ADChannel;
    684                              }
    685                          }
    686                      }
    687                  }
    688                  //break;
    689                  break;
    690              case INTOFF_UART_A:
    691                  ClearPending(BIT_EINT0);
    692                  HandleUARTInterrupt(3);
    693                  break;
    694              case INTOFF_UART_B:
    695                  ClearPending(BIT_EINT1);
    696                  HandleUARTInterrupt(4);
    697                  break;
    698              case INTOFF_UART_C:
    699                  ClearPending(BIT_EINT2);
    700                  HandleUARTInterrupt(5);
    701                  break;
    702              case INTOFF_UART_D:
    703                  ClearPending(BIT_EINT3);
    704                  HandleUARTInterrupt(6);
    705                  break;
    706              default:
    707                  DefaultIrqCnt++;
    708                  OS_LeaveInterrupt();
    709                  return;
    710          
    711              }
    712              OS_LeaveInterruptNoSwitch();
   \                     ??OS_irq_handler_6:
   \   000000D4   0100D4E5           LDRB     R0,[R4, #+1]
   \   000000D8   010040E2           SUB      R0,R0,#+1
   \   000000DC   0100C4E5           STRB     R0,[R4, #+1]
   \                     ??OS_irq_handler_7:
   \   000000E0   0000D4E5           LDRB     R0,[R4, #+0]
   \   000000E4   010040E2           SUB      R0,R0,#+1
   \   000000E8   0000C4E5           STRB     R0,[R4, #+0]
    713          }
   \   000000EC   260000EA           B        ??OS_irq_handler_8
   \                     ??OS_irq_handler_9:
   \   000000F0   8008A0E3           MOV      R0,#+8388608
   \   000000F4   000088E5           STR      R0,[R8, #+0]
   \   000000F8   000089E5           STR      R0,[R9, #+0]
   \   000000FC   000099E5           LDR      R0,[R9, #+0]
   \   00000100   0100A0E3           MOV      R0,#+1
   \   00000104   F1FFFFEA           B        ??OS_irq_handler_5
   \                     ??OS_irq_handler_10:
   \   00000108   800CA0E3           MOV      R0,#+32768
   \   0000010C   000088E5           STR      R0,[R8, #+0]
   \   00000110   000089E5           STR      R0,[R9, #+0]
   \   00000114   000099E5           LDR      R0,[R9, #+0]
   \   00000118   0200A0E3           MOV      R0,#+2
   \   0000011C   EBFFFFEA           B        ??OS_irq_handler_5
   \                     ??OS_irq_handler_11:
   \   00000120   007088E5           STR      R7,[R8, #+0]
   \   00000124   007089E5           STR      R7,[R9, #+0]
   \   00000128   000099E5           LDR      R0,[R9, #+0]
   \   0000012C   240095E5           LDR      R0,[R5, #+36]
   \   00000130   011080E2           ADD      R1,R0,#+1
   \   00000134   241085E5           STR      R1,[R5, #+36]
   \   00000138   FA0F50E3           CMP      R0,#+1000
   \   0000013C   060000BA           BLT      ??OS_irq_handler_12
   \   00000140   246085E5           STR      R6,[R5, #+36]
   \   00000144   280095E5           LDR      R0,[R5, #+40]
   \   00000148   010080E2           ADD      R0,R0,#+1
   \   0000014C   280085E5           STR      R0,[R5, #+40]
   \   00000150   2C0095E5           LDR      R0,[R5, #+44]
   \   00000154   010080E2           ADD      R0,R0,#+1
   \   00000158   2C0085E5           STR      R0,[R5, #+44]
   \                     ??OS_irq_handler_12:
   \   0000015C   ........           _BLF     OS_HandleTick,??OS_HandleTick??rA
   \   00000160   0100D4E5           LDRB     R0,[R4, #+1]
   \   00000164   010040E2           SUB      R0,R0,#+1
   \   00000168   0100C4E5           STRB     R0,[R4, #+1]
   \   0000016C   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000170   010050E3           CMP      R0,#+1
   \   00000174   D9FFFF1A           BNE      ??OS_irq_handler_7
   \                     ??OS_irq_handler_13:
   \   00000178   C0049FE5           LDR      R0,??OS_irq_handler_2+0x8  ;; OS_Pending
   \   0000017C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000180   000050E3           CMP      R0,#+0
   \   00000184   D5FFFF0A           BEQ      ??OS_irq_handler_7
   \   00000188   ........           _BLF     OS_SwitchFromInt,??OS_SwitchFromInt??rA
   \                     ??OS_irq_handler_8:
   \   0000018C   FF4FBDE8           POP      {R0-R11,LR}
   \   00000190   1EFF2FE1           BX       LR
   \                     ??OS_irq_handler_14:
   \   00000194   A820A0E3           MOV      R2,#+168
   \   00000198   562482E3           ORR      R2,R2,#0x56000000
   \   0000019C   002092E5           LDR      R2,[R2, #+0]
   \   000001A0   A810A0E3           MOV      R1,#+168
   \   000001A4   0C208DE5           STR      R2,[SP, #+12]
   \   000001A8   561481E3           ORR      R1,R1,#0x56000000
   \   000001AC   002081E5           STR      R2,[R1, #+0]
   \   000001B0   0470A0E3           MOV      R7,#+4
   \   000001B4   38A0A0E3           MOV      R10,#+56
   \   000001B8   51A48AE3           ORR      R10,R10,#0x51000000
   \                     ??OS_irq_handler_15:
   \   000001BC   0C109DE5           LDR      R1,[SP, #+12]
   \   000001C0   0100A0E3           MOV      R0,#+1
   \   000001C4   100711E1           TST      R1,R0, LSL R7
   \   000001C8   6B00000A           BEQ      ??OS_irq_handler_16
   \   000001CC   70049FE5           LDR      R0,??OS_irq_handler_2+0xC  ;; IncMailBox
   \   000001D0   803BE0E3           MVN      R3,#+131072
   \   000001D4   FF10A0E3           MOV      R1,#+255
   \   000001D8   FF1C81E3           ORR      R1,R1,#0xFF00
   \   000001DC   40BB83E2           ADD      R11,R3,#+65536
   \   000001E0   3020CAE3           BIC      R2,R10,#0x30
   \   000001E4   04C047E2           SUB      R12,R7,#+4
   \   000001E8   0C005CE3           CMP      R12,#+12
   \   000001EC   6200008A           BHI      ??OS_irq_handler_16
   \   000001F0   01EF8FE2           ADR      LR,??OS_irq_handler_1
   \   000001F4   0CE0DEE7           LDRB     LR,[LR, R12]
   \   000001F8   0EF18FE0           ADD      PC,PC,LR, LSL #+2
   \                     ??OS_irq_handler_1:
   \   000001FC   03051833           DC8      +3,+5,+24,+51
   \   00000200   435F5F5F           DC8      +67,+95,+95,+95
   \   00000204   5F5F5F5F           DC8      +95,+95,+95,+95
   \   00000208   59000000           DC8      +89,+0,+0,+0
   \                     ??OS_irq_handler_17:
   \   0000020C   34049FE5           LDR      R0,??OS_irq_handler_2+0x10  ;; ExternAlarmSilence
   \   00000210   540000EA           B        ??OS_irq_handler_18
   \                     ??OS_irq_handler_19:
   \   00000214   000092E5           LDR      R0,[R2, #+0]
   \   00000218   400DC0E3           BIC      R0,R0,#0x1000
   \   0000021C   000082E5           STR      R0,[R2, #+0]
   \   00000220   240082E3           ORR      R0,R2,#0x24
   \   00000224   000090E5           LDR      R0,[R0, #+0]
   \   00000228   000041E0           SUB      R0,R1,R0
   \   0000022C   B001C5E1           STRH     R0,[R5, #+16]
   \   00000230   240082E3           ORR      R0,R2,#0x24
   \   00000234   006080E5           STR      R6,[R0, #+0]
   \   00000238   000092E5           LDR      R0,[R2, #+0]
   \   0000023C   800D80E3           ORR      R0,R0,#0x2000
   \   00000240   000082E5           STR      R0,[R2, #+0]
   \   00000244   000092E5           LDR      R0,[R2, #+0]
   \   00000248   800DC0E3           BIC      R0,R0,#0x2000
   \   0000024C   000082E5           STR      R0,[R2, #+0]
   \   00000250   000092E5           LDR      R0,[R2, #+0]
   \   00000254   400D80E3           ORR      R0,R0,#0x1000
   \                     ??OS_irq_handler_20:
   \   00000258   000082E5           STR      R0,[R2, #+0]
   \   0000025C   460000EA           B        ??OS_irq_handler_16
   \                     ??OS_irq_handler_21:
   \   00000260   003092E5           LDR      R3,[R2, #+0]
   \   00000264   403DC3E3           BIC      R3,R3,#0x1000
   \   00000268   003082E5           STR      R3,[R2, #+0]
   \   0000026C   243082E3           ORR      R3,R2,#0x24
   \   00000270   003093E5           LDR      R3,[R3, #+0]
   \   00000274   031041E0           SUB      R1,R1,R3
   \   00000278   B211C5E1           STRH     R1,[R5, #+18]
   \   0000027C   241082E3           ORR      R1,R2,#0x24
   \   00000280   006081E5           STR      R6,[R1, #+0]
   \   00000284   001092E5           LDR      R1,[R2, #+0]
   \   00000288   801D81E3           ORR      R1,R1,#0x2000
   \   0000028C   001082E5           STR      R1,[R2, #+0]
   \   00000290   001092E5           LDR      R1,[R2, #+0]
   \   00000294   801DC1E3           BIC      R1,R1,#0x2000
   \   00000298   001082E5           STR      R1,[R2, #+0]
   \   0000029C   001092E5           LDR      R1,[R2, #+0]
   \   000002A0   401D81E3           ORR      R1,R1,#0x1000
   \   000002A4   001082E5           STR      R1,[R2, #+0]
   \   000002A8   0120A0E3           MOV      R2,#+1
   \   000002AC   04208DE5           STR      R2,[SP, #+4]
   \   000002B0   B021D5E1           LDRH     R2,[R5, #+16]
   \   000002B4   B820CDE1           STRH     R2,[SP, #+8]
   \   000002B8   B221D5E1           LDRH     R2,[R5, #+18]
   \                     ??OS_irq_handler_22:
   \   000002BC   04108DE2           ADD      R1,SP,#+4
   \   000002C0   BA20CDE1           STRH     R2,[SP, #+10]
   \   000002C4   ........           _BLF     OS_PutMailCond,??OS_PutMailCond??rA
   \   000002C8   2B0000EA           B        ??OS_irq_handler_16
   \                     ??OS_irq_handler_23:
   \   000002CC   000092E5           LDR      R0,[R2, #+0]
   \   000002D0   00000BE0           AND      R0,R11,R0
   \   000002D4   000082E5           STR      R0,[R2, #+0]
   \   000002D8   00009AE5           LDR      R0,[R10, #+0]
   \   000002DC   000041E0           SUB      R0,R1,R0
   \   000002E0   B401C5E1           STRH     R0,[R5, #+20]
   \   000002E4   00608AE5           STR      R6,[R10, #+0]
   \   000002E8   000092E5           LDR      R0,[R2, #+0]
   \   000002EC   800B80E3           ORR      R0,R0,#0x20000
   \   000002F0   000082E5           STR      R0,[R2, #+0]
   \   000002F4   000092E5           LDR      R0,[R2, #+0]
   \   000002F8   000003E0           AND      R0,R3,R0
   \   000002FC   000082E5           STR      R0,[R2, #+0]
   \   00000300   000092E5           LDR      R0,[R2, #+0]
   \   00000304   400B80E3           ORR      R0,R0,#0x10000
   \   00000308   D2FFFFEA           B        ??OS_irq_handler_20
   \                     ??OS_irq_handler_24:
   \   0000030C   00C092E5           LDR      R12,[R2, #+0]
   \   00000310   0CB00BE0           AND      R11,R11,R12
   \   00000314   00B082E5           STR      R11,[R2, #+0]
   \   00000318   00B09AE5           LDR      R11,[R10, #+0]
   \   0000031C   0B1041E0           SUB      R1,R1,R11
   \   00000320   B611C5E1           STRH     R1,[R5, #+22]
   \   00000324   00608AE5           STR      R6,[R10, #+0]
   \   00000328   001092E5           LDR      R1,[R2, #+0]
   \   0000032C   801B81E3           ORR      R1,R1,#0x20000
   \   00000330   001082E5           STR      R1,[R2, #+0]
   \   00000334   001092E5           LDR      R1,[R2, #+0]
   \   00000338   011003E0           AND      R1,R3,R1
   \   0000033C   001082E5           STR      R1,[R2, #+0]
   \   00000340   001092E5           LDR      R1,[R2, #+0]
   \   00000344   401B81E3           ORR      R1,R1,#0x10000
   \   00000348   001082E5           STR      R1,[R2, #+0]
   \   0000034C   0220A0E3           MOV      R2,#+2
   \   00000350   04208DE5           STR      R2,[SP, #+4]
   \   00000354   B421D5E1           LDRH     R2,[R5, #+20]
   \   00000358   B820CDE1           STRH     R2,[SP, #+8]
   \   0000035C   B621D5E1           LDRH     R2,[R5, #+22]
   \   00000360   D5FFFFEA           B        ??OS_irq_handler_22
   \                     ??OS_irq_handler_25:
   \   00000364   E0029FE5           LDR      R0,??OS_irq_handler_2+0x14  ;; HandleCS8900
   \                     ??OS_irq_handler_18:
   \   00000368   001090E5           LDR      R1,[R0, #+0]
   \   0000036C   000051E3           CMP      R1,#+0
   \   00000370   0100000A           BEQ      ??OS_irq_handler_16
   \   00000374   0100A0E3           MOV      R0,#+1
   \   00000378   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
   \                     ??OS_irq_handler_16:
   \   0000037C   017087E2           ADD      R7,R7,#+1
   \   00000380   180057E3           CMP      R7,#+24
   \   00000384   8CFFFF3A           BCC      ??OS_irq_handler_15
   \   00000388   00009DE5           LDR      R0,[SP, #+0]
   \   0000038C   000088E5           STR      R0,[R8, #+0]
   \   00000390   00009DE5           LDR      R0,[SP, #+0]
   \   00000394   000089E5           STR      R0,[R9, #+0]
   \   00000398   000099E5           LDR      R0,[R9, #+0]
   \   0000039C   4CFFFFEA           B        ??OS_irq_handler_6
   \                     ??OS_irq_handler_26:
   \   000003A0   8004A0E3           MOV      R0,#-2147483648
   \   000003A4   000088E5           STR      R0,[R8, #+0]
   \   000003A8   000089E5           STR      R0,[R9, #+0]
   \   000003AC   000099E5           LDR      R0,[R9, #+0]
   \   000003B0   98929FE5           LDR      R9,??OS_irq_handler_2+0x18  ;; ReadTouchKey
   \   000003B4   181088E3           ORR      R1,R8,#0x18
   \   000003B8   001091E5           LDR      R1,[R1, #+0]
   \   000003BC   018047E2           SUB      R8,R7,#+1
   \   000003C0   00108DE5           STR      R1,[SP, #+0]
   \   000003C4   18A0A0E3           MOV      R10,#+24
   \   000003C8   4AA48AE3           ORR      R10,R10,#0x4A000000
   \   000003CC   05B0A0E3           MOV      R11,#+5
   \   000003D0   800F11E3           TST      R1,#0x200
   \   000003D4   0F00000A           BEQ      ??OS_irq_handler_27
   \   000003D8   1C6085E5           STR      R6,[R5, #+28]
   \   000003DC   800FA0E3           MOV      R0,#+512
   \   000003E0   00008AE5           STR      R0,[R10, #+0]
   \   000003E4   0400A0E3           MOV      R0,#+4
   \   000003E8   580480E3           ORR      R0,R0,#0x58000000
   \   000003EC   001090E5           LDR      R1,[R0, #+0]
   \   000003F0   400F11E3           TST      R1,#0x100
   \   000003F4   2600000A           BEQ      ??OS_irq_handler_28
   \   000003F8   001090E5           LDR      R1,[R0, #+0]
   \   000003FC   FF1001E2           AND      R1,R1,#0xFF
   \   00000400   001080E5           STR      R1,[R0, #+0]
   \   00000404   001099E5           LDR      R1,[R9, #+0]
   \   00000408   000051E3           CMP      R1,#+0
   \   0000040C   0100000A           BEQ      ??OS_irq_handler_27
   \   00000410   0100A0E3           MOV      R0,#+1
   \   00000414   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
   \                     ??OS_irq_handler_27:
   \   00000418   00009DE5           LDR      R0,[SP, #+0]
   \   0000041C   400E10E3           TST      R0,#0x400
   \   00000420   2BFFFF0A           BEQ      ??OS_irq_handler_6
   \   00000424   00708AE5           STR      R7,[R10, #+0]
   \   00000428   0C00A0E3           MOV      R0,#+12
   \   0000042C   580480E3           ORR      R0,R0,#0x58000000
   \   00000430   000090E5           LDR      R0,[R0, #+0]
   \   00000434   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000438   2008A0E1           MOV      R0,R0, LSR #+16
   \   0000043C   400C10E3           TST      R0,#0x4000
   \   00000440   3F00000A           BEQ      ??OS_irq_handler_29
   \   00000444   3CB085E5           STR      R11,[R5, #+60]
   \   00000448   001008E0           AND      R1,R8,R0
   \   0000044C   BE10C5E1           STRH     R1,[R5, #+14]
   \   00000450   1010A0E3           MOV      R1,#+16
   \   00000454   581481E3           ORR      R1,R1,#0x58000000
   \   00000458   001091E5           LDR      R1,[R1, #+0]
   \   0000045C   800C10E3           TST      R0,#0x8000
   \   00000460   011008E0           AND      R1,R8,R1
   \   00000464   BA10C5E1           STRH     R1,[R5, #+10]
   \   00000468   380095E5           LDR      R0,[R5, #+56]
   \   0000046C   2B00000A           BEQ      ??OS_irq_handler_30
   \   00000470   000050E3           CMP      R0,#+0
   \   00000474   16FFFF0A           BEQ      ??OS_irq_handler_6
   \   00000478   386085E5           STR      R6,[R5, #+56]
   \   0000047C   001099E5           LDR      R1,[R9, #+0]
   \   00000480   000051E3           CMP      R1,#+0
   \   00000484   12FFFF0A           BEQ      ??OS_irq_handler_6
   \   00000488   0100A0E3           MOV      R0,#+1
   \                     ??OS_irq_handler_31:
   \   0000048C   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
   \   00000490   0FFFFFEA           B        ??OS_irq_handler_6
   \                     ??OS_irq_handler_28:
   \   00000494   D410A0E3           MOV      R1,#+212
   \   00000498   001080E5           STR      R1,[R0, #+0]
   \   0000049C   5814A0E3           MOV      R1,#+1476395008
   \   000004A0   002091E5           LDR      R2,[R1, #+0]
   \   000004A4   012082E3           ORR      R2,R2,#0x1
   \   000004A8   002081E5           STR      R2,[R1, #+0]
   \                     ??OS_irq_handler_32:
   \   000004AC   002091E5           LDR      R2,[R1, #+0]
   \   000004B0   010012E3           TST      R2,#0x1
   \   000004B4   FCFFFF1A           BNE      ??OS_irq_handler_32
   \                     ??OS_irq_handler_33:
   \   000004B8   002091E5           LDR      R2,[R1, #+0]
   \   000004BC   800C12E3           TST      R2,#0x8000
   \   000004C0   FCFFFF0A           BEQ      ??OS_irq_handler_33
   \   000004C4   082080E3           ORR      R2,R0,#0x8
   \   000004C8   002092E5           LDR      R2,[R2, #+0]
   \   000004CC   022008E0           AND      R2,R8,R2
   \   000004D0   BE20C5E1           STRH     R2,[R5, #+14]
   \   000004D4   0C2080E2           ADD      R2,R0,#+12
   \   000004D8   002092E5           LDR      R2,[R2, #+0]
   \   000004DC   022008E0           AND      R2,R8,R2
   \   000004E0   BA20C5E1           STRH     R2,[R5, #+10]
   \   000004E4   8B2FC8E3           BIC      R2,R8,#0x22C
   \   000004E8   002080E5           STR      R2,[R0, #+0]
   \   000004EC   000091E5           LDR      R0,[R1, #+0]
   \   000004F0   010080E3           ORR      R0,R0,#0x1
   \   000004F4   000081E5           STR      R0,[R1, #+0]
   \   000004F8   001099E5           LDR      R1,[R9, #+0]
   \   000004FC   000051E3           CMP      R1,#+0
   \   00000500   0100000A           BEQ      ??OS_irq_handler_34
   \   00000504   0200A0E3           MOV      R0,#+2
   \   00000508   ........           _BLF     OS_SignalEvent,??OS_SignalEvent??rA
   \                     ??OS_irq_handler_34:
   \   0000050C   180095E5           LDR      R0,[R5, #+24]
   \   00000510   010080E2           ADD      R0,R0,#+1
   \   00000514   180085E5           STR      R0,[R5, #+24]
   \   00000518   3CB085E5           STR      R11,[R5, #+60]
   \   0000051C   ECFEFFEA           B        ??OS_irq_handler_6
   \                     ??OS_irq_handler_30:
   \   00000520   000050E3           CMP      R0,#+0
   \   00000524   EAFEFF1A           BNE      ??OS_irq_handler_6
   \   00000528   0100A0E3           MOV      R0,#+1
   \   0000052C   380085E5           STR      R0,[R5, #+56]
   \   00000530   001099E5           LDR      R1,[R9, #+0]
   \   00000534   000051E3           CMP      R1,#+0
   \   00000538   E5FEFF0A           BEQ      ??OS_irq_handler_6
   \   0000053C   0200A0E3           MOV      R0,#+2
   \   00000540   D1FFFFEA           B        ??OS_irq_handler_31
   \                     ??OS_irq_handler_29:
   \   00000544   3C1095E5           LDR      R1,[R5, #+60]
   \   00000548   000051E3           CMP      R1,#+0
   \   0000054C   0300000A           BEQ      ??OS_irq_handler_35
   \   00000550   3C0095E5           LDR      R0,[R5, #+60]
   \   00000554   010040E2           SUB      R0,R0,#+1
   \   00000558   3C0085E5           STR      R0,[R5, #+60]
   \   0000055C   DCFEFFEA           B        ??OS_irq_handler_6
   \                     ??OS_irq_handler_35:
   \   00000560   4010D5E5           LDRB     R1,[R5, #+64]
   \   00000564   000008E0           AND      R0,R8,R0
   \   00000568   812085E0           ADD      R2,R5,R1, LSL #+1
   \   0000056C   B000C2E1           STRH     R0,[R2, #+0]
   \   00000570   010081E2           ADD      R0,R1,#+1
   \   00000574   4000C5E5           STRB     R0,[R5, #+64]
   \   00000578   FF0000E2           AND      R0,R0,#0xFF
   \   0000057C   050050E3           CMP      R0,#+5
   \   00000580   0600A003           MOVEQ    R0,#+6
   \   00000584   4000C505           STRBEQ   R0,[R5, #+64]
   \   00000588   0100000A           BEQ      ??OS_irq_handler_36
   \   0000058C   070050E3           CMP      R0,#+7
   \   00000590   4060C525           STRBCS   R6,[R5, #+64]
   \                     ??OS_irq_handler_36:
   \   00000594   200095E5           LDR      R0,[R5, #+32]
   \   00000598   4020D5E5           LDRB     R2,[R5, #+64]
   \   0000059C   001090E5           LDR      R1,[R0, #+0]
   \   000005A0   3830A0E3           MOV      R3,#+56
   \   000005A4   3810C1E3           BIC      R1,R1,#0x38
   \   000005A8   822103E0           AND      R2,R3,R2, LSL #+3
   \   000005AC   011082E1           ORR      R1,R2,R1
   \   000005B0   001080E5           STR      R1,[R0, #+0]
   \   000005B4   C6FEFFEA           B        ??OS_irq_handler_6
   \                     ??OS_irq_handler_37:
   \   000005B8   0100A0E3           MOV      R0,#+1
   \   000005BC   000088E5           STR      R0,[R8, #+0]
   \   000005C0   000089E5           STR      R0,[R9, #+0]
   \   000005C4   000099E5           LDR      R0,[R9, #+0]
   \   000005C8   0300A0E3           MOV      R0,#+3
   \   000005CC   BFFEFFEA           B        ??OS_irq_handler_5
   \                     ??OS_irq_handler_38:
   \   000005D0   0200A0E3           MOV      R0,#+2
   \   000005D4   000088E5           STR      R0,[R8, #+0]
   \   000005D8   000089E5           STR      R0,[R9, #+0]
   \   000005DC   000099E5           LDR      R0,[R9, #+0]
   \   000005E0   0400A0E3           MOV      R0,#+4
   \   000005E4   B9FEFFEA           B        ??OS_irq_handler_5
   \                     ??OS_irq_handler_39:
   \   000005E8   000088E5           STR      R0,[R8, #+0]
   \   000005EC   000089E5           STR      R0,[R9, #+0]
   \   000005F0   000099E5           LDR      R0,[R9, #+0]
   \   000005F4   0500A0E3           MOV      R0,#+5
   \   000005F8   B4FEFFEA           B        ??OS_irq_handler_5
   \                     ??OS_irq_handler_40:
   \   000005FC   0800A0E3           MOV      R0,#+8
   \   00000600   000088E5           STR      R0,[R8, #+0]
   \   00000604   000089E5           STR      R0,[R9, #+0]
   \   00000608   000099E5           LDR      R0,[R9, #+0]
   \   0000060C   0600A0E3           MOV      R0,#+6
   \   00000610   AEFEFFEA           B        ??OS_irq_handler_5
   \                     ??OS_irq_handler_3:
   \   00000614   340095E5           LDR      R0,[R5, #+52]
   \   00000618   010080E2           ADD      R0,R0,#+1
   \   0000061C   340085E5           STR      R0,[R5, #+52]
   \   00000620   010041E2           SUB      R0,R1,#+1
   \   00000624   0100C4E5           STRB     R0,[R4, #+1]
   \   00000628   0000D4E5           LDRB     R0,[R4, #+0]
   \   0000062C   010050E3           CMP      R0,#+1
   \   00000630   D0FEFF0A           BEQ      ??OS_irq_handler_13
   \   00000634   A9FEFFEA           B        ??OS_irq_handler_7
   \                     ??OS_irq_handler_2:
   \   00000638   ........           DC32     OS_Counters
   \   0000063C   ........           DC32     TXUADData
   \   00000640   ........           DC32     OS_Pending
   \   00000644   ........           DC32     IncMailBox
   \   00000648   ........           DC32     ExternAlarmSilence
   \   0000064C   ........           DC32     HandleCS8900
   \   00000650   ........           DC32     ReadTouchKey

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   D34D6210           DC32     0x10624dd3

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     OS_FSys

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for TXUADData>`:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     `?<Initializer for Inc1CntUp>`:
   \   00000010   0000               DC16 0
   \                     `?<Initializer for Inc1CntDown>`:
   \   00000012   0000               DC16 0
   \                     `?<Initializer for Inc2CntUp>`:
   \   00000014   0000               DC16 0
   \                     `?<Initializer for Inc2CntDown>`:
   \   00000016   0000               DC16 0
   \                     `?<Initializer for KbdIntCnt>`:
   \   00000018   00000000           DC32 0
   \                     `?<Initializer for ADIntCnt>`:
   \   0000001C   00000000           DC32 0
   \                     `?<Initializer for ADCCon>`:
   \   00000020   00000058           DC32 58000000H
   \                     `?<Initializer for FastTime>`:
   \   00000024   00000000           DC32 0
   \                     `?<Initializer for CurrentTime>`:
   \   00000028   00000000           DC32 0
   \                     `?<Initializer for RunningTime>`:
   \   0000002C   00000000           DC32 0
   \                     `?<Initializer for IrqCnt>`:
   \   00000030   00000000           DC32 0
   \                     `?<Initializer for DefaultIrqCnt>`:
   \   00000034   00000000           DC32 0
   \                     `?<Initializer for IsDown>`:
   \   00000038   00000000           DC32 0
   \                     `?<Initializer for TCCnt>`:
   \   0000003C   00000000           DC32 0
   \                     `?<Initializer for ADChannel>`:
   \   00000040   00                 DC8 0
    714          
    715          

   Maximum stack usage in bytes:

     Function            CSTACK
     --------            ------
     OS_COM_Init             0
     OS_COM_Send1            4
     OS_ConvertCycles2us     4
     OS_GetTime_Cycles       8
     OS_Idle                 0
     OS_InitHW              12
     OS_irq_handler         52
     fiq_handler             0
     swi_handler             8


   Segment part sizes:

     Function/Label               Bytes
     --------------               -----
     LastOSError                     4
     LastOSErrorTask                32
     TouchKeyPressed                 1
     OS_InitHW                     436
     ??OS_Idle_0                     4
     OS_GetTime_Cycles             144
     OS_ConvertCycles2us            48
     OS_COM_Init                     4
     OS_COM_Send1                   16
     swi_handler                    64
     fiq_handler                     4
     InTimerFlag                     4
     TXUADData                      65
     OS_irq_handler               1620
     ??DataTable4                    4
     ??DataTable5                    4
     ?<Initializer for TXUADData>   65
      Others                       152

 
 2 476 bytes in segment CODE
    36 bytes in segment DATA_AN
    65 bytes in segment DATA_I
    65 bytes in segment DATA_ID
     5 bytes in segment DATA_Z
    24 bytes in segment INITTAB
 
 2 348 bytes of CODE  memory (+ 152 bytes shared)
    65 bytes of CONST memory
    70 bytes of DATA  memory (+  36 bytes shared)

Errors: none
Warnings: none
