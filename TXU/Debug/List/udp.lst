##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32               14/Sep/2022  15:20:22 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\S2Prog\TXU\lwip-1.4.1\src\core\udp.c              #
#    Command line    =  D:\S2Prog\TXU\lwip-1.4.1\src\core\udp.c --fpu None   #
#                       -D OS_LIBMODE_SP -D CPU_S3C2410 -D OS_RAMVECT=0 -D   #
#                       OS_UART=-1 -D S2TXU -D USE_LZO=1 -D __ARM_LIBRARY__  #
#                       -D WATCHDOG=1 -D NETWORK=1 -lCN                      #
#                       D:\S2Prog\TXU\Debug\List\ -o                         #
#                       D:\S2Prog\TXU\Debug\Obj\ -s9 --debug --cpu_mode arm  #
#                       --endian little --cpu ARM920T --stack_align 4        #
#                       --interwork -e --enable_multibytes --dlib_config     #
#                       "C:\Program Files (x86)\IAR Systems\Embedded         #
#                       Workbench 4.0\arm\LIB\dl4tpainl8n.h" -I              #
#                       D:\S2Prog\TXU\GUI\CORE\ -I D:\S2Prog\TXU\GUI\WM\ -I  #
#                       D:\S2Prog\TXU\GUI\WIDGET\ -I D:\S2Prog\TXU\CONFIG\   #
#                       -I D:\S2Prog\TXU\INC\ -I D:\S2Prog\TXU\..\SHARED\INC #
#                       \ -I D:\S2Prog\TXU\..\SHARED\SRC\ -I                 #
#                       D:\S2Prog\TXU\..\SHARED\LZO\minilzo.210\ -I          #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ -I             #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\include\ipv4\ -I        #
#                       D:\S2Prog\TXU\lwip-1.4.1\src\ -I                     #
#                       D:\S2Prog\TXU\..\SHARED\Database\ -I                 #
#                       D:\S2Prog\TXU\src\ -I "C:\Program Files (x86)\IAR    #
#                       Systems\Embedded Workbench 4.0\arm\INC\"             #
#                       --inline_threshold=2                                 #
#    List file       =  D:\S2Prog\TXU\Debug\List\udp.lst                     #
#    Object file     =  D:\S2Prog\TXU\Debug\Obj\udp.r79                      #
#                                                                            #
#                                                                            #
##############################################################################

D:\S2Prog\TXU\lwip-1.4.1\src\core\udp.c
      1          /**
      2           * @file
      3           * User Datagram Protocol module
      4           *
      5           */
      6          
      7          /*
      8           * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
      9           * All rights reserved.
     10           *
     11           * Redistribution and use in source and binary forms, with or without modification,
     12           * are permitted provided that the following conditions are met:
     13           *
     14           * 1. Redistributions of source code must retain the above copyright notice,
     15           *    this list of conditions and the following disclaimer.
     16           * 2. Redistributions in binary form must reproduce the above copyright notice,
     17           *    this list of conditions and the following disclaimer in the documentation
     18           *    and/or other materials provided with the distribution.
     19           * 3. The name of the author may not be used to endorse or promote products
     20           *    derived from this software without specific prior written permission.
     21           *
     22           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
     23           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     24           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     25           * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     26           * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     27           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     28           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     29           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
     30           * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
     31           * OF SUCH DAMAGE.
     32           *
     33           * This file is part of the lwIP TCP/IP stack.
     34           *
     35           * Author: Adam Dunkels <adam@sics.se>
     36           *
     37           */
     38          
     39          
     40          /* udp.c
     41           *
     42           * The code for the User Datagram Protocol UDP & UDPLite (RFC 3828).
     43           *
     44           */
     45          
     46          /* @todo Check the use of '(struct udp_pcb).chksum_len_rx'!
     47           */
     48          
     49          #include "lwip/opt.h"
     50          
     51          #if LWIP_UDP /* don't build if not configured for use in lwipopts.h */
     52          
     53          #include "lwip/udp.h"
     54          #include "lwip/def.h"
     55          #include "lwip/memp.h"
     56          #include "lwip/inet_chksum.h"
     57          #include "lwip/ip_addr.h"
     58          #include "lwip/netif.h"
     59          #include "lwip/icmp.h"
     60          #include "lwip/stats.h"
     61          #include "lwip/snmp.h"
     62          #include "arch/perf.h"
     63          #include "lwip/dhcp.h"
     64          
     65          #include <string.h>
     66          
     67          #ifndef UDP_LOCAL_PORT_RANGE_START
     68          /* From http://www.iana.org/assignments/port-numbers:
     69             "The Dynamic and/or Private Ports are those from 49152 through 65535" */
     70          #define UDP_LOCAL_PORT_RANGE_START  0xc000
     71          #define UDP_LOCAL_PORT_RANGE_END    0xffff
     72          #define UDP_ENSURE_LOCAL_PORT_RANGE(port) (((port) & ~UDP_LOCAL_PORT_RANGE_START) + UDP_LOCAL_PORT_RANGE_START)
     73          #endif
     74          
     75          /* last local UDP port */

   \                                 In segment DATA_I, align 4, align-sorted
     76          static u16_t udp_port = UDP_LOCAL_PORT_RANGE_START;
   \                     udp_port:
   \   00000000                      DS8 2
   \   00000002                      REQUIRE `?<Initializer for udp_port>`
   \   00000002                      DS8 2
     77          
     78          /* The list of UDP PCBs */
     79          /* exported in udp.h (was static) */
     80          struct udp_pcb *udp_pcbs;
   \                     udp_pcbs:
   \   00000004                      DS8 4
   \   00000008                      REQUIRE `?<Initializer for udp_pcbs>`
     81          
     82          /**
     83           * Initialize this module.
     84           */

   \                                 In segment CODE, align 4, keep-with-next
     85          void
     86          udp_init(void)
     87          {
     88          #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
     89            udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
     90          #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
     91          }
   \                     udp_init:
   \   00000000   1EFF2FE1           BX       LR               ;; return
     92          
     93          /**
     94           * Allocate a new local UDP port.
     95           *
     96           * @return a new (free) local UDP port number
     97           */
     98          static u16_t
     99          udp_new_port(void)
    100          {
    101            u16_t n = 0;
    102            struct udp_pcb *pcb;
    103            
    104          again:
    105            if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    106              udp_port = UDP_LOCAL_PORT_RANGE_START;
    107            }
    108            /* Check all PCBs. */
    109            for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    110              if (pcb->local_port == udp_port) {
    111                if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    112                  return 0;
    113                }
    114                goto again;
    115              }
    116            }
    117            return udp_port;
    118          #if 0
    119            struct udp_pcb *ipcb = udp_pcbs;
    120            while ((ipcb != NULL) && (udp_port != UDP_LOCAL_PORT_RANGE_END)) {
    121              if (ipcb->local_port == udp_port) {
    122                /* port is already used by another udp_pcb */
    123                udp_port++;
    124                /* restart scanning all udp pcbs */
    125                ipcb = udp_pcbs;
    126              } else {
    127                /* go on with next udp pcb */
    128                ipcb = ipcb->next;
    129              }
    130            }
    131            if (ipcb != NULL) {
    132              return 0;
    133            }
    134            return udp_port;
    135          #endif
    136          }
    137          
    138          /**
    139           * Process an incoming UDP datagram.
    140           *
    141           * Given an incoming UDP datagram (as a chain of pbufs) this function
    142           * finds a corresponding UDP PCB and hands over the pbuf to the pcbs
    143           * recv function. If no pcb is found or the datagram is incorrect, the
    144           * pbuf is freed.
    145           *
    146           * @param p pbuf to be demultiplexed to a UDP PCB.
    147           * @param inp network interface on which the datagram was received.
    148           *
    149           */

   \                                 In segment CODE, align 4, keep-with-next
    150          void
    151          udp_input(struct pbuf *p, struct netif *inp)
    152          {
   \                     udp_input:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
    153            struct udp_hdr *udphdr;
    154            struct udp_pcb *pcb, *prev;
    155            struct udp_pcb *uncon_pcb;
    156            struct ip_hdr *iphdr;
    157            u16_t src, dest;
    158            u8_t local_match;
    159            u8_t broadcast;
    160          
    161            PERF_START;
    162          
    163            UDP_STATS_INC(udp.recv);
   \   00000004   ........           LDR      R5,??DataTable3  ;; lwip_stats
   \   00000008   08D04DE2           SUB      SP,SP,#+8
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   BA07D5E1           LDRH     R0,[R5, #+122]
    164          
    165            iphdr = (struct ip_hdr *)p->payload;
    166          
    167            /* Check minimum length (IP header + UDP header)
    168             * and move payload pointer to UDP header */
    169            if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
   \   00000014   0830A0E3           MOV      R3,#+8
   \   00000018   010080E2           ADD      R0,R0,#+1
   \   0000001C   BA07C5E1           STRH     R0,[R5, #+122]
   \   00000020   041094E5           LDR      R1,[R4, #+4]
   \   00000024   04108DE5           STR      R1,[SP, #+4]
   \   00000028   0000D1E5           LDRB     R0,[R1, #+0]
   \   0000002C   B810D4E1           LDRH     R1,[R4, #+8]
   \   00000030   0F2000E2           AND      R2,R0,#0xF
   \   00000034   022183E0           ADD      R2,R3,R2, LSL #+2
   \   00000038   020051E1           CMP      R1,R2
   \   0000003C   080000BA           BLT      ??udp_input_0
   \   00000040   0F0000E2           AND      R0,R0,#0xF
   \   00000044   0001A0E1           LSL      R0,R0,#+2
   \   00000048   001060E2           RSB      R1,R0,#+0
   \   0000004C   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000050   4118A0E1           MOV      R1,R1, ASR #+16
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0300000A           BEQ      ??udp_input_1
    170              /* drop short packets */
    171              LWIP_DEBUGF(UDP_DEBUG,
    172                          ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    173              UDP_STATS_INC(udp.lenerr);
   \                     ??udp_input_0:
   \   00000064   B208D5E1           LDRH     R0,[R5, #+130]
   \   00000068   010080E2           ADD      R0,R0,#+1
   \   0000006C   B208C5E1           STRH     R0,[R5, #+130]
    174              UDP_STATS_INC(udp.drop);
   \   00000070   870000EA           B        ??udp_input_2
    175              snmp_inc_udpinerrors();
    176              pbuf_free(p);
    177              goto end;
    178            }
    179          
    180            udphdr = (struct udp_hdr *)p->payload;
    181          
    182            /* is broadcast packet ? */
    183            broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
   \                     ??udp_input_1:
   \   00000074   34729FE5           LDR      R7,??udp_input_3  ;; current_iphdr_dest
   \   00000078   046094E5           LDR      R6,[R4, #+4]
   \   0000007C   08109DE5           LDR      R1,[SP, #+8]
   \   00000080   000097E5           LDR      R0,[R7, #+0]
    184          
    185            LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
    186          
    187            /* convert src and dest ports to host byte order */
    188            src = ntohs(udphdr->src);
    189            dest = ntohs(udphdr->dest);
    190          
    191            udp_debug_print(udphdr);
    192          
    193            /* print the UDP source and destination */
    194            LWIP_DEBUGF(UDP_DEBUG,
    195                        ("udp (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") <-- "
    196                         "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
    197                         ip4_addr1_16(&iphdr->dest), ip4_addr2_16(&iphdr->dest),
    198                         ip4_addr3_16(&iphdr->dest), ip4_addr4_16(&iphdr->dest), ntohs(udphdr->dest),
    199                         ip4_addr1_16(&iphdr->src), ip4_addr2_16(&iphdr->src),
    200                         ip4_addr3_16(&iphdr->src), ip4_addr4_16(&iphdr->src), ntohs(udphdr->src)));
    201          
    202          #if LWIP_DHCP
    203            pcb = NULL;
    204            /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
    205               the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
    206            if (dest == DHCP_CLIENT_PORT) {
    207              /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    208              if (src == DHCP_SERVER_PORT) {
    209                if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
    210                  /* accept the packe if 
    211                     (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
    212                     - inp->dhcp->pcb->remote == ANY or iphdr->src */
    213                  if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
    214                     ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
    215                    pcb = inp->dhcp->pcb;
    216                  }
    217                }
    218              }
    219            } else
    220          #endif /* LWIP_DHCP */
    221            {
    222              prev = NULL;
    223              local_match = 0;
    224              uncon_pcb = NULL;
    225              /* Iterate through the UDP pcb list for a matching pcb.
    226               * 'Perfect match' pcbs (connected to the remote port & ip address) are
    227               * preferred. If no perfect match is found, the first unconnected pcb that
    228               * matches the local port and ip address gets the datagram. */
    229              for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   \   00000084   28B29FE5           LDR      R11,??udp_input_3+0x4  ;; current_iphdr_src
   \   00000088   ........           _BLF     ip4_addr_isbroadcast,??ip4_addr_isbroadcast??rA
   \   0000008C   0010D6E5           LDRB     R1,[R6, #+0]
   \   00000090   0080A0E1           MOV      R8,R0
   \   00000094   0100D6E5           LDRB     R0,[R6, #+1]
   \   00000098   000481E1           ORR      R0,R1,R0, LSL #+8
   \   0000009C   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000000A0   0210D6E5           LDRB     R1,[R6, #+2]
   \   000000A4   0090A0E1           MOV      R9,R0
   \   000000A8   0300D6E5           LDRB     R0,[R6, #+3]
   \   000000AC   000481E1           ORR      R0,R1,R0, LSL #+8
   \   000000B0   ........           _BLF     lwip_ntohs,??lwip_ntohs??rA
   \   000000B4   ........           LDR      R2,??DataTable6  ;; udp_port
   \   000000B8   0010A0E3           MOV      R1,#+0
   \   000000BC   00108DE5           STR      R1,[SP, #+0]
   \   000000C0   04A092E5           LDR      R10,[R2, #+4]
   \   000000C4   010000EA           B        ??udp_input_4
    230                local_match = 0;
    231                /* print the PCB local and remote address */
    232                LWIP_DEBUGF(UDP_DEBUG,
    233                            ("pcb (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") --- "
    234                             "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
    235                             ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
    236                             ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
    237                             ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
    238                             ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));
    239          
    240                /* compare PCB local addr+port to UDP destination addr+port */
    241                if (pcb->local_port == dest) {
    242                  if (
    243                     (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
    244                     ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
    245          #if LWIP_IGMP
    246                     ip_addr_ismulticast(&current_iphdr_dest) ||
    247          #endif /* LWIP_IGMP */
    248          #if IP_SOF_BROADCAST_RECV
    249                      (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
    250                       (ip_addr_isany(&pcb->local_ip) ||
    251                        ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    252          #else /* IP_SOF_BROADCAST_RECV */
    253                      (broadcast &&
    254                       (ip_addr_isany(&pcb->local_ip) ||
    255                        ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    256          #endif /* IP_SOF_BROADCAST_RECV */ 
    257                    local_match = 1;
    258                    if ((uncon_pcb == NULL) && 
    259                        ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    260                      /* the first unconnected matching PCB */
    261                      uncon_pcb = pcb;
    262                    }
    263                  }
    264                }
    265                /* compare PCB remote addr+port to UDP source addr+port */
    266                if ((local_match != 0) &&
    267                    (pcb->remote_port == src) &&
    268                    (ip_addr_isany(&pcb->remote_ip) ||
    269                     ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    270                  /* the first fully matching PCB */
    271                  if (prev != NULL) {
    272                    /* move the pcb to the front of udp_pcbs so that is
    273                       found faster next time */
    274                    prev->next = pcb->next;
    275                    pcb->next = udp_pcbs;
    276                    udp_pcbs = pcb;
    277                  } else {
    278                    UDP_STATS_INC(udp.cachehit);
    279                  }
    280                  break;
    281                }
    282                prev = pcb;
   \                     ??udp_input_5:
   \   000000C8   00A08DE5           STR      R10,[SP, #+0]
   \   000000CC   0CA09AE5           LDR      R10,[R10, #+12]
   \                     ??udp_input_4:
   \   000000D0   003097E5           LDR      R3,[R7, #+0]
   \   000000D4   00005AE3           CMP      R10,#+0
   \   000000D8   2F00000A           BEQ      ??udp_input_6
   \   000000DC   B2C1DAE1           LDRH     R12,[R10, #+18]
   \   000000E0   00005CE1           CMP      R12,R0
   \   000000E4   F7FFFF1A           BNE      ??udp_input_5
   \   000000E8   00E09AE5           LDR      LR,[R10, #+0]
   \   000000EC   08C0B0E1           MOVS     R12,R8
   \   000000F0   0200001A           BNE      ??udp_input_7
   \   000000F4   00005AE3           CMP      R10,#+0
   \   000000F8   00005E13           CMPNE    LR,#+0
   \   000000FC   0C00000A           BEQ      ??udp_input_8
   \                     ??udp_input_7:
   \   00000100   03005EE1           CMP      LR,R3
   \   00000104   0A00000A           BEQ      ??udp_input_8
   \   00000108   08C0B0E1           MOVS     R12,R8
   \   0000010C   EDFFFF0A           BEQ      ??udp_input_5
   \   00000110   00005AE3           CMP      R10,#+0
   \   00000114   00005E13           CMPNE    LR,#+0
   \   00000118   0500000A           BEQ      ??udp_input_8
   \   0000011C   08C09DE5           LDR      R12,[SP, #+8]
   \   00000120   08C09CE5           LDR      R12,[R12, #+8]
   \   00000124   0EE00CE0           AND      LR,R12,LR
   \   00000128   03300CE0           AND      R3,R12,R3
   \   0000012C   03005EE1           CMP      LR,R3
   \   00000130   E4FFFF1A           BNE      ??udp_input_5
   \                     ??udp_input_8:
   \   00000134   000051E3           CMP      R1,#+0
   \   00000138   1030DA05           LDRBEQ   R3,[R10, #+16]
   \   0000013C   04001303           TSTEQ    R3,#0x4
   \   00000140   B431DAE1           LDRH     R3,[R10, #+20]
   \   00000144   0A10A001           MOVEQ    R1,R10
   \   00000148   090053E1           CMP      R3,R9
   \   0000014C   DDFFFF1A           BNE      ??udp_input_5
   \   00000150   04309AE2           ADDS     R3,R10,#+4
   \   00000154   04309A15           LDRNE    R3,[R10, #+4]
   \   00000158   00005313           CMPNE    R3,#+0
   \   0000015C   00C09B15           LDRNE    R12,[R11, #+0]
   \   00000160   0C005311           CMPNE    R3,R12
   \   00000164   D7FFFF1A           BNE      ??udp_input_5
   \   00000168   00009DE5           LDR      R0,[SP, #+0]
   \   0000016C   000050E3           CMP      R0,#+0
   \   00000170   0500000A           BEQ      ??udp_input_9
   \   00000174   0C109AE5           LDR      R1,[R10, #+12]
   \   00000178   0C1080E5           STR      R1,[R0, #+12]
   \   0000017C   040092E5           LDR      R0,[R2, #+4]
   \   00000180   0C008AE5           STR      R0,[R10, #+12]
   \   00000184   04A082E5           STR      R10,[R2, #+4]
   \   00000188   090000EA           B        ??udp_input_10
   \                     ??udp_input_9:
   \   0000018C   BE08D5E1           LDRH     R0,[R5, #+142]
   \   00000190   010080E2           ADD      R0,R0,#+1
   \   00000194   BE08C5E1           STRH     R0,[R5, #+142]
   \   00000198   050000EA           B        ??udp_input_10
    283              }
    284              /* no fully matching pcb found? then look for an unconnected pcb */
    285              if (pcb == NULL) {
    286                pcb = uncon_pcb;
   \                     ??udp_input_6:
   \   0000019C   01A0B0E1           MOVS     R10,R1
    287              }
    288            }
    289          
    290            /* Check checksum if this is a match or if it was directed at us. */
    291            if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
   \   000001A0   0300001A           BNE      ??udp_input_10
   \   000001A4   08009DE5           LDR      R0,[SP, #+8]
   \   000001A8   040090E5           LDR      R0,[R0, #+4]
   \   000001AC   030050E1           CMP      R0,R3
   \   000001B0   3A00001A           BNE      ??udp_input_11
    292              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
    293          #if LWIP_UDPLITE
    294              if (IPH_PROTO(iphdr) == IP_PROTO_UDPLITE) {
    295                /* Do the UDP Lite checksum */
    296          #if CHECKSUM_CHECK_UDP
    297                u16_t chklen = ntohs(udphdr->len);
    298                if (chklen < sizeof(struct udp_hdr)) {
    299                  if (chklen == 0) {
    300                    /* For UDP-Lite, checksum length of 0 means checksum
    301                       over the complete packet (See RFC 3828 chap. 3.1) */
    302                    chklen = p->tot_len;
    303                  } else {
    304                    /* At least the UDP-Lite header must be covered by the
    305                       checksum! (Again, see RFC 3828 chap. 3.1) */
    306                    UDP_STATS_INC(udp.chkerr);
    307                    UDP_STATS_INC(udp.drop);
    308                    snmp_inc_udpinerrors();
    309                    pbuf_free(p);
    310                    goto end;
    311                  }
    312                }
    313                if (inet_chksum_pseudo_partial(p, &current_iphdr_src, &current_iphdr_dest,
    314                                       IP_PROTO_UDPLITE, p->tot_len, chklen) != 0) {
    315                 LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
    316                             ("udp_input: UDP Lite datagram discarded due to failing checksum\n"));
    317                  UDP_STATS_INC(udp.chkerr);
    318                  UDP_STATS_INC(udp.drop);
    319                  snmp_inc_udpinerrors();
    320                  pbuf_free(p);
    321                  goto end;
    322                }
    323          #endif /* CHECKSUM_CHECK_UDP */
    324              } else
    325          #endif /* LWIP_UDPLITE */
    326              {
    327          #if CHECKSUM_CHECK_UDP
    328                if (udphdr->chksum != 0) {
   \                     ??udp_input_10:
   \   000001B4   0700D6E5           LDRB     R0,[R6, #+7]
   \   000001B8   0610D6E5           LDRB     R1,[R6, #+6]
   \   000001BC   000491E1           ORRS     R0,R1,R0, LSL #+8
   \   000001C0   0D00000A           BEQ      ??udp_input_12
    329                  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
    330                                         IP_PROTO_UDP, p->tot_len) != 0) {
   \   000001C4   B800D4E1           LDRH     R0,[R4, #+8]
   \   000001C8   1130A0E3           MOV      R3,#+17
   \   000001CC   0720A0E1           MOV      R2,R7
   \   000001D0   01002DE9           PUSH     {R0}
   \   000001D4   0B10A0E1           MOV      R1,R11
   \   000001D8   0400A0E1           MOV      R0,R4
   \   000001DC   ........           _BLF     inet_chksum_pseudo,??inet_chksum_pseudo??rA
   \   000001E0   000050E3           CMP      R0,#+0
   \   000001E4   04D08DE2           ADD      SP,SP,#+4
   \   000001E8   0300000A           BEQ      ??udp_input_12
    331                    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
    332                                ("udp_input: UDP datagram discarded due to failing checksum\n"));
    333                    UDP_STATS_INC(udp.chkerr);
   \   000001EC   B008D5E1           LDRH     R0,[R5, #+128]
   \   000001F0   010080E2           ADD      R0,R0,#+1
   \   000001F4   B008C5E1           STRH     R0,[R5, #+128]
    334                    UDP_STATS_INC(udp.drop);
   \   000001F8   250000EA           B        ??udp_input_2
    335                    snmp_inc_udpinerrors();
    336                    pbuf_free(p);
    337                    goto end;
    338                  }
    339                }
    340          #endif /* CHECKSUM_CHECK_UDP */
    341              }
    342              if(pbuf_header(p, -UDP_HLEN)) {
   \                     ??udp_input_12:
   \   000001FC   0710E0E3           MVN      R1,#+7
   \   00000200   0400A0E1           MOV      R0,R4
   \   00000204   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   00000208   000050E3           CMP      R0,#+0
   \   0000020C   2000001A           BNE      ??udp_input_2
    343                /* Can we cope with this failing? Just assert for now */
    344                LWIP_ASSERT("pbuf_header failed\n", 0);
    345                UDP_STATS_INC(udp.drop);
    346                snmp_inc_udpinerrors();
    347                pbuf_free(p);
    348                goto end;
    349              }
    350              if (pcb != NULL) {
   \                     ??udp_input_13:
   \   00000210   00005AE3           CMP      R10,#+0
   \   00000214   0B00000A           BEQ      ??udp_input_14
    351                snmp_inc_udpindatagrams();
    352          #if SO_REUSE && SO_REUSE_RXTOALL
    353                if ((broadcast || ip_addr_ismulticast(&current_iphdr_dest)) &&
    354                    ip_get_option(pcb, SOF_REUSEADDR)) {
    355                  /* pass broadcast- or multicast packets to all multicast pcbs
    356                     if SOF_REUSEADDR is set on the first match */
    357                  struct udp_pcb *mpcb;
    358                  u8_t p_header_changed = 0;
    359                  for (mpcb = udp_pcbs; mpcb != NULL; mpcb = mpcb->next) {
    360                    if (mpcb != pcb) {
    361                      /* compare PCB local addr+port to UDP destination addr+port */
    362                      if ((mpcb->local_port == dest) &&
    363                          ((!broadcast && ip_addr_isany(&mpcb->local_ip)) ||
    364                           ip_addr_cmp(&(mpcb->local_ip), &current_iphdr_dest) ||
    365          #if LWIP_IGMP
    366                           ip_addr_ismulticast(&current_iphdr_dest) ||
    367          #endif /* LWIP_IGMP */
    368          #if IP_SOF_BROADCAST_RECV
    369                           (broadcast && ip_get_option(mpcb, SOF_BROADCAST)))) {
    370          #else  /* IP_SOF_BROADCAST_RECV */
    371                           (broadcast))) {
    372          #endif /* IP_SOF_BROADCAST_RECV */
    373                        /* pass a copy of the packet to all local matches */
    374                        if (mpcb->recv != NULL) {
    375                          struct pbuf *q;
    376                          /* for that, move payload to IP header again */
    377                          if (p_header_changed == 0) {
    378                            pbuf_header(p, (s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
    379                            p_header_changed = 1;
    380                          }
    381                          q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    382                          if (q != NULL) {
    383                            err_t err = pbuf_copy(q, p);
    384                            if (err == ERR_OK) {
    385                              /* move payload to UDP data */
    386                              pbuf_header(q, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
    387                              mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
    388                            }
    389                          }
    390                        }
    391                      }
    392                    }
    393                  }
    394                  if (p_header_changed) {
    395                    /* and move payload to UDP data again */
    396                    pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
    397                  }
    398                }
    399          #endif /* SO_REUSE && SO_REUSE_RXTOALL */
    400                /* callback */
    401                if (pcb->recv != NULL) {
   \   00000218   18509AE5           LDR      R5,[R10, #+24]
   \   0000021C   000055E3           CMP      R5,#+0
   \   00000220   1E00000A           BEQ      ??udp_input_11
    402                  /* now the recv function is responsible for freeing p */
    403                  pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
   \   00000224   00022DE9           PUSH     {R9}
   \   00000228   1C009AE5           LDR      R0,[R10, #+28]
   \   0000022C   0B30A0E1           MOV      R3,R11
   \   00000230   0420A0E1           MOV      R2,R4
   \   00000234   0A10A0E1           MOV      R1,R10
   \   00000238   0FE0A0E1           MOV      LR,PC
   \   0000023C   15FF2FE1           BX       R5
   \   00000240   04D08DE2           ADD      SP,SP,#+4
   \   00000244   170000EA           B        ??udp_input_15
    404                } else {
    405                  /* no recv function registered? then we have to free the pbuf! */
    406                  pbuf_free(p);
    407                  goto end;
    408                }
    409              } else {
    410                LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
    411          
    412          #if LWIP_ICMP
    413                /* No match was found, send ICMP destination port unreachable unless
    414                   destination address was broadcast/multicast. */
    415                if (!broadcast &&
    416                    !ip_addr_ismulticast(&current_iphdr_dest)) {
   \                     ??udp_input_14:
   \   00000248   000058E3           CMP      R8,#+0
   \   0000024C   0D00001A           BNE      ??udp_input_16
   \   00000250   000097E5           LDR      R0,[R7, #+0]
   \   00000254   F00000E2           AND      R0,R0,#0xF0
   \   00000258   E00050E3           CMP      R0,#+224
   \   0000025C   0900000A           BEQ      ??udp_input_16
    417                  /* move payload pointer back to ip header */
    418                  pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
   \   00000260   04009DE5           LDR      R0,[SP, #+4]
   \   00000264   0810A0E3           MOV      R1,#+8
   \   00000268   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000026C   0F0000E2           AND      R0,R0,#0xF
   \   00000270   001181E0           ADD      R1,R1,R0, LSL #+2
   \   00000274   0400A0E1           MOV      R0,R4
   \   00000278   ........           _BLF     pbuf_header,??pbuf_header??rA
    419                  LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
    420                  icmp_dest_unreach(p, ICMP_DUR_PORT);
   \   0000027C   0310A0E3           MOV      R1,#+3
   \   00000280   0400A0E1           MOV      R0,R4
   \   00000284   ........           _BLF     icmp_dest_unreach,??icmp_dest_unreach??rA
    421                }
    422          #endif /* LWIP_ICMP */
    423                UDP_STATS_INC(udp.proterr);
   \                     ??udp_input_16:
   \   00000288   B808D5E1           LDRH     R0,[R5, #+136]
   \   0000028C   010080E2           ADD      R0,R0,#+1
   \   00000290   B808C5E1           STRH     R0,[R5, #+136]
    424                UDP_STATS_INC(udp.drop);
   \                     ??udp_input_2:
   \   00000294   BE07D5E1           LDRH     R0,[R5, #+126]
   \   00000298   010080E2           ADD      R0,R0,#+1
   \   0000029C   BE07C5E1           STRH     R0,[R5, #+126]
    425                snmp_inc_udpnoports();
    426                pbuf_free(p);
    427              }
    428            } else {
    429              pbuf_free(p);
   \                     ??udp_input_11:
   \   000002A0   0400A0E1           MOV      R0,R4
   \   000002A4   ........           _BLF     pbuf_free,??pbuf_free??rA
    430            }
    431          end:
    432            PERF_STOP("udp_input");
    433          }
   \                     ??udp_input_15:
   \   000002A8   F74FBDE8           POP      {R0-R2,R4-R11,LR}
   \   000002AC   1EFF2FE1           BX       LR               ;; return
   \                     ??udp_input_3:
   \   000002B0   ........           DC32     current_iphdr_dest
   \   000002B4   ........           DC32     current_iphdr_src
    434          
    435          /**
    436           * Send data using UDP.
    437           *
    438           * @param pcb UDP PCB used to send the data.
    439           * @param p chain of pbuf's to be sent.
    440           *
    441           * The datagram will be sent to the current remote_ip & remote_port
    442           * stored in pcb. If the pcb is not bound to a port, it will
    443           * automatically be bound to a random port.
    444           *
    445           * @return lwIP error code.
    446           * - ERR_OK. Successful. No error occured.
    447           * - ERR_MEM. Out of memory.
    448           * - ERR_RTE. Could not find route to destination address.
    449           * - More errors could be returned by lower protocol layers.
    450           *
    451           * @see udp_disconnect() udp_sendto()
    452           */

   \                                 In segment CODE, align 4, keep-with-next
    453          err_t
    454          udp_send(struct udp_pcb *pcb, struct pbuf *p)
    455          {
   \                     udp_send:
   \   00000000   00402DE9           PUSH     {LR}
    456            /* send to the packet using remote ip and port stored in the pcb */
    457            return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
   \   00000004   B431D0E1           LDRH     R3,[R0, #+20]
   \   00000008   042080E2           ADD      R2,R0,#+4
   \   0000000C   ........           BL       udp_sendto
   \   00000010   0040BDE8           POP      {LR}
   \   00000014   1EFF2FE1           BX       LR               ;; return
    458          }
    459          
    460          #if LWIP_CHECKSUM_ON_COPY
    461          /** Same as udp_send() but with checksum
    462           */
    463          err_t
    464          udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
    465                          u8_t have_chksum, u16_t chksum)
    466          {
    467            /* send to the packet using remote ip and port stored in the pcb */
    468            return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,
    469              have_chksum, chksum);
    470          }
    471          #endif /* LWIP_CHECKSUM_ON_COPY */
    472          
    473          /**
    474           * Send data to a specified address using UDP.
    475           *
    476           * @param pcb UDP PCB used to send the data.
    477           * @param p chain of pbuf's to be sent.
    478           * @param dst_ip Destination IP address.
    479           * @param dst_port Destination UDP port.
    480           *
    481           * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
    482           *
    483           * If the PCB already has a remote address association, it will
    484           * be restored after the data is sent.
    485           * 
    486           * @return lwIP error code (@see udp_send for possible error codes)
    487           *
    488           * @see udp_disconnect() udp_send()
    489           */

   \                                 In segment CODE, align 4, keep-with-next
    490          err_t
    491          udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
    492            ip_addr_t *dst_ip, u16_t dst_port)
    493          {
   \                     udp_sendto:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
   \   00000010   0370A0E1           MOV      R7,R3
    494          #if LWIP_CHECKSUM_ON_COPY
    495            return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
    496          }
    497          
    498          /** Same as udp_sendto(), but with checksum */
    499          err_t
    500          udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
    501                            u16_t dst_port, u8_t have_chksum, u16_t chksum)
    502          {
    503          #endif /* LWIP_CHECKSUM_ON_COPY */
    504            struct netif *netif;
    505          
    506            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));
    507          
    508            /* find the outgoing network interface for this packet */
    509          #if LWIP_IGMP
    510            netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
    511          #else
    512            netif = ip_route(dst_ip);
   \   00000014   0600A0E1           MOV      R0,R6
   \   00000018   ........           _BLF     ip_route,??ip_route??rA
    513          #endif /* LWIP_IGMP */
    514          
    515            /* no outgoing network interface could be found? */
    516            if (netif == NULL) {
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0600001A           BNE      ??udp_sendto_0
    517              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
    518                ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    519              UDP_STATS_INC(udp.rterr);
   \   00000024   ........           LDR      R0,??DataTable3  ;; lwip_stats
   \   00000028   B618D0E1           LDRH     R1,[R0, #+134]
   \   0000002C   011081E2           ADD      R1,R1,#+1
   \   00000030   B618C0E1           STRH     R1,[R0, #+134]
    520              return ERR_RTE;
   \   00000034   F040BDE8           POP      {R4-R7,LR}
   \   00000038   0300E0E3           MVN      R0,#+3
   \   0000003C   1EFF2FE1           BX       LR
    521            }
    522          #if LWIP_CHECKSUM_ON_COPY
    523            return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
    524          #else /* LWIP_CHECKSUM_ON_COPY */
    525            return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
   \                     ??udp_sendto_0:
   \   00000040   01002DE9           PUSH     {R0}
   \   00000044   0730A0E1           MOV      R3,R7
   \   00000048   0620A0E1           MOV      R2,R6
   \   0000004C   0510A0E1           MOV      R1,R5
   \   00000050   0400A0E1           MOV      R0,R4
   \   00000054   ........           BL       udp_sendto_if
   \   00000058   04D08DE2           ADD      SP,SP,#+4
   \   0000005C   F040BDE8           POP      {R4-R7,LR}
   \   00000060   1EFF2FE1           BX       LR               ;; return
    526          #endif /* LWIP_CHECKSUM_ON_COPY */
    527          }
    528          
    529          /**
    530           * Send data to a specified address using UDP.
    531           * The netif used for sending can be specified.
    532           *
    533           * This function exists mainly for DHCP, to be able to send UDP packets
    534           * on a netif that is still down.
    535           *
    536           * @param pcb UDP PCB used to send the data.
    537           * @param p chain of pbuf's to be sent.
    538           * @param dst_ip Destination IP address.
    539           * @param dst_port Destination UDP port.
    540           * @param netif the netif used for sending.
    541           *
    542           * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
    543           *
    544           * @return lwIP error code (@see udp_send for possible error codes)
    545           *
    546           * @see udp_disconnect() udp_send()
    547           */

   \                                 In segment CODE, align 4, keep-with-next
    548          err_t
    549          udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
    550            ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
    551          {
   \                     udp_sendto_if:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   20709DE5           LDR      R7,[SP, #+32]
   \   00000008   0040A0E1           MOV      R4,R0
    552          #if LWIP_CHECKSUM_ON_COPY
    553            return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
    554          }
    555          
    556          /** Same as udp_sendto_if(), but with checksum */
    557          err_t
    558          udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
    559                               u16_t dst_port, struct netif *netif, u8_t have_chksum,
    560                               u16_t chksum)
    561          {
    562          #endif /* LWIP_CHECKSUM_ON_COPY */
    563            struct udp_hdr *udphdr;
    564            ip_addr_t *src_ip;
    565            err_t err;
    566            struct pbuf *q; /* q will be sent down the stack */
    567          
    568          #if IP_SOF_BROADCAST
    569            /* broadcast filter? */
    570            if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(dst_ip, netif)) {
    571              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
    572                ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
    573              return ERR_VAL;
    574            }
    575          #endif /* IP_SOF_BROADCAST */
    576          
    577            /* if the PCB is not yet bound to a port, bind it here */
    578            if (pcb->local_port == 0) {
   \   0000000C   B201D4E1           LDRH     R0,[R4, #+18]
   \   00000010   0150A0E1           MOV      R5,R1
   \   00000014   0260A0E1           MOV      R6,R2
   \   00000018   03A0A0E1           MOV      R10,R3
   \   0000001C   000050E3           CMP      R0,#+0
   \   00000020   0500001A           BNE      ??udp_sendto_if_0
    579              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    580              err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   \   00000024   0020A0E3           MOV      R2,#+0
   \   00000028   0410A0E1           MOV      R1,R4
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       udp_bind
   \   00000034   0090B0E1           MOVS     R9,R0
    581              if (err != ERR_OK) {
   \   00000038   5C00001A           BNE      ??udp_sendto_if_1
    582                LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
    583                return err;
    584              }
    585            }
    586          
    587            /* not enough space to add an UDP header to first pbuf in given p chain? */
    588            if (pbuf_header(p, UDP_HLEN)) {
   \                     ??udp_sendto_if_0:
   \   0000003C   0810A0E3           MOV      R1,#+8
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   ........           _BLF     pbuf_header,??pbuf_header??rA
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0D00000A           BEQ      ??udp_sendto_if_2
    589              /* allocate header in a separate new pbuf */
    590              q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
   \   00000050   0020A0E3           MOV      R2,#+0
   \   00000054   0810A0E3           MOV      R1,#+8
   \   00000058   0100A0E3           MOV      R0,#+1
   \   0000005C   ........           _BLF     pbuf_alloc,??pbuf_alloc??rA
   \   00000060   0080B0E1           MOVS     R8,R0
    591              /* new header pbuf could not be allocated? */
    592              if (q == NULL) {
    593                LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
    594                return ERR_MEM;
   \   00000064   0000E003           MVNEQ    R0,#+0
   \   00000068   5000000A           BEQ      ??udp_sendto_if_1
    595              }
    596              if (p->tot_len != 0) {
   \   0000006C   B800D5E1           LDRH     R0,[R5, #+8]
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   0400000A           BEQ      ??udp_sendto_if_3
    597                /* chain header q in front of given pbuf p (only if p contains data) */
    598                pbuf_chain(q, p);
   \   00000078   0510A0E1           MOV      R1,R5
   \   0000007C   0800A0E1           MOV      R0,R8
   \   00000080   ........           _BLF     pbuf_chain,??pbuf_chain??rA
   \   00000084   000000EA           B        ??udp_sendto_if_3
    599              }
    600              /* first pbuf q points to header pbuf */
    601              LWIP_DEBUGF(UDP_DEBUG,
    602                          ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
    603            } else {
    604              /* adding space for header within p succeeded */
    605              /* first pbuf q equals given pbuf */
    606              q = p;
   \                     ??udp_sendto_if_2:
   \   00000088   0580A0E1           MOV      R8,R5
    607              LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
    608            }
    609            LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
    610                        (q->len >= sizeof(struct udp_hdr)));
    611            /* q now represents the packet to be sent */
    612            udphdr = (struct udp_hdr *)q->payload;
    613            udphdr->src = htons(pcb->local_port);
   \                     ??udp_sendto_if_3:
   \   0000008C   B201D4E1           LDRH     R0,[R4, #+18]
   \   00000090   049098E5           LDR      R9,[R8, #+4]
   \   00000094   ........           _BLF     lwip_htons,??lwip_htons??rA
   \   00000098   0000C9E5           STRB     R0,[R9, #+0]
   \   0000009C   2004A0E1           LSR      R0,R0,#+8
   \   000000A0   0100C9E5           STRB     R0,[R9, #+1]
    614            udphdr->dest = htons(dst_port);
   \   000000A4   0A00A0E1           MOV      R0,R10
   \   000000A8   ........           _BLF     lwip_htons,??lwip_htons??rA
   \   000000AC   0200C9E5           STRB     R0,[R9, #+2]
   \   000000B0   2004A0E1           LSR      R0,R0,#+8
   \   000000B4   0300C9E5           STRB     R0,[R9, #+3]
    615            /* in UDP, 0 checksum means 'no checksum' */
    616            udphdr->chksum = 0x0000; 
   \   000000B8   0000A0E3           MOV      R0,#+0
   \   000000BC   0600C9E5           STRB     R0,[R9, #+6]
   \   000000C0   0700C9E5           STRB     R0,[R9, #+7]
    617          
    618            /* Multicast Loop? */
    619          #if LWIP_IGMP
    620            if (ip_addr_ismulticast(dst_ip) && ((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0)) {
    621              q->flags |= PBUF_FLAG_MCASTLOOP;
    622            }
    623          #endif /* LWIP_IGMP */
    624          
    625          
    626            /* PCB local address is IP_ANY_ADDR? */
    627            if (ip_addr_isany(&pcb->local_ip)) {
   \   000000C4   000054E3           CMP      R4,#+0
   \   000000C8   00009415           LDRNE    R0,[R4, #+0]
   \   000000CC   00005013           CMPNE    R0,#+0
    628              /* use outgoing network interface IP address as source address */
    629              src_ip = &(netif->ip_addr);
   \   000000D0   04A08702           ADDEQ    R10,R7,#+4
   \   000000D4   0A00000A           BEQ      ??udp_sendto_if_4
    630            } else {
    631              /* check if UDP PCB local IP address is correct
    632               * this could be an old address if netif->ip_addr has changed */
    633              if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
   \   000000D8   041097E5           LDR      R1,[R7, #+4]
   \   000000DC   010050E1           CMP      R0,R1
   \   000000E0   0600000A           BEQ      ??udp_sendto_if_5
    634                /* local_ip doesn't match, drop the packet */
    635                if (q != p) {
   \   000000E4   050058E1           CMP      R8,R5
   \   000000E8   0100000A           BEQ      ??udp_sendto_if_6
    636                  /* free the header pbuf */
    637                  pbuf_free(q);
   \   000000EC   0800A0E1           MOV      R0,R8
   \   000000F0   ........           _BLF     pbuf_free,??pbuf_free??rA
    638                  q = NULL;
    639                  /* p is still referenced by the caller, and will live on */
    640                }
    641                return ERR_VAL;
   \                     ??udp_sendto_if_6:
   \   000000F4   F047BDE8           POP      {R4-R10,LR}
   \   000000F8   0500E0E3           MVN      R0,#+5
   \   000000FC   1EFF2FE1           BX       LR
    642              }
    643              /* use UDP PCB local IP address as source address */
    644              src_ip = &(pcb->local_ip);
   \                     ??udp_sendto_if_5:
   \   00000100   04A0A0E1           MOV      R10,R4
    645            }
    646          
    647            LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
    648          
    649          #if LWIP_UDPLITE
    650            /* UDP Lite protocol? */
    651            if (pcb->flags & UDP_FLAGS_UDPLITE) {
    652              u16_t chklen, chklen_hdr;
    653              LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
    654              /* set UDP message length in UDP header */
    655              chklen_hdr = chklen = pcb->chksum_len_tx;
    656              if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
    657                if (chklen != 0) {
    658                  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen));
    659                }
    660                /* For UDP-Lite, checksum length of 0 means checksum
    661                   over the complete packet. (See RFC 3828 chap. 3.1)
    662                   At least the UDP-Lite header must be covered by the
    663                   checksum, therefore, if chksum_len has an illegal
    664                   value, we generate the checksum over the complete
    665                   packet to be safe. */
    666                chklen_hdr = 0;
    667                chklen = q->tot_len;
    668              }
    669              udphdr->len = htons(chklen_hdr);
    670              /* calculate checksum */
    671          #if CHECKSUM_GEN_UDP
    672              udphdr->chksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip,
    673                IP_PROTO_UDPLITE, q->tot_len,
    674          #if !LWIP_CHECKSUM_ON_COPY
    675                chklen);
    676          #else /* !LWIP_CHECKSUM_ON_COPY */
    677                (have_chksum ? UDP_HLEN : chklen));
    678              if (have_chksum) {
    679                u32_t acc;
    680                acc = udphdr->chksum + (u16_t)~(chksum);
    681                udphdr->chksum = FOLD_U32T(acc);
    682              }
    683          #endif /* !LWIP_CHECKSUM_ON_COPY */
    684          
    685              /* chksum zero must become 0xffff, as zero means 'no checksum' */
    686              if (udphdr->chksum == 0x0000) {
    687                udphdr->chksum = 0xffff;
    688              }
    689          #endif /* CHECKSUM_GEN_UDP */
    690              /* output to IP */
    691              LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDPLITE,)\n"));
    692              NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    693              err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDPLITE, netif);
    694              NETIF_SET_HWADDRHINT(netif, NULL);
    695            } else
    696          #endif /* LWIP_UDPLITE */
    697            {      /* UDP */
    698              LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    699              udphdr->len = htons(q->tot_len);
   \                     ??udp_sendto_if_4:
   \   00000104   B800D8E1           LDRH     R0,[R8, #+8]
   \   00000108   ........           _BLF     lwip_htons,??lwip_htons??rA
   \   0000010C   0400C9E5           STRB     R0,[R9, #+4]
   \   00000110   2004A0E1           LSR      R0,R0,#+8
   \   00000114   0500C9E5           STRB     R0,[R9, #+5]
    700              /* calculate checksum */
    701          #if CHECKSUM_GEN_UDP
    702              if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
   \   00000118   1000D4E5           LDRB     R0,[R4, #+16]
   \   0000011C   010010E3           TST      R0,#0x1
   \   00000120   0D00001A           BNE      ??udp_sendto_if_7
    703                u16_t udpchksum;
    704          #if LWIP_CHECKSUM_ON_COPY
    705                if (have_chksum) {
    706                  u32_t acc;
    707                  udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
    708                    q->tot_len, UDP_HLEN);
    709                  acc = udpchksum + (u16_t)~(chksum);
    710                  udpchksum = FOLD_U32T(acc);
    711                } else
    712          #endif /* LWIP_CHECKSUM_ON_COPY */
    713                {
    714                  udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
   \   00000124   B800D8E1           LDRH     R0,[R8, #+8]
   \   00000128   1130A0E3           MOV      R3,#+17
   \   0000012C   0620A0E1           MOV      R2,R6
   \   00000130   01002DE9           PUSH     {R0}
   \   00000134   0A10A0E1           MOV      R1,R10
   \   00000138   0800A0E1           MOV      R0,R8
   \   0000013C   ........           _BLF     inet_chksum_pseudo,??inet_chksum_pseudo??rA
    715                }
    716          
    717                /* chksum zero must become 0xffff, as zero means 'no checksum' */
    718                if (udpchksum == 0x0000) {
   \   00000140   0010B0E1           MOVS     R1,R0
   \   00000144   04D08DE2           ADD      SP,SP,#+4
    719                  udpchksum = 0xffff;
   \   00000148   FF00A003           MOVEQ    R0,#+255
   \   0000014C   FF0C8003           ORREQ    R0,R0,#0xFF00
    720                }
    721                udphdr->chksum = udpchksum;
   \   00000150   0600C9E5           STRB     R0,[R9, #+6]
   \   00000154   2004A0E1           LSR      R0,R0,#+8
   \   00000158   0700C9E5           STRB     R0,[R9, #+7]
    722              }
    723          #endif /* CHECKSUM_GEN_UDP */
    724              LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    725              LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    726              /* output to IP */
    727              NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    728              err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
   \                     ??udp_sendto_if_7:
   \   0000015C   80002DE9           PUSH     {R7}
   \   00000160   1100A0E3           MOV      R0,#+17
   \   00000164   01002DE9           PUSH     {R0}
   \   00000168   0900D4E5           LDRB     R0,[R4, #+9]
   \   0000016C   0620A0E1           MOV      R2,R6
   \   00000170   0A10A0E1           MOV      R1,R10
   \   00000174   01002DE9           PUSH     {R0}
   \   00000178   0A30D4E5           LDRB     R3,[R4, #+10]
   \   0000017C   0800A0E1           MOV      R0,R8
   \   00000180   ........           _BLF     ip_output_if,??ip_output_if??rA
   \   00000184   0090A0E1           MOV      R9,R0
    729              NETIF_SET_HWADDRHINT(netif, NULL);
    730            }
    731            /* TODO: must this be increased even if error occured? */
    732            snmp_inc_udpoutdatagrams();
    733          
    734            /* did we chain a separate header pbuf earlier? */
    735            if (q != p) {
   \   00000188   050058E1           CMP      R8,R5
   \   0000018C   0CD08DE2           ADD      SP,SP,#+12
   \   00000190   0100000A           BEQ      ??udp_sendto_if_8
    736              /* free the header pbuf */
    737              pbuf_free(q);
   \   00000194   0800A0E1           MOV      R0,R8
   \   00000198   ........           _BLF     pbuf_free,??pbuf_free??rA
    738              q = NULL;
    739              /* p is still referenced by the caller, and will live on */
    740            }
    741          
    742            UDP_STATS_INC(udp.xmit);
   \                     ??udp_sendto_if_8:
   \   0000019C   ........           LDR      R0,??DataTable3  ;; lwip_stats
   \   000001A0   B817D0E1           LDRH     R1,[R0, #+120]
   \   000001A4   011081E2           ADD      R1,R1,#+1
   \   000001A8   B817C0E1           STRH     R1,[R0, #+120]
    743            return err;
   \   000001AC   0900A0E1           MOV      R0,R9
   \                     ??udp_sendto_if_1:
   \   000001B0   F047BDE8           POP      {R4-R10,LR}
   \   000001B4   1EFF2FE1           BX       LR               ;; return
    744          }
    745          
    746          /**
    747           * Bind an UDP PCB.
    748           *
    749           * @param pcb UDP PCB to be bound with a local address ipaddr and port.
    750           * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
    751           * bind to all local interfaces.
    752           * @param port local UDP port to bind with. Use 0 to automatically bind
    753           * to a random port between UDP_LOCAL_PORT_RANGE_START and
    754           * UDP_LOCAL_PORT_RANGE_END.
    755           *
    756           * ipaddr & port are expected to be in the same byte order as in the pcb.
    757           *
    758           * @return lwIP error code.
    759           * - ERR_OK. Successful. No error occured.
    760           * - ERR_USE. The specified ipaddr and port are already bound to by
    761           * another UDP PCB.
    762           *
    763           * @see udp_disconnect()
    764           */

   \                                 In segment CODE, align 4, keep-with-next
    765          err_t
    766          udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
    767          {
    768            struct udp_pcb *ipcb;
    769            u8_t rebind;
    770          
    771            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
    772            ip_addr_debug_print(UDP_DEBUG, ipaddr);
    773            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));
    774          
    775            rebind = 0;
    776            /* Check for double bind and rebind of the same pcb */
    777            for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   \                     udp_bind:
   \   00000000   ........           LDR      R3,??DataTable6  ;; udp_port
   \   00000004   F0002DE9           PUSH     {R4-R7}
   \   00000008   04C093E5           LDR      R12,[R3, #+4]
   \   0000000C   0040A0E3           MOV      R4,#+0
   \   00000010   0C50A0E1           MOV      R5,R12
   \   00000014   010000EA           B        ??udp_bind_0
    778              /* is this UDP PCB already on active list? */
    779              if (pcb == ipcb) {
    780                /* pcb may occur at most once in active list */
    781                LWIP_ASSERT("rebind == 0", rebind == 0);
    782                /* pcb already in list, just rebind */
    783                rebind = 1;
   \                     ??udp_bind_1:
   \   00000018   0140A0E3           MOV      R4,#+1
    784              }
   \                     ??udp_bind_2:
   \   0000001C   0C5095E5           LDR      R5,[R5, #+12]
   \                     ??udp_bind_0:
   \   00000020   006091E5           LDR      R6,[R1, #+0]
   \   00000024   000055E3           CMP      R5,#+0
   \   00000028   1200000A           BEQ      ??udp_bind_3
   \   0000002C   050050E1           CMP      R0,R5
   \   00000030   F8FFFF0A           BEQ      ??udp_bind_1
    785          
    786              /* By default, we don't allow to bind to a port that any other udp
    787                 PCB is alread bound to, unless *all* PCBs with that port have tha
    788                 REUSEADDR flag set. */
    789          #if SO_REUSE
    790              else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
    791                       !ip_get_option(ipcb, SOF_REUSEADDR)) {
   \   00000034   0870D0E5           LDRB     R7,[R0, #+8]
   \   00000038   040017E3           TST      R7,#0x4
   \   0000003C   0870D505           LDRBEQ   R7,[R5, #+8]
   \   00000040   04001703           TSTEQ    R7,#0x4
    792          #else /* SO_REUSE */
    793              /* port matches that of PCB in list and REUSEADDR not set -> reject */
    794              else {
    795          #endif /* SO_REUSE */
    796                if ((ipcb->local_port == port) &&
    797                    /* IP address matches, or one is IP_ADDR_ANY? */
    798                    (ip_addr_isany(&(ipcb->local_ip)) ||
    799                     ip_addr_isany(ipaddr) ||
    800                     ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
   \   00000044   B271D501           LDRHEQ   R7,[R5, #+18]
   \   00000048   02005701           CMPEQ    R7,R2
   \   0000004C   F2FFFF1A           BNE      ??udp_bind_2
   \   00000050   000055E3           CMP      R5,#+0
   \   00000054   00709515           LDRNE    R7,[R5, #+0]
   \   00000058   00005713           CMPNE    R7,#+0
   \   0000005C   00005113           CMPNE    R1,#+0
   \   00000060   00005613           CMPNE    R6,#+0
   \   00000064   06005711           CMPNE    R7,R6
   \   00000068   EBFFFF1A           BNE      ??udp_bind_2
    801                  /* other PCB already binds to this local IP and port */
    802                  LWIP_DEBUGF(UDP_DEBUG,
    803                              ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
    804                  return ERR_USE;
   \                     ??udp_bind_4:
   \   0000006C   F000BDE8           POP      {R4-R7}
   \   00000070   0700E0E3           MVN      R0,#+7
   \   00000074   1EFF2FE1           BX       LR
    805                }
    806              }
    807            }
    808          
    809            ip_addr_set(&pcb->local_ip, ipaddr);
   \                     ??udp_bind_3:
   \   00000078   000051E3           CMP      R1,#+0
   \   0000007C   0060A003           MOVEQ    R6,#+0
   \   00000080   006080E5           STR      R6,[R0, #+0]
    810          
    811            /* no port specified? */
    812            if (port == 0) {
   \   00000084   000052E3           CMP      R2,#+0
   \   00000088   1800001A           BNE      ??udp_bind_5
    813              port = udp_new_port();
   \   0000008C   0010A0E3           MOV      R1,#+0
   \   00000090   FF50A0E3           MOV      R5,#+255
   \   00000094   FF5C85E3           ORR      R5,R5,#0xFF00
   \   00000098   070000EA           B        ??udp_bind_6
   \                     ??udp_bind_7:
   \   0000009C   B271D6E1           LDRH     R7,[R6, #+18]
   \   000000A0   020057E1           CMP      R7,R2
   \   000000A4   0B00001A           BNE      ??udp_bind_8
   \   000000A8   011081E2           ADD      R1,R1,#+1
   \   000000AC   0118A0E1           MOV      R1,R1, LSL #+16
   \   000000B0   2118A0E1           MOV      R1,R1, LSR #+16
   \   000000B4   400C51E3           CMP      R1,#+16384
   \   000000B8   EBFFFF2A           BCS      ??udp_bind_4
   \                     ??udp_bind_6:
   \   000000BC   B020D3E1           LDRH     R2,[R3, #+0]
   \   000000C0   016082E2           ADD      R6,R2,#+1
   \   000000C4   050052E1           CMP      R2,R5
   \   000000C8   C06CA003           MOVEQ    R6,#+49152
   \   000000CC   B060C3E1           STRH     R6,[R3, #+0]
   \   000000D0   0C60A0E1           MOV      R6,R12
   \   000000D4   000000EA           B        ??udp_bind_9
   \                     ??udp_bind_8:
   \   000000D8   0C6096E5           LDR      R6,[R6, #+12]
   \                     ??udp_bind_9:
   \   000000DC   B020D3E1           LDRH     R2,[R3, #+0]
   \   000000E0   000056E3           CMP      R6,#+0
   \   000000E4   ECFFFF1A           BNE      ??udp_bind_7
    814              if (port == 0) {
   \   000000E8   000052E3           CMP      R2,#+0
   \   000000EC   DEFFFF0A           BEQ      ??udp_bind_4
    815                /* no more ports available in local range */
    816                LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
    817                return ERR_USE;
    818              }
    819            }
    820            pcb->local_port = port;
   \                     ??udp_bind_5:
   \   000000F0   B221C0E1           STRH     R2,[R0, #+18]
    821            snmp_insert_udpidx_tree(pcb);
    822            /* pcb not active yet? */
    823            if (rebind == 0) {
   \   000000F4   000054E3           CMP      R4,#+0
    824              /* place the PCB on the active list if not already there */
    825              pcb->next = udp_pcbs;
   \   000000F8   0CC08005           STREQ    R12,[R0, #+12]
    826              udp_pcbs = pcb;
   \   000000FC   04008305           STREQ    R0,[R3, #+4]
    827            }
    828            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    829                        ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
    830                         ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
    831                         ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
    832                         pcb->local_port));
    833            return ERR_OK;
   \   00000100   F000BDE8           POP      {R4-R7}
   \   00000104   0000A0E3           MOV      R0,#+0
   \   00000108   1EFF2FE1           BX       LR               ;; return
    834          }
    835          /**
    836           * Connect an UDP PCB.
    837           *
    838           * This will associate the UDP PCB with the remote address.
    839           *
    840           * @param pcb UDP PCB to be connected with remote address ipaddr and port.
    841           * @param ipaddr remote IP address to connect with.
    842           * @param port remote UDP port to connect with.
    843           *
    844           * @return lwIP error code
    845           *
    846           * ipaddr & port are expected to be in the same byte order as in the pcb.
    847           *
    848           * The udp pcb is bound to a random local port if not already bound.
    849           *
    850           * @see udp_disconnect()
    851           */

   \                                 In segment CODE, align 4, keep-with-next
    852          err_t
    853          udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
    854          {
   \                     udp_connect:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    855            struct udp_pcb *ipcb;
    856          
    857            if (pcb->local_port == 0) {
   \   00000008   B201D4E1           LDRH     R0,[R4, #+18]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0260A0E1           MOV      R6,R2
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0500001A           BNE      ??udp_connect_0
    858              err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   \   0000001C   0020A0E3           MOV      R2,#+0
   \   00000020   0410A0E1           MOV      R1,R4
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       udp_bind
    859              if (err != ERR_OK) {
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   1400001A           BNE      ??udp_connect_1
    860                return err;
    861              }
    862            }
    863          
    864            ip_addr_set(&pcb->remote_ip, ipaddr);
   \                     ??udp_connect_0:
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   00009515           LDRNE    R0,[R5, #+0]
   \   0000003C   0000A003           MOVEQ    R0,#+0
   \   00000040   040084E5           STR      R0,[R4, #+4]
    865            pcb->remote_port = port;
   \   00000044   B461C4E1           STRH     R6,[R4, #+20]
    866            pcb->flags |= UDP_FLAGS_CONNECTED;
   \   00000048   1000D4E5           LDRB     R0,[R4, #+16]
   \   0000004C   040080E3           ORR      R0,R0,#0x4
   \   00000050   1000C4E5           STRB     R0,[R4, #+16]
    867          /** TODO: this functionality belongs in upper layers */
    868          #ifdef LWIP_UDP_TODO
    869            /* Nail down local IP for netconn_addr()/getsockname() */
    870            if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) {
    871              struct netif *netif;
    872          
    873              if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
    874                LWIP_DEBUGF(UDP_DEBUG, ("udp_connect: No route to 0x%lx\n", pcb->remote_ip.addr));
    875                UDP_STATS_INC(udp.rterr);
    876                return ERR_RTE;
    877              }
    878              /** TODO: this will bind the udp pcb locally, to the interface which
    879                  is used to route output packets to the remote address. However, we
    880                  might want to accept incoming packets on any interface! */
    881              pcb->local_ip = netif->ip_addr;
    882            } else if (ip_addr_isany(&pcb->remote_ip)) {
    883              pcb->local_ip.addr = 0;
    884            }
    885          #endif
    886            LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    887                        ("udp_connect: connected to %"U16_F".%"U16_F".%"U16_F".%"U16_F",port %"U16_F"\n",
    888                         ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
    889                         ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
    890                         pcb->local_port));
    891          
    892            /* Insert UDP PCB into the list of active UDP PCBs. */
    893            for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   \   00000054   ........           LDR      R0,??DataTable6  ;; udp_port
   \   00000058   041090E5           LDR      R1,[R0, #+4]
   \   0000005C   0120A0E1           MOV      R2,R1
   \   00000060   000000EA           B        ??udp_connect_2
   \                     ??udp_connect_3:
   \   00000064   0C2092E5           LDR      R2,[R2, #+12]
   \                     ??udp_connect_2:
   \   00000068   000052E3           CMP      R2,#+0
   \   0000006C   0200000A           BEQ      ??udp_connect_4
    894              if (pcb == ipcb) {
   \   00000070   020054E1           CMP      R4,R2
   \   00000074   FAFFFF1A           BNE      ??udp_connect_3
    895                /* already on the list, just return */
    896                return ERR_OK;
   \   00000078   010000EA           B        ??udp_connect_5
    897              }
    898            }
    899            /* PCB not yet on the list, add PCB now */
    900            pcb->next = udp_pcbs;
   \                     ??udp_connect_4:
   \   0000007C   0C1084E5           STR      R1,[R4, #+12]
    901            udp_pcbs = pcb;
   \   00000080   044080E5           STR      R4,[R0, #+4]
    902            return ERR_OK;
   \                     ??udp_connect_5:
   \   00000084   0000A0E3           MOV      R0,#+0
   \                     ??udp_connect_1:
   \   00000088   7040BDE8           POP      {R4-R6,LR}
   \   0000008C   1EFF2FE1           BX       LR               ;; return
    903          }
    904          
    905          /**
    906           * Disconnect a UDP PCB
    907           *
    908           * @param pcb the udp pcb to disconnect.
    909           */

   \                                 In segment CODE, align 4, keep-with-next
    910          void
    911          udp_disconnect(struct udp_pcb *pcb)
    912          {
    913            /* reset remote address association */
    914            ip_addr_set_any(&pcb->remote_ip);
   \                     udp_disconnect:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   041080E5           STR      R1,[R0, #+4]
    915            pcb->remote_port = 0;
   \   00000008   B411C0E1           STRH     R1,[R0, #+20]
    916            /* mark PCB as unconnected */
    917            pcb->flags &= ~UDP_FLAGS_CONNECTED;
   \   0000000C   1010D0E5           LDRB     R1,[R0, #+16]
   \   00000010   FB1001E2           AND      R1,R1,#0xFB
   \   00000014   1010C0E5           STRB     R1,[R0, #+16]
    918          }
   \   00000018   1EFF2FE1           BX       LR               ;; return
    919          
    920          /**
    921           * Set a receive callback for a UDP PCB
    922           *
    923           * This callback will be called when receiving a datagram for the pcb.
    924           *
    925           * @param pcb the pcb for wich to set the recv callback
    926           * @param recv function pointer of the callback function
    927           * @param recv_arg additional argument to pass to the callback function
    928           */

   \                                 In segment CODE, align 4, keep-with-next
    929          void
    930          udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
    931          {
    932            /* remember recv() callback and user data */
    933            pcb->recv = recv;
   \                     udp_recv:
   \   00000000   181080E5           STR      R1,[R0, #+24]
    934            pcb->recv_arg = recv_arg;
   \   00000004   1C2080E5           STR      R2,[R0, #+28]
    935          }
   \   00000008   1EFF2FE1           BX       LR               ;; return
    936          
    937          /**
    938           * Remove an UDP PCB.
    939           *
    940           * @param pcb UDP PCB to be removed. The PCB is removed from the list of
    941           * UDP PCB's and the data structure is freed from memory.
    942           *
    943           * @see udp_new()
    944           */

   \                                 In segment CODE, align 4, keep-with-next
    945          void
    946          udp_remove(struct udp_pcb *pcb)
    947          {
    948            struct udp_pcb *pcb2;
    949          
    950            snmp_delete_udpidx_tree(pcb);
    951            /* pcb to be removed is first in list? */
    952            if (udp_pcbs == pcb) {
   \                     udp_remove:
   \   00000000   ........           LDR      R1,??DataTable6  ;; udp_port
   \   00000004   00402DE9           PUSH     {LR}
   \   00000008   042091E5           LDR      R2,[R1, #+4]
   \   0000000C   000052E1           CMP      R2,R0
    953              /* make list start at 2nd pcb */
    954              udp_pcbs = udp_pcbs->next;
   \   00000010   0C209205           LDREQ    R2,[R2, #+12]
   \   00000014   04208105           STREQ    R2,[R1, #+4]
    955              /* pcb not 1st in list */
    956            } else {
    957              for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   \   00000018   00005213           CMPNE    R2,#+0
   \   0000001C   0800000A           BEQ      ??udp_remove_0
    958                /* find pcb in udp_pcbs list */
    959                if (pcb2->next != NULL && pcb2->next == pcb) {
   \                     ??udp_remove_1:
   \   00000020   0C1092E5           LDR      R1,[R2, #+12]
   \   00000024   000051E3           CMP      R1,#+0
   \   00000028   0200000A           BEQ      ??udp_remove_2
   \   0000002C   000051E1           CMP      R1,R0
    960                  /* remove pcb from list */
    961                  pcb2->next = pcb->next;
   \   00000030   0C109005           LDREQ    R1,[R0, #+12]
   \   00000034   0C108205           STREQ    R1,[R2, #+12]
    962                }
    963              }
   \                     ??udp_remove_2:
   \   00000038   0C2092E5           LDR      R2,[R2, #+12]
   \   0000003C   000052E3           CMP      R2,#+0
   \   00000040   F6FFFF1A           BNE      ??udp_remove_1
    964            }
    965            memp_free(MEMP_UDP_PCB, pcb);
   \                     ??udp_remove_0:
   \   00000044   0010A0E1           MOV      R1,R0
   \   00000048   0100A0E3           MOV      R0,#+1
   \   0000004C   ........           _BLF     memp_free,??memp_free??rA
    966          }
   \   00000050   0040BDE8           POP      {LR}
   \   00000054   1EFF2FE1           BX       LR               ;; return
    967          
    968          /**
    969           * Create a UDP PCB.
    970           *
    971           * @return The UDP PCB which was created. NULL if the PCB data structure
    972           * could not be allocated.
    973           *
    974           * @see udp_remove()
    975           */

   \                                 In segment CODE, align 4, keep-with-next
    976          struct udp_pcb *
    977          udp_new(void)
    978          {
   \                     udp_new:
   \   00000000   10402DE9           PUSH     {R4,LR}
    979            struct udp_pcb *pcb;
    980            pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
   \   00000004   0100A0E3           MOV      R0,#+1
   \   00000008   ........           _BLF     memp_malloc,??memp_malloc??rA
   \   0000000C   0040B0E1           MOVS     R4,R0
    981            /* could allocate UDP PCB? */
    982            if (pcb != NULL) {
   \   00000010   0400000A           BEQ      ??udp_new_0
    983              /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
    984               * which means checksum is generated over the whole datagram per default
    985               * (recommended as default by RFC 3828). */
    986              /* initialize PCB to all zeroes */
    987              memset(pcb, 0, sizeof(struct udp_pcb));
   \   00000014   2020A0E3           MOV      R2,#+32
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   ........           _BLF     memset,??memset??rA
    988              pcb->ttl = UDP_TTL;
   \   00000020   FF00A0E3           MOV      R0,#+255
   \   00000024   0A00C4E5           STRB     R0,[R4, #+10]
    989            }
    990            return pcb;
   \                     ??udp_new_0:
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   1040BDE8           POP      {R4,LR}
   \   00000030   1EFF2FE1           BX       LR               ;; return
    991          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     lwip_stats

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     udp_port

   \                                 In segment DATA_ID, align 4, align-sorted
   \                     `?<Initializer for udp_port>`:
   \   00000000   00C0               DC16 49152
   \   00000002   0000               DC8 0, 0
   \                     `?<Initializer for udp_pcbs>`:
   \   00000004   00000000           DC8 0, 0, 0, 0
    992          
    993          #if UDP_DEBUG
    994          /**
    995           * Print UDP header information for debug purposes.
    996           *
    997           * @param udphdr pointer to the udp header in memory.
    998           */
    999          void
   1000          udp_debug_print(struct udp_hdr *udphdr)
   1001          {
   1002            LWIP_DEBUGF(UDP_DEBUG, ("UDP header:\n"));
   1003            LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
   1004            LWIP_DEBUGF(UDP_DEBUG, ("|     %5"U16_F"     |     %5"U16_F"     | (src port, dest port)\n",
   1005                                    ntohs(udphdr->src), ntohs(udphdr->dest)));
   1006            LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
   1007            LWIP_DEBUGF(UDP_DEBUG, ("|     %5"U16_F"     |     0x%04"X16_F"    | (len, chksum)\n",
   1008                                    ntohs(udphdr->len), ntohs(udphdr->chksum)));
   1009            LWIP_DEBUGF(UDP_DEBUG, ("+-------------------------------+\n"));
   1010          }
   1011          #endif /* UDP_DEBUG */
   1012          
   1013          #endif /* LWIP_UDP */
   1014          

   Maximum stack usage in bytes:

     Function       CSTACK
     --------       ------
     udp_bind          16
     udp_connect       16
     udp_disconnect     0
     udp_init           0
     udp_input         52
     udp_new            8
     udp_recv           0
     udp_remove         4
     udp_send           4
     udp_sendto        24
     udp_sendto_if     44


   Segment part sizes:

     Function/Label              Bytes
     --------------              -----
     udp_port                       8
     udp_init                       4
     udp_input                    696
     udp_send                      24
     udp_sendto                   100
     udp_sendto_if                440
     udp_bind                     268
     udp_connect                  144
     udp_disconnect                28
     udp_recv                      12
     udp_remove                    88
     udp_new                       52
     ??DataTable3                   4
     ??DataTable6                   4
     ?<Initializer for udp_port>    8
      Others                      224

 
 2 076 bytes in segment CODE
     8 bytes in segment DATA_I
     8 bytes in segment DATA_ID
    12 bytes in segment INITTAB
 
 1 864 bytes of CODE  memory (+ 224 bytes shared)
     8 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
