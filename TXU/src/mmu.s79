/*
 * $Revision: 1.1 $
 */

; Setup MMU page table.
; Memory is mapped as:
; external SRAM at 0x00000000
; external SRAM at 0x30000000
; internal SRAM at 0x40000c1a
; internal registers at 0x0c000c12
;
; Note that virtual addresses 0x000000000 and 0x30000000 both
; accesses the same physical address in the external SRAM.
; This is done to simplify the handling of the exception vector table.

  rseg ICODE:CODE(2)
  code32

  ;
  ; Setup the MMU.
  ;
  export mmu_setup
mmu_setup:
  ; Disable MMU.
  mrc p15, 0, r0, c1, c0, 0
  ldr r1, =~0x1307
  and r0, r0, r1
  mcr p15, 0, r0, c1, c0, 0

  ; Flush the cache and TLB.
  ldr r0, =0x00000000
  mcr p15, 0, r0, c7, c7, 0 ; invalidate I and D cache
  mcr p15, 0, r0, c8, c7, 0 ; invalidate both I and D TLBs

  ; Set domain access control register for all 16 domains.
  ldr r0, =0x55555555
  mcr p15, 0, r0, c3, c0, 0

  ; Set MMU page table.
  ldr r0, =page_table
  mcr p15, 0, r0, c2, c0, 0

  ; Enable the MMU and I/D caches.
  mrc p15, 0, r0, c1, c0, 0
  ldr r1, =0x107d
  orr r0, r0, r1
  mcr     p15, 0, r0, c1, c0, 0

  ; Two NOP instructions to wait for translation to start.
  mov r0, r0
  mov r0, r0

  bx lr ; return

  
  rseg ICODE:CODE(14) ; Align page table at 16k
  data
  
  ; This is a very simple page table setup to map
  ; internal SRAM, external SRAM and internal registers.
  ; Only the first 1 kbyte of the page table is populated.
  
page_table:
  dcd 0x30000c1a ; map 0x00000000 to external SRAM
  rept 4 * 16 - 1
    dcd 0 ; page fault
  endr
  dcd 0x30000c1a ; map 0x30000000 to external SRAM
  rept 2 * 16 - 1
    dcd 0 ; page fault
  endr
  dcd 0x40000c1a ; map 0x40000000 to internal SRAM
  rept 6 * 16 - 1
    dcd 0 ; page fault
  endr
  dcd 0x0c000c12 ; map 0x0c000000 to internal registers
  rept 4 * 16 - 1
    dcd 0 ; page fault
  endr

  end
  