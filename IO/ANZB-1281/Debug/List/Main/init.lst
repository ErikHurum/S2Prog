###############################################################################
#
# IAR C/C++ Compiler V8.10.1.1784/W64 for Microchip AVR   28/Apr/2023  08:50:16
# Copyright 1996-2023 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file           =  D:\S2Prog\IO\ANZB-1281\Src\init.c
#    Command line          =
#        -f D:\S2Prog\IO\ANZB-1281\Debug\Obj\Main\init.r90.rsp
#        (D:\S2Prog\IO\ANZB-1281\Src\init.c --cpu=m128 -ms -o
#        D:\S2Prog\IO\ANZB-1281\Debug\Obj\Main -D OS_LIBMODE_D -D OS_UART=-1
#        -lCN D:\S2Prog\IO\ANZB-1281\Debug\List\Main -y --initializers_in_flash
#        --no_tbaa --debug -DENABLE_BIT_DEFINITIONS -e -I
#        D:\S2Prog\IO\ANZB-1281\INC\ -I
#        D:\S2Prog\IO\ANZB-1281\..\..\SHARED\INC\ --eeprom_size 4096 --clib
#        -Ohz) --dependencies=n
#        D:\S2Prog\IO\ANZB-1281\Debug\Obj\Main\init.r90.iar_deps
#    Locale                =  C
#    List file             =  D:\S2Prog\IO\ANZB-1281\Debug\List\Main\init.lst
#    Object file           =  D:\S2Prog\IO\ANZB-1281\Debug\Obj\Main\init.r90
#    Runtime model:           
#      __64bit_doubles     =  disabled
#      __SystemLibrary     =  CLib
#      __architecture      =  *
#      __cpu               =  3
#      __cpu_name          =  ATmega128
#      __dlib_version      =  clib
#      __enhanced_core     =  enabled
#      __enhanced_core_mul =  enabled
#      __has_elpm          =  true
#      __memory_model      =  2
#      __mex               =  disabled
#      __no_rampd          =  enabled
#      __rt_version        =  3
#      __vtable_memory     =  __nearflash
#
###############################################################################

D:\S2Prog\IO\ANZB-1281\Src\init.c
      1          /****************************************************************************************
      2          / Init the project
      3          /
      4          ***************************************************************************************/
      5          #ifdef __ATMEGA_1280__
      6          #include	"iom1280.h"
      7          #endif
      8          
      9          #ifdef __ATMEGA_1281__
     10          #include	"iom1281.h"
     11          #endif
     12          #include "stdio.h"
     13          #include "math.h"
     14          #include "externals.h"
     15          #include "version.h"
     16          #include "inavr.h"
     17          #include "string.h"
     18          
     19          /*
     20          **===========================================================================
     21          ** Init the system according to board type
     22          **===========================================================================
     23          */ 
     24          void InitSystem(void) {
     25          
     26              DDRB    =  0x00 ;      // Port B data direction, bit 0, 4-7 out
     27          //    PORTB   =  0xc;
     28              UnitID  = (PINB >> 2)& 0x03;       //get the unit ID
     29          #if (OS_UART == 0)
     30              UnitID = 0x00; //AStmark  for test
     31          #endif
     32          
     33              Init_CPU();                         // init all processes
     34              Init_IO();
     35              Init_TMR() ;
     36          #if (OS_UART != 0)
     37              Init_USART(0, 38400) ;              // 
     38          #endif
     39              Init_USART(1, 38400) ;              //    
     40              Init_AD();
     41              Init_Values();                      // init the values in the system
     42          
     43              ADCSR |= 0x40 ;                     //start the AD convertion
     44          }
     45          
     46          /*
     47          **===========================================================================
     48          ** Init the CPU related registers
     49          **===========================================================================
     50          */ 
     51          void Init_CPU( void ) {
     52          
     53              __disable_interrupt();
     54          
     55              /*--- Configure CPU and interrupts ---*/
     56              switch (UnitID) {
     57              case AN_ZB485:                  // AN-ZB485 
     58                  MCUCR = 0xc0 ;        // MCU control register  External Ram + wait state
     59                  EIMSK = 0x00 ;        // External interrupt mask register, all off
     60                  EICRA = 0xAf ;        // External interrupt control register, 0,1 raising, rest faling
     61                  EICRB = 0xAA ;        // External interrupt control register 
     62                  EIMSK = 0x03 ;        // External interrupt mask register, int 0 and 1 on 
     63                  break;
     64              case AN_ZBANA:                  // AN-ZBANA
     65                  MCUCR = 0x00 ;        // MCU control register wait state
     66                  EIMSK = 0x00 ;        // External interrupt mask register , all off
     67                  EICRA = 0xAA ;        // External interrupt control register, o on faling edge
     68                  EICRB = 0xAA ;        // External interrupt control register 
     69                  EIMSK = 0x01 ;        // External interrupt mask register, int 0 on 
     70                  break;
     71              }
     72              XMCRA = 0x00 ;       // maximum wait states
     73              XMCRB = 0x07 ;       // Full portC + bus keeper
     74              SREG  = 0x80 ;        // global interrupt
     75              XDIV  = 0x00 ;     // Init valuse used 0x00
     76          
     77          
     78              RestartStatus = MCUCSR;       // Remember reset source
     79              MCUCSR = 0x00;              // and reset
     80              /*--- Initialize buffer ---*/
     81              WriteCount = 0;
     82          
     83          }
     84          
     85          /*
     86          **===========================================================================
     87          ** Init the watchdog registers
     88          **===========================================================================
     89          */ 
     90          __monitor void Init_Watchdog( void ) {
     91          
     92              asm("WDR");                             // kick the dog!!
     93              WDTCR = 0x0f;
     94              asm("WDR");                             // kick the dog!!
     95          
     96          }
     97          
     98          /*
     99          **===========================================================================
    100          ** Init the IO related registers
    101          **===========================================================================
    102          */ 
    103          void Init_IO( void ) {
    104          
    105              /*--- Initialize the data registers, output value and input pullup ---*/
    106              switch (UnitID) {
    107              case AN_ZB485:                  // AN-ZB485  
    108                  DDRA   =  0xff ;      // Port A data direction (out), external bus
    109                  PORTA  =  0x00 ;      // Port A data
    110                  DDRB   =  0x10 ;      // Port B data direction, bit 0, 4-7 out
    111                  PORTB  =  0x00 ;      // Port B data   
    112                  DDRC   =  0xff ;      // Port C data direction, all out
    113                  PORTC  =  0x00 ;      // Port C data
    114                  DDRD   =  0x00 ;      // Port D data direction, all in except output to osc and txd
    115                  PORTD  =  0xff ;      // Port D data pullup on int fro AD
    116                  DDRE   =  0xFE ;      // Port E data direction, all out except rxd
    117                  PORTE  =  0xf0 ;      // Port E data 
    118                  DDRF   =  0x00 ;      // Port F data direction, used for ADC
    119                  PORTF  =  0x00 ;      // Port F data 
    120                  DDRG   =  0x07 ;      // Port G data direction, port 1,2,3 out
    121                  PORTG  =  0x03 ;      // Port G data 
    122                  break;
    123              case AN_ZBANA:                  // AN-ZBANA
    124                  DDRA   =  0x00 ;      // Port A data direction in (not used)
    125                  PORTA  =  0x00 ;      // Port A data
    126                  DDRB   =  0xF1 ;      // Port B data direction, bit 0, 4-7 out
    127                  PORTB  =  0x00 ;      // Port B data   
    128                  DDRC   =  0xFF ;      // Port C data direction, all out
    129                  PORTC  =  0x00 ;      // Port C data
    130                  DDRD   =  0x02 ;      // Port D data direction, all in except output to osc and txd
    131                  PORTD  =  0xf1 ;      // Port D data pullup on int fro AD
    132                  DDRE   =  0xFE ;      // Port E data direction, all out except rxd
    133                  PORTE  =  0x00 ;      // Port E data 
    134                  DDRF   =  0x00 ;      // Port F data direction, used for ADC
    135                  PORTF  =  0x00 ;      // Port F data 
    136                  DDRG   =  0x10 ;      // Port G data direction, bit 5 out
    137                  PORTG  =  0x00 ;      // Port G data 
    138                  break;
    139              default:
    140                  break;
    141              }    
    142          }
    143          
    144          /*
    145          **===========================================================================
    146          ** Init the timer related registers
    147          **===========================================================================
    148          */ 
    149          void Init_TMR( void ) {
    150              /*--- Timer control (disable clock inputs) ---*/
    151          
    152              switch (UnitID) {
    153              case AN_ZB485:                  // AN-ZB485
    154                  TCCR0   =  0x99 ;      // Timer control register 0 
    155                  OCR0    =  3;         // Timer output compare register 0, 2MHZ //16MHz xtal
    156                  break;
    157              case AN_ZBANA:                  // AN-ZBANA
    158                  TCCR0   =  0x99 ;      // Timer control register 0 
    159                  OCR0    =  7 ;         // Timer output compare register 0, 1MHZ //16MHz xtal
    160                  break;
    161              default:
    162                  break;
    163              }
    164          
    165          } 
    166          
    167          /*
    168          **===========================================================================
    169          ** Init the USARTs registers
    170          **===========================================================================
    171          */ 
    172          void Init_USART( char channel, unsigned long baud ) {
    173          
    174          
    175              /*--- Configure UART data block ---*/
    176              UART[channel].TxFirst   = 0x00;
    177              UART[channel].TxLast    = 0x00;
    178              UART[channel].TxCount   = 0x00;
    179              UART[channel].RxFirst   = 0x00;
    180              UART[channel].RxLast    = 0x00;
    181              UART[channel].RxCount   = 0x00;
    182              UART[channel].RxState   = SYNC;
    183              UART[channel].SyncCnt   = 0 ;
    184              UART[channel].TxStatus  = 0x00;
    185          
    186              switch (channel) {
    187              case 0x00 :          
    188                  UART[channel].RxTimeout = RX_TO_TIME ;   // reset timeout
    189                  UART[channel].pTxBuffer = TxBufferCh0;        
    190                  UART[channel].pRxBuffer = RxBufferCh0;        
    191                  UCSR0A  = 0x00; 
    192                  UBRR0L  = ((XTAL_CPU / 16 / baud )-1) & 0xff;
    193                  UBRR0H  = (((XTAL_CPU / 16 / baud )-1)>> 8) & 0xff;
    194                  UCSR0B  = 0xb8;       /* tx/ rx enable, int udre/rxon */
    195                  UCSR0C  = 0x06;       /* n,8,1 */
    196                  break;
    197              case 0x01 :
    198                  UART[channel].RxTimeout = RX_TO_TIME ;   // reset timeout
    199                  UART[channel].pTxBuffer = TxBufferCh1;
    200                  UART[channel].pRxBuffer = RxBufferCh1;
    201                  UCSR1A  = 0x00; 
    202                  UBRR1L  = ((XTAL_CPU / 16 / baud )-1) & 0xff;
    203                  UBRR1H  = (((XTAL_CPU / 16 / baud )-1)>> 8) & 0xff;
    204                  UCSR1B  = 0xb8;       /* tx/ rx enable, int udre/rxon */
    205                  UCSR1C  = 0x06;       /* n,8,1 */
    206                  break;
    207              default:
    208                  break ;
    209              }    
    210          }
    211          
    212          
    213          /*
    214          **===========================================================================
    215          ** Init the AD converter registers
    216          **===========================================================================
    217          */ 
    218          void Init_AD( void ) {
    219          
    220              char i;     
    221              for (i = 0; i<8; i++) {                 // Init variables
    222                  ADInt.Result[i] = 0;                   // convertion resluts
    223              }
    224              ADChannel = 0x00 ;                      // AD channel to be converted
    225              ADMUX   = 0xc0 ;                        // Ref = 2,56V, right adjust
    226              ADCSR   = 0x8f ;                        // AD enabled, int enabled, xtal / 128
    227          }
    228          
    229          /*
    230          **===========================================================================
    231          ** Init values  in the system
    232          **===========================================================================
    233          */ 
    234          void Init_Values(void) {
    235          
    236          
    237          }

Errors: 46
Warnings: none
