###############################################################################
#
# IAR C/C++ Compiler V8.10.1.1784/W64 for Microchip AVR   28/Apr/2023  08:50:15
# Copyright 1996-2023 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file           =  D:\S2Prog\IO\ANZB-1281\Src\RS485.c
#    Command line          =
#        -f D:\S2Prog\IO\ANZB-1281\Debug\Obj\Main\RS485.r90.rsp
#        (D:\S2Prog\IO\ANZB-1281\Src\RS485.c --cpu=m128 -ms -o
#        D:\S2Prog\IO\ANZB-1281\Debug\Obj\Main -D OS_LIBMODE_D -D OS_UART=-1
#        -lCN D:\S2Prog\IO\ANZB-1281\Debug\List\Main -y --initializers_in_flash
#        --no_tbaa --debug -DENABLE_BIT_DEFINITIONS -e -I
#        D:\S2Prog\IO\ANZB-1281\INC\ -I
#        D:\S2Prog\IO\ANZB-1281\..\..\SHARED\INC\ --eeprom_size 4096 --clib
#        -Ohz) --dependencies=n
#        D:\S2Prog\IO\ANZB-1281\Debug\Obj\Main\RS485.r90.iar_deps
#    Locale                =  C
#    List file             =  D:\S2Prog\IO\ANZB-1281\Debug\List\Main\RS485.lst
#    Object file           =  D:\S2Prog\IO\ANZB-1281\Debug\Obj\Main\RS485.r90
#    Runtime model:           
#      __64bit_doubles     =  disabled
#      __SystemLibrary     =  CLib
#      __architecture      =  *
#      __cpu               =  3
#      __cpu_name          =  ATmega128
#      __dlib_version      =  clib
#      __enhanced_core     =  enabled
#      __enhanced_core_mul =  enabled
#      __has_elpm          =  true
#      __memory_model      =  2
#      __mex               =  disabled
#      __no_rampd          =  enabled
#      __rt_version        =  3
#      __vtable_memory     =  __nearflash
#
###############################################################################

D:\S2Prog\IO\ANZB-1281\Src\RS485.c
      1          
      2          /****************************************************************************************
      3          / Uart communication to external ADcards
      4          /
      5          ***************************************************************************************/
      6          
      7          #ifdef __ATMEGA_1280__
      8          #include	"iom1280.h"
      9          #endif
     10          
     11          #ifdef __ATMEGA_1281__
     12          #include	"iom1281.h"
     13          #endif
     14          #include "stdio.h"
     15          #include "math.h"
     16          #include "externals.h"
     17          #include "version.h"
     18          //#include "stdlib.h"
     19          //#include "string.h"
     20          
     21          
     22          
     23          /************************************************ *************************
     24          *   (This is a timer calback)
     25          *  Timout timer UART 0
     26          *
     27          *************************************************************************/
     28          void TimoutUART0(void) {
     29          
     30              U0_MCR &= ~RTS;      // set RTS off
     31          }
     32          
     33          /*************************************************************************
     34          *   (This is a timer calback)
     35          *  Timout timer UART 1
     36          *
     37          *************************************************************************/
     38          void TimoutUART1(void) {
     39          
     40              U1_MCR &= ~RTS;       // set RTS off
     41          }
     42          
     43          
     44          /*************************************************************************
     45          *   (This is a task)
     46          *  Usart handler UART send request
     47          *
     48          *************************************************************************/
     49          void ExtRS485Ctl(void) {
     50              char SeqCnt = 0;
     51              char PowerOnTimer = POWER_ON_CNT;                    // do not make a unwanted power on sequence in the starting phase
     52              char EventStatus;
     53              char AskMD[2];
     54          
     55              Init16552(0, 9600);                                      // Init UART channel 0
     56              Init16552(1, 9600);                                      // Init UART channel 1
     57          
     58              TData.RS4.PortUsed = ReadEEPROMByte(EEPROM_PORTSETUP);   // Get setup from EEPROM
     59              TData.RS4.SensorType[0] = ReadEEPROMByte(EEPROM_PORTSETUP + 1);
     60              TData.RS4.SensorType[1] = ReadEEPROMByte(EEPROM_PORTSETUP + 2);
     61          
     62              TData.RS4.ToTargetBuffer[0][0] = false;
     63              TData.RS4.ToTargetBuffer[1][0] = false;
     64              TData.RS4.FromTargetBuffer[0][0] = false;
     65              TData.RS4.FromTargetBuffer[1][0] = false;
     66          
     67              for (char i = 0; i < 8; i++) {
     68                  SetBit(PORTC, (TData.RS4.PortUsed & (0x01 << i)));      // Switch on power
     69                  OS_Delay(100);
     70              }
     71              OS_Delay(UART_START_DELAY);                               // Waiting for target startup
     72          
     73              while (1) {
     74                  for (PortPair = 0; PortPair < 4; PortPair++) {        // loop through all ports
     75                      if (UART16552[0].RxFaultCnt > MAX_16552_FAIL) {
     76                          EmptyRxBuf16552(0);                            // Empty UART channel 0
     77                      }
     78                      if (UART16552[1].RxFaultCnt > MAX_16552_FAIL) {
     79                          EmptyRxBuf16552(1);                            // Empty UART channel 1
     80                      }
     81                      if (PowerOnTimer < POWER_ON_CNT) {
     82                          if (++PowerOnTimer >= POWER_ON_CNT) {          // check if time to switch on power
     83                              SetRS4Port();                                // and set power on ports
     84                          }
     85                      }
     86                      SetBit(PORTE, 0xf0);
     87                      ClrBit(PORTE, (0x10 << PortPair) & 0xf0);            // set mux port
     88                      if ((TData.RS4.PortUsed >> PortPair) & 0x01) {              // sensor on port 0?
     89                          UART16552[0].TxFirst = 6;                       // Start packet build at pos.
     90                          char SnsType = (TData.RS4.SensorType[0] >> (2 * PortPair));
     91                          if (SnsType == 0x01) {    //Water ingress??
     92                              switch (SeqCnt) {
     93                              case 0:
     94                                  Uart_BuildReqWISCardStatus(0);          //Card status
     95                                  break;
     96                              case 20:
     97                                  if ((TData.RS4.FromTargetBuffer[0][0] == false) && (TData.RS4.EEPROMPortpair[0] == PortPair)) { // buffer ready
     98                                      Uart_BuildReqWISXData(0, 115);            // Request serial no
     99                                      if (++TData.RS4.EEPROMPortpair[0] >= 4) {
    100                                          TData.RS4.EEPROMPortpair[0] = 0;
    101                                      }
    102                                  } else {
    103                                      Uart_BuildReqWISData(0);                //WIS data
    104                                  }
    105                                  break;
    106                              default:
    107                                  Uart_BuildReqWISData(0);                //WIS data
    108                                  break;
    109                              }
    110                          } else if (SnsType == 0x02) {       // Radar??
    111                              switch (SeqCnt) {
    112                              case 20:
    113                                  if ((TData.RS4.FromTargetBuffer[0][0] == false) && (TData.RS4.EEPROMPortpair[0] == PortPair)) { // buffer ready
    114                                      if (++TData.RS4.EEPROMPortpair[0] >= 4) {
    115                                          TData.RS4.EEPROMPortpair[0] = 0;
    116                                      }
    117                                  }
    118                                  // Fall through and send the request
    119                              default:
    120                                  Uart_BuildReqRadarData(0);          // Radar data
    121                                  break;
    122                              case 0:
    123                                  Uart_BuildReqRadarInfo(0);          //Radar Information
    124                                  break;
    125                              }
    126                          } else {                                        // AN-SGCNV
    127                              if ((TData.RS4.ToTargetBuffer[0][0] == true) && // Data ready for this AD card
    128                                  (TData.RS4.ToTargetBuffer[0][1] == PortPair)) {
    129                                  Uart_BuildSndData(0);                       // add data to AD card package
    130                                  Uart_BuildReqConfig(0);                 //Config data, cmd 17
    131                                  AskMD[0] = false;
    132                              } else {
    133                                  AskMD[0] = true;
    134                              }
    135                              if (SeqCnt == 0) {
    136                                  Uart_BuildReqCardStatus(0);             //Card status, cmd 27
    137                              } else if (SeqCnt == 5) {
    138                                  Uart_BuildReqR16552(0);                 //Raw data, cmd 13
    139                              } else if (SeqCnt == 10) {
    140                                  Uart_BuildReqConfig(0);                 //Config data, cmd 17
    141                              } else if (SeqCnt == 15) {
    142                                  Uart_BuildReqC16552(0);                 //Cal data, cmd 16
    143                              } else if (SeqCnt == 20) {
    144                                  if ((TData.RS4.FromTargetBuffer[0][0] == false) && (TData.RS4.EEPROMPortpair[0] == PortPair)) { // buffer ready
    145                                      Uart_BuildReqEEPROMData(0);             //EEpromdata cmd, 24
    146                                      if ((TData.RS4.EEPROMADChannel[0] += 2) > 14) { //Next channel
    147                                          TData.RS4.EEPROMADChannel[0] = 0;
    148                                          if (++TData.RS4.EEPROMPortpair[0] >= 4) {
    149                                              TData.RS4.EEPROMPortpair[0] = 0;
    150                                          }
    151                                      }
    152                                  } else if (AskMD[0] == true) {
    153                                      Uart_BuildReqM16552(0);                 //Measure data, cmd 10
    154                                  }
    155                              } else if (AskMD[0] == true) {
    156                                  Uart_BuildReqM16552(0);                 //Measure data, cmd 10
    157                              }
    158                          }
    159                          Uart_BuildTail16552(0);
    160                      } else {
    161                          if (TData.RS4.EEPROMPortpair[0] == PortPair) {
    162                              if (++TData.RS4.EEPROMPortpair[0] >= 4) {  // make sure that the EEPROM reading is not stopped
    163                                  TData.RS4.EEPROMPortpair[0] = 0;
    164                              }
    165                          }
    166                      }
    167                      if ((TData.RS4.PortUsed >> (PortPair + 4)) & 0x01) {              // sensor on port 1?
    168                          UART16552[1].TxFirst = 6;                       // Start at
    169                          char SnsType = (TData.RS4.SensorType[1] >> (2 * PortPair));
    170                          if (SnsType == 0x01) {    //Water ingress??
    171                              switch (SeqCnt) {
    172                              case 0:
    173                                  Uart_BuildReqWISCardStatus(1);          //Card status
    174                                  break;
    175                              case 20:
    176                                  if ((TData.RS4.FromTargetBuffer[1][0] == false) && (TData.RS4.EEPROMPortpair[1] == PortPair)) { // buffer ready
    177                                      Uart_BuildReqWISXData(1, 115);            // Request serial no
    178                                      if (++TData.RS4.EEPROMPortpair[1] >= 4) {
    179                                          TData.RS4.EEPROMPortpair[1] = 0;
    180                                      }
    181                                  } else {
    182                                      Uart_BuildReqWISData(1);                //WIS data
    183                                  }
    184                                  break;
    185                              default:
    186                                  Uart_BuildReqWISData(1);                //WIS data
    187                                  break;
    188                              }
    189                          } else if (SnsType == 0x02) {       // Radar??
    190                              switch (SeqCnt) {
    191                              case 20:
    192                                  if ((TData.RS4.FromTargetBuffer[1][0] == false) && (TData.RS4.EEPROMPortpair[1] == PortPair)) { // buffer ready
    193                                      if (++TData.RS4.EEPROMPortpair[1] >= 4) {
    194                                          TData.RS4.EEPROMPortpair[1] = 0;
    195                                      }
    196                                  }
    197                                  // Fall through and send the request
    198                              default:
    199                                  Uart_BuildReqRadarData(1);          // Radar data
    200                                  break;
    201                              case 0:
    202                                  Uart_BuildReqRadarInfo(1);          //Radar Information
    203                                  break;
    204                              }
    205                          } else {                                        // AN-SGCNV
    206                              if ((TData.RS4.ToTargetBuffer[1][0] == true) && // Data ready for this AD card
    207                                  (TData.RS4.ToTargetBuffer[1][1] == (PortPair + 4))) {
    208                                  Uart_BuildSndData(1);                       // add data to AD card package
    209                                  Uart_BuildReqConfig(1);                 //Config data, cmd 17
    210                                  AskMD[1] = false;
    211                              } else {
    212                                  AskMD[1] = true;
    213                              }
    214                              if (SeqCnt == 0) {
    215                                  Uart_BuildReqCardStatus(1);             //Card status, cmd 27
    216                              } else if (SeqCnt == 5) {
    217                                  Uart_BuildReqR16552(1);                 //Raw data cmd, 13
    218                              } else if (SeqCnt == 10) {
    219                                  Uart_BuildReqConfig(1);                 //Config data, cmd 17
    220                              } else if (SeqCnt == 15) {
    221                                  Uart_BuildReqC16552(1);                 //Cal data  cmd, 16
    222                              } else if (SeqCnt == 20) {
    223                                  if ((TData.RS4.FromTargetBuffer[1][0] == false) && (TData.RS4.EEPROMPortpair[1] == PortPair)) { // buffer ready
    224                                      Uart_BuildReqEEPROMData(1);             //EEpromdata cmd, 24
    225                                      if ((TData.RS4.EEPROMADChannel[1] += 2) > 14) { //Next channel
    226                                          TData.RS4.EEPROMADChannel[1] = 0;
    227                                          if (++TData.RS4.EEPROMPortpair[1] >= 4) {
    228                                              TData.RS4.EEPROMPortpair[1] = 0;
    229                                          }
    230                                      }
    231                                  } else if (AskMD[1] == true) {
    232                                      Uart_BuildReqM16552(1);                 //Measure data, cmd 10
    233                                  }
    234                              } else if (AskMD[1] == true) {
    235                                  Uart_BuildReqM16552(1);                 //Measure data, cmd 10
    236                              }
    237                          }
    238                          Uart_BuildTail16552(1);
    239                      } else {
    240                          if (TData.RS4.EEPROMPortpair[1] == PortPair) {
    241                              if (++TData.RS4.EEPROMPortpair[1] >= 4) {  // make sure that the EEPROM reading is not stopped
    242                                  TData.RS4.EEPROMPortpair[1] = 0;
    243                              }
    244                          }
    245                      }
    246                      EventStatus = OS_WaitEventTimed(1, 1000);              // Wait for ready to send next
    247                      if (EventStatus & 0x02) {
    248                          if (PowerOnTimer >= POWER_ON_CNT) {
    249                              PowerOnTimer = 0;                              // and start over again
    250                          }
    251                      }
    252                  }
    253                  if (++SeqCnt > 20) {              //  all request within 20 x 2 sec.
    254                      SeqCnt = 0;
    255                  }
    256              }
    257          }
    258          
    259          
    260          /*************************************************************************
    261          *   (This is a task)
    262          *  Usart handler UART receive data
    263          *
    264          *************************************************************************/
    265          void ExtRS485Rec(void) {
    266          
    267              char portresp;
    268          
    269              OS_Delay(UART_START_DELAY + 800);           // Waiting for target startup and power on sequence
    270          
    271              while (1) {
    272                  OS_Delay(499);                          // wait for answer and correct the speed (.5 * 4 = 2 sec update)
    273                  portresp = OS_WaitEventTimed(3, 1);     // Wait for receive from both channels
    274                  if (portresp & 0x01) {                  // answer on ch 0
    275                      Usart16552CheckPackage(0);         // handle incomming package
    276                      TData.RS4.FailCnt[PortPair][0] = 0; // Reset counter
    277                      TData.RS4.IOUnitStatus[PortPair] &= ~COMFAIL_BIT; // No error
    278                      UART16552[0].RxFaultCnt = 0;          // OK package on 16552 channel
    279                  } else {
    280                      UART16552[0].RxFaultCnt++;          // Fault in package on 16552 channel
    281                      TData.RS4.FailCnt[PortPair][1]++;      // no answer total counter
    282                      if (TData.RS4.FailCnt[PortPair][0]++ > FAILCNT_ERROR) {
    283                          TData.RS4.IOUnitStatus[PortPair] |= COMFAIL_BIT;      // report fault
    284                      }
    285                      if ((TData.RS4.PortUsed >> PortPair) & 0x01) {              // sensor on port 0?
    286                          if ((TData.RS4.FailCnt[PortPair][0] & 0x0007) == 0x0004) {   //check if powqer shall be switched off
    287                              ClrBit(PORTC, (0x01 << PortPair));            // Switch off power
    288                              OS_SignalEvent(2, &TCB_RS485Ctl);
    289                          }
    290                      }
    291                  }
    292                  if (portresp & 0x02) {                  // answer on ch 1
    293                      Usart16552CheckPackage(1);         // handle incomming package
    294                      TData.RS4.FailCnt[PortPair + 4][0] = 0; // Reset counter
    295                      TData.RS4.IOUnitStatus[PortPair + 4] &= ~COMFAIL_BIT; // No error
    296                      UART16552[1].RxFaultCnt = 0;          // OK package on 16552 channel
    297                  } else {
    298                      UART16552[1].RxFaultCnt++;          // Fault in package on 16552 channel
    299                      TData.RS4.FailCnt[PortPair + 4][1]++;      // no answer
    300                      if (TData.RS4.FailCnt[PortPair + 4][0]++ > FAILCNT_ERROR) {
    301                          TData.RS4.IOUnitStatus[PortPair + 4] |= COMFAIL_BIT;      // report fault
    302                      }
    303                      if ((TData.RS4.PortUsed >> (PortPair + 4)) & 0x01) {              // sensor on port 1?
    304                          if ((TData.RS4.FailCnt[PortPair + 4][0] & 0x0007) == 0x0004) {   //check if powqer shall be switched off
    305                              ClrBit(PORTC, (0x01 << (PortPair + 4)));            // Switch off power
    306                              OS_SignalEvent(2, &TCB_RS485Ctl);
    307                          }
    308                      }
    309                  }
    310                  OS_SignalEvent(1, &TCB_RS485Ctl);
    311              }
    312          }
    313          
    314          /*************************************************************************
    315          *
    316          *  Set ports on or off
    317          *
    318          *************************************************************************/
    319          void SetRS4Port(void) {
    320          
    321              PORTC = TData.RS4.PortUsed;
    322          
    323          }
    324          
    325          /*************************************************************************
    326          *
    327          *  Check the incoming packages from AN_SGCNV / WIS
    328          *
    329          *************************************************************************/
    330          void Usart16552CheckPackage(char ch) {
    331          
    332              unsigned short pointer;
    333              char count_out, more;
    334          
    335              count_out = MAX_PROT_CMD;                  // max command
    336              more = true;
    337              pointer = 4;
    338              do {
    339                  if (!CheckActionUart16552(ch, pointer)) {
    340                      more = false;                          // terminate while loop
    341                  }
    342                  pointer += UART16552[ch].pRxBuffer[pointer + 1] + 2;            // Point to a command cmd hb/lb
    343                  if (!--count_out) {
    344                      more = false;
    345                  }
    346              } while (more && (pointer < UART16552[ch].RxPacklen - 3));
    347              GoToSyncUART16552(ch);
    348          }
    349          
    350          /*************************************************************************
    351          *
    352          *  Check action on received data from AN_SGCNV
    353          *
    354          *************************************************************************/
    355          char CheckActionUart16552(char ch, unsigned short pointer) {
    356          
    357              char retval = true;
    358          
    359              switch (UART16552[ch].pRxBuffer[pointer]) {    // check action
    360          
    361              case ANP1_REP_MP_DATA :                              // Measured pressure data
    362              case ANP1_REP_MT_DATA :                              // Measured temperature data
    363              case ANP1_REP_MO_DATA :                              // Measured "other" data
    364                  ReceivePTOData(ch, pointer + 2);                     // receive package
    365                  break;
    366              case ANP1_REP_WH_DATA :                              // Measured "washtrack and high level" data
    367                  ReceiveWHData(ch, pointer + 2);                     // receive package
    368                  break;
    369              case ANP1_REP_RP_DATA :                              // Raw pressure data
    370              case ANP1_REP_RT_DATA :                              // Raw temp. data
    371              case ANP1_REP_RO_DATA :                              // Raw "other" data
    372                  ReceiveRData(ch, pointer + 2);              // receive package
    373                  break;
    374              case ANP1_REP_CAL_DATA :                             // Raw "other" data
    375                  ReceiveCData(ch, pointer + 2);              // receive package
    376                  break;
    377          
    378              case ANP1_REP_CARD_STAT :                             // card status package
    379                  ReceiveCardStatus(ch, pointer + 2);          // receive package
    380                  break;
    381          
    382              case ANP1_REP_CONFIG :                             // config data
    383                  ReceiveConfigData(ch, pointer + 2);          // receive package
    384                  break;
    385          
    386              case ANP1_REP_EEP_DATA :                             // card eeprome
    387                  ReceiveCardEEPROMData(ch, pointer + 2);          // receive package
    388                  break;
    389          
    390              case ANP1_REP_WIS_STAT :                             // Card status from WIS
    391                  ReceiveWISStatus(ch, pointer + 2);            // receive package
    392                  break;
    393          
    394              case ANP1_REP_WIS_XDATA :                             // Card WIS protocol
    395                  ReceiveWISXData(ch, pointer + 2);            // receive package
    396                  break;
    397          
    398              case ANP1_REP_WIS_DATA :                             // Data from WIS
    399                  ReceiveWISData(ch, pointer + 2);             // receive package
    400                  break;
    401              case ANP1_REP_GODA_DATA:
    402                  ReceiveRadarData(ch, pointer + 2);             // receive package
    403                  break;
    404              case ANP1_REP_GODA_INFO:
    405                  ReceiveRadarInfo(ch, pointer + 2);             // receive package
    406                  break;
    407              case ANP1_ECMD_NMDRQACK :                             // No more data, send ack.
    408              case ANP1_ECMD_NMDWOACK :                         // No more data
    409                  retval = false;
    410                  break;
    411              }
    412              return retval;
    413          }
    414          
    415          /*************************************************************************
    416          *
    417          *  Receive card status from WIS
    418          *
    419          *************************************************************************/
    420          void ReceiveWISStatus(char ch, unsigned short pointer) {
    421          
    422              TData.RS4.TargetStatusSWVer[(ch * 4) + PortPair] |= UART16552[ch].pRxBuffer[pointer];
    423              TData.RS4.TargetStatusAddress[(ch * 4) + PortPair] = UART16552[ch].pRxBuffer[pointer + 1];
    424              if (UART16552[ch].pRxBuffer[pointer + 4]) {
    425                  TData.RS4.TargetStatusAddress[(ch * 4) + PortPair] |= 0x80;
    426              }
    427          }
    428          
    429          /*************************************************************************
    430          *
    431          *  Receive WIS protocol data
    432          *
    433          *************************************************************************/
    434          void ReceiveWISXData(char ch, unsigned short pointer) {
    435          
    436              char i;
    437          
    438              switch (UART16552[ch].pRxBuffer[pointer++]) {
    439              case 115:                                     // Serial number
    440                  TData.RS4.FromTargetBuffer[ch][0] = true;
    441                  TData.RS4.FromTargetBuffer[ch][1] = (ch * 4) + PortPair;
    442                  for (i = 2; i < (4 + 2); i++) {
    443                      TData.RS4.FromTargetBuffer[ch][i] = UART16552[ch].pRxBuffer[pointer++];
    444                  }
    445                  break;
    446              default:
    447                  break;
    448              }
    449          }
    450          
    451          /*************************************************************************
    452          *
    453          *  Receive measured data from WIS
    454          *
    455          *************************************************************************/
    456          void ReceiveWISData(char ch, unsigned short pointer) {
    457          
    458              TData.RS4.Result[(ch * 4) + PortPair][0] = (float)UART16552[ch].pRxBuffer[pointer + 0];       // Water detected
    459              TData.RS4.Result[(ch * 4) + PortPair][1] = (float)((UART16552[ch].pRxBuffer[pointer + 1] << 8) // Temperature
    460                                                                 + UART16552[ch].pRxBuffer[pointer + 2]) / 10.0;
    461              TData.RS4.TargetSetup1[(ch * 4) + PortPair][0] = UART16552[ch].pRxBuffer[pointer + 3];         // Status
    462              TData.RS4.TargetSetup2[(ch * 4) + PortPair][0] = 0;                                            // Unused
    463          }
    464          
    465          
    466          /*************************************************************************
    467          *
    468          *  Receive measured data from Radar
    469          *
    470          *************************************************************************/
    471          void ReceiveRadarData(char ch, unsigned short pointer) {
    472              float *Data1 = (float *)&UART16552[ch].pRxBuffer[pointer + 0];
    473              float *Data2 = (float *)&UART16552[ch].pRxBuffer[pointer + 4];
    474          
    475              TData.RS4.Result[(ch * 4) + PortPair][0] = *Data1;       // Distance
    476              TData.RS4.Result[(ch * 4) + PortPair][1] = *Data2;      // Level
    477              TData.RS4.TargetSetup1[(ch * 4) + PortPair][0] = UART16552[ch].pRxBuffer[pointer + 8];         // Status
    478              TData.RS4.TargetSetup2[(ch * 4) + PortPair][0] = UART16552[ch].pRxBuffer[pointer + 9];         // Unused???
    479          }
    480          
    481          
    482          /*************************************************************************
    483          *
    484          *  Receive Serial number and version information from Radar
    485          *
    486          *************************************************************************/
    487          void ReceiveRadarInfo(char ch, unsigned short pointer) {
    488              // TData.RS4.SerialNumber[(ch * 4) + PortPair] = atol((const char *)&UART16552[ch].pRxBuffer[pointer + 0]);
    489              TData.RS4.TargetStatusSWVer[(ch * 4) + PortPair] = *((long *)&UART16552[ch].pRxBuffer[pointer + 10]);
    490          }
    491          
    492          /*************************************************************************
    493          *
    494          *  Receive pressure measured data from AN_SGCNV
    495          *
    496          *************************************************************************/
    497          void ReceivePTOData(char ch, unsigned short pointer) {
    498          
    499              unsigned short pnt, ADCh;
    500              short packlen;
    501          
    502              packlen = UART16552[ch].pRxBuffer[pointer - 1];
    503          
    504              OS_Use(&UARTSEND);    // Do not write to buffer while the buffer can be read by other
    505          
    506              if (packlen > 0) {
    507                  for (pnt = 0; pnt < packlen; pnt += 6) {
    508                      ADCh = UART16552[ch].pRxBuffer[pointer + pnt];
    509                      if (ADCh < 14) {
    510                          TData.RS4.TargetSetup1[(ch * 4) + PortPair][ADCh] = UART16552[ch].pRxBuffer[pointer + pnt + 1];
    511                          *((float *)&TData.RS4.Result[(ch * 4) + PortPair][ADCh]) = *((float *)&UART16552[ch].pRxBuffer[pointer + pnt + 2]);
    512                      }
    513                  }
    514              }
    515              OS_Unuse(&UARTSEND);
    516          }
    517          /*************************************************************************
    518          *
    519          *  Receive Wash Track and High Level data from AN_SGCNV
    520          *
    521          *************************************************************************/
    522          void ReceiveWHData(char ch, unsigned short pointer) {
    523          
    524              // Fixed packet length
    525              //short packlen;
    526          
    527              //packlen = UART16552[ch].pRxBuffer[pointer - 1];
    528          
    529              OS_Use(&UARTSEND);    // Do not write to buffer while the buffer can be read by other
    530          
    531              for (short pnt = 0; pnt < 4; pnt++) {
    532                  TData.RS4.WTrackCnt[(ch * 4) + PortPair][pnt] = ((unsigned short*)&UART16552[ch].pRxBuffer[pointer])[pnt];  // 4 x Wash track 
    533              }
    534              TData.RS4.LevelSwitch[(ch * 4) + PortPair] = UART16552[ch].pRxBuffer[pointer+8]; // Hgh levels in 9th byte
    535              TData.RS4.WTTime[(ch * 4) + PortPair] = *((unsigned short *)&UART16552[ch].pRxBuffer[pointer+9]);  // WashTrack time in 10th and 11th bytes
    536              
    537              TData.RS4.WHDataAvailable |= 0x01 << ((ch * 4) + PortPair);
    538              OS_Unuse(&UARTSEND);
    539          }
    540          
    541          
    542          /************************************************************************
    543          *
    544          *  Receive raw data for pressure, temp and other from AN_SGCNV
    545          *
    546          *************************************************************************/
    547          void ReceiveRData(char ch, unsigned short pointer) {
    548          
    549              char pnt, ADCh;
    550              short packlen;
    551          
    552              packlen = UART16552[ch].pRxBuffer[pointer - 1];
    553          
    554              if (packlen > 0) {
    555                  for (pnt = 0; pnt < packlen; pnt += 4) {
    556                      ADCh = UART16552[ch].pRxBuffer[pointer + pnt];
    557                      if (ADCh < 14) {
    558                          TData.RS4.TargetSetup1[(ch * 4) + PortPair][ADCh] = UART16552[ch].pRxBuffer[pointer + pnt + 1];
    559                          *((short *)&TData.RS4.Raw[(ch * 4) + PortPair][ADCh]) = *((short *)&UART16552[ch].pRxBuffer[pointer + pnt + 2]);
    560                      }
    561                  }
    562              }
    563          }
    564          
    565          /*************************************************************************
    566          *
    567          *  Receive cal data  from AN_SGCNV
    568          *
    569          *************************************************************************/
    570          void ReceiveCData(char ch, unsigned short pointer) {
    571          
    572              char pnt, ADCh;
    573              short packlen;
    574          
    575              packlen = UART16552[ch].pRxBuffer[pointer - 1];
    576          
    577              if (packlen > 0) {
    578                  for (pnt = 0; pnt < packlen; pnt += 4) {
    579                      ADCh = UART16552[ch].pRxBuffer[pointer + pnt];
    580                      if (ADCh < 14) {
    581                          TData.RS4.TargetSetup1[(ch * 4) + PortPair][ADCh] = UART16552[ch].pRxBuffer[pointer + pnt + 1];
    582                          *((short *)&TData.RS4.Cal[(ch * 4) + PortPair][ADCh]) = *((short *)&UART16552[ch].pRxBuffer[pointer + pnt + 2]);
    583                      }
    584                  }
    585              }
    586          }
    587          
    588          /*************************************************************************
    589          *
    590          *  Receive card status  from AN_SGCNV
    591          *
    592          *************************************************************************/
    593          void ReceiveCardStatus(char ch, unsigned short pointer) {
    594          
    595              TData.RS4.TargetStatusSWVer[(ch * 4) + PortPair] = UART16552[ch].pRxBuffer[pointer];
    596              TData.RS4.TargetStatusAddress[(ch * 4) + PortPair] = UART16552[ch].pRxBuffer[pointer + 1];
    597          }
    598          
    599          /*************************************************************************
    600          *
    601          *  Receive config data from AN_SGCNV
    602          *
    603          *************************************************************************/
    604          void ReceiveConfigData(char ch, unsigned short pointer) {
    605          
    606              char i, ADCh;
    607          
    608              for (i = 0; i < 14; i++) {
    609                  ADCh = UART16552[ch].pRxBuffer[pointer++];
    610                  if (ADCh < 14) {
    611                      TData.RS4.TargetSetup1[(ch * 4) + PortPair][ADCh] = UART16552[ch].pRxBuffer[pointer];
    612                      TData.RS4.TargetSetup2[(ch * 4) + PortPair][ADCh] = UART16552[ch].pRxBuffer[pointer + 1];
    613                  }
    614                  pointer += 2;
    615              }
    616          }
    617          
    618          /*************************************************************************
    619          *
    620          *  Receive eeprom data from AN_SGCNV
    621          *
    622          *************************************************************************/
    623          void ReceiveCardEEPROMData(char ch, unsigned short pointer) {
    624          
    625              short i;
    626          
    627              TData.RS4.FromTargetBuffer[ch][0] = true;
    628              TData.RS4.FromTargetBuffer[ch][1] = (ch * 4) + PortPair;
    629              for (i = 2; i < (41 + 2); i++) {
    630                  TData.RS4.FromTargetBuffer[ch][i] = UART16552[ch].pRxBuffer[pointer++];
    631              }
    632          }
    633          
    634          /*************************************************************************
    635          *
    636          * Build send packet header for AN-SGCNV
    637          *
    638          *************************************************************************/
    639          void Uart_BuildHeader16552(char ch) {
    640          
    641              UART16552[ch].RxFirst = 0;                                // Reset pointers
    642              UART16552[ch].RxLast = 0;
    643              UART16552[ch].TxLast = 0;
    644          
    645              UART16552[ch].pTxBuffer[0] = ANPRO1_SYN;                        /* Sync */
    646              UART16552[ch].pTxBuffer[1] = ANPRO1_SYN;                        /* Sync */
    647              UART16552[ch].pTxBuffer[2] = 0;                          /* Rx address */
    648              UART16552[ch].pTxBuffer[3] = MY_SGCNV_ADDR;              /* My address to AD-SGCNV */
    649              UART16552[ch].pTxBuffer[4] = 0;                          /* packlen HB, don't know yet */
    650              UART16552[ch].pTxBuffer[5] = 0;                          /* packlen LB, don't know yet */
    651          }
    652          
    653          /*************************************************************************
    654          *
    655          * Build  packet tail
    656          *
    657          *************************************************************************/
    658          void Uart_BuildTail16552(char ch) {
    659          
    660              Uart_BuildHeader16552(ch);                                // fist build the header
    661          
    662              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 1;         // command, No more data
    663              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;         // error
    664          
    665              UART16552[ch].pTxBuffer[4] = (UART16552[ch].TxFirst) >> 8;           // packet len high
    666              UART16552[ch].pTxBuffer[5] = UART16552[ch].TxFirst;                // correct length because stx's
    667          
    668          
    669              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst] = CalcDSTxChecksumUART16552(ch, UART16552[ch].TxFirst); // Get checksum
    670              UART16552[ch].TxFirst++;                                     // OBS!! must be inc here due
    671                                                                           // to ANSI standard !!!!
    672          
    673              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANPRO1_EOT;            // End of transmission
    674              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0x00;            //switch off transmitter delay
    675          
    676              UART16552[ch].TxCount = UART16552[ch].TxFirst - 1;       //bytes to send (-1 for the start byte)
    677              UART16552[ch].TxLast = 1;                               // sent 1 byte
    678              GoToSyncUART16552(ch);                                 // go to sync modus for recive
    679              if (ch == 0) {                                           // Turn on TXE for channel
    680                  OS_RetriggerTimer(&TimerUART0);                    // and start timeout timer
    681                  U0_MCR |= RTS;                                    // set RTS on
    682                  OS_Delay(20);                                           // Wait (ms) for tx stable
    683                  U0_THR = UART16552[ch].pTxBuffer[0];                // Send 1. byte
    684              } else if (ch == 1) {
    685                  OS_RetriggerTimer(&TimerUART1);                    // and start timeout timer
    686                  U1_MCR |= RTS;                                      // set RTS on
    687                  OS_Delay(20);                                           // Wait (ms) for tx stable
    688                  U1_THR = UART16552[ch].pTxBuffer[0];                  // Send 1. byte
    689              }
    690          }
    691          
    692          /*************************************************************************
    693          *
    694          * Build send request for system status on WIS
    695          *
    696          *************************************************************************/
    697          void Uart_BuildReqWISCardStatus(char ch) {
    698          
    699              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_SND_WIS_STAT;       /*command, send data */
    700              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;                 /*nob */
    701          
    702          }
    703          
    704          /*************************************************************************
    705          *
    706          * Build send request for WIS protocoler on WIS
    707          *
    708          *************************************************************************/
    709          void Uart_BuildReqWISXData(char ch, char sndcmd) {
    710          
    711              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_SND_WIS_XDATA;       /*command, send data */
    712              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 1;                        /*nob */
    713              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = sndcmd;                 // xdata cmd
    714          
    715          }
    716          
    717          /*************************************************************************
    718          *
    719          * Build send request for measure data to Water ingress
    720          *
    721          *************************************************************************/
    722          void Uart_BuildReqWISData(char ch) {
    723          
    724              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_SND_WIS_DATA;       /*command, send data */
    725              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 1;                 /*nob */
    726              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;                 /*data */
    727          
    728          }
    729          
    730          
    731          /*************************************************************************
    732          *
    733          * Build send request for GODA measurement
    734          *
    735          *************************************************************************/
    736          void Uart_BuildReqRadarData(char ch) {
    737          
    738              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_SND_GODA_DATA;       /*command, send data */
    739              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 1;                        /*nob */
    740              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;                 // data
    741          
    742          }
    743          
    744          /*************************************************************************
    745          *
    746          * Build send request for GODA device information
    747          *
    748          *************************************************************************/
    749          void Uart_BuildReqRadarInfo(char ch) {
    750          
    751              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_SND_GODA_INFO;       /*command, send data */
    752              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;                        /*nob */
    753          }
    754          
    755          /*************************************************************************
    756          *
    757          * Build datablock to AN-SGCNV
    758          *
    759          *************************************************************************/
    760          void Uart_BuildSndData(char ch) {
    761          
    762              char i;
    763          
    764              for (i = 3; i < (TData.RS4.ToTargetBuffer[ch][2]) + 3; i++) {
    765                  UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = TData.RS4.ToTargetBuffer[ch][i];       /*command, send data */
    766              }
    767              TData.RS4.ToTargetBuffer[ch][0] = false;            // data sent
    768          }
    769          
    770          /*************************************************************************
    771          *
    772          * Build send request for measure data to AN-SGCNV
    773          *
    774          *************************************************************************/
    775          void Uart_BuildReqM16552(char ch) {
    776          
    777              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_REQ_M_DATA;       /*command, send data */
    778              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 1;                 /*nob */
    779              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;                 /*data */
    780          
    781          }
    782          
    783          /*************************************************************************
    784          *
    785          * Build send request for raw data to AN-SGCNV
    786          *
    787          *************************************************************************/
    788          void Uart_BuildReqR16552(char ch) {
    789          
    790              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_REQ_R_DATA;       /*command, send data */
    791              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 1;                 /*nob */
    792              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;                 /*data */
    793          
    794          }
    795          
    796          /*************************************************************************
    797          *
    798          * Build send request for cal data to AN-SGCNV
    799          *
    800          *************************************************************************/
    801          void Uart_BuildReqC16552(char ch) {
    802          
    803              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_REQ_C_DATA;       /*command, send data */
    804              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 1;                 /*nob */
    805              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;                 /*data */
    806          
    807          }
    808          
    809          /*************************************************************************
    810          *
    811          * Build send request for system status on AN_SGCNV
    812          *
    813          *************************************************************************/
    814          void Uart_BuildReqCardStatus(char ch) {
    815          
    816              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_REQ_CARD_STAT;       /*command, send data */
    817              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 1;                 /*nob */
    818              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;                 /*data */
    819          
    820          }
    821          
    822          /*************************************************************************
    823          *
    824          * Build send request for card config on AN_SGCNV
    825          *
    826          *************************************************************************/
    827          void Uart_BuildReqConfig(char ch) {
    828          
    829              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_REQ_CONFIG;       /*command, send data */
    830              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 0;                 /*nob */
    831          
    832          }
    833          
    834          /*************************************************************************
    835          *
    836          * Build send request for EEPROM data on AN_SGCNV
    837          *
    838          *************************************************************************/
    839          void Uart_BuildReqEEPROMData(char ch) {
    840          
    841              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = ANP1_REQ_EEP_DATA;       /*command, send data */
    842              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = 1;                 /*nob */
    843              UART16552[ch].pTxBuffer[UART16552[ch].TxFirst++] = TData.RS4.EEPROMADChannel[ch];       /*data */
    844          
    845          }
    846          /*************************************************************************
    847          *
    848          *  Receive data on USARTs
    849          *
    850          *************************************************************************/
    851          void ReceivePacketUart16552(char ch) {
    852          
    853              switch (UART16552[ch].RxState) {                  // check status
    854              case SYNC :
    855                  // all functionallity in inerrupt routine
    856                  break;
    857              case HEADER :
    858                  if (UART16552[ch].RxLast >= 3) {             // receive header
    859                      UART16552[ch].RxPacklen = ((UART16552[ch].pRxBuffer[2] * 256) +
    860                                                 UART16552[ch].pRxBuffer[3]);    // Find length of package
    861                      if ((UART16552[ch].RxPacklen < ((short)RXSIZE_UART_16552 - UART16552[ch].RxLast)) &&    /* chk. header */
    862                          (UART16552[ch].RxPacklen >= MIN_PACK_LEN)) {
    863                          UART16552[ch].RxState = RECEIVE;       // Header ok og to data receive state
    864                          UART16552[ch].RxCount = UART16552[ch].RxLast + 1;    // Set receivcounter
    865                      } else {
    866                          GoToSyncUART16552(ch);                                    // go to sync modus for recive
    867                      }
    868                  }
    869                  break;
    870              case RECEIVE :
    871                  if (++UART16552[ch].RxCount >= UART16552[ch].RxPacklen) {
    872                      if ((UART16552[ch].pRxBuffer[UART16552[ch].RxPacklen - 1]) == ANPRO1_EOT) {
    873                          if (CalcDSRxChecksum16552(ch)) {
    874                              if (UART16552[ch].pRxBuffer[0] == MY_SGCNV_ADDR) {     // reply from AN_SGCNV
    875                                  UART16552[ch].RxState = HANDLE;                   // Package OK
    876                                  if (ch == 0) {
    877                                      OS_SignalEvent(1, &TCB_RS485Rec);
    878                                  } else if (ch == 1) {
    879                                      OS_SignalEvent(2, &TCB_RS485Rec);
    880                                  }
    881                              } else {
    882                                  GoToSyncUART16552(ch);                             // go to sync modus for recive
    883                              }
    884                          } else {
    885                              GoToSyncUART16552(ch);                                // go to sync modus for recive
    886                          }
    887                      } else {
    888                          GoToSyncUART16552(ch);                                    // go to sync modus for recive
    889                      }
    890                  }
    891                  break;
    892              case HANDLE :
    893                  break;
    894              default :
    895                  GoToSyncUART16552(ch);                                            // go to sync modus for recive
    896                  break;
    897              }                                                           // end switch
    898              if (++UART16552[ch].RxLast >= RXSIZE_UART_16552) {                     // check pointer
    899                  UART16552[ch].RxLast = 0;                                     // reset pointer
    900              }
    901          }
    902          
    903          
    904          /*************************************************************************
    905          *
    906          * Calculate tx checksum for Dallas Semiconductor one-wire CRC
    907          *
    908          *************************************************************************/
    909          char CalcDSTxChecksumUART16552(char ch, unsigned short len) {
    910          
    911              unsigned short cnt;
    912              unsigned char csum;
    913          
    914              csum = 0;
    915              for (cnt = 2; cnt < len; cnt++) {
    916                  csum = crc[csum ^ UART16552[ch].pTxBuffer[cnt]];
    917              }
    918              return csum;
    919          }
    920          
    921          /*************************************************************************
    922          *
    923          * Calculate rx checksum for Dallas Semiconductor one-wire CRC
    924          *
    925          *************************************************************************/
    926          short CalcDSRxChecksum16552(char ch) {
    927          
    928              short cnt;
    929              unsigned char csum;
    930          
    931              csum = 0;
    932              for (cnt = 0; cnt < (UART16552[ch].RxPacklen - 2); cnt++) {
    933                  csum = crc[csum ^ UART16552[ch].pRxBuffer[cnt]];
    934              }
    935              if (csum == UART16552[ch].pRxBuffer[UART16552[ch].RxPacklen - 2]) {
    936                  return true;
    937              } else {
    938                  return false;
    939              }
    940          }
    941          
    942          /*************************************************************************
    943          *
    944          * Goes to sync mode
    945          *
    946          *************************************************************************/
    947          void GoToSyncUART16552(char ch) {
    948          
    949              if (ch < 2) {
    950                  UART16552[ch].SyncCnt = 0;                        // ready for sync
    951                  UART16552[ch].RxState = SYNC;
    952                  UART16552[ch].RxFirst = 0;
    953                  UART16552[ch].RxPacklen = 0;
    954              }
    955          }
    956          
    957          /*************************************************************************
    958          *
    959          *  Empty rx buffer on PC16552 UART
    960          *
    961          *************************************************************************/
    962          void EmptyRxBuf16552(char uartno) {
    963          
    964              switch (uartno) {
    965              case 0:
    966                  do {
    967                      U0_RBR;
    968                  } while (U0_LSR & DATA_READY);
    969                  break;
    970              case 1:
    971                  do {
    972                      U1_RBR;
    973                  } while (U1_LSR & DATA_READY);
    974                  break;
    975              }
    976          }
    977          
    978          /*************************************************************************
    979          *
    980          *  Init the PC16552 UART
    981          *
    982          *************************************************************************/
    983          void Init16552(char channel, unsigned long baud) {
    984          
    985              /*--- Configure UART data block ---*/
    986              UART16552[channel].TxFirst = 0x00;
    987              UART16552[channel].TxLast = 0x00;
    988              UART16552[channel].TxCount = 0x00;
    989              UART16552[channel].RxFirst = 0x00;
    990              UART16552[channel].RxLast = 0x00;
    991              UART16552[channel].RxCount = 0x00;
    992              UART16552[channel].RxState = SYNC;
    993              UART16552[channel].SyncCnt = 0;
    994              UART16552[channel].TxStatus = 0x00;
    995          
    996              switch (channel) {
    997              case 0x00 :
    998                  UART16552[channel].RxTimeout = RX_TO_TIME;   // reset timeout
    999                  UART16552[channel].pTxBuffer = TxBuf16552Ch0;
   1000                  UART16552[channel].pRxBuffer = RxBuf16552Ch0;
   1001                  U0_LCR = 0x80;          // set DLAB
   1002                  U0_DLL = ((XTAL_CPU / 8 / 16 / baud) & 0xff);
   1003                  U0_DLM = (((XTAL_CPU / 8 / 16 / baud) >> 8) & 0xff);
   1004                  U0_LCR = 0x03;          // reset DLAB and set 8,n,1
   1005                  U0_FCR = 0x01;          // enable FIFO ..
   1006                  U0_FCR = 0xC1;          // and set RXLevel to 14
   1007                  U0_IER = 0x03;          // enable TX and RX int.
   1008                  U0_MCR = 0x00;          // RTS off
   1009                  break;
   1010              case 0x01 :
   1011                  UART16552[channel].RxTimeout = RX_TO_TIME;   // reset timeout
   1012                  UART16552[channel].pTxBuffer = TxBuf16552Ch1;
   1013                  UART16552[channel].pRxBuffer = RxBuf16552Ch1;
   1014                  U1_LCR = 0x80;          // set DLAB
   1015                  U1_DLL = ((XTAL_CPU / 8 / 16 / baud) & 0xff);
   1016                  U1_DLM = (((XTAL_CPU / 8 / 16 / baud) >> 8) & 0xff);
   1017                  U1_LCR = 0x03;          // reset DLAB and set 8,n,1
   1018                  U1_FCR = 0x01;          // enable FIFO ..
   1019                  U1_FCR = 0xC1;          // and set RXLevel to 14
   1020                  U1_IER = 0x03;          // enable TX and RX int.
   1021                  U1_MCR = 0x00;          // RTS off
   1022                  break;
   1023              default:
   1024                  break;
   1025              }
   1026          }

Errors: 10
Warnings: none
