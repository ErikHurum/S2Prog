###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       29/Dec/2022  11:10:01
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\hart active\Src\UsartPro.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW97A7.tmp ("D:\S2Prog\IO\hart
#        active\Src\UsartPro.c" --cpu=m1280 -ms -o "D:\S2Prog\IO\hart
#        active\Release_debug\Obj" -D OS_LIBMODE_S -D OS_UART=-1 -lCN
#        "D:\S2Prog\IO\hart active\Release_debug\List" -y
#        --initializers_in_flash -DENABLE_BIT_DEFINITIONS -e -I
#        "D:\S2Prog\IO\hart active\INC\\" -I "D:\S2Prog\IO\hart
#        active\..\..\SHARED\INC\\" --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -Ohs)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\hart active\Release_debug\List\UsartPro.lst
#    Object file  =  D:\S2Prog\IO\hart active\Release_debug\Obj\UsartPro.r90
#
###############################################################################

D:\S2Prog\IO\hart active\Src\UsartPro.c
      1          /****************************************************************************************
      2          / Com protocol for USART0
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0xc1
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "string.h"
     10          #include "RTOS.h"
     11          #include "hart.h"
     12          #include "externals.h"
     13          #include "version.h"
     14          #include "structs.h"
     15          

   \                                 In  segment ABSOLUTE, at 0x21fd
     16          __no_init volatile int RestartCnt             @0x21FD;
   \                     RestartCnt:
   \   00000000                      DS8 2
     17          //extern __no_init TargetData  TData;                    
     18          /*************************************************************************
     19          *   
     20          *  Handle the ANPRO10 protocol
     21          * 
     22          *  Returns 1 if a reply has been sent
     23          *
     24          *************************************************************************/

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   00000000                      DS8 2
     25          static unsigned short LastCommand = 0;

   \                                 In  segment CODE, align 2, keep-with-next
     26          char ANPRO10_UnpackPacket(My485UARTDataType *pMy485UART, unsigned char *Buf) {
   \                     ANPRO10_UnpackPacket:
   \   00000000   92DA               ST      -Y, R13
   \   00000002   92CA               ST      -Y, R12
   \   00000004   92BA               ST      -Y, R11
   \   00000006   92AA               ST      -Y, R10
   \   00000008   928A               ST      -Y, R8
   \   0000000A   927A               ST      -Y, R7
   \   0000000C   926A               ST      -Y, R6
   \   0000000E   925A               ST      -Y, R5
   \   00000010   924A               ST      -Y, R4
   \   00000012   93BA               ST      -Y, R27
   \   00000014   93AA               ST      -Y, R26
   \   00000016   939A               ST      -Y, R25
   \   00000018   938A               ST      -Y, R24
   \   0000001A                      REQUIRE ?Register_R4_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R5_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R6_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R7_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R8_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R10_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R11_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R12_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R13_is_cg_reg
   \   0000001A   01C8               MOVW    R25:R24, R17:R16
   \   0000001C   01D9               MOVW    R27:R26, R19:R18
     27              const ANPRO10_PacketHeading *pPH = (ANPRO10_PacketHeading *)Buf;
   \   0000001E   0189               MOVW    R17:R16, R19:R18
     28              pMy485UART->RxCount++;
   \   00000020   01FC               MOVW    R31:R30, R25:R24
   \   00000022   8D23               LDD     R18, Z+27
   \   00000024   8D34               LDD     R19, Z+28
   \   00000026   5F2F               SUBI    R18, 255
   \   00000028   4F3F               SBCI    R19, 255
   \   0000002A   8F23               STD     Z+27, R18
   \   0000002C   8F34               STD     Z+28, R19
     29              pMy485UART->TxAddress   = pPH->txadr;
   \   0000002E   01F8               MOVW    R31:R30, R17:R16
   \   00000030   8123               LDD     R18, Z+3
   \   00000032   01FC               MOVW    R31:R30, R25:R24
   \   00000034   8723               STD     Z+11, R18
     30              pMy485UART->TxId        = pPH->txtypeid;
   \   00000036   01F8               MOVW    R31:R30, R17:R16
   \   00000038   8122               LDD     R18, Z+2
   \   0000003A   01FC               MOVW    R31:R30, R25:R24
   \   0000003C   8722               STD     Z+10, R18
     31              pMy485UART->RxSendReply = false;                              // flag for answering set to fault
   \   0000003E   E020               LDI     R18, 0
   \   00000040   8F22               STD     Z+26, R18
     32              pMy485UART->TxFirst     = 11;                                 // Start pos for first TX command
   \   00000042   E02B               LDI     R18, 11
   \   00000044   8322               STD     Z+2, R18
   \   00000046   E020               LDI     R18, 0
   \   00000048   8323               STD     Z+3, R18
     33          
     34              Buf += sizeof(ANPRO10_PacketHeading);
   \   0000004A   9617               ADIW    R27:R26, 7
     35              unsigned char *EndPtr =  &Buf[pPH->nob];
   \   0000004C   01F8               MOVW    R31:R30, R17:R16
   \   0000004E   8104               LDD     R16, Z+4
   \   00000050   8115               LDD     R17, Z+5
   \   00000052   013D               MOVW    R7:R6, R27:R26
   \   00000054   0E60               ADD     R6, R16
   \   00000056   1E71               ADC     R7, R17
     36              ANPRO10_CommandHeading *pCH;
     37              char MoreCommands = true;
   \   00000058   E108               LDI     R16, 24
   \   0000005A   2ED0               MOV     R13, R16
   \   0000005C   E00F               LDI     R16, 15
   \   0000005E   2EC0               MOV     R12, R16
   \   00000060   E008               LDI     R16, 8
   \   00000062   2EB0               MOV     R11, R16
   \   00000064   24AA               CLR     R10
   \   00000066   94AA               DEC     R10
   \   00000068   2488               CLR     R8
     38              do {
     39                  pCH = (ANPRO10_CommandHeading *)Buf;
   \                     ??ANPRO10_UnpackPacket_0:
   \   0000006A   012D               MOVW    R5:R4, R27:R26
     40                  Buf += sizeof(ANPRO10_CommandHeading);  // ??
   \   0000006C   9614               ADIW    R27:R26, 4
     41                  switch ( pCH->CommandNo ) {
     42                  case ECMD_NMDWOACK:
     43                  case ECMD_NMDRQACK:
     44                      break;
     45                  default:
     46                      LastCommand = pCH->CommandNo;
     47                      break;
     48                  }
     49                  switch ( pCH->CommandNo ) {
   \   0000006E   01F2               MOVW    R31:R30, R5:R4
   \   00000070   8100               LD      R16, Z
   \   00000072   81F1               LDD     R31, Z+1
   \   00000074   2FE0               MOV     R30, R16
   \   00000076   9630               ADIW    R31:R30, 0
   \   00000078   F409               BRNE    $+2+2
   \   0000007A   C07D               RJMP    ??ANPRO10_UnpackPacket_1
   \   0000007C   9731               SBIW    R31:R30, 1
   \   0000007E   F409               BRNE    $+2+2
   \   00000080   C07A               RJMP    ??ANPRO10_UnpackPacket_1
   \   00000082   5EE7               SUBI    R30, 231
   \   00000084   40F3               SBCI    R31, 3
   \   00000086   F0E9               BREQ    ??ANPRO10_UnpackPacket_2
   \   00000088   973A               SBIW    R31:R30, 10
   \   0000008A   F111               BREQ    ??ANPRO10_UnpackPacket_3
   \   0000008C   973A               SBIW    R31:R30, 10
   \   0000008E   F119               BREQ    ??ANPRO10_UnpackPacket_4
   \   00000090   97F2               SBIW    R31:R30, 50
   \   00000092   F179               BREQ    ??ANPRO10_UnpackPacket_5
   \   00000094   973A               SBIW    R31:R30, 10
   \   00000096   F181               BREQ    ??ANPRO10_UnpackPacket_6
   \   00000098   973A               SBIW    R31:R30, 10
   \   0000009A   F191               BREQ    ??ANPRO10_UnpackPacket_7
   \   0000009C   5AE0               SUBI    R30, 160
   \   0000009E   40F0               SBCI    R31, 0
   \   000000A0   F199               BREQ    ??ANPRO10_UnpackPacket_8
   \   000000A2   973A               SBIW    R31:R30, 10
   \   000000A4   F409               BRNE    $+2+2
   \   000000A6   C047               RJMP    ??ANPRO10_UnpackPacket_9
   \   000000A8   973A               SBIW    R31:R30, 10
   \   000000AA   F409               BRNE    $+2+2
   \   000000AC   C048               RJMP    ??ANPRO10_UnpackPacket_10
   \   000000AE   973A               SBIW    R31:R30, 10
   \   000000B0   F409               BRNE    $+2+2
   \   000000B2   C052               RJMP    ??ANPRO10_UnpackPacket_11
   \   000000B4   973A               SBIW    R31:R30, 10
   \   000000B6   F409               BRNE    $+2+2
   \   000000B8   C053               RJMP    ??ANPRO10_UnpackPacket_12
   \   000000BA   56EC               SUBI    R30, 108
   \   000000BC   40F2               SBCI    R31, 2
   \   000000BE   F021               BREQ    ??ANPRO10_UnpackPacket_13
   \   000000C0   C051               RJMP    ??ANPRO10_UnpackPacket_14
     50                  case CMD_TXU_COMPRESSED_PACKET:
     51                      //Decompress(Size,Buf,Port);
     52                      break;
     53                  case CMD_REQ_STATUS :                           // Regusest status for target
     54                      BuildStatusData(pMy485UART);                // make package
   \                     ??ANPRO10_UnpackPacket_2:
   \   000000C2   018C               MOVW    R17:R16, R25:R24
   \   000000C4   ....               RCALL   BuildStatusData
     55                      break;
   \   000000C6   C04E               RJMP    ??ANPRO10_UnpackPacket_14
     56                  case CMD_GET_STACKSTATUS :                      // Request stck status
     57                      BuildStackStatus(pMy485UART, Buf);
   \                     ??ANPRO10_UnpackPacket_13:
   \   000000C8   019D               MOVW    R19:R18, R27:R26
   \   000000CA   018C               MOVW    R17:R16, R25:R24
   \   000000CC   ....               RCALL   BuildStackStatus
     58                      break;
   \   000000CE   C04A               RJMP    ??ANPRO10_UnpackPacket_14
     59                  case CMD_EEPROM_RESET :                         // Reset EEPROM??
     60                      GetResetEEPROM();
   \                     ??ANPRO10_UnpackPacket_3:
   \   000000D0   ........           CALL    EEPROMReset
     61                      break;
   \   000000D4   C047               RJMP    ??ANPRO10_UnpackPacket_14
   \                     ??ANPRO10_UnpackPacket_4:
   \   000000D6   99F9               SBIC    0x1F, 0x01
   \   000000D8   CFFE               RJMP    ??ANPRO10_UnpackPacket_4
   \   000000DA   BCA1               OUT     0x21, R10
   \   000000DC   BCC2               OUT     0x22, R12
   \   000000DE   BCA0               OUT     0x20, R10
   \   000000E0   9AFA               SBI     0x1F, 0x02
   \   000000E2   9AF9               SBI     0x1F, 0x01
   \                     ??ANPRO10_UnpackPacket_15:
   \   000000E4   99F9               SBIC    0x1F, 0x01
   \   000000E6   CFFE               RJMP    ??ANPRO10_UnpackPacket_15
   \   000000E8   92D0....           STS     _A_WDTCSR, R13
   \   000000EC   92B0....           STS     _A_WDTCSR, R11
     62                  case CMD_GOTO_BOOTLOADER :                      // Goto bootlaoder??
     63                      GetGotoBootloader(Buf);
     64                      break;
   \   000000F0   C039               RJMP    ??ANPRO10_UnpackPacket_14
     65                  case CMD_SND_EEPROM_DATA :                      // Receive EEPROM data
     66                      GetEEPROMData(Buf);
   \                     ??ANPRO10_UnpackPacket_5:
   \   000000F2   018D               MOVW    R17:R16, R27:R26
   \   000000F4   ....               RCALL   GetEEPROMData
     67                      break;
   \   000000F6   C036               RJMP    ??ANPRO10_UnpackPacket_14
     68                  case CMD_REQ_EEPROM_DATA :                      // Request to send EEPROM data
     69                      BuildEEPROMData(pMy485UART, Buf);
   \                     ??ANPRO10_UnpackPacket_6:
   \   000000F8   019D               MOVW    R19:R18, R27:R26
   \   000000FA   018C               MOVW    R17:R16, R25:R24
   \   000000FC   ....               RCALL   BuildEEPROMData
     70                      break;
   \   000000FE   C032               RJMP    ??ANPRO10_UnpackPacket_14
     71                  case CMD_REQ_INT_DATA :                         // Request external data
     72                      BuildADInt(pMy485UART, Buf);
   \                     ??ANPRO10_UnpackPacket_7:
   \   00000100   019D               MOVW    R19:R18, R27:R26
   \   00000102   018C               MOVW    R17:R16, R25:R24
   \   00000104   ....               RCALL   BuildADInt
     73                      break;
   \   00000106   C02E               RJMP    ??ANPRO10_UnpackPacket_14
     74                  case CMD_SND_HART_SETUP :                       // Receive sertup of AN-RSANA
     75                      GetHartSetup(Buf);
   \                     ??ANPRO10_UnpackPacket_8:
   \   00000108   9280....           STS     RestartCnt, R8
   \   0000010C   9280....           STS     (RestartCnt + 1), R8
   \   00000110   910C               LD      R16, X
   \   00000112   01FD               MOVW    R31:R30, R27:R26
   \   00000114   8111               LDD     R17, Z+1
   \   00000116   9300....           STS     (TData + 144), R16
   \   0000011A   9310....           STS     (TData + 145), R17
   \   0000011E   8120               LD      R18, Z
   \   00000120   E002               LDI     R16, 2
   \   00000122   E010               LDI     R17, 0
   \   00000124   ........           CALL    WriteEEPROMByte
   \   00000128   01FD               MOVW    R31:R30, R27:R26
   \   0000012A   8121               LDD     R18, Z+1
   \   0000012C   E003               LDI     R16, 3
   \   0000012E   E010               LDI     R17, 0
   \   00000130   ........           CALL    WriteEEPROMByte
     76                      break;
   \   00000134   C017               RJMP    ??ANPRO10_UnpackPacket_14
     77                  case CMD_REQ_HART_SETUP :                       // Request for sertup of AN-RSANA
     78                      BuildHartSetup(pMy485UART, Buf);
   \                     ??ANPRO10_UnpackPacket_9:
   \   00000136   019D               MOVW    R19:R18, R27:R26
   \   00000138   018C               MOVW    R17:R16, R25:R24
   \   0000013A   ....               RCALL   BuildHartSetup
     79                      break;
   \   0000013C   C013               RJMP    ??ANPRO10_UnpackPacket_14
     80                  case CMD_SND_HART_FILTER :                      // Receive filter of AN-RSANA
     81                      GetHartFilter(Buf);
   \                     ??ANPRO10_UnpackPacket_10:
   \   0000013E   01AD               MOVW    R21:R20, R27:R26
   \   00000140   ....               LDI     R18, LOW((TData + 146))
   \   00000142   ....               LDI     R19, HIGH((TData + 146))
   \   00000144   E00C               LDI     R16, 12
   \                     ??ANPRO10_UnpackPacket_16:
   \   00000146   01FA               MOVW    R31:R30, R21:R20
   \   00000148   9111               LD      R17, Z+
   \   0000014A   01AF               MOVW    R21:R20, R31:R30
   \   0000014C   01F9               MOVW    R31:R30, R19:R18
   \   0000014E   9311               ST      Z+, R17
   \   00000150   019F               MOVW    R19:R18, R31:R30
   \   00000152   950A               DEC     R16
   \   00000154   F039               BREQ    ??ANPRO10_UnpackPacket_14
   \   00000156   CFF7               RJMP    ??ANPRO10_UnpackPacket_16
     82                      break;
     83                  case CMD_REQ_HART_FILTER :                      // Request filter of AN-RSANA
     84                      BuildHartFilter(pMy485UART, Buf);
   \                     ??ANPRO10_UnpackPacket_11:
   \   00000158   019D               MOVW    R19:R18, R27:R26
   \   0000015A   018C               MOVW    R17:R16, R25:R24
   \   0000015C   ....               RCALL   BuildHartFilter
     85                      break;
   \   0000015E   C002               RJMP    ??ANPRO10_UnpackPacket_14
     86                  case CMD_REQ_HART_DATA :                        // Request ANA data(4-20ma)
     87                      BuildMDataHart(pMy485UART);
   \                     ??ANPRO10_UnpackPacket_12:
   \   00000160   018C               MOVW    R17:R16, R25:R24
   \   00000162   ....               RCALL   BuildMDataHart
     88                      break;
     89          
     90                  case ECMD_NMDWOACK:
     91                  case ECMD_NMDRQACK:
     92                      MoreCommands = false;
     93                      break;
     94                  default:
     95                      break;
     96          
     97                  }
     98                  if ( MoreCommands ) {
     99                      Buf += pCH->ndb;
   \                     ??ANPRO10_UnpackPacket_14:
   \   00000164   01F2               MOVW    R31:R30, R5:R4
   \   00000166   8102               LDD     R16, Z+2
   \   00000168   8113               LDD     R17, Z+3
   \   0000016A   0FA0               ADD     R26, R16
   \   0000016C   1FB1               ADC     R27, R17
   \   0000016E   15A6               CP      R26, R6
   \   00000170   05B7               CPC     R27, R7
   \   00000172   F408               BRCC    $+2+2
   \   00000174   CF7A               RJMP    ??ANPRO10_UnpackPacket_0
    100                  }
    101              } while ( MoreCommands && (Buf < EndPtr) );
    102              if ( pMy485UART->RxSendReply ) {                                   //send answer?
   \                     ??ANPRO10_UnpackPacket_1:
   \   00000176   01FC               MOVW    R31:R30, R25:R24
   \   00000178   8D02               LDD     R16, Z+26
   \   0000017A   2300               TST     R16
   \   0000017C   F011               BREQ    ??ANPRO10_UnpackPacket_17
    103                  My485UART_BuildTail(pMy485UART);                                       // yes, build tail (and header) and start sending
   \   0000017E   018C               MOVW    R17:R16, R25:R24
   \   00000180   ....               RCALL   My485UART_BuildTail
    104              }
    105              return (pMy485UART->RxSendReply);
   \                     ??ANPRO10_UnpackPacket_17:
   \   00000182   01FC               MOVW    R31:R30, R25:R24
   \   00000184   8D02               LDD     R16, Z+26
   \   00000186   9189               LD      R24, Y+
   \   00000188   9199               LD      R25, Y+
   \   0000018A   91A9               LD      R26, Y+
   \   0000018C   91B9               LD      R27, Y+
   \   0000018E   9049               LD      R4, Y+
   \   00000190   9059               LD      R5, Y+
   \   00000192   9069               LD      R6, Y+
   \   00000194   9079               LD      R7, Y+
   \   00000196   9089               LD      R8, Y+
   \   00000198   90A9               LD      R10, Y+
   \   0000019A   90B9               LD      R11, Y+
   \   0000019C   90C9               LD      R12, Y+
   \   0000019E   90D9               LD      R13, Y+
   \   000001A0   9508               RET
   \   000001A2                      REQUIRE RestartCnt
   \   000001A2                      REQUIRE _A_EECR
   \   000001A2                      REQUIRE _A_EEAR
   \   000001A2                      REQUIRE _A_EEDR
   \   000001A2                      REQUIRE _A_WDTCSR
    106          }
    107          
    108          #define MAX_TIME_BETWEEN_BYTE	10
    109          

   \                                 In  segment CODE, align 2, keep-with-next
    110          void ANPRO10_IO_Receive(My485UARTDataType *pMy485UART) {
   \                     ANPRO10_IO_Receive:
   \   00000000   92BA               ST      -Y, R11
   \   00000002   92AA               ST      -Y, R10
   \   00000004   929A               ST      -Y, R9
   \   00000006   928A               ST      -Y, R8
   \   00000008   927A               ST      -Y, R7
   \   0000000A   926A               ST      -Y, R6
   \   0000000C   925A               ST      -Y, R5
   \   0000000E   924A               ST      -Y, R4
   \   00000010   93BA               ST      -Y, R27
   \   00000012   93AA               ST      -Y, R26
   \   00000014   939A               ST      -Y, R25
   \   00000016   938A               ST      -Y, R24
   \   00000018                      REQUIRE ?Register_R4_is_cg_reg
   \   00000018                      REQUIRE ?Register_R5_is_cg_reg
   \   00000018                      REQUIRE ?Register_R6_is_cg_reg
   \   00000018                      REQUIRE ?Register_R7_is_cg_reg
   \   00000018                      REQUIRE ?Register_R8_is_cg_reg
   \   00000018                      REQUIRE ?Register_R9_is_cg_reg
   \   00000018                      REQUIRE ?Register_R10_is_cg_reg
   \   00000018                      REQUIRE ?Register_R11_is_cg_reg
   \   00000018   9722               SBIW    R29:R28, 2
   \   0000001A   01C8               MOVW    R25:R24, R17:R16
    111              unsigned char *RxBuf = (unsigned char *)pMy485UART->pRxBuffer;
   \   0000001C   01F8               MOVW    R31:R30, R17:R16
   \   0000001E   8887               LDD     R8, Z+23
   \   00000020   8C90               LDD     R9, Z+24
    112              const ANPRO10_PacketHeading *pPH =  (ANPRO10_PacketHeading *)RxBuf;
    113              char Data;
    114              char dataAvailable = 1;
    115              int  SyncCnt       = 1;     // Initialize to 1 as 1 must have been found when exiting the while loop
   \   00000022   E0A1               LDI     R26, 1
   \   00000024   E0B0               LDI     R27, 0
    116              char PacketOK      = false; // Assume the worse at the beginning
    117              // Look for ANPRO10_SYN, ignore the rest
    118              do {
    119                  OS_GetMail1(&pMy485UART->RxMailBox, &Data);
   \                     ??ANPRO10_IO_Receive_0:
   \   00000026   019E               MOVW    R19:R18, R29:R28
   \   00000028   018C               MOVW    R17:R16, R25:R24
   \   0000002A   5F04               SUBI    R16, 244
   \   0000002C   4F1F               SBCI    R17, 255
   \   0000002E   ........           CALL    OS_GetMail1
    120              }while ( Data != ANPRO10_SYN );
   \   00000032   8108               LD      R16, Y
   \   00000034   3106               CPI     R16, 22
   \   00000036   F7B9               BRNE    ??ANPRO10_IO_Receive_0
    121              // We know we have a ANPRO10_SYN
    122              // A minimum of 2 SYN to accept start
    123              //Message("First SYN");
    124              //SyncCnt = 0;
    125              do {
    126                  dataAvailable = !OS_GetMailTimed(&pMy485UART->RxMailBox, &Data, MAX_TIME_BETWEEN_BYTE);
   \                     ??ANPRO10_IO_Receive_1:
   \   00000038   E04A               LDI     R20, 10
   \   0000003A   E050               LDI     R21, 0
   \   0000003C   019E               MOVW    R19:R18, R29:R28
   \   0000003E   018C               MOVW    R17:R16, R25:R24
   \   00000040   5F04               SUBI    R16, 244
   \   00000042   4F1F               SBCI    R17, 255
   \   00000044   ........           CALL    OS_GetMailTimed
   \   00000048   2300               TST     R16
   \   0000004A   F009               BREQ    $+2+2
   \   0000004C   C05D               RJMP    ??ANPRO10_IO_Receive_2
   \   0000004E   8108               LD      R16, Y
   \   00000050   3106               CPI     R16, 22
   \   00000052   F411               BRNE    ??ANPRO10_IO_Receive_3
    127                  if ( dataAvailable && (Data == ANPRO10_SYN) ) SyncCnt++;
   \   00000054   9611               ADIW    R27:R26, 1
   \   00000056   CFF0               RJMP    ??ANPRO10_IO_Receive_1
    128              } while ( dataAvailable && (Data == ANPRO10_SYN) );
    129              if ( dataAvailable && SyncCnt && (Data == ANPRO10_SOH) ) {
   \                     ??ANPRO10_IO_Receive_3:
   \   00000058   2BAB               OR      R26, R27
   \   0000005A   F409               BRNE    $+2+2
   \   0000005C   C055               RJMP    ??ANPRO10_IO_Receive_2
   \   0000005E   3001               CPI     R16, 1
   \   00000060   F009               BREQ    $+2+2
   \   00000062   C052               RJMP    ??ANPRO10_IO_Receive_2
    130                  unsigned char *RxPtr = RxBuf;
   \   00000064   01D4               MOVW    R27:R26, R9:R8
    131                  for ( unsigned i = 0; dataAvailable && i < sizeof(NetHeading); i++ ) {
   \   00000066   E007               LDI     R16, 7
   \   00000068   2E40               MOV     R4, R16
    132                      dataAvailable = !OS_GetMailTimed(&pMy485UART->RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
   \                     ??ANPRO10_IO_Receive_4:
   \   0000006A   E04A               LDI     R20, 10
   \   0000006C   E050               LDI     R21, 0
   \   0000006E   019D               MOVW    R19:R18, R27:R26
   \   00000070   018C               MOVW    R17:R16, R25:R24
   \   00000072   5F04               SUBI    R16, 244
   \   00000074   4F1F               SBCI    R17, 255
   \   00000076   ........           CALL    OS_GetMailTimed
   \   0000007A   9611               ADIW    R27:R26, 1
   \   0000007C   2300               TST     R16
   \   0000007E   F411               BRNE    ??ANPRO10_IO_Receive_5
   \   00000080   E001               LDI     R16, 1
   \   00000082   C001               RJMP    ??ANPRO10_IO_Receive_6
   \                     ??ANPRO10_IO_Receive_5:
   \   00000084   E000               LDI     R16, 0
    133                  }
   \                     ??ANPRO10_IO_Receive_6:
   \   00000086   944A               DEC     R4
   \   00000088   2300               TST     R16
   \   0000008A   F1F1               BREQ    ??ANPRO10_IO_Receive_2
   \   0000008C   2044               TST     R4
   \   0000008E   F769               BRNE    ??ANPRO10_IO_Receive_4
    134                  if ( dataAvailable ) {
    135                      unsigned char HCSum = 0;
   \   00000090   E040               LDI     R20, 0
    136                      {
    137                          unsigned char *TmpRxPtr = RxBuf;
   \   00000092   0184               MOVW    R17:R16, R9:R8
    138                          for ( unsigned i = 0; i < sizeof(ANPRO10_PacketHeading) - 1; i++ ) {
   \   00000094   E026               LDI     R18, 6
    139                              HCSum     = crc[HCSum ^ *TmpRxPtr++];
   \                     ??ANPRO10_IO_Receive_7:
   \   00000096   01F8               MOVW    R31:R30, R17:R16
   \   00000098   9131               LD      R19, Z+
   \   0000009A   018F               MOVW    R17:R16, R31:R30
   \   0000009C   2743               EOR     R20, R19
   \   0000009E   2FE4               MOV     R30, R20
   \   000000A0   E0F0               LDI     R31, 0
   \   000000A2   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000A4   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000A6   ....               LDI     R19, (crc) >> 16
   \   000000A8   BF3B               OUT     0x3B, R19
   \   000000AA   9146               ELPM    R20, Z
    140                          }
   \   000000AC   952A               DEC     R18
   \   000000AE   F799               BRNE    ??ANPRO10_IO_Receive_7
    141          
    142                      }
    143                      if ( HCSum == pPH->HCRC ) {
   \   000000B0   01F4               MOVW    R31:R30, R9:R8
   \   000000B2   8106               LDD     R16, Z+6
   \   000000B4   1740               CP      R20, R16
   \   000000B6   F541               BRNE    ??ANPRO10_IO_Receive_2
    144                          //OS_Delay(1000);
    145                          unsigned DataSize = (unsigned)pPH->nob;
   \   000000B8   8044               LDD     R4, Z+4
   \   000000BA   8055               LDD     R5, Z+5
    146                          // Before checked against MAX_ANPRO10_IO_SIZE which is not related to the buffer size for AN-ZBHART
    147                          if ( DataSize > 3 && DataSize < RXSIZE_UART ) { 
   \   000000BC   01F2               MOVW    R31:R30, R5:R4
   \   000000BE   9734               SBIW    R31:R30, 4
   \   000000C0   39E2               CPI     R30, 146
   \   000000C2   40F0               SBCI    R31, 0
   \   000000C4   F508               BRCC    ??ANPRO10_IO_Receive_2
    148                              for ( unsigned i = 0; dataAvailable && i < DataSize - sizeof(ANPRO10_PacketHeading); i++ ) {
   \   000000C6   2466               CLR     R6
   \   000000C8   2477               CLR     R7
   \   000000CA   0152               MOVW    R11:R10, R5:R4
   \   000000CC   EF09               LDI     R16, 249
   \   000000CE   0EA0               ADD     R10, R16
   \   000000D0   EF0F               LDI     R16, 255
   \   000000D2   1EB0               ADC     R11, R16
   \                     ??ANPRO10_IO_Receive_8:
   \   000000D4   146A               CP      R6, R10
   \   000000D6   047B               CPC     R7, R11
   \   000000D8   F548               BRCC    ??ANPRO10_IO_Receive_9
    149                                  dataAvailable = !OS_GetMailTimed(&pMy485UART->RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
   \   000000DA   E04A               LDI     R20, 10
   \   000000DC   E050               LDI     R21, 0
   \   000000DE   019D               MOVW    R19:R18, R27:R26
   \   000000E0   018C               MOVW    R17:R16, R25:R24
   \   000000E2   5F04               SUBI    R16, 244
   \   000000E4   4F1F               SBCI    R17, 255
   \   000000E6   ........           CALL    OS_GetMailTimed
   \   000000EA   9611               ADIW    R27:R26, 1
   \   000000EC   2300               TST     R16
   \   000000EE   F411               BRNE    ??ANPRO10_IO_Receive_10
   \   000000F0   E001               LDI     R16, 1
   \   000000F2   C001               RJMP    ??ANPRO10_IO_Receive_11
   \                     ??ANPRO10_IO_Receive_10:
   \   000000F4   E000               LDI     R16, 0
    150                              }
   \                     ??ANPRO10_IO_Receive_11:
   \   000000F6   E011               LDI     R17, 1
   \   000000F8   0E61               ADD     R6, R17
   \   000000FA   E010               LDI     R17, 0
   \   000000FC   1E71               ADC     R7, R17
   \   000000FE   2300               TST     R16
   \   00000100   F749               BRNE    ??ANPRO10_IO_Receive_8
    151                              if ( dataAvailable ) {
    152                                  RxPtr = RxBuf;
    153                                  volatile unsigned char CSum = 0;
    154          
    155                                  for ( unsigned i = 0; i < DataSize - 2; i++ ) {
    156                                      CSum     = crc[CSum ^ *RxPtr++];
    157                                  }
    158                                  unsigned char  PacketCheckSum = *((unsigned char *)&RxBuf[DataSize - 2]);
    159                                  if ( PacketCheckSum == CSum ) {
    160                                      pMy485UART->SequenceNumber = RxBuf[DataSize - 3];
    161                                      // U16 EndCommand = *((U16*)&ARxBuf[DataSize-6]);
    162                                      // unsigned char EndData = *((unsigned char*)&ARxBuf[DataSize-4]);
    163                                      unsigned char EOTByte = *((unsigned char *)&RxBuf[DataSize - 1]);
    164                                      if ( EOTByte == ANPRO10_EOT ) {
    165                                          switch ( pPH->txtypeid ) {
    166                                          case DEVICE_TCU :
    167                                              if ( (pPH->rxadr == MyAddress()) && (pPH->rxtypeid == (UnitID + DEVICE_IO)) ) {
    168                                                  ANPRO10_UnpackPacket(pMy485UART, RxBuf);
    169                                                  PacketOK = true; // Packet accepted so signal OK!
    170                                              } else {
    171                                                  //Ignore = true;
    172                                              }
    173                                              break;
    174                                          case DEVICE_ZBHART:
    175                                              //Echo = true;
    176                                              break;
    177                                          default:
    178                                              // Ignore message
    179                                              break;
    180                                          }
    181                                      }
    182                                  }
    183                              } else {
    184                                  OS_Delay(0);
   \   00000102   E000               LDI     R16, 0
   \   00000104   ........           CALL    OS_Delay
    185                              }
    186                          }
    187                      }
    188                  }
    189              }
    190              if ( !PacketOK ) {
    191                  pMy485UART->RxFaultCnt++;
   \                     ??ANPRO10_IO_Receive_2:
   \   00000108   01FC               MOVW    R31:R30, R25:R24
   \   0000010A   8D01               LDD     R16, Z+25
   \   0000010C   9503               INC     R16
   \   0000010E   8F01               STD     Z+25, R16
    192              }
    193          }
   \                     ??ANPRO10_IO_Receive_12:
   \   00000110   9622               ADIW    R29:R28, 2
   \   00000112   9189               LD      R24, Y+
   \   00000114   9199               LD      R25, Y+
   \   00000116   91A9               LD      R26, Y+
   \   00000118   91B9               LD      R27, Y+
   \   0000011A   9049               LD      R4, Y+
   \   0000011C   9059               LD      R5, Y+
   \   0000011E   9069               LD      R6, Y+
   \   00000120   9079               LD      R7, Y+
   \   00000122   9089               LD      R8, Y+
   \   00000124   9099               LD      R9, Y+
   \   00000126   90A9               LD      R10, Y+
   \   00000128   90B9               LD      R11, Y+
   \   0000012A   9508               RET
   \                     ??ANPRO10_IO_Receive_9:
   \   0000012C   01D4               MOVW    R27:R26, R9:R8
   \   0000012E   E000               LDI     R16, 0
   \   00000130   8309               STD     Y+1, R16
   \   00000132   0182               MOVW    R17:R16, R5:R4
   \   00000134   5002               SUBI    R16, 2
   \   00000136   4010               SBCI    R17, 0
   \   00000138   2F20               MOV     R18, R16
   \   0000013A   2B21               OR      R18, R17
   \   0000013C   F071               BREQ    ??ANPRO10_IO_Receive_13
   \                     ??ANPRO10_IO_Receive_14:
   \   0000013E   8129               LDD     R18, Y+1
   \   00000140   913D               LD      R19, X+
   \   00000142   2723               EOR     R18, R19
   \   00000144   2FE2               MOV     R30, R18
   \   00000146   E0F0               LDI     R31, 0
   \   00000148   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000014A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000014C   ....               LDI     R19, (crc) >> 16
   \   0000014E   BF3B               OUT     0x3B, R19
   \   00000150   9126               ELPM    R18, Z
   \   00000152   8329               STD     Y+1, R18
   \   00000154   5001               SUBI    R16, 1
   \   00000156   4010               SBCI    R17, 0
   \   00000158   F791               BRNE    ??ANPRO10_IO_Receive_14
   \                     ??ANPRO10_IO_Receive_13:
   \   0000015A   0184               MOVW    R17:R16, R9:R8
   \   0000015C   0D04               ADD     R16, R4
   \   0000015E   1D15               ADC     R17, R5
   \   00000160   5003               SUBI    R16, 3
   \   00000162   4010               SBCI    R17, 0
   \   00000164   01F8               MOVW    R31:R30, R17:R16
   \   00000166   8121               LDD     R18, Z+1
   \   00000168   8139               LDD     R19, Y+1
   \   0000016A   1723               CP      R18, R19
   \   0000016C   F669               BRNE    ??ANPRO10_IO_Receive_2
   \   0000016E   8120               LD      R18, Z
   \   00000170   01FC               MOVW    R31:R30, R25:R24
   \   00000172   8F26               STD     Z+30, R18
   \   00000174   01F8               MOVW    R31:R30, R17:R16
   \   00000176   8102               LDD     R16, Z+2
   \   00000178   3004               CPI     R16, 4
   \   0000017A   F631               BRNE    ??ANPRO10_IO_Receive_2
   \   0000017C   01F4               MOVW    R31:R30, R9:R8
   \   0000017E   8102               LDD     R16, Z+2
   \   00000180   3200               CPI     R16, 32
   \   00000182   F611               BRNE    ??ANPRO10_IO_Receive_2
   \   00000184   81A1               LDD     R26, Z+1
   \   00000186   ........           CALL    MyAddress
   \   0000018A   17A0               CP      R26, R16
   \   0000018C   F009               BREQ    $+2+2
   \   0000018E   CFBC               RJMP    ??ANPRO10_IO_Receive_2
   \   00000190   01F4               MOVW    R31:R30, R9:R8
   \   00000192   8100               LD      R16, Z
   \   00000194   E010               LDI     R17, 0
   \   00000196   91E0....           LDS     R30, UnitID
   \   0000019A   E0F0               LDI     R31, 0
   \   0000019C   9670               ADIW    R31:R30, 16
   \   0000019E   170E               CP      R16, R30
   \   000001A0   071F               CPC     R17, R31
   \   000001A2   F009               BREQ    $+2+2
   \   000001A4   CFB1               RJMP    ??ANPRO10_IO_Receive_2
   \   000001A6   0194               MOVW    R19:R18, R9:R8
   \   000001A8   018C               MOVW    R17:R16, R25:R24
   \   000001AA   ....               RCALL   ANPRO10_UnpackPacket
   \   000001AC   CFB1               RJMP    ??ANPRO10_IO_Receive_12
    194          
    195          /*************************************************************************
    196          *   (This is a task)
    197          *  Usart0 handler
    198          *
    199          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    200          void Usart0Handler(void) {
   \                     Usart0Handler:
    201          
    202              while ( 1 ) {
    203                  ANPRO10_IO_Receive(&My485UART);
   \                     ??Usart0Handler_0:
   \   00000000   ....               LDI     R16, LOW(My485UART)
   \   00000002   ....               LDI     R17, (My485UART) >> 8
   \   00000004   ....               RCALL   ANPRO10_IO_Receive
   \   00000006   CFFC               RJMP    ??Usart0Handler_0
    204              }
    205          }
    206          
    207          
    208          
    209          
    210          /*************************************************************************
    211          *
    212          * Build send packet header
    213          *
    214          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    215          void My485UART_BuildHeader(My485UARTDataType *pMy485UART) {
   \                     My485UART_BuildHeader:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
    216          
    217              pMy485UART->TxLast  = 0;
   \   00000004   01F8               MOVW    R31:R30, R17:R16
   \   00000006   E020               LDI     R18, 0
   \   00000008   8324               STD     Z+4, R18
   \   0000000A   8325               STD     Z+5, R18
    218              char *txBuf = pMy485UART->pTxBuffer;
   \   0000000C   81A0               LD      R26, Z
   \   0000000E   81B1               LDD     R27, Z+1
    219          
    220              txBuf[0] = ANPRO10_SYN;                        /* Sync */
   \   00000010   01FD               MOVW    R31:R30, R27:R26
   \   00000012   E126               LDI     R18, 22
   \   00000014   8320               ST      Z, R18
    221              txBuf[1] = ANPRO10_SYN;                        /* Sync */
   \   00000016   8321               STD     Z+1, R18
    222              txBuf[2] = ANPRO10_SYN;                        /* Sync */
   \   00000018   8322               STD     Z+2, R18
    223              txBuf[3] = ANPRO10_SOH;                        /* Start of header */
   \   0000001A   E021               LDI     R18, 1
   \   0000001C   8323               STD     Z+3, R18
    224              txBuf[4] = pMy485UART->TxId;                        /* RXID */
   \   0000001E   01F8               MOVW    R31:R30, R17:R16
   \   00000020   8522               LDD     R18, Z+10
   \   00000022   01FD               MOVW    R31:R30, R27:R26
   \   00000024   8324               STD     Z+4, R18
    225              txBuf[5] = pMy485UART->TxAddress;                   /* Rx address */
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   8503               LDD     R16, Z+11
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   8305               STD     Z+5, R16
    226              txBuf[6] = DEVICE_IO + UnitID;                 /* Unit ID */
   \   0000002E   9100....           LDS     R16, UnitID
   \   00000032   5F00               SUBI    R16, 240
   \   00000034   8306               STD     Z+6, R16
    227              txBuf[7] = MyAddress();                        /* Tx address */
   \   00000036   ........           CALL    MyAddress
   \   0000003A   01FD               MOVW    R31:R30, R27:R26
   \   0000003C   8307               STD     Z+7, R16
    228              txBuf[8] = 0;                                  /* packlen HB, don't know yet */
   \   0000003E   E000               LDI     R16, 0
   \   00000040   8700               STD     Z+8, R16
    229              txBuf[9] = 0;                                  /* packlen LB, don't know yet */
   \   00000042   8701               STD     Z+9, R16
    230              txBuf[10] = 0;                                  /* Header checksum, don't know yet */
   \   00000044   8702               STD     Z+10, R16
    231          }
   \   00000046   91A9               LD      R26, Y+
   \   00000048   91B9               LD      R27, Y+
   \   0000004A   9508               RET
    232          
    233          /*************************************************************************
    234          *
    235          * Build  packet tail
    236          *
    237          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    238          void My485UART_BuildTail(My485UARTDataType *pMy485UART) {
   \                     My485UART_BuildTail:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008   01D8               MOVW    R27:R26, R17:R16
    239          
    240              My485UART_BuildHeader(pMy485UART);                      // fist build the header
   \   0000000A   ....               RCALL   My485UART_BuildHeader
    241              char *txBuf = pMy485UART->pTxBuffer;
   \   0000000C   914D               LD      R20, X+
   \   0000000E   915C               LD      R21, X
   \   00000010   9711               SBIW    R27:R26, 1
    242              txBuf[pMy485UART->TxFirst++] = ECMD_NMDWOACK & 0xff;    // End command lb
   \   00000012   01FD               MOVW    R31:R30, R27:R26
   \   00000014   8102               LDD     R16, Z+2
   \   00000016   8113               LDD     R17, Z+3
   \   00000018   01C8               MOVW    R25:R24, R17:R16
   \   0000001A   9601               ADIW    R25:R24, 1
   \   0000001C   8382               STD     Z+2, R24
   \   0000001E   8393               STD     Z+3, R25
   \   00000020   01FA               MOVW    R31:R30, R21:R20
   \   00000022   0FE0               ADD     R30, R16
   \   00000024   1FF1               ADC     R31, R17
   \   00000026   E000               LDI     R16, 0
   \   00000028   8300               ST      Z, R16
    243              txBuf[pMy485UART->TxFirst++] = ECMD_NMDWOACK >> 8;      // End command hb
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   8102               LDD     R16, Z+2
   \   0000002E   8113               LDD     R17, Z+3
   \   00000030   01C8               MOVW    R25:R24, R17:R16
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   8382               STD     Z+2, R24
   \   00000036   8393               STD     Z+3, R25
   \   00000038   01FA               MOVW    R31:R30, R21:R20
   \   0000003A   0FE0               ADD     R30, R16
   \   0000003C   1FF1               ADC     R31, R17
   \   0000003E   E000               LDI     R16, 0
   \   00000040   8300               ST      Z, R16
    244              txBuf[pMy485UART->TxFirst++] = 0x00;                    // End data
   \   00000042   01FD               MOVW    R31:R30, R27:R26
   \   00000044   8102               LDD     R16, Z+2
   \   00000046   8113               LDD     R17, Z+3
   \   00000048   01C8               MOVW    R25:R24, R17:R16
   \   0000004A   9601               ADIW    R25:R24, 1
   \   0000004C   8382               STD     Z+2, R24
   \   0000004E   8393               STD     Z+3, R25
   \   00000050   01FA               MOVW    R31:R30, R21:R20
   \   00000052   0FE0               ADD     R30, R16
   \   00000054   1FF1               ADC     R31, R17
   \   00000056   E000               LDI     R16, 0
   \   00000058   8300               ST      Z, R16
    245          
    246              txBuf[pMy485UART->TxFirst++] = pMy485UART->TxSeqCnt++;  // Sequence counter
   \   0000005A   01FD               MOVW    R31:R30, R27:R26
   \   0000005C   8102               LDD     R16, Z+2
   \   0000005E   8113               LDD     R17, Z+3
   \   00000060   01C8               MOVW    R25:R24, R17:R16
   \   00000062   9601               ADIW    R25:R24, 1
   \   00000064   8382               STD     Z+2, R24
   \   00000066   8393               STD     Z+3, R25
   \   00000068   8521               LDD     R18, Z+9
   \   0000006A   2F32               MOV     R19, R18
   \   0000006C   9533               INC     R19
   \   0000006E   8731               STD     Z+9, R19
   \   00000070   01FA               MOVW    R31:R30, R21:R20
   \   00000072   0FE0               ADD     R30, R16
   \   00000074   1FF1               ADC     R31, R17
   \   00000076   8320               ST      Z, R18
    247          
    248              txBuf[ 8] = pMy485UART->TxFirst - 2;                     // correct length because stx's
   \   00000078   01FD               MOVW    R31:R30, R27:R26
   \   0000007A   8102               LDD     R16, Z+2
   \   0000007C   8113               LDD     R17, Z+3
   \   0000007E   5002               SUBI    R16, 2
   \   00000080   01FA               MOVW    R31:R30, R21:R20
   \   00000082   8700               STD     Z+8, R16
    249              txBuf[ 9] = (pMy485UART->TxFirst - 2) >> 8;              // packet len high
   \   00000084   01FD               MOVW    R31:R30, R27:R26
   \   00000086   8182               LDD     R24, Z+2
   \   00000088   8193               LDD     R25, Z+3
   \   0000008A   9702               SBIW    R25:R24, 2
   \   0000008C   01FA               MOVW    R31:R30, R21:R20
   \   0000008E   8791               STD     Z+9, R25
    250              txBuf[10] = CalcDSTxChecksum(pMy485UART, 6);            // Get header checksum
   \   00000090   E060               LDI     R22, 0
   \   00000092   910D               LD      R16, X+
   \   00000094   911C               LD      R17, X
   \   00000096   9711               SBIW    R27:R26, 1
   \   00000098   5F0C               SUBI    R16, 252
   \   0000009A   4F1F               SBCI    R17, 255
   \   0000009C   E026               LDI     R18, 6
   \   0000009E   E070               LDI     R23, 0
   \   000000A0   ....               LDI     R19, (crc) >> 16
   \                     ??My485UART_BuildTail_0:
   \   000000A2   01F8               MOVW    R31:R30, R17:R16
   \   000000A4   9001               LD      R0, Z+
   \   000000A6   018F               MOVW    R17:R16, R31:R30
   \   000000A8   2560               EOR     R22, R0
   \   000000AA   01FB               MOVW    R31:R30, R23:R22
   \   000000AC   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000AE   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000B0   BF3B               OUT     0x3B, R19
   \   000000B2   9166               ELPM    R22, Z
   \   000000B4   952A               DEC     R18
   \   000000B6   F7A9               BRNE    ??My485UART_BuildTail_0
   \   000000B8   01FA               MOVW    R31:R30, R21:R20
   \   000000BA   8762               STD     Z+10, R22
    251          
    252              txBuf[pMy485UART->TxFirst]      = CalcDSTxChecksum(pMy485UART, pMy485UART->TxFirst - 4); // Get checksum
   \   000000BC   01FD               MOVW    R31:R30, R27:R26
   \   000000BE   8002               LDD     R0, Z+2
   \   000000C0   8013               LDD     R1, Z+3
   \   000000C2   8022               LDD     R2, Z+2
   \   000000C4   8033               LDD     R3, Z+3
   \   000000C6   EF0C               LDI     R16, 252
   \   000000C8   0E20               ADD     R2, R16
   \   000000CA   EF0F               LDI     R16, 255
   \   000000CC   1E30               ADC     R3, R16
   \   000000CE   E060               LDI     R22, 0
   \   000000D0   E080               LDI     R24, 0
   \   000000D2   E090               LDI     R25, 0
   \   000000D4   8100               LD      R16, Z
   \   000000D6   8111               LDD     R17, Z+1
   \   000000D8   5F0C               SUBI    R16, 252
   \   000000DA   4F1F               SBCI    R17, 255
   \   000000DC   2D22               MOV     R18, R2
   \   000000DE   2923               OR      R18, R3
   \   000000E0   F061               BREQ    ??My485UART_BuildTail_1
   \                     ??My485UART_BuildTail_2:
   \   000000E2   01F8               MOVW    R31:R30, R17:R16
   \   000000E4   9121               LD      R18, Z+
   \   000000E6   018F               MOVW    R17:R16, R31:R30
   \   000000E8   2762               EOR     R22, R18
   \   000000EA   01FB               MOVW    R31:R30, R23:R22
   \   000000EC   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000EE   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000F0   9166               ELPM    R22, Z
   \   000000F2   9601               ADIW    R25:R24, 1
   \   000000F4   1582               CP      R24, R2
   \   000000F6   0593               CPC     R25, R3
   \   000000F8   F3A0               BRCS    ??My485UART_BuildTail_2
   \                     ??My485UART_BuildTail_1:
   \   000000FA   01FA               MOVW    R31:R30, R21:R20
   \   000000FC   0DE0               ADD     R30, R0
   \   000000FE   1DF1               ADC     R31, R1
   \   00000100   8360               ST      Z, R22
    253              pMy485UART->TxFirst++;                                  // OBS!! must be inc here due to ANSI standard !!!!
   \   00000102   01FD               MOVW    R31:R30, R27:R26
   \   00000104   8102               LDD     R16, Z+2
   \   00000106   8113               LDD     R17, Z+3
   \   00000108   5F0F               SUBI    R16, 255
   \   0000010A   4F1F               SBCI    R17, 255
   \   0000010C   8302               STD     Z+2, R16
   \   0000010E   8313               STD     Z+3, R17
    254          
    255              txBuf[pMy485UART->TxFirst++]    = ANPRO10_EOT;          // End of transmission
   \   00000110   8102               LDD     R16, Z+2
   \   00000112   8113               LDD     R17, Z+3
   \   00000114   01C8               MOVW    R25:R24, R17:R16
   \   00000116   9601               ADIW    R25:R24, 1
   \   00000118   8382               STD     Z+2, R24
   \   0000011A   8393               STD     Z+3, R25
   \   0000011C   01FA               MOVW    R31:R30, R21:R20
   \   0000011E   0FE0               ADD     R30, R16
   \   00000120   1FF1               ADC     R31, R17
   \   00000122   E004               LDI     R16, 4
   \   00000124   8300               ST      Z, R16
    256              txBuf[pMy485UART->TxFirst++]    = ANPRO10_EOT;          // End of transmission
   \   00000126   01FD               MOVW    R31:R30, R27:R26
   \   00000128   8102               LDD     R16, Z+2
   \   0000012A   8113               LDD     R17, Z+3
   \   0000012C   01C8               MOVW    R25:R24, R17:R16
   \   0000012E   9601               ADIW    R25:R24, 1
   \   00000130   8382               STD     Z+2, R24
   \   00000132   8393               STD     Z+3, R25
   \   00000134   0F40               ADD     R20, R16
   \   00000136   1F51               ADC     R21, R17
   \   00000138   01FA               MOVW    R31:R30, R21:R20
   \   0000013A   E004               LDI     R16, 4
   \   0000013C   8300               ST      Z, R16
    257              pMy485UART->TxCount             = pMy485UART->TxFirst;  //bytes to send
   \   0000013E   01FD               MOVW    R31:R30, R27:R26
   \   00000140   8102               LDD     R16, Z+2
   \   00000142   8113               LDD     R17, Z+3
   \   00000144   8306               STD     Z+6, R16
   \   00000146   8317               STD     Z+7, R17
    258              pMy485UART->TxLast 			    = 0;                    // reset cunter
   \   00000148   8374               STD     Z+4, R23
   \   0000014A   8375               STD     Z+5, R23
    259              // Turn on TXE for channel
    260              SetBit(PORTE, 0x04);                                 // TXE0 on
   \   0000014C   94F8               cli
   \   0000014E   9100....           LDS     R16, (OS_Global + 1)
   \   00000152   9503               INC     R16
   \   00000154   9300....           STS     (OS_Global + 1), R16
   \   00000158   9A72               SBI     0x0E, 0x02
   \   0000015A   9100....           LDS     R16, (OS_Global + 1)
   \   0000015E   950A               DEC     R16
   \   00000160   9300....           STS     (OS_Global + 1), R16
   \   00000164   F409               BRNE    ??My485UART_BuildTail_3
   \   00000166   9478               sei
    261              OS_Delay(2);                                            // Ensure some settling time
   \                     ??My485UART_BuildTail_3:
   \   00000168   E002               LDI     R16, 2
   \   0000016A   E010               LDI     R17, 0
   \   0000016C   ........           CALL    OS_Delay
    262              UCSR0B |= __BIT_MASK(UDRIE0);                           // start sending by enableing interrupt
   \   00000170   910000C1           LDS     R16, 193
   \   00000174   6200               ORI     R16, 0x20
   \   00000176   930000C1           STS     193, R16
    263              if ( OS_WaitSingleEventTimed(UART0_EVENT_TX_COMPLETE, 1000) != UART0_EVENT_TX_COMPLETE) {
   \   0000017A   EE28               LDI     R18, 232
   \   0000017C   E033               LDI     R19, 3
   \   0000017E   E001               LDI     R16, 1
   \   00000180   ........           CALL    OS_WaitSingleEventTimed
   \   00000184   3001               CPI     R16, 1
   \   00000186   F019               BREQ    ??My485UART_BuildTail_4
    264                  CriticalComError = 2;
   \   00000188   E002               LDI     R16, 2
   \   0000018A   9300....           STS     CriticalComError, R16
    265              }
    266          
    267          }
   \                     ??My485UART_BuildTail_4:
   \   0000018E                      REQUIRE ?Subroutine1
   \   0000018E                      REQUIRE _A_PORTE
   \   0000018E                      REQUIRE _A_UCSR0B
   \   0000018E                      ;               // Fall through to label ?Subroutine1

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9508               RET
    268          
    269          /*************************************************************************
    270          *
    271          * Build datablock for card status
    272          *
    273          *************************************************************************/
    274          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9049               LD      R4, Y+
   \   0000000A   9059               LD      R5, Y+
   \   0000000C   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    275          void BuildStatusData(My485UARTDataType *pMy485UART) {
   \                     BuildStatusData:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C   01D8               MOVW    R27:R26, R17:R16
    276          
    277              short ntna;
    278              pMy485UART->RxSendReply = true;                               // flag for answering
   \   0000000E   01F8               MOVW    R31:R30, R17:R16
   \   00000010   E001               LDI     R16, 1
   \   00000012   8F02               STD     Z+26, R16
    279          
    280              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_STATUS & 0xff;
   \   00000014   8102               LDD     R16, Z+2
   \   00000016   8113               LDD     R17, Z+3
   \   00000018   01C8               MOVW    R25:R24, R17:R16
   \   0000001A   9601               ADIW    R25:R24, 1
   \   0000001C   8382               STD     Z+2, R24
   \   0000001E   8393               STD     Z+3, R25
   \   00000020   91ED               LD      R30, X+
   \   00000022   91FC               LD      R31, X
   \   00000024   9711               SBIW    R27:R26, 1
   \   00000026   0FE0               ADD     R30, R16
   \   00000028   1FF1               ADC     R31, R17
   \   0000002A   EE09               LDI     R16, 233
   \   0000002C   8300               ST      Z, R16
    281              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_STATUS >> 8;
   \   0000002E   01FD               MOVW    R31:R30, R27:R26
   \   00000030   8102               LDD     R16, Z+2
   \   00000032   8113               LDD     R17, Z+3
   \   00000034   01C8               MOVW    R25:R24, R17:R16
   \   00000036   9601               ADIW    R25:R24, 1
   \   00000038   8382               STD     Z+2, R24
   \   0000003A   8393               STD     Z+3, R25
   \   0000003C   91ED               LD      R30, X+
   \   0000003E   91FC               LD      R31, X
   \   00000040   9711               SBIW    R27:R26, 1
   \   00000042   0FE0               ADD     R30, R16
   \   00000044   1FF1               ADC     R31, R17
   \   00000046   E003               LDI     R16, 3
   \   00000048   8300               ST      Z, R16
    282              ntna = pMy485UART->TxFirst;                                    /* remember index */
   \   0000004A   01FD               MOVW    R31:R30, R27:R26
   \   0000004C   8042               LDD     R4, Z+2
   \   0000004E   8053               LDD     R5, Z+3
    283              pMy485UART->TxFirst += 2;                                                       // two byte length
   \   00000050   8102               LDD     R16, Z+2
   \   00000052   8113               LDD     R17, Z+3
   \   00000054   5F0E               SUBI    R16, 254
   \   00000056   4F1F               SBCI    R17, 255
   \   00000058   8302               STD     Z+2, R16
   \   0000005A   8313               STD     Z+3, R17
    284              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = 0;                               // channel fixed to 0
   \   0000005C   8102               LDD     R16, Z+2
   \   0000005E   8113               LDD     R17, Z+3
   \   00000060   01C8               MOVW    R25:R24, R17:R16
   \   00000062   9601               ADIW    R25:R24, 1
   \   00000064   8382               STD     Z+2, R24
   \   00000066   8393               STD     Z+3, R25
   \   00000068   91ED               LD      R30, X+
   \   0000006A   91FC               LD      R31, X
   \   0000006C   9711               SBIW    R27:R26, 1
   \   0000006E   0FE0               ADD     R30, R16
   \   00000070   1FF1               ADC     R31, R17
   \   00000072   E000               LDI     R16, 0
   \   00000074   8300               ST      Z, R16
    285              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = DEVICE_IO + UnitID;              // Product ID
   \   00000076   01FD               MOVW    R31:R30, R27:R26
   \   00000078   8122               LDD     R18, Z+2
   \   0000007A   8133               LDD     R19, Z+3
   \   0000007C   01C9               MOVW    R25:R24, R19:R18
   \   0000007E   9601               ADIW    R25:R24, 1
   \   00000080   8382               STD     Z+2, R24
   \   00000082   8393               STD     Z+3, R25
   \   00000084   9100....           LDS     R16, UnitID
   \   00000088   5F00               SUBI    R16, 240
   \   0000008A   91ED               LD      R30, X+
   \   0000008C   91FC               LD      R31, X
   \   0000008E   9711               SBIW    R27:R26, 1
   \   00000090   0FE2               ADD     R30, R18
   \   00000092   1FF3               ADC     R31, R19
   \   00000094   8300               ST      Z, R16
    286              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = MyAddress();                     // unit adddress
   \   00000096   01FD               MOVW    R31:R30, R27:R26
   \   00000098   8182               LDD     R24, Z+2
   \   0000009A   8193               LDD     R25, Z+3
   \   0000009C   018C               MOVW    R17:R16, R25:R24
   \   0000009E   5F0F               SUBI    R16, 255
   \   000000A0   4F1F               SBCI    R17, 255
   \   000000A2   8302               STD     Z+2, R16
   \   000000A4   8313               STD     Z+3, R17
   \   000000A6   ........           CALL    MyAddress
   \   000000AA   91ED               LD      R30, X+
   \   000000AC   91FC               LD      R31, X
   \   000000AE   9711               SBIW    R27:R26, 1
   \   000000B0   0FE8               ADD     R30, R24
   \   000000B2   1FF9               ADC     R31, R25
   \   000000B4   8300               ST      Z, R16
    287              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = PROG_VERSION;                    // software version */
   \   000000B6   01FD               MOVW    R31:R30, R27:R26
   \   000000B8   8102               LDD     R16, Z+2
   \   000000BA   8113               LDD     R17, Z+3
   \   000000BC   01C8               MOVW    R25:R24, R17:R16
   \   000000BE   9601               ADIW    R25:R24, 1
   \   000000C0   8382               STD     Z+2, R24
   \   000000C2   8393               STD     Z+3, R25
   \   000000C4   91ED               LD      R30, X+
   \   000000C6   91FC               LD      R31, X
   \   000000C8   9711               SBIW    R27:R26, 1
   \   000000CA   0FE0               ADD     R30, R16
   \   000000CC   1FF1               ADC     R31, R17
   \   000000CE   E007               LDI     R16, 7
   \   000000D0   8300               ST      Z, R16
    288              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = COMP_VERSION;                    // cpmpability version
   \   000000D2   01FD               MOVW    R31:R30, R27:R26
   \   000000D4   8102               LDD     R16, Z+2
   \   000000D6   8113               LDD     R17, Z+3
   \   000000D8   01C8               MOVW    R25:R24, R17:R16
   \   000000DA   9601               ADIW    R25:R24, 1
   \   000000DC   8382               STD     Z+2, R24
   \   000000DE   8393               STD     Z+3, R25
   \   000000E0   91ED               LD      R30, X+
   \   000000E2   91FC               LD      R31, X
   \   000000E4   9711               SBIW    R27:R26, 1
   \   000000E6   0FE0               ADD     R30, R16
   \   000000E8   1FF1               ADC     R31, R17
   \   000000EA   E001               LDI     R16, 1
   \   000000EC   8300               ST      Z, R16
    289              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = STORE_VERSION;                   // cpmpability version
   \   000000EE   01FD               MOVW    R31:R30, R27:R26
   \   000000F0   8102               LDD     R16, Z+2
   \   000000F2   8113               LDD     R17, Z+3
   \   000000F4   01C8               MOVW    R25:R24, R17:R16
   \   000000F6   9601               ADIW    R25:R24, 1
   \   000000F8   8382               STD     Z+2, R24
   \   000000FA   8393               STD     Z+3, R25
   \   000000FC   91ED               LD      R30, X+
   \   000000FE   91FC               LD      R31, X
   \   00000100   9711               SBIW    R27:R26, 1
   \   00000102   0FE0               ADD     R30, R16
   \   00000104   1FF1               ADC     R31, R17
   \   00000106   E002               LDI     R16, 2
   \   00000108   8300               ST      Z, R16
    290              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = (RXSIZE_UART & 0xff);            // rx buffer size
   \   0000010A   01FD               MOVW    R31:R30, R27:R26
   \   0000010C   8102               LDD     R16, Z+2
   \   0000010E   8113               LDD     R17, Z+3
   \   00000110   01C8               MOVW    R25:R24, R17:R16
   \   00000112   9601               ADIW    R25:R24, 1
   \   00000114   8382               STD     Z+2, R24
   \   00000116   8393               STD     Z+3, R25
   \   00000118   91ED               LD      R30, X+
   \   0000011A   91FC               LD      R31, X
   \   0000011C   9711               SBIW    R27:R26, 1
   \   0000011E   0FE0               ADD     R30, R16
   \   00000120   1FF1               ADC     R31, R17
   \   00000122   E906               LDI     R16, 150
   \   00000124   8300               ST      Z, R16
    291              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = ((RXSIZE_UART >> 8) & 0xff);     // rx buffer size
   \   00000126   01FD               MOVW    R31:R30, R27:R26
   \   00000128   8102               LDD     R16, Z+2
   \   0000012A   8113               LDD     R17, Z+3
   \   0000012C   01C8               MOVW    R25:R24, R17:R16
   \   0000012E   9601               ADIW    R25:R24, 1
   \   00000130   8382               STD     Z+2, R24
   \   00000132   8393               STD     Z+3, R25
   \   00000134   91ED               LD      R30, X+
   \   00000136   91FC               LD      R31, X
   \   00000138   9711               SBIW    R27:R26, 1
   \   0000013A   0FE0               ADD     R30, R16
   \   0000013C   1FF1               ADC     R31, R17
   \   0000013E   E000               LDI     R16, 0
   \   00000140   8300               ST      Z, R16
    292              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = (TXSIZE_UART & 0xff);            // tx buffer size
   \   00000142   01FD               MOVW    R31:R30, R27:R26
   \   00000144   8102               LDD     R16, Z+2
   \   00000146   8113               LDD     R17, Z+3
   \   00000148   01C8               MOVW    R25:R24, R17:R16
   \   0000014A   9601               ADIW    R25:R24, 1
   \   0000014C   8382               STD     Z+2, R24
   \   0000014E   8393               STD     Z+3, R25
   \   00000150   91ED               LD      R30, X+
   \   00000152   91FC               LD      R31, X
   \   00000154   9711               SBIW    R27:R26, 1
   \   00000156   0FE0               ADD     R30, R16
   \   00000158   1FF1               ADC     R31, R17
   \   0000015A   E900               LDI     R16, 144
   \   0000015C   8300               ST      Z, R16
    293              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);     // tx buffer size
   \   0000015E   01FD               MOVW    R31:R30, R27:R26
   \   00000160   8102               LDD     R16, Z+2
   \   00000162   8113               LDD     R17, Z+3
   \   00000164   01C8               MOVW    R25:R24, R17:R16
   \   00000166   9601               ADIW    R25:R24, 1
   \   00000168   8382               STD     Z+2, R24
   \   0000016A   8393               STD     Z+3, R25
   \   0000016C   91ED               LD      R30, X+
   \   0000016E   91FC               LD      R31, X
   \   00000170   9711               SBIW    R27:R26, 1
   \   00000172   0FE0               ADD     R30, R16
   \   00000174   1FF1               ADC     R31, R17
   \   00000176   E001               LDI     R16, 1
   \   00000178   8300               ST      Z, R16
    294              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = RestartStatus;                   // restart flag
   \   0000017A   01FD               MOVW    R31:R30, R27:R26
   \   0000017C   8102               LDD     R16, Z+2
   \   0000017E   8113               LDD     R17, Z+3
   \   00000180   01C8               MOVW    R25:R24, R17:R16
   \   00000182   9601               ADIW    R25:R24, 1
   \   00000184   8382               STD     Z+2, R24
   \   00000186   8393               STD     Z+3, R25
   \   00000188   9120....           LDS     R18, RestartStatus
   \   0000018C   91ED               LD      R30, X+
   \   0000018E   91FC               LD      R31, X
   \   00000190   9711               SBIW    R27:R26, 1
   \   00000192   0FE0               ADD     R30, R16
   \   00000194   1FF1               ADC     R31, R17
   \   00000196   8320               ST      Z, R18
    295              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = PROGTYPE_APP;                    // Application program
   \   00000198   01FD               MOVW    R31:R30, R27:R26
   \   0000019A   8102               LDD     R16, Z+2
   \   0000019C   8113               LDD     R17, Z+3
   \   0000019E   01C8               MOVW    R25:R24, R17:R16
   \   000001A0   9601               ADIW    R25:R24, 1
   \   000001A2   8382               STD     Z+2, R24
   \   000001A4   8393               STD     Z+3, R25
   \   000001A6   91ED               LD      R30, X+
   \   000001A8   91FC               LD      R31, X
   \   000001AA   9711               SBIW    R27:R26, 1
   \   000001AC   0FE0               ADD     R30, R16
   \   000001AE   1FF1               ADC     R31, R17
   \   000001B0   E001               LDI     R16, 1
   \   000001B2   8300               ST      Z, R16
    296              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = RestartCnt & 0xff;               // Unit restart count
   \   000001B4   01FD               MOVW    R31:R30, R27:R26
   \   000001B6   8122               LDD     R18, Z+2
   \   000001B8   8133               LDD     R19, Z+3
   \   000001BA   01C9               MOVW    R25:R24, R19:R18
   \   000001BC   9601               ADIW    R25:R24, 1
   \   000001BE   8382               STD     Z+2, R24
   \   000001C0   8393               STD     Z+3, R25
   \   000001C2   9100....           LDS     R16, RestartCnt
   \   000001C6   9110....           LDS     R17, (RestartCnt + 1)
   \   000001CA   91ED               LD      R30, X+
   \   000001CC   91FC               LD      R31, X
   \   000001CE   9711               SBIW    R27:R26, 1
   \   000001D0   0FE2               ADD     R30, R18
   \   000001D2   1FF3               ADC     R31, R19
   \   000001D4   8300               ST      Z, R16
    297              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = (RestartCnt >> 8 ) & 0xff;       // Unit restart count
   \   000001D6   01FD               MOVW    R31:R30, R27:R26
   \   000001D8   8122               LDD     R18, Z+2
   \   000001DA   8133               LDD     R19, Z+3
   \   000001DC   01C9               MOVW    R25:R24, R19:R18
   \   000001DE   9601               ADIW    R25:R24, 1
   \   000001E0   8382               STD     Z+2, R24
   \   000001E2   8393               STD     Z+3, R25
   \   000001E4   9100....           LDS     R16, RestartCnt
   \   000001E8   9110....           LDS     R17, (RestartCnt + 1)
   \   000001EC   91ED               LD      R30, X+
   \   000001EE   91FC               LD      R31, X
   \   000001F0   9711               SBIW    R27:R26, 1
   \   000001F2   0FE2               ADD     R30, R18
   \   000001F4   1FF3               ADC     R31, R19
   \   000001F6   8310               ST      Z, R17
    298          
    299              pMy485UART->pTxBuffer[ntna] =   (pMy485UART->TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000001F8   01FD               MOVW    R31:R30, R27:R26
   \   000001FA   8102               LDD     R16, Z+2
   \   000001FC   8113               LDD     R17, Z+3
   \   000001FE   1904               SUB     R16, R4
   \   00000200   5002               SUBI    R16, 2
   \   00000202   91ED               LD      R30, X+
   \   00000204   91FC               LD      R31, X
   \   00000206   9711               SBIW    R27:R26, 1
   \   00000208   0DE4               ADD     R30, R4
   \   0000020A   1DF5               ADC     R31, R5
   \   0000020C   8300               ST      Z, R16
    300              pMy485UART->pTxBuffer[ntna + 1] = ((pMy485UART->TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000020E   01FD               MOVW    R31:R30, R27:R26
   \   00000210   8182               LDD     R24, Z+2
   \   00000212   8193               LDD     R25, Z+3
   \   00000214   1984               SUB     R24, R4
   \   00000216   0995               SBC     R25, R5
   \   00000218   9702               SBIW    R25:R24, 2
   \   0000021A   91ED               LD      R30, X+
   \   0000021C   91FC               LD      R31, X
   \   0000021E   0DE4               ADD     R30, R4
   \   00000220   1DF5               ADC     R31, R5
   \   00000222   8391               STD     Z+1, R25
    301          
    302              RestartStatus = 0;                                                       // set reset stat to 0 = read
   \   00000224   E000               LDI     R16, 0
   \   00000226   9300....           STS     RestartStatus, R16
    303          }
   \   0000022A   ....               RJMP    ?Subroutine0
   \   0000022C                      REQUIRE RestartCnt
    304          
    305          /*************************************************************************
    306          *
    307          * Build EEPROM data package
    308          *
    309          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    310          void BuildEEPROMData(My485UARTDataType *pMy485UART, unsigned char *pointer) {
   \                     BuildEEPROMData:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C   01D8               MOVW    R27:R26, R17:R16
    311          
    312              short ntna;
    313              char channel;
    314              pMy485UART->RxSendReply = true;                               // flag for answering
   \   0000000E   01F8               MOVW    R31:R30, R17:R16
   \   00000010   E001               LDI     R16, 1
   \   00000012   8F02               STD     Z+26, R16
    315          
    316              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_EEPROM_DATA & 0xff;
   \   00000014   8102               LDD     R16, Z+2
   \   00000016   8113               LDD     R17, Z+3
   \   00000018   01C8               MOVW    R25:R24, R17:R16
   \   0000001A   9601               ADIW    R25:R24, 1
   \   0000001C   8382               STD     Z+2, R24
   \   0000001E   8393               STD     Z+3, R25
   \   00000020   91ED               LD      R30, X+
   \   00000022   91FC               LD      R31, X
   \   00000024   9711               SBIW    R27:R26, 1
   \   00000026   0FE0               ADD     R30, R16
   \   00000028   1FF1               ADC     R31, R17
   \   0000002A   E309               LDI     R16, 57
   \   0000002C   8300               ST      Z, R16
    317              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_EEPROM_DATA >> 8;
   \   0000002E   01FD               MOVW    R31:R30, R27:R26
   \   00000030   8102               LDD     R16, Z+2
   \   00000032   8113               LDD     R17, Z+3
   \   00000034   01C8               MOVW    R25:R24, R17:R16
   \   00000036   9601               ADIW    R25:R24, 1
   \   00000038   8382               STD     Z+2, R24
   \   0000003A   8393               STD     Z+3, R25
   \   0000003C   91ED               LD      R30, X+
   \   0000003E   91FC               LD      R31, X
   \   00000040   9711               SBIW    R27:R26, 1
   \   00000042   0FE0               ADD     R30, R16
   \   00000044   1FF1               ADC     R31, R17
   \   00000046   E004               LDI     R16, 4
   \   00000048   8300               ST      Z, R16
    318              ntna = pMy485UART->TxFirst;                                    /* remember index */
   \   0000004A   01FD               MOVW    R31:R30, R27:R26
   \   0000004C   8042               LDD     R4, Z+2
   \   0000004E   8053               LDD     R5, Z+3
    319              pMy485UART->TxFirst += 2;                                      // two byte length
   \   00000050   8102               LDD     R16, Z+2
   \   00000052   8113               LDD     R17, Z+3
   \   00000054   5F0E               SUBI    R16, 254
   \   00000056   4F1F               SBCI    R17, 255
   \   00000058   8302               STD     Z+2, R16
   \   0000005A   8313               STD     Z+3, R17
    320          
    321              channel = pointer[0];
   \   0000005C   01F9               MOVW    R31:R30, R19:R18
   \   0000005E   8100               LD      R16, Z
    322              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = channel; //channel
   \   00000060   01FD               MOVW    R31:R30, R27:R26
   \   00000062   8122               LDD     R18, Z+2
   \   00000064   8133               LDD     R19, Z+3
   \   00000066   01C9               MOVW    R25:R24, R19:R18
   \   00000068   9601               ADIW    R25:R24, 1
   \   0000006A   8382               STD     Z+2, R24
   \   0000006C   8393               STD     Z+3, R25
   \   0000006E   91ED               LD      R30, X+
   \   00000070   91FC               LD      R31, X
   \   00000072   9711               SBIW    R27:R26, 1
   \   00000074   0FE2               ADD     R30, R18
   \   00000076   1FF3               ADC     R31, R19
   \   00000078   8300               ST      Z, R16
    323          
    324              ReadEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&pMy485UART->pTxBuffer[pMy485UART->TxFirst]);
   \   0000007A   E018               LDI     R17, 8
   \   0000007C   9F01               MUL     R16, R17
   \   0000007E   01C0               MOVW    R25:R24, R1:R0
   \   00000080   914D               LD      R20, X+
   \   00000082   915C               LD      R21, X
   \   00000084   9711               SBIW    R27:R26, 1
   \   00000086   01FD               MOVW    R31:R30, R27:R26
   \   00000088   8102               LDD     R16, Z+2
   \   0000008A   8113               LDD     R17, Z+3
   \   0000008C   0F40               ADD     R20, R16
   \   0000008E   1F51               ADC     R21, R17
   \   00000090   E024               LDI     R18, 4
   \   00000092   0180               MOVW    R17:R16, R1:R0
   \   00000094   ........           CALL    ReadEEPROMBuffer
    325              pMy485UART->TxFirst += sizeof(float);
   \   00000098   01FD               MOVW    R31:R30, R27:R26
   \   0000009A   8102               LDD     R16, Z+2
   \   0000009C   8113               LDD     R17, Z+3
   \   0000009E   5F0C               SUBI    R16, 252
   \   000000A0   4F1F               SBCI    R17, 255
   \   000000A2   8302               STD     Z+2, R16
   \   000000A4   8313               STD     Z+3, R17
    326              ReadEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&pMy485UART->pTxBuffer[pMy485UART->TxFirst]);
   \   000000A6   8140               LD      R20, Z
   \   000000A8   8151               LDD     R21, Z+1
   \   000000AA   8102               LDD     R16, Z+2
   \   000000AC   8113               LDD     R17, Z+3
   \   000000AE   0F40               ADD     R20, R16
   \   000000B0   1F51               ADC     R21, R17
   \   000000B2   E024               LDI     R18, 4
   \   000000B4   9604               ADIW    R25:R24, 4
   \   000000B6   018C               MOVW    R17:R16, R25:R24
   \   000000B8   ........           CALL    ReadEEPROMBuffer
    327              pMy485UART->TxFirst += sizeof(float);
   \   000000BC   01FD               MOVW    R31:R30, R27:R26
   \   000000BE   8102               LDD     R16, Z+2
   \   000000C0   8113               LDD     R17, Z+3
   \   000000C2   5F0C               SUBI    R16, 252
   \   000000C4   4F1F               SBCI    R17, 255
   \   000000C6   8302               STD     Z+2, R16
   \   000000C8   8313               STD     Z+3, R17
    328          
    329              pMy485UART->pTxBuffer[ntna] = (pMy485UART->TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000CA   8102               LDD     R16, Z+2
   \   000000CC   8113               LDD     R17, Z+3
   \   000000CE   1904               SUB     R16, R4
   \   000000D0   5002               SUBI    R16, 2
   \   000000D2   91ED               LD      R30, X+
   \   000000D4   91FC               LD      R31, X
   \   000000D6   9711               SBIW    R27:R26, 1
   \   000000D8   0DE4               ADD     R30, R4
   \   000000DA   1DF5               ADC     R31, R5
   \   000000DC   8300               ST      Z, R16
    330              pMy485UART->pTxBuffer[ntna + 1] = ((pMy485UART->TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000DE   01FD               MOVW    R31:R30, R27:R26
   \   000000E0   8182               LDD     R24, Z+2
   \   000000E2   8193               LDD     R25, Z+3
   \   000000E4   1984               SUB     R24, R4
   \   000000E6   0995               SBC     R25, R5
   \   000000E8   9702               SBIW    R25:R24, 2
   \   000000EA   91ED               LD      R30, X+
   \   000000EC   91FC               LD      R31, X
   \   000000EE   0DE4               ADD     R30, R4
   \   000000F0   1DF5               ADC     R31, R5
   \   000000F2   8391               STD     Z+1, R25
    331          }
   \   000000F4                      REQUIRE ?Subroutine0
   \   000000F4                      ;               // Fall through to label ?Subroutine0
    332          
    333          
    334          /*************************************************************************
    335          *
    336          * Build datablock for Internal AD
    337          *
    338          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    339          void BuildADInt(My485UARTDataType *pMy485UART, unsigned char *pointer) {
   \                     BuildADInt:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F59               MOV     R21, R25
   \   00000006   2E28               MOV     R2, R24
   \   00000008   01F8               MOVW    R31:R30, R17:R16
    340          
    341              short ntna, i;
    342              pMy485UART->RxSendReply = true;                               // flag for answering
   \   0000000A   E001               LDI     R16, 1
   \   0000000C   8F02               STD     Z+26, R16
    343          
    344              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_INT_DATA & 0xff;
   \   0000000E   8102               LDD     R16, Z+2
   \   00000010   8113               LDD     R17, Z+3
   \   00000012   01C8               MOVW    R25:R24, R17:R16
   \   00000014   9601               ADIW    R25:R24, 1
   \   00000016   8382               STD     Z+2, R24
   \   00000018   8393               STD     Z+3, R25
   \   0000001A   81A0               LD      R26, Z
   \   0000001C   81B1               LDD     R27, Z+1
   \   0000001E   0FA0               ADD     R26, R16
   \   00000020   1FB1               ADC     R27, R17
   \   00000022   E403               LDI     R16, 67
   \   00000024   930C               ST      X, R16
    345              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_INT_DATA >> 8;
   \   00000026   8102               LDD     R16, Z+2
   \   00000028   8113               LDD     R17, Z+3
   \   0000002A   01C8               MOVW    R25:R24, R17:R16
   \   0000002C   9601               ADIW    R25:R24, 1
   \   0000002E   8382               STD     Z+2, R24
   \   00000030   8393               STD     Z+3, R25
   \   00000032   81A0               LD      R26, Z
   \   00000034   81B1               LDD     R27, Z+1
   \   00000036   0FA0               ADD     R26, R16
   \   00000038   1FB1               ADC     R27, R17
   \   0000003A   E004               LDI     R16, 4
   \   0000003C   930C               ST      X, R16
    346              ntna = pMy485UART->TxFirst;                                    /* remember index */
   \   0000003E   8122               LDD     R18, Z+2
   \   00000040   8133               LDD     R19, Z+3
    347              pMy485UART->TxFirst += 2;                                      // two byte length
   \   00000042   8102               LDD     R16, Z+2
   \   00000044   8113               LDD     R17, Z+3
   \   00000046   5F0E               SUBI    R16, 254
   \   00000048   4F1F               SBCI    R17, 255
   \   0000004A   8302               STD     Z+2, R16
   \   0000004C   8313               STD     Z+3, R17
    348          
    349              for ( i = 0; i < 3; i++ ) {
   \   0000004E   ....               LDI     R16, LOW(ADInt)
   \   00000050   ....               LDI     R17, (ADInt) >> 8
   \   00000052   E043               LDI     R20, 3
    350                  pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = ADInt.Result[i];
   \                     ??BuildADInt_0:
   \   00000054   8002               LDD     R0, Z+2
   \   00000056   8013               LDD     R1, Z+3
   \   00000058   01C0               MOVW    R25:R24, R1:R0
   \   0000005A   9601               ADIW    R25:R24, 1
   \   0000005C   8382               STD     Z+2, R24
   \   0000005E   8393               STD     Z+3, R25
   \   00000060   01D8               MOVW    R27:R26, R17:R16
   \   00000062   916D               LD      R22, X+
   \   00000064   81A0               LD      R26, Z
   \   00000066   81B1               LDD     R27, Z+1
   \   00000068   0DA0               ADD     R26, R0
   \   0000006A   1DB1               ADC     R27, R1
   \   0000006C   936C               ST      X, R22
    351                  pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = ADInt.Result[i] >> 8;   // ADresult
   \   0000006E   8002               LDD     R0, Z+2
   \   00000070   8013               LDD     R1, Z+3
   \   00000072   01C0               MOVW    R25:R24, R1:R0
   \   00000074   9601               ADIW    R25:R24, 1
   \   00000076   8382               STD     Z+2, R24
   \   00000078   8393               STD     Z+3, R25
   \   0000007A   01D8               MOVW    R27:R26, R17:R16
   \   0000007C   9611               ADIW    R27:R26, 1
   \   0000007E   917D               LD      R23, X+
   \   00000080   018D               MOVW    R17:R16, R27:R26
   \   00000082   81A0               LD      R26, Z
   \   00000084   81B1               LDD     R27, Z+1
   \   00000086   0DA0               ADD     R26, R0
   \   00000088   1DB1               ADC     R27, R1
   \   0000008A   937C               ST      X, R23
    352              }
   \   0000008C   954A               DEC     R20
   \   0000008E   F711               BRNE    ??BuildADInt_0
    353          
    354              pMy485UART->pTxBuffer[ntna] = (pMy485UART->TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   00000090   8102               LDD     R16, Z+2
   \   00000092   8113               LDD     R17, Z+3
   \   00000094   1B02               SUB     R16, R18
   \   00000096   5002               SUBI    R16, 2
   \   00000098   81A0               LD      R26, Z
   \   0000009A   81B1               LDD     R27, Z+1
   \   0000009C   0FA2               ADD     R26, R18
   \   0000009E   1FB3               ADC     R27, R19
   \   000000A0   930C               ST      X, R16
    355              pMy485UART->pTxBuffer[ntna + 1] = ((pMy485UART->TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000A2   8182               LDD     R24, Z+2
   \   000000A4   8193               LDD     R25, Z+3
   \   000000A6   1B82               SUB     R24, R18
   \   000000A8   0B93               SBC     R25, R19
   \   000000AA   9702               SBIW    R25:R24, 2
   \   000000AC   8100               LD      R16, Z
   \   000000AE   8111               LDD     R17, Z+1
   \   000000B0   0F02               ADD     R16, R18
   \   000000B2   1F13               ADC     R17, R19
   \   000000B4   01F8               MOVW    R31:R30, R17:R16
   \   000000B6   8391               STD     Z+1, R25
    356          
    357          }
   \   000000B8   2D82               MOV     R24, R2
   \   000000BA   2F95               MOV     R25, R21
   \   000000BC   2DA3               MOV     R26, R3
   \   000000BE   91B9               LD      R27, Y+
   \   000000C0   9508               RET
    358          
    359          
    360          /*************************************************************************
    361          *
    362          * Build setup data package for AN-ZBHART
    363          *
    364          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    365          void BuildHartSetup(My485UARTDataType *pMy485UART, unsigned char *pointer) {
   \                     BuildHartSetup:
   \   00000000   010D               MOVW    R1:R0, R27:R26
   \   00000002   01BC               MOVW    R23:R22, R25:R24
   \   00000004   01F8               MOVW    R31:R30, R17:R16
    366          
    367              short ntna;
    368              pMy485UART->RxSendReply = true;                               // flag for answering
   \   00000006   E001               LDI     R16, 1
   \   00000008   8F02               STD     Z+26, R16
    369          
    370              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_HART_SETUP & 0xff;
   \   0000000A   8102               LDD     R16, Z+2
   \   0000000C   8113               LDD     R17, Z+3
   \   0000000E   01C8               MOVW    R25:R24, R17:R16
   \   00000010   9601               ADIW    R25:R24, 1
   \   00000012   8382               STD     Z+2, R24
   \   00000014   8393               STD     Z+3, R25
   \   00000016   81A0               LD      R26, Z
   \   00000018   81B1               LDD     R27, Z+1
   \   0000001A   0FA0               ADD     R26, R16
   \   0000001C   1FB1               ADC     R27, R17
   \   0000001E   EE0D               LDI     R16, 237
   \   00000020   930C               ST      X, R16
    371              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_HART_SETUP >> 8;
   \   00000022   8102               LDD     R16, Z+2
   \   00000024   8113               LDD     R17, Z+3
   \   00000026   01C8               MOVW    R25:R24, R17:R16
   \   00000028   9601               ADIW    R25:R24, 1
   \   0000002A   8382               STD     Z+2, R24
   \   0000002C   8393               STD     Z+3, R25
   \   0000002E   81A0               LD      R26, Z
   \   00000030   81B1               LDD     R27, Z+1
   \   00000032   0FA0               ADD     R26, R16
   \   00000034   1FB1               ADC     R27, R17
   \   00000036   E004               LDI     R16, 4
   \   00000038   930C               ST      X, R16
    372              ntna = pMy485UART->TxFirst;                                    /* remember index */
   \   0000003A   8102               LDD     R16, Z+2
   \   0000003C   8113               LDD     R17, Z+3
    373              pMy485UART->TxFirst += 2;                                      // two byte length
   \   0000003E   8122               LDD     R18, Z+2
   \   00000040   8133               LDD     R19, Z+3
   \   00000042   5F2E               SUBI    R18, 254
   \   00000044   4F3F               SBCI    R19, 255
   \   00000046   8322               STD     Z+2, R18
   \   00000048   8333               STD     Z+3, R19
    374          
    375              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = TData.Hart.PortUsed & 0xff;
   \   0000004A   8142               LDD     R20, Z+2
   \   0000004C   8153               LDD     R21, Z+3
   \   0000004E   01CA               MOVW    R25:R24, R21:R20
   \   00000050   9601               ADIW    R25:R24, 1
   \   00000052   8382               STD     Z+2, R24
   \   00000054   8393               STD     Z+3, R25
   \   00000056   9120....           LDS     R18, (TData + 144)
   \   0000005A   81A0               LD      R26, Z
   \   0000005C   81B1               LDD     R27, Z+1
   \   0000005E   0FA4               ADD     R26, R20
   \   00000060   1FB5               ADC     R27, R21
   \   00000062   932C               ST      X, R18
    376              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = (TData.Hart.PortUsed >> 8) & 0xff;
   \   00000064   8142               LDD     R20, Z+2
   \   00000066   8153               LDD     R21, Z+3
   \   00000068   01CA               MOVW    R25:R24, R21:R20
   \   0000006A   9601               ADIW    R25:R24, 1
   \   0000006C   8382               STD     Z+2, R24
   \   0000006E   8393               STD     Z+3, R25
   \   00000070   9120....           LDS     R18, (TData + 145)
   \   00000074   81A0               LD      R26, Z
   \   00000076   81B1               LDD     R27, Z+1
   \   00000078   0FA4               ADD     R26, R20
   \   0000007A   1FB5               ADC     R27, R21
   \   0000007C   932C               ST      X, R18
    377          
    378              pMy485UART->pTxBuffer[ntna] =  (pMy485UART->TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   0000007E   8122               LDD     R18, Z+2
   \   00000080   8133               LDD     R19, Z+3
   \   00000082   1B20               SUB     R18, R16
   \   00000084   5022               SUBI    R18, 2
   \   00000086   81A0               LD      R26, Z
   \   00000088   81B1               LDD     R27, Z+1
   \   0000008A   0FA0               ADD     R26, R16
   \   0000008C   1FB1               ADC     R27, R17
   \   0000008E   932C               ST      X, R18
    379              pMy485UART->pTxBuffer[ntna + 1] = ((pMy485UART->TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000090   8182               LDD     R24, Z+2
   \   00000092   8193               LDD     R25, Z+3
   \   00000094   1B80               SUB     R24, R16
   \   00000096   0B91               SBC     R25, R17
   \   00000098   9702               SBIW    R25:R24, 2
   \   0000009A   8120               LD      R18, Z
   \   0000009C   8131               LDD     R19, Z+1
   \   0000009E   0F20               ADD     R18, R16
   \   000000A0   1F31               ADC     R19, R17
   \   000000A2   01F9               MOVW    R31:R30, R19:R18
   \   000000A4   8391               STD     Z+1, R25
    380          }
   \   000000A6   01CB               MOVW    R25:R24, R23:R22
   \   000000A8   01D0               MOVW    R27:R26, R1:R0
   \   000000AA   9508               RET
    381          
    382          /*************************************************************************
    383          *
    384          * Build filter data package for AN-ZBHART
    385          *
    386          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    387          void BuildHartFilter(My485UARTDataType *pMy485UART, unsigned char *pointer) {
   \                     BuildHartFilter:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F79               MOV     R23, R25
   \   00000006   2E28               MOV     R2, R24
   \   00000008   01D8               MOVW    R27:R26, R17:R16
    388          
    389              char port;
    390              short ntna;
    391              pMy485UART->RxSendReply = true;                               // flag for answering
   \   0000000A   01F8               MOVW    R31:R30, R17:R16
   \   0000000C   E001               LDI     R16, 1
   \   0000000E   8F02               STD     Z+26, R16
    392          
    393              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_HART_FILTER & 0xff;
   \   00000010   8102               LDD     R16, Z+2
   \   00000012   8113               LDD     R17, Z+3
   \   00000014   01C8               MOVW    R25:R24, R17:R16
   \   00000016   9601               ADIW    R25:R24, 1
   \   00000018   8382               STD     Z+2, R24
   \   0000001A   8393               STD     Z+3, R25
   \   0000001C   91ED               LD      R30, X+
   \   0000001E   91FC               LD      R31, X
   \   00000020   9711               SBIW    R27:R26, 1
   \   00000022   0FE0               ADD     R30, R16
   \   00000024   1FF1               ADC     R31, R17
   \   00000026   E001               LDI     R16, 1
   \   00000028   8300               ST      Z, R16
    394              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_HART_FILTER >> 8;
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   8102               LDD     R16, Z+2
   \   0000002E   8113               LDD     R17, Z+3
   \   00000030   01C8               MOVW    R25:R24, R17:R16
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   8382               STD     Z+2, R24
   \   00000036   8393               STD     Z+3, R25
   \   00000038   91ED               LD      R30, X+
   \   0000003A   91FC               LD      R31, X
   \   0000003C   9711               SBIW    R27:R26, 1
   \   0000003E   0FE0               ADD     R30, R16
   \   00000040   1FF1               ADC     R31, R17
   \   00000042   E005               LDI     R16, 5
   \   00000044   8300               ST      Z, R16
    395              ntna = pMy485UART->TxFirst;                                    /* remember index */
   \   00000046   01FD               MOVW    R31:R30, R27:R26
   \   00000048   8142               LDD     R20, Z+2
   \   0000004A   8153               LDD     R21, Z+3
    396              pMy485UART->TxFirst += 2;                                      // two byte length
   \   0000004C   8102               LDD     R16, Z+2
   \   0000004E   8113               LDD     R17, Z+3
   \   00000050   5F0E               SUBI    R16, 254
   \   00000052   4F1F               SBCI    R17, 255
   \   00000054   8302               STD     Z+2, R16
   \   00000056   8313               STD     Z+3, R17
    397          
    398              for ( port = 0; port < 12; port++ ) {
   \   00000058   E060               LDI     R22, 0
   \   0000005A   E02C               LDI     R18, 12
    399                  pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = TData.Hart.Filter[port];
   \                     ??BuildHartFilter_0:
   \   0000005C   01FD               MOVW    R31:R30, R27:R26
   \   0000005E   8002               LDD     R0, Z+2
   \   00000060   8013               LDD     R1, Z+3
   \   00000062   01C0               MOVW    R25:R24, R1:R0
   \   00000064   9601               ADIW    R25:R24, 1
   \   00000066   8382               STD     Z+2, R24
   \   00000068   8393               STD     Z+3, R25
   \   0000006A   E0F0               LDI     R31, 0
   \   0000006C   2FE6               MOV     R30, R22
   \   0000006E   ....               SUBI    R30, LOW((-(TData + 146) & 0xFFFF))
   \   00000070   ....               SBCI    R31, HIGH((-(TData + 146) & 0xFFFF))
   \   00000072   8130               LD      R19, Z
   \   00000074   01FD               MOVW    R31:R30, R27:R26
   \   00000076   8100               LD      R16, Z
   \   00000078   8111               LDD     R17, Z+1
   \   0000007A   0D00               ADD     R16, R0
   \   0000007C   1D11               ADC     R17, R1
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   8330               ST      Z, R19
    400              }
   \   00000082   9563               INC     R22
   \   00000084   952A               DEC     R18
   \   00000086   F751               BRNE    ??BuildHartFilter_0
    401          
    402              pMy485UART->pTxBuffer[ntna] =  (pMy485UART->TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   00000088   01FD               MOVW    R31:R30, R27:R26
   \   0000008A   8102               LDD     R16, Z+2
   \   0000008C   8113               LDD     R17, Z+3
   \   0000008E   1B04               SUB     R16, R20
   \   00000090   5002               SUBI    R16, 2
   \   00000092   91ED               LD      R30, X+
   \   00000094   91FC               LD      R31, X
   \   00000096   9711               SBIW    R27:R26, 1
   \   00000098   0FE4               ADD     R30, R20
   \   0000009A   1FF5               ADC     R31, R21
   \   0000009C   8300               ST      Z, R16
    403              pMy485UART->pTxBuffer[ntna + 1] = ((pMy485UART->TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000009E   01FD               MOVW    R31:R30, R27:R26
   \   000000A0   8182               LDD     R24, Z+2
   \   000000A2   8193               LDD     R25, Z+3
   \   000000A4   1B84               SUB     R24, R20
   \   000000A6   0B95               SBC     R25, R21
   \   000000A8   9702               SBIW    R25:R24, 2
   \   000000AA   91ED               LD      R30, X+
   \   000000AC   91FC               LD      R31, X
   \   000000AE   0FE4               ADD     R30, R20
   \   000000B0   1FF5               ADC     R31, R21
   \   000000B2   8391               STD     Z+1, R25
    404          }
   \   000000B4   2D82               MOV     R24, R2
   \   000000B6   2F97               MOV     R25, R23
   \   000000B8   2DA3               MOV     R26, R3
   \   000000BA   91B9               LD      R27, Y+
   \   000000BC   9508               RET
    405          
    406          /*************************************************************************
    407          *
    408          * Build datablock for Hart (Hart)
    409          *
    410          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    411          void BuildMDataHart(My485UARTDataType *pMy485UART) {
   \                     BuildMDataHart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
    412              short Index        = 11; // // Add data after the heading, Heading size is 11
    413              char *Buf          = pMy485UART->pTxBuffer;
   \   00000008   01F8               MOVW    R31:R30, R17:R16
   \   0000000A   8140               LD      R20, Z
   \   0000000C   8151               LDD     R21, Z+1
    414              pMy485UART->RxSendReply = true;                               // flag for answering
   \   0000000E   E021               LDI     R18, 1
   \   00000010   8F22               STD     Z+26, R18
    415              Buf[Index++] = CMD_REP_HART_MDATA & 0xff;
   \   00000012   01FA               MOVW    R31:R30, R21:R20
   \   00000014   E02B               LDI     R18, 11
   \   00000016   8723               STD     Z+11, R18
    416              Buf[Index++] = CMD_REP_HART_MDATA >> 8;
   \   00000018   E025               LDI     R18, 5
   \   0000001A   8724               STD     Z+12, R18
    417              short ntna = Index;                                  /* remember index */
    418              Index  += 2;                                      // two byte length
    419          
    420              Buf[Index++] = (RestartStatus << 4);    // Add restart status
   \   0000001C   9120....           LDS     R18, RestartStatus
   \   00000020   9522               SWAP    R18
   \   00000022   7F20               ANDI    R18, 0xF0
   \   00000024   8727               STD     Z+15, R18
   \   00000026   E180               LDI     R24, 16
   \   00000028   E090               LDI     R25, 0
    421              // Hart PV
    422              for ( short i = 0; i < 12; i++ ) {
   \   0000002A   9674               ADIW    R31:R30, 20
   \   0000002C   ....               LDI     R18, LOW((TData + 158))
   \   0000002E   ....               LDI     R19, HIGH((TData + 158))
   \   00000030   E06C               LDI     R22, 12
    423                  *((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][0];   // Hart 1st
   \                     ??BuildMDataHart_0:
   \   00000032   0109               MOVW    R1:R0, R19:R18
   \   00000034   E672               LDI     R23, 98
   \   00000036   0E07               ADD     R0, R23
   \   00000038   EF7F               LDI     R23, 255
   \   0000003A   1E17               ADC     R1, R23
   \   0000003C   01D0               MOVW    R27:R26, R1:R0
   \   0000003E   902D               LD      R2, X+
   \   00000040   903C               LD      R3, X
   \   00000042   01DF               MOVW    R27:R26, R31:R30
   \   00000044   9714               SBIW    R27:R26, 4
   \   00000046   922D               ST      X+, R2
   \   00000048   923C               ST      X, R3
    424                  Index += sizeof(unsigned short);
    425                  *((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][1];   // Hart 2nd
   \   0000004A   01D0               MOVW    R27:R26, R1:R0
   \   0000004C   9612               ADIW    R27:R26, 2
   \   0000004E   900D               LD      R0, X+
   \   00000050   901C               LD      R1, X
   \   00000052   01DF               MOVW    R27:R26, R31:R30
   \   00000054   9712               SBIW    R27:R26, 2
   \   00000056   920D               ST      X+, R0
   \   00000058   921C               ST      X, R1
    426                  Index += sizeof(unsigned short);
    427                  //hart_channel_lock(&_hart_channels[i]);
    428                  *((float *)&Buf[Index]) = TData.Hart.Distance[i];       // Hart 1st
   \   0000005A   01D9               MOVW    R27:R26, R19:R18
   \   0000005C   5AA0               SUBI    R26, 160
   \   0000005E   4FBF               SBCI    R27, 255
   \   00000060   900D               LD      R0, X+
   \   00000062   901D               LD      R1, X+
   \   00000064   902D               LD      R2, X+
   \   00000066   903C               LD      R3, X
   \   00000068   969D               ADIW    R27:R26, 45
   \   0000006A   8200               ST      Z, R0
   \   0000006C   8211               STD     Z+1, R1
   \   0000006E   8222               STD     Z+2, R2
   \   00000070   8233               STD     Z+3, R3
    429                  Index += sizeof(float);
    430                  *((float *)&Buf[Index]) = TData.Hart.Level[i];          // Hart 2nd
   \   00000072   900D               LD      R0, X+
   \   00000074   901D               LD      R1, X+
   \   00000076   902D               LD      R2, X+
   \   00000078   903C               LD      R3, X
   \   0000007A   8204               STD     Z+4, R0
   \   0000007C   8215               STD     Z+5, R1
   \   0000007E   8226               STD     Z+6, R2
   \   00000080   8237               STD     Z+7, R3
    431                  Index += sizeof(float);
    432                  *((float *)&Buf[Index]) = TData.Hart.ADCurrent[i];   // Measured current via onboard ADC
   \   00000082   01D9               MOVW    R27:R26, R19:R18
   \   00000084   900D               LD      R0, X+
   \   00000086   901D               LD      R1, X+
   \   00000088   902D               LD      R2, X+
   \   0000008A   903C               LD      R3, X
   \   0000008C   8600               STD     Z+8, R0
   \   0000008E   8611               STD     Z+9, R1
   \   00000090   8622               STD     Z+10, R2
   \   00000092   8633               STD     Z+11, R3
    433                  Index += sizeof(float);
   \   00000094   9640               ADIW    R25:R24, 16
    434                  //*((float *)&Buf[Index]) = TData.Hart.HartCurrent[i];    // mA current from the device
    435                  //Index += sizeof(float);
    436                  //hart_channel_unlock(&_hart_channels[i]);
    437              }
   \   00000096   5F2C               SUBI    R18, 252
   \   00000098   4F3F               SBCI    R19, 255
   \   0000009A   9670               ADIW    R31:R30, 16
   \   0000009C   956A               DEC     R22
   \   0000009E   F649               BRNE    ??BuildMDataHart_0
    438              Buf[ntna] = (Index - ntna - 2) & 0xff;      // length of data block lb
   \   000000A0   2F28               MOV     R18, R24
   \   000000A2   502F               SUBI    R18, 15
   \   000000A4   01FA               MOVW    R31:R30, R21:R20
   \   000000A6   8725               STD     Z+13, R18
    439              Buf[ntna + 1] = ((Index - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000A8   01FC               MOVW    R31:R30, R25:R24
   \   000000AA   973F               SBIW    R31:R30, 15
   \   000000AC   2F2F               MOV     R18, R31
   \   000000AE   01FA               MOVW    R31:R30, R21:R20
   \   000000B0   8726               STD     Z+14, R18
    440              pMy485UART->TxFirst = Index; // Add data after the heading
   \   000000B2   01F8               MOVW    R31:R30, R17:R16
   \   000000B4   8382               STD     Z+2, R24
   \   000000B6   8393               STD     Z+3, R25
    441          
    442          
    443          }
   \   000000B8   ....               RJMP    ?Subroutine1
    444          
    445          
    446          /*************************************************************************
    447          *
    448          * Build datablock for Stack status
    449          *
    450          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    451          void BuildStackStatus(My485UARTDataType *pMy485UART, unsigned char *pointer) {
   \                     BuildStackStatus:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008   01D8               MOVW    R27:R26, R17:R16
    452          
    453              short ntna, stack;
    454              pMy485UART->RxSendReply = true;                               // flag for answering
   \   0000000A   01F8               MOVW    R31:R30, R17:R16
   \   0000000C   E001               LDI     R16, 1
   \   0000000E   8F02               STD     Z+26, R16
    455          
    456              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_STACKSTATUS & 0xff;
   \   00000010   8102               LDD     R16, Z+2
   \   00000012   8113               LDD     R17, Z+3
   \   00000014   01C8               MOVW    R25:R24, R17:R16
   \   00000016   9601               ADIW    R25:R24, 1
   \   00000018   8382               STD     Z+2, R24
   \   0000001A   8393               STD     Z+3, R25
   \   0000001C   91ED               LD      R30, X+
   \   0000001E   91FC               LD      R31, X
   \   00000020   9711               SBIW    R27:R26, 1
   \   00000022   0FE0               ADD     R30, R16
   \   00000024   1FF1               ADC     R31, R17
   \   00000026   E707               LDI     R16, 119
   \   00000028   8300               ST      Z, R16
    457              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = CMD_REP_STACKSTATUS >> 8;
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   8102               LDD     R16, Z+2
   \   0000002E   8113               LDD     R17, Z+3
   \   00000030   01C8               MOVW    R25:R24, R17:R16
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   8382               STD     Z+2, R24
   \   00000036   8393               STD     Z+3, R25
   \   00000038   91ED               LD      R30, X+
   \   0000003A   91FC               LD      R31, X
   \   0000003C   9711               SBIW    R27:R26, 1
   \   0000003E   0FE0               ADD     R30, R16
   \   00000040   1FF1               ADC     R31, R17
   \   00000042   E007               LDI     R16, 7
   \   00000044   8300               ST      Z, R16
    458              ntna = pMy485UART->TxFirst;                                    /* remember index */
   \   00000046   01FD               MOVW    R31:R30, R27:R26
   \   00000048   8182               LDD     R24, Z+2
   \   0000004A   8193               LDD     R25, Z+3
    459              pMy485UART->TxFirst += 2;                                      // two byte length
   \   0000004C   8102               LDD     R16, Z+2
   \   0000004E   8113               LDD     R17, Z+3
   \   00000050   5F0E               SUBI    R16, 254
   \   00000052   4F1F               SBCI    R17, 255
   \   00000054   8302               STD     Z+2, R16
   \   00000056   8313               STD     Z+3, R17
    460          
    461              stack = OS_GetStackSpace(&TCB_USART0);                            // USART 0
   \   00000058   ....               LDI     R16, LOW(TCB_USART0)
   \   0000005A   ....               LDI     R17, (TCB_USART0) >> 8
   \   0000005C   ........           CALL    OS_GetStackSpace
    462              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = (stack & 0xff);
   \   00000060   01FD               MOVW    R31:R30, R27:R26
   \   00000062   8142               LDD     R20, Z+2
   \   00000064   8153               LDD     R21, Z+3
   \   00000066   019A               MOVW    R19:R18, R21:R20
   \   00000068   5F2F               SUBI    R18, 255
   \   0000006A   4F3F               SBCI    R19, 255
   \   0000006C   8322               STD     Z+2, R18
   \   0000006E   8333               STD     Z+3, R19
   \   00000070   91ED               LD      R30, X+
   \   00000072   91FC               LD      R31, X
   \   00000074   9711               SBIW    R27:R26, 1
   \   00000076   0FE4               ADD     R30, R20
   \   00000078   1FF5               ADC     R31, R21
   \   0000007A   8300               ST      Z, R16
    463              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = ((stack >> 8) & 0xff);
   \   0000007C   01FD               MOVW    R31:R30, R27:R26
   \   0000007E   8142               LDD     R20, Z+2
   \   00000080   8153               LDD     R21, Z+3
   \   00000082   019A               MOVW    R19:R18, R21:R20
   \   00000084   5F2F               SUBI    R18, 255
   \   00000086   4F3F               SBCI    R19, 255
   \   00000088   8322               STD     Z+2, R18
   \   0000008A   8333               STD     Z+3, R19
   \   0000008C   91ED               LD      R30, X+
   \   0000008E   91FC               LD      R31, X
   \   00000090   9711               SBIW    R27:R26, 1
   \   00000092   0FE4               ADD     R30, R20
   \   00000094   1FF5               ADC     R31, R21
   \   00000096   8310               ST      Z, R17
    464          
    465              stack = OS_GetStackSpace(&TCB_WATCHDOG);                            // watchdog
   \   00000098   ....               LDI     R16, LOW(TCB_WATCHDOG)
   \   0000009A   ....               LDI     R17, (TCB_WATCHDOG) >> 8
   \   0000009C   ........           CALL    OS_GetStackSpace
    466              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = (stack & 0xff);
   \   000000A0   01FD               MOVW    R31:R30, R27:R26
   \   000000A2   8142               LDD     R20, Z+2
   \   000000A4   8153               LDD     R21, Z+3
   \   000000A6   019A               MOVW    R19:R18, R21:R20
   \   000000A8   5F2F               SUBI    R18, 255
   \   000000AA   4F3F               SBCI    R19, 255
   \   000000AC   8322               STD     Z+2, R18
   \   000000AE   8333               STD     Z+3, R19
   \   000000B0   91ED               LD      R30, X+
   \   000000B2   91FC               LD      R31, X
   \   000000B4   9711               SBIW    R27:R26, 1
   \   000000B6   0FE4               ADD     R30, R20
   \   000000B8   1FF5               ADC     R31, R21
   \   000000BA   8300               ST      Z, R16
    467              pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = ((stack >> 8) & 0xff);
   \   000000BC   01FD               MOVW    R31:R30, R27:R26
   \   000000BE   8142               LDD     R20, Z+2
   \   000000C0   8153               LDD     R21, Z+3
   \   000000C2   019A               MOVW    R19:R18, R21:R20
   \   000000C4   5F2F               SUBI    R18, 255
   \   000000C6   4F3F               SBCI    R19, 255
   \   000000C8   8322               STD     Z+2, R18
   \   000000CA   8333               STD     Z+3, R19
   \   000000CC   91ED               LD      R30, X+
   \   000000CE   91FC               LD      R31, X
   \   000000D0   9711               SBIW    R27:R26, 1
   \   000000D2   0FE4               ADD     R30, R20
   \   000000D4   1FF5               ADC     R31, R21
   \   000000D6   8310               ST      Z, R17
    468              switch ( UnitID ) {
   \   000000D8   9100....           LDS     R16, UnitID
   \   000000DC   3003               CPI     R16, 3
   \   000000DE   F5F1               BRNE    ??BuildStackStatus_0
    469              case AN_ZB485 :
    470              case AN_ZBANA :
    471                  break;
    472              case AN_ZBHART :
    473                  stack = OS_GetStackSpace(&TCB_AD7715);                            // AD handling
   \   000000E0   ....               LDI     R16, LOW(TCB_AD7715)
   \   000000E2   ....               LDI     R17, (TCB_AD7715) >> 8
   \   000000E4   ........           CALL    OS_GetStackSpace
    474                  pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = (stack & 0xff);
   \   000000E8   01FD               MOVW    R31:R30, R27:R26
   \   000000EA   8142               LDD     R20, Z+2
   \   000000EC   8153               LDD     R21, Z+3
   \   000000EE   019A               MOVW    R19:R18, R21:R20
   \   000000F0   5F2F               SUBI    R18, 255
   \   000000F2   4F3F               SBCI    R19, 255
   \   000000F4   8322               STD     Z+2, R18
   \   000000F6   8333               STD     Z+3, R19
   \   000000F8   91ED               LD      R30, X+
   \   000000FA   91FC               LD      R31, X
   \   000000FC   9711               SBIW    R27:R26, 1
   \   000000FE   0FE4               ADD     R30, R20
   \   00000100   1FF5               ADC     R31, R21
   \   00000102   8300               ST      Z, R16
    475                  pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = ((stack >> 8) & 0xff);
   \   00000104   01FD               MOVW    R31:R30, R27:R26
   \   00000106   8142               LDD     R20, Z+2
   \   00000108   8153               LDD     R21, Z+3
   \   0000010A   019A               MOVW    R19:R18, R21:R20
   \   0000010C   5F2F               SUBI    R18, 255
   \   0000010E   4F3F               SBCI    R19, 255
   \   00000110   8322               STD     Z+2, R18
   \   00000112   8333               STD     Z+3, R19
   \   00000114   91ED               LD      R30, X+
   \   00000116   91FC               LD      R31, X
   \   00000118   9711               SBIW    R27:R26, 1
   \   0000011A   0FE4               ADD     R30, R20
   \   0000011C   1FF5               ADC     R31, R21
   \   0000011E   8310               ST      Z, R17
    476                  pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = 0;
   \   00000120   01FD               MOVW    R31:R30, R27:R26
   \   00000122   8122               LDD     R18, Z+2
   \   00000124   8133               LDD     R19, Z+3
   \   00000126   0189               MOVW    R17:R16, R19:R18
   \   00000128   5F0F               SUBI    R16, 255
   \   0000012A   4F1F               SBCI    R17, 255
   \   0000012C   8302               STD     Z+2, R16
   \   0000012E   8313               STD     Z+3, R17
   \   00000130   91ED               LD      R30, X+
   \   00000132   91FC               LD      R31, X
   \   00000134   9711               SBIW    R27:R26, 1
   \   00000136   0FE2               ADD     R30, R18
   \   00000138   1FF3               ADC     R31, R19
   \   0000013A   E000               LDI     R16, 0
   \   0000013C   8300               ST      Z, R16
    477                  pMy485UART->pTxBuffer[pMy485UART->TxFirst++] = 0;
   \   0000013E   01FD               MOVW    R31:R30, R27:R26
   \   00000140   8122               LDD     R18, Z+2
   \   00000142   8133               LDD     R19, Z+3
   \   00000144   0189               MOVW    R17:R16, R19:R18
   \   00000146   5F0F               SUBI    R16, 255
   \   00000148   4F1F               SBCI    R17, 255
   \   0000014A   8302               STD     Z+2, R16
   \   0000014C   8313               STD     Z+3, R17
   \   0000014E   91ED               LD      R30, X+
   \   00000150   91FC               LD      R31, X
   \   00000152   9711               SBIW    R27:R26, 1
   \   00000154   0FE2               ADD     R30, R18
   \   00000156   1FF3               ADC     R31, R19
   \   00000158   E000               LDI     R16, 0
   \   0000015A   8300               ST      Z, R16
    478                  break;
    479              }
    480          
    481              pMy485UART->pTxBuffer[ntna] = (pMy485UART->TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \                     ??BuildStackStatus_0:
   \   0000015C   01FD               MOVW    R31:R30, R27:R26
   \   0000015E   8102               LDD     R16, Z+2
   \   00000160   8113               LDD     R17, Z+3
   \   00000162   1B08               SUB     R16, R24
   \   00000164   5002               SUBI    R16, 2
   \   00000166   91ED               LD      R30, X+
   \   00000168   91FC               LD      R31, X
   \   0000016A   9711               SBIW    R27:R26, 1
   \   0000016C   0FE8               ADD     R30, R24
   \   0000016E   1FF9               ADC     R31, R25
   \   00000170   8300               ST      Z, R16
    482              pMy485UART->pTxBuffer[ntna + 1] = ((pMy485UART->TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000172   01FD               MOVW    R31:R30, R27:R26
   \   00000174   8102               LDD     R16, Z+2
   \   00000176   8113               LDD     R17, Z+3
   \   00000178   1B08               SUB     R16, R24
   \   0000017A   0B19               SBC     R17, R25
   \   0000017C   5002               SUBI    R16, 2
   \   0000017E   4010               SBCI    R17, 0
   \   00000180   91ED               LD      R30, X+
   \   00000182   91FC               LD      R31, X
   \   00000184   0FE8               ADD     R30, R24
   \   00000186   1FF9               ADC     R31, R25
   \   00000188   8311               STD     Z+1, R17
    483          
    484          }
   \   0000018A   ....               RJMP    ?Subroutine1
    485          
    486          //////////////////////////////////////////////////////////////////////////////
    487          // Receiving data to IO module here
    488          /////////////////////////////////////////////////////////////////////////////
    489          
    490          /*************************************************************************
    491          *
    492          * Receive Command to Reset the EEPROM
    493          *
    494          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    495          void GetResetEEPROM(void) {
   \                     GetResetEEPROM:
    496          
    497              EEPROMReset();
   \   00000000   ........           JMP     EEPROMReset
    498          }
    499          
    500          
    501          /*************************************************************************
    502          *
    503          * Receive Command to go to the bootloader program
    504          *
    505          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    506          void GetGotoBootloader(unsigned char *pointer) {
   \                     GetGotoBootloader:
    507          
    508          //    void (*BootApp)(void) = (void(*)())0xF000;
    509          
    510              while ( (EECR & 1 << EEPE) != 0 ) //chech if EEPROM is ready
   \                     ??GetGotoBootloader_0:
   \   00000000   99F9               SBIC    0x1F, 0x01
   \   00000002   CFFE               RJMP    ??GetGotoBootloader_0
    511              ;
    512              EEARL = (0x0fff & 0xff);
   \   00000004   EF0F               LDI     R16, 255
   \   00000006   BD01               OUT     0x21, R16
    513              EEARH = (0x0fff >> 8);
   \   00000008   E00F               LDI     R16, 15
   \   0000000A   BD02               OUT     0x22, R16
    514              EEDR = 0xff;
   \   0000000C   EF0F               LDI     R16, 255
   \   0000000E   BD00               OUT     0x20, R16
    515              EECR |= (1 << EEMPE);
   \   00000010   9AFA               SBI     0x1F, 0x02
    516              EECR |= (1 << EEPE);
   \   00000012   9AF9               SBI     0x1F, 0x01
    517              while ( EECR & (1 << EEPE) )
   \                     ??GetGotoBootloader_1:
   \   00000014   99F9               SBIC    0x1F, 0x01
   \   00000016   CFFE               RJMP    ??GetGotoBootloader_1
    518              ;
    519          
    520              WDTCSR = 0x18;               //Start watchdog to genetate restart
   \   00000018   E108               LDI     R16, 24
   \   0000001A   9300....           STS     _A_WDTCSR, R16
    521              WDTCSR = 0x08;               //Start watchdog to genetate restart
   \   0000001E   E008               LDI     R16, 8
   \   00000020   9300....           STS     _A_WDTCSR, R16
    522          }
   \   00000024   9508               RET
   \   00000026                      REQUIRE _A_EECR
   \   00000026                      REQUIRE _A_EEAR
   \   00000026                      REQUIRE _A_EEDR
   \   00000026                      REQUIRE _A_WDTCSR
    523          
    524          /*************************************************************************
    525          *
    526          * Receive EEPROM data
    527          *
    528          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    529          void GetEEPROMData(unsigned char *pointer) {
   \                     GetEEPROMData:
   \   00000000   927A               ST      -Y, R7
   \   00000002   925A               ST      -Y, R5
   \   00000004   924A               ST      -Y, R4
   \   00000006   93BA               ST      -Y, R27
   \   00000008   93AA               ST      -Y, R26
   \   0000000A   939A               ST      -Y, R25
   \   0000000C   938A               ST      -Y, R24
   \   0000000E                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000E                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000E                      REQUIRE ?Register_R7_is_cg_reg
   \   0000000E   0128               MOVW    R5:R4, R17:R16
    530          
    531              char channel;
    532              int t0;
    533          
    534              channel = pointer[0];
   \   00000010   01F8               MOVW    R31:R30, R17:R16
   \   00000012   8100               LD      R16, Z
    535              switch ( UnitID ) {
   \   00000014   9110....           LDS     R17, UnitID
   \   00000018   3013               CPI     R17, 3
   \   0000001A   F4F9               BRNE    ??GetEEPROMData_0
    536              case AN_ZBANA:
    537                  break;
    538              case AN_ZBHART:
    539                  if ( channel >= 0x80 ) {
   \   0000001C   3800               CPI     R16, 128
   \   0000001E   F0E8               BRCS    ??GetEEPROMData_0
    540                      *((float *)&TData.Hart.Offset[channel & 0x0f]) = *((float *)&pointer[1]);  //offset
   \   00000020   ....               LDI     R30, LOW((TData + 350))
   \   00000022   ....               LDI     R31, HIGH((TData + 350))
   \   00000024   2F20               MOV     R18, R16
   \   00000026   E030               LDI     R19, 0
   \   00000028   702F               ANDI    R18, 0x0F
   \   0000002A   0F22               LSL     R18
   \   0000002C   0F22               LSL     R18
   \   0000002E   0FE2               ADD     R30, R18
   \   00000030   1FF3               ADC     R31, R19
   \   00000032   01D2               MOVW    R27:R26, R5:R4
   \   00000034   9611               ADIW    R27:R26, 1
   \   00000036   914D               LD      R20, X+
   \   00000038   915D               LD      R21, X+
   \   0000003A   916D               LD      R22, X+
   \   0000003C   917C               LD      R23, X
   \   0000003E   8340               ST      Z, R20
   \   00000040   8351               STD     Z+1, R21
   \   00000042   8362               STD     Z+2, R22
   \   00000044   8373               STD     Z+3, R23
    541                      *((float *)&TData.Hart.Gain[channel & 0x0f]) = *((float *)&pointer[5]);  //gain
   \   00000046   01D2               MOVW    R27:R26, R5:R4
   \   00000048   9615               ADIW    R27:R26, 5
   \   0000004A   914D               LD      R20, X+
   \   0000004C   915D               LD      R21, X+
   \   0000004E   916D               LD      R22, X+
   \   00000050   917C               LD      R23, X
   \   00000052   AB40               STD     Z+48, R20
   \   00000054   AB51               STD     Z+49, R21
   \   00000056   AB62               STD     Z+50, R22
   \   00000058   AB73               STD     Z+51, R23
    542                  }
    543                  break;
    544              case AN_ZB485:
    545                  break;
    546              }
    547              WriteEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&pointer[1]);
   \                     ??GetEEPROMData_0:
   \   0000005A   E018               LDI     R17, 8
   \   0000005C   9F01               MUL     R16, R17
   \   0000005E   01D0               MOVW    R27:R26, R1:R0
   \   00000060   01A2               MOVW    R21:R20, R5:R4
   \   00000062   5F4F               SUBI    R20, 255
   \   00000064   4F5F               SBCI    R21, 255
   \   00000066   E024               LDI     R18, 4
   \   00000068   0180               MOVW    R17:R16, R1:R0
   \   0000006A   ........           CALL    WriteEEPROMBuffer
    548              t0 = OS_GetTime();
   \   0000006E   ........           CALL    OS__Gettime
   \   00000072   01C8               MOVW    R25:R24, R17:R16
   \   00000074   2477               CLR     R7
    549              do {
    550                  OS_Delay(1);
   \                     ??GetEEPROMData_1:
   \   00000076   E001               LDI     R16, 1
   \   00000078   E010               LDI     R17, 0
   \   0000007A   ........           CALL    OS_Delay
    551              }while ( (OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK );  //8.5 ms programming time
   \   0000007E   ........           CALL    OS__Gettime
   \   00000082   1B08               SUB     R16, R24
   \   00000084   0B19               SBC     R17, R25
   \   00000086   3204               CPI     R16, 36
   \   00000088   4010               SBCI    R17, 0
   \   0000008A   F420               BRCC    ??GetEEPROMData_2
   \   0000008C   9100....           LDS     R16, EEPWriteOK
   \   00000090   2300               TST     R16
   \   00000092   F389               BREQ    ??GetEEPROMData_1
    552              WriteEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&pointer[5]);
   \                     ??GetEEPROMData_2:
   \   00000094   E005               LDI     R16, 5
   \   00000096   0E40               ADD     R4, R16
   \   00000098   1C57               ADC     R5, R7
   \   0000009A   01A2               MOVW    R21:R20, R5:R4
   \   0000009C   E024               LDI     R18, 4
   \   0000009E   9614               ADIW    R27:R26, 4
   \   000000A0   018D               MOVW    R17:R16, R27:R26
   \   000000A2   ........           CALL    WriteEEPROMBuffer
    553              t0 = OS_GetTime();
   \   000000A6   ........           CALL    OS__Gettime
   \   000000AA   01C8               MOVW    R25:R24, R17:R16
    554              do {
    555                  OS_Delay(1);
   \                     ??GetEEPROMData_3:
   \   000000AC   E001               LDI     R16, 1
   \   000000AE   E010               LDI     R17, 0
   \   000000B0   ........           CALL    OS_Delay
    556              }while ( (OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK );
   \   000000B4   ........           CALL    OS__Gettime
   \   000000B8   1B08               SUB     R16, R24
   \   000000BA   0B19               SBC     R17, R25
   \   000000BC   3204               CPI     R16, 36
   \   000000BE   4010               SBCI    R17, 0
   \   000000C0   F420               BRCC    ??GetEEPROMData_4
   \   000000C2   9100....           LDS     R16, EEPWriteOK
   \   000000C6   2300               TST     R16
   \   000000C8   F389               BREQ    ??GetEEPROMData_3
    557          }
   \                     ??GetEEPROMData_4:
   \   000000CA   9189               LD      R24, Y+
   \   000000CC   9199               LD      R25, Y+
   \   000000CE   91A9               LD      R26, Y+
   \   000000D0   91B9               LD      R27, Y+
   \   000000D2   9049               LD      R4, Y+
   \   000000D4   9059               LD      R5, Y+
   \   000000D6   9079               LD      R7, Y+
   \   000000D8   9508               RET
    558          
    559          
    560          
    561          /*************************************************************************
    562          *
    563          * Receive AN-ZBHART setup
    564          *
    565          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    566          void GetHartSetup(unsigned char *pointer) {
   \                     GetHartSetup:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   01D8               MOVW    R27:R26, R17:R16
    567              RestartCnt = 0;
   \   00000006   E000               LDI     R16, 0
   \   00000008   9300....           STS     RestartCnt, R16
   \   0000000C   9300....           STS     (RestartCnt + 1), R16
    568              //memset(&TData, 0, sizeof(TData));
    569              TData.Hart.PortUsed = pointer[0] + (pointer[1] << 8);  //Get the setup
   \   00000010   910C               LD      R16, X
   \   00000012   01FD               MOVW    R31:R30, R27:R26
   \   00000014   8111               LDD     R17, Z+1
   \   00000016   9300....           STS     (TData + 144), R16
   \   0000001A   9310....           STS     (TData + 145), R17
    570              WriteEEPROMByte(EEPROM_PORTSETUP, pointer[0]);     // store in EEPROM
   \   0000001E   8120               LD      R18, Z
   \   00000020   E002               LDI     R16, 2
   \   00000022   E010               LDI     R17, 0
   \   00000024   ........           CALL    WriteEEPROMByte
    571              WriteEEPROMByte(EEPROM_PORTSETUP + 1, pointer[1]);
   \   00000028   01FD               MOVW    R31:R30, R27:R26
   \   0000002A   8121               LDD     R18, Z+1
   \   0000002C   E003               LDI     R16, 3
   \   0000002E   E010               LDI     R17, 0
   \   00000030   ........           CALL    WriteEEPROMByte
    572          }
   \   00000034   91A9               LD      R26, Y+
   \   00000036   91B9               LD      R27, Y+
   \   00000038   9508               RET
   \   0000003A                      REQUIRE RestartCnt
    573          
    574          /*************************************************************************
    575          *
    576          * Receive AN-ZBHART filter
    577          *
    578          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    579          void GetHartFilter(unsigned char *pointer) {
   \                     GetHartFilter:
   \   00000000   01AD               MOVW    R21:R20, R27:R26
    580          
    581              for ( int port = 0; port < 12; port++ ) {
   \   00000002   ....               LDI     R26, LOW((TData + 146))
   \   00000004   ....               LDI     R27, HIGH((TData + 146))
   \   00000006   E02C               LDI     R18, 12
    582                  TData.Hart.Filter[port] = *pointer++;  //Get the filter
   \                     ??GetHartFilter_0:
   \   00000008   01F8               MOVW    R31:R30, R17:R16
   \   0000000A   9131               LD      R19, Z+
   \   0000000C   018F               MOVW    R17:R16, R31:R30
   \   0000000E   933D               ST      X+, R19
    583              }
   \   00000010   952A               DEC     R18
   \   00000012   F7D1               BRNE    ??GetHartFilter_0
    584          }
   \   00000014   01DA               MOVW    R27:R26, R21:R20
   \   00000016   9508               RET
    585          
    586          
    587          /*************************************************************************
    588          *
    589          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    590          *
    591          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    592          char CalcDSTxChecksum(My485UARTDataType *pMy485UART, unsigned short Length) {
   \                     CalcDSTxChecksum:
   \   00000000   2E1B               MOV     R1, R27
   \   00000002   2E2A               MOV     R2, R26
   \   00000004   2F59               MOV     R21, R25
   \   00000006   2E08               MOV     R0, R24
   \   00000008   01B9               MOVW    R23:R22, R19:R18
    593              unsigned char csum = 0;
   \   0000000A   E040               LDI     R20, 0
    594              for ( short cnt = 0; cnt < Length; cnt++ ) {
   \   0000000C   E080               LDI     R24, 0
   \   0000000E   E090               LDI     R25, 0
   \   00000010   2B27               OR      R18, R23
   \   00000012   F099               BREQ    ??CalcDSTxChecksum_0
    595                  csum = crc[csum ^ pMy485UART->pTxBuffer[cnt + 4]];
   \                     ??CalcDSTxChecksum_1:
   \   00000014   01F8               MOVW    R31:R30, R17:R16
   \   00000016   81A0               LD      R26, Z
   \   00000018   81B1               LDD     R27, Z+1
   \   0000001A   0FA8               ADD     R26, R24
   \   0000001C   1FB9               ADC     R27, R25
   \   0000001E   9614               ADIW    R27:R26, 4
   \   00000020   912C               LD      R18, X
   \   00000022   2742               EOR     R20, R18
   \   00000024   2FE4               MOV     R30, R20
   \   00000026   E0F0               LDI     R31, 0
   \   00000028   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000002A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000002C   ....               LDI     R19, (crc) >> 16
   \   0000002E   BF3B               OUT     0x3B, R19
   \   00000030   9146               ELPM    R20, Z
    596              }
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   1786               CP      R24, R22
   \   00000036   0797               CPC     R25, R23
   \   00000038   F368               BRCS    ??CalcDSTxChecksum_1
    597              return csum;
   \                     ??CalcDSTxChecksum_0:
   \   0000003A   2F04               MOV     R16, R20
   \   0000003C   2D80               MOV     R24, R0
   \   0000003E   2F95               MOV     R25, R21
   \   00000040   2DA2               MOV     R26, R2
   \   00000042   2DB1               MOV     R27, R1
   \   00000044   9508               RET
    598          }
    599          
    600          

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
     14      2   ANPRO10_IO_Receive
       14      2   -> ANPRO10_UnpackPacket
       14      2   -> MyAddress
       14      2   -> OS_Delay
       14      2   -> OS_GetMail1
       14      2   -> OS_GetMailTimed
     13      2   ANPRO10_UnpackPacket
       13      2   -> BuildADInt
       13      2   -> BuildEEPROMData
       13      2   -> BuildHartFilter
       13      2   -> BuildHartSetup
       13      2   -> BuildMDataHart
       13      2   -> BuildStackStatus
       13      2   -> BuildStatusData
       13      2   -> EEPROMReset
       13      2   -> GetEEPROMData
       13      2   -> My485UART_BuildTail
       13      2   -> WriteEEPROMByte
      1      2   BuildADInt
      6      2   BuildEEPROMData
        6      2   -> ReadEEPROMBuffer
      1      2   BuildHartFilter
      0      2   BuildHartSetup
      4      2   BuildMDataHart
      4      2   BuildStackStatus
        4      2   -> OS_GetStackSpace
      6      2   BuildStatusData
        6      2   -> MyAddress
      0      2   CalcDSTxChecksum
      7      2   GetEEPROMData
        7      2   -> OS_Delay
        7      2   -> OS__Gettime
        7      2   -> WriteEEPROMBuffer
      0      2   GetGotoBootloader
      0      2   GetHartFilter
      2      2   GetHartSetup
        2      2   -> WriteEEPROMByte
      0      2   GetResetEEPROM
        0      2   -> EEPROMReset
      2      2   My485UART_BuildHeader
        2      2   -> MyAddress
      4      2   My485UART_BuildTail
        4      2   -> My485UART_BuildHeader
        4      2   -> OS_Delay
        4      2   -> OS_WaitSingleEventTimed
      0      2   Usart0Handler
        0      2   -> ANPRO10_IO_Receive


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      14  ?Subroutine0
      10  ?Subroutine1
     430  ANPRO10_IO_Receive
     418  ANPRO10_UnpackPacket
     194  BuildADInt
     244  BuildEEPROMData
     190  BuildHartFilter
     172  BuildHartSetup
     186  BuildMDataHart
     396  BuildStackStatus
     556  BuildStatusData
      70  CalcDSTxChecksum
     218  GetEEPROMData
      38  GetGotoBootloader
      24  GetHartFilter
      58  GetHartSetup
       4  GetResetEEPROM
       2  LastCommand
      76  My485UART_BuildHeader
     398  My485UART_BuildTail
       2  RestartCnt
       8  Usart0Handler
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_UCSR0B
       1  _A_WDTCSR
       7  -- Other

 
     9 bytes in segment ABSOLUTE
 3 704 bytes in segment CODE
     7 bytes in segment INITTAB
     2 bytes in segment NEAR_Z
 
 3 704 bytes of CODE memory (+ 7 bytes shared)
     2 bytes of DATA memory (+ 9 bytes shared)

Errors: none
Warnings: 4
