###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       29/Dec/2022  11:10:00
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\hart active\Src\init.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW929E.tmp ("D:\S2Prog\IO\hart
#        active\Src\init.c" --cpu=m1280 -ms -o "D:\S2Prog\IO\hart
#        active\Release_debug\Obj" -D OS_LIBMODE_S -D OS_UART=-1 -lCN
#        "D:\S2Prog\IO\hart active\Release_debug\List" -y
#        --initializers_in_flash -DENABLE_BIT_DEFINITIONS -e -I
#        "D:\S2Prog\IO\hart active\INC\\" -I "D:\S2Prog\IO\hart
#        active\..\..\SHARED\INC\\" --eeprom_size 4096 --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -Ohs)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\hart active\Release_debug\List\init.lst
#    Object file  =  D:\S2Prog\IO\hart active\Release_debug\Obj\init.r90
#
###############################################################################

D:\S2Prog\IO\hart active\Src\init.c
      1          /****************************************************************************************
      2          / Init the project
      3          /
      4          ***************************************************************************************/
      5          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0x108
   \   union <unnamed> volatile __ext_io _A_PORTK
   \                     _A_PORTK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x107
   \   union <unnamed> volatile __ext_io _A_DDRK
   \                     _A_DDRK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc4
   \   union <unnamed> volatile __io _A_UBRR0
   \                     _A_UBRR0:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xc2
   \   union <unnamed> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   union <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x98
   \   union <unnamed> volatile __io _A_OCR3A
   \                     _A_OCR3A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x91
   \   union <unnamed> volatile __io _A_TCCR3B
   \                     _A_TCCR3B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x90
   \   union <unnamed> volatile __io _A_TCCR3A
   \                     _A_TCCR3A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7e
   \   union <unnamed> volatile __io _A_DIDR0
   \                     _A_DIDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7d
   \   union <unnamed> volatile __io _A_DIDR2
   \                     _A_DIDR2:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7b
   \   union <unnamed> volatile __io _A_ADCSRB
   \                     _A_ADCSRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7a
   \   union <unnamed> volatile __io _A_ADCSRA
   \                     _A_ADCSRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x75
   \   union <unnamed> volatile __io _A_XMCRB
   \                     _A_XMCRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x74
   \   union <unnamed> volatile __io _A_XMCRA
   \                     _A_XMCRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6a
   \   union <unnamed> volatile __io _A_EICRB
   \                     _A_EICRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x69
   \   union <unnamed> volatile __io _A_EICRA
   \                     _A_EICRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5f
   \   union <unnamed> volatile __io _A_SREG
   \                     _A_SREG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x55
   \   union <unnamed> volatile __io _A_MCUCR
   \                     _A_MCUCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x47
   \   union <unnamed> volatile __io _A_OCR0A
   \                     _A_OCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x44
   \   union <unnamed> volatile __io _A_TCCR0A
   \                     _A_TCCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   union <unnamed> volatile __io _A_EIMSK
   \                     _A_EIMSK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   union <unnamed> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33
   \   union <unnamed> volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   union <unnamed> volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   union <unnamed> volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d
   \   union <unnamed> volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   union <unnamed> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x28
   \   union <unnamed> volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   union <unnamed> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   union <unnamed> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   union <unnamed> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x23
   \   union <unnamed> volatile __io _A_PINB
   \                     _A_PINB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x22
   \   union <unnamed> volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21
   \   union <unnamed> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          #include "string.h"
     12          
     13          #include "hart_gpio.h"
     14          #include "hart.h"
     15          
     16          /*
     17          **===========================================================================
     18          ** Init the system according to board type
     19          **===========================================================================
     20          */

   \                                 In  segment CODE, align 2, keep-with-next
     21          void InitSystem(void) {
   \                     InitSystem:
     22              // UnitID = AN_ZBANA; //EHSMark AN_ZBHART;                   // 0x02: ZBHART
     23          
     24              UnitID  = (PINB >> 2) & 0x03;          //get the unit ID
   \   00000000   B103               IN      R16, 0x03
   \   00000002   9506               LSR     R16
   \   00000004   9506               LSR     R16
   \   00000006   7003               ANDI    R16, 0x03
   \   00000008   9300....           STS     UnitID, R16
     25              Init_CPU();                           // init all processes
   \   0000000C   ....               RCALL   Init_CPU
     26              Init_IO();
   \   0000000E   ....               RCALL   Init_IO
     27              Init_TMR();
   \   00000010   9100....           LDS     R16, UnitID
   \   00000014   2300               TST     R16
   \   00000016   F0A9               BREQ    ??InitSystem_0
   \   00000018   950A               DEC     R16
   \   0000001A   F079               BREQ    ??InitSystem_1
   \   0000001C   5002               SUBI    R16, 2
   \   0000001E   F4A9               BRNE    ??InitSystem_2
   \   00000020   E400               LDI     R16, 64
   \   00000022   9300....           STS     _A_TCCR3A, R16
   \   00000026   E009               LDI     R16, 9
   \   00000028   9300....           STS     _A_TCCR3B, R16
   \   0000002C   E007               LDI     R16, 7
   \   0000002E   E010               LDI     R17, 0
   \   00000030   9310....           STS     (_A_OCR3A + 1), R17
   \   00000034   9300....           STS     _A_OCR3A, R16
   \   00000038   C008               RJMP    ??InitSystem_2
   \                     ??InitSystem_1:
   \   0000003A   E909               LDI     R16, 153
   \   0000003C   BD04               OUT     0x24, R16
   \   0000003E   E007               LDI     R16, 7
   \   00000040   C003               RJMP    ??InitSystem_3
   \                     ??InitSystem_0:
   \   00000042   E909               LDI     R16, 153
   \   00000044   BD04               OUT     0x24, R16
   \   00000046   E003               LDI     R16, 3
   \                     ??InitSystem_3:
   \   00000048   BD07               OUT     0x27, R16
     28          #if (OS_UART != 0)
     29              Init_USART(38400);                // only 1 My485UART to TCU on ZBHART
   \                     ??InitSystem_2:
   \   0000004A   E000               LDI     R16, 0
   \   0000004C   9300....           STS     (My485UART + 2), R16
   \   00000050   9300....           STS     (My485UART + 3), R16
   \   00000054   9300....           STS     (My485UART + 4), R16
   \   00000058   9300....           STS     (My485UART + 5), R16
   \   0000005C   9300....           STS     (My485UART + 6), R16
   \   00000060   9300....           STS     (My485UART + 7), R16
   \   00000064   9300....           STS     (My485UART + 10), R16
   \   00000068   9300....           STS     (My485UART + 11), R16
   \   0000006C   9300....           STS     (My485UART + 27), R16
   \   00000070   9300....           STS     (My485UART + 28), R16
   \   00000074   9300....           STS     (My485UART + 8), R16
   \   00000078   9300....           STS     (My485UART + 30), R16
   \   0000007C   ....               LDI     R22, LOW(MailBufCh0)
   \   0000007E   ....               LDI     R23, (MailBufCh0) >> 8
   \   00000080   E644               LDI     R20, 100
   \   00000082   E050               LDI     R21, 0
   \   00000084   E021               LDI     R18, 1
   \   00000086   ....               LDI     R16, LOW((My485UART + 12))
   \   00000088   ....               LDI     R17, HIGH((My485UART + 12))
   \   0000008A   ........           CALL    OS_CreateMB
   \   0000008E   ....               LDI     R16, LOW(TxBufferCh0)
   \   00000090   ....               LDI     R17, (TxBufferCh0) >> 8
   \   00000092   9300....           STS     My485UART, R16
   \   00000096   9310....           STS     (My485UART + 1), R17
   \   0000009A   ....               LDI     R16, LOW(RxBufferCh0)
   \   0000009C   ....               LDI     R17, (RxBufferCh0) >> 8
   \   0000009E   9300....           STS     (My485UART + 23), R16
   \   000000A2   9310....           STS     (My485UART + 24), R17
   \   000000A6   E000               LDI     R16, 0
   \   000000A8   9300....           STS     _A_UCSR0A, R16
   \   000000AC   E109               LDI     R16, 25
   \   000000AE   9300....           STS     _A_UBRR0, R16
   \   000000B2   E000               LDI     R16, 0
   \   000000B4   930000C5           STS     197, R16
   \   000000B8   E908               LDI     R16, 152
   \   000000BA   9300....           STS     _A_UCSR0B, R16
   \   000000BE   E006               LDI     R16, 6
   \   000000C0   9300....           STS     _A_UCSR0C, R16
     30          #endif
     31              //Init_AD();
     32              Init_Values();                        // init the values in the system
     33          
     34              //ADCSRA |= 0x40 ;                    //start the AD convertion
     35          }
   \   000000C4   9508               RET
   \   000000C6                      REQUIRE _A_PINB
   \   000000C6                      REQUIRE _A_UCSR0A
   \   000000C6                      REQUIRE _A_UBRR0
   \   000000C6                      REQUIRE _A_UCSR0B
   \   000000C6                      REQUIRE _A_UCSR0C
   \   000000C6                      REQUIRE _A_TCCR0A
   \   000000C6                      REQUIRE _A_OCR0A
   \   000000C6                      REQUIRE _A_TCCR3A
   \   000000C6                      REQUIRE _A_TCCR3B
   \   000000C6                      REQUIRE _A_OCR3A
     36          
     37          /*
     38          **===========================================================================
     39          ** Init the CPU related registers
     40          **===========================================================================
     41          */

   \                                 In  segment CODE, align 2, keep-with-next
     42          void Init_CPU(void) {
   \                     Init_CPU:
     43          
     44              __disable_interrupt();
   \   00000000   94F8               CLI
     45          
     46              MCUCR = 0x00;        // MCU control register wait state
   \   00000002   E000               LDI     R16, 0
   \   00000004   BF05               OUT     0x35, R16
     47              EIMSK = 0x00;        // External interrupt mask register , all off
   \   00000006   BB0D               OUT     0x1D, R16
     48              EICRA = 0xAA;        // External interrupt control register, o on faling edge
   \   00000008   EA0A               LDI     R16, 170
   \   0000000A   9300....           STS     _A_EICRA, R16
     49              EICRB = 0xAA;        // External interrupt control register
   \   0000000E   9300....           STS     _A_EICRB, R16
     50              EIMSK = 0x01;        // External interrupt mask register, int 0 on
   \   00000012   E001               LDI     R16, 1
   \   00000014   BB0D               OUT     0x1D, R16
     51          
     52              XMCRA = 0x00;        // maximum wait states
   \   00000016   E000               LDI     R16, 0
   \   00000018   9300....           STS     _A_XMCRA, R16
     53              XMCRB = 0x07;        // Full portC + bus keeper
   \   0000001C   E007               LDI     R16, 7
   \   0000001E   9300....           STS     _A_XMCRB, R16
     54              SREG  = 0x80;        // global interrupt
   \   00000022   E800               LDI     R16, 128
   \   00000024   BF0F               OUT     0x3F, R16
     55              //XDIV  = 0x00 ;      // Init valuse used 0x00v XXX
     56          
     57              RestartStatus = MCUCR;       // Remember reset source
   \   00000026   B705               IN      R16, 0x35
   \   00000028   9300....           STS     RestartStatus, R16
     58              MCUCR = 0x00;              // and reset
   \   0000002C   E000               LDI     R16, 0
   \   0000002E   BF05               OUT     0x35, R16
     59          
     60              /*--- Initialize buffer ---*/
     61              WriteCount = 0;
   \   00000030   9300....           STS     WriteCount, R16
     62          }
   \   00000034   9508               RET
   \   00000036                      REQUIRE _A_MCUCR
   \   00000036                      REQUIRE _A_EIMSK
   \   00000036                      REQUIRE _A_EICRA
   \   00000036                      REQUIRE _A_EICRB
   \   00000036                      REQUIRE _A_XMCRA
   \   00000036                      REQUIRE _A_XMCRB
   \   00000036                      REQUIRE _A_SREG
     63          
     64          /*
     65          **===========================================================================
     66          ** Init the watchdog registers
     67          **===========================================================================
     68          */

   \                                 In  segment CODE, align 2, keep-with-next
     69          __monitor void Init_Watchdog(void) {
   \                     Init_Watchdog:
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002   94F8               CLI
     70          
     71              asm("WDR");                             // kick the dog!!
   \   00000004   95A8               WDR
     72              WDTCSR = 0x0f;
   \   00000006   E00F               LDI     R16, 15
   \   00000008   9300....           STS     _A_WDTCSR, R16
     73              asm("WDR");                             // kick the dog!!
   \   0000000C   95A8               WDR
     74          
     75          }
   \   0000000E   BF1F               OUT     0x3F, R17
   \   00000010   9508               RET
   \   00000012                      REQUIRE _A_WDTCSR
     76          
     77          /*
     78          **===========================================================================
     79          ** Init the IO related registers
     80          **===========================================================================
     81          */
     82          

   \                                 In  segment CODE, align 2, keep-with-next
     83          void Init_IO(void) {
   \                     Init_IO:
     84              /*--- Initialize the data registers, output value and input pullup ---*/
     85              switch ( UnitID ) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   2300               TST     R16
   \   00000006   F029               BREQ    ??Init_IO_0
   \   00000008   950A               DEC     R16
   \   0000000A   F0E9               BREQ    ??Init_IO_1
   \   0000000C   5002               SUBI    R16, 2
   \   0000000E   F1A9               BREQ    ??Init_IO_2
   \   00000010   9508               RET
     86              case AN_ZB485:                  // AN-ZB485
     87                  DDRA   =  0xff;      // Port A data direction (out), external bus
   \                     ??Init_IO_0:
   \   00000012   EF0F               LDI     R16, 255
   \   00000014   B901               OUT     0x01, R16
     88                  PORTA  =  0x00;      // Port A data
   \   00000016   E000               LDI     R16, 0
   \   00000018   B902               OUT     0x02, R16
     89                  DDRB   =  0x10;      // Port B data direction, bit 0, 4-7 out
   \   0000001A   E100               LDI     R16, 16
   \   0000001C   B904               OUT     0x04, R16
     90                  PORTB  =  0x00;      // Port B data
   \   0000001E   E000               LDI     R16, 0
   \   00000020   B905               OUT     0x05, R16
     91                  DDRC   =  0xff;      // Port C data direction, all out
   \   00000022   EF0F               LDI     R16, 255
   \   00000024   B907               OUT     0x07, R16
     92                  PORTC  =  0x00;      // Port C data
   \   00000026   E000               LDI     R16, 0
   \   00000028   B908               OUT     0x08, R16
     93                  DDRD   =  0x00;      // Port D data direction, all in except output to osc and txd
   \   0000002A   B90A               OUT     0x0A, R16
     94                  PORTD  =  0xff;      // Port D data pullup on int fro AD
   \   0000002C   EF0F               LDI     R16, 255
   \   0000002E   B90B               OUT     0x0B, R16
     95                  DDRE   =  0xFE;      // Port E data direction, all out except rxd
   \   00000030   EF0E               LDI     R16, 254
   \   00000032   B90D               OUT     0x0D, R16
     96                  PORTE  =  0xf0;      // Port E data
   \   00000034   EF00               LDI     R16, 240
   \   00000036   B90E               OUT     0x0E, R16
     97                  DDRF   =  0x00;      // Port F data direction, used for ADC
   \   00000038   E000               LDI     R16, 0
   \   0000003A   BB00               OUT     0x10, R16
     98                  PORTF  =  0x00;      // Port F data
   \   0000003C   BB01               OUT     0x11, R16
     99                  DDRG   =  0x07;      // Port G data direction, port 1,2,3 out
   \   0000003E   E007               LDI     R16, 7
   \   00000040   BB03               OUT     0x13, R16
    100                  PORTG  =  0x03;      // Port G data
   \   00000042   E003               LDI     R16, 3
   \   00000044   C018               RJMP    ??Init_IO_3
    101                  break;
    102          
    103              case AN_ZBANA:                  // AN-ZBANA
    104                  DDRA   =  0x00;      // Port A data direction in (not used)
   \                     ??Init_IO_1:
   \   00000046   E000               LDI     R16, 0
   \   00000048   B901               OUT     0x01, R16
    105                  PORTA  =  0x00;      // Port A data
   \   0000004A   B902               OUT     0x02, R16
    106                  DDRB   =  0xF1;      // Port B data direction, bit 0, 4-7 out
   \   0000004C   EF01               LDI     R16, 241
   \   0000004E   B904               OUT     0x04, R16
    107                  PORTB  =  0x00;      // Port B data
   \   00000050   E000               LDI     R16, 0
   \   00000052   B905               OUT     0x05, R16
    108                  DDRC   =  0xFF;      // Port C data direction, all out
   \   00000054   EF0F               LDI     R16, 255
   \   00000056   B907               OUT     0x07, R16
    109                  PORTC  =  0x00;      // Port C data
   \   00000058   E000               LDI     R16, 0
   \   0000005A   B908               OUT     0x08, R16
    110                  DDRD   =  0x02;      // Port D data direction, all in except output to osc and txd
   \   0000005C   E002               LDI     R16, 2
   \   0000005E   B90A               OUT     0x0A, R16
    111                  PORTD  =  0xf1;      // Port D data pullup on int fro AD
   \   00000060   EF01               LDI     R16, 241
   \   00000062   B90B               OUT     0x0B, R16
    112                  DDRE   =  0xFE;      // Port E data direction, all out except rxd
   \   00000064   EF0E               LDI     R16, 254
   \   00000066   B90D               OUT     0x0D, R16
    113                  PORTE  =  0x00;      // Port E data
   \   00000068   E000               LDI     R16, 0
   \   0000006A   B90E               OUT     0x0E, R16
    114                  DDRF   =  0x00;      // Port F data direction, used for ADC
   \   0000006C   BB00               OUT     0x10, R16
    115                  PORTF  =  0x00;      // Port F data
   \   0000006E   BB01               OUT     0x11, R16
    116                  DDRG   =  0x10;      // Port G data direction, bit 5 out
   \   00000070   E100               LDI     R16, 16
   \   00000072   BB03               OUT     0x13, R16
    117                  PORTG  =  0x00;      // Port G data
   \   00000074   E000               LDI     R16, 0
   \                     ??Init_IO_3:
   \   00000076   BB04               OUT     0x14, R16
    118                  break;
   \   00000078   9508               RET
    119          
    120              case AN_ZBHART:
    121                  DDRF      =  0x00;      // Port F data direction, used for ADC
   \                     ??Init_IO_2:
   \   0000007A   E000               LDI     R16, 0
   \   0000007C   BB00               OUT     0x10, R16
    122                  PORTF     =  0x00;      // Port F data
   \   0000007E   BB01               OUT     0x11, R16
    123                  // Port K initialization
    124                  // Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In 
    125                  DDRK=(0<<DDK7) | (0<<DDK6) | (1<<DDK5) | (1<<DDK4) | (0<<DDK3) | (0<<DDK2) | (1<<DDK1) | (1<<DDK0);
   \   00000080   E303               LDI     R16, 51
   \   00000082   9300....           STS     _A_DDRK, R16
    126                  // State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T Pullup
    127                  PORTK=(1<<PORTK7) | (0<<PORTK6) | (0<<PORTK5) | (0<<PORTK4) | (1<<PORTK3) | (1<<PORTK2) | (0<<PORTK1) | (0<<PORTK0);
   \   00000086   E80C               LDI     R16, 140
   \   00000088   9300....           STS     _A_PORTK, R16
    128                  // ADC initialization
    129                  // ADC Clock frequency: 125,000 kHz
    130                  // ADC Voltage Reference: AVCC pin
    131                  // ADC Auto Trigger Source: ADC Stopped
    132                  // Digital input buffers on ADC0: On, ADC1: On, ADC2: On, ADC3: On
    133                  // ADC4: On, ADC5: On, ADC6: On, ADC7: On
    134                  DIDR0=(0<<ADC7D) | (0<<ADC6D) | (0<<ADC5D) | (0<<ADC4D) | (0<<ADC3D) | (0<<ADC2D) | (0<<ADC1D) | (0<<ADC0D);
   \   0000008C   E000               LDI     R16, 0
   \   0000008E   9300....           STS     _A_DIDR0, R16
    135                  // Digital input buffers on ADC8: On, ADC9: On, ADC10: On, ADC11: On
    136                  // ADC12: On, ADC13: On, ADC14: Off, ADC15: On
    137                  DIDR2=(0<<ADC15D) | (1<<ADC14D) | (0<<ADC13D) | (0<<ADC12D) | (0<<ADC11D) | (0<<ADC10D) | (0<<ADC9D) | (0<<ADC8D);
   \   00000092   E400               LDI     R16, 64
   \   00000094   9300....           STS     _A_DIDR2, R16
    138                  //ADMUX=ADC_VREF_TYPE;
    139                  ADCSRA=(1<<ADEN) | (0<<ADSC) | (0<<ADATE) | (0<<ADIF) | (0<<ADIE) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
   \   00000098   E807               LDI     R16, 135
   \   0000009A   9300....           STS     _A_ADCSRA, R16
    140                  ADCSRB=(0<<MUX5) | (0<<ADTS2) | (0<<ADTS1) | (0<<ADTS0);
   \   0000009E   E000               LDI     R16, 0
   \   000000A0   9300....           STS     _A_ADCSRB, R16
    141                  hart_gpio_init();
   \   000000A4   ........           JMP     hart_gpio_init
   \   000000A8                      REQUIRE _A_DDRA
   \   000000A8                      REQUIRE _A_PORTA
   \   000000A8                      REQUIRE _A_DDRB
   \   000000A8                      REQUIRE _A_PORTB
   \   000000A8                      REQUIRE _A_DDRC
   \   000000A8                      REQUIRE _A_PORTC
   \   000000A8                      REQUIRE _A_DDRD
   \   000000A8                      REQUIRE _A_PORTD
   \   000000A8                      REQUIRE _A_DDRE
   \   000000A8                      REQUIRE _A_PORTE
   \   000000A8                      REQUIRE _A_DDRF
   \   000000A8                      REQUIRE _A_PORTF
   \   000000A8                      REQUIRE _A_DDRG
   \   000000A8                      REQUIRE _A_PORTG
   \   000000A8                      REQUIRE _A_DDRK
   \   000000A8                      REQUIRE _A_PORTK
   \   000000A8                      REQUIRE _A_DIDR0
   \   000000A8                      REQUIRE _A_DIDR2
   \   000000A8                      REQUIRE _A_ADCSRA
   \   000000A8                      REQUIRE _A_ADCSRB
    142                  break;
    143          
    144              default:
    145                  break;
    146              }
    147          }
    148          
    149          /*
    150          **===========================================================================
    151          ** Init the timer related registers
    152          **===========================================================================
    153          */

   \                                 In  segment CODE, align 2, keep-with-next
    154          void Init_TMR(void) {
   \                     Init_TMR:
    155              /*--- Timer control (disable clock inputs) ---*/
    156          
    157              switch ( UnitID ) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   2300               TST     R16
   \   00000006   F029               BREQ    ??Init_TMR_0
   \   00000008   950A               DEC     R16
   \   0000000A   F039               BREQ    ??Init_TMR_1
   \   0000000C   5002               SUBI    R16, 2
   \   0000000E   F051               BREQ    ??Init_TMR_2
   \   00000010   9508               RET
    158              case AN_ZB485:                  // AN-ZB485
    159                  TCCR0A  =  0x99;             // Timer control register 0
   \                     ??Init_TMR_0:
   \   00000012   E909               LDI     R16, 153
   \   00000014   BD04               OUT     0x24, R16
    160                  OCR0A   =  3;                 // Timer output compare register 0, 2MHZ //16MHz xtal
   \   00000016   E003               LDI     R16, 3
   \   00000018   C003               RJMP    ??Init_TMR_3
    161                  break;
    162          
    163              case AN_ZBANA:                  // AN-ZBANA
    164                  TCCR0A  =  0x99;             // Timer control register 0
   \                     ??Init_TMR_1:
   \   0000001A   E909               LDI     R16, 153
   \   0000001C   BD04               OUT     0x24, R16
    165                  OCR0A    =  7;               // Timer output compare register 0, 1MHZ //16MHz xtal
   \   0000001E   E007               LDI     R16, 7
   \                     ??Init_TMR_3:
   \   00000020   BD07               OUT     0x27, R16
    166                  break;
   \   00000022   9508               RET
    167          
    168              case AN_ZBHART:
    169                  //TCCR0A  =  0x99;             // Timer control register 0
    170                  //OCR0A    =  7;               // Timer output compare register 0, 1MHZ //16MHz xtal
    171                  //
    172                  // to provide ADC with 1 Mhz clock, OC3A (PE3) is connected to ADC clock
    173                  //
    174                  // we will use TC3 to generate 1 Mhz clock by setting
    175                  //
    176                  // 1) TCCR3A    : 01000000   = 0x40
    177                  //    a) Bit 7:6,     COM3A1/COM3A0   :   01  - Toggle OC3A(PE3) on compare match
    178                  //    b) Bit 5:2,     don't care. all zero
    179                  //    c) Bit 1:0,     WGM31/WGM30     :   00 for CTC mode
    180                  //
    181                  // 2) TCCR3B    : 00001001 = 0x09
    182                  //    a) Bit 7,       noise canceler. don't care. 0
    183                  //    b) Bit 6,       edge select for input. don't care. 0
    184                  //    c) Bit 5,       reserved, 0
    185                  //    d) Bit 4:3,     WGM33/WGM32     : 01 for CTC mode with OCR3A as TOP
    186                  //    e) Bit 2:0,     CS32/CS31/CS30  : Clock Select, 001 : 16 Mhz with no divider
    187                  //
    188                  // 3) OCR3A     : 7, compare match at 8 tick at 16 Mhz will generate 1 MHz Clock
    189                  //
    190                  //
    191                  TCCR3A    = 0x40;
   \                     ??Init_TMR_2:
   \   00000024   E400               LDI     R16, 64
   \   00000026   9300....           STS     _A_TCCR3A, R16
    192                  TCCR3B    = 0x09;
   \   0000002A   E009               LDI     R16, 9
   \   0000002C   9300....           STS     _A_TCCR3B, R16
    193                  OCR3A     = 7;
   \   00000030   E007               LDI     R16, 7
   \   00000032   E010               LDI     R17, 0
   \   00000034   9310....           STS     (_A_OCR3A + 1), R17
   \   00000038   9300....           STS     _A_OCR3A, R16
    194                  break;
    195          
    196              default:
    197                  break;
    198              }
    199          }
   \   0000003C   9508               RET
   \   0000003E                      REQUIRE _A_TCCR0A
   \   0000003E                      REQUIRE _A_OCR0A
   \   0000003E                      REQUIRE _A_TCCR3A
   \   0000003E                      REQUIRE _A_TCCR3B
   \   0000003E                      REQUIRE _A_OCR3A
    200          
    201          /*
    202          **===========================================================================
    203          ** Init the USARTs registers
    204          **===========================================================================
    205          */

   \                                 In  segment CODE, align 2, keep-with-next
    206          void Init_USART(unsigned long baud) {
   \                     Init_USART:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008   01C8               MOVW    R25:R24, R17:R16
   \   0000000A   01D9               MOVW    R27:R26, R19:R18
    207          
    208          
    209              /*--- Configure My485UART data block ---*/
    210              My485UART.TxFirst   	    = 0x00;
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   9300....           STS     (My485UART + 2), R16
   \   00000012   9300....           STS     (My485UART + 3), R16
    211              My485UART.TxLast    	    = 0x00;
   \   00000016   9300....           STS     (My485UART + 4), R16
   \   0000001A   9300....           STS     (My485UART + 5), R16
    212              My485UART.TxCount   	    = 0x00;
   \   0000001E   9300....           STS     (My485UART + 6), R16
   \   00000022   9300....           STS     (My485UART + 7), R16
    213              My485UART.TxId        	    = 0x00;
   \   00000026   9300....           STS     (My485UART + 10), R16
    214              My485UART.TxAddress   	    = 0x00;
   \   0000002A   9300....           STS     (My485UART + 11), R16
    215              My485UART.RxCount   	    = 0x00;
   \   0000002E   9300....           STS     (My485UART + 27), R16
   \   00000032   9300....           STS     (My485UART + 28), R16
    216              My485UART.TxStatus  	    = 0x00;
   \   00000036   9300....           STS     (My485UART + 8), R16
    217              My485UART.SequenceNumber    = 0x00;
   \   0000003A   9300....           STS     (My485UART + 30), R16
    218          
    219          
    220              OS_CreateMB(&My485UART.RxMailBox, 1, MBUF_SIZE, MailBufCh0);
   \   0000003E   ....               LDI     R22, LOW(MailBufCh0)
   \   00000040   ....               LDI     R23, (MailBufCh0) >> 8
   \   00000042   E644               LDI     R20, 100
   \   00000044   E050               LDI     R21, 0
   \   00000046   E021               LDI     R18, 1
   \   00000048   ....               LDI     R16, LOW((My485UART + 12))
   \   0000004A   ....               LDI     R17, HIGH((My485UART + 12))
   \   0000004C   ........           CALL    OS_CreateMB
    221              My485UART.pTxBuffer = TxBufferCh0;
   \   00000050   ....               LDI     R16, LOW(TxBufferCh0)
   \   00000052   ....               LDI     R17, (TxBufferCh0) >> 8
   \   00000054   9300....           STS     My485UART, R16
   \   00000058   9310....           STS     (My485UART + 1), R17
    222              My485UART.pRxBuffer = RxBufferCh0;
   \   0000005C   ....               LDI     R16, LOW(RxBufferCh0)
   \   0000005E   ....               LDI     R17, (RxBufferCh0) >> 8
   \   00000060   9300....           STS     (My485UART + 23), R16
   \   00000064   9310....           STS     (My485UART + 24), R17
    223              UCSR0A  = 0x00;
   \   00000068   E000               LDI     R16, 0
   \   0000006A   9300....           STS     _A_UCSR0A, R16
    224              UBRR0L  = ((XTAL_CPU / 16 / baud) - 1) & 0xff;
   \   0000006E   E400               LDI     R16, 64
   \   00000070   E412               LDI     R17, 66
   \   00000072   E02F               LDI     R18, 15
   \   00000074   E030               LDI     R19, 0
   \   00000076   01AC               MOVW    R21:R20, R25:R24
   \   00000078   01BD               MOVW    R23:R22, R27:R26
   \   0000007A   ........           CALL    ?UL_DIVMOD_S_L03
   \   0000007E   2F40               MOV     R20, R16
   \   00000080   954A               DEC     R20
   \   00000082   9340....           STS     _A_UBRR0, R20
    225              UBRR0H  = (((XTAL_CPU / 16 / baud) - 1) >> 8) & 0xff;
   \   00000086   5001               SUBI    R16, 1
   \   00000088   4010               SBCI    R17, 0
   \   0000008A   931000C5           STS     197, R17
    226              // why the fuck do you enalbe UDRE here you stupid fucktard!!! -hkim-
    227              //UCSR0B  = 0xb8;                                       /* tx/ rx enable, int udre/rxon */
    228              UCSR0B  = 0x98;                                       /* tx/ rx enable, int udre/rxon */
   \   0000008E   E908               LDI     R16, 152
   \   00000090   9300....           STS     _A_UCSR0B, R16
    229              UCSR0C  = 0x06;                                       /* n,8,1 */
   \   00000094   E006               LDI     R16, 6
   \   00000096   9300....           STS     _A_UCSR0C, R16
    230          }
   \   0000009A   9189               LD      R24, Y+
   \   0000009C   9199               LD      R25, Y+
   \   0000009E   91A9               LD      R26, Y+
   \   000000A0   91B9               LD      R27, Y+
   \   000000A2   9508               RET
   \   000000A4                      REQUIRE _A_UCSR0A
   \   000000A4                      REQUIRE _A_UBRR0
   \   000000A4                      REQUIRE _A_UCSR0B
   \   000000A4                      REQUIRE _A_UCSR0C
    231          
    232          
    233          /*
    234          **===========================================================================
    235          ** Init values  in the system
    236          **===========================================================================
    237          */

   \                                 In  segment CODE, align 2, keep-with-next
    238          void Init_Values(void) {
   \                     Init_Values:
    239          }
   \   00000000   9508               RET

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   InitSystem
        0      2   -> Init_CPU
        0      2   -> Init_IO
        0      2   -> OS_CreateMB
      0      2   Init_CPU
      0      2   Init_IO
        0      2   -> hart_gpio_init
      0      2   Init_TMR
      4      2   Init_USART
        4      2   -> OS_CreateMB
        4      2 ?UL_DIVMOD_S_L03
      0      2   Init_Values
      0      2   Init_Watchdog


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     198  InitSystem
      54  Init_CPU
     168  Init_IO
      62  Init_TMR
     164  Init_USART
       2  Init_Values
      18  Init_Watchdog
       1  _A_ADCSRA
       1  _A_ADCSRB
       1  _A_DDRA
       1  _A_DDRB
       1  _A_DDRC
       1  _A_DDRD
       1  _A_DDRE
       1  _A_DDRF
       1  _A_DDRG
       1  _A_DDRK
       1  _A_DIDR0
       1  _A_DIDR2
       1  _A_EICRA
       1  _A_EICRB
       1  _A_EIMSK
       1  _A_MCUCR
       1  _A_OCR0A
       2  _A_OCR3A
       1  _A_PINB
       1  _A_PORTA
       1  _A_PORTB
       1  _A_PORTC
       1  _A_PORTD
       1  _A_PORTE
       1  _A_PORTF
       1  _A_PORTG
       1  _A_PORTK
       1  _A_SREG
       1  _A_TCCR0A
       1  _A_TCCR3A
       1  _A_TCCR3B
       2  _A_UBRR0
       1  _A_UCSR0A
       1  _A_UCSR0B
       1  _A_UCSR0C
       1  _A_WDTCSR
       1  _A_XMCRA
       1  _A_XMCRB

 
  40 bytes in segment ABSOLUTE
 666 bytes in segment CODE
 
 666 bytes of CODE memory
   0 bytes of DATA memory (+ 40 bytes shared)

Errors: none
Warnings: none
