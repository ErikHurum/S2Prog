###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       02/Oct/2023  15:18:53
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\eeprom.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWCFDF.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\eeprom.c"
#        --cpu=m1280 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\Obj" -D
#        OS_LIBMODE_D -D OS_UART=-1 -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\List" -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\INC\\" -I
#        ..\..\..\Shared\Inc\\ --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\List\eeprom.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\Obj\eeprom.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\eeprom.c
      1          /****************************************************************************************
      2          / Read and write the eeprom
      3          /
      4          ***************************************************************************************/
      5          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          
     12          
     13          /*---------------------------------------------------------------------------
     14          **
     15          **  See how many date i remining
     16          **
     17          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     18          char TestEEPROM( void ) {
   \                     TestEEPROM:
     19          
     20              return WriteCount;
   \   00000000   9100....           LDS     R16, WriteCount
   \   00000004   9508               RET
     21          }
     22          
     23          /*---------------------------------------------------------------------------
     24          **
     25          **  Reads an address in the eeprom
     26          **
     27          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     28          char ReadEEPROMByte( unsigned int Address ) {
   \                     ReadEEPROMByte:
   \   00000000   0198               MOVW    R19:R18, R17:R16
     29          #if 0
     30              unsigned char Data;
     31          
     32              while (EECR & (1<<EEPE))     // Wait until ready
     33                  ;
     34              EEAR = Address;
     35              OS_IncDI();
     36              EECR |= (1 << EERE) ;       // Don't use My_SetBit macrod due to timing
     37              OS_DecRI();
     38          
     39              Data = EEDR;
     40              return Data;
     41          #else
     42              return 0;
   \   00000002   E000               LDI     R16, 0
   \   00000004   9508               RET
     43          #endif
     44          }
     45          
     46          /*---------------------------------------------------------------------------
     47          **
     48          **  Write a caracther to the eeprom
     49          **
     50          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     51          void WriteEEPROMByte( unsigned int Address, char Data ) {   
   \                     WriteEEPROMByte:
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   2FA2               MOV     R26, R18
     52              while (EECR & (1<<EEPE))     // Wait until ready
   \                     ??WriteEEPROMByte_0:
   \   00000008   99F9               SBIC    0x1F, 0x01
   \   0000000A   CFFE               RJMP    ??WriteEEPROMByte_0
     53                  ;
     54              OS_IncDI();
   \   0000000C   9100....           LDS     R16, (OS_Global + 1)
   \   00000010   7F00               ANDI    R16, 0xF0
   \   00000012   2300               TST     R16
   \   00000014   F021               BREQ    ??WriteEEPROMByte_1
   \   00000016   E909               LDI     R16, 153
   \   00000018   E010               LDI     R17, 0
   \   0000001A   ........           CALL    OS_Error
   \                     ??WriteEEPROMByte_1:
   \   0000001E   94F8               cli
   \   00000020   9100....           LDS     R16, (OS_Global + 1)
   \   00000024   9503               INC     R16
   \   00000026   9300....           STS     (OS_Global + 1), R16
     55              EEAR = Address;
   \   0000002A   BD92               OUT     0x22, R25
   \   0000002C   BD81               OUT     0x21, R24
     56              EEDR = Data;
   \   0000002E   BDA0               OUT     0x20, R26
     57              EECR |= (1 << EEMPE) ;       // Don't use My_SetBit macrod due to timing
   \   00000030   9AFA               SBI     0x1F, 0x02
     58              EECR |= (1 << EEPE) ;        // Don't use My_SetBit macrod due to timing
   \   00000032   9AF9               SBI     0x1F, 0x01
     59              OS_DecRI();
   \   00000034   9100....           LDS     R16, (OS_Global + 1)
   \   00000038   7F00               ANDI    R16, 0xF0
   \   0000003A   2300               TST     R16
   \   0000003C   F021               BREQ    ??WriteEEPROMByte_2
   \   0000003E   E909               LDI     R16, 153
   \   00000040   E010               LDI     R17, 0
   \   00000042   ........           CALL    OS_Error
   \                     ??WriteEEPROMByte_2:
   \   00000046   9100....           LDS     R16, (OS_Global + 1)
   \   0000004A   950A               DEC     R16
   \   0000004C   9300....           STS     (OS_Global + 1), R16
   \   00000050   9100....           LDS     R16, (OS_Global + 1)
   \   00000054   2300               TST     R16
   \   00000056   F409               BRNE    ??WriteEEPROMByte_3
   \   00000058   9478               sei
     60          }
   \                     ??WriteEEPROMByte_3:
   \   0000005A   E0E3               LDI     R30, 3
   \   0000005C   ........           JMP     ?EPILOGUE_B3_L09
   \   00000060                      REQUIRE _A_EECR
   \   00000060                      REQUIRE _A_EEAR
   \   00000060                      REQUIRE _A_EEDR
     61          
     62          /*---------------------------------------------------------------------------
     63          **
     64          **  Read a tring from the eeprom
     65          **
     66          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     67          void ReadEEPROMBuffer( unsigned int Address, char Size, char *pData ) {   
   \                     ReadEEPROMBuffer:
   \   00000000   2F79               MOV     R23, R25
   \   00000002   2E28               MOV     R2, R24
   \   00000004   0108               MOVW    R1:R0, R17:R16
   \   00000006   2F62               MOV     R22, R18
     68              unsigned int Index;
     69          
     70              for ( Index = 0; Index < Size; Index++ ) {
   \   00000008   E080               LDI     R24, 0
   \   0000000A   E090               LDI     R25, 0
   \                     ??ReadEEPROMBuffer_0:
   \   0000000C   2F06               MOV     R16, R22
   \   0000000E   E010               LDI     R17, 0
   \   00000010   1780               CP      R24, R16
   \   00000012   0791               CPC     R25, R17
   \   00000014   F450               BRCC    ??ReadEEPROMBuffer_1
     71                  *pData++ = ReadEEPROMByte( Address + Index );
   \   00000016   0180               MOVW    R17:R16, R1:R0
   \   00000018   0F08               ADD     R16, R24
   \   0000001A   1F19               ADC     R17, R25
   \   0000001C   ....               RCALL   ReadEEPROMByte
   \   0000001E   01FA               MOVW    R31:R30, R21:R20
   \   00000020   8300               ST      Z, R16
   \   00000022   5F4F               SUBI    R20, 255
   \   00000024   4F5F               SBCI    R21, 255
     72              }
   \   00000026   9601               ADIW    R25:R24, 1
   \   00000028   CFF1               RJMP    ??ReadEEPROMBuffer_0
     73          }
   \                     ??ReadEEPROMBuffer_1:
   \   0000002A   2D82               MOV     R24, R2
   \   0000002C   2F97               MOV     R25, R23
   \   0000002E   9508               RET
     74          
     75          /*---------------------------------------------------------------------------
     76          **
     77          **  Writ buffer to eeprom
     78          **
     79          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     80          void WriteEEPROMBuffer( unsigned int Address, char Size, char *pData ) {   
   \                     WriteEEPROMBuffer:
     81          #if 0
     82              while (EECR & (1<<EEPE))     // Wait until ready
     83                  ;
     84              OS_IncDI();
     85              pWriteBuffer = pData;
     86              WriteCount = Size;
     87              EEAR = Address ;
     88              EEDR = *pData ;
     89              pWriteBuffer++;
     90              EEPWriteOK = false;
     91              EECR |= (1 << EEMPE) ;       // Don't use My_SetBit macrod due to timing
     92              EECR |= (1 << EEPE) ;        // Don't use My_SetBit macrod due to timing
     93              EECR |= (1 << EERIE) ;       // Don't use My_SetBit macrod due to timing
     94              OS_DecRI();
     95          #endif
     96          }
   \   00000000   9508               RET
     97          
     98          /*---------------------------------------------------------------------------
     99          **
    100          **  Interrupt on EEPROM write
    101          **
    102          **--------------------------------------------------------------------------*/
    103          

   \                                 In  segment CODE, align 2, keep-with-next
    104          void INT_Handler_EEPROM(void) {
   \                     INT_Handler_EEPROM:
   \   00000000   019D               MOVW    R19:R18, R27:R26
    105              if ( --WriteCount ) {                        // More to write? 
   \   00000002   9100....           LDS     R16, WriteCount
   \   00000006   950A               DEC     R16
   \   00000008   9300....           STS     WriteCount, R16
   \   0000000C   9100....           LDS     R16, WriteCount
   \   00000010   2300               TST     R16
   \   00000012   F0C1               BREQ    ??INT_Handler_EEPROM_0
    106                  EEAR++;                                  // Define address and data 
   \   00000014   B501               IN      R16, 0x21
   \   00000016   B512               IN      R17, 0x22
   \   00000018   5F0F               SUBI    R16, 255
   \   0000001A   4F1F               SBCI    R17, 255
   \   0000001C   BD12               OUT     0x22, R17
   \   0000001E   BD01               OUT     0x21, R16
    107                  EEDR = *pWriteBuffer++;
   \   00000020   ....               LDI     R26, LOW(pWriteBuffer)
   \   00000022   ....               LDI     R27, (pWriteBuffer) >> 8
   \   00000024   91ED               LD      R30, X+
   \   00000026   91FC               LD      R31, X
   \   00000028   9711               SBIW    R27:R26, 1
   \   0000002A   8100               LD      R16, Z
   \   0000002C   BD00               OUT     0x20, R16
   \   0000002E   ....               LDI     R30, LOW(pWriteBuffer)
   \   00000030   ....               LDI     R31, (pWriteBuffer) >> 8
   \   00000032   8100               LD      R16, Z
   \   00000034   8111               LDD     R17, Z+1
   \   00000036   5F0F               SUBI    R16, 255
   \   00000038   4F1F               SBCI    R17, 255
   \   0000003A   8300               ST      Z, R16
   \   0000003C   8311               STD     Z+1, R17
    108                  EECR |= (1 << EEMPE) ;       // Don't use My_SetBit macrod due to timing
   \   0000003E   9AFA               SBI     0x1F, 0x02
    109                  EECR |= (1 << EEPE) ;        // Don't use My_SetBit macrod due to timing
   \   00000040   9AF9               SBI     0x1F, 0x01
   \   00000042   C004               RJMP    ??INT_Handler_EEPROM_1
    110              } else {
    111                  EECR &= ~(1 << EERIE) ;       // Don't use My_ClrBit macrod due to timing
   \                     ??INT_Handler_EEPROM_0:
   \   00000044   98FB               CBI     0x1F, 0x03
    112                  EEPWriteOK = true;
   \   00000046   E001               LDI     R16, 1
   \   00000048   9300....           STS     EEPWriteOK, R16
    113              }
    114          
    115          }
   \                     ??INT_Handler_EEPROM_1:
   \   0000004C   01D9               MOVW    R27:R26, R19:R18
   \   0000004E   9508               RET
   \   00000050                      REQUIRE _A_EEAR
   \   00000050                      REQUIRE _A_EEDR
   \   00000050                      REQUIRE _A_EECR
    116          
    117          #pragma vector=EE_READY_vect

   \                                 In  segment CODE, align 2, keep-with-next
    118          __interrupt void IntHandler_EEPROM( void ){
   \                     IntHandler_EEPROM:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    119              OS_CallISR(INT_Handler_EEPROM);
   \   00000024   ....               LDI     R16, LOW(INT_Handler_EEPROM/2)
   \   00000026   ....               LDI     R17, (INT_Handler_EEPROM/2) >> 8
   \   00000028   ........           CALL    OS_CallISR_Debug
    120          }
   \   0000002C   BF9B               OUT     0x3B, R25
   \   0000002E   BF8F               OUT     0x3F, R24
   \   00000030   9109               LD      R16, Y+
   \   00000032   9119               LD      R17, Y+
   \   00000034   9129               LD      R18, Y+
   \   00000036   9139               LD      R19, Y+
   \   00000038   9149               LD      R20, Y+
   \   0000003A   9159               LD      R21, Y+
   \   0000003C   9169               LD      R22, Y+
   \   0000003E   9179               LD      R23, Y+
   \   00000040   9009               LD      R0, Y+
   \   00000042   9019               LD      R1, Y+
   \   00000044   9029               LD      R2, Y+
   \   00000046   9039               LD      R3, Y+
   \   00000048   91E9               LD      R30, Y+
   \   0000004A   91F9               LD      R31, Y+
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9518               RETI
    121          
    122          
    123          /**===========================================================================
    124          ** Get the stored version in EEPROM
    125          **==========================================================================*/ 

   \                                 In  segment CODE, align 2, keep-with-next
    126          char EEPROMVersion(void) {
   \                     EEPROMVersion:
    127          #if 0
    128              char val ;
    129              char retval = false;
    130          
    131              ReadEEPROMBuffer(EEPROM_ID_START, 1, (char*)&val) ;
    132              if (val == EEPROM_ID) {                                     //correct EEPROM ID
    133                  ReadEEPROMBuffer(EEPROM_ID_START+1, 1, (char*)&val) ;
    134                  if (val == STORE_VERSION) {                             // and version
    135                      ReadEEPROMBuffer(0xffe, 1, (char*)&val) ;
    136                      if (val == EEPROM_OK) {                             // and no reset from user
    137                          retval = true ;                                 // then everything is OK
    138                      }
    139                  }
    140              }
    141              return retval;
    142          #else
    143              return 0;
   \   00000000   E000               LDI     R16, 0
   \   00000002   9508               RET
    144          #endif
    145          }
    146          
    147          /**===========================================================================
    148          ** Reset the EEPROM
    149          **==========================================================================*/ 

   \                                 In  segment CODE, align 2, keep-with-next
    150          void EEPROMReset(void) {
   \                     EEPROMReset:
    151          #if 0
    152              EEARL = (0x0ffe & 0xff);
    153              EEARH = (0x0ffe >> 8);
    154              EEDR = EEPROM_RESET;
    155              EECR |= (1<<EEMPE);
    156              EECR |= (1<<EEPE);
    157              while (EECR & (1<<EEPE))
    158                  ;
    159              WDTCSR = 0x18;               //Start watchdog to genetate restart
    160              WDTCSR = 0x18;
    161          #endif
    162          }
   \   00000000   9508               RET

   \                                 In  segment INTVEC, offset 0x78, root
   \                     `??IntHandler_EEPROM::??INTVEC 120`:
   \   00000078   ........           JMP     IntHandler_EEPROM

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   EEPROMReset
      0      2   EEPROMVersion
      0      2   INT_Handler_EEPROM
     16      2   IntHandler_EEPROM
       16      2   -> OS_CallISR_Debug
      0      2   ReadEEPROMBuffer
        0      2   -> ReadEEPROMByte
      0      2   ReadEEPROMByte
      0      2   TestEEPROM
      0      2   WriteEEPROMBuffer
      3      2   WriteEEPROMByte
        3      2   -> OS_Error


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  EEPROMReset
       4  EEPROMVersion
      80  INT_Handler_EEPROM
      82  IntHandler_EEPROM
       4  IntHandler_EEPROM::??INTVEC 120
      48  ReadEEPROMBuffer
       6  ReadEEPROMByte
       6  TestEEPROM
       2  WriteEEPROMBuffer
      96  WriteEEPROMByte
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR

 
   4 bytes in segment ABSOLUTE
 326 bytes in segment CODE
   4 bytes in segment INTVEC
 
 326 bytes of CODE memory (+ 4 bytes shared)
   0 bytes of DATA memory (+ 4 bytes shared)

Errors: none
Warnings: none
