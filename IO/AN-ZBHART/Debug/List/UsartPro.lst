###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       15/Nov/2023  09:53:38
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\UsartPro.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW5966.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\UsartPro.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\Obj" -D
#        OS_LIBMODE_D -D OS_UART=-1 -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\List" -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\INC\\" -I
#        ..\..\..\Shared\Inc\\ --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\List\UsartPro.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\Obj\UsartPro.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\UsartPro.c
      1          /****************************************************************************************
      2          / Com protocol for USART0
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom1280.h"
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "string.h"
     10          #include "RTOS.h"
     11          #include "hart.h"
     12          #include "externals.h"
     13          #include "version.h"
     14          #include "structs.h"
     15          
     16          //__no_init int RestartCnt             @0x21FD;
     17          
     18          char hasStartedUARTTask = 0;
     19          
     20          //extern __no_init TargetData  TData;                    
     21          /*************************************************************************
     22          *   
     23          *  Handle the ANPRO10 protocol
     24          * 
     25          *  Returns 1 if a reply has been sent
     26          *
     27          *************************************************************************/
     28          static unsigned LastCommand = 0;
     29          char ANPRO10_UnpackPacket(void) {
     30              char *Buf = My485UART.pRxBuffer;
     31              const ANPRO10_PacketHeading *pPH = (ANPRO10_PacketHeading *)Buf;
     32              My485UART.RxCount++;
     33              My485UART.TxAddress   = pPH->txadr;
     34              My485UART.TxId        = pPH->txtypeid;
     35              My485UART.RxSendReply = false;                              // flag for answering set to fault
     36              My485UART.TxFirst     = 11;                                 // Start pos for first TX command
     37          
     38              Buf += sizeof(ANPRO10_PacketHeading);
     39              const char *EndPtr =  (char*)&Buf[pPH->nob];
     40              // Sanity check
     41              if ( pPH->nob >= RXSIZE_UART-5 ) {
     42                  return 0;
     43              }
     44              ANPRO10_CommandHeading *pCH;
     45              char MoreCommands = true;
     46              do {
     47                  pCH = (ANPRO10_CommandHeading *)Buf;
     48                  Buf += sizeof(ANPRO10_CommandHeading);  // ??
     49                  switch ( pCH->CommandNo ) {
     50                  case ECMD_NMDWOACK:
     51                  case ECMD_NMDRQACK:
     52                      break;
     53                  default:
     54                      LastCommand = pCH->CommandNo;
     55                      break;
     56                  }
     57                  switch ( pCH->CommandNo ) {
     58                  case CMD_REQ_STATUS :                           // Regusest status for target
     59                      BuildStatusData();                          // make package
     60                      break;
     61                  case CMD_GET_STACKSTATUS :                      // Request stck status
     62                      BuildStackStatus( Buf);
     63                      break;
     64                  case CMD_EEPROM_RESET :                         // Reset EEPROM??
     65                      GetResetEEPROM();
     66                      break;
     67                  case CMD_GOTO_BOOTLOADER :                      // Goto bootlaoder??
     68                      GetGotoBootloader(Buf);
     69                      break;
     70                  case CMD_SND_EEPROM_DATA :                      // Receive EEPROM data
     71                      GetEEPROMData(Buf);
     72                      break;
     73                  case CMD_REQ_EEPROM_DATA :                      // Request to send EEPROM data
     74                      BuildEEPROMData( Buf);
     75                      break;
     76                  case CMD_REQ_INT_DATA :                         // Request external data
     77                      BuildADInt( Buf);
     78                      break;
     79                  case CMD_SND_HART_SETUP :                       // Receive sertup of AN-RSANA
     80                      GetHartSetup(Buf, pCH->ndb);
     81                      break;
     82                  case CMD_REQ_HART_SETUP :                       // Request for sertup of AN-RSANA
     83                      BuildHartSetup( Buf);
     84                      break;
     85                  case CMD_SND_HART_FILTER :                      // Receive filter of AN-RSANA
     86                      GetHartFilter(Buf);
     87                      break;
     88                  case CMD_REQ_HART_FILTER :                      // Request filter of AN-RSANA
     89                      BuildHartFilter( Buf);
     90                      break;
     91                  case CMD_REQ_HART_DATA :                        // Request ANA data(4-20ma)
     92                      BuildMDataHart();
     93                      break;
     94          
     95                  case ECMD_NMDWOACK:
     96                  case ECMD_NMDRQACK:
     97                      MoreCommands = false;
     98                      break;
     99                  default:
    100                      break;
    101          
    102                  }
    103                  if ( MoreCommands ) {
    104                      Buf += pCH->ndb;
    105                  }
    106              } while ( MoreCommands && (Buf < EndPtr) );
    107              if ( My485UART.RxSendReply ) {                                   //send answer?
    108                  My485UART_BuildTail();                                       // yes, build tail (and header) and start sending
    109              }
    110              return (My485UART.RxSendReply);
    111          }
    112          
    113          #define MAX_TIME_BETWEEN_BYTE	15
    114          
    115          void ANPRO10_IO_Receive(void) {
    116              unsigned char *RxBuf = (unsigned char *)My485UART.pRxBuffer;
    117              const ANPRO10_PacketHeading *pPH =  (ANPRO10_PacketHeading *)RxBuf;
    118              char Data;
    119              char dataAvailable = 1;
    120              int  SyncCnt       = 1;     // Initialize to 1 as 1 must have been found when exiting the while loop
    121              char PacketOK      = false; // Assume the worse at the beginning
    122              // Look for ANPRO10_SYN, ignore the rest
    123              do {
    124                  OS_GetMail1(&My485UART.RxMailBox, &Data);
    125              }while ( Data != ANPRO10_SYN );
    126              // We know we have a ANPRO10_SYN
    127              // A minimum of 2 SYN to accept start
    128              //Message("First SYN");
    129              //SyncCnt = 0;
    130              do {
    131                  dataAvailable = !OS_GetMailTimed(&My485UART.RxMailBox, &Data, MAX_TIME_BETWEEN_BYTE);
    132                  if ( dataAvailable && (Data == ANPRO10_SYN) ) SyncCnt++;
    133              } while ( dataAvailable && (Data == ANPRO10_SYN) );
    134              if ( dataAvailable && SyncCnt && (Data == ANPRO10_SOH) ) {
    135                  unsigned char *RxPtr = RxBuf;
    136                  for ( unsigned i = 0; dataAvailable && i < sizeof(NetHeading); i++ ) {
    137                      dataAvailable = !OS_GetMailTimed(&My485UART.RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
    138                  }
    139                  if ( dataAvailable ) {
    140                      unsigned char HCSum = 0;
    141                      {
    142                          unsigned char *TmpRxPtr = RxBuf;
    143                          for ( unsigned i = 0; i < sizeof(ANPRO10_PacketHeading) - 1; i++ ) {
    144                              HCSum     = crc[HCSum ^ *TmpRxPtr++];
    145                          }
    146          
    147                      }
    148                      if ( HCSum == pPH->HCRC ) {
    149                          unsigned DataSize = (unsigned)pPH->nob;
    150                          // Before checked against MAX_ANPRO10_IO_SIZE which is not related to the buffer size for AN-ZBHART
    151                          if ( DataSize > 3 && DataSize < RXSIZE_UART ) { 
    152                              for ( unsigned i = 0; dataAvailable && i < DataSize - sizeof(ANPRO10_PacketHeading); i++ ) {
    153                                  dataAvailable = !OS_GetMailTimed(&My485UART.RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
    154                              }
    155                              if ( dataAvailable ) {
    156                                  RxPtr = RxBuf;
    157                                  volatile unsigned char CSum = 0;
    158          
    159                                  for ( unsigned i = 0; i < DataSize - 2; i++ ) {
    160                                      CSum     = crc[CSum ^ *RxPtr++];
    161                                  }
    162                                  unsigned char  PacketCheckSum = *((unsigned char *)&RxBuf[DataSize - 2]);
    163                                  if ( PacketCheckSum == CSum ) {
    164                                      My485UART.SequenceNumber = RxBuf[DataSize - 3];
    165                                      // U16 EndCommand = *((U16*)&ARxBuf[DataSize-6]);
    166                                      // unsigned char EndData = *((unsigned char*)&ARxBuf[DataSize-4]);
    167                                      unsigned char EOTByte = *((unsigned char *)&RxBuf[DataSize - 1]);
    168                                      if ( EOTByte == ANPRO10_EOT ) {
    169                                          switch ( pPH->txtypeid ) {
    170                                          case DEVICE_TCU :
    171                                              if ( (pPH->rxadr == MyAddress()) && (pPH->rxtypeid == (UnitID + DEVICE_IO)) ) {
    172                                                  ANPRO10_UnpackPacket();
    173                                                  PacketOK = true; // Packet accepted so signal OK!
    174                                              } else {
    175                                                  //Ignore = true;
    176                                              }
    177                                              break;
    178                                          case DEVICE_ZBHART:
    179                                              //Echo = true;
    180                                              break;
    181                                          default:
    182                                              // Ignore message
    183                                              break;
    184                                          }
    185                                      }
    186                                  }
    187                              } else {
    188                                  OS_Delay(0);
    189                              }
    190                          }
    191                      }
    192                  }
    193              }
    194              if ( !PacketOK ) {
    195                  My485UART.RxFaultCnt++;
    196              }
    197          }
    198          
    199          /*************************************************************************
    200          *   (This is a task)
    201          *  Usart0 handler
    202          *
    203          *************************************************************************/
    204          void Usart0Handler(void) {
    205              hasStartedUARTTask = 1;
    206              UCSR0B  = 1 << RXCIE0 | 1 << RXEN0 | 1 << TXEN0;  //0x98;                                       /* tx/ rx enable, int udre/rxon */
    207              while ( 1 ) {
    208                  ANPRO10_IO_Receive();
    209              }
    210          }
    211          
    212          
    213          
    214          
    215          /*************************************************************************
    216          *
    217          * Build send packet header
    218          *
    219          *************************************************************************/
    220          void My485UART_BuildHeader(void) {
    221          
    222              My485UART.TxLast  = 0;
    223              char *txBuf = My485UART.pTxBuffer;
    224          
    225              txBuf[ 0] = ANPRO10_SYN;                        /* Sync */
    226              txBuf[ 1] = ANPRO10_SYN;                        /* Sync */
    227              txBuf[ 2] = ANPRO10_SYN;                        /* Sync */
    228              txBuf[ 3] = ANPRO10_SOH;                        /* Start of header */
    229              txBuf[ 4] = My485UART.TxId;                        /* RXID */
    230              txBuf[ 5] = My485UART.TxAddress;                   /* Rx address */
    231              txBuf[ 6] = DEVICE_IO + UnitID;                 /* Unit ID */
    232              txBuf[ 7] = MyAddress();                        /* Tx address */
    233              txBuf[ 8] = 0;                                  /* packlen HB, don't know yet */
    234              txBuf[ 9] = 0;                                  /* packlen LB, don't know yet */
    235              txBuf[10] = 0;                                  /* Header checksum, don't know yet */
    236          }
    237          
    238          /*************************************************************************
    239          *
    240          * Build  packet tail
    241          *
    242          *************************************************************************/
    243          void My485UART_BuildTail(void) {
    244          
    245              My485UART_BuildHeader();                      // fist build the header
    246              char *txBuf = My485UART.pTxBuffer;
    247              txBuf[My485UART.TxFirst++] = ECMD_NMDWOACK & 0xff;    // End command lb
    248              txBuf[My485UART.TxFirst++] = ECMD_NMDWOACK >> 8;      // End command hb
    249              txBuf[My485UART.TxFirst++] = 0x00;                    // End data
    250          
    251              txBuf[My485UART.TxFirst++] = My485UART.TxSeqCnt++;  // Sequence counter
    252          
    253              txBuf[ 8] = My485UART.TxFirst - 2;                     // correct length because stx's
    254              txBuf[ 9] = (My485UART.TxFirst - 2) >> 8;              // packet len high
    255              txBuf[10] = CalcDSTxChecksum( 6);                       // Get header checksum
    256              unsigned PacketStart = My485UART.TxFirst;
    257              txBuf[My485UART.TxFirst]      = CalcDSTxChecksum(PacketStart - 4); // Get checksum
    258              My485UART.TxFirst++;                                  // OBS!! must be inc here due to ANSI standard !!!!
    259          
    260              txBuf[My485UART.TxFirst++]    = ANPRO10_EOT;          // End of transmission
    261           //   txBuf[My485UART.TxFirst++]    = ANPRO10_EOT;          // End of transmission
    262              My485UART.TxCount             = My485UART.TxFirst;  //bytes to send
    263              My485UART.TxLast 			    = 0;                    // reset cunter
    264              // Turn on TXE for channel
    265              My_SetBit(PORTE, 0x04);                                 // TXE0 on
    266              OS_Delay(2);                                            // Ensure some settling time
    267              UCSR0B |= __BIT_MASK(UDRIE0);                           // start sending by enableing interrupt
    268              OS_WaitEvent(UART0_EVENT_TX_COMPLETE);
    269          
    270          }
    271          
    272          /*************************************************************************
    273          *
    274          * Build datablock for card status
    275          *
    276          *************************************************************************/
    277          
    278          void BuildStatusData(void) {
    279              if ( My485UART.TxFirst < TXSIZE_UART -20 ) {
    280                  short ntna;
    281                  My485UART.RxSendReply = true;                               // flag for answering
    282          
    283                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STATUS & 0xff;
    284                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STATUS >> 8;
    285                  ntna = My485UART.TxFirst;                                    /* remember index */
    286                  My485UART.TxFirst += 2;                                                       // two byte length
    287                  My485UART.pTxBuffer[My485UART.TxFirst++] = 0;                               // channel fixed to 0
    288                  My485UART.pTxBuffer[My485UART.TxFirst++] = DEVICE_IO + UnitID;              // Product ID
    289                  My485UART.pTxBuffer[My485UART.TxFirst++] = MyAddress();                     // unit adddress
    290                  My485UART.pTxBuffer[My485UART.TxFirst++] = PROG_VERSION;                    // software version */
    291                  My485UART.pTxBuffer[My485UART.TxFirst++] = COMP_VERSION;                    // cpmpability version
    292                  My485UART.pTxBuffer[My485UART.TxFirst++] = STORE_VERSION;                   // cpmpability version
    293                  My485UART.pTxBuffer[My485UART.TxFirst++] = (RXSIZE_UART & 0xff);            // rx buffer size
    294                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((RXSIZE_UART >> 8) & 0xff);     // rx buffer size
    295                  My485UART.pTxBuffer[My485UART.TxFirst++] = (TXSIZE_UART & 0xff);            // tx buffer size
    296                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);     // tx buffer size
    297                  My485UART.pTxBuffer[My485UART.TxFirst++] = RestartStatus;                   // restart flag
    298                  My485UART.pTxBuffer[My485UART.TxFirst++] = PROGTYPE_APP;                    // Application program
    299                  My485UART.pTxBuffer[My485UART.TxFirst++] = RestartCnt & 0xff;               // Unit restart count
    300                  My485UART.pTxBuffer[My485UART.TxFirst++] = (RestartCnt >> 8 ) & 0xff;       // Unit restart count
    301          
    302                  My485UART.pTxBuffer[ntna] =   (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
    303                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
    304          
    305                  RestartStatus = 0;                                                       // set reset stat to 0 = read
    306              }
    307          }
    308          
    309          /*************************************************************************
    310          *
    311          * Build EEPROM data package
    312          *
    313          *************************************************************************/
    314          void BuildEEPROMData(char *pointer) {
    315              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
    316                  short ntna;
    317                  char channel;
    318                  My485UART.RxSendReply = true;                               // flag for answering
    319          
    320                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_EEPROM_DATA & 0xff;
    321                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_EEPROM_DATA >> 8;
    322                  ntna = My485UART.TxFirst;                                    /* remember index */
    323                  My485UART.TxFirst += 2;                                      // two byte length
    324          
    325                  channel = pointer[0];
    326                  My485UART.pTxBuffer[My485UART.TxFirst++] = channel; //channel
    327          
    328                  ReadEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&My485UART.pTxBuffer[My485UART.TxFirst]);
    329                  My485UART.TxFirst += sizeof(float);
    330                  ReadEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&My485UART.pTxBuffer[My485UART.TxFirst]);
    331                  My485UART.TxFirst += sizeof(float);
    332          
    333                  My485UART.pTxBuffer[ntna] = (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
    334                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
    335              }
    336          }
    337          
    338          
    339          /*************************************************************************
    340          *
    341          * Build datablock for Internal AD
    342          *
    343          *************************************************************************/
    344          void BuildADInt(char *pointer) {
    345              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
    346                  short ntna, i;
    347                  My485UART.RxSendReply = true;                               // flag for answering
    348          
    349                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_INT_DATA & 0xff;
    350                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_INT_DATA >> 8;
    351                  ntna = My485UART.TxFirst;                                    /* remember index */
    352                  My485UART.TxFirst += 2;                                      // two byte length
    353          
    354                  for ( i = 0; i < 3; i++ ) {
    355                      My485UART.pTxBuffer[My485UART.TxFirst++] = ADInt.Result[i];
    356                      My485UART.pTxBuffer[My485UART.TxFirst++] = ADInt.Result[i] >> 8;   // ADresult
    357                  }
    358          
    359                  My485UART.pTxBuffer[ntna] = (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
    360                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
    361              }
    362          
    363          }
    364          
    365          
    366          /*************************************************************************
    367          *
    368          * Build setup data package for AN-ZBHART
    369          *
    370          *************************************************************************/
    371          void BuildHartSetup( char *pointer) {
    372              if ( My485UART.TxFirst < TXSIZE_UART - 20) {
    373                  short ntna;
    374                  My485UART.RxSendReply = true;                               // flag for answering
    375          
    376                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_SETUP & 0xff;
    377                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_SETUP >> 8;
    378                  ntna = My485UART.TxFirst;                                    /* remember index */
    379                  My485UART.TxFirst += 2;                                      // two byte length
    380          
    381                  My485UART.pTxBuffer[My485UART.TxFirst++] = TData.Hart.PortUsed & 0xff;
    382                  My485UART.pTxBuffer[My485UART.TxFirst++] = (TData.Hart.PortUsed >> 8) & 0xff;
    383          
    384                  My485UART.pTxBuffer[ntna] =  (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
    385                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
    386              }
    387          }
    388          
    389          /*************************************************************************
    390          *
    391          * Build filter data package for AN-ZBHART
    392          *
    393          *************************************************************************/
    394          void BuildHartFilter( char *pointer) {
    395              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
    396                  char port;
    397                  short ntna;
    398                  My485UART.RxSendReply = true;                               // flag for answering
    399          
    400                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_FILTER & 0xff;
    401                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_FILTER >> 8;
    402                  ntna = My485UART.TxFirst;                                    /* remember index */
    403                  My485UART.TxFirst += 2;                                      // two byte length
    404          
    405                  for ( port = 0; port < 12; port++ ) {
    406                      My485UART.pTxBuffer[My485UART.TxFirst++] = TData.Hart.Filter[port];
    407                  }
    408          
    409                  My485UART.pTxBuffer[ntna] =  (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
    410                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
    411              }
    412          }
    413          
    414          /*************************************************************************
    415          *
    416          * Build datablock for Hart (Hart)
    417          *
    418          *************************************************************************/
    419          void BuildMDataHart(void) {
    420              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
    421                  short Index        = 11; // // Add data after the heading, Heading size is 11
    422                  char *Buf          = My485UART.pTxBuffer;
    423                  My485UART.RxSendReply = true;                               // flag for answering
    424                  Buf[Index++] = CMD_REP_HART_MDATA & 0xff;
    425                  Buf[Index++] = CMD_REP_HART_MDATA >> 8;
    426                  short ntna = Index;                                  /* remember index */
    427                  Index  += 2;                                      // two byte length
    428          
    429                  Buf[Index++] = (RestartStatus << 4);    // Add restart status
    430                  // Hart PV
    431                  for ( short i = 0; i < 12; i++ ) {
    432                      *((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][0];   // Hart 1st
    433                      Index += sizeof(unsigned short);
    434                      *((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][1];   // Hart 2nd
    435                      Index += sizeof(unsigned short);
    436                      //hart_channel_lock(&_hart_channels[i]);
    437                      *((float *)&Buf[Index]) = TData.Hart.Distance[i];       // Hart 1st
    438                      Index += sizeof(float);
    439                      *((float *)&Buf[Index]) = TData.Hart.Level[i];          // Hart 2nd
    440                      Index += sizeof(float);
    441                      *((float *)&Buf[Index]) = TData.Hart.ADCurrent[i];      //*TData.Hart.Gain[i] - TData.Hart.Offset[i];   // Measured current via onboard ADC
    442                      Index += sizeof(float);
    443                      //*((float *)&Buf[Index]) = TData.Hart.HartCurrent[i];    // mA current from the device
    444                      //Index += sizeof(float);
    445                      //hart_channel_unlock(&_hart_channels[i]);
    446                  }
    447                  Buf[ntna] = (Index - ntna - 2) & 0xff;      // length of data block lb
    448                  Buf[ntna + 1] = ((Index - ntna - 2) >> 8) & 0xff; // length of data block hb
    449                  My485UART.TxFirst = Index; // Add data after the heading
    450              }
    451          
    452          
    453          }
    454          
    455          
    456          /*************************************************************************
    457          *
    458          * Build datablock for Stack status
    459          *
    460          *************************************************************************/
    461          void BuildStackStatus( char *pointer) {
    462              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
    463                  short ntna, stack;
    464                  My485UART.RxSendReply = true;                               // flag for answering
    465          
    466                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STACKSTATUS & 0xff;
    467                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STACKSTATUS >> 8;
    468                  ntna = My485UART.TxFirst;                                    /* remember index */
    469                  My485UART.TxFirst += 2;                                      // two byte length
    470          
    471                  stack = OS_GetStackSpace(&TCB_USART0);                            // USART 0
    472                  My485UART.pTxBuffer[My485UART.TxFirst++] = (stack & 0xff);
    473                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((stack >> 8) & 0xff);
    474          
    475                  stack = OS_GetStackSpace(&TCB_WATCHDOG);                            // watchdog
    476                  My485UART.pTxBuffer[My485UART.TxFirst++] = (stack & 0xff);
    477                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((stack >> 8) & 0xff);
    478                  switch ( UnitID ) {
    479                  case AN_ZB485 :
    480                  case AN_ZBANA :
    481                      break;
    482                  case AN_ZBHART :
    483                      stack = OS_GetStackSpace(&TCB_AD7715);                            // AD handling
    484                      My485UART.pTxBuffer[My485UART.TxFirst++] = (stack & 0xff);
    485                      My485UART.pTxBuffer[My485UART.TxFirst++] = ((stack >> 8) & 0xff);
    486                      My485UART.pTxBuffer[My485UART.TxFirst++] = 0;
    487                      My485UART.pTxBuffer[My485UART.TxFirst++] = 0;
    488                      break;
    489                  }
    490          
    491                  My485UART.pTxBuffer[ntna] = (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
    492                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
    493              }
    494          
    495          }
    496          
    497          //////////////////////////////////////////////////////////////////////////////
    498          // Receiving data to IO module here
    499          /////////////////////////////////////////////////////////////////////////////
    500          
    501          /*************************************************************************
    502          *
    503          * Receive Command to Reset the EEPROM
    504          *
    505          *************************************************************************/
    506          void GetResetEEPROM(void) {
    507          
    508              EEPROMReset();
    509          }
    510          
    511          
    512          /*************************************************************************
    513          *
    514          * Receive Command to go to the bootloader program
    515          *
    516          *************************************************************************/
    517          extern volatile char RestartCmd;
    518          void GetGotoBootloader( char *pointer) {
    519          
    520              void (*BootApp)(void) = (void(*)())0xF000;
    521              while ( (EECR & 1 << EEPE) != 0 ) //chech if EEPROM is ready
    522              ;
    523              EEARL = (0x0fff & 0xff);
    524              EEARH = (0x0fff >> 8);
    525              EEDR = 0x00;
    526              EECR |= (1 << EEMPE);
    527              EECR |= (1 << EEPE);
    528              while ( EECR & (1 << EEPE) );
    529              //RestartCmd = 1;
    530              BootApp();
    531              //OS_Error(ZB_REBOOT);
    532          }
    533          
    534          /*************************************************************************
    535          *
    536          * Receive EEPROM data
    537          *
    538          *************************************************************************/
    539          void GetEEPROMData( char *pointer) {
    540          
    541              char channel;
    542              OS_U32 t0;
    543          
    544              channel = pointer[0];
    545              switch ( UnitID ) {
    546              case AN_ZBANA:
    547                  break;
    548              case AN_ZBHART:
    549                  if ( channel >= 0x80 ) {
    550                      *((float *)&TData.Hart.Offset[channel & 0x0f]) = *((float *)&pointer[1]);  //offset
    551                      *((float *)&TData.Hart.Gain[channel   & 0x0f]) = *((float *)&pointer[5]);  //gain
    552                  }
    553                  break;
    554              case AN_ZB485:
    555                  break;
    556              }
    557              WriteEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&pointer[1]);
    558              t0 = OS_GetTime();
    559              do {
    560                  OS_Delay(1);
    561              }while ( (OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK );  //8.5 ms programming time
    562              WriteEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&pointer[5]);
    563              t0 = OS_GetTime();
    564              do {
    565                  OS_Delay(1);
    566              }while ( (OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK );
    567          }
    568          
    569          
    570          
    571          /*************************************************************************
    572          *
    573          * Receive AN-ZBHART setup
    574          *
    575          *************************************************************************/
    576          void GetHartSetup( char *pointer, unsigned Size) {
    577              switch ( Size ) {
    578              case 4:
    579                  TData.Hart.PortUsed     = pointer[0] + (pointer[1] << 8);  //Get the setup
    580                  TData.Hart.HartSensor   = pointer[2] + (pointer[3] << 8);  //Get the setup
    581                  WriteEEPROMByte(EEPROM_PORTSETUP, pointer[0]);     // store in EEPROM
    582                  WriteEEPROMByte(EEPROM_HART_SNS , pointer[2]);
    583                  for ( char i = 0; i < 12; i++ ) {
    584                      TData.Hart.FailCnt[i][0] = 0;
    585                      TData.Hart.FailCnt[i][1] = 0;
    586                  }
    587                  break;
    588              case 6:
    589                  {
    590                      TData.Hart.PortUsed     = pointer[0] + (pointer[1] << 8);  //Get the setup
    591                      TData.Hart.HartSensor   = pointer[2] + (pointer[3] << 8);  //Get the setup
    592                      unsigned AdditionalCmd  = pointer[4] + (pointer[5] << 8);  //Get the extra command
    593                      if ( AdditionalCmd & 1 ) {
    594                          WriteEEPROMByte(EEPROM_PORTSETUP, pointer[0]);     // store in EEPROM
    595                          WriteEEPROMByte(EEPROM_HART_SNS , pointer[2]);
    596                          RestartCnt  = 0;
    597                          for ( char i = 0; i < 12; i++ ) {
    598                              TData.Hart.FailCnt[i][0] = 0;
    599                              TData.Hart.FailCnt[i][1] = 0;
    600                          }
    601                      }
    602                      
    603                  }
    604                  break;
    605              }
    606                                                                         
    607          
    608          }
    609          
    610          /*************************************************************************
    611          *
    612          * Receive AN-ZBHART filter
    613          *
    614          *************************************************************************/
    615          void GetHartFilter( char *pointer) {
    616          
    617              for ( int port = 0; port < 12; port++ ) {
    618                  TData.Hart.Filter[port] = *pointer++;  //Get the filter
    619              }
    620          }
    621          
    622          
    623          /*************************************************************************
    624          *
    625          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    626          *
    627          *************************************************************************/
    628          char CalcDSTxChecksum(unsigned  Length) {
    629              unsigned char csum = 0;
    630              for ( short cnt = 0; cnt < Length; cnt++ ) {
    631                  csum = crc[csum ^ My485UART.pTxBuffer[cnt + 4]];
    632              }
    633              return csum;
    634          }
    635          
    636          

Errors: 2
Warnings: 1
