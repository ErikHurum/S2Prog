###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       04/May/2023  10:24:01
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  D:\S2Prog\IO\AN-ZBHART\Src\UsartPro.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWBA0.tmp
#        (D:\S2Prog\IO\AN-ZBHART\Src\UsartPro.c --cpu=m1280 -ms -o
#        D:\S2Prog\IO\AN-ZBHART\Debug\Obj -D OS_LIBMODE_D -D OS_UART=-1 -lCN
#        D:\S2Prog\IO\AN-ZBHART\Debug\List -y --initializers_in_flash --no_cse
#        --no_inline --no_code_motion --no_cross_call --no_clustering --no_tbaa
#        --debug -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\AN-ZBHART\INC\\ -I
#        ..\..\..\Shared\Inc\\ --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  D:\S2Prog\IO\AN-ZBHART\Debug\List\UsartPro.lst
#    Object file  =  D:\S2Prog\IO\AN-ZBHART\Debug\Obj\UsartPro.r90
#
###############################################################################

D:\S2Prog\IO\AN-ZBHART\Src\UsartPro.c
      1          /****************************************************************************************
      2          / Com protocol for USART0
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0xc1
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "string.h"
     10          #include "RTOS.h"
     11          #include "hart.h"
     12          #include "externals.h"
     13          #include "version.h"
     14          #include "structs.h"
     15          

   \                                 In  segment ABSOLUTE, at 0x21fd
     16          __no_init int RestartCnt             @0x21FD;
   \                     RestartCnt:
   \   00000000                      DS8 2
     17          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     18          char hasStartedUARTTask = 0;
   \                     hasStartedUARTTask:
   \   00000000                      DS8 1
     19          
     20          //extern __no_init TargetData  TData;                    
     21          /*************************************************************************
     22          *   
     23          *  Handle the ANPRO10 protocol
     24          * 
     25          *  Returns 1 if a reply has been sent
     26          *
     27          *************************************************************************/

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     28          static unsigned LastCommand = 0;
   \                     LastCommand:
   \   00000000                      DS8 2

   \                                 In  segment CODE, align 2, keep-with-next
     29          char ANPRO10_UnpackPacket(void) {
   \                     ANPRO10_UnpackPacket:
   \   00000000   ........           CALL    ?PROLOGUE10_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
     30              char *Buf = My485UART.pRxBuffer;
   \   00000004   ....               LDI     R24, LOW((My485UART + 524))
   \   00000006   ....               LDI     R25, HIGH((My485UART + 524))
     31              const ANPRO10_PacketHeading *pPH = (ANPRO10_PacketHeading *)Buf;
   \   00000008   014C               MOVW    R9:R8, R25:R24
     32              My485UART.RxCount++;
   \   0000000A   ....               LDI     R30, LOW((My485UART + 676))
   \   0000000C   ....               LDI     R31, HIGH((My485UART + 676))
   \   0000000E   8100               LD      R16, Z
   \   00000010   8111               LDD     R17, Z+1
   \   00000012   5F0F               SUBI    R16, 255
   \   00000014   4F1F               SBCI    R17, 255
   \   00000016   8300               ST      Z, R16
   \   00000018   8311               STD     Z+1, R17
     33              My485UART.TxAddress   = pPH->txadr;
   \   0000001A   01F4               MOVW    R31:R30, R9:R8
   \   0000001C   8103               LDD     R16, Z+3
   \   0000001E   9300....           STS     (My485UART + 9), R16
     34              My485UART.TxId        = pPH->txtypeid;
   \   00000022   01F4               MOVW    R31:R30, R9:R8
   \   00000024   8102               LDD     R16, Z+2
   \   00000026   9300....           STS     (My485UART + 8), R16
     35              My485UART.RxSendReply = false;                              // flag for answering set to fault
   \   0000002A   E000               LDI     R16, 0
   \   0000002C   9300....           STS     (My485UART + 675), R16
     36              My485UART.TxFirst     = 11;                                 // Start pos for first TX command
   \   00000030   ....               LDI     R30, LOW(My485UART)
   \   00000032   ....               LDI     R31, (My485UART) >> 8
   \   00000034   E00B               LDI     R16, 11
   \   00000036   E010               LDI     R17, 0
   \   00000038   8300               ST      Z, R16
   \   0000003A   8311               STD     Z+1, R17
     37          
     38              Buf += sizeof(ANPRO10_PacketHeading);
   \   0000003C   9607               ADIW    R25:R24, 7
     39              const char *EndPtr =  (char*)&Buf[pPH->nob];
   \   0000003E   01F4               MOVW    R31:R30, R9:R8
   \   00000040   8104               LDD     R16, Z+4
   \   00000042   8115               LDD     R17, Z+5
   \   00000044   012C               MOVW    R5:R4, R25:R24
   \   00000046   0E40               ADD     R4, R16
   \   00000048   1E51               ADC     R5, R17
     40              // Sanity check
     41              if ( pPH->nob >= RXSIZE_UART-5 ) {
   \   0000004A   01F4               MOVW    R31:R30, R9:R8
   \   0000004C   8104               LDD     R16, Z+4
   \   0000004E   8115               LDD     R17, Z+5
   \   00000050   3901               CPI     R16, 145
   \   00000052   E020               LDI     R18, 0
   \   00000054   0712               CPC     R17, R18
   \   00000056   F010               BRCS    ??ANPRO10_UnpackPacket_0
     42                  return 0;
   \   00000058   E000               LDI     R16, 0
   \   0000005A   C054               RJMP    ??ANPRO10_UnpackPacket_1
     43              }
     44              ANPRO10_CommandHeading *pCH;
     45              char MoreCommands = true;
   \                     ??ANPRO10_UnpackPacket_0:
   \   0000005C   2466               CLR     R6
   \   0000005E   9463               INC     R6
     46              do {
     47                  pCH = (ANPRO10_CommandHeading *)Buf;
   \                     ??ANPRO10_UnpackPacket_2:
   \   00000060   01DC               MOVW    R27:R26, R25:R24
     48                  Buf += sizeof(ANPRO10_CommandHeading);  // ??
   \   00000062   9604               ADIW    R25:R24, 4
     49                  switch ( pCH->CommandNo ) {
   \   00000064   91ED               LD      R30, X+
   \   00000066   91FC               LD      R31, X
   \   00000068   9711               SBIW    R27:R26, 1
   \   0000006A   9630               ADIW    R31:R30, 0
   \   0000006C   F049               BREQ    ??ANPRO10_UnpackPacket_3
   \   0000006E   9731               SBIW    R31:R30, 1
   \   00000070   F039               BREQ    ??ANPRO10_UnpackPacket_3
     50                  case ECMD_NMDWOACK:
     51                  case ECMD_NMDRQACK:
     52                      break;
     53                  default:
     54                      LastCommand = pCH->CommandNo;
   \   00000072   910D               LD      R16, X+
   \   00000074   911C               LD      R17, X
   \   00000076   9711               SBIW    R27:R26, 1
   \   00000078   ....               LDI     R30, LOW(LastCommand)
   \   0000007A   ....               LDI     R31, (LastCommand) >> 8
   \   0000007C   8300               ST      Z, R16
   \   0000007E   8311               STD     Z+1, R17
     55                      break;
     56                  }
     57                  switch ( pCH->CommandNo ) {
   \                     ??ANPRO10_UnpackPacket_3:
   \   00000080   910D               LD      R16, X+
   \   00000082   911C               LD      R17, X
   \   00000084   9711               SBIW    R27:R26, 1
   \   00000086   ....               LDI     R30, LOW(`?<Jumptable for ANPRO10_UnpackPacket>_0`)
   \   00000088   ....               LDI     R31, (`?<Jumptable for ANPRO10_UnpackPacket>_0`) >> 16
   \   0000008A   BFFB               OUT     0x3B, R31
   \   0000008C   ....               LDI     R31, HIGH(`?<Jumptable for ANPRO10_UnpackPacket>_0`)
   \   0000008E   ........           JMP     ?SV_SWITCH_L06
     58                  case CMD_REQ_STATUS :                           // Regusest status for target
     59                      BuildStatusData();                          // make package
   \                     ??ANPRO10_UnpackPacket_4:
   \   00000092   ....               RCALL   BuildStatusData
     60                      break;
   \   00000094   C023               RJMP    ??ANPRO10_UnpackPacket_5
     61                  case CMD_GET_STACKSTATUS :                      // Request stck status
     62                      BuildStackStatus( Buf);
   \                     ??ANPRO10_UnpackPacket_6:
   \   00000096   018C               MOVW    R17:R16, R25:R24
   \   00000098   ....               RCALL   BuildStackStatus
     63                      break;
   \   0000009A   C020               RJMP    ??ANPRO10_UnpackPacket_5
     64                  case CMD_EEPROM_RESET :                         // Reset EEPROM??
     65                      GetResetEEPROM();
   \                     ??ANPRO10_UnpackPacket_7:
   \   0000009C   ....               RCALL   GetResetEEPROM
     66                      break;
   \   0000009E   C01E               RJMP    ??ANPRO10_UnpackPacket_5
     67                  case CMD_GOTO_BOOTLOADER :                      // Goto bootlaoder??
     68                      GetGotoBootloader(Buf);
   \                     ??ANPRO10_UnpackPacket_8:
   \   000000A0   018C               MOVW    R17:R16, R25:R24
   \   000000A2   ....               RCALL   GetGotoBootloader
     69                      break;
   \   000000A4   C01B               RJMP    ??ANPRO10_UnpackPacket_5
     70                  case CMD_SND_EEPROM_DATA :                      // Receive EEPROM data
     71                      GetEEPROMData(Buf);
   \                     ??ANPRO10_UnpackPacket_9:
   \   000000A6   018C               MOVW    R17:R16, R25:R24
   \   000000A8   ....               RCALL   GetEEPROMData
     72                      break;
   \   000000AA   C018               RJMP    ??ANPRO10_UnpackPacket_5
     73                  case CMD_REQ_EEPROM_DATA :                      // Request to send EEPROM data
     74                      BuildEEPROMData( Buf);
   \                     ??ANPRO10_UnpackPacket_10:
   \   000000AC   018C               MOVW    R17:R16, R25:R24
   \   000000AE   ....               RCALL   BuildEEPROMData
     75                      break;
   \   000000B0   C015               RJMP    ??ANPRO10_UnpackPacket_5
     76                  case CMD_REQ_INT_DATA :                         // Request external data
     77                      BuildADInt( Buf);
   \                     ??ANPRO10_UnpackPacket_11:
   \   000000B2   018C               MOVW    R17:R16, R25:R24
   \   000000B4   ....               RCALL   BuildADInt
     78                      break;
   \   000000B6   C012               RJMP    ??ANPRO10_UnpackPacket_5
     79                  case CMD_SND_HART_SETUP :                       // Receive sertup of AN-RSANA
     80                      GetHartSetup(Buf, pCH->ndb);
   \                     ??ANPRO10_UnpackPacket_12:
   \   000000B8   01FD               MOVW    R31:R30, R27:R26
   \   000000BA   8122               LDD     R18, Z+2
   \   000000BC   8133               LDD     R19, Z+3
   \   000000BE   018C               MOVW    R17:R16, R25:R24
   \   000000C0   ....               RCALL   GetHartSetup
     81                      break;
   \   000000C2   C00C               RJMP    ??ANPRO10_UnpackPacket_5
     82                  case CMD_REQ_HART_SETUP :                       // Request for sertup of AN-RSANA
     83                      BuildHartSetup( Buf);
   \                     ??ANPRO10_UnpackPacket_13:
   \   000000C4   018C               MOVW    R17:R16, R25:R24
   \   000000C6   ....               RCALL   BuildHartSetup
     84                      break;
   \   000000C8   C009               RJMP    ??ANPRO10_UnpackPacket_5
     85                  case CMD_SND_HART_FILTER :                      // Receive filter of AN-RSANA
     86                      GetHartFilter(Buf);
   \                     ??ANPRO10_UnpackPacket_14:
   \   000000CA   018C               MOVW    R17:R16, R25:R24
   \   000000CC   ....               RCALL   GetHartFilter
     87                      break;
   \   000000CE   C006               RJMP    ??ANPRO10_UnpackPacket_5
     88                  case CMD_REQ_HART_FILTER :                      // Request filter of AN-RSANA
     89                      BuildHartFilter( Buf);
   \                     ??ANPRO10_UnpackPacket_15:
   \   000000D0   018C               MOVW    R17:R16, R25:R24
   \   000000D2   ....               RCALL   BuildHartFilter
     90                      break;
   \   000000D4   C003               RJMP    ??ANPRO10_UnpackPacket_5
     91                  case CMD_REQ_HART_DATA :                        // Request ANA data(4-20ma)
     92                      BuildMDataHart();
   \                     ??ANPRO10_UnpackPacket_16:
   \   000000D6   ....               RCALL   BuildMDataHart
     93                      break;
   \   000000D8   C001               RJMP    ??ANPRO10_UnpackPacket_5
     94          
     95                  case ECMD_NMDWOACK:
     96                  case ECMD_NMDRQACK:
     97                      MoreCommands = false;
   \                     ??ANPRO10_UnpackPacket_17:
   \   000000DA   2466               CLR     R6
     98                      break;
     99                  default:
    100                      break;
    101          
    102                  }
    103                  if ( MoreCommands ) {
   \                     ??ANPRO10_UnpackPacket_5:
   \   000000DC   2066               TST     R6
   \   000000DE   F029               BREQ    ??ANPRO10_UnpackPacket_18
    104                      Buf += pCH->ndb;
   \   000000E0   01FD               MOVW    R31:R30, R27:R26
   \   000000E2   8102               LDD     R16, Z+2
   \   000000E4   8113               LDD     R17, Z+3
   \   000000E6   0F80               ADD     R24, R16
   \   000000E8   1F91               ADC     R25, R17
    105                  }
    106              } while ( MoreCommands && (Buf < EndPtr) );
   \                     ??ANPRO10_UnpackPacket_18:
   \   000000EA   2066               TST     R6
   \   000000EC   F021               BREQ    ??ANPRO10_UnpackPacket_19
   \   000000EE   1584               CP      R24, R4
   \   000000F0   0595               CPC     R25, R5
   \   000000F2   F408               BRCC    $+2+2
   \   000000F4   CFB5               RJMP    ??ANPRO10_UnpackPacket_2
    107              if ( My485UART.RxSendReply ) {                                   //send answer?
   \                     ??ANPRO10_UnpackPacket_19:
   \   000000F6   9100....           LDS     R16, (My485UART + 675)
   \   000000FA   2300               TST     R16
   \   000000FC   F009               BREQ    ??ANPRO10_UnpackPacket_20
    108                  My485UART_BuildTail();                                       // yes, build tail (and header) and start sending
   \   000000FE   ....               RCALL   My485UART_BuildTail
    109              }
    110              return (My485UART.RxSendReply);
   \                     ??ANPRO10_UnpackPacket_20:
   \   00000100   9100....           LDS     R16, (My485UART + 675)
   \                     ??ANPRO10_UnpackPacket_1:
   \   00000104   E0EA               LDI     R30, 10
   \   00000106   ........           JMP     ?EPILOGUE_B10_L09
    111          }
    112          
    113          #define MAX_TIME_BETWEEN_BYTE	15
    114          

   \                                 In  segment CODE, align 2, keep-with-next
    115          void ANPRO10_IO_Receive(void) {
   \                     ANPRO10_IO_Receive:
   \   00000000   ........           CALL    ?PROLOGUE16_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004                      REQUIRE ?Register_R12_is_cg_reg
   \   00000004                      REQUIRE ?Register_R13_is_cg_reg
   \   00000004                      REQUIRE ?Register_R14_is_cg_reg
   \   00000004                      REQUIRE ?Register_R15_is_cg_reg
   \   00000004   9722               SBIW    R29:R28, 2
    116              unsigned char *RxBuf = (unsigned char *)My485UART.pRxBuffer;
   \   00000006   ....               LDI     R16, LOW((My485UART + 524))
   \   00000008   2E80               MOV     R8, R16
   \   0000000A   ....               LDI     R16, HIGH((My485UART + 524))
   \   0000000C   2E90               MOV     R9, R16
    117              const ANPRO10_PacketHeading *pPH =  (ANPRO10_PacketHeading *)RxBuf;
   \   0000000E   0164               MOVW    R13:R12, R9:R8
    118              char Data;
    119              char dataAvailable = 1;
   \   00000010   E081               LDI     R24, 1
    120              int  SyncCnt       = 1;     // Initialize to 1 as 1 must have been found when exiting the while loop
   \   00000012   24BB               CLR     R11
   \   00000014   24AA               CLR     R10
   \   00000016   94A3               INC     R10
    121              char PacketOK      = false; // Assume the worse at the beginning
   \   00000018   24EE               CLR     R14
    122              // Look for ANPRO10_SYN, ignore the rest
    123              do {
    124                  OS_GetMail1(&My485UART.RxMailBox, &Data);
   \                     ??ANPRO10_IO_Receive_0:
   \   0000001A   019E               MOVW    R19:R18, R29:R28
   \   0000001C   ....               LDI     R16, LOW((My485UART + 10))
   \   0000001E   ....               LDI     R17, HIGH((My485UART + 10))
   \   00000020   ........           CALL    OS_GetMail1
    125              }while ( Data != ANPRO10_SYN );
   \   00000024   8108               LD      R16, Y
   \   00000026   3106               CPI     R16, 22
   \   00000028   F7C1               BRNE    ??ANPRO10_IO_Receive_0
    126              // We know we have a ANPRO10_SYN
    127              // A minimum of 2 SYN to accept start
    128              //Message("First SYN");
    129              //SyncCnt = 0;
    130              do {
    131                  dataAvailable = !OS_GetMailTimed(&My485UART.RxMailBox, &Data, MAX_TIME_BETWEEN_BYTE);
   \                     ??ANPRO10_IO_Receive_1:
   \   0000002A   E04F               LDI     R20, 15
   \   0000002C   E050               LDI     R21, 0
   \   0000002E   019E               MOVW    R19:R18, R29:R28
   \   00000030   ....               LDI     R16, LOW((My485UART + 10))
   \   00000032   ....               LDI     R17, HIGH((My485UART + 10))
   \   00000034   ........           CALL    OS_GetMailTimed
   \   00000038   2300               TST     R16
   \   0000003A   F411               BRNE    ??ANPRO10_IO_Receive_2
   \   0000003C   E081               LDI     R24, 1
   \   0000003E   C001               RJMP    ??ANPRO10_IO_Receive_3
   \                     ??ANPRO10_IO_Receive_2:
   \   00000040   E080               LDI     R24, 0
    132                  if ( dataAvailable && (Data == ANPRO10_SYN) ) SyncCnt++;
   \                     ??ANPRO10_IO_Receive_3:
   \   00000042   2388               TST     R24
   \   00000044   F039               BREQ    ??ANPRO10_IO_Receive_4
   \   00000046   8108               LD      R16, Y
   \   00000048   3106               CPI     R16, 22
   \   0000004A   F421               BRNE    ??ANPRO10_IO_Receive_4
   \   0000004C   E001               LDI     R16, 1
   \   0000004E   0EA0               ADD     R10, R16
   \   00000050   E000               LDI     R16, 0
   \   00000052   1EB0               ADC     R11, R16
    133              } while ( dataAvailable && (Data == ANPRO10_SYN) );
   \                     ??ANPRO10_IO_Receive_4:
   \   00000054   2388               TST     R24
   \   00000056   F019               BREQ    ??ANPRO10_IO_Receive_5
   \   00000058   8108               LD      R16, Y
   \   0000005A   3106               CPI     R16, 22
   \   0000005C   F331               BREQ    ??ANPRO10_IO_Receive_1
    134              if ( dataAvailable && SyncCnt && (Data == ANPRO10_SOH) ) {
   \                     ??ANPRO10_IO_Receive_5:
   \   0000005E   2388               TST     R24
   \   00000060   F409               BRNE    $+2+2
   \   00000062   C0C1               RJMP    ??ANPRO10_IO_Receive_6
   \   00000064   2D0A               MOV     R16, R10
   \   00000066   290B               OR      R16, R11
   \   00000068   F409               BRNE    $+2+2
   \   0000006A   C0BD               RJMP    ??ANPRO10_IO_Receive_6
   \   0000006C   8108               LD      R16, Y
   \   0000006E   3001               CPI     R16, 1
   \   00000070   F009               BREQ    $+2+2
   \   00000072   C0B9               RJMP    ??ANPRO10_IO_Receive_6
    135                  unsigned char *RxPtr = RxBuf;
   \   00000074   01D4               MOVW    R27:R26, R9:R8
    136                  for ( unsigned i = 0; dataAvailable && i < sizeof(NetHeading); i++ ) {
   \   00000076   2444               CLR     R4
   \   00000078   2455               CLR     R5
   \                     ??ANPRO10_IO_Receive_7:
   \   0000007A   2388               TST     R24
   \   0000007C   F0B9               BREQ    ??ANPRO10_IO_Receive_8
   \   0000007E   E007               LDI     R16, 7
   \   00000080   1640               CP      R4, R16
   \   00000082   E000               LDI     R16, 0
   \   00000084   0650               CPC     R5, R16
   \   00000086   F490               BRCC    ??ANPRO10_IO_Receive_8
    137                      dataAvailable = !OS_GetMailTimed(&My485UART.RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
   \   00000088   E04F               LDI     R20, 15
   \   0000008A   E050               LDI     R21, 0
   \   0000008C   019D               MOVW    R19:R18, R27:R26
   \   0000008E   ....               LDI     R16, LOW((My485UART + 10))
   \   00000090   ....               LDI     R17, HIGH((My485UART + 10))
   \   00000092   ........           CALL    OS_GetMailTimed
   \   00000096   9611               ADIW    R27:R26, 1
   \   00000098   2300               TST     R16
   \   0000009A   F411               BRNE    ??ANPRO10_IO_Receive_9
   \   0000009C   E081               LDI     R24, 1
   \   0000009E   C001               RJMP    ??ANPRO10_IO_Receive_10
   \                     ??ANPRO10_IO_Receive_9:
   \   000000A0   E080               LDI     R24, 0
    138                  }
   \                     ??ANPRO10_IO_Receive_10:
   \   000000A2   E001               LDI     R16, 1
   \   000000A4   0E40               ADD     R4, R16
   \   000000A6   E000               LDI     R16, 0
   \   000000A8   1E50               ADC     R5, R16
   \   000000AA   CFE7               RJMP    ??ANPRO10_IO_Receive_7
    139                  if ( dataAvailable ) {
   \                     ??ANPRO10_IO_Receive_8:
   \   000000AC   2388               TST     R24
   \   000000AE   F409               BRNE    $+2+2
   \   000000B0   C09A               RJMP    ??ANPRO10_IO_Receive_6
    140                      unsigned char HCSum = 0;
   \   000000B2   E090               LDI     R25, 0
    141                      {
    142                          unsigned char *TmpRxPtr = RxBuf;
   \   000000B4   0184               MOVW    R17:R16, R9:R8
    143                          for ( unsigned i = 0; i < sizeof(ANPRO10_PacketHeading) - 1; i++ ) {
   \   000000B6   E040               LDI     R20, 0
   \   000000B8   E050               LDI     R21, 0
   \                     ??ANPRO10_IO_Receive_11:
   \   000000BA   3046               CPI     R20, 6
   \   000000BC   E020               LDI     R18, 0
   \   000000BE   0752               CPC     R21, R18
   \   000000C0   F478               BRCC    ??ANPRO10_IO_Receive_12
    144                              HCSum     = crc[HCSum ^ *TmpRxPtr++];
   \   000000C2   01F8               MOVW    R31:R30, R17:R16
   \   000000C4   8120               LD      R18, Z
   \   000000C6   2792               EOR     R25, R18
   \   000000C8   2FE9               MOV     R30, R25
   \   000000CA   E0F0               LDI     R31, 0
   \   000000CC   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000CE   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000D0   ....               LDI     R19, (crc) >> 16
   \   000000D2   BF3B               OUT     0x3B, R19
   \   000000D4   9196               ELPM    R25, Z
   \   000000D6   5F0F               SUBI    R16, 255
   \   000000D8   4F1F               SBCI    R17, 255
    145                          }
   \   000000DA   5F4F               SUBI    R20, 255
   \   000000DC   4F5F               SBCI    R21, 255
   \   000000DE   CFED               RJMP    ??ANPRO10_IO_Receive_11
    146          
    147                      }
    148                      if ( HCSum == pPH->HCRC ) {
   \                     ??ANPRO10_IO_Receive_12:
   \   000000E0   01F6               MOVW    R31:R30, R13:R12
   \   000000E2   8106               LDD     R16, Z+6
   \   000000E4   1790               CP      R25, R16
   \   000000E6   F009               BREQ    $+2+2
   \   000000E8   C07E               RJMP    ??ANPRO10_IO_Receive_6
    149                          unsigned DataSize = (unsigned)pPH->nob;
   \   000000EA   01F6               MOVW    R31:R30, R13:R12
   \   000000EC   8044               LDD     R4, Z+4
   \   000000EE   8055               LDD     R5, Z+5
    150                          // Before checked against MAX_ANPRO10_IO_SIZE which is not related to the buffer size for AN-ZBHART
    151                          if ( DataSize > 3 && DataSize < RXSIZE_UART ) { 
   \   000000F0   E004               LDI     R16, 4
   \   000000F2   1640               CP      R4, R16
   \   000000F4   E000               LDI     R16, 0
   \   000000F6   0650               CPC     R5, R16
   \   000000F8   F408               BRCC    $+2+2
   \   000000FA   C075               RJMP    ??ANPRO10_IO_Receive_6
   \   000000FC   E906               LDI     R16, 150
   \   000000FE   1640               CP      R4, R16
   \   00000100   E000               LDI     R16, 0
   \   00000102   0650               CPC     R5, R16
   \   00000104   F008               BRCS    $+2+2
   \   00000106   C06F               RJMP    ??ANPRO10_IO_Receive_6
    152                              for ( unsigned i = 0; dataAvailable && i < DataSize - sizeof(ANPRO10_PacketHeading); i++ ) {
   \   00000108   2466               CLR     R6
   \   0000010A   2477               CLR     R7
   \                     ??ANPRO10_IO_Receive_13:
   \   0000010C   2388               TST     R24
   \   0000010E   F0C1               BREQ    ??ANPRO10_IO_Receive_14
   \   00000110   0182               MOVW    R17:R16, R5:R4
   \   00000112   5007               SUBI    R16, 7
   \   00000114   4010               SBCI    R17, 0
   \   00000116   1660               CP      R6, R16
   \   00000118   0671               CPC     R7, R17
   \   0000011A   F490               BRCC    ??ANPRO10_IO_Receive_14
    153                                  dataAvailable = !OS_GetMailTimed(&My485UART.RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
   \   0000011C   E04F               LDI     R20, 15
   \   0000011E   E050               LDI     R21, 0
   \   00000120   019D               MOVW    R19:R18, R27:R26
   \   00000122   ....               LDI     R16, LOW((My485UART + 10))
   \   00000124   ....               LDI     R17, HIGH((My485UART + 10))
   \   00000126   ........           CALL    OS_GetMailTimed
   \   0000012A   9611               ADIW    R27:R26, 1
   \   0000012C   2300               TST     R16
   \   0000012E   F411               BRNE    ??ANPRO10_IO_Receive_15
   \   00000130   E081               LDI     R24, 1
   \   00000132   C001               RJMP    ??ANPRO10_IO_Receive_16
   \                     ??ANPRO10_IO_Receive_15:
   \   00000134   E080               LDI     R24, 0
    154                              }
   \                     ??ANPRO10_IO_Receive_16:
   \   00000136   E001               LDI     R16, 1
   \   00000138   0E60               ADD     R6, R16
   \   0000013A   E000               LDI     R16, 0
   \   0000013C   1E70               ADC     R7, R16
   \   0000013E   CFE6               RJMP    ??ANPRO10_IO_Receive_13
    155                              if ( dataAvailable ) {
   \                     ??ANPRO10_IO_Receive_14:
   \   00000140   2388               TST     R24
   \   00000142   F409               BRNE    $+2+2
   \   00000144   C04C               RJMP    ??ANPRO10_IO_Receive_17
    156                                  RxPtr = RxBuf;
   \   00000146   01D4               MOVW    R27:R26, R9:R8
    157                                  volatile unsigned char CSum = 0;
   \   00000148   E000               LDI     R16, 0
   \   0000014A   8309               STD     Y+1, R16
    158          
    159                                  for ( unsigned i = 0; i < DataSize - 2; i++ ) {
   \   0000014C   E040               LDI     R20, 0
   \   0000014E   E050               LDI     R21, 0
   \                     ??ANPRO10_IO_Receive_18:
   \   00000150   0182               MOVW    R17:R16, R5:R4
   \   00000152   5002               SUBI    R16, 2
   \   00000154   4010               SBCI    R17, 0
   \   00000156   1740               CP      R20, R16
   \   00000158   0751               CPC     R21, R17
   \   0000015A   F478               BRCC    ??ANPRO10_IO_Receive_19
    160                                      CSum     = crc[CSum ^ *RxPtr++];
   \   0000015C   8109               LDD     R16, Y+1
   \   0000015E   911C               LD      R17, X
   \   00000160   2701               EOR     R16, R17
   \   00000162   2FE0               MOV     R30, R16
   \   00000164   E0F0               LDI     R31, 0
   \   00000166   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000168   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000016A   ....               LDI     R19, (crc) >> 16
   \   0000016C   BF3B               OUT     0x3B, R19
   \   0000016E   9106               ELPM    R16, Z
   \   00000170   8309               STD     Y+1, R16
   \   00000172   9611               ADIW    R27:R26, 1
    161                                  }
   \   00000174   5F4F               SUBI    R20, 255
   \   00000176   4F5F               SBCI    R21, 255
   \   00000178   CFEB               RJMP    ??ANPRO10_IO_Receive_18
    162                                  unsigned char  PacketCheckSum = *((unsigned char *)&RxBuf[DataSize - 2]);
   \                     ??ANPRO10_IO_Receive_19:
   \   0000017A   01F4               MOVW    R31:R30, R9:R8
   \   0000017C   0DE4               ADD     R30, R4
   \   0000017E   1DF5               ADC     R31, R5
   \   00000180   9732               SBIW    R31:R30, 2
   \   00000182   8070               LD      R7, Z
    163                                  if ( PacketCheckSum == CSum ) {
   \   00000184   8109               LDD     R16, Y+1
   \   00000186   1670               CP      R7, R16
   \   00000188   F571               BRNE    ??ANPRO10_IO_Receive_6
    164                                      My485UART.SequenceNumber = RxBuf[DataSize - 3];
   \   0000018A   01F4               MOVW    R31:R30, R9:R8
   \   0000018C   0DE4               ADD     R30, R4
   \   0000018E   1DF5               ADC     R31, R5
   \   00000190   9733               SBIW    R31:R30, 3
   \   00000192   8100               LD      R16, Z
   \   00000194   9300....           STS     (My485UART + 679), R16
    165                                      // U16 EndCommand = *((U16*)&ARxBuf[DataSize-6]);
    166                                      // unsigned char EndData = *((unsigned char*)&ARxBuf[DataSize-4]);
    167                                      unsigned char EOTByte = *((unsigned char *)&RxBuf[DataSize - 1]);
   \   00000198   01F4               MOVW    R31:R30, R9:R8
   \   0000019A   0DE4               ADD     R30, R4
   \   0000019C   1DF5               ADC     R31, R5
   \   0000019E   9731               SBIW    R31:R30, 1
   \   000001A0   8060               LD      R6, Z
    168                                      if ( EOTByte == ANPRO10_EOT ) {
   \   000001A2   E004               LDI     R16, 4
   \   000001A4   1660               CP      R6, R16
   \   000001A6   F4F9               BRNE    ??ANPRO10_IO_Receive_6
    169                                          switch ( pPH->txtypeid ) {
   \   000001A8   01F6               MOVW    R31:R30, R13:R12
   \   000001AA   8102               LDD     R16, Z+2
   \   000001AC   5103               SUBI    R16, 19
   \   000001AE   F0D9               BREQ    ??ANPRO10_IO_Receive_6
   \   000001B0   500D               SUBI    R16, 13
   \   000001B2   F4C9               BRNE    ??ANPRO10_IO_Receive_6
    170                                          case DEVICE_TCU :
    171                                              if ( (pPH->rxadr == MyAddress()) && (pPH->rxtypeid == (UnitID + DEVICE_IO)) ) {
   \   000001B4   01F6               MOVW    R31:R30, R13:R12
   \   000001B6   80F1               LDD     R15, Z+1
   \   000001B8   ........           CALL    MyAddress
   \   000001BC   16F0               CP      R15, R16
   \   000001BE   F499               BRNE    ??ANPRO10_IO_Receive_6
   \   000001C0   01F6               MOVW    R31:R30, R13:R12
   \   000001C2   8120               LD      R18, Z
   \   000001C4   E030               LDI     R19, 0
   \   000001C6   9100....           LDS     R16, UnitID
   \   000001CA   E010               LDI     R17, 0
   \   000001CC   5F00               SUBI    R16, 240
   \   000001CE   4F1F               SBCI    R17, 255
   \   000001D0   1720               CP      R18, R16
   \   000001D2   0731               CPC     R19, R17
   \   000001D4   F441               BRNE    ??ANPRO10_IO_Receive_6
    172                                                  ANPRO10_UnpackPacket();
   \   000001D6   ....               RCALL   ANPRO10_UnpackPacket
    173                                                  PacketOK = true; // Packet accepted so signal OK!
   \   000001D8   24EE               CLR     R14
   \   000001DA   94E3               INC     R14
    174                                              } else {
    175                                                  //Ignore = true;
    176                                              }
    177                                              break;
   \   000001DC   C004               RJMP    ??ANPRO10_IO_Receive_6
    178                                          case DEVICE_ZBHART:
    179                                              //Echo = true;
    180                                              break;
    181                                          default:
    182                                              // Ignore message
    183                                              break;
    184                                          }
    185                                      }
    186                                  }
    187                              } else {
    188                                  OS_Delay(0);
   \                     ??ANPRO10_IO_Receive_17:
   \   000001DE   E000               LDI     R16, 0
   \   000001E0   E010               LDI     R17, 0
   \   000001E2   ........           CALL    OS_Delay
    189                              }
    190                          }
    191                      }
    192                  }
    193              }
    194              if ( !PacketOK ) {
   \                     ??ANPRO10_IO_Receive_6:
   \   000001E6   20EE               TST     R14
   \   000001E8   F429               BRNE    ??ANPRO10_IO_Receive_20
    195                  My485UART.RxFaultCnt++;
   \   000001EA   9100....           LDS     R16, (My485UART + 674)
   \   000001EE   9503               INC     R16
   \   000001F0   9300....           STS     (My485UART + 674), R16
    196              }
    197          }
   \                     ??ANPRO10_IO_Receive_20:
   \   000001F4   9622               ADIW    R29:R28, 2
   \   000001F6   E1E0               LDI     R30, 16
   \   000001F8   ........           JMP     ?EPILOGUE_B16_L09
    198          
    199          /*************************************************************************
    200          *   (This is a task)
    201          *  Usart0 handler
    202          *
    203          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    204          void Usart0Handler(void) {
   \                     Usart0Handler:
    205              hasStartedUARTTask = 1;
   \   00000000   E001               LDI     R16, 1
   \   00000002   9300....           STS     hasStartedUARTTask, R16
    206              UCSR0B  = 1 << RXCIE0 | 1 << RXEN0 | 1 << TXEN0;  //0x98;                                       /* tx/ rx enable, int udre/rxon */
   \   00000006   E908               LDI     R16, 152
   \   00000008   9300....           STS     _A_UCSR0B, R16
    207              while ( 1 ) {
    208                  ANPRO10_IO_Receive();
   \                     ??Usart0Handler_0:
   \   0000000C   ....               RCALL   ANPRO10_IO_Receive
   \   0000000E   CFFE               RJMP    ??Usart0Handler_0
   \   00000010                      REQUIRE _A_UCSR0B
    209              }
    210          }
    211          
    212          
    213          
    214          
    215          /*************************************************************************
    216          *
    217          * Build send packet header
    218          *
    219          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    220          void My485UART_BuildHeader(void) {
   \                     My485UART_BuildHeader:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
    221          
    222              My485UART.TxLast  = 0;
   \   00000004   ....               LDI     R30, LOW(My485UART)
   \   00000006   ....               LDI     R31, (My485UART) >> 8
   \   00000008   E000               LDI     R16, 0
   \   0000000A   E010               LDI     R17, 0
   \   0000000C   8302               STD     Z+2, R16
   \   0000000E   8313               STD     Z+3, R17
    223              char *txBuf = My485UART.pTxBuffer;
   \   00000010   ....               LDI     R26, LOW((My485UART + 124))
   \   00000012   ....               LDI     R27, HIGH((My485UART + 124))
    224          
    225              txBuf[ 0] = ANPRO10_SYN;                        /* Sync */
   \   00000014   E106               LDI     R16, 22
   \   00000016   930C               ST      X, R16
    226              txBuf[ 1] = ANPRO10_SYN;                        /* Sync */
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E106               LDI     R16, 22
   \   0000001C   8301               STD     Z+1, R16
    227              txBuf[ 2] = ANPRO10_SYN;                        /* Sync */
   \   0000001E   01FD               MOVW    R31:R30, R27:R26
   \   00000020   E106               LDI     R16, 22
   \   00000022   8302               STD     Z+2, R16
    228              txBuf[ 3] = ANPRO10_SOH;                        /* Start of header */
   \   00000024   01FD               MOVW    R31:R30, R27:R26
   \   00000026   E001               LDI     R16, 1
   \   00000028   8303               STD     Z+3, R16
    229              txBuf[ 4] = My485UART.TxId;                        /* RXID */
   \   0000002A   9100....           LDS     R16, (My485UART + 8)
   \   0000002E   01FD               MOVW    R31:R30, R27:R26
   \   00000030   8304               STD     Z+4, R16
    230              txBuf[ 5] = My485UART.TxAddress;                   /* Rx address */
   \   00000032   9100....           LDS     R16, (My485UART + 9)
   \   00000036   01FD               MOVW    R31:R30, R27:R26
   \   00000038   8305               STD     Z+5, R16
    231              txBuf[ 6] = DEVICE_IO + UnitID;                 /* Unit ID */
   \   0000003A   9100....           LDS     R16, UnitID
   \   0000003E   5F00               SUBI    R16, 240
   \   00000040   01FD               MOVW    R31:R30, R27:R26
   \   00000042   8306               STD     Z+6, R16
    232              txBuf[ 7] = MyAddress();                        /* Tx address */
   \   00000044   ........           CALL    MyAddress
   \   00000048   01FD               MOVW    R31:R30, R27:R26
   \   0000004A   8307               STD     Z+7, R16
    233              txBuf[ 8] = 0;                                  /* packlen HB, don't know yet */
   \   0000004C   01FD               MOVW    R31:R30, R27:R26
   \   0000004E   E000               LDI     R16, 0
   \   00000050   8700               STD     Z+8, R16
    234              txBuf[ 9] = 0;                                  /* packlen LB, don't know yet */
   \   00000052   01FD               MOVW    R31:R30, R27:R26
   \   00000054   E000               LDI     R16, 0
   \   00000056   8701               STD     Z+9, R16
    235              txBuf[10] = 0;                                  /* Header checksum, don't know yet */
   \   00000058   01FD               MOVW    R31:R30, R27:R26
   \   0000005A   E000               LDI     R16, 0
   \   0000005C   8702               STD     Z+10, R16
    236          }
   \   0000005E   91A9               LD      R26, Y+
   \   00000060   91B9               LD      R27, Y+
   \   00000062   9508               RET
    237          
    238          /*************************************************************************
    239          *
    240          * Build  packet tail
    241          *
    242          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    243          void My485UART_BuildTail(void) {
   \                     My485UART_BuildTail:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    244          
    245              My485UART_BuildHeader();                      // fist build the header
   \   00000004   ....               RCALL   My485UART_BuildHeader
    246              char *txBuf = My485UART.pTxBuffer;
   \   00000006   ....               LDI     R26, LOW((My485UART + 124))
   \   00000008   ....               LDI     R27, HIGH((My485UART + 124))
    247              txBuf[My485UART.TxFirst++] = ECMD_NMDWOACK & 0xff;    // End command lb
   \   0000000A   ....               LDI     R30, LOW(My485UART)
   \   0000000C   ....               LDI     R31, (My485UART) >> 8
   \   0000000E   8100               LD      R16, Z
   \   00000010   8111               LDD     R17, Z+1
   \   00000012   01C8               MOVW    R25:R24, R17:R16
   \   00000014   9601               ADIW    R25:R24, 1
   \   00000016   ....               LDI     R30, LOW(My485UART)
   \   00000018   ....               LDI     R31, (My485UART) >> 8
   \   0000001A   8380               ST      Z, R24
   \   0000001C   8391               STD     Z+1, R25
   \   0000001E   01FD               MOVW    R31:R30, R27:R26
   \   00000020   0FE0               ADD     R30, R16
   \   00000022   1FF1               ADC     R31, R17
   \   00000024   E000               LDI     R16, 0
   \   00000026   8300               ST      Z, R16
    248              txBuf[My485UART.TxFirst++] = ECMD_NMDWOACK >> 8;      // End command hb
   \   00000028   ....               LDI     R30, LOW(My485UART)
   \   0000002A   ....               LDI     R31, (My485UART) >> 8
   \   0000002C   8100               LD      R16, Z
   \   0000002E   8111               LDD     R17, Z+1
   \   00000030   01C8               MOVW    R25:R24, R17:R16
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   ....               LDI     R30, LOW(My485UART)
   \   00000036   ....               LDI     R31, (My485UART) >> 8
   \   00000038   8380               ST      Z, R24
   \   0000003A   8391               STD     Z+1, R25
   \   0000003C   01FD               MOVW    R31:R30, R27:R26
   \   0000003E   0FE0               ADD     R30, R16
   \   00000040   1FF1               ADC     R31, R17
   \   00000042   E000               LDI     R16, 0
   \   00000044   8300               ST      Z, R16
    249              txBuf[My485UART.TxFirst++] = 0x00;                    // End data
   \   00000046   ....               LDI     R30, LOW(My485UART)
   \   00000048   ....               LDI     R31, (My485UART) >> 8
   \   0000004A   8100               LD      R16, Z
   \   0000004C   8111               LDD     R17, Z+1
   \   0000004E   01C8               MOVW    R25:R24, R17:R16
   \   00000050   9601               ADIW    R25:R24, 1
   \   00000052   ....               LDI     R30, LOW(My485UART)
   \   00000054   ....               LDI     R31, (My485UART) >> 8
   \   00000056   8380               ST      Z, R24
   \   00000058   8391               STD     Z+1, R25
   \   0000005A   01FD               MOVW    R31:R30, R27:R26
   \   0000005C   0FE0               ADD     R30, R16
   \   0000005E   1FF1               ADC     R31, R17
   \   00000060   E000               LDI     R16, 0
   \   00000062   8300               ST      Z, R16
    250          
    251              txBuf[My485UART.TxFirst++] = My485UART.TxSeqCnt++;  // Sequence counter
   \   00000064   ....               LDI     R30, LOW(My485UART)
   \   00000066   ....               LDI     R31, (My485UART) >> 8
   \   00000068   8100               LD      R16, Z
   \   0000006A   8111               LDD     R17, Z+1
   \   0000006C   01C8               MOVW    R25:R24, R17:R16
   \   0000006E   9601               ADIW    R25:R24, 1
   \   00000070   ....               LDI     R30, LOW(My485UART)
   \   00000072   ....               LDI     R31, (My485UART) >> 8
   \   00000074   8380               ST      Z, R24
   \   00000076   8391               STD     Z+1, R25
   \   00000078   9120....           LDS     R18, (My485UART + 7)
   \   0000007C   01FD               MOVW    R31:R30, R27:R26
   \   0000007E   0FE0               ADD     R30, R16
   \   00000080   1FF1               ADC     R31, R17
   \   00000082   8320               ST      Z, R18
   \   00000084   9100....           LDS     R16, (My485UART + 7)
   \   00000088   9503               INC     R16
   \   0000008A   9300....           STS     (My485UART + 7), R16
    252          
    253              txBuf[ 8] = My485UART.TxFirst - 2;                     // correct length because stx's
   \   0000008E   ....               LDI     R30, LOW(My485UART)
   \   00000090   ....               LDI     R31, (My485UART) >> 8
   \   00000092   8100               LD      R16, Z
   \   00000094   8111               LDD     R17, Z+1
   \   00000096   5002               SUBI    R16, 2
   \   00000098   01FD               MOVW    R31:R30, R27:R26
   \   0000009A   8700               STD     Z+8, R16
    254              txBuf[ 9] = (My485UART.TxFirst - 2) >> 8;              // packet len high
   \   0000009C   ....               LDI     R30, LOW(My485UART)
   \   0000009E   ....               LDI     R31, (My485UART) >> 8
   \   000000A0   8180               LD      R24, Z
   \   000000A2   8191               LDD     R25, Z+1
   \   000000A4   9702               SBIW    R25:R24, 2
   \   000000A6   2F89               MOV     R24, R25
   \   000000A8   E090               LDI     R25, 0
   \   000000AA   01FD               MOVW    R31:R30, R27:R26
   \   000000AC   8781               STD     Z+9, R24
    255              txBuf[10] = CalcDSTxChecksum( 6);                       // Get header checksum
   \   000000AE   E006               LDI     R16, 6
   \   000000B0   E010               LDI     R17, 0
   \   000000B2   ....               RCALL   CalcDSTxChecksum
   \   000000B4   01FD               MOVW    R31:R30, R27:R26
   \   000000B6   8702               STD     Z+10, R16
    256              unsigned PacketStart = My485UART.TxFirst;
   \   000000B8   ....               LDI     R30, LOW(My485UART)
   \   000000BA   ....               LDI     R31, (My485UART) >> 8
   \   000000BC   8180               LD      R24, Z
   \   000000BE   8191               LDD     R25, Z+1
    257              txBuf[My485UART.TxFirst]      = CalcDSTxChecksum(PacketStart - 4); // Get checksum
   \   000000C0   ....               LDI     R30, LOW(My485UART)
   \   000000C2   ....               LDI     R31, (My485UART) >> 8
   \   000000C4   8000               LD      R0, Z
   \   000000C6   8011               LDD     R1, Z+1
   \   000000C8   018C               MOVW    R17:R16, R25:R24
   \   000000CA   5004               SUBI    R16, 4
   \   000000CC   4010               SBCI    R17, 0
   \   000000CE   ....               RCALL   CalcDSTxChecksum
   \   000000D0   01FD               MOVW    R31:R30, R27:R26
   \   000000D2   0DE0               ADD     R30, R0
   \   000000D4   1DF1               ADC     R31, R1
   \   000000D6   8300               ST      Z, R16
    258              My485UART.TxFirst++;                                  // OBS!! must be inc here due to ANSI standard !!!!
   \   000000D8   ....               LDI     R30, LOW(My485UART)
   \   000000DA   ....               LDI     R31, (My485UART) >> 8
   \   000000DC   8100               LD      R16, Z
   \   000000DE   8111               LDD     R17, Z+1
   \   000000E0   5F0F               SUBI    R16, 255
   \   000000E2   4F1F               SBCI    R17, 255
   \   000000E4   8300               ST      Z, R16
   \   000000E6   8311               STD     Z+1, R17
    259          
    260              txBuf[My485UART.TxFirst++]    = ANPRO10_EOT;          // End of transmission
   \   000000E8   ....               LDI     R30, LOW(My485UART)
   \   000000EA   ....               LDI     R31, (My485UART) >> 8
   \   000000EC   8120               LD      R18, Z
   \   000000EE   8131               LDD     R19, Z+1
   \   000000F0   0189               MOVW    R17:R16, R19:R18
   \   000000F2   5F0F               SUBI    R16, 255
   \   000000F4   4F1F               SBCI    R17, 255
   \   000000F6   ....               LDI     R30, LOW(My485UART)
   \   000000F8   ....               LDI     R31, (My485UART) >> 8
   \   000000FA   8300               ST      Z, R16
   \   000000FC   8311               STD     Z+1, R17
   \   000000FE   01FD               MOVW    R31:R30, R27:R26
   \   00000100   0FE2               ADD     R30, R18
   \   00000102   1FF3               ADC     R31, R19
   \   00000104   E004               LDI     R16, 4
   \   00000106   8300               ST      Z, R16
    261           //   txBuf[My485UART.TxFirst++]    = ANPRO10_EOT;          // End of transmission
    262              My485UART.TxCount             = My485UART.TxFirst;  //bytes to send
   \   00000108   ....               LDI     R30, LOW(My485UART)
   \   0000010A   ....               LDI     R31, (My485UART) >> 8
   \   0000010C   8100               LD      R16, Z
   \   0000010E   8111               LDD     R17, Z+1
   \   00000110   ....               LDI     R30, LOW(My485UART)
   \   00000112   ....               LDI     R31, (My485UART) >> 8
   \   00000114   8304               STD     Z+4, R16
   \   00000116   8315               STD     Z+5, R17
    263              My485UART.TxLast 			    = 0;                    // reset cunter
   \   00000118   ....               LDI     R30, LOW(My485UART)
   \   0000011A   ....               LDI     R31, (My485UART) >> 8
   \   0000011C   E000               LDI     R16, 0
   \   0000011E   E010               LDI     R17, 0
   \   00000120   8302               STD     Z+2, R16
   \   00000122   8313               STD     Z+3, R17
    264              // Turn on TXE for channel
    265              My_SetBit(PORTE, 0x04);                                 // TXE0 on
   \   00000124   9100....           LDS     R16, (OS_Global + 1)
   \   00000128   7F00               ANDI    R16, 0xF0
   \   0000012A   2300               TST     R16
   \   0000012C   F021               BREQ    ??My485UART_BuildTail_0
   \   0000012E   E909               LDI     R16, 153
   \   00000130   E010               LDI     R17, 0
   \   00000132   ........           CALL    OS_Error
   \                     ??My485UART_BuildTail_0:
   \   00000136   94F8               cli
   \   00000138   9100....           LDS     R16, (OS_Global + 1)
   \   0000013C   9503               INC     R16
   \   0000013E   9300....           STS     (OS_Global + 1), R16
   \   00000142   9A72               SBI     0x0E, 0x02
   \   00000144   9100....           LDS     R16, (OS_Global + 1)
   \   00000148   7F00               ANDI    R16, 0xF0
   \   0000014A   2300               TST     R16
   \   0000014C   F021               BREQ    ??My485UART_BuildTail_1
   \   0000014E   E909               LDI     R16, 153
   \   00000150   E010               LDI     R17, 0
   \   00000152   ........           CALL    OS_Error
   \                     ??My485UART_BuildTail_1:
   \   00000156   9100....           LDS     R16, (OS_Global + 1)
   \   0000015A   950A               DEC     R16
   \   0000015C   9300....           STS     (OS_Global + 1), R16
   \   00000160   9100....           LDS     R16, (OS_Global + 1)
   \   00000164   2300               TST     R16
   \   00000166   F409               BRNE    ??My485UART_BuildTail_2
   \   00000168   9478               sei
    266              OS_Delay(2);                                            // Ensure some settling time
   \                     ??My485UART_BuildTail_2:
   \   0000016A   E002               LDI     R16, 2
   \   0000016C   E010               LDI     R17, 0
   \   0000016E   ........           CALL    OS_Delay
    267              UCSR0B |= __BIT_MASK(UDRIE0);                           // start sending by enableing interrupt
   \   00000172   910000C1           LDS     R16, 193
   \   00000176   6200               ORI     R16, 0x20
   \   00000178   930000C1           STS     193, R16
    268              OS_WaitEvent(UART0_EVENT_TX_COMPLETE);
   \   0000017C   E001               LDI     R16, 1
   \   0000017E   ........           CALL    OS_WaitEvent
    269          
    270          }
   \   00000182   E0E4               LDI     R30, 4
   \   00000184   ........           JMP     ?EPILOGUE_B4_L09
   \   00000188                      REQUIRE _A_PORTE
   \   00000188                      REQUIRE _A_UCSR0B
    271          
    272          /*************************************************************************
    273          *
    274          * Build datablock for card status
    275          *
    276          *************************************************************************/
    277          

   \                                 In  segment CODE, align 2, keep-with-next
    278          void BuildStatusData(void) {
   \                     BuildStatusData:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    279              if ( My485UART.TxFirst < TXSIZE_UART -20 ) {
   \   00000004   ....               LDI     R30, LOW(My485UART)
   \   00000006   ....               LDI     R31, (My485UART) >> 8
   \   00000008   8100               LD      R16, Z
   \   0000000A   8111               LDD     R17, Z+1
   \   0000000C   370C               CPI     R16, 124
   \   0000000E   E021               LDI     R18, 1
   \   00000010   0712               CPC     R17, R18
   \   00000012   F008               BRCS    $+2+2
   \   00000014   C129               RJMP    ??BuildStatusData_0
    280                  short ntna;
    281                  My485UART.RxSendReply = true;                               // flag for answering
   \   00000016   E001               LDI     R16, 1
   \   00000018   9300....           STS     (My485UART + 675), R16
    282          
    283                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STATUS & 0xff;
   \   0000001C   ....               LDI     R30, LOW(My485UART)
   \   0000001E   ....               LDI     R31, (My485UART) >> 8
   \   00000020   8100               LD      R16, Z
   \   00000022   8111               LDD     R17, Z+1
   \   00000024   01C8               MOVW    R25:R24, R17:R16
   \   00000026   9601               ADIW    R25:R24, 1
   \   00000028   ....               LDI     R30, LOW(My485UART)
   \   0000002A   ....               LDI     R31, (My485UART) >> 8
   \   0000002C   8380               ST      Z, R24
   \   0000002E   8391               STD     Z+1, R25
   \   00000030   01F8               MOVW    R31:R30, R17:R16
   \   00000032   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000034   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000036   EE09               LDI     R16, 233
   \   00000038   8300               ST      Z, R16
    284                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STATUS >> 8;
   \   0000003A   ....               LDI     R30, LOW(My485UART)
   \   0000003C   ....               LDI     R31, (My485UART) >> 8
   \   0000003E   8100               LD      R16, Z
   \   00000040   8111               LDD     R17, Z+1
   \   00000042   01C8               MOVW    R25:R24, R17:R16
   \   00000044   9601               ADIW    R25:R24, 1
   \   00000046   ....               LDI     R30, LOW(My485UART)
   \   00000048   ....               LDI     R31, (My485UART) >> 8
   \   0000004A   8380               ST      Z, R24
   \   0000004C   8391               STD     Z+1, R25
   \   0000004E   01F8               MOVW    R31:R30, R17:R16
   \   00000050   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000052   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000054   E003               LDI     R16, 3
   \   00000056   8300               ST      Z, R16
    285                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   00000058   ....               LDI     R30, LOW(My485UART)
   \   0000005A   ....               LDI     R31, (My485UART) >> 8
   \   0000005C   8100               LD      R16, Z
   \   0000005E   8111               LDD     R17, Z+1
   \   00000060   01D8               MOVW    R27:R26, R17:R16
    286                  My485UART.TxFirst += 2;                                                       // two byte length
   \   00000062   ....               LDI     R30, LOW(My485UART)
   \   00000064   ....               LDI     R31, (My485UART) >> 8
   \   00000066   8100               LD      R16, Z
   \   00000068   8111               LDD     R17, Z+1
   \   0000006A   5F0E               SUBI    R16, 254
   \   0000006C   4F1F               SBCI    R17, 255
   \   0000006E   8300               ST      Z, R16
   \   00000070   8311               STD     Z+1, R17
    287                  My485UART.pTxBuffer[My485UART.TxFirst++] = 0;                               // channel fixed to 0
   \   00000072   ....               LDI     R30, LOW(My485UART)
   \   00000074   ....               LDI     R31, (My485UART) >> 8
   \   00000076   8100               LD      R16, Z
   \   00000078   8111               LDD     R17, Z+1
   \   0000007A   01C8               MOVW    R25:R24, R17:R16
   \   0000007C   9601               ADIW    R25:R24, 1
   \   0000007E   ....               LDI     R30, LOW(My485UART)
   \   00000080   ....               LDI     R31, (My485UART) >> 8
   \   00000082   8380               ST      Z, R24
   \   00000084   8391               STD     Z+1, R25
   \   00000086   01F8               MOVW    R31:R30, R17:R16
   \   00000088   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   0000008A   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000008C   E000               LDI     R16, 0
   \   0000008E   8300               ST      Z, R16
    288                  My485UART.pTxBuffer[My485UART.TxFirst++] = DEVICE_IO + UnitID;              // Product ID
   \   00000090   ....               LDI     R30, LOW(My485UART)
   \   00000092   ....               LDI     R31, (My485UART) >> 8
   \   00000094   8120               LD      R18, Z
   \   00000096   8131               LDD     R19, Z+1
   \   00000098   01C9               MOVW    R25:R24, R19:R18
   \   0000009A   9601               ADIW    R25:R24, 1
   \   0000009C   ....               LDI     R30, LOW(My485UART)
   \   0000009E   ....               LDI     R31, (My485UART) >> 8
   \   000000A0   8380               ST      Z, R24
   \   000000A2   8391               STD     Z+1, R25
   \   000000A4   9100....           LDS     R16, UnitID
   \   000000A8   5F00               SUBI    R16, 240
   \   000000AA   01F9               MOVW    R31:R30, R19:R18
   \   000000AC   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000AE   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000B0   8300               ST      Z, R16
    289                  My485UART.pTxBuffer[My485UART.TxFirst++] = MyAddress();                     // unit adddress
   \   000000B2   ....               LDI     R30, LOW(My485UART)
   \   000000B4   ....               LDI     R31, (My485UART) >> 8
   \   000000B6   8180               LD      R24, Z
   \   000000B8   8191               LDD     R25, Z+1
   \   000000BA   018C               MOVW    R17:R16, R25:R24
   \   000000BC   5F0F               SUBI    R16, 255
   \   000000BE   4F1F               SBCI    R17, 255
   \   000000C0   ....               LDI     R30, LOW(My485UART)
   \   000000C2   ....               LDI     R31, (My485UART) >> 8
   \   000000C4   8300               ST      Z, R16
   \   000000C6   8311               STD     Z+1, R17
   \   000000C8   ........           CALL    MyAddress
   \   000000CC   01FC               MOVW    R31:R30, R25:R24
   \   000000CE   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000D0   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000D2   8300               ST      Z, R16
    290                  My485UART.pTxBuffer[My485UART.TxFirst++] = PROG_VERSION;                    // software version */
   \   000000D4   ....               LDI     R30, LOW(My485UART)
   \   000000D6   ....               LDI     R31, (My485UART) >> 8
   \   000000D8   8100               LD      R16, Z
   \   000000DA   8111               LDD     R17, Z+1
   \   000000DC   01C8               MOVW    R25:R24, R17:R16
   \   000000DE   9601               ADIW    R25:R24, 1
   \   000000E0   ....               LDI     R30, LOW(My485UART)
   \   000000E2   ....               LDI     R31, (My485UART) >> 8
   \   000000E4   8380               ST      Z, R24
   \   000000E6   8391               STD     Z+1, R25
   \   000000E8   01F8               MOVW    R31:R30, R17:R16
   \   000000EA   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000EC   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000EE   E00E               LDI     R16, 14
   \   000000F0   8300               ST      Z, R16
    291                  My485UART.pTxBuffer[My485UART.TxFirst++] = COMP_VERSION;                    // cpmpability version
   \   000000F2   ....               LDI     R30, LOW(My485UART)
   \   000000F4   ....               LDI     R31, (My485UART) >> 8
   \   000000F6   8100               LD      R16, Z
   \   000000F8   8111               LDD     R17, Z+1
   \   000000FA   01C8               MOVW    R25:R24, R17:R16
   \   000000FC   9601               ADIW    R25:R24, 1
   \   000000FE   ....               LDI     R30, LOW(My485UART)
   \   00000100   ....               LDI     R31, (My485UART) >> 8
   \   00000102   8380               ST      Z, R24
   \   00000104   8391               STD     Z+1, R25
   \   00000106   01F8               MOVW    R31:R30, R17:R16
   \   00000108   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   0000010A   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000010C   E002               LDI     R16, 2
   \   0000010E   8300               ST      Z, R16
    292                  My485UART.pTxBuffer[My485UART.TxFirst++] = STORE_VERSION;                   // cpmpability version
   \   00000110   ....               LDI     R30, LOW(My485UART)
   \   00000112   ....               LDI     R31, (My485UART) >> 8
   \   00000114   8100               LD      R16, Z
   \   00000116   8111               LDD     R17, Z+1
   \   00000118   01C8               MOVW    R25:R24, R17:R16
   \   0000011A   9601               ADIW    R25:R24, 1
   \   0000011C   ....               LDI     R30, LOW(My485UART)
   \   0000011E   ....               LDI     R31, (My485UART) >> 8
   \   00000120   8380               ST      Z, R24
   \   00000122   8391               STD     Z+1, R25
   \   00000124   01F8               MOVW    R31:R30, R17:R16
   \   00000126   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000128   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000012A   E003               LDI     R16, 3
   \   0000012C   8300               ST      Z, R16
    293                  My485UART.pTxBuffer[My485UART.TxFirst++] = (RXSIZE_UART & 0xff);            // rx buffer size
   \   0000012E   ....               LDI     R30, LOW(My485UART)
   \   00000130   ....               LDI     R31, (My485UART) >> 8
   \   00000132   8100               LD      R16, Z
   \   00000134   8111               LDD     R17, Z+1
   \   00000136   01C8               MOVW    R25:R24, R17:R16
   \   00000138   9601               ADIW    R25:R24, 1
   \   0000013A   ....               LDI     R30, LOW(My485UART)
   \   0000013C   ....               LDI     R31, (My485UART) >> 8
   \   0000013E   8380               ST      Z, R24
   \   00000140   8391               STD     Z+1, R25
   \   00000142   01F8               MOVW    R31:R30, R17:R16
   \   00000144   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000146   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000148   E906               LDI     R16, 150
   \   0000014A   8300               ST      Z, R16
    294                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((RXSIZE_UART >> 8) & 0xff);     // rx buffer size
   \   0000014C   ....               LDI     R30, LOW(My485UART)
   \   0000014E   ....               LDI     R31, (My485UART) >> 8
   \   00000150   8100               LD      R16, Z
   \   00000152   8111               LDD     R17, Z+1
   \   00000154   01C8               MOVW    R25:R24, R17:R16
   \   00000156   9601               ADIW    R25:R24, 1
   \   00000158   ....               LDI     R30, LOW(My485UART)
   \   0000015A   ....               LDI     R31, (My485UART) >> 8
   \   0000015C   8380               ST      Z, R24
   \   0000015E   8391               STD     Z+1, R25
   \   00000160   01F8               MOVW    R31:R30, R17:R16
   \   00000162   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000164   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000166   E000               LDI     R16, 0
   \   00000168   8300               ST      Z, R16
    295                  My485UART.pTxBuffer[My485UART.TxFirst++] = (TXSIZE_UART & 0xff);            // tx buffer size
   \   0000016A   ....               LDI     R30, LOW(My485UART)
   \   0000016C   ....               LDI     R31, (My485UART) >> 8
   \   0000016E   8100               LD      R16, Z
   \   00000170   8111               LDD     R17, Z+1
   \   00000172   01C8               MOVW    R25:R24, R17:R16
   \   00000174   9601               ADIW    R25:R24, 1
   \   00000176   ....               LDI     R30, LOW(My485UART)
   \   00000178   ....               LDI     R31, (My485UART) >> 8
   \   0000017A   8380               ST      Z, R24
   \   0000017C   8391               STD     Z+1, R25
   \   0000017E   01F8               MOVW    R31:R30, R17:R16
   \   00000180   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000182   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000184   E900               LDI     R16, 144
   \   00000186   8300               ST      Z, R16
    296                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);     // tx buffer size
   \   00000188   ....               LDI     R30, LOW(My485UART)
   \   0000018A   ....               LDI     R31, (My485UART) >> 8
   \   0000018C   8100               LD      R16, Z
   \   0000018E   8111               LDD     R17, Z+1
   \   00000190   01C8               MOVW    R25:R24, R17:R16
   \   00000192   9601               ADIW    R25:R24, 1
   \   00000194   ....               LDI     R30, LOW(My485UART)
   \   00000196   ....               LDI     R31, (My485UART) >> 8
   \   00000198   8380               ST      Z, R24
   \   0000019A   8391               STD     Z+1, R25
   \   0000019C   01F8               MOVW    R31:R30, R17:R16
   \   0000019E   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000001A0   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000001A2   E001               LDI     R16, 1
   \   000001A4   8300               ST      Z, R16
    297                  My485UART.pTxBuffer[My485UART.TxFirst++] = RestartStatus;                   // restart flag
   \   000001A6   ....               LDI     R30, LOW(My485UART)
   \   000001A8   ....               LDI     R31, (My485UART) >> 8
   \   000001AA   8100               LD      R16, Z
   \   000001AC   8111               LDD     R17, Z+1
   \   000001AE   01C8               MOVW    R25:R24, R17:R16
   \   000001B0   9601               ADIW    R25:R24, 1
   \   000001B2   ....               LDI     R30, LOW(My485UART)
   \   000001B4   ....               LDI     R31, (My485UART) >> 8
   \   000001B6   8380               ST      Z, R24
   \   000001B8   8391               STD     Z+1, R25
   \   000001BA   9120....           LDS     R18, RestartStatus
   \   000001BE   01F8               MOVW    R31:R30, R17:R16
   \   000001C0   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000001C2   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000001C4   8320               ST      Z, R18
    298                  My485UART.pTxBuffer[My485UART.TxFirst++] = PROGTYPE_APP;                    // Application program
   \   000001C6   ....               LDI     R30, LOW(My485UART)
   \   000001C8   ....               LDI     R31, (My485UART) >> 8
   \   000001CA   8100               LD      R16, Z
   \   000001CC   8111               LDD     R17, Z+1
   \   000001CE   01C8               MOVW    R25:R24, R17:R16
   \   000001D0   9601               ADIW    R25:R24, 1
   \   000001D2   ....               LDI     R30, LOW(My485UART)
   \   000001D4   ....               LDI     R31, (My485UART) >> 8
   \   000001D6   8380               ST      Z, R24
   \   000001D8   8391               STD     Z+1, R25
   \   000001DA   01F8               MOVW    R31:R30, R17:R16
   \   000001DC   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000001DE   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000001E0   E001               LDI     R16, 1
   \   000001E2   8300               ST      Z, R16
    299                  My485UART.pTxBuffer[My485UART.TxFirst++] = RestartCnt & 0xff;               // Unit restart count
   \   000001E4   ....               LDI     R30, LOW(My485UART)
   \   000001E6   ....               LDI     R31, (My485UART) >> 8
   \   000001E8   8120               LD      R18, Z
   \   000001EA   8131               LDD     R19, Z+1
   \   000001EC   01C9               MOVW    R25:R24, R19:R18
   \   000001EE   9601               ADIW    R25:R24, 1
   \   000001F0   ....               LDI     R30, LOW(My485UART)
   \   000001F2   ....               LDI     R31, (My485UART) >> 8
   \   000001F4   8380               ST      Z, R24
   \   000001F6   8391               STD     Z+1, R25
   \   000001F8   ....               LDI     R30, LOW(RestartCnt)
   \   000001FA   ....               LDI     R31, (RestartCnt) >> 8
   \   000001FC   8100               LD      R16, Z
   \   000001FE   8111               LDD     R17, Z+1
   \   00000200   01F9               MOVW    R31:R30, R19:R18
   \   00000202   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000204   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000206   8300               ST      Z, R16
    300                  My485UART.pTxBuffer[My485UART.TxFirst++] = (RestartCnt >> 8 ) & 0xff;       // Unit restart count
   \   00000208   ....               LDI     R30, LOW(My485UART)
   \   0000020A   ....               LDI     R31, (My485UART) >> 8
   \   0000020C   8120               LD      R18, Z
   \   0000020E   8131               LDD     R19, Z+1
   \   00000210   01C9               MOVW    R25:R24, R19:R18
   \   00000212   9601               ADIW    R25:R24, 1
   \   00000214   ....               LDI     R30, LOW(My485UART)
   \   00000216   ....               LDI     R31, (My485UART) >> 8
   \   00000218   8380               ST      Z, R24
   \   0000021A   8391               STD     Z+1, R25
   \   0000021C   ....               LDI     R30, LOW(RestartCnt)
   \   0000021E   ....               LDI     R31, (RestartCnt) >> 8
   \   00000220   8100               LD      R16, Z
   \   00000222   8111               LDD     R17, Z+1
   \   00000224   2F01               MOV     R16, R17
   \   00000226   0F11               LSL     R17
   \   00000228   0B11               SBC     R17, R17
   \   0000022A   01F9               MOVW    R31:R30, R19:R18
   \   0000022C   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   0000022E   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000230   8300               ST      Z, R16
    301          
    302                  My485UART.pTxBuffer[ntna] =   (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   00000232   ....               LDI     R30, LOW(My485UART)
   \   00000234   ....               LDI     R31, (My485UART) >> 8
   \   00000236   8100               LD      R16, Z
   \   00000238   8111               LDD     R17, Z+1
   \   0000023A   2F1A               MOV     R17, R26
   \   0000023C   1B01               SUB     R16, R17
   \   0000023E   5002               SUBI    R16, 2
   \   00000240   01FD               MOVW    R31:R30, R27:R26
   \   00000242   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000244   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000246   8300               ST      Z, R16
    303                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000248   ....               LDI     R30, LOW(My485UART)
   \   0000024A   ....               LDI     R31, (My485UART) >> 8
   \   0000024C   8180               LD      R24, Z
   \   0000024E   8191               LDD     R25, Z+1
   \   00000250   1B8A               SUB     R24, R26
   \   00000252   0B9B               SBC     R25, R27
   \   00000254   9702               SBIW    R25:R24, 2
   \   00000256   2F89               MOV     R24, R25
   \   00000258   E090               LDI     R25, 0
   \   0000025A   01FD               MOVW    R31:R30, R27:R26
   \   0000025C   ....               SUBI    R30, LOW((-(My485UART + 125) & 0xFFFF))
   \   0000025E   ....               SBCI    R31, HIGH((-(My485UART + 125) & 0xFFFF))
   \   00000260   8380               ST      Z, R24
    304          
    305                  RestartStatus = 0;                                                       // set reset stat to 0 = read
   \   00000262   E000               LDI     R16, 0
   \   00000264   9300....           STS     RestartStatus, R16
    306              }
    307          }
   \                     ??BuildStatusData_0:
   \   00000268   E0E4               LDI     R30, 4
   \   0000026A   ........           JMP     ?EPILOGUE_B4_L09
   \   0000026E                      REQUIRE RestartCnt
    308          
    309          /*************************************************************************
    310          *
    311          * Build EEPROM data package
    312          *
    313          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    314          void BuildEEPROMData(char *pointer) {
   \                     BuildEEPROMData:
   \   00000000   ........           CALL    ?PROLOGUE5_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004   01D8               MOVW    R27:R26, R17:R16
    315              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000006   ....               LDI     R30, LOW(My485UART)
   \   00000008   ....               LDI     R31, (My485UART) >> 8
   \   0000000A   8100               LD      R16, Z
   \   0000000C   8111               LDD     R17, Z+1
   \   0000000E   370C               CPI     R16, 124
   \   00000010   E021               LDI     R18, 1
   \   00000012   0712               CPC     R17, R18
   \   00000014   F008               BRCS    $+2+2
   \   00000016   C092               RJMP    ??BuildEEPROMData_0
    316                  short ntna;
    317                  char channel;
    318                  My485UART.RxSendReply = true;                               // flag for answering
   \   00000018   E001               LDI     R16, 1
   \   0000001A   9300....           STS     (My485UART + 675), R16
    319          
    320                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_EEPROM_DATA & 0xff;
   \   0000001E   ....               LDI     R30, LOW(My485UART)
   \   00000020   ....               LDI     R31, (My485UART) >> 8
   \   00000022   8120               LD      R18, Z
   \   00000024   8131               LDD     R19, Z+1
   \   00000026   0189               MOVW    R17:R16, R19:R18
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   ....               LDI     R30, LOW(My485UART)
   \   0000002E   ....               LDI     R31, (My485UART) >> 8
   \   00000030   8300               ST      Z, R16
   \   00000032   8311               STD     Z+1, R17
   \   00000034   01F9               MOVW    R31:R30, R19:R18
   \   00000036   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000038   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000003A   E309               LDI     R16, 57
   \   0000003C   8300               ST      Z, R16
    321                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_EEPROM_DATA >> 8;
   \   0000003E   ....               LDI     R30, LOW(My485UART)
   \   00000040   ....               LDI     R31, (My485UART) >> 8
   \   00000042   8120               LD      R18, Z
   \   00000044   8131               LDD     R19, Z+1
   \   00000046   0189               MOVW    R17:R16, R19:R18
   \   00000048   5F0F               SUBI    R16, 255
   \   0000004A   4F1F               SBCI    R17, 255
   \   0000004C   ....               LDI     R30, LOW(My485UART)
   \   0000004E   ....               LDI     R31, (My485UART) >> 8
   \   00000050   8300               ST      Z, R16
   \   00000052   8311               STD     Z+1, R17
   \   00000054   01F9               MOVW    R31:R30, R19:R18
   \   00000056   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000058   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000005A   E004               LDI     R16, 4
   \   0000005C   8300               ST      Z, R16
    322                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   0000005E   ....               LDI     R30, LOW(My485UART)
   \   00000060   ....               LDI     R31, (My485UART) >> 8
   \   00000062   8100               LD      R16, Z
   \   00000064   8111               LDD     R17, Z+1
   \   00000066   01C8               MOVW    R25:R24, R17:R16
    323                  My485UART.TxFirst += 2;                                      // two byte length
   \   00000068   ....               LDI     R30, LOW(My485UART)
   \   0000006A   ....               LDI     R31, (My485UART) >> 8
   \   0000006C   8100               LD      R16, Z
   \   0000006E   8111               LDD     R17, Z+1
   \   00000070   5F0E               SUBI    R16, 254
   \   00000072   4F1F               SBCI    R17, 255
   \   00000074   8300               ST      Z, R16
   \   00000076   8311               STD     Z+1, R17
    324          
    325                  channel = pointer[0];
   \   00000078   910C               LD      R16, X
   \   0000007A   2E40               MOV     R4, R16
    326                  My485UART.pTxBuffer[My485UART.TxFirst++] = channel; //channel
   \   0000007C   ....               LDI     R30, LOW(My485UART)
   \   0000007E   ....               LDI     R31, (My485UART) >> 8
   \   00000080   8120               LD      R18, Z
   \   00000082   8131               LDD     R19, Z+1
   \   00000084   0189               MOVW    R17:R16, R19:R18
   \   00000086   5F0F               SUBI    R16, 255
   \   00000088   4F1F               SBCI    R17, 255
   \   0000008A   ....               LDI     R30, LOW(My485UART)
   \   0000008C   ....               LDI     R31, (My485UART) >> 8
   \   0000008E   8300               ST      Z, R16
   \   00000090   8311               STD     Z+1, R17
   \   00000092   01F9               MOVW    R31:R30, R19:R18
   \   00000094   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000096   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000098   8240               ST      Z, R4
    327          
    328                  ReadEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&My485UART.pTxBuffer[My485UART.TxFirst]);
   \   0000009A   ....               LDI     R20, LOW((My485UART + 124))
   \   0000009C   ....               LDI     R21, HIGH((My485UART + 124))
   \   0000009E   ....               LDI     R30, LOW(My485UART)
   \   000000A0   ....               LDI     R31, (My485UART) >> 8
   \   000000A2   8100               LD      R16, Z
   \   000000A4   8111               LDD     R17, Z+1
   \   000000A6   0F40               ADD     R20, R16
   \   000000A8   1F51               ADC     R21, R17
   \   000000AA   E024               LDI     R18, 4
   \   000000AC   01BA               MOVW    R23:R22, R21:R20
   \   000000AE   2D04               MOV     R16, R4
   \   000000B0   E010               LDI     R17, 0
   \   000000B2   E048               LDI     R20, 8
   \   000000B4   E050               LDI     R21, 0
   \   000000B6   ........           CALL    ?S_EC_MUL_L02
   \   000000BA   01AB               MOVW    R21:R20, R23:R22
   \   000000BC   ........           CALL    ReadEEPROMBuffer
    329                  My485UART.TxFirst += sizeof(float);
   \   000000C0   ....               LDI     R30, LOW(My485UART)
   \   000000C2   ....               LDI     R31, (My485UART) >> 8
   \   000000C4   8100               LD      R16, Z
   \   000000C6   8111               LDD     R17, Z+1
   \   000000C8   5F0C               SUBI    R16, 252
   \   000000CA   4F1F               SBCI    R17, 255
   \   000000CC   8300               ST      Z, R16
   \   000000CE   8311               STD     Z+1, R17
    330                  ReadEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&My485UART.pTxBuffer[My485UART.TxFirst]);
   \   000000D0   ....               LDI     R20, LOW((My485UART + 124))
   \   000000D2   ....               LDI     R21, HIGH((My485UART + 124))
   \   000000D4   ....               LDI     R30, LOW(My485UART)
   \   000000D6   ....               LDI     R31, (My485UART) >> 8
   \   000000D8   8100               LD      R16, Z
   \   000000DA   8111               LDD     R17, Z+1
   \   000000DC   0F40               ADD     R20, R16
   \   000000DE   1F51               ADC     R21, R17
   \   000000E0   E024               LDI     R18, 4
   \   000000E2   01BA               MOVW    R23:R22, R21:R20
   \   000000E4   2D04               MOV     R16, R4
   \   000000E6   E010               LDI     R17, 0
   \   000000E8   E048               LDI     R20, 8
   \   000000EA   E050               LDI     R21, 0
   \   000000EC   ........           CALL    ?S_EC_MUL_L02
   \   000000F0   5F0C               SUBI    R16, 252
   \   000000F2   4F1F               SBCI    R17, 255
   \   000000F4   01AB               MOVW    R21:R20, R23:R22
   \   000000F6   ........           CALL    ReadEEPROMBuffer
    331                  My485UART.TxFirst += sizeof(float);
   \   000000FA   ....               LDI     R30, LOW(My485UART)
   \   000000FC   ....               LDI     R31, (My485UART) >> 8
   \   000000FE   8100               LD      R16, Z
   \   00000100   8111               LDD     R17, Z+1
   \   00000102   5F0C               SUBI    R16, 252
   \   00000104   4F1F               SBCI    R17, 255
   \   00000106   8300               ST      Z, R16
   \   00000108   8311               STD     Z+1, R17
    332          
    333                  My485UART.pTxBuffer[ntna] = (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   0000010A   ....               LDI     R30, LOW(My485UART)
   \   0000010C   ....               LDI     R31, (My485UART) >> 8
   \   0000010E   8100               LD      R16, Z
   \   00000110   8111               LDD     R17, Z+1
   \   00000112   2F18               MOV     R17, R24
   \   00000114   1B01               SUB     R16, R17
   \   00000116   5002               SUBI    R16, 2
   \   00000118   01FC               MOVW    R31:R30, R25:R24
   \   0000011A   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   0000011C   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000011E   8300               ST      Z, R16
    334                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000120   ....               LDI     R30, LOW(My485UART)
   \   00000122   ....               LDI     R31, (My485UART) >> 8
   \   00000124   8100               LD      R16, Z
   \   00000126   8111               LDD     R17, Z+1
   \   00000128   1B08               SUB     R16, R24
   \   0000012A   0B19               SBC     R17, R25
   \   0000012C   5002               SUBI    R16, 2
   \   0000012E   4010               SBCI    R17, 0
   \   00000130   2F01               MOV     R16, R17
   \   00000132   E010               LDI     R17, 0
   \   00000134   01FC               MOVW    R31:R30, R25:R24
   \   00000136   ....               SUBI    R30, LOW((-(My485UART + 125) & 0xFFFF))
   \   00000138   ....               SBCI    R31, HIGH((-(My485UART + 125) & 0xFFFF))
   \   0000013A   8300               ST      Z, R16
    335              }
    336          }
   \                     ??BuildEEPROMData_0:
   \   0000013C   E0E5               LDI     R30, 5
   \   0000013E   ........           JMP     ?EPILOGUE_B5_L09
    337          
    338          
    339          /*************************************************************************
    340          *
    341          * Build datablock for Internal AD
    342          *
    343          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    344          void BuildADInt(char *pointer) {
   \                     BuildADInt:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    345              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000004   ....               LDI     R30, LOW(My485UART)
   \   00000006   ....               LDI     R31, (My485UART) >> 8
   \   00000008   8120               LD      R18, Z
   \   0000000A   8131               LDD     R19, Z+1
   \   0000000C   372C               CPI     R18, 124
   \   0000000E   E041               LDI     R20, 1
   \   00000010   0734               CPC     R19, R20
   \   00000012   F008               BRCS    $+2+2
   \   00000014   C07D               RJMP    ??BuildADInt_0
    346                  short ntna, i;
    347                  My485UART.RxSendReply = true;                               // flag for answering
   \   00000016   E041               LDI     R20, 1
   \   00000018   9340....           STS     (My485UART + 675), R20
    348          
    349                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_INT_DATA & 0xff;
   \   0000001C   ....               LDI     R30, LOW(My485UART)
   \   0000001E   ....               LDI     R31, (My485UART) >> 8
   \   00000020   8140               LD      R20, Z
   \   00000022   8151               LDD     R21, Z+1
   \   00000024   01DA               MOVW    R27:R26, R21:R20
   \   00000026   9611               ADIW    R27:R26, 1
   \   00000028   ....               LDI     R30, LOW(My485UART)
   \   0000002A   ....               LDI     R31, (My485UART) >> 8
   \   0000002C   83A0               ST      Z, R26
   \   0000002E   83B1               STD     Z+1, R27
   \   00000030   01FA               MOVW    R31:R30, R21:R20
   \   00000032   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000034   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000036   E443               LDI     R20, 67
   \   00000038   8340               ST      Z, R20
    350                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_INT_DATA >> 8;
   \   0000003A   ....               LDI     R30, LOW(My485UART)
   \   0000003C   ....               LDI     R31, (My485UART) >> 8
   \   0000003E   8140               LD      R20, Z
   \   00000040   8151               LDD     R21, Z+1
   \   00000042   01DA               MOVW    R27:R26, R21:R20
   \   00000044   9611               ADIW    R27:R26, 1
   \   00000046   ....               LDI     R30, LOW(My485UART)
   \   00000048   ....               LDI     R31, (My485UART) >> 8
   \   0000004A   83A0               ST      Z, R26
   \   0000004C   83B1               STD     Z+1, R27
   \   0000004E   01FA               MOVW    R31:R30, R21:R20
   \   00000050   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000052   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000054   E044               LDI     R20, 4
   \   00000056   8340               ST      Z, R20
    351                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   00000058   ....               LDI     R30, LOW(My485UART)
   \   0000005A   ....               LDI     R31, (My485UART) >> 8
   \   0000005C   8140               LD      R20, Z
   \   0000005E   8151               LDD     R21, Z+1
   \   00000060   019A               MOVW    R19:R18, R21:R20
    352                  My485UART.TxFirst += 2;                                      // two byte length
   \   00000062   ....               LDI     R30, LOW(My485UART)
   \   00000064   ....               LDI     R31, (My485UART) >> 8
   \   00000066   8140               LD      R20, Z
   \   00000068   8151               LDD     R21, Z+1
   \   0000006A   5F4E               SUBI    R20, 254
   \   0000006C   4F5F               SBCI    R21, 255
   \   0000006E   8340               ST      Z, R20
   \   00000070   8351               STD     Z+1, R21
    353          
    354                  for ( i = 0; i < 3; i++ ) {
   \   00000072   E080               LDI     R24, 0
   \   00000074   E090               LDI     R25, 0
   \                     ??BuildADInt_1:
   \   00000076   3083               CPI     R24, 3
   \   00000078   E040               LDI     R20, 0
   \   0000007A   0794               CPC     R25, R20
   \   0000007C   F58C               BRGE    ??BuildADInt_2
    355                      My485UART.pTxBuffer[My485UART.TxFirst++] = ADInt.Result[i];
   \   0000007E   ....               LDI     R30, LOW(My485UART)
   \   00000080   ....               LDI     R31, (My485UART) >> 8
   \   00000082   8160               LD      R22, Z
   \   00000084   8171               LDD     R23, Z+1
   \   00000086   01DB               MOVW    R27:R26, R23:R22
   \   00000088   9611               ADIW    R27:R26, 1
   \   0000008A   ....               LDI     R30, LOW(My485UART)
   \   0000008C   ....               LDI     R31, (My485UART) >> 8
   \   0000008E   83A0               ST      Z, R26
   \   00000090   83B1               STD     Z+1, R27
   \   00000092   01AC               MOVW    R21:R20, R25:R24
   \   00000094   0F44               LSL     R20
   \   00000096   1F55               ROL     R21
   \   00000098   01FA               MOVW    R31:R30, R21:R20
   \   0000009A   ....               SUBI    R30, LOW((-(ADInt) & 0xFFFF))
   \   0000009C   ....               SBCI    R31, (-(ADInt) & 0xFFFF) >> 8
   \   0000009E   8140               LD      R20, Z
   \   000000A0   8151               LDD     R21, Z+1
   \   000000A2   01FB               MOVW    R31:R30, R23:R22
   \   000000A4   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000A6   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000A8   8340               ST      Z, R20
    356                      My485UART.pTxBuffer[My485UART.TxFirst++] = ADInt.Result[i] >> 8;   // ADresult
   \   000000AA   ....               LDI     R30, LOW(My485UART)
   \   000000AC   ....               LDI     R31, (My485UART) >> 8
   \   000000AE   8160               LD      R22, Z
   \   000000B0   8171               LDD     R23, Z+1
   \   000000B2   01DB               MOVW    R27:R26, R23:R22
   \   000000B4   9611               ADIW    R27:R26, 1
   \   000000B6   ....               LDI     R30, LOW(My485UART)
   \   000000B8   ....               LDI     R31, (My485UART) >> 8
   \   000000BA   83A0               ST      Z, R26
   \   000000BC   83B1               STD     Z+1, R27
   \   000000BE   01AC               MOVW    R21:R20, R25:R24
   \   000000C0   0F44               LSL     R20
   \   000000C2   1F55               ROL     R21
   \   000000C4   01FA               MOVW    R31:R30, R21:R20
   \   000000C6   ....               SUBI    R30, LOW((-(ADInt) & 0xFFFF))
   \   000000C8   ....               SBCI    R31, (-(ADInt) & 0xFFFF) >> 8
   \   000000CA   8140               LD      R20, Z
   \   000000CC   8151               LDD     R21, Z+1
   \   000000CE   2F45               MOV     R20, R21
   \   000000D0   0F55               LSL     R21
   \   000000D2   0B55               SBC     R21, R21
   \   000000D4   01FB               MOVW    R31:R30, R23:R22
   \   000000D6   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000D8   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000DA   8340               ST      Z, R20
    357                  }
   \   000000DC   9601               ADIW    R25:R24, 1
   \   000000DE   CFCB               RJMP    ??BuildADInt_1
    358          
    359                  My485UART.pTxBuffer[ntna] = (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \                     ??BuildADInt_2:
   \   000000E0   ....               LDI     R30, LOW(My485UART)
   \   000000E2   ....               LDI     R31, (My485UART) >> 8
   \   000000E4   8140               LD      R20, Z
   \   000000E6   8151               LDD     R21, Z+1
   \   000000E8   2F52               MOV     R21, R18
   \   000000EA   1B45               SUB     R20, R21
   \   000000EC   5042               SUBI    R20, 2
   \   000000EE   01F9               MOVW    R31:R30, R19:R18
   \   000000F0   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000F2   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000F4   8340               ST      Z, R20
    360                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000F6   ....               LDI     R30, LOW(My485UART)
   \   000000F8   ....               LDI     R31, (My485UART) >> 8
   \   000000FA   81A0               LD      R26, Z
   \   000000FC   81B1               LDD     R27, Z+1
   \   000000FE   1BA2               SUB     R26, R18
   \   00000100   0BB3               SBC     R27, R19
   \   00000102   9712               SBIW    R27:R26, 2
   \   00000104   2FAB               MOV     R26, R27
   \   00000106   E0B0               LDI     R27, 0
   \   00000108   01F9               MOVW    R31:R30, R19:R18
   \   0000010A   ....               SUBI    R30, LOW((-(My485UART + 125) & 0xFFFF))
   \   0000010C   ....               SBCI    R31, HIGH((-(My485UART + 125) & 0xFFFF))
   \   0000010E   83A0               ST      Z, R26
    361              }
    362          
    363          }
   \                     ??BuildADInt_0:
   \   00000110   E0E4               LDI     R30, 4
   \   00000112   ........           JMP     ?EPILOGUE_B4_L09
    364          
    365          
    366          /*************************************************************************
    367          *
    368          * Build setup data package for AN-ZBHART
    369          *
    370          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    371          void BuildHartSetup( char *pointer) {
   \                     BuildHartSetup:
   \   00000000   010C               MOVW    R1:R0, R25:R24
    372              if ( My485UART.TxFirst < TXSIZE_UART - 20) {
   \   00000002   ....               LDI     R30, LOW(My485UART)
   \   00000004   ....               LDI     R31, (My485UART) >> 8
   \   00000006   8120               LD      R18, Z
   \   00000008   8131               LDD     R19, Z+1
   \   0000000A   372C               CPI     R18, 124
   \   0000000C   E041               LDI     R20, 1
   \   0000000E   0734               CPC     R19, R20
   \   00000010   F008               BRCS    $+2+2
   \   00000012   C06C               RJMP    ??BuildHartSetup_0
    373                  short ntna;
    374                  My485UART.RxSendReply = true;                               // flag for answering
   \   00000014   E041               LDI     R20, 1
   \   00000016   9340....           STS     (My485UART + 675), R20
    375          
    376                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_SETUP & 0xff;
   \   0000001A   ....               LDI     R30, LOW(My485UART)
   \   0000001C   ....               LDI     R31, (My485UART) >> 8
   \   0000001E   8140               LD      R20, Z
   \   00000020   8151               LDD     R21, Z+1
   \   00000022   01CA               MOVW    R25:R24, R21:R20
   \   00000024   9601               ADIW    R25:R24, 1
   \   00000026   ....               LDI     R30, LOW(My485UART)
   \   00000028   ....               LDI     R31, (My485UART) >> 8
   \   0000002A   8380               ST      Z, R24
   \   0000002C   8391               STD     Z+1, R25
   \   0000002E   01FA               MOVW    R31:R30, R21:R20
   \   00000030   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000032   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000034   EE4D               LDI     R20, 237
   \   00000036   8340               ST      Z, R20
    377                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_SETUP >> 8;
   \   00000038   ....               LDI     R30, LOW(My485UART)
   \   0000003A   ....               LDI     R31, (My485UART) >> 8
   \   0000003C   8140               LD      R20, Z
   \   0000003E   8151               LDD     R21, Z+1
   \   00000040   01CA               MOVW    R25:R24, R21:R20
   \   00000042   9601               ADIW    R25:R24, 1
   \   00000044   ....               LDI     R30, LOW(My485UART)
   \   00000046   ....               LDI     R31, (My485UART) >> 8
   \   00000048   8380               ST      Z, R24
   \   0000004A   8391               STD     Z+1, R25
   \   0000004C   01FA               MOVW    R31:R30, R21:R20
   \   0000004E   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000050   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000052   E044               LDI     R20, 4
   \   00000054   8340               ST      Z, R20
    378                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   00000056   ....               LDI     R30, LOW(My485UART)
   \   00000058   ....               LDI     R31, (My485UART) >> 8
   \   0000005A   8140               LD      R20, Z
   \   0000005C   8151               LDD     R21, Z+1
   \   0000005E   019A               MOVW    R19:R18, R21:R20
    379                  My485UART.TxFirst += 2;                                      // two byte length
   \   00000060   ....               LDI     R30, LOW(My485UART)
   \   00000062   ....               LDI     R31, (My485UART) >> 8
   \   00000064   8140               LD      R20, Z
   \   00000066   8151               LDD     R21, Z+1
   \   00000068   5F4E               SUBI    R20, 254
   \   0000006A   4F5F               SBCI    R21, 255
   \   0000006C   8340               ST      Z, R20
   \   0000006E   8351               STD     Z+1, R21
    380          
    381                  My485UART.pTxBuffer[My485UART.TxFirst++] = TData.Hart.PortUsed & 0xff;
   \   00000070   ....               LDI     R30, LOW(My485UART)
   \   00000072   ....               LDI     R31, (My485UART) >> 8
   \   00000074   8160               LD      R22, Z
   \   00000076   8171               LDD     R23, Z+1
   \   00000078   01CB               MOVW    R25:R24, R23:R22
   \   0000007A   9601               ADIW    R25:R24, 1
   \   0000007C   ....               LDI     R30, LOW(My485UART)
   \   0000007E   ....               LDI     R31, (My485UART) >> 8
   \   00000080   8380               ST      Z, R24
   \   00000082   8391               STD     Z+1, R25
   \   00000084   ....               LDI     R30, LOW((TData + 144))
   \   00000086   ....               LDI     R31, HIGH((TData + 144))
   \   00000088   8140               LD      R20, Z
   \   0000008A   8151               LDD     R21, Z+1
   \   0000008C   01FB               MOVW    R31:R30, R23:R22
   \   0000008E   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000090   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000092   8340               ST      Z, R20
    382                  My485UART.pTxBuffer[My485UART.TxFirst++] = (TData.Hart.PortUsed >> 8) & 0xff;
   \   00000094   ....               LDI     R30, LOW(My485UART)
   \   00000096   ....               LDI     R31, (My485UART) >> 8
   \   00000098   8160               LD      R22, Z
   \   0000009A   8171               LDD     R23, Z+1
   \   0000009C   01CB               MOVW    R25:R24, R23:R22
   \   0000009E   9601               ADIW    R25:R24, 1
   \   000000A0   ....               LDI     R30, LOW(My485UART)
   \   000000A2   ....               LDI     R31, (My485UART) >> 8
   \   000000A4   8380               ST      Z, R24
   \   000000A6   8391               STD     Z+1, R25
   \   000000A8   ....               LDI     R30, LOW((TData + 144))
   \   000000AA   ....               LDI     R31, HIGH((TData + 144))
   \   000000AC   8140               LD      R20, Z
   \   000000AE   8151               LDD     R21, Z+1
   \   000000B0   2F45               MOV     R20, R21
   \   000000B2   E050               LDI     R21, 0
   \   000000B4   01FB               MOVW    R31:R30, R23:R22
   \   000000B6   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000B8   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000BA   8340               ST      Z, R20
    383          
    384                  My485UART.pTxBuffer[ntna] =  (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000BC   ....               LDI     R30, LOW(My485UART)
   \   000000BE   ....               LDI     R31, (My485UART) >> 8
   \   000000C0   8140               LD      R20, Z
   \   000000C2   8151               LDD     R21, Z+1
   \   000000C4   2F52               MOV     R21, R18
   \   000000C6   1B45               SUB     R20, R21
   \   000000C8   5042               SUBI    R20, 2
   \   000000CA   01F9               MOVW    R31:R30, R19:R18
   \   000000CC   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000CE   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000D0   8340               ST      Z, R20
    385                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000D2   ....               LDI     R30, LOW(My485UART)
   \   000000D4   ....               LDI     R31, (My485UART) >> 8
   \   000000D6   8180               LD      R24, Z
   \   000000D8   8191               LDD     R25, Z+1
   \   000000DA   1B82               SUB     R24, R18
   \   000000DC   0B93               SBC     R25, R19
   \   000000DE   9702               SBIW    R25:R24, 2
   \   000000E0   2F89               MOV     R24, R25
   \   000000E2   E090               LDI     R25, 0
   \   000000E4   01F9               MOVW    R31:R30, R19:R18
   \   000000E6   ....               SUBI    R30, LOW((-(My485UART + 125) & 0xFFFF))
   \   000000E8   ....               SBCI    R31, HIGH((-(My485UART + 125) & 0xFFFF))
   \   000000EA   8380               ST      Z, R24
    386              }
    387          }
   \                     ??BuildHartSetup_0:
   \   000000EC   01C0               MOVW    R25:R24, R1:R0
   \   000000EE   9508               RET
    388          
    389          /*************************************************************************
    390          *
    391          * Build filter data package for AN-ZBHART
    392          *
    393          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    394          void BuildHartFilter( char *pointer) {
   \                     BuildHartFilter:
   \   00000000   010C               MOVW    R1:R0, R25:R24
   \   00000002   0198               MOVW    R19:R18, R17:R16
    395              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000004   ....               LDI     R30, LOW(My485UART)
   \   00000006   ....               LDI     R31, (My485UART) >> 8
   \   00000008   8100               LD      R16, Z
   \   0000000A   8111               LDD     R17, Z+1
   \   0000000C   370C               CPI     R16, 124
   \   0000000E   E041               LDI     R20, 1
   \   00000010   0714               CPC     R17, R20
   \   00000012   F008               BRCS    $+2+2
   \   00000014   C05E               RJMP    ??BuildHartFilter_0
    396                  char port;
    397                  short ntna;
    398                  My485UART.RxSendReply = true;                               // flag for answering
   \   00000016   E011               LDI     R17, 1
   \   00000018   9310....           STS     (My485UART + 675), R17
    399          
    400                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_FILTER & 0xff;
   \   0000001C   ....               LDI     R30, LOW(My485UART)
   \   0000001E   ....               LDI     R31, (My485UART) >> 8
   \   00000020   8160               LD      R22, Z
   \   00000022   8171               LDD     R23, Z+1
   \   00000024   01CB               MOVW    R25:R24, R23:R22
   \   00000026   9601               ADIW    R25:R24, 1
   \   00000028   ....               LDI     R30, LOW(My485UART)
   \   0000002A   ....               LDI     R31, (My485UART) >> 8
   \   0000002C   8380               ST      Z, R24
   \   0000002E   8391               STD     Z+1, R25
   \   00000030   01FB               MOVW    R31:R30, R23:R22
   \   00000032   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000034   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000036   E011               LDI     R17, 1
   \   00000038   8310               ST      Z, R17
    401                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_FILTER >> 8;
   \   0000003A   ....               LDI     R30, LOW(My485UART)
   \   0000003C   ....               LDI     R31, (My485UART) >> 8
   \   0000003E   8160               LD      R22, Z
   \   00000040   8171               LDD     R23, Z+1
   \   00000042   01CB               MOVW    R25:R24, R23:R22
   \   00000044   9601               ADIW    R25:R24, 1
   \   00000046   ....               LDI     R30, LOW(My485UART)
   \   00000048   ....               LDI     R31, (My485UART) >> 8
   \   0000004A   8380               ST      Z, R24
   \   0000004C   8391               STD     Z+1, R25
   \   0000004E   01FB               MOVW    R31:R30, R23:R22
   \   00000050   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000052   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000054   E015               LDI     R17, 5
   \   00000056   8310               ST      Z, R17
    402                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   00000058   ....               LDI     R30, LOW(My485UART)
   \   0000005A   ....               LDI     R31, (My485UART) >> 8
   \   0000005C   8160               LD      R22, Z
   \   0000005E   8171               LDD     R23, Z+1
   \   00000060   01AB               MOVW    R21:R20, R23:R22
    403                  My485UART.TxFirst += 2;                                      // two byte length
   \   00000062   ....               LDI     R30, LOW(My485UART)
   \   00000064   ....               LDI     R31, (My485UART) >> 8
   \   00000066   8160               LD      R22, Z
   \   00000068   8171               LDD     R23, Z+1
   \   0000006A   5F6E               SUBI    R22, 254
   \   0000006C   4F7F               SBCI    R23, 255
   \   0000006E   8360               ST      Z, R22
   \   00000070   8371               STD     Z+1, R23
    404          
    405                  for ( port = 0; port < 12; port++ ) {
   \   00000072   E000               LDI     R16, 0
   \                     ??BuildHartFilter_1:
   \   00000074   300C               CPI     R16, 12
   \   00000076   F4A8               BRCC    ??BuildHartFilter_2
    406                      My485UART.pTxBuffer[My485UART.TxFirst++] = TData.Hart.Filter[port];
   \   00000078   ....               LDI     R30, LOW(My485UART)
   \   0000007A   ....               LDI     R31, (My485UART) >> 8
   \   0000007C   8160               LD      R22, Z
   \   0000007E   8171               LDD     R23, Z+1
   \   00000080   01CB               MOVW    R25:R24, R23:R22
   \   00000082   9601               ADIW    R25:R24, 1
   \   00000084   ....               LDI     R30, LOW(My485UART)
   \   00000086   ....               LDI     R31, (My485UART) >> 8
   \   00000088   8380               ST      Z, R24
   \   0000008A   8391               STD     Z+1, R25
   \   0000008C   E010               LDI     R17, 0
   \   0000008E   01F8               MOVW    R31:R30, R17:R16
   \   00000090   ....               SUBI    R30, LOW((-(TData + 160) & 0xFFFF))
   \   00000092   ....               SBCI    R31, HIGH((-(TData + 160) & 0xFFFF))
   \   00000094   8110               LD      R17, Z
   \   00000096   01FB               MOVW    R31:R30, R23:R22
   \   00000098   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   0000009A   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000009C   8310               ST      Z, R17
    407                  }
   \   0000009E   9503               INC     R16
   \   000000A0   CFE9               RJMP    ??BuildHartFilter_1
    408          
    409                  My485UART.pTxBuffer[ntna] =  (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \                     ??BuildHartFilter_2:
   \   000000A2   ....               LDI     R30, LOW(My485UART)
   \   000000A4   ....               LDI     R31, (My485UART) >> 8
   \   000000A6   8160               LD      R22, Z
   \   000000A8   8171               LDD     R23, Z+1
   \   000000AA   2F14               MOV     R17, R20
   \   000000AC   1B61               SUB     R22, R17
   \   000000AE   5062               SUBI    R22, 2
   \   000000B0   01FA               MOVW    R31:R30, R21:R20
   \   000000B2   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000B4   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000B6   8360               ST      Z, R22
    410                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000B8   ....               LDI     R30, LOW(My485UART)
   \   000000BA   ....               LDI     R31, (My485UART) >> 8
   \   000000BC   8180               LD      R24, Z
   \   000000BE   8191               LDD     R25, Z+1
   \   000000C0   1B84               SUB     R24, R20
   \   000000C2   0B95               SBC     R25, R21
   \   000000C4   9702               SBIW    R25:R24, 2
   \   000000C6   2F89               MOV     R24, R25
   \   000000C8   E090               LDI     R25, 0
   \   000000CA   01FA               MOVW    R31:R30, R21:R20
   \   000000CC   ....               SUBI    R30, LOW((-(My485UART + 125) & 0xFFFF))
   \   000000CE   ....               SBCI    R31, HIGH((-(My485UART + 125) & 0xFFFF))
   \   000000D0   8380               ST      Z, R24
    411              }
    412          }
   \                     ??BuildHartFilter_0:
   \   000000D2   01C0               MOVW    R25:R24, R1:R0
   \   000000D4   9508               RET
    413          
    414          /*************************************************************************
    415          *
    416          * Build datablock for Hart (Hart)
    417          *
    418          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    419          void BuildMDataHart(void) {
   \                     BuildMDataHart:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    420              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000004   ....               LDI     R30, LOW(My485UART)
   \   00000006   ....               LDI     R31, (My485UART) >> 8
   \   00000008   8100               LD      R16, Z
   \   0000000A   8111               LDD     R17, Z+1
   \   0000000C   370C               CPI     R16, 124
   \   0000000E   E021               LDI     R18, 1
   \   00000010   0712               CPC     R17, R18
   \   00000012   F008               BRCS    $+2+2
   \   00000014   C0A7               RJMP    ??BuildMDataHart_0
    421                  short Index        = 11; // // Add data after the heading, Heading size is 11
   \   00000016   E0EB               LDI     R30, 11
   \   00000018   E0F0               LDI     R31, 0
    422                  char *Buf          = My485UART.pTxBuffer;
   \   0000001A   ....               LDI     R16, LOW((My485UART + 124))
   \   0000001C   ....               LDI     R17, HIGH((My485UART + 124))
    423                  My485UART.RxSendReply = true;                               // flag for answering
   \   0000001E   E021               LDI     R18, 1
   \   00000020   9320....           STS     (My485UART + 675), R18
    424                  Buf[Index++] = CMD_REP_HART_MDATA & 0xff;
   \   00000024   01D8               MOVW    R27:R26, R17:R16
   \   00000026   0FAE               ADD     R26, R30
   \   00000028   1FBF               ADC     R27, R31
   \   0000002A   E02B               LDI     R18, 11
   \   0000002C   932C               ST      X, R18
   \   0000002E   9631               ADIW    R31:R30, 1
    425                  Buf[Index++] = CMD_REP_HART_MDATA >> 8;
   \   00000030   01D8               MOVW    R27:R26, R17:R16
   \   00000032   0FAE               ADD     R26, R30
   \   00000034   1FBF               ADC     R27, R31
   \   00000036   E025               LDI     R18, 5
   \   00000038   932C               ST      X, R18
   \   0000003A   9631               ADIW    R31:R30, 1
    426                  short ntna = Index;                                  /* remember index */
   \   0000003C   019F               MOVW    R19:R18, R31:R30
    427                  Index  += 2;                                      // two byte length
   \   0000003E   9632               ADIW    R31:R30, 2
    428          
    429                  Buf[Index++] = (RestartStatus << 4);    // Add restart status
   \   00000040   9140....           LDS     R20, RestartStatus
   \   00000044   9542               SWAP    R20
   \   00000046   7F40               ANDI    R20, 0xF0
   \   00000048   01D8               MOVW    R27:R26, R17:R16
   \   0000004A   0FAE               ADD     R26, R30
   \   0000004C   1FBF               ADC     R27, R31
   \   0000004E   934C               ST      X, R20
   \   00000050   9631               ADIW    R31:R30, 1
    430                  // Hart PV
    431                  for ( short i = 0; i < 12; i++ ) {
   \   00000052   E080               LDI     R24, 0
   \   00000054   E090               LDI     R25, 0
   \                     ??BuildMDataHart_1:
   \   00000056   308C               CPI     R24, 12
   \   00000058   E040               LDI     R20, 0
   \   0000005A   0794               CPC     R25, R20
   \   0000005C   F00C               BRLT    $+2+2
   \   0000005E   C068               RJMP    ??BuildMDataHart_2
    432                      *((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][0];   // Hart 1st
   \   00000060   01AC               MOVW    R21:R20, R25:R24
   \   00000062   0F44               LSL     R20
   \   00000064   1F55               ROL     R21
   \   00000066   0F44               LSL     R20
   \   00000068   1F55               ROL     R21
   \   0000006A   01DA               MOVW    R27:R26, R21:R20
   \   0000006C   ....               SUBI    R26, LOW((-(TData) & 0xFFFF))
   \   0000006E   ....               SBCI    R27, (-(TData) & 0xFFFF) >> 8
   \   00000070   914D               LD      R20, X+
   \   00000072   915C               LD      R21, X
   \   00000074   9711               SBIW    R27:R26, 1
   \   00000076   01D8               MOVW    R27:R26, R17:R16
   \   00000078   0FAE               ADD     R26, R30
   \   0000007A   1FBF               ADC     R27, R31
   \   0000007C   934D               ST      X+, R20
   \   0000007E   935C               ST      X, R21
   \   00000080   9711               SBIW    R27:R26, 1
    433                      Index += sizeof(unsigned short);
   \   00000082   9632               ADIW    R31:R30, 2
    434                      *((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][1];   // Hart 2nd
   \   00000084   01AC               MOVW    R21:R20, R25:R24
   \   00000086   0F44               LSL     R20
   \   00000088   1F55               ROL     R21
   \   0000008A   0F44               LSL     R20
   \   0000008C   1F55               ROL     R21
   \   0000008E   01DA               MOVW    R27:R26, R21:R20
   \   00000090   ....               SUBI    R26, LOW((-(TData + 2) & 0xFFFF))
   \   00000092   ....               SBCI    R27, HIGH((-(TData + 2) & 0xFFFF))
   \   00000094   914D               LD      R20, X+
   \   00000096   915C               LD      R21, X
   \   00000098   9711               SBIW    R27:R26, 1
   \   0000009A   01D8               MOVW    R27:R26, R17:R16
   \   0000009C   0FAE               ADD     R26, R30
   \   0000009E   1FBF               ADC     R27, R31
   \   000000A0   934D               ST      X+, R20
   \   000000A2   935C               ST      X, R21
   \   000000A4   9711               SBIW    R27:R26, 1
    435                      Index += sizeof(unsigned short);
   \   000000A6   9632               ADIW    R31:R30, 2
    436                      //hart_channel_lock(&_hart_channels[i]);
    437                      *((float *)&Buf[Index]) = TData.Hart.Distance[i];       // Hart 1st
   \   000000A8   01AC               MOVW    R21:R20, R25:R24
   \   000000AA   0F44               LSL     R20
   \   000000AC   1F55               ROL     R21
   \   000000AE   0F44               LSL     R20
   \   000000B0   1F55               ROL     R21
   \   000000B2   01DA               MOVW    R27:R26, R21:R20
   \   000000B4   ....               SUBI    R26, LOW((-(TData + 268) & 0xFFFF))
   \   000000B6   ....               SBCI    R27, HIGH((-(TData + 268) & 0xFFFF))
   \   000000B8   914D               LD      R20, X+
   \   000000BA   915D               LD      R21, X+
   \   000000BC   916D               LD      R22, X+
   \   000000BE   917C               LD      R23, X
   \   000000C0   9713               SBIW    R27:R26, 3
   \   000000C2   01D8               MOVW    R27:R26, R17:R16
   \   000000C4   0FAE               ADD     R26, R30
   \   000000C6   1FBF               ADC     R27, R31
   \   000000C8   934D               ST      X+, R20
   \   000000CA   935D               ST      X+, R21
   \   000000CC   936D               ST      X+, R22
   \   000000CE   937C               ST      X, R23
   \   000000D0   9713               SBIW    R27:R26, 3
    438                      Index += sizeof(float);
   \   000000D2   9634               ADIW    R31:R30, 4
    439                      *((float *)&Buf[Index]) = TData.Hart.Level[i];          // Hart 2nd
   \   000000D4   01AC               MOVW    R21:R20, R25:R24
   \   000000D6   0F44               LSL     R20
   \   000000D8   1F55               ROL     R21
   \   000000DA   0F44               LSL     R20
   \   000000DC   1F55               ROL     R21
   \   000000DE   01DA               MOVW    R27:R26, R21:R20
   \   000000E0   ....               SUBI    R26, LOW((-(TData + 316) & 0xFFFF))
   \   000000E2   ....               SBCI    R27, HIGH((-(TData + 316) & 0xFFFF))
   \   000000E4   914D               LD      R20, X+
   \   000000E6   915D               LD      R21, X+
   \   000000E8   916D               LD      R22, X+
   \   000000EA   917C               LD      R23, X
   \   000000EC   9713               SBIW    R27:R26, 3
   \   000000EE   01D8               MOVW    R27:R26, R17:R16
   \   000000F0   0FAE               ADD     R26, R30
   \   000000F2   1FBF               ADC     R27, R31
   \   000000F4   934D               ST      X+, R20
   \   000000F6   935D               ST      X+, R21
   \   000000F8   936D               ST      X+, R22
   \   000000FA   937C               ST      X, R23
   \   000000FC   9713               SBIW    R27:R26, 3
    440                      Index += sizeof(float);
   \   000000FE   9634               ADIW    R31:R30, 4
    441                      *((float *)&Buf[Index]) = TData.Hart.ADCurrent[i];      //*TData.Hart.Gain[i] - TData.Hart.Offset[i];   // Measured current via onboard ADC
   \   00000100   01AC               MOVW    R21:R20, R25:R24
   \   00000102   0F44               LSL     R20
   \   00000104   1F55               ROL     R21
   \   00000106   0F44               LSL     R20
   \   00000108   1F55               ROL     R21
   \   0000010A   01DA               MOVW    R27:R26, R21:R20
   \   0000010C   ....               SUBI    R26, LOW((-(TData + 172) & 0xFFFF))
   \   0000010E   ....               SBCI    R27, HIGH((-(TData + 172) & 0xFFFF))
   \   00000110   914D               LD      R20, X+
   \   00000112   915D               LD      R21, X+
   \   00000114   916D               LD      R22, X+
   \   00000116   917C               LD      R23, X
   \   00000118   9713               SBIW    R27:R26, 3
   \   0000011A   01D8               MOVW    R27:R26, R17:R16
   \   0000011C   0FAE               ADD     R26, R30
   \   0000011E   1FBF               ADC     R27, R31
   \   00000120   934D               ST      X+, R20
   \   00000122   935D               ST      X+, R21
   \   00000124   936D               ST      X+, R22
   \   00000126   937C               ST      X, R23
   \   00000128   9713               SBIW    R27:R26, 3
    442                      Index += sizeof(float);
   \   0000012A   9634               ADIW    R31:R30, 4
    443                      //*((float *)&Buf[Index]) = TData.Hart.HartCurrent[i];    // mA current from the device
    444                      //Index += sizeof(float);
    445                      //hart_channel_unlock(&_hart_channels[i]);
    446                  }
   \   0000012C   9601               ADIW    R25:R24, 1
   \   0000012E   CF93               RJMP    ??BuildMDataHart_1
    447                  Buf[ntna] = (Index - ntna - 2) & 0xff;      // length of data block lb
   \                     ??BuildMDataHart_2:
   \   00000130   2F4E               MOV     R20, R30
   \   00000132   2F52               MOV     R21, R18
   \   00000134   1B45               SUB     R20, R21
   \   00000136   5042               SUBI    R20, 2
   \   00000138   01D8               MOVW    R27:R26, R17:R16
   \   0000013A   0FA2               ADD     R26, R18
   \   0000013C   1FB3               ADC     R27, R19
   \   0000013E   934C               ST      X, R20
    448                  Buf[ntna + 1] = ((Index - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000140   01CF               MOVW    R25:R24, R31:R30
   \   00000142   1B82               SUB     R24, R18
   \   00000144   0B93               SBC     R25, R19
   \   00000146   9702               SBIW    R25:R24, 2
   \   00000148   2F89               MOV     R24, R25
   \   0000014A   0F99               LSL     R25
   \   0000014C   0B99               SBC     R25, R25
   \   0000014E   01D8               MOVW    R27:R26, R17:R16
   \   00000150   0FA2               ADD     R26, R18
   \   00000152   1FB3               ADC     R27, R19
   \   00000154   9611               ADIW    R27:R26, 1
   \   00000156   938C               ST      X, R24
   \   00000158   9711               SBIW    R27:R26, 1
    449                  My485UART.TxFirst = Index; // Add data after the heading
   \   0000015A   01AF               MOVW    R21:R20, R31:R30
   \   0000015C   ....               LDI     R30, LOW(My485UART)
   \   0000015E   ....               LDI     R31, (My485UART) >> 8
   \   00000160   8340               ST      Z, R20
   \   00000162   8351               STD     Z+1, R21
    450              }
    451          
    452          
    453          }
   \                     ??BuildMDataHart_0:
   \   00000164   E0E4               LDI     R30, 4
   \   00000166   ........           JMP     ?EPILOGUE_B4_L09
    454          
    455          
    456          /*************************************************************************
    457          *
    458          * Build datablock for Stack status
    459          *
    460          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    461          void BuildStackStatus( char *pointer) {
   \                     BuildStackStatus:
   \   00000000   ........           CALL    ?PROLOGUE6_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004   01D8               MOVW    R27:R26, R17:R16
    462              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000006   ....               LDI     R30, LOW(My485UART)
   \   00000008   ....               LDI     R31, (My485UART) >> 8
   \   0000000A   8100               LD      R16, Z
   \   0000000C   8111               LDD     R17, Z+1
   \   0000000E   370C               CPI     R16, 124
   \   00000010   E021               LDI     R18, 1
   \   00000012   0712               CPC     R17, R18
   \   00000014   F008               BRCS    $+2+2
   \   00000016   C0EB               RJMP    ??BuildStackStatus_0
    463                  short ntna, stack;
    464                  My485UART.RxSendReply = true;                               // flag for answering
   \   00000018   E001               LDI     R16, 1
   \   0000001A   9300....           STS     (My485UART + 675), R16
    465          
    466                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STACKSTATUS & 0xff;
   \   0000001E   ....               LDI     R30, LOW(My485UART)
   \   00000020   ....               LDI     R31, (My485UART) >> 8
   \   00000022   8120               LD      R18, Z
   \   00000024   8131               LDD     R19, Z+1
   \   00000026   0189               MOVW    R17:R16, R19:R18
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   ....               LDI     R30, LOW(My485UART)
   \   0000002E   ....               LDI     R31, (My485UART) >> 8
   \   00000030   8300               ST      Z, R16
   \   00000032   8311               STD     Z+1, R17
   \   00000034   01F9               MOVW    R31:R30, R19:R18
   \   00000036   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000038   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000003A   E707               LDI     R16, 119
   \   0000003C   8300               ST      Z, R16
    467                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STACKSTATUS >> 8;
   \   0000003E   ....               LDI     R30, LOW(My485UART)
   \   00000040   ....               LDI     R31, (My485UART) >> 8
   \   00000042   8120               LD      R18, Z
   \   00000044   8131               LDD     R19, Z+1
   \   00000046   0189               MOVW    R17:R16, R19:R18
   \   00000048   5F0F               SUBI    R16, 255
   \   0000004A   4F1F               SBCI    R17, 255
   \   0000004C   ....               LDI     R30, LOW(My485UART)
   \   0000004E   ....               LDI     R31, (My485UART) >> 8
   \   00000050   8300               ST      Z, R16
   \   00000052   8311               STD     Z+1, R17
   \   00000054   01F9               MOVW    R31:R30, R19:R18
   \   00000056   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000058   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000005A   E007               LDI     R16, 7
   \   0000005C   8300               ST      Z, R16
    468                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   0000005E   ....               LDI     R30, LOW(My485UART)
   \   00000060   ....               LDI     R31, (My485UART) >> 8
   \   00000062   8100               LD      R16, Z
   \   00000064   8111               LDD     R17, Z+1
   \   00000066   0128               MOVW    R5:R4, R17:R16
    469                  My485UART.TxFirst += 2;                                      // two byte length
   \   00000068   ....               LDI     R30, LOW(My485UART)
   \   0000006A   ....               LDI     R31, (My485UART) >> 8
   \   0000006C   8100               LD      R16, Z
   \   0000006E   8111               LDD     R17, Z+1
   \   00000070   5F0E               SUBI    R16, 254
   \   00000072   4F1F               SBCI    R17, 255
   \   00000074   8300               ST      Z, R16
   \   00000076   8311               STD     Z+1, R17
    470          
    471                  stack = OS_GetStackSpace(&TCB_USART0);                            // USART 0
   \   00000078   ....               LDI     R16, LOW(TCB_USART0)
   \   0000007A   ....               LDI     R17, (TCB_USART0) >> 8
   \   0000007C   ........           CALL    OS_GetStackSpace
   \   00000080   01C8               MOVW    R25:R24, R17:R16
    472                  My485UART.pTxBuffer[My485UART.TxFirst++] = (stack & 0xff);
   \   00000082   ....               LDI     R30, LOW(My485UART)
   \   00000084   ....               LDI     R31, (My485UART) >> 8
   \   00000086   8120               LD      R18, Z
   \   00000088   8131               LDD     R19, Z+1
   \   0000008A   0189               MOVW    R17:R16, R19:R18
   \   0000008C   5F0F               SUBI    R16, 255
   \   0000008E   4F1F               SBCI    R17, 255
   \   00000090   ....               LDI     R30, LOW(My485UART)
   \   00000092   ....               LDI     R31, (My485UART) >> 8
   \   00000094   8300               ST      Z, R16
   \   00000096   8311               STD     Z+1, R17
   \   00000098   2F08               MOV     R16, R24
   \   0000009A   01F9               MOVW    R31:R30, R19:R18
   \   0000009C   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   0000009E   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000A0   8300               ST      Z, R16
    473                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((stack >> 8) & 0xff);
   \   000000A2   ....               LDI     R30, LOW(My485UART)
   \   000000A4   ....               LDI     R31, (My485UART) >> 8
   \   000000A6   8120               LD      R18, Z
   \   000000A8   8131               LDD     R19, Z+1
   \   000000AA   0189               MOVW    R17:R16, R19:R18
   \   000000AC   5F0F               SUBI    R16, 255
   \   000000AE   4F1F               SBCI    R17, 255
   \   000000B0   ....               LDI     R30, LOW(My485UART)
   \   000000B2   ....               LDI     R31, (My485UART) >> 8
   \   000000B4   8300               ST      Z, R16
   \   000000B6   8311               STD     Z+1, R17
   \   000000B8   018C               MOVW    R17:R16, R25:R24
   \   000000BA   2F01               MOV     R16, R17
   \   000000BC   0F11               LSL     R17
   \   000000BE   0B11               SBC     R17, R17
   \   000000C0   01F9               MOVW    R31:R30, R19:R18
   \   000000C2   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000C4   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000C6   8300               ST      Z, R16
    474          
    475                  stack = OS_GetStackSpace(&TCB_WATCHDOG);                            // watchdog
   \   000000C8   ....               LDI     R16, LOW(TCB_WATCHDOG)
   \   000000CA   ....               LDI     R17, (TCB_WATCHDOG) >> 8
   \   000000CC   ........           CALL    OS_GetStackSpace
   \   000000D0   01C8               MOVW    R25:R24, R17:R16
    476                  My485UART.pTxBuffer[My485UART.TxFirst++] = (stack & 0xff);
   \   000000D2   ....               LDI     R30, LOW(My485UART)
   \   000000D4   ....               LDI     R31, (My485UART) >> 8
   \   000000D6   8120               LD      R18, Z
   \   000000D8   8131               LDD     R19, Z+1
   \   000000DA   0189               MOVW    R17:R16, R19:R18
   \   000000DC   5F0F               SUBI    R16, 255
   \   000000DE   4F1F               SBCI    R17, 255
   \   000000E0   ....               LDI     R30, LOW(My485UART)
   \   000000E2   ....               LDI     R31, (My485UART) >> 8
   \   000000E4   8300               ST      Z, R16
   \   000000E6   8311               STD     Z+1, R17
   \   000000E8   2F08               MOV     R16, R24
   \   000000EA   01F9               MOVW    R31:R30, R19:R18
   \   000000EC   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000000EE   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000000F0   8300               ST      Z, R16
    477                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((stack >> 8) & 0xff);
   \   000000F2   ....               LDI     R30, LOW(My485UART)
   \   000000F4   ....               LDI     R31, (My485UART) >> 8
   \   000000F6   8120               LD      R18, Z
   \   000000F8   8131               LDD     R19, Z+1
   \   000000FA   0189               MOVW    R17:R16, R19:R18
   \   000000FC   5F0F               SUBI    R16, 255
   \   000000FE   4F1F               SBCI    R17, 255
   \   00000100   ....               LDI     R30, LOW(My485UART)
   \   00000102   ....               LDI     R31, (My485UART) >> 8
   \   00000104   8300               ST      Z, R16
   \   00000106   8311               STD     Z+1, R17
   \   00000108   018C               MOVW    R17:R16, R25:R24
   \   0000010A   2F01               MOV     R16, R17
   \   0000010C   0F11               LSL     R17
   \   0000010E   0B11               SBC     R17, R17
   \   00000110   01F9               MOVW    R31:R30, R19:R18
   \   00000112   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000114   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000116   8300               ST      Z, R16
    478                  switch ( UnitID ) {
   \   00000118   9100....           LDS     R16, UnitID
   \   0000011C   5000               SUBI    R16, 0
   \   0000011E   F029               BREQ    ??BuildStackStatus_1
   \   00000120   950A               DEC     R16
   \   00000122   F019               BREQ    ??BuildStackStatus_1
   \   00000124   5002               SUBI    R16, 2
   \   00000126   F011               BREQ    ??BuildStackStatus_2
   \   00000128   C049               RJMP    ??BuildStackStatus_3
    479                  case AN_ZB485 :
    480                  case AN_ZBANA :
    481                      break;
   \                     ??BuildStackStatus_1:
   \   0000012A   C048               RJMP    ??BuildStackStatus_3
    482                  case AN_ZBHART :
    483                      stack = OS_GetStackSpace(&TCB_AD7715);                            // AD handling
   \                     ??BuildStackStatus_2:
   \   0000012C   ....               LDI     R16, LOW(TCB_AD7715)
   \   0000012E   ....               LDI     R17, (TCB_AD7715) >> 8
   \   00000130   ........           CALL    OS_GetStackSpace
   \   00000134   01C8               MOVW    R25:R24, R17:R16
    484                      My485UART.pTxBuffer[My485UART.TxFirst++] = (stack & 0xff);
   \   00000136   ....               LDI     R30, LOW(My485UART)
   \   00000138   ....               LDI     R31, (My485UART) >> 8
   \   0000013A   8120               LD      R18, Z
   \   0000013C   8131               LDD     R19, Z+1
   \   0000013E   0189               MOVW    R17:R16, R19:R18
   \   00000140   5F0F               SUBI    R16, 255
   \   00000142   4F1F               SBCI    R17, 255
   \   00000144   ....               LDI     R30, LOW(My485UART)
   \   00000146   ....               LDI     R31, (My485UART) >> 8
   \   00000148   8300               ST      Z, R16
   \   0000014A   8311               STD     Z+1, R17
   \   0000014C   2F08               MOV     R16, R24
   \   0000014E   01F9               MOVW    R31:R30, R19:R18
   \   00000150   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000152   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000154   8300               ST      Z, R16
    485                      My485UART.pTxBuffer[My485UART.TxFirst++] = ((stack >> 8) & 0xff);
   \   00000156   ....               LDI     R30, LOW(My485UART)
   \   00000158   ....               LDI     R31, (My485UART) >> 8
   \   0000015A   8120               LD      R18, Z
   \   0000015C   8131               LDD     R19, Z+1
   \   0000015E   0189               MOVW    R17:R16, R19:R18
   \   00000160   5F0F               SUBI    R16, 255
   \   00000162   4F1F               SBCI    R17, 255
   \   00000164   ....               LDI     R30, LOW(My485UART)
   \   00000166   ....               LDI     R31, (My485UART) >> 8
   \   00000168   8300               ST      Z, R16
   \   0000016A   8311               STD     Z+1, R17
   \   0000016C   018C               MOVW    R17:R16, R25:R24
   \   0000016E   2F01               MOV     R16, R17
   \   00000170   0F11               LSL     R17
   \   00000172   0B11               SBC     R17, R17
   \   00000174   01F9               MOVW    R31:R30, R19:R18
   \   00000176   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000178   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   0000017A   8300               ST      Z, R16
    486                      My485UART.pTxBuffer[My485UART.TxFirst++] = 0;
   \   0000017C   ....               LDI     R30, LOW(My485UART)
   \   0000017E   ....               LDI     R31, (My485UART) >> 8
   \   00000180   8120               LD      R18, Z
   \   00000182   8131               LDD     R19, Z+1
   \   00000184   0189               MOVW    R17:R16, R19:R18
   \   00000186   5F0F               SUBI    R16, 255
   \   00000188   4F1F               SBCI    R17, 255
   \   0000018A   ....               LDI     R30, LOW(My485UART)
   \   0000018C   ....               LDI     R31, (My485UART) >> 8
   \   0000018E   8300               ST      Z, R16
   \   00000190   8311               STD     Z+1, R17
   \   00000192   01F9               MOVW    R31:R30, R19:R18
   \   00000194   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   00000196   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   00000198   E000               LDI     R16, 0
   \   0000019A   8300               ST      Z, R16
    487                      My485UART.pTxBuffer[My485UART.TxFirst++] = 0;
   \   0000019C   ....               LDI     R30, LOW(My485UART)
   \   0000019E   ....               LDI     R31, (My485UART) >> 8
   \   000001A0   8120               LD      R18, Z
   \   000001A2   8131               LDD     R19, Z+1
   \   000001A4   0189               MOVW    R17:R16, R19:R18
   \   000001A6   5F0F               SUBI    R16, 255
   \   000001A8   4F1F               SBCI    R17, 255
   \   000001AA   ....               LDI     R30, LOW(My485UART)
   \   000001AC   ....               LDI     R31, (My485UART) >> 8
   \   000001AE   8300               ST      Z, R16
   \   000001B0   8311               STD     Z+1, R17
   \   000001B2   01F9               MOVW    R31:R30, R19:R18
   \   000001B4   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000001B6   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000001B8   E000               LDI     R16, 0
   \   000001BA   8300               ST      Z, R16
    488                      break;
    489                  }
    490          
    491                  My485UART.pTxBuffer[ntna] = (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \                     ??BuildStackStatus_3:
   \   000001BC   ....               LDI     R30, LOW(My485UART)
   \   000001BE   ....               LDI     R31, (My485UART) >> 8
   \   000001C0   8100               LD      R16, Z
   \   000001C2   8111               LDD     R17, Z+1
   \   000001C4   2D14               MOV     R17, R4
   \   000001C6   1B01               SUB     R16, R17
   \   000001C8   5002               SUBI    R16, 2
   \   000001CA   01F2               MOVW    R31:R30, R5:R4
   \   000001CC   ....               SUBI    R30, LOW((-(My485UART + 124) & 0xFFFF))
   \   000001CE   ....               SBCI    R31, HIGH((-(My485UART + 124) & 0xFFFF))
   \   000001D0   8300               ST      Z, R16
    492                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000001D2   ....               LDI     R30, LOW(My485UART)
   \   000001D4   ....               LDI     R31, (My485UART) >> 8
   \   000001D6   8100               LD      R16, Z
   \   000001D8   8111               LDD     R17, Z+1
   \   000001DA   1904               SUB     R16, R4
   \   000001DC   0915               SBC     R17, R5
   \   000001DE   5002               SUBI    R16, 2
   \   000001E0   4010               SBCI    R17, 0
   \   000001E2   2F01               MOV     R16, R17
   \   000001E4   E010               LDI     R17, 0
   \   000001E6   01F2               MOVW    R31:R30, R5:R4
   \   000001E8   ....               SUBI    R30, LOW((-(My485UART + 125) & 0xFFFF))
   \   000001EA   ....               SBCI    R31, HIGH((-(My485UART + 125) & 0xFFFF))
   \   000001EC   8300               ST      Z, R16
    493              }
    494          
    495          }
   \                     ??BuildStackStatus_0:
   \   000001EE   E0E6               LDI     R30, 6
   \   000001F0   ........           JMP     ?EPILOGUE_B6_L09
    496          
    497          //////////////////////////////////////////////////////////////////////////////
    498          // Receiving data to IO module here
    499          /////////////////////////////////////////////////////////////////////////////
    500          
    501          /*************************************************************************
    502          *
    503          * Receive Command to Reset the EEPROM
    504          *
    505          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    506          void GetResetEEPROM(void) {
   \                     GetResetEEPROM:
    507          
    508              EEPROMReset();
   \   00000000   ........           CALL    EEPROMReset
    509          }
   \   00000004   9508               RET
    510          
    511          
    512          /*************************************************************************
    513          *
    514          * Receive Command to go to the bootloader program
    515          *
    516          *************************************************************************/
    517          extern volatile char RestartCmd;

   \                                 In  segment CODE, align 2, keep-with-next
    518          void GetGotoBootloader( char *pointer) {
   \                     GetGotoBootloader:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01D8               MOVW    R27:R26, R17:R16
    519          
    520              void (*BootApp)(void) = (void(*)())0xF000;
   \   00000006   E080               LDI     R24, LOW(61440)
   \   00000008   EF90               LDI     R25, (61440) >> 8
    521              while ( (EECR & 1 << EEPE) != 0 ) //chech if EEPROM is ready
   \                     ??GetGotoBootloader_0:
   \   0000000A   99F9               SBIC    0x1F, 0x01
   \   0000000C   CFFE               RJMP    ??GetGotoBootloader_0
    522              ;
    523              EEARL = (0x0fff & 0xff);
   \   0000000E   EF0F               LDI     R16, 255
   \   00000010   BD01               OUT     0x21, R16
    524              EEARH = (0x0fff >> 8);
   \   00000012   E00F               LDI     R16, 15
   \   00000014   BD02               OUT     0x22, R16
    525              EEDR = 0x00;
   \   00000016   E000               LDI     R16, 0
   \   00000018   BD00               OUT     0x20, R16
    526              EECR |= (1 << EEMPE);
   \   0000001A   9AFA               SBI     0x1F, 0x02
    527              EECR |= (1 << EEPE);
   \   0000001C   9AF9               SBI     0x1F, 0x01
    528              while ( EECR & (1 << EEPE) );
   \                     ??GetGotoBootloader_1:
   \   0000001E   99F9               SBIC    0x1F, 0x01
   \   00000020   CFFE               RJMP    ??GetGotoBootloader_1
    529              //RestartCmd = 1;
    530              BootApp();
   \   00000022   01FC               MOVW    R31:R30, R25:R24
   \   00000024   9509               ICALL
    531              //OS_Error(ZB_REBOOT);
    532          }
   \   00000026   E0E4               LDI     R30, 4
   \   00000028   ........           JMP     ?EPILOGUE_B4_L09
   \   0000002C                      REQUIRE _A_EECR
   \   0000002C                      REQUIRE _A_EEAR
   \   0000002C                      REQUIRE _A_EEDR
    533          
    534          /*************************************************************************
    535          *
    536          * Receive EEPROM data
    537          *
    538          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    539          void GetEEPROMData( char *pointer) {
   \                     GetEEPROMData:
   \   00000000   ........           CALL    ?PROLOGUE7_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004   0128               MOVW    R5:R4, R17:R16
    540          
    541              char channel;
    542              OS_U32 t0;
    543          
    544              channel = pointer[0];
   \   00000006   01F2               MOVW    R31:R30, R5:R4
   \   00000008   8100               LD      R16, Z
   \   0000000A   2E60               MOV     R6, R16
    545              switch ( UnitID ) {
   \   0000000C   9100....           LDS     R16, UnitID
   \   00000010   5000               SUBI    R16, 0
   \   00000012   F179               BREQ    ??GetEEPROMData_0
   \   00000014   950A               DEC     R16
   \   00000016   F169               BREQ    ??GetEEPROMData_0
   \   00000018   5002               SUBI    R16, 2
   \   0000001A   F559               BRNE    ??GetEEPROMData_0
    546              case AN_ZBANA:
    547                  break;
    548              case AN_ZBHART:
    549                  if ( channel >= 0x80 ) {
   \   0000001C   E800               LDI     R16, 128
   \   0000001E   1660               CP      R6, R16
   \   00000020   F140               BRCS    ??GetEEPROMData_0
    550                      *((float *)&TData.Hart.Offset[channel & 0x0f]) = *((float *)&pointer[1]);  //offset
   \   00000022   01F2               MOVW    R31:R30, R5:R4
   \   00000024   8141               LDD     R20, Z+1
   \   00000026   8152               LDD     R21, Z+2
   \   00000028   8163               LDD     R22, Z+3
   \   0000002A   8174               LDD     R23, Z+4
   \   0000002C   2D06               MOV     R16, R6
   \   0000002E   E010               LDI     R17, 0
   \   00000030   700F               ANDI    R16, 0x0F
   \   00000032   7010               ANDI    R17, 0x00
   \   00000034   0F00               LSL     R16
   \   00000036   1F11               ROL     R17
   \   00000038   0F00               LSL     R16
   \   0000003A   1F11               ROL     R17
   \   0000003C   01F8               MOVW    R31:R30, R17:R16
   \   0000003E   ....               SUBI    R30, LOW((-(TData + 364) & 0xFFFF))
   \   00000040   ....               SBCI    R31, HIGH((-(TData + 364) & 0xFFFF))
   \   00000042   8340               ST      Z, R20
   \   00000044   8351               STD     Z+1, R21
   \   00000046   8362               STD     Z+2, R22
   \   00000048   8373               STD     Z+3, R23
    551                      *((float *)&TData.Hart.Gain[channel   & 0x0f]) = *((float *)&pointer[5]);  //gain
   \   0000004A   01F2               MOVW    R31:R30, R5:R4
   \   0000004C   8145               LDD     R20, Z+5
   \   0000004E   8156               LDD     R21, Z+6
   \   00000050   8167               LDD     R22, Z+7
   \   00000052   8570               LDD     R23, Z+8
   \   00000054   2D06               MOV     R16, R6
   \   00000056   E010               LDI     R17, 0
   \   00000058   700F               ANDI    R16, 0x0F
   \   0000005A   7010               ANDI    R17, 0x00
   \   0000005C   0F00               LSL     R16
   \   0000005E   1F11               ROL     R17
   \   00000060   0F00               LSL     R16
   \   00000062   1F11               ROL     R17
   \   00000064   01F8               MOVW    R31:R30, R17:R16
   \   00000066   ....               SUBI    R30, LOW((-(TData + 412) & 0xFFFF))
   \   00000068   ....               SBCI    R31, HIGH((-(TData + 412) & 0xFFFF))
   \   0000006A   8340               ST      Z, R20
   \   0000006C   8351               STD     Z+1, R21
   \   0000006E   8362               STD     Z+2, R22
   \   00000070   8373               STD     Z+3, R23
    552                  }
    553                  break;
    554              case AN_ZB485:
    555                  break;
    556              }
    557              WriteEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&pointer[1]);
   \                     ??GetEEPROMData_0:
   \   00000072   01A2               MOVW    R21:R20, R5:R4
   \   00000074   5F4F               SUBI    R20, 255
   \   00000076   4F5F               SBCI    R21, 255
   \   00000078   E024               LDI     R18, 4
   \   0000007A   01BA               MOVW    R23:R22, R21:R20
   \   0000007C   2D06               MOV     R16, R6
   \   0000007E   E010               LDI     R17, 0
   \   00000080   E048               LDI     R20, 8
   \   00000082   E050               LDI     R21, 0
   \   00000084   ........           CALL    ?S_EC_MUL_L02
   \   00000088   01AB               MOVW    R21:R20, R23:R22
   \   0000008A   ........           CALL    WriteEEPROMBuffer
    558              t0 = OS_GetTime();
   \   0000008E   ........           CALL    OS__Gettime
   \   00000092   2F21               MOV     R18, R17
   \   00000094   0F22               LSL     R18
   \   00000096   0B22               SBC     R18, R18
   \   00000098   2F32               MOV     R19, R18
   \   0000009A   01C8               MOVW    R25:R24, R17:R16
   \   0000009C   01D9               MOVW    R27:R26, R19:R18
    559              do {
    560                  OS_Delay(1);
   \                     ??GetEEPROMData_1:
   \   0000009E   E001               LDI     R16, 1
   \   000000A0   E010               LDI     R17, 0
   \   000000A2   ........           CALL    OS_Delay
    561              }while ( (OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK );  //8.5 ms programming time
   \   000000A6   ........           CALL    OS__Gettime
   \   000000AA   2F21               MOV     R18, R17
   \   000000AC   0F22               LSL     R18
   \   000000AE   0B22               SBC     R18, R18
   \   000000B0   2F32               MOV     R19, R18
   \   000000B2   1B08               SUB     R16, R24
   \   000000B4   0B19               SBC     R17, R25
   \   000000B6   0B2A               SBC     R18, R26
   \   000000B8   0B3B               SBC     R19, R27
   \   000000BA   3204               CPI     R16, 36
   \   000000BC   E040               LDI     R20, 0
   \   000000BE   0714               CPC     R17, R20
   \   000000C0   E040               LDI     R20, 0
   \   000000C2   0724               CPC     R18, R20
   \   000000C4   E040               LDI     R20, 0
   \   000000C6   0734               CPC     R19, R20
   \   000000C8   F420               BRCC    ??GetEEPROMData_2
   \   000000CA   9100....           LDS     R16, EEPWriteOK
   \   000000CE   2300               TST     R16
   \   000000D0   F331               BREQ    ??GetEEPROMData_1
    562              WriteEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&pointer[5]);
   \                     ??GetEEPROMData_2:
   \   000000D2   01A2               MOVW    R21:R20, R5:R4
   \   000000D4   5F4B               SUBI    R20, 251
   \   000000D6   4F5F               SBCI    R21, 255
   \   000000D8   E024               LDI     R18, 4
   \   000000DA   01BA               MOVW    R23:R22, R21:R20
   \   000000DC   2D06               MOV     R16, R6
   \   000000DE   E010               LDI     R17, 0
   \   000000E0   E048               LDI     R20, 8
   \   000000E2   E050               LDI     R21, 0
   \   000000E4   ........           CALL    ?S_EC_MUL_L02
   \   000000E8   5F0C               SUBI    R16, 252
   \   000000EA   4F1F               SBCI    R17, 255
   \   000000EC   01AB               MOVW    R21:R20, R23:R22
   \   000000EE   ........           CALL    WriteEEPROMBuffer
    563              t0 = OS_GetTime();
   \   000000F2   ........           CALL    OS__Gettime
   \   000000F6   2F21               MOV     R18, R17
   \   000000F8   0F22               LSL     R18
   \   000000FA   0B22               SBC     R18, R18
   \   000000FC   2F32               MOV     R19, R18
   \   000000FE   01C8               MOVW    R25:R24, R17:R16
   \   00000100   01D9               MOVW    R27:R26, R19:R18
    564              do {
    565                  OS_Delay(1);
   \                     ??GetEEPROMData_3:
   \   00000102   E001               LDI     R16, 1
   \   00000104   E010               LDI     R17, 0
   \   00000106   ........           CALL    OS_Delay
    566              }while ( (OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK );
   \   0000010A   ........           CALL    OS__Gettime
   \   0000010E   2F21               MOV     R18, R17
   \   00000110   0F22               LSL     R18
   \   00000112   0B22               SBC     R18, R18
   \   00000114   2F32               MOV     R19, R18
   \   00000116   1B08               SUB     R16, R24
   \   00000118   0B19               SBC     R17, R25
   \   0000011A   0B2A               SBC     R18, R26
   \   0000011C   0B3B               SBC     R19, R27
   \   0000011E   3204               CPI     R16, 36
   \   00000120   E040               LDI     R20, 0
   \   00000122   0714               CPC     R17, R20
   \   00000124   E040               LDI     R20, 0
   \   00000126   0724               CPC     R18, R20
   \   00000128   E040               LDI     R20, 0
   \   0000012A   0734               CPC     R19, R20
   \   0000012C   F420               BRCC    ??GetEEPROMData_4
   \   0000012E   9100....           LDS     R16, EEPWriteOK
   \   00000132   2300               TST     R16
   \   00000134   F331               BREQ    ??GetEEPROMData_3
    567          }
   \                     ??GetEEPROMData_4:
   \   00000136   E0E7               LDI     R30, 7
   \   00000138   ........           JMP     ?EPILOGUE_B7_L09
    568          
    569          
    570          
    571          /*************************************************************************
    572          *
    573          * Receive AN-ZBHART setup
    574          *
    575          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    576          void GetHartSetup( char *pointer, unsigned Size) {
   \                     GetHartSetup:
   \   00000000   ........           CALL    ?PROLOGUE6_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \   00000006   0129               MOVW    R5:R4, R19:R18
    577              switch ( Size ) {
   \   00000008   01F2               MOVW    R31:R30, R5:R4
   \   0000000A   9734               SBIW    R31:R30, 4
   \   0000000C   F019               BREQ    ??GetHartSetup_0
   \   0000000E   9732               SBIW    R31:R30, 2
   \   00000010   F1D9               BREQ    ??GetHartSetup_1
   \   00000012   C07F               RJMP    ??GetHartSetup_2
    578              case 4:
    579                  TData.Hart.PortUsed     = pointer[0] + (pointer[1] << 8);  //Get the setup
   \                     ??GetHartSetup_0:
   \   00000014   910C               LD      R16, X
   \   00000016   01FD               MOVW    R31:R30, R27:R26
   \   00000018   8111               LDD     R17, Z+1
   \   0000001A   ....               LDI     R30, LOW((TData + 144))
   \   0000001C   ....               LDI     R31, HIGH((TData + 144))
   \   0000001E   8300               ST      Z, R16
   \   00000020   8311               STD     Z+1, R17
    580                  TData.Hart.HartSensor   = pointer[2] + (pointer[3] << 8);  //Get the setup
   \   00000022   01FD               MOVW    R31:R30, R27:R26
   \   00000024   8102               LDD     R16, Z+2
   \   00000026   01FD               MOVW    R31:R30, R27:R26
   \   00000028   8113               LDD     R17, Z+3
   \   0000002A   ....               LDI     R30, LOW((TData + 146))
   \   0000002C   ....               LDI     R31, HIGH((TData + 146))
   \   0000002E   8300               ST      Z, R16
   \   00000030   8311               STD     Z+1, R17
    581                  WriteEEPROMByte(EEPROM_PORTSETUP, pointer[0]);     // store in EEPROM
   \   00000032   912C               LD      R18, X
   \   00000034   E002               LDI     R16, 2
   \   00000036   E010               LDI     R17, 0
   \   00000038   ........           CALL    WriteEEPROMByte
    582                  WriteEEPROMByte(EEPROM_HART_SNS , pointer[2]);
   \   0000003C   01FD               MOVW    R31:R30, R27:R26
   \   0000003E   8122               LDD     R18, Z+2
   \   00000040   E004               LDI     R16, 4
   \   00000042   E010               LDI     R17, 0
   \   00000044   ........           CALL    WriteEEPROMByte
    583                  for ( char i = 0; i < 12; i++ ) {
   \   00000048   E000               LDI     R16, 0
   \                     ??GetHartSetup_3:
   \   0000004A   300C               CPI     R16, 12
   \   0000004C   F4E0               BRCC    ??GetHartSetup_4
    584                      TData.Hart.FailCnt[i][0] = 0;
   \   0000004E   2F20               MOV     R18, R16
   \   00000050   E030               LDI     R19, 0
   \   00000052   0F22               LSL     R18
   \   00000054   1F33               ROL     R19
   \   00000056   0F22               LSL     R18
   \   00000058   1F33               ROL     R19
   \   0000005A   01F9               MOVW    R31:R30, R19:R18
   \   0000005C   ....               SUBI    R30, LOW((-(TData) & 0xFFFF))
   \   0000005E   ....               SBCI    R31, (-(TData) & 0xFFFF) >> 8
   \   00000060   E010               LDI     R17, 0
   \   00000062   8310               ST      Z, R17
   \   00000064   E010               LDI     R17, 0
   \   00000066   8311               STD     Z+1, R17
    585                      TData.Hart.FailCnt[i][1] = 0;
   \   00000068   2F20               MOV     R18, R16
   \   0000006A   E030               LDI     R19, 0
   \   0000006C   0F22               LSL     R18
   \   0000006E   1F33               ROL     R19
   \   00000070   0F22               LSL     R18
   \   00000072   1F33               ROL     R19
   \   00000074   01F9               MOVW    R31:R30, R19:R18
   \   00000076   ....               SUBI    R30, LOW((-(TData) & 0xFFFF))
   \   00000078   ....               SBCI    R31, (-(TData) & 0xFFFF) >> 8
   \   0000007A   E010               LDI     R17, 0
   \   0000007C   8312               STD     Z+2, R17
   \   0000007E   E010               LDI     R17, 0
   \   00000080   8313               STD     Z+3, R17
    586                  }
   \   00000082   9503               INC     R16
   \   00000084   CFE2               RJMP    ??GetHartSetup_3
    587                  break;
   \                     ??GetHartSetup_4:
   \   00000086   C045               RJMP    ??GetHartSetup_2
    588              case 6:
    589                  {
    590                      TData.Hart.PortUsed     = pointer[0] + (pointer[1] << 8);  //Get the setup
   \                     ??GetHartSetup_1:
   \   00000088   910C               LD      R16, X
   \   0000008A   01FD               MOVW    R31:R30, R27:R26
   \   0000008C   8111               LDD     R17, Z+1
   \   0000008E   ....               LDI     R30, LOW((TData + 144))
   \   00000090   ....               LDI     R31, HIGH((TData + 144))
   \   00000092   8300               ST      Z, R16
   \   00000094   8311               STD     Z+1, R17
    591                      TData.Hart.HartSensor   = pointer[2] + (pointer[3] << 8);  //Get the setup
   \   00000096   01FD               MOVW    R31:R30, R27:R26
   \   00000098   8102               LDD     R16, Z+2
   \   0000009A   01FD               MOVW    R31:R30, R27:R26
   \   0000009C   8113               LDD     R17, Z+3
   \   0000009E   ....               LDI     R30, LOW((TData + 146))
   \   000000A0   ....               LDI     R31, HIGH((TData + 146))
   \   000000A2   8300               ST      Z, R16
   \   000000A4   8311               STD     Z+1, R17
    592                      unsigned AdditionalCmd  = pointer[4] + (pointer[5] << 8);  //Get the extra command
   \   000000A6   01FD               MOVW    R31:R30, R27:R26
   \   000000A8   8184               LDD     R24, Z+4
   \   000000AA   01FD               MOVW    R31:R30, R27:R26
   \   000000AC   8195               LDD     R25, Z+5
    593                      if ( AdditionalCmd & 1 ) {
   \   000000AE   FB80               BST     R24, 0
   \   000000B0   F586               BRTC    ??GetHartSetup_2
    594                          WriteEEPROMByte(EEPROM_PORTSETUP, pointer[0]);     // store in EEPROM
   \   000000B2   912C               LD      R18, X
   \   000000B4   E002               LDI     R16, 2
   \   000000B6   E010               LDI     R17, 0
   \   000000B8   ........           CALL    WriteEEPROMByte
    595                          WriteEEPROMByte(EEPROM_HART_SNS , pointer[2]);
   \   000000BC   01FD               MOVW    R31:R30, R27:R26
   \   000000BE   8122               LDD     R18, Z+2
   \   000000C0   E004               LDI     R16, 4
   \   000000C2   E010               LDI     R17, 0
   \   000000C4   ........           CALL    WriteEEPROMByte
    596                          RestartCnt  = 0;
   \   000000C8   ....               LDI     R30, LOW(RestartCnt)
   \   000000CA   ....               LDI     R31, (RestartCnt) >> 8
   \   000000CC   E000               LDI     R16, 0
   \   000000CE   8300               ST      Z, R16
   \   000000D0   E000               LDI     R16, 0
   \   000000D2   8301               STD     Z+1, R16
    597                          for ( char i = 0; i < 12; i++ ) {
   \   000000D4   E000               LDI     R16, 0
   \                     ??GetHartSetup_5:
   \   000000D6   300C               CPI     R16, 12
   \   000000D8   F4E0               BRCC    ??GetHartSetup_2
    598                              TData.Hart.FailCnt[i][0] = 0;
   \   000000DA   2F20               MOV     R18, R16
   \   000000DC   E030               LDI     R19, 0
   \   000000DE   0F22               LSL     R18
   \   000000E0   1F33               ROL     R19
   \   000000E2   0F22               LSL     R18
   \   000000E4   1F33               ROL     R19
   \   000000E6   01F9               MOVW    R31:R30, R19:R18
   \   000000E8   ....               SUBI    R30, LOW((-(TData) & 0xFFFF))
   \   000000EA   ....               SBCI    R31, (-(TData) & 0xFFFF) >> 8
   \   000000EC   E010               LDI     R17, 0
   \   000000EE   8310               ST      Z, R17
   \   000000F0   E010               LDI     R17, 0
   \   000000F2   8311               STD     Z+1, R17
    599                              TData.Hart.FailCnt[i][1] = 0;
   \   000000F4   2F20               MOV     R18, R16
   \   000000F6   E030               LDI     R19, 0
   \   000000F8   0F22               LSL     R18
   \   000000FA   1F33               ROL     R19
   \   000000FC   0F22               LSL     R18
   \   000000FE   1F33               ROL     R19
   \   00000100   01F9               MOVW    R31:R30, R19:R18
   \   00000102   ....               SUBI    R30, LOW((-(TData) & 0xFFFF))
   \   00000104   ....               SBCI    R31, (-(TData) & 0xFFFF) >> 8
   \   00000106   E010               LDI     R17, 0
   \   00000108   8312               STD     Z+2, R17
   \   0000010A   E010               LDI     R17, 0
   \   0000010C   8313               STD     Z+3, R17
    600                          }
   \   0000010E   9503               INC     R16
   \   00000110   CFE2               RJMP    ??GetHartSetup_5
    601                      }
    602                      
    603                  }
    604                  break;
    605              }
    606                                                                         
    607          
    608          }
   \                     ??GetHartSetup_2:
   \   00000112   E0E6               LDI     R30, 6
   \   00000114   ........           JMP     ?EPILOGUE_B6_L09
   \   00000118                      REQUIRE RestartCnt
    609          
    610          /*************************************************************************
    611          *
    612          * Receive AN-ZBHART filter
    613          *
    614          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    615          void GetHartFilter( char *pointer) {
   \                     GetHartFilter:
   \   00000000   2F39               MOV     R19, R25
   \   00000002   2F48               MOV     R20, R24
    616          
    617              for ( int port = 0; port < 12; port++ ) {
   \   00000004   E080               LDI     R24, 0
   \   00000006   E090               LDI     R25, 0
   \                     ??GetHartFilter_0:
   \   00000008   308C               CPI     R24, 12
   \   0000000A   E020               LDI     R18, 0
   \   0000000C   0792               CPC     R25, R18
   \   0000000E   F454               BRGE    ??GetHartFilter_1
    618                  TData.Hart.Filter[port] = *pointer++;  //Get the filter
   \   00000010   01F8               MOVW    R31:R30, R17:R16
   \   00000012   8120               LD      R18, Z
   \   00000014   01FC               MOVW    R31:R30, R25:R24
   \   00000016   ....               SUBI    R30, LOW((-(TData + 160) & 0xFFFF))
   \   00000018   ....               SBCI    R31, HIGH((-(TData + 160) & 0xFFFF))
   \   0000001A   8320               ST      Z, R18
   \   0000001C   5F0F               SUBI    R16, 255
   \   0000001E   4F1F               SBCI    R17, 255
    619              }
   \   00000020   9601               ADIW    R25:R24, 1
   \   00000022   CFF2               RJMP    ??GetHartFilter_0
    620          }
   \                     ??GetHartFilter_1:
   \   00000024   2F84               MOV     R24, R20
   \   00000026   2F93               MOV     R25, R19
   \   00000028   9508               RET
    621          
    622          
    623          /*************************************************************************
    624          *
    625          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    626          *
    627          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    628          char CalcDSTxChecksum(unsigned  Length) {
   \                     CalcDSTxChecksum:
   \   00000000   01BC               MOVW    R23:R22, R25:R24
   \   00000002   01A8               MOVW    R21:R20, R17:R16
    629              unsigned char csum = 0;
   \   00000004   E000               LDI     R16, 0
    630              for ( short cnt = 0; cnt < Length; cnt++ ) {
   \   00000006   E080               LDI     R24, 0
   \   00000008   E090               LDI     R25, 0
   \                     ??CalcDSTxChecksum_0:
   \   0000000A   1784               CP      R24, R20
   \   0000000C   0795               CPC     R25, R21
   \   0000000E   F480               BRCC    ??CalcDSTxChecksum_1
    631                  csum = crc[csum ^ My485UART.pTxBuffer[cnt + 4]];
   \   00000010   E010               LDI     R17, 0
   \   00000012   01FC               MOVW    R31:R30, R25:R24
   \   00000014   ....               SUBI    R30, LOW((-(My485UART + 128) & 0xFFFF))
   \   00000016   ....               SBCI    R31, HIGH((-(My485UART + 128) & 0xFFFF))
   \   00000018   8120               LD      R18, Z
   \   0000001A   E030               LDI     R19, 0
   \   0000001C   2702               EOR     R16, R18
   \   0000001E   2713               EOR     R17, R19
   \   00000020   01F8               MOVW    R31:R30, R17:R16
   \   00000022   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000024   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000026   ....               LDI     R19, (crc) >> 16
   \   00000028   BF3B               OUT     0x3B, R19
   \   0000002A   9106               ELPM    R16, Z
    632              }
   \   0000002C   9601               ADIW    R25:R24, 1
   \   0000002E   CFED               RJMP    ??CalcDSTxChecksum_0
    633              return csum;
   \                     ??CalcDSTxChecksum_1:
   \   00000030   01CB               MOVW    R25:R24, R23:R22
   \   00000032   9508               RET
    634          }

   \                                 In  segment SWITCH, align 2, keep-with-next
   \                     `?<Jumptable for ANPRO10_UnpackPacket>_0`:
   \   00000000   0000               DW      0
   \   00000002   01                 DB      1
   \   00000003   ....               DW      (??ANPRO10_UnpackPacket_5) /2
   \   00000005   ....               DW      (??ANPRO10_UnpackPacket_17) /2
   \   00000007   01                 DB      0x1
   \   00000008   ....               DW      (??ANPRO10_UnpackPacket_17) /2
   \   0000000A   03FEE7             DB      254,0x3,0xe7
   \   0000000D   ....               DW      (??ANPRO10_UnpackPacket_4) /2
   \   0000000F   0A                 DB      0xa
   \   00000010   ....               DW      (??ANPRO10_UnpackPacket_7) /2
   \   00000012   0A                 DB      0xa
   \   00000013   ....               DW      (??ANPRO10_UnpackPacket_8) /2
   \   00000015   32                 DB      0x32
   \   00000016   ....               DW      (??ANPRO10_UnpackPacket_9) /2
   \   00000018   0A                 DB      0xa
   \   00000019   ....               DW      (??ANPRO10_UnpackPacket_10) /2
   \   0000001B   0A                 DB      0xa
   \   0000001C   ....               DW      (??ANPRO10_UnpackPacket_11) /2
   \   0000001E   A0                 DB      0xa0
   \   0000001F   ....               DW      (??ANPRO10_UnpackPacket_12) /2
   \   00000021   0A                 DB      0xa
   \   00000022   ....               DW      (??ANPRO10_UnpackPacket_13) /2
   \   00000024   0A                 DB      0xa
   \   00000025   ....               DW      (??ANPRO10_UnpackPacket_14) /2
   \   00000027   0A                 DB      0xa
   \   00000028   ....               DW      (??ANPRO10_UnpackPacket_15) /2
   \   0000002A   0A                 DB      0xa
   \   0000002B   ....               DW      (??ANPRO10_UnpackPacket_16) /2
   \   0000002D   02FE6C             DB      254,0x2,0x6c
   \   00000030   ....               DW      (??ANPRO10_UnpackPacket_6) /2
   \   00000032   FB                 DB      251
   \   00000033   00                 DB      0
    635          
    636          

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
     18      2   ANPRO10_IO_Receive
       18      2   -> ANPRO10_UnpackPacket
       18      2   -> MyAddress
       18      2   -> OS_Delay
       18      2   -> OS_GetMail1
       18      2   -> OS_GetMailTimed
     10      2   ANPRO10_UnpackPacket
       10      2   -> BuildADInt
       10      2   -> BuildEEPROMData
       10      2   -> BuildHartFilter
       10      2   -> BuildHartSetup
       10      2   -> BuildMDataHart
       10      2   -> BuildStackStatus
       10      2   -> BuildStatusData
       10      2   -> GetEEPROMData
       10      2   -> GetGotoBootloader
       10      2   -> GetHartFilter
       10      2   -> GetHartSetup
       10      2   -> GetResetEEPROM
       10      2   -> My485UART_BuildTail
       10      2 ?SV_SWITCH_L06
      4      2   BuildADInt
      5      2   BuildEEPROMData
        5      2   -> ReadEEPROMBuffer
        5      2 ?S_EC_MUL_L02
      0      2   BuildHartFilter
      0      2   BuildHartSetup
      4      2   BuildMDataHart
      6      2   BuildStackStatus
        6      2   -> OS_GetStackSpace
      4      2   BuildStatusData
        4      2   -> MyAddress
      0      2   CalcDSTxChecksum
      7      2   GetEEPROMData
        7      2   -> OS_Delay
        7      2   -> OS__Gettime
        7      2   -> WriteEEPROMBuffer
        7      2 ?S_EC_MUL_L02
      4      2   GetGotoBootloader
        4      2   -- Indirect call
      0      2   GetHartFilter
      6      2   GetHartSetup
        6      2   -> WriteEEPROMByte
      0      2   GetResetEEPROM
        0      2   -> EEPROMReset
      2      2   My485UART_BuildHeader
        2      2   -> MyAddress
      4      2   My485UART_BuildTail
        4      2   -> CalcDSTxChecksum
        4      2   -> My485UART_BuildHeader
        4      2   -> OS_Delay
        4      2   -> OS_Error
        4      2   -> OS_WaitEvent
      0      2   Usart0Handler
        0      2   -> ANPRO10_IO_Receive


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      52  ?<Jumptable for ANPRO10_UnpackPacket>_0
     508  ANPRO10_IO_Receive
     266  ANPRO10_UnpackPacket
     278  BuildADInt
     322  BuildEEPROMData
     214  BuildHartFilter
     240  BuildHartSetup
     362  BuildMDataHart
     500  BuildStackStatus
     622  BuildStatusData
      52  CalcDSTxChecksum
     316  GetEEPROMData
      44  GetGotoBootloader
      42  GetHartFilter
     280  GetHartSetup
       6  GetResetEEPROM
       2  LastCommand
     100  My485UART_BuildHeader
     392  My485UART_BuildTail
       2  RestartCnt
      16  Usart0Handler
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_UCSR0B
       1  hasStartedUARTTask
       7  -- Other

 
     8 bytes in segment ABSOLUTE
 4 560 bytes in segment CODE
     7 bytes in segment INITTAB
     3 bytes in segment NEAR_Z
    52 bytes in segment SWITCH
 
 4 612 bytes of CODE memory (+ 7 bytes shared)
     3 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: 1
