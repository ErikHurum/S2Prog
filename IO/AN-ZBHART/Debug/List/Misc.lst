###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       15/Nov/2023  09:53:37
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\Misc.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW4B2C.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\Misc.c" --cpu=m1281
#        -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\Obj" -D
#        OS_LIBMODE_D -D OS_UART=-1 -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\List" -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\INC\\" -I
#        ..\..\..\Shared\Inc\\ --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\List\Misc.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\Obj\Misc.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\Misc.c
      1          /****************************************************************************************
      2          /  Misc. routines
      3          /
      4          ***************************************************************************************/
      5          #include "iom1280.h"
      6          #include "stdio.h"
      7          #include "stdlib.h"
      8          #include "math.h"
      9          #include "externals.h"
     10          #include "version.h"
     11          #include "inavr.h"
     12          #include "string.h"
     13          #include "hart.h"
     14          
     15          _//_no_init int RestartCnt             @0x21FD;
     16          volatile char RestartCmd = 0;
     17          
     18          
     19          void WDT_off(void)
     20          {
     21              __disable_interrupt();
     22              __watchdog_reset();
     23              /* Clear WDRF in MCUSR */
     24              MCUSR &= ~(1<<WDRF);
     25              /* Write logical one to WDCE and WDE */
     26              /* Keep old prescaler setting to prevent unintentional time-out
     27              */
     28              WDTCSR = (1<<WDE) | (1<<WDP2) | (1<<WDP1) | (1<<WDP0);
     29              /* Turn off WDT */
     30              WDTCSR = 0x00;
     31              __enable_interrupt();
     32          }
     33          
     34          void WDT_Prescaler_Change(void)
     35          {
     36              __disable_interrupt();
     37              __watchdog_reset();
     38              /* Start timed equence */
     39              WDTCSR |= (1<<WDCE) | (1<<WDE);
     40              /* Set new prescaler(time-out) value = 64K cycles (~0.5 s) */
     41              //WDTCSR = (1<<WDE) | (1<<WDP2) | (1<<WDP0);
     42              /* Set new prescaler(time-out) value = 256K cycles (~2.0 s) */
     43              WDTCSR = (1<<WDE) | (1<<WDP2) | (1<<WDP1) | (1<<WDP0);
     44          
     45          
     46          __enable_interrupt();
     47          }
     48          
     49          /*************************************************************************
     50          *   (This is a task)
     51          *  Watchdog handler
     52          *
     53          *************************************************************************/
     54          #define NUMBER_OF_TASKS 7
     55          void WatchDogHandler(void) {
     56          #if defined( OS_LIBMODE_D) || defined( OS_LIBMODE_S )
     57              static const char *StackCheck[] = { 
     58                  StackTest1              , StackTest2            , 
     59                  StackTest3              , StackTest4            , 
     60                  StackTest5              , StackTest6            , 
     61                  _hart_task0.StackTest1  , _hart_task0.StackTest2, 
     62                  _hart_task1.StackTest1  , _hart_task1.StackTest2,
     63                  _hart_task2.StackTest1  , _hart_task2.StackTest2 };
     64          #endif
     65              char HartComCheckTimeCnt = 0;
     66          #ifdef OS_LIBMODE_DP
     67              char LoadCnt            = 0;
     68              int RawPerformance[NUMBER_OF_TASKS];
     69              static OS_TASK *MyTasks[NUMBER_OF_TASKS] = { &_hart_task0.tcb, &_hart_task1.tcb, &_hart_task2.tcb, &TCB_USART0, &TCB_AD7715, &TCB_INT_ADC, &TCB_WATCHDOG };
     70          #endif
     71              OS_Delay(100);                         // wait 1 seconds for other tasks to start and set TaskStatus
     72              //asm("WDR");                             // kick the dog!!
     73              //WDTCSR = 0x1f;
     74              //WDTCSR = 0x0f;
     75              //asm("WDR");                             // kick the dog!!
     76              while (1) {
     77                  OS_Delay(500);
     78                  OS_U32 CurrentTime = OS_Time;
     79                  if (CriticalComError) {
     80                      OS_Error(ZB_ERR_UART);
     81                  } else if (HartComCheckTimeCnt++ >= 10) {
     82                      if (labs(CurrentTime - _hart_task0.LastHartTaskRunTime) > 10000) {
     83                          OS_Error(ZB_ERR_MODEM_0);
     84                      }
     85                      if (labs(CurrentTime - _hart_task1.LastHartTaskRunTime) > 10000) {
     86                          OS_Error(ZB_ERR_MODEM_1);
     87                      }
     88                      if (labs(CurrentTime - _hart_task2.LastHartTaskRunTime) > 10000) {
     89                          OS_Error(ZB_ERR_MODEM_2);
     90                      }
     91                  } else if (labs(CurrentTime - Last_ADC_OK_Time) > 5000) {
     92                      OS_Error(ZB_ERR_EXT_ADC);
     93                  }
     94                  if (!RestartCmd) {
     95                      __watchdog_reset();               //kick the dog
     96                  }
     97          #if defined( OS_LIBMODE_D) || defined( OS_LIBMODE_S )
     98                  char ErrorStack = 0;
     99                  for (char i = 0; i < NELEMENTS(StackCheck); i++) {
    100                      if (memcmp(StackCheck[i], "123456789", 10)) {
    101                          ErrorStack = i + 1;
    102                      }
    103                  }
    104          #endif
    105          #ifdef OS_LIBMODE_DP
    106                  if (LoadCnt++ > 5) {
    107                      OS_STAT_Sample();
    108                      OS_Delay(10);
    109                      int tmpRawLoad = 0;
    110                      for (char i = 0; i < NUMBER_OF_TASKS; i++) {
    111                          RawPerformance[i] = OS_STAT_GetLoad(MyTasks[i]);
    112                          tmpRawLoad       += RawPerformance[i];
    113                      }
    114                  }
    115          #endif
    116              }
    117          }
    118          
    119          
    120          /*************************************************************************
    121          *
    122          *  Get my address
    123          *
    124          *************************************************************************/
    125          char MyAddress(void) {
    126          
    127          #if (OS_UART == 0)
    128              return 0;                   // Debug only
    129          #else
    130              int Address = (~(PINE >> 4) & 0x0f);
    131              return Address;
    132              //return(~(PINE>>4) & 0x0f) ;
    133          #endif
    134          }
    135          
    136          /*************************************************************************
    137          *
    138          *  Check for legal float
    139          *
    140          *************************************************************************/
    141          char IsFloat(float A) {
    142              long exp;
    143              // A NAN has an exponent of 255 (shifted left 23 positions) and
    144              // Denormalized has an exponent set to 0
    145              exp = *(long *)&A & 0x7F800000L;
    146              //int mantissa = *(int*)&A & 0x007FFFFF;
    147              if (exp && (exp != 0x7F800000L)) {
    148                  return (true);
    149              }
    150              return (false);
    151          }
    152          

Errors: 3
Warnings: 1
