###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       02/Oct/2023  15:18:53
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\hart_diag.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWCFDD.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\hart_diag.c"
#        --cpu=m1280 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\Obj" -D
#        OS_LIBMODE_D -D OS_UART=-1 -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\List" -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\INC\\" -I
#        ..\..\..\Shared\Inc\\ --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\List\hart_diag.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Debug\Obj\hart_diag.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\hart_diag.c
      1          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0x10b
   \   union <unnamed> volatile __ext_io _A_PORTL
   \                     _A_PORTL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x109
   \   union <unnamed> volatile __ext_io _A_PINL
   \                     _A_PINL:
   \   00000000                      DS8 1
      2          #include "version.h"
      3          #include "inavr.h"
      4          #include "RTOS.h"
      5          
      6          #include "constants.h"
      7          
      8          #include "hart_common.h"
      9          #include "hart.h"
     10          #include "hart_diag.h"
     11          #include "hart_gpio.h"
     12          #include "structs.h"
     13          #include "externals.h"
     14          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     15          static char hasStartedHartDiag = false;
   \                     hasStartedHartDiag:
   \   00000000                      DS8 1
     16          
     17          /////////////////////////////////////////////////////////////////////////////////////
     18          //
     19          // AD7715 summary.
     20          // * some people are stupid enough not to write this down in the code. So I do.
     21          //   -hkim-
     22          //
     23          //
     24          // a. setup communication register
     25          //
     26          // 7        6       5       4       3       2       1       0
     27          // must     must    rs1     rs0     r/w     sdby    g1      g0
     28          // be 0     be 0                    r=1     1 =
     29          //                                  w=0     p down  gain setup
     30          //
     31          // rs1    rs0
     32          // ============
     33          // 0      0       comm reg        8  bit
     34          // 0      1       setup reg       8  bit
     35          // 1      0       test reg        8  bit
     36          // 1      1       data reg        16 bit
     37          //
     38          // g1     g0
     39          // ============
     40          //  0     0       x1
     41          //  0     1       x2
     42          //  1     0       x32
     43          //  1     1       x128
     44          //
     45          // b. setup register (rs1,rs0= 0,1
     46          //
     47          // 7        6       5       4       3       2       1       0
     48          // MD1      MD0     CLK     FS1     FS0     B/U     BUF     FSYNC
     49          // mode selection   opr     output rate     bi/uni  buf     filter
     50          //                  freq                    polar   control sync
     51          //
     52          // CLK should be set to 0 with 1 Mhz clock
     53          //
     54          // MD1    MD0
     55          // ============
     56          // 0      0       normal mode
     57          // 0      1       self calib
     58          // 1      0       zero scale calib
     59          // 1      1       full scale calib
     60          //
     61          // CLK      FS1     FS0
     62          // ================================
     63          // 0        0       0           20 Hz
     64          // 0        0       1           25 Hz
     65          // 0        1       0           100 Hz
     66          // 0        1       1           200 Hz
     67          // 1        0       0           50 Hz
     68          // 1        0       1           60 Hz
     69          // 1        1       0           250 Hz
     70          // 1        1       1           5600 Hz
     71          //
     72          // B/U : 0 bipolar, 1 unipolar
     73          //
     74          // c. test register (rs1,rs0 = 1,0
     75          // just don't use it. chip maker doesn't want you to fuck up with this.
     76          //
     77          // d. data register (rs1,rs0 = 1,1)
     78          //
     79          /////////////////////////////////////////////////////////////////////////////////////
     80          
     81          ////////////////////////////////////////////////////////////////////////////////
     82          //
     83          // private defines
     84          //
     85          ////////////////////////////////////////////////////////////////////////////////
     86          #define HART_DIAG_CONVERSION_COMPLETE         0x01
     87          
     88          ////////////////////////////////////////////////////////////////////////////////
     89          //
     90          // private prototypes
     91          //
     92          ////////////////////////////////////////////////////////////////////////////////
     93          
     94          ////////////////////////////////////////////////////////////////////////////////
     95          //
     96          // hart module privates
     97          //
     98          ////////////////////////////////////////////////////////////////////////////////
     99          #if defined( OS_LIBMODE_D) || defined( OS_LIBMODE_S )

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
    100          char StackTest5[] = {"123456789"};
   \                     StackTest5:
   \   00000000                      DS8 10
   \   0000000A                      REQUIRE `?<Initializer for StackTest5>`
    101          #endif

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    102          OS_STACKPTR int  _hart_diag_task_stack[150];
   \                     _hart_diag_task_stack:
   \   00000000                      DS8 300
    103          #if defined( OS_LIBMODE_D) || defined( OS_LIBMODE_S )

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
    104          char StackTest6[] = {"123456789"};
   \                     StackTest6:
   \   00000000                      DS8 10
   \   0000000A                      REQUIRE `?<Initializer for StackTest6>`
    105          #endif

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    106          OS_TASK          TCB_AD7715;
   \                     TCB_AD7715:
   \   00000000                      DS8 33

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    107          uint16_t         _num_adc_fuckups    = 0;
   \                     _num_adc_fuckups:
   \   00000000                      DS8 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    108          OS_U32           Last_ADC_FuckUpTime = 0;
   \                     Last_ADC_FuckUpTime:
   \   00000000                      DS8 4

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    109          OS_U32           Last_ADC_OK_Time    = 0;
   \                     Last_ADC_OK_Time:
   \   00000000                      DS8 4

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    110          char             CriticalADC_Failure = FALSE;
   \                     CriticalADC_Failure:
   \   00000000                      DS8 1
    111          ////////////////////////////////////////////////////////////////////////////////
    112          //
    113          // AD7715 related utilities
    114          //
    115          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    116          static void
    117          ad7715_toggle_debug_led(void) {
   \                     ad7715_toggle_debug_led:
    118              static uint8_t    on_off = 1;
    119          
    120              hart_gpio_debug_led(on_off);
   \   00000000   9100....           LDS     R16, ??on_off
   \   00000004   ........           CALL    hart_gpio_debug_led
    121              on_off = !on_off;
   \   00000008   9100....           LDS     R16, ??on_off
   \   0000000C   2300               TST     R16
   \   0000000E   F421               BRNE    ??ad7715_toggle_debug_led_0
   \   00000010   E001               LDI     R16, 1
   \   00000012   9300....           STS     ??on_off, R16
   \   00000016   9508               RET
   \                     ??ad7715_toggle_debug_led_0:
   \   00000018   E000               LDI     R16, 0
   \   0000001A   9300....           STS     ??on_off, R16
    122          }
   \   0000001E   9508               RET

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     ??on_off:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for on_off>`
    123          

   \                                 In  segment CODE, align 2, keep-with-next
    124          static uint8_t
    125          ad7715_read_byte(void) {
   \                     ad7715_read_byte:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
    126              uint8_t readbyte = 0;
   \   00000004   E090               LDI     R25, 0
    127              for (uint8_t i = 0; i <  8; i++) {
   \   00000006   E080               LDI     R24, 0
   \                     ??ad7715_read_byte_0:
   \   00000008   3088               CPI     R24, 8
   \   0000000A   F4B0               BRCC    ??ad7715_read_byte_1
    128                  readbyte <<= 1;                      // shift to next bit
   \   0000000C   0F99               LSL     R25
    129                  AD7715_CLK_LO();
   \   0000000E   9100010B           LDS     R16, 267
   \   00000012   7F0E               ANDI    R16, 0xFE
   \   00000014   9300010B           STS     267, R16
    130                  OS_Delayus(10);
   \   00000018   E00A               LDI     R16, 10
   \   0000001A   E010               LDI     R17, 0
   \   0000001C   ........           CALL    OS_Delayus
    131                  AD7715_CLK_HI();
   \   00000020   9100010B           LDS     R16, 267
   \   00000024   6001               ORI     R16, 0x01
   \   00000026   9300010B           STS     267, R16
    132          
    133                  if (AD7715_MISO_READ()) {
   \   0000002A   9100....           LDS     R16, _A_PINL
   \   0000002E   2F10               MOV     R17, R16
   \   00000030   FD11               SBRC    R17, 1
    134                      // data high
    135                      readbyte |= 0x01;                   // set bit high
   \   00000032   6091               ORI     R25, 0x01
    136                  }
    137              }
   \                     ??ad7715_read_byte_2:
   \   00000034   9583               INC     R24
   \   00000036   CFE8               RJMP    ??ad7715_read_byte_0
    138              return readbyte;
   \                     ??ad7715_read_byte_1:
   \   00000038   2F09               MOV     R16, R25
   \   0000003A   9189               LD      R24, Y+
   \   0000003C   9199               LD      R25, Y+
   \   0000003E   9508               RET
   \   00000040                      REQUIRE _A_PORTL
   \   00000040                      REQUIRE _A_PINL
    139          }
    140          

   \                                 In  segment CODE, align 2, keep-with-next
    141          static void
    142          ad7715_write_byte(uint8_t data) {
   \                     ad7715_write_byte:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   2F90               MOV     R25, R16
    143              for (uint8_t i = 0; i <  8; i++) {
   \   00000006   E080               LDI     R24, 0
   \                     ??ad7715_write_byte_0:
   \   00000008   3088               CPI     R24, 8
   \   0000000A   F510               BRCC    ??ad7715_write_byte_1
    144                  AD7715_CLK_LO();
   \   0000000C   9100010B           LDS     R16, 267
   \   00000010   7F0E               ANDI    R16, 0xFE
   \   00000012   9300010B           STS     267, R16
    145                  OS_Delayus(10);
   \   00000016   E00A               LDI     R16, 10
   \   00000018   E010               LDI     R17, 0
   \   0000001A   ........           CALL    OS_Delayus
    146                  if (data & 0x80) {                        // data bit = 1?
   \   0000001E   FB97               BST     R25, 7
   \   00000020   F436               BRTC    ??ad7715_write_byte_2
    147                      AD7715_MOSI_HI();
   \   00000022   9100010B           LDS     R16, 267
   \   00000026   6004               ORI     R16, 0x04
   \   00000028   9300010B           STS     267, R16
   \   0000002C   C005               RJMP    ??ad7715_write_byte_3
    148                  } else {
    149                      AD7715_MOSI_LO();
   \                     ??ad7715_write_byte_2:
   \   0000002E   9100010B           LDS     R16, 267
   \   00000032   7F0B               ANDI    R16, 0xFB
   \   00000034   9300010B           STS     267, R16
    150                  }
    151                  data <<= 1;                              // shift to next bit
   \                     ??ad7715_write_byte_3:
   \   00000038   0F99               LSL     R25
    152                  AD7715_CLK_HI();
   \   0000003A   9100010B           LDS     R16, 267
   \   0000003E   6001               ORI     R16, 0x01
   \   00000040   9300010B           STS     267, R16
    153                  OS_Delayus(10);
   \   00000044   E00A               LDI     R16, 10
   \   00000046   E010               LDI     R17, 0
   \   00000048   ........           CALL    OS_Delayus
    154              }
   \   0000004C   9583               INC     R24
   \   0000004E   CFDC               RJMP    ??ad7715_write_byte_0
    155          }
   \                     ??ad7715_write_byte_1:
   \   00000050   9189               LD      R24, Y+
   \   00000052   9199               LD      R25, Y+
   \   00000054   9508               RET
   \   00000056                      REQUIRE _A_PORTL
    156          

   \                                 In  segment CODE, align 2, keep-with-next
    157          static void
    158          ad7715_hard_reset(void) {
   \                     ad7715_hard_reset:
    159              hart_gpio_adc_reset(1);     // high
   \   00000000   E001               LDI     R16, 1
   \   00000002   ........           CALL    hart_gpio_adc_reset
    160              OS_Delay(100);
   \   00000006   E604               LDI     R16, 100
   \   00000008   E010               LDI     R17, 0
   \   0000000A   ........           CALL    OS_Delay
    161              hart_gpio_adc_reset(0);     // low
   \   0000000E   E000               LDI     R16, 0
   \   00000010   ........           CALL    hart_gpio_adc_reset
    162              OS_Delay(500);
   \   00000014   EF04               LDI     R16, 244
   \   00000016   E011               LDI     R17, 1
   \   00000018   ........           CALL    OS_Delay
    163              hart_gpio_adc_reset(1);     // high
   \   0000001C   E001               LDI     R16, 1
   \   0000001E   ........           CALL    hart_gpio_adc_reset
    164              OS_Delay(100);
   \   00000022   E604               LDI     R16, 100
   \   00000024   E010               LDI     R17, 0
   \   00000026   ........           CALL    OS_Delay
    165          }
   \   0000002A   9508               RET
    166          

   \                                 In  segment CODE, align 2, keep-with-next
    167          static void
    168          ad7715_put_on_hold(void) {
   \                     ad7715_put_on_hold:
    169              // select setup reg
    170              ad7715_write_byte(0x10);
   \   00000000   E100               LDI     R16, 16
   \   00000002   ....               RCALL   ad7715_write_byte
    171          
    172              // set fsync to put ADC on hold
    173              ad7715_write_byte(0x0f);
   \   00000004   E00F               LDI     R16, 15
   \   00000006   ....               RCALL   ad7715_write_byte
    174          }
   \   00000008   9508               RET
    175          

   \                                 In  segment CODE, align 2, keep-with-next
    176          static void
    177          ad7715_start_next_sample(void) {
   \                     ad7715_start_next_sample:
    178              // select setup reg
    179              ad7715_write_byte(0x10);
   \   00000000   E100               LDI     R16, 16
   \   00000002   ....               RCALL   ad7715_write_byte
    180          
    181              // clear fsync bit to start conversion
    182              ad7715_write_byte(0x0e);
   \   00000004   E00E               LDI     R16, 14
   \   00000006   ....               RCALL   ad7715_write_byte
    183          
    184              //
    185              // sample will be available after 3x1/output rate, which is 3x1/25 = 120ms.
    186              // code will be notified by /DRDY
    187              //
    188          }
   \   00000008   9508               RET
    189          

   \                                 In  segment CODE, align 2, keep-with-next
    190          static uint16_t ad7715_read_sample(void) {
   \                     ad7715_read_sample:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    191              uint8_t   lo, hi;
    192              uint16_t  ret;
    193          
    194              // select data reg
    195              ad7715_write_byte(0x38);
   \   00000004   E308               LDI     R16, 56
   \   00000006   ....               RCALL   ad7715_write_byte
    196          
    197              hi = ad7715_read_byte();
   \   00000008   ....               RCALL   ad7715_read_byte
   \   0000000A   2FB0               MOV     R27, R16
    198              lo = ad7715_read_byte();
   \   0000000C   ....               RCALL   ad7715_read_byte
   \   0000000E   2FA0               MOV     R26, R16
    199          
    200              ret = (uint16_t)(hi << 8 | lo);
   \   00000010   2F3B               MOV     R19, R27
   \   00000012   E020               LDI     R18, 0
   \   00000014   2F0A               MOV     R16, R26
   \   00000016   E010               LDI     R17, 0
   \   00000018   2B20               OR      R18, R16
   \   0000001A   2B31               OR      R19, R17
   \   0000001C   01C9               MOVW    R25:R24, R19:R18
    201          
    202              return ret;
   \   0000001E   018C               MOVW    R17:R16, R25:R24
   \   00000020   E0E4               LDI     R30, 4
   \   00000022   ........           JMP     ?EPILOGUE_B4_L09
    203          }
    204          

   \                                 In  segment CODE, align 2, keep-with-next
    205          static uint8_t ad7715_wait_for_drdy(void) {
   \                     ad7715_wait_for_drdy:
    206              char Status = OS_WaitSingleEventTimed(HART_DIAG_CONVERSION_COMPLETE, 1000);
   \   00000000   EE28               LDI     R18, 232
   \   00000002   E033               LDI     R19, 3
   \   00000004   E001               LDI     R16, 1
   \   00000006   ........           CALL    OS_WaitSingleEventTimed
    207              if (!Status) {
   \   0000000A   2300               TST     R16
   \   0000000C   F4A9               BRNE    ??ad7715_wait_for_drdy_0
    208                  Last_ADC_FuckUpTime = OS_Time;
   \   0000000E   ....               LDI     R30, LOW(OS_Global)
   \   00000010   ....               LDI     R31, (OS_Global) >> 8
   \   00000012   8942               LDD     R20, Z+18
   \   00000014   8953               LDD     R21, Z+19
   \   00000016   8964               LDD     R22, Z+20
   \   00000018   8975               LDD     R23, Z+21
   \   0000001A   ....               LDI     R30, LOW(Last_ADC_FuckUpTime)
   \   0000001C   ....               LDI     R31, (Last_ADC_FuckUpTime) >> 8
   \   0000001E   8340               ST      Z, R20
   \   00000020   8351               STD     Z+1, R21
   \   00000022   8362               STD     Z+2, R22
   \   00000024   8373               STD     Z+3, R23
    209                  _num_adc_fuckups++;
   \   00000026   ....               LDI     R30, LOW(_num_adc_fuckups)
   \   00000028   ....               LDI     R31, (_num_adc_fuckups) >> 8
   \   0000002A   8120               LD      R18, Z
   \   0000002C   8131               LDD     R19, Z+1
   \   0000002E   5F2F               SUBI    R18, 255
   \   00000030   4F3F               SBCI    R19, 255
   \   00000032   8320               ST      Z, R18
   \   00000034   8331               STD     Z+1, R19
   \   00000036   9508               RET
    210              } else {
    211                  Last_ADC_OK_Time = OS_Time;
   \                     ??ad7715_wait_for_drdy_0:
   \   00000038   ....               LDI     R30, LOW(OS_Global)
   \   0000003A   ....               LDI     R31, (OS_Global) >> 8
   \   0000003C   8942               LDD     R20, Z+18
   \   0000003E   8953               LDD     R21, Z+19
   \   00000040   8964               LDD     R22, Z+20
   \   00000042   8975               LDD     R23, Z+21
   \   00000044   ....               LDI     R30, LOW(Last_ADC_OK_Time)
   \   00000046   ....               LDI     R31, (Last_ADC_OK_Time) >> 8
   \   00000048   8340               ST      Z, R20
   \   0000004A   8351               STD     Z+1, R21
   \   0000004C   8362               STD     Z+2, R22
   \   0000004E   8373               STD     Z+3, R23
    212              }
    213              return Status;
   \   00000050   9508               RET
    214          }
    215          

   \                                 In  segment CODE, align 2, keep-with-next
    216          static void ad7715_do_calibration(void) {
   \                     ad7715_do_calibration:
    217              //
    218              // set current channel to 2.5V reference
    219              //
    220              hart_gpio_adc_channel_select((hart_channel_t)14);
   \   00000000   E00E               LDI     R16, 14
   \   00000002   ........           CALL    hart_gpio_adc_channel_select
    221          
    222              //
    223              // select setup reg (0,1)
    224              // 7        6         5         4         3         2         1         0
    225              // 0        0         0         1         0         0         0         0
    226              //                    setup reg           write     no        gain x1
    227              //                                                  stby
    228              ad7715_write_byte(0x10);
   \   00000006   E100               LDI     R16, 16
   \   00000008   ....               RCALL   ad7715_write_byte
    229          
    230              //
    231              // setup reg to perform calib
    232              //
    233              // 7        6         5         4         3         2         1         0
    234              // 0        1         0         0         1         1         1         0
    235              // seld calib         1 Mhz     25 Hz Rate          Unipolar  buffed    no fsync
    236              // mode               clk
    237              //
    238              ad7715_write_byte(0x4e);
   \   0000000A   E40E               LDI     R16, 78
   \   0000000C   ....               RCALL   ad7715_write_byte
    239          
    240              //
    241              // calibration will be complete after 6 x 1/outpur rate
    242              // which is 6 * 1/25 = roughly 240ms and /DRDY will be asserted.
    243              //
    244              ad7715_wait_for_drdy();
   \   0000000E   ....               RCALL   ad7715_wait_for_drdy
    245          
    246              //
    247              // read dummy sample. /DRDY will go hi again after this
    248              //
    249              ad7715_read_sample();
   \   00000010   ....               RCALL   ad7715_read_sample
    250          
    251              ad7715_put_on_hold();
   \   00000012   ....               RCALL   ad7715_put_on_hold
    252          
    253              // back to 0
    254              hart_gpio_adc_channel_select(hart_channel_0);
   \   00000014   E000               LDI     R16, 0
   \   00000016   ........           CALL    hart_gpio_adc_channel_select
    255          }
   \   0000001A   9508               RET
    256          
    257          
    258          ////////////////////////////////////////////////////////////////////////////////
    259          //
    260          // ADC interrupt handler
    261          //
    262          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    263          void INT_Handler_INT0(void) {
   \                     INT_Handler_INT0:
    264              if (hasStartedHartDiag) {
   \   00000000   9100....           LDS     R16, hasStartedHartDiag
   \   00000004   2300               TST     R16
   \   00000006   F029               BREQ    ??INT_Handler_INT0_0
    265                  OS_SignalEvent(HART_DIAG_CONVERSION_COMPLETE, &TCB_AD7715);
   \   00000008   ....               LDI     R18, LOW(TCB_AD7715)
   \   0000000A   ....               LDI     R19, (TCB_AD7715) >> 8
   \   0000000C   E001               LDI     R16, 1
   \   0000000E   ........           CALL    OS_SignalEvent
    266              }
    267          }
   \                     ??INT_Handler_INT0_0:
   \   00000012   9508               RET
    268          
    269          #pragma vector=INT0_vect

   \                                 In  segment CODE, align 2, keep-with-next
    270          __interrupt void IntHandler_INT0(void) {
   \                     IntHandler_INT0:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    271              OS_CallISR(INT_Handler_INT0);
   \   00000024   ....               LDI     R16, LOW(INT_Handler_INT0/2)
   \   00000026   ....               LDI     R17, (INT_Handler_INT0/2) >> 8
   \   00000028   ........           CALL    OS_CallISR_Debug
    272          }
   \   0000002C   BF9B               OUT     0x3B, R25
   \   0000002E   BF8F               OUT     0x3F, R24
   \   00000030   9109               LD      R16, Y+
   \   00000032   9119               LD      R17, Y+
   \   00000034   9129               LD      R18, Y+
   \   00000036   9139               LD      R19, Y+
   \   00000038   9149               LD      R20, Y+
   \   0000003A   9159               LD      R21, Y+
   \   0000003C   9169               LD      R22, Y+
   \   0000003E   9179               LD      R23, Y+
   \   00000040   9009               LD      R0, Y+
   \   00000042   9019               LD      R1, Y+
   \   00000044   9029               LD      R2, Y+
   \   00000046   9039               LD      R3, Y+
   \   00000048   91E9               LD      R30, Y+
   \   0000004A   91F9               LD      R31, Y+
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9518               RETI
    273          
    274          
    275          
    276          ////////////////////////////////////////////////////////////////////////////////
    277          //
    278          // private utilities
    279          //
    280          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    281          static void hart_diag_configure_adc(void) {
   \                     hart_diag_configure_adc:
    282              ad7715_hard_reset();
   \   00000000   ....               RCALL   ad7715_hard_reset
    283              OS_Delay(10);
   \   00000002   E00A               LDI     R16, 10
   \   00000004   E010               LDI     R17, 0
   \   00000006   ........           CALL    OS_Delay
    284              ad7715_do_calibration();
   \   0000000A   ....               RCALL   ad7715_do_calibration
    285              OS_Delay(10);
   \   0000000C   E00A               LDI     R16, 10
   \   0000000E   E010               LDI     R17, 0
   \   00000010   ........           CALL    OS_Delay
    286          }
   \   00000014   9508               RET
    287          
    288          ////////////////////////////////////////////////////////////////////////////////
    289          //
    290          // ADC raw to mA
    291          //
    292          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    293          static void hart_diag_set_diag_value(hart_channel_t chnl, uint16_t raw_adc) {
   \                     hart_diag_set_diag_value:
   \   00000000   ........           CALL    ?PROLOGUE12_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004   2EA0               MOV     R10, R16
   \   00000006   0149               MOVW    R9:R8, R19:R18
    294              // the H/W circuit is created using INA138 current shunt and 5 ohm resistor.
    295              //
    296              // The input current is between 0 and 20mA. So voltage drop across the 5 Ohm
    297              // resistor will be between 0 and 0.1V. This voltage difference is fed into
    298              // INA138 and with 100K RL resistor, the voltage is amplied by 20 times.
    299              //
    300              // So the measured voltage to the ADC is in the range of 0V and 2V, where
    301              // 0V corresponds to 0mA and 2V corresponds to 20mA.
    302              //
    303              // Additionally ADC ref voltage is 2.5V, which means 0xffff corresponds 2.5V
    304              //
    305              // hkim is kind enough to analyze this freaking circuit himself and leave a
    306              // record here. Appreciate him.
    307              //
    308              // -hkim-
    309              //
    310              //float   voltage = 2.5f * ((float)(raw_adc)) / 65535.0;
    311              //float   current = voltage / 10.0 * 100.0f * TData.Hart.Gain[chnl]-TData.Hart.Offset[chnl];
    312              float   current = ((2.5f * ((float)(raw_adc)) / 65535.0) / 10.0 * 100.0f);// *(1.0 / 1.0028280); // * TData.Hart.Gain[chnl] - TData.Hart.Offset[chnl];
   \   00000008   0184               MOVW    R17:R16, R9:R8
   \   0000000A   E020               LDI     R18, 0
   \   0000000C   E030               LDI     R19, 0
   \   0000000E   ........           CALL    ?UL2F_L04
   \   00000012   E040               LDI     R20, 0
   \   00000014   E050               LDI     R21, 0
   \   00000016   E260               LDI     R22, 32
   \   00000018   E470               LDI     R23, 64
   \   0000001A   ........           CALL    ?F_MUL_L04
   \   0000001E   E040               LDI     R20, 0
   \   00000020   EF5F               LDI     R21, 255
   \   00000022   E76F               LDI     R22, 127
   \   00000024   E477               LDI     R23, 71
   \   00000026   ........           CALL    ?F_DIV_L04
   \   0000002A   E040               LDI     R20, 0
   \   0000002C   E050               LDI     R21, 0
   \   0000002E   E260               LDI     R22, 32
   \   00000030   E471               LDI     R23, 65
   \   00000032   ........           CALL    ?F_DIV_L04
   \   00000036   E040               LDI     R20, 0
   \   00000038   E050               LDI     R21, 0
   \   0000003A   EC68               LDI     R22, 200
   \   0000003C   E472               LDI     R23, 66
   \   0000003E   ........           CALL    ?F_MUL_L04
   \   00000042   01C8               MOVW    R25:R24, R17:R16
   \   00000044   01D9               MOVW    R27:R26, R19:R18
    313              // EHSMarkuint16_t    current_final = (uint16_t)(current * 10);       // 10 = 1mA, 1 = 0.1mA
    314          
    315              switch (chnl) {
   \   00000046   2D0A               MOV     R16, R10
   \   00000048   5000               SUBI    R16, 0
   \   0000004A   500C               SUBI    R16, 12
   \   0000004C   F068               BRCS    ??hart_diag_set_diag_value_0
   \   0000004E   5000               SUBI    R16, 0
   \   00000050   F409               BRNE    $+2+2
   \   00000052   C0A2               RJMP    ??hart_diag_set_diag_value_1
   \   00000054   950A               DEC     R16
   \   00000056   F409               BRNE    $+2+2
   \   00000058   C09F               RJMP    ??hart_diag_set_diag_value_1
   \   0000005A   950A               DEC     R16
   \   0000005C   F409               BRNE    $+2+2
   \   0000005E   C06C               RJMP    ??hart_diag_set_diag_value_2
   \   00000060   950A               DEC     R16
   \   00000062   F409               BRNE    $+2+2
   \   00000064   C085               RJMP    ??hart_diag_set_diag_value_3
   \   00000066   C098               RJMP    ??hart_diag_set_diag_value_1
    316              case hart_channel_0 :
    317              case hart_channel_1 :
    318              case hart_channel_2 :
    319              case hart_channel_3 :
    320              case hart_channel_4 :
    321              case hart_channel_5 :
    322              case hart_channel_6 :
    323              case hart_channel_7 :
    324              case hart_channel_8 :
    325              case hart_channel_9 :
    326              case hart_channel_10:
    327              case hart_channel_11:
    328                  {
    329                      current = current * TData.Hart.Gain[chnl] - TData.Hart.Offset[chnl];
   \                     ??hart_diag_set_diag_value_0:
   \   00000068   2D0A               MOV     R16, R10
   \   0000006A   E010               LDI     R17, 0
   \   0000006C   0F00               LSL     R16
   \   0000006E   1F11               ROL     R17
   \   00000070   0F00               LSL     R16
   \   00000072   1F11               ROL     R17
   \   00000074   01F8               MOVW    R31:R30, R17:R16
   \   00000076   ....               SUBI    R30, LOW((-(TData + 412) & 0xFFFF))
   \   00000078   ....               SBCI    R31, HIGH((-(TData + 412) & 0xFFFF))
   \   0000007A   8100               LD      R16, Z
   \   0000007C   8111               LDD     R17, Z+1
   \   0000007E   8122               LDD     R18, Z+2
   \   00000080   8133               LDD     R19, Z+3
   \   00000082   01AC               MOVW    R21:R20, R25:R24
   \   00000084   01BD               MOVW    R23:R22, R27:R26
   \   00000086   ........           CALL    ?F_MUL_L04
   \   0000008A   2D4A               MOV     R20, R10
   \   0000008C   E050               LDI     R21, 0
   \   0000008E   0F44               LSL     R20
   \   00000090   1F55               ROL     R21
   \   00000092   0F44               LSL     R20
   \   00000094   1F55               ROL     R21
   \   00000096   01FA               MOVW    R31:R30, R21:R20
   \   00000098   ....               SUBI    R30, LOW((-(TData + 364) & 0xFFFF))
   \   0000009A   ....               SBCI    R31, HIGH((-(TData + 364) & 0xFFFF))
   \   0000009C   8140               LD      R20, Z
   \   0000009E   8151               LDD     R21, Z+1
   \   000000A0   8162               LDD     R22, Z+2
   \   000000A2   8173               LDD     R23, Z+3
   \   000000A4   ........           CALL    ?F_SUB_L04
   \   000000A8   01C8               MOVW    R25:R24, R17:R16
   \   000000AA   01D9               MOVW    R27:R26, R19:R18
    330                      TData.Hart.ADCurrent[chnl] += (current - TData.Hart.ADCurrent[chnl]) / ((float)TData.Hart.Filter[chnl] + 1.0);
   \   000000AC   2D0A               MOV     R16, R10
   \   000000AE   E010               LDI     R17, 0
   \   000000B0   0F00               LSL     R16
   \   000000B2   1F11               ROL     R17
   \   000000B4   0F00               LSL     R16
   \   000000B6   1F11               ROL     R17
   \   000000B8   01F8               MOVW    R31:R30, R17:R16
   \   000000BA   ....               SUBI    R30, LOW((-(TData + 172) & 0xFFFF))
   \   000000BC   ....               SBCI    R31, HIGH((-(TData + 172) & 0xFFFF))
   \   000000BE   8140               LD      R20, Z
   \   000000C0   8151               LDD     R21, Z+1
   \   000000C2   8162               LDD     R22, Z+2
   \   000000C4   8173               LDD     R23, Z+3
   \   000000C6   018C               MOVW    R17:R16, R25:R24
   \   000000C8   019D               MOVW    R19:R18, R27:R26
   \   000000CA   ........           CALL    ?F_SUB_L04
   \   000000CE   0128               MOVW    R5:R4, R17:R16
   \   000000D0   0139               MOVW    R7:R6, R19:R18
   \   000000D2   24BB               CLR     R11
   \   000000D4   01F5               MOVW    R31:R30, R11:R10
   \   000000D6   ....               SUBI    R30, LOW((-(TData + 160) & 0xFFFF))
   \   000000D8   ....               SBCI    R31, HIGH((-(TData + 160) & 0xFFFF))
   \   000000DA   8100               LD      R16, Z
   \   000000DC   E010               LDI     R17, 0
   \   000000DE   E020               LDI     R18, 0
   \   000000E0   E030               LDI     R19, 0
   \   000000E2   ........           CALL    ?UL2F_L04
   \   000000E6   E040               LDI     R20, 0
   \   000000E8   E050               LDI     R21, 0
   \   000000EA   E860               LDI     R22, 128
   \   000000EC   E37F               LDI     R23, 63
   \   000000EE   ........           CALL    ?F_ADD_L04
   \   000000F2   01A8               MOVW    R21:R20, R17:R16
   \   000000F4   01B9               MOVW    R23:R22, R19:R18
   \   000000F6   0182               MOVW    R17:R16, R5:R4
   \   000000F8   0193               MOVW    R19:R18, R7:R6
   \   000000FA   ........           CALL    ?F_DIV_L04
   \   000000FE   2D4A               MOV     R20, R10
   \   00000100   E050               LDI     R21, 0
   \   00000102   0F44               LSL     R20
   \   00000104   1F55               ROL     R21
   \   00000106   0F44               LSL     R20
   \   00000108   1F55               ROL     R21
   \   0000010A   01FA               MOVW    R31:R30, R21:R20
   \   0000010C   ....               SUBI    R30, LOW((-(TData + 172) & 0xFFFF))
   \   0000010E   ....               SBCI    R31, HIGH((-(TData + 172) & 0xFFFF))
   \   00000110   8140               LD      R20, Z
   \   00000112   8151               LDD     R21, Z+1
   \   00000114   8162               LDD     R22, Z+2
   \   00000116   8173               LDD     R23, Z+3
   \   00000118   ........           CALL    ?F_ADD_L04
   \   0000011C   2D4A               MOV     R20, R10
   \   0000011E   E050               LDI     R21, 0
   \   00000120   0F44               LSL     R20
   \   00000122   1F55               ROL     R21
   \   00000124   0F44               LSL     R20
   \   00000126   1F55               ROL     R21
   \   00000128   01FA               MOVW    R31:R30, R21:R20
   \   0000012A   ....               SUBI    R30, LOW((-(TData + 172) & 0xFFFF))
   \   0000012C   ....               SBCI    R31, HIGH((-(TData + 172) & 0xFFFF))
   \   0000012E   8300               ST      Z, R16
   \   00000130   8311               STD     Z+1, R17
   \   00000132   8322               STD     Z+2, R18
   \   00000134   8333               STD     Z+3, R19
    331                  }
    332                  break;
   \   00000136   C030               RJMP    ??hart_diag_set_diag_value_1
    333              case 12:
    334              case 13:
    335                  // Not connected
    336                  break;
    337              case 14:
    338                  {
    339                      float Gain = 2.5 / current; 
   \                     ??hart_diag_set_diag_value_2:
   \   00000138   E000               LDI     R16, 0
   \   0000013A   E010               LDI     R17, 0
   \   0000013C   E220               LDI     R18, 32
   \   0000013E   E430               LDI     R19, 64
   \   00000140   01AC               MOVW    R21:R20, R25:R24
   \   00000142   01BD               MOVW    R23:R22, R27:R26
   \   00000144   ........           CALL    ?F_DIV_L04
   \   00000148   01A8               MOVW    R21:R20, R17:R16
   \   0000014A   01B9               MOVW    R23:R22, R19:R18
    340                      for (char ch = 0; ch < 12; ch++) {
   \   0000014C   E000               LDI     R16, 0
   \                     ??hart_diag_set_diag_value_4:
   \   0000014E   300C               CPI     R16, 12
   \   00000150   F518               BRCC    ??hart_diag_set_diag_value_1
    341                          TData.Hart.Gain[ch]         = Gain; // Original gain on AN-ZBANA is 0.9985 or 0.9965
   \   00000152   2F20               MOV     R18, R16
   \   00000154   E030               LDI     R19, 0
   \   00000156   0F22               LSL     R18
   \   00000158   1F33               ROL     R19
   \   0000015A   0F22               LSL     R18
   \   0000015C   1F33               ROL     R19
   \   0000015E   01F9               MOVW    R31:R30, R19:R18
   \   00000160   ....               SUBI    R30, LOW((-(TData + 412) & 0xFFFF))
   \   00000162   ....               SBCI    R31, HIGH((-(TData + 412) & 0xFFFF))
   \   00000164   8340               ST      Z, R20
   \   00000166   8351               STD     Z+1, R21
   \   00000168   8362               STD     Z+2, R22
   \   0000016A   8373               STD     Z+3, R23
    342                      }
   \   0000016C   9503               INC     R16
   \   0000016E   CFEF               RJMP    ??hart_diag_set_diag_value_4
    343                  }
    344                  break;
    345              case 15:
    346                  {
    347                      float Offset = current; 
   \                     ??hart_diag_set_diag_value_3:
   \   00000170   01AC               MOVW    R21:R20, R25:R24
   \   00000172   01BD               MOVW    R23:R22, R27:R26
    348                      for (char ch = 0; ch < 12; ch++) {
   \   00000174   E000               LDI     R16, 0
   \                     ??hart_diag_set_diag_value_5:
   \   00000176   300C               CPI     R16, 12
   \   00000178   F478               BRCC    ??hart_diag_set_diag_value_1
    349                          TData.Hart.Offset[ch] = Offset; // Original gain on AN-ZBANA is 0.9985 or 0.9965
   \   0000017A   2F20               MOV     R18, R16
   \   0000017C   E030               LDI     R19, 0
   \   0000017E   0F22               LSL     R18
   \   00000180   1F33               ROL     R19
   \   00000182   0F22               LSL     R18
   \   00000184   1F33               ROL     R19
   \   00000186   01F9               MOVW    R31:R30, R19:R18
   \   00000188   ....               SUBI    R30, LOW((-(TData + 364) & 0xFFFF))
   \   0000018A   ....               SBCI    R31, HIGH((-(TData + 364) & 0xFFFF))
   \   0000018C   8340               ST      Z, R20
   \   0000018E   8351               STD     Z+1, R21
   \   00000190   8362               STD     Z+2, R22
   \   00000192   8373               STD     Z+3, R23
    350                      }
   \   00000194   9503               INC     R16
   \   00000196   CFEF               RJMP    ??hart_diag_set_diag_value_5
    351                  }
    352                  break;
    353          
    354              }
    355          }
   \                     ??hart_diag_set_diag_value_1:
   \   00000198   E0EC               LDI     R30, 12
   \   0000019A   ........           JMP     ?EPILOGUE_B12_L09
    356          
    357          ////////////////////////////////////////////////////////////////////////////////
    358          //
    359          // HART Diagnostic Task
    360          //
    361          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    362          static void ad7715_read_diag_adc(hart_channel_t chnl) {
   \                     ad7715_read_diag_adc:
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   2FA0               MOV     R26, R16
    363          
    364              hart_gpio_adc_channel_select(chnl);
   \   00000006   2F0A               MOV     R16, R26
   \   00000008   ........           CALL    hart_gpio_adc_channel_select
    365              OS_Delay(10);
   \   0000000C   E00A               LDI     R16, 10
   \   0000000E   E010               LDI     R17, 0
   \   00000010   ........           CALL    OS_Delay
    366              ad7715_start_next_sample();
   \   00000014   ....               RCALL   ad7715_start_next_sample
    367              if (ad7715_wait_for_drdy()) {
   \   00000016   ....               RCALL   ad7715_wait_for_drdy
   \   00000018   2300               TST     R16
   \   0000001A   F031               BREQ    ??ad7715_read_diag_adc_0
    368                  uint16_t raw_adc = ad7715_read_sample();
   \   0000001C   ....               RCALL   ad7715_read_sample
   \   0000001E   01C8               MOVW    R25:R24, R17:R16
    369                  ad7715_put_on_hold();
   \   00000020   ....               RCALL   ad7715_put_on_hold
    370                  hart_diag_set_diag_value(chnl, raw_adc);
   \   00000022   019C               MOVW    R19:R18, R25:R24
   \   00000024   2F0A               MOV     R16, R26
   \   00000026   ....               RCALL   hart_diag_set_diag_value
    371              }
    372          }
   \                     ??ad7715_read_diag_adc_0:
   \   00000028   E0E3               LDI     R30, 3
   \   0000002A   ........           JMP     ?EPILOGUE_B3_L09
    373          

   \                                 In  segment CODE, align 2, keep-with-next
    374          static void HARTDiag_Task(void) {
   \                     HARTDiag_Task:
   \   00000000   938A               ST      -Y, R24
    375              hart_channel_t      current;
    376              hasStartedHartDiag = true;
   \   00000002   E001               LDI     R16, 1
   \   00000004   9300....           STS     hasStartedHartDiag, R16
    377              hart_diag_init();
   \   00000008   ....               RCALL   hart_diag_init
    378          
    379              //ad7715_hard_reset();
    380              while (1) {
    381                  hart_for_each_channel(current) {
   \                     ??HARTDiag_Task_0:
   \   0000000A   E080               LDI     R24, 0
   \                     ??HARTDiag_Task_1:
   \   0000000C   308C               CPI     R24, 12
   \   0000000E   F7E8               BRCC    ??HARTDiag_Task_0
    382                      ad7715_read_diag_adc(current);
   \   00000010   2F08               MOV     R16, R24
   \   00000012   ....               RCALL   ad7715_read_diag_adc
    383                      ad7715_toggle_debug_led();
   \   00000014   ....               RCALL   ad7715_toggle_debug_led
    384                      OS_Delay(200);
   \   00000016   EC08               LDI     R16, 200
   \   00000018   E010               LDI     R17, 0
   \   0000001A   ........           CALL    OS_Delay
    385                  }
   \   0000001E   9583               INC     R24
   \   00000020   CFF5               RJMP    ??HARTDiag_Task_1
    386          #if 0 // for ADC debugging only
    387                  //ad7715_read_diag_adc((hart_channel_t)12);
    388                  //ad7715_read_diag_adc((hart_channel_t)13);
    389                  //
    390                  // 2.5V reference check for debugging
    391                  //
    392                  ad7715_read_diag_adc((hart_channel_t)14);
    393          
    394                  //
    395                  // 0V ground
    396                  //
    397                  ad7715_read_diag_adc((hart_channel_t)15);
    398          #endif
    399              }
    400          }
    401          
    402          ////////////////////////////////////////////////////////////////////////////////
    403          //
    404          // public interfaces
    405          //
    406          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    407          void hart_diag_init(void) {
   \                     hart_diag_init:
    408              hart_diag_configure_adc();
   \   00000000   ....               RCALL   hart_diag_configure_adc
    409              TData.Hart.PortUsed   = 0;
   \   00000002   ....               LDI     R30, LOW((TData + 144))
   \   00000004   ....               LDI     R31, HIGH((TData + 144))
   \   00000006   E000               LDI     R16, 0
   \   00000008   8300               ST      Z, R16
   \   0000000A   E000               LDI     R16, 0
   \   0000000C   8301               STD     Z+1, R16
    410              TData.Hart.HartSensor = 0;
   \   0000000E   ....               LDI     R30, LOW((TData + 146))
   \   00000010   ....               LDI     R31, HIGH((TData + 146))
   \   00000012   E000               LDI     R16, 0
   \   00000014   8300               ST      Z, R16
   \   00000016   E000               LDI     R16, 0
   \   00000018   8301               STD     Z+1, R16
    411              for (char ch = 0; ch < 12; ch++) {
   \   0000001A   E040               LDI     R20, 0
   \                     ??hart_diag_init_0:
   \   0000001C   304C               CPI     R20, 12
   \   0000001E   F008               BRCS    $+2+2
   \   00000020   C041               RJMP    ??hart_diag_init_1
    412                  TData.Hart.Filter[ch]       = 3;
   \   00000022   E050               LDI     R21, 0
   \   00000024   01FA               MOVW    R31:R30, R21:R20
   \   00000026   ....               SUBI    R30, LOW((-(TData + 160) & 0xFFFF))
   \   00000028   ....               SBCI    R31, HIGH((-(TData + 160) & 0xFFFF))
   \   0000002A   E003               LDI     R16, 3
   \   0000002C   8300               ST      Z, R16
    413                  TData.Hart.Gain[ch]         = 1.0 / 1.0028280; // Original gain on AN-ZBANA is 0.9985 or 0.9965
   \   0000002E   2F04               MOV     R16, R20
   \   00000030   E010               LDI     R17, 0
   \   00000032   0F00               LSL     R16
   \   00000034   1F11               ROL     R17
   \   00000036   0F00               LSL     R16
   \   00000038   1F11               ROL     R17
   \   0000003A   01F8               MOVW    R31:R30, R17:R16
   \   0000003C   ....               SUBI    R30, LOW((-(TData + 412) & 0xFFFF))
   \   0000003E   ....               SBCI    R31, HIGH((-(TData + 412) & 0xFFFF))
   \   00000040   E300               LDI     R16, 48
   \   00000042   E417               LDI     R17, 71
   \   00000044   E72F               LDI     R18, 127
   \   00000046   E33F               LDI     R19, 63
   \   00000048   8300               ST      Z, R16
   \   0000004A   8311               STD     Z+1, R17
   \   0000004C   8322               STD     Z+2, R18
   \   0000004E   8333               STD     Z+3, R19
    414                  TData.Hart.Offset[ch]       = 0.0;
   \   00000050   2F04               MOV     R16, R20
   \   00000052   E010               LDI     R17, 0
   \   00000054   0F00               LSL     R16
   \   00000056   1F11               ROL     R17
   \   00000058   0F00               LSL     R16
   \   0000005A   1F11               ROL     R17
   \   0000005C   01F8               MOVW    R31:R30, R17:R16
   \   0000005E   ....               SUBI    R30, LOW((-(TData + 364) & 0xFFFF))
   \   00000060   ....               SBCI    R31, HIGH((-(TData + 364) & 0xFFFF))
   \   00000062   E000               LDI     R16, 0
   \   00000064   8300               ST      Z, R16
   \   00000066   E000               LDI     R16, 0
   \   00000068   8301               STD     Z+1, R16
   \   0000006A   E000               LDI     R16, 0
   \   0000006C   8302               STD     Z+2, R16
   \   0000006E   E000               LDI     R16, 0
   \   00000070   8303               STD     Z+3, R16
    415                  TData.Hart.ADCurrent[ch]    = 4.0;
   \   00000072   2F04               MOV     R16, R20
   \   00000074   E010               LDI     R17, 0
   \   00000076   0F00               LSL     R16
   \   00000078   1F11               ROL     R17
   \   0000007A   0F00               LSL     R16
   \   0000007C   1F11               ROL     R17
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   ....               SUBI    R30, LOW((-(TData + 172) & 0xFFFF))
   \   00000082   ....               SBCI    R31, HIGH((-(TData + 172) & 0xFFFF))
   \   00000084   E000               LDI     R16, 0
   \   00000086   E010               LDI     R17, 0
   \   00000088   E820               LDI     R18, 128
   \   0000008A   E430               LDI     R19, 64
   \   0000008C   8300               ST      Z, R16
   \   0000008E   8311               STD     Z+1, R17
   \   00000090   8322               STD     Z+2, R18
   \   00000092   8333               STD     Z+3, R19
    416                  TData.Hart.HartCmd[ch]      = 1;
   \   00000094   E050               LDI     R21, 0
   \   00000096   01FA               MOVW    R31:R30, R21:R20
   \   00000098   ....               SUBI    R30, LOW((-(TData + 148) & 0xFFFF))
   \   0000009A   ....               SBCI    R31, HIGH((-(TData + 148) & 0xFFFF))
   \   0000009C   E001               LDI     R16, 1
   \   0000009E   8300               ST      Z, R16
    417              }
   \   000000A0   9543               INC     R20
   \   000000A2   CFBC               RJMP    ??hart_diag_init_0
    418          }
   \                     ??hart_diag_init_1:
   \   000000A4   9508               RET
    419          

   \                                 In  segment CODE, align 2, keep-with-next
    420          void hart_diag_task_start(void) {
   \                     hart_diag_task_start:
    421              OS_CREATETASK(&TCB_AD7715, "HARTDiag", HARTDiag_Task, 135, _hart_diag_task_stack);
   \   00000000   E002               LDI     R16, 2
   \   00000002   E010               LDI     R17, 0
   \   00000004   931A               ST      -Y, R17
   \   00000006   930A               ST      -Y, R16
   \   00000008   E20C               LDI     R16, 44
   \   0000000A   E011               LDI     R17, 1
   \   0000000C   931A               ST      -Y, R17
   \   0000000E   930A               ST      -Y, R16
   \   00000010   ....               LDI     R16, LOW(_hart_diag_task_stack)
   \   00000012   ....               LDI     R17, (_hart_diag_task_stack) >> 8
   \   00000014   931A               ST      -Y, R17
   \   00000016   930A               ST      -Y, R16
   \   00000018   ....               LDI     R22, LOW(HARTDiag_Task/2)
   \   0000001A   ....               LDI     R23, (HARTDiag_Task/2) >> 8
   \   0000001C   E847               LDI     R20, 135
   \   0000001E   ....               LDI     R18, LOW(`?<Constant "HARTDiag">`)
   \   00000020   ....               LDI     R19, (`?<Constant "HARTDiag">`) >> 8
   \   00000022   ....               LDI     R16, LOW(TCB_AD7715)
   \   00000024   ....               LDI     R17, (TCB_AD7715) >> 8
   \   00000026   ........           CALL    OS_CreateTask_D
    422          }
   \   0000002A   9508               RET

   \                                 In  segment INTVEC, offset 0x4, root
   \                     `??IntHandler_INT0::??INTVEC 4`:
   \   00000004   ........           JMP     IntHandler_INT0

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "HARTDiag">>`:
   \   00000000   414854526944       DC8 "HARTDiag"
   \              676100      

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for StackTest5>`:
   \   00000000   323134333635       DC8 "123456789"
   \              38370039    

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for StackTest6>`:
   \   00000000   323134333635       DC8 "123456789"
   \              38370039    

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for on_off>`:
   \   00000000   01                 DC8 1

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant "HARTDiag">`:
   \   00000000                      DS8 9
   \   00000009                      REQUIRE `?<Initializer for <Constant "HARTDiag">>`

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      1      2   HARTDiag_Task
        1      2   -> OS_Delay
        1      2   -> ad7715_read_diag_adc
        1      2   -> ad7715_toggle_debug_led
        1      2   -> hart_diag_init
      0      2   INT_Handler_INT0
        0      2   -> OS_SignalEvent
     16      2   IntHandler_INT0
       16      2   -> OS_CallISR_Debug
      0      2   ad7715_do_calibration
        0      2   -> ad7715_put_on_hold
        0      2   -> ad7715_read_sample
        0      2   -> ad7715_wait_for_drdy
        0      2   -> ad7715_write_byte
        0      2   -> hart_gpio_adc_channel_select
      0      2   ad7715_hard_reset
        0      2   -> OS_Delay
        0      2   -> hart_gpio_adc_reset
      0      2   ad7715_put_on_hold
        0      2   -> ad7715_write_byte
      2      2   ad7715_read_byte
        2      2   -> OS_Delayus
      3      2   ad7715_read_diag_adc
        3      2   -> OS_Delay
        3      2   -> ad7715_put_on_hold
        3      2   -> ad7715_read_sample
        3      2   -> ad7715_start_next_sample
        3      2   -> ad7715_wait_for_drdy
        3      2   -> hart_diag_set_diag_value
        3      2   -> hart_gpio_adc_channel_select
      4      2   ad7715_read_sample
        4      2   -> ad7715_read_byte
        4      2   -> ad7715_write_byte
      0      2   ad7715_start_next_sample
        0      2   -> ad7715_write_byte
      0      2   ad7715_toggle_debug_led
        0      2   -> hart_gpio_debug_led
      0      2   ad7715_wait_for_drdy
        0      2   -> OS_WaitSingleEventTimed
      2      2   ad7715_write_byte
        2      2   -> OS_Delayus
      0      2   hart_diag_configure_adc
        0      2   -> OS_Delay
        0      2   -> ad7715_do_calibration
        0      2   -> ad7715_hard_reset
      0      2   hart_diag_init
        0      2   -> hart_diag_configure_adc
     12      2   hart_diag_set_diag_value
       12      2 ?F_ADD_L04
       12      2 ?F_DIV_L04
       12      2 ?F_MUL_L04
       12      2 ?F_SUB_L04
       12      2 ?UL2F_L04
      6      2   hart_diag_task_start
        0      2   -> OS_CreateTask_D


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant "HARTDiag">
       9  ?<Initializer for <Constant "HARTDiag">>
      10  ?<Initializer for StackTest5>
      10  ?<Initializer for StackTest6>
       1  ?<Initializer for on_off>
       1  CriticalADC_Failure
      34  HARTDiag_Task
      20  INT_Handler_INT0
      82  IntHandler_INT0
       4  IntHandler_INT0::??INTVEC 4
       4  Last_ADC_FuckUpTime
       4  Last_ADC_OK_Time
      10  StackTest5
      10  StackTest6
      33  TCB_AD7715
       1  _A_PINL
       1  _A_PORTL
     300  _hart_diag_task_stack
       2  _num_adc_fuckups
      28  ad7715_do_calibration
      44  ad7715_hard_reset
      10  ad7715_put_on_hold
      64  ad7715_read_byte
      46  ad7715_read_diag_adc
      38  ad7715_read_sample
      10  ad7715_start_next_sample
      32  ad7715_toggle_debug_led
      82  ad7715_wait_for_drdy
      86  ad7715_write_byte
      22  hart_diag_configure_adc
     166  hart_diag_init
     414  hart_diag_set_diag_value
      44  hart_diag_task_start
       1  hasStartedHartDiag
       1  on_off
      14  -- Other

 
     2 bytes in segment ABSOLUTE
 1 222 bytes in segment CODE
    14 bytes in segment INITTAB
     4 bytes in segment INTVEC
    30 bytes in segment NEAR_I
    30 bytes in segment NEAR_ID
   345 bytes in segment NEAR_Z
 
 1 252 bytes of CODE memory (+ 18 bytes shared)
   375 bytes of DATA memory (+  2 bytes shared)

Errors: none
Warnings: none
