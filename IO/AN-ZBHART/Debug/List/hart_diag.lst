###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       04/May/2023  10:24:01
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  D:\S2Prog\IO\AN-ZBHART\Src\hart_diag.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWA3F.tmp
#        (D:\S2Prog\IO\AN-ZBHART\Src\hart_diag.c --cpu=m1280 -ms -o
#        D:\S2Prog\IO\AN-ZBHART\Debug\Obj -D OS_LIBMODE_D -D OS_UART=-1 -lCN
#        D:\S2Prog\IO\AN-ZBHART\Debug\List -y --initializers_in_flash --no_cse
#        --no_inline --no_code_motion --no_cross_call --no_clustering --no_tbaa
#        --debug -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\AN-ZBHART\INC\\ -I
#        ..\..\..\Shared\Inc\\ --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  D:\S2Prog\IO\AN-ZBHART\Debug\List\hart_diag.lst
#    Object file  =  D:\S2Prog\IO\AN-ZBHART\Debug\Obj\hart_diag.r90
#
###############################################################################

D:\S2Prog\IO\AN-ZBHART\Src\hart_diag.c
      1          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0x10b
   \   union <unnamed> volatile __ext_io _A_PORTL
   \                     _A_PORTL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x109
   \   union <unnamed> volatile __ext_io _A_PINL
   \                     _A_PINL:
   \   00000000                      DS8 1
      2          #include "version.h"
      3          #include "inavr.h"
      4          #include "RTOS.h"
      5          
      6          #include "constants.h"
      7          
      8          #include "hart_common.h"
      9          #include "hart.h"
     10          #include "hart_diag.h"
     11          #include "hart_gpio.h"
     12          #include "structs.h"
     13          #include "externals.h"
     14          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     15          static char hasStartedHartDiag = false;
   \                     hasStartedHartDiag:
   \   00000000                      DS8 1
     16          
     17          /////////////////////////////////////////////////////////////////////////////////////
     18          //
     19          // AD7715 summary.
     20          // * some people are stupid enough not to write this down in the code. So I do.
     21          //   -hkim-
     22          //
     23          //
     24          // a. setup communication register
     25          //
     26          // 7        6       5       4       3       2       1       0
     27          // must     must    rs1     rs0     r/w     sdby    g1      g0
     28          // be 0     be 0                    r=1     1 =
     29          //                                  w=0     p down  gain setup
     30          //
     31          // rs1    rs0
     32          // ============
     33          // 0      0       comm reg        8  bit
     34          // 0      1       setup reg       8  bit
     35          // 1      0       test reg        8  bit
     36          // 1      1       data reg        16 bit
     37          //
     38          // g1     g0
     39          // ============
     40          //  0     0       x1
     41          //  0     1       x2
     42          //  1     0       x32
     43          //  1     1       x128
     44          //
     45          // b. setup register (rs1,rs0= 0,1
     46          //
     47          // 7        6       5       4       3       2       1       0
     48          // MD1      MD0     CLK     FS1     FS0     B/U     BUF     FSYNC
     49          // mode selection   opr     output rate     bi/uni  buf     filter
     50          //                  freq                    polar   control sync
     51          //
     52          // CLK should be set to 0 with 1 Mhz clock
     53          //
     54          // MD1    MD0
     55          // ============
     56          // 0      0       normal mode
     57          // 0      1       self calib
     58          // 1      0       zero scale calib
     59          // 1      1       full scale calib
     60          //
     61          // CLK      FS1     FS0
     62          // ================================
     63          // 0        0       0           20 Hz
     64          // 0        0       1           25 Hz
     65          // 0        1       0           100 Hz
     66          // 0        1       1           200 Hz
     67          // 1        0       0           50 Hz
     68          // 1        0       1           60 Hz
     69          // 1        1       0           250 Hz
     70          // 1        1       1           5600 Hz
     71          //
     72          // B/U : 0 bipolar, 1 unipolar
     73          //
     74          // c. test register (rs1,rs0 = 1,0
     75          // just don't use it. chip maker doesn't want you to fuck up with this.
     76          //
     77          // d. data register (rs1,rs0 = 1,1)
     78          //
     79          /////////////////////////////////////////////////////////////////////////////////////
     80          
     81          ////////////////////////////////////////////////////////////////////////////////
     82          //
     83          // private defines
     84          //
     85          ////////////////////////////////////////////////////////////////////////////////
     86          #define HART_DIAG_CONVERSION_COMPLETE         0x01
     87          
     88          ////////////////////////////////////////////////////////////////////////////////
     89          //
     90          // private prototypes
     91          //
     92          ////////////////////////////////////////////////////////////////////////////////
     93          
     94          ////////////////////////////////////////////////////////////////////////////////
     95          //
     96          // hart module privates
     97          //
     98          ////////////////////////////////////////////////////////////////////////////////
     99          #if defined( OS_LIBMODE_D) || defined( OS_LIBMODE_S )

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
    100          char StackTest5[] = {"123456789"};
   \                     StackTest5:
   \   00000000                      DS8 10
   \   0000000A                      REQUIRE `?<Initializer for StackTest5>`
    101          #endif

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    102          OS_STACKPTR int  _hart_diag_task_stack[150];
   \                     _hart_diag_task_stack:
   \   00000000                      DS8 300
    103          #if defined( OS_LIBMODE_D) || defined( OS_LIBMODE_S )

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
    104          char StackTest6[] = {"123456789"};
   \                     StackTest6:
   \   00000000                      DS8 10
   \   0000000A                      REQUIRE `?<Initializer for StackTest6>`
    105          #endif

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    106          OS_TASK          TCB_AD7715;
   \                     TCB_AD7715:
   \   00000000                      DS8 33

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    107          uint16_t         _num_adc_fuckups    = 0;
   \                     _num_adc_fuckups:
   \   00000000                      DS8 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    108          OS_U32           Last_ADC_FuckUpTime = 0;
   \                     Last_ADC_FuckUpTime:
   \   00000000                      DS8 4

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    109          OS_U32           Last_ADC_OK_Time    = 0;
   \                     Last_ADC_OK_Time:
   \   00000000                      DS8 4

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    110          char             CriticalADC_Failure = FALSE;
   \                     CriticalADC_Failure:
   \   00000000                      DS8 1
    111          ////////////////////////////////////////////////////////////////////////////////
    112          //
    113          // AD7715 related utilities
    114          //
    115          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    116          static void
    117          ad7715_toggle_debug_led(void) {
   \                     ad7715_toggle_debug_led:
    118              static uint8_t    on_off = 1;
    119          
    120              hart_gpio_debug_led(on_off);
   \   00000000   9100....           LDS     R16, ??on_off
   \   00000004   ........           CALL    hart_gpio_debug_led
    121              on_off = !on_off;
   \   00000008   9100....           LDS     R16, ??on_off
   \   0000000C   2300               TST     R16
   \   0000000E   F421               BRNE    ??ad7715_toggle_debug_led_0
   \   00000010   E001               LDI     R16, 1
   \   00000012   9300....           STS     ??on_off, R16
   \   00000016   9508               RET
   \                     ??ad7715_toggle_debug_led_0:
   \   00000018   E000               LDI     R16, 0
   \   0000001A   9300....           STS     ??on_off, R16
    122          }
   \   0000001E   9508               RET

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     ??on_off:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for on_off>`
    123          

   \                                 In  segment CODE, align 2, keep-with-next
    124          static uint8_t
    125          ad7715_read_byte(void) {
   \                     ad7715_read_byte:
    126              uint8_t readbyte = 0;
   \   00000000   E000               LDI     R16, 0
    127              //OS_EnterRegion();
    128              //OS_IncDI();
    129              for (uint8_t i = 0; i <  8; i++) {
   \   00000002   E010               LDI     R17, 0
   \                     ??ad7715_read_byte_0:
   \   00000004   3018               CPI     R17, 8
   \   00000006   F490               BRCC    ??ad7715_read_byte_1
    130                  readbyte <<= 1;                      // shift to next bit
   \   00000008   0F00               LSL     R16
    131                  AD7715_CLK_LO();
   \   0000000A   9120010B           LDS     R18, 267
   \   0000000E   7F2E               ANDI    R18, 0xFE
   \   00000010   9320010B           STS     267, R18
    132                  AD7715_CLK_HI();
   \   00000014   9120010B           LDS     R18, 267
   \   00000018   6021               ORI     R18, 0x01
   \   0000001A   9320010B           STS     267, R18
    133          
    134                  if (AD7715_MISO_READ()) {
   \   0000001E   9120....           LDS     R18, _A_PINL
   \   00000022   2F32               MOV     R19, R18
   \   00000024   FD31               SBRC    R19, 1
    135                      // data high
    136                      readbyte |= 0x01;                   // set bit high
   \   00000026   6001               ORI     R16, 0x01
    137                  }
    138              }
   \                     ??ad7715_read_byte_2:
   \   00000028   9513               INC     R17
   \   0000002A   CFEC               RJMP    ??ad7715_read_byte_0
    139              //OS_LeaveRegion();
    140              //OS_DecRI();
    141              return readbyte;
   \                     ??ad7715_read_byte_1:
   \   0000002C   9508               RET
   \   0000002E                      REQUIRE _A_PORTL
   \   0000002E                      REQUIRE _A_PINL
    142          }
    143          

   \                                 In  segment CODE, align 2, keep-with-next
    144          static void
    145          ad7715_write_byte(uint8_t data) {
   \                     ad7715_write_byte:
    146              //OS_EnterRegion();
    147              //OS_IncDI();
    148              for (uint8_t i = 0; i <  8; i++) {
   \   00000000   E010               LDI     R17, 0
   \                     ??ad7715_write_byte_0:
   \   00000002   3018               CPI     R17, 8
   \   00000004   F4D0               BRCC    ??ad7715_write_byte_1
    149                  AD7715_CLK_LO();
   \   00000006   9120010B           LDS     R18, 267
   \   0000000A   7F2E               ANDI    R18, 0xFE
   \   0000000C   9320010B           STS     267, R18
    150                  if (data & 0x80) {                        // data bit = 1?
   \   00000010   FB07               BST     R16, 7
   \   00000012   F436               BRTC    ??ad7715_write_byte_2
    151                      AD7715_MOSI_HI();
   \   00000014   9120010B           LDS     R18, 267
   \   00000018   6024               ORI     R18, 0x04
   \   0000001A   9320010B           STS     267, R18
   \   0000001E   C005               RJMP    ??ad7715_write_byte_3
    152                  } else {
    153                      AD7715_MOSI_LO();
   \                     ??ad7715_write_byte_2:
   \   00000020   9120010B           LDS     R18, 267
   \   00000024   7F2B               ANDI    R18, 0xFB
   \   00000026   9320010B           STS     267, R18
    154                  }
    155                  data <<= 1;                              // shift to next bit
   \                     ??ad7715_write_byte_3:
   \   0000002A   0F00               LSL     R16
    156                  AD7715_CLK_HI();
   \   0000002C   9120010B           LDS     R18, 267
   \   00000030   6021               ORI     R18, 0x01
   \   00000032   9320010B           STS     267, R18
    157              }
   \   00000036   9513               INC     R17
   \   00000038   CFE4               RJMP    ??ad7715_write_byte_0
    158              //OS_LeaveRegion();
    159              //OS_DecRI();
    160          }
   \                     ??ad7715_write_byte_1:
   \   0000003A   9508               RET
   \   0000003C                      REQUIRE _A_PORTL
    161          

   \                                 In  segment CODE, align 2, keep-with-next
    162          static void
    163          ad7715_hard_reset(void) {
   \                     ad7715_hard_reset:
    164              hart_gpio_adc_reset(1);     // high
   \   00000000   E001               LDI     R16, 1
   \   00000002   ........           CALL    hart_gpio_adc_reset
    165              OS_Delay(100);
   \   00000006   E604               LDI     R16, 100
   \   00000008   E010               LDI     R17, 0
   \   0000000A   ........           CALL    OS_Delay
    166              hart_gpio_adc_reset(0);     // low
   \   0000000E   E000               LDI     R16, 0
   \   00000010   ........           CALL    hart_gpio_adc_reset
    167              OS_Delay(500);
   \   00000014   EF04               LDI     R16, 244
   \   00000016   E011               LDI     R17, 1
   \   00000018   ........           CALL    OS_Delay
    168              hart_gpio_adc_reset(1);     // high
   \   0000001C   E001               LDI     R16, 1
   \   0000001E   ........           CALL    hart_gpio_adc_reset
    169              OS_Delay(100);
   \   00000022   E604               LDI     R16, 100
   \   00000024   E010               LDI     R17, 0
   \   00000026   ........           CALL    OS_Delay
    170          }
   \   0000002A   9508               RET
    171          

   \                                 In  segment CODE, align 2, keep-with-next
    172          static void
    173          ad7715_put_on_hold(void) {
   \                     ad7715_put_on_hold:
    174              // select setup reg
    175              ad7715_write_byte(0x10);
   \   00000000   E100               LDI     R16, 16
   \   00000002   ....               RCALL   ad7715_write_byte
    176          
    177              // set fsync to put ADC on hold
    178              ad7715_write_byte(0x0f);
   \   00000004   E00F               LDI     R16, 15
   \   00000006   ....               RCALL   ad7715_write_byte
    179          }
   \   00000008   9508               RET
    180          

   \                                 In  segment CODE, align 2, keep-with-next
    181          static void
    182          ad7715_start_next_sample(void) {
   \                     ad7715_start_next_sample:
    183              // select setup reg
    184              ad7715_write_byte(0x10);
   \   00000000   E100               LDI     R16, 16
   \   00000002   ....               RCALL   ad7715_write_byte
    185          
    186              // clear fsync bit to start conversion
    187              ad7715_write_byte(0x0e);
   \   00000004   E00E               LDI     R16, 14
   \   00000006   ....               RCALL   ad7715_write_byte
    188          
    189              //
    190              // sample will be available after 3x1/output rate, which is 3x1/25 = 120ms.
    191              // code will be notified by /DRDY
    192              //
    193          }
   \   00000008   9508               RET
    194          

   \                                 In  segment CODE, align 2, keep-with-next
    195          static uint16_t ad7715_read_sample(void) {
   \                     ad7715_read_sample:
    196              uint8_t   lo, hi;
    197              uint16_t  ret;
    198          
    199              // select data reg
    200              ad7715_write_byte(0x38);
   \   00000000   E308               LDI     R16, 56
   \   00000002   ....               RCALL   ad7715_write_byte
    201          
    202              hi = ad7715_read_byte();
   \   00000004   ....               RCALL   ad7715_read_byte
   \   00000006   2F70               MOV     R23, R16
    203              lo = ad7715_read_byte();
   \   00000008   ....               RCALL   ad7715_read_byte
   \   0000000A   2F60               MOV     R22, R16
    204          
    205              ret = (uint16_t)(hi << 8 | lo);
   \   0000000C   2F37               MOV     R19, R23
   \   0000000E   E020               LDI     R18, 0
   \   00000010   2F06               MOV     R16, R22
   \   00000012   E010               LDI     R17, 0
   \   00000014   2B20               OR      R18, R16
   \   00000016   2B31               OR      R19, R17
   \   00000018   01A9               MOVW    R21:R20, R19:R18
    206          
    207              return ret;
   \   0000001A   018A               MOVW    R17:R16, R21:R20
   \   0000001C   9508               RET
    208          }
    209          

   \                                 In  segment CODE, align 2, keep-with-next
    210          static uint8_t ad7715_wait_for_drdy(void) {
   \                     ad7715_wait_for_drdy:
    211              char Status = OS_WaitSingleEventTimed(HART_DIAG_CONVERSION_COMPLETE, 1000);
   \   00000000   EE28               LDI     R18, 232
   \   00000002   E033               LDI     R19, 3
   \   00000004   E001               LDI     R16, 1
   \   00000006   ........           CALL    OS_WaitSingleEventTimed
    212              if (!Status) {
   \   0000000A   2300               TST     R16
   \   0000000C   F4A9               BRNE    ??ad7715_wait_for_drdy_0
    213                  Last_ADC_FuckUpTime = OS_Time;
   \   0000000E   ....               LDI     R30, LOW(OS_Global)
   \   00000010   ....               LDI     R31, (OS_Global) >> 8
   \   00000012   8942               LDD     R20, Z+18
   \   00000014   8953               LDD     R21, Z+19
   \   00000016   8964               LDD     R22, Z+20
   \   00000018   8975               LDD     R23, Z+21
   \   0000001A   ....               LDI     R30, LOW(Last_ADC_FuckUpTime)
   \   0000001C   ....               LDI     R31, (Last_ADC_FuckUpTime) >> 8
   \   0000001E   8340               ST      Z, R20
   \   00000020   8351               STD     Z+1, R21
   \   00000022   8362               STD     Z+2, R22
   \   00000024   8373               STD     Z+3, R23
    214                  _num_adc_fuckups++;
   \   00000026   ....               LDI     R30, LOW(_num_adc_fuckups)
   \   00000028   ....               LDI     R31, (_num_adc_fuckups) >> 8
   \   0000002A   8120               LD      R18, Z
   \   0000002C   8131               LDD     R19, Z+1
   \   0000002E   5F2F               SUBI    R18, 255
   \   00000030   4F3F               SBCI    R19, 255
   \   00000032   8320               ST      Z, R18
   \   00000034   8331               STD     Z+1, R19
   \   00000036   9508               RET
    215              } else {
    216                  Last_ADC_OK_Time = OS_Time;
   \                     ??ad7715_wait_for_drdy_0:
   \   00000038   ....               LDI     R30, LOW(OS_Global)
   \   0000003A   ....               LDI     R31, (OS_Global) >> 8
   \   0000003C   8942               LDD     R20, Z+18
   \   0000003E   8953               LDD     R21, Z+19
   \   00000040   8964               LDD     R22, Z+20
   \   00000042   8975               LDD     R23, Z+21
   \   00000044   ....               LDI     R30, LOW(Last_ADC_OK_Time)
   \   00000046   ....               LDI     R31, (Last_ADC_OK_Time) >> 8
   \   00000048   8340               ST      Z, R20
   \   0000004A   8351               STD     Z+1, R21
   \   0000004C   8362               STD     Z+2, R22
   \   0000004E   8373               STD     Z+3, R23
    217              }
    218              return Status;
   \   00000050   9508               RET
    219          }
    220          

   \                                 In  segment CODE, align 2, keep-with-next
    221          static void ad7715_do_calibration(void) {
   \                     ad7715_do_calibration:
    222              //
    223              // set current channel to 2.5V reference
    224              //
    225              hart_gpio_adc_channel_select((hart_channel_t)14);
   \   00000000   E00E               LDI     R16, 14
   \   00000002   ........           CALL    hart_gpio_adc_channel_select
    226          
    227              //
    228              // select setup reg (0,1)
    229              // 7        6         5         4         3         2         1         0
    230              // 0        0         0         1         0         0         0         0
    231              //                    setup reg           write     no        gain x1
    232              //                                                  stby
    233              ad7715_write_byte(0x10);
   \   00000006   E100               LDI     R16, 16
   \   00000008   ....               RCALL   ad7715_write_byte
    234          
    235              //
    236              // setup reg to perform calib
    237              //
    238              // 7        6         5         4         3         2         1         0
    239              // 0        1         0         0         1         1         1         0
    240              // seld calib         1 Mhz     25 Hz Rate          Unipolar  buffed    no fsync
    241              // mode               clk
    242              //
    243              ad7715_write_byte(0x4e);
   \   0000000A   E40E               LDI     R16, 78
   \   0000000C   ....               RCALL   ad7715_write_byte
    244          
    245              //
    246              // calibration will be complete after 6 x 1/outpur rate
    247              // which is 6 * 1/25 = roughly 240ms and /DRDY will be asserted.
    248              //
    249              ad7715_wait_for_drdy();
   \   0000000E   ....               RCALL   ad7715_wait_for_drdy
    250          
    251              //
    252              // read dummy sample. /DRDY will go hi again after this
    253              //
    254              ad7715_read_sample();
   \   00000010   ....               RCALL   ad7715_read_sample
    255          
    256              ad7715_put_on_hold();
   \   00000012   ....               RCALL   ad7715_put_on_hold
    257          
    258              // back to 0
    259              hart_gpio_adc_channel_select(hart_channel_0);
   \   00000014   E000               LDI     R16, 0
   \   00000016   ........           CALL    hart_gpio_adc_channel_select
    260          }
   \   0000001A   9508               RET
    261          
    262          
    263          ////////////////////////////////////////////////////////////////////////////////
    264          //
    265          // ADC interrupt handler
    266          //
    267          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    268          void INT_Handler_INT0(void) {
   \                     INT_Handler_INT0:
    269              if (hasStartedHartDiag) {
   \   00000000   9100....           LDS     R16, hasStartedHartDiag
   \   00000004   2300               TST     R16
   \   00000006   F029               BREQ    ??INT_Handler_INT0_0
    270                  OS_SignalEvent(HART_DIAG_CONVERSION_COMPLETE, &TCB_AD7715);
   \   00000008   ....               LDI     R18, LOW(TCB_AD7715)
   \   0000000A   ....               LDI     R19, (TCB_AD7715) >> 8
   \   0000000C   E001               LDI     R16, 1
   \   0000000E   ........           CALL    OS_SignalEvent
    271              }
    272          }
   \                     ??INT_Handler_INT0_0:
   \   00000012   9508               RET
    273          
    274          #pragma vector=INT0_vect

   \                                 In  segment CODE, align 2, keep-with-next
    275          __interrupt void IntHandler_INT0(void) {
   \                     IntHandler_INT0:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    276              OS_CallISR(INT_Handler_INT0);
   \   00000024   ....               LDI     R16, LOW(INT_Handler_INT0/2)
   \   00000026   ....               LDI     R17, (INT_Handler_INT0/2) >> 8
   \   00000028   ........           CALL    OS_CallISR_Debug
    277          }
   \   0000002C   BF9B               OUT     0x3B, R25
   \   0000002E   BF8F               OUT     0x3F, R24
   \   00000030   9109               LD      R16, Y+
   \   00000032   9119               LD      R17, Y+
   \   00000034   9129               LD      R18, Y+
   \   00000036   9139               LD      R19, Y+
   \   00000038   9149               LD      R20, Y+
   \   0000003A   9159               LD      R21, Y+
   \   0000003C   9169               LD      R22, Y+
   \   0000003E   9179               LD      R23, Y+
   \   00000040   9009               LD      R0, Y+
   \   00000042   9019               LD      R1, Y+
   \   00000044   9029               LD      R2, Y+
   \   00000046   9039               LD      R3, Y+
   \   00000048   91E9               LD      R30, Y+
   \   0000004A   91F9               LD      R31, Y+
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9518               RETI
    278          
    279          
    280          
    281          ////////////////////////////////////////////////////////////////////////////////
    282          //
    283          // private utilities
    284          //
    285          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    286          static void hart_diag_configure_adc(void) {
   \                     hart_diag_configure_adc:
    287              ad7715_hard_reset();
   \   00000000   ....               RCALL   ad7715_hard_reset
    288              OS_Delay(10);
   \   00000002   E00A               LDI     R16, 10
   \   00000004   E010               LDI     R17, 0
   \   00000006   ........           CALL    OS_Delay
    289              ad7715_do_calibration();
   \   0000000A   ....               RCALL   ad7715_do_calibration
    290              OS_Delay(10);
   \   0000000C   E00A               LDI     R16, 10
   \   0000000E   E010               LDI     R17, 0
   \   00000010   ........           CALL    OS_Delay
    291          }
   \   00000014   9508               RET
    292          
    293          ////////////////////////////////////////////////////////////////////////////////
    294          //
    295          // ADC raw to mA
    296          //
    297          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    298          static void hart_diag_set_diag_value(hart_channel_t chnl, uint16_t raw_adc) {
   \                     hart_diag_set_diag_value:
   \   00000000   ........           CALL    ?PROLOGUE12_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004   2EA0               MOV     R10, R16
   \   00000006   0149               MOVW    R9:R8, R19:R18
    299              // the H/W circuit is created using INA138 current shunt and 5 ohm resistor.
    300              //
    301              // The input current is between 0 and 20mA. So voltage drop across the 5 Ohm
    302              // resistor will be between 0 and 0.1V. This voltage difference is fed into
    303              // INA138 and with 100K RL resistor, the voltage is amplied by 20 times.
    304              //
    305              // So the measured voltage to the ADC is in the range of 0V and 2V, where
    306              // 0V corresponds to 0mA and 2V corresponds to 20mA.
    307              //
    308              // Additionally ADC ref voltage is 2.5V, which means 0xffff corresponds 2.5V
    309              //
    310              // hkim is kind enough to analyze this freaking circuit himself and leave a
    311              // record here. Appreciate him.
    312              //
    313              // -hkim-
    314              //
    315              //float   voltage = 2.5f * ((float)(raw_adc)) / 65535.0;
    316              //float   current = voltage / 10.0 * 100.0f * TData.Hart.Gain[chnl]-TData.Hart.Offset[chnl];
    317              float   current = ((2.5f * ((float)(raw_adc)) / 65535.0) / 10.0 * 100.0f);// *(1.0 / 1.0028280); // * TData.Hart.Gain[chnl] - TData.Hart.Offset[chnl];
   \   00000008   0184               MOVW    R17:R16, R9:R8
   \   0000000A   E020               LDI     R18, 0
   \   0000000C   E030               LDI     R19, 0
   \   0000000E   ........           CALL    ?UL2F_L04
   \   00000012   E040               LDI     R20, 0
   \   00000014   E050               LDI     R21, 0
   \   00000016   E260               LDI     R22, 32
   \   00000018   E470               LDI     R23, 64
   \   0000001A   ........           CALL    ?F_MUL_L04
   \   0000001E   E040               LDI     R20, 0
   \   00000020   EF5F               LDI     R21, 255
   \   00000022   E76F               LDI     R22, 127
   \   00000024   E477               LDI     R23, 71
   \   00000026   ........           CALL    ?F_DIV_L04
   \   0000002A   E040               LDI     R20, 0
   \   0000002C   E050               LDI     R21, 0
   \   0000002E   E260               LDI     R22, 32
   \   00000030   E471               LDI     R23, 65
   \   00000032   ........           CALL    ?F_DIV_L04
   \   00000036   E040               LDI     R20, 0
   \   00000038   E050               LDI     R21, 0
   \   0000003A   EC68               LDI     R22, 200
   \   0000003C   E472               LDI     R23, 66
   \   0000003E   ........           CALL    ?F_MUL_L04
   \   00000042   01C8               MOVW    R25:R24, R17:R16
   \   00000044   01D9               MOVW    R27:R26, R19:R18
    318              // EHSMarkuint16_t    current_final = (uint16_t)(current * 10);       // 10 = 1mA, 1 = 0.1mA
    319          
    320              switch (chnl) {
   \   00000046   2D0A               MOV     R16, R10
   \   00000048   5000               SUBI    R16, 0
   \   0000004A   500C               SUBI    R16, 12
   \   0000004C   F068               BRCS    ??hart_diag_set_diag_value_0
   \   0000004E   5000               SUBI    R16, 0
   \   00000050   F409               BRNE    $+2+2
   \   00000052   C0A2               RJMP    ??hart_diag_set_diag_value_1
   \   00000054   950A               DEC     R16
   \   00000056   F409               BRNE    $+2+2
   \   00000058   C09F               RJMP    ??hart_diag_set_diag_value_1
   \   0000005A   950A               DEC     R16
   \   0000005C   F409               BRNE    $+2+2
   \   0000005E   C06C               RJMP    ??hart_diag_set_diag_value_2
   \   00000060   950A               DEC     R16
   \   00000062   F409               BRNE    $+2+2
   \   00000064   C085               RJMP    ??hart_diag_set_diag_value_3
   \   00000066   C098               RJMP    ??hart_diag_set_diag_value_1
    321              case hart_channel_0 :
    322              case hart_channel_1 :
    323              case hart_channel_2 :
    324              case hart_channel_3 :
    325              case hart_channel_4 :
    326              case hart_channel_5 :
    327              case hart_channel_6 :
    328              case hart_channel_7 :
    329              case hart_channel_8 :
    330              case hart_channel_9 :
    331              case hart_channel_10:
    332              case hart_channel_11:
    333                  {
    334                      current = current * TData.Hart.Gain[chnl] - TData.Hart.Offset[chnl];
   \                     ??hart_diag_set_diag_value_0:
   \   00000068   2D0A               MOV     R16, R10
   \   0000006A   E010               LDI     R17, 0
   \   0000006C   0F00               LSL     R16
   \   0000006E   1F11               ROL     R17
   \   00000070   0F00               LSL     R16
   \   00000072   1F11               ROL     R17
   \   00000074   01F8               MOVW    R31:R30, R17:R16
   \   00000076   ....               SUBI    R30, LOW((-(TData + 412) & 0xFFFF))
   \   00000078   ....               SBCI    R31, HIGH((-(TData + 412) & 0xFFFF))
   \   0000007A   8100               LD      R16, Z
   \   0000007C   8111               LDD     R17, Z+1
   \   0000007E   8122               LDD     R18, Z+2
   \   00000080   8133               LDD     R19, Z+3
   \   00000082   01AC               MOVW    R21:R20, R25:R24
   \   00000084   01BD               MOVW    R23:R22, R27:R26
   \   00000086   ........           CALL    ?F_MUL_L04
   \   0000008A   2D4A               MOV     R20, R10
   \   0000008C   E050               LDI     R21, 0
   \   0000008E   0F44               LSL     R20
   \   00000090   1F55               ROL     R21
   \   00000092   0F44               LSL     R20
   \   00000094   1F55               ROL     R21
   \   00000096   01FA               MOVW    R31:R30, R21:R20
   \   00000098   ....               SUBI    R30, LOW((-(TData + 364) & 0xFFFF))
   \   0000009A   ....               SBCI    R31, HIGH((-(TData + 364) & 0xFFFF))
   \   0000009C   8140               LD      R20, Z
   \   0000009E   8151               LDD     R21, Z+1
   \   000000A0   8162               LDD     R22, Z+2
   \   000000A2   8173               LDD     R23, Z+3
   \   000000A4   ........           CALL    ?F_SUB_L04
   \   000000A8   01C8               MOVW    R25:R24, R17:R16
   \   000000AA   01D9               MOVW    R27:R26, R19:R18
    335                      TData.Hart.ADCurrent[chnl] += (current - TData.Hart.ADCurrent[chnl]) / ((float)TData.Hart.Filter[chnl] + 1.0);
   \   000000AC   2D0A               MOV     R16, R10
   \   000000AE   E010               LDI     R17, 0
   \   000000B0   0F00               LSL     R16
   \   000000B2   1F11               ROL     R17
   \   000000B4   0F00               LSL     R16
   \   000000B6   1F11               ROL     R17
   \   000000B8   01F8               MOVW    R31:R30, R17:R16
   \   000000BA   ....               SUBI    R30, LOW((-(TData + 172) & 0xFFFF))
   \   000000BC   ....               SBCI    R31, HIGH((-(TData + 172) & 0xFFFF))
   \   000000BE   8140               LD      R20, Z
   \   000000C0   8151               LDD     R21, Z+1
   \   000000C2   8162               LDD     R22, Z+2
   \   000000C4   8173               LDD     R23, Z+3
   \   000000C6   018C               MOVW    R17:R16, R25:R24
   \   000000C8   019D               MOVW    R19:R18, R27:R26
   \   000000CA   ........           CALL    ?F_SUB_L04
   \   000000CE   0128               MOVW    R5:R4, R17:R16
   \   000000D0   0139               MOVW    R7:R6, R19:R18
   \   000000D2   24BB               CLR     R11
   \   000000D4   01F5               MOVW    R31:R30, R11:R10
   \   000000D6   ....               SUBI    R30, LOW((-(TData + 160) & 0xFFFF))
   \   000000D8   ....               SBCI    R31, HIGH((-(TData + 160) & 0xFFFF))
   \   000000DA   8100               LD      R16, Z
   \   000000DC   E010               LDI     R17, 0
   \   000000DE   E020               LDI     R18, 0
   \   000000E0   E030               LDI     R19, 0
   \   000000E2   ........           CALL    ?UL2F_L04
   \   000000E6   E040               LDI     R20, 0
   \   000000E8   E050               LDI     R21, 0
   \   000000EA   E860               LDI     R22, 128
   \   000000EC   E37F               LDI     R23, 63
   \   000000EE   ........           CALL    ?F_ADD_L04
   \   000000F2   01A8               MOVW    R21:R20, R17:R16
   \   000000F4   01B9               MOVW    R23:R22, R19:R18
   \   000000F6   0182               MOVW    R17:R16, R5:R4
   \   000000F8   0193               MOVW    R19:R18, R7:R6
   \   000000FA   ........           CALL    ?F_DIV_L04
   \   000000FE   2D4A               MOV     R20, R10
   \   00000100   E050               LDI     R21, 0
   \   00000102   0F44               LSL     R20
   \   00000104   1F55               ROL     R21
   \   00000106   0F44               LSL     R20
   \   00000108   1F55               ROL     R21
   \   0000010A   01FA               MOVW    R31:R30, R21:R20
   \   0000010C   ....               SUBI    R30, LOW((-(TData + 172) & 0xFFFF))
   \   0000010E   ....               SBCI    R31, HIGH((-(TData + 172) & 0xFFFF))
   \   00000110   8140               LD      R20, Z
   \   00000112   8151               LDD     R21, Z+1
   \   00000114   8162               LDD     R22, Z+2
   \   00000116   8173               LDD     R23, Z+3
   \   00000118   ........           CALL    ?F_ADD_L04
   \   0000011C   2D4A               MOV     R20, R10
   \   0000011E   E050               LDI     R21, 0
   \   00000120   0F44               LSL     R20
   \   00000122   1F55               ROL     R21
   \   00000124   0F44               LSL     R20
   \   00000126   1F55               ROL     R21
   \   00000128   01FA               MOVW    R31:R30, R21:R20
   \   0000012A   ....               SUBI    R30, LOW((-(TData + 172) & 0xFFFF))
   \   0000012C   ....               SBCI    R31, HIGH((-(TData + 172) & 0xFFFF))
   \   0000012E   8300               ST      Z, R16
   \   00000130   8311               STD     Z+1, R17
   \   00000132   8322               STD     Z+2, R18
   \   00000134   8333               STD     Z+3, R19
    336                  }
    337                  break;
   \   00000136   C030               RJMP    ??hart_diag_set_diag_value_1
    338              case 12:
    339              case 13:
    340                  // Not connected
    341                  break;
    342              case 14:
    343                  {
    344                      float Gain = 2.5 / current; 
   \                     ??hart_diag_set_diag_value_2:
   \   00000138   E000               LDI     R16, 0
   \   0000013A   E010               LDI     R17, 0
   \   0000013C   E220               LDI     R18, 32
   \   0000013E   E430               LDI     R19, 64
   \   00000140   01AC               MOVW    R21:R20, R25:R24
   \   00000142   01BD               MOVW    R23:R22, R27:R26
   \   00000144   ........           CALL    ?F_DIV_L04
   \   00000148   01A8               MOVW    R21:R20, R17:R16
   \   0000014A   01B9               MOVW    R23:R22, R19:R18
    345                      for (char ch = 0; ch < 12; ch++) {
   \   0000014C   E000               LDI     R16, 0
   \                     ??hart_diag_set_diag_value_4:
   \   0000014E   300C               CPI     R16, 12
   \   00000150   F518               BRCC    ??hart_diag_set_diag_value_1
    346                          TData.Hart.Gain[ch]         = Gain; // Original gain on AN-ZBANA is 0.9985 or 0.9965
   \   00000152   2F20               MOV     R18, R16
   \   00000154   E030               LDI     R19, 0
   \   00000156   0F22               LSL     R18
   \   00000158   1F33               ROL     R19
   \   0000015A   0F22               LSL     R18
   \   0000015C   1F33               ROL     R19
   \   0000015E   01F9               MOVW    R31:R30, R19:R18
   \   00000160   ....               SUBI    R30, LOW((-(TData + 412) & 0xFFFF))
   \   00000162   ....               SBCI    R31, HIGH((-(TData + 412) & 0xFFFF))
   \   00000164   8340               ST      Z, R20
   \   00000166   8351               STD     Z+1, R21
   \   00000168   8362               STD     Z+2, R22
   \   0000016A   8373               STD     Z+3, R23
    347                      }
   \   0000016C   9503               INC     R16
   \   0000016E   CFEF               RJMP    ??hart_diag_set_diag_value_4
    348                  }
    349                  break;
    350              case 15:
    351                  {
    352                      float Offset = current; 
   \                     ??hart_diag_set_diag_value_3:
   \   00000170   01AC               MOVW    R21:R20, R25:R24
   \   00000172   01BD               MOVW    R23:R22, R27:R26
    353                      for (char ch = 0; ch < 12; ch++) {
   \   00000174   E000               LDI     R16, 0
   \                     ??hart_diag_set_diag_value_5:
   \   00000176   300C               CPI     R16, 12
   \   00000178   F478               BRCC    ??hart_diag_set_diag_value_1
    354                          TData.Hart.Offset[ch] = Offset; // Original gain on AN-ZBANA is 0.9985 or 0.9965
   \   0000017A   2F20               MOV     R18, R16
   \   0000017C   E030               LDI     R19, 0
   \   0000017E   0F22               LSL     R18
   \   00000180   1F33               ROL     R19
   \   00000182   0F22               LSL     R18
   \   00000184   1F33               ROL     R19
   \   00000186   01F9               MOVW    R31:R30, R19:R18
   \   00000188   ....               SUBI    R30, LOW((-(TData + 364) & 0xFFFF))
   \   0000018A   ....               SBCI    R31, HIGH((-(TData + 364) & 0xFFFF))
   \   0000018C   8340               ST      Z, R20
   \   0000018E   8351               STD     Z+1, R21
   \   00000190   8362               STD     Z+2, R22
   \   00000192   8373               STD     Z+3, R23
    355                      }
   \   00000194   9503               INC     R16
   \   00000196   CFEF               RJMP    ??hart_diag_set_diag_value_5
    356                  }
    357                  break;
    358          
    359              }
    360          }
   \                     ??hart_diag_set_diag_value_1:
   \   00000198   E0EC               LDI     R30, 12
   \   0000019A   ........           JMP     ?EPILOGUE_B12_L09
    361          
    362          ////////////////////////////////////////////////////////////////////////////////
    363          //
    364          // HART Diagnostic Task
    365          //
    366          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    367          static void ad7715_read_diag_adc(hart_channel_t chnl) {
   \                     ad7715_read_diag_adc:
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   2FA0               MOV     R26, R16
    368          
    369              hart_gpio_adc_channel_select(chnl);
   \   00000006   2F0A               MOV     R16, R26
   \   00000008   ........           CALL    hart_gpio_adc_channel_select
    370              OS_Delay(10);
   \   0000000C   E00A               LDI     R16, 10
   \   0000000E   E010               LDI     R17, 0
   \   00000010   ........           CALL    OS_Delay
    371              ad7715_start_next_sample();
   \   00000014   ....               RCALL   ad7715_start_next_sample
    372              if (ad7715_wait_for_drdy()) {
   \   00000016   ....               RCALL   ad7715_wait_for_drdy
   \   00000018   2300               TST     R16
   \   0000001A   F031               BREQ    ??ad7715_read_diag_adc_0
    373                  uint16_t raw_adc = ad7715_read_sample();
   \   0000001C   ....               RCALL   ad7715_read_sample
   \   0000001E   01C8               MOVW    R25:R24, R17:R16
    374                  ad7715_put_on_hold();
   \   00000020   ....               RCALL   ad7715_put_on_hold
    375                  hart_diag_set_diag_value(chnl, raw_adc);
   \   00000022   019C               MOVW    R19:R18, R25:R24
   \   00000024   2F0A               MOV     R16, R26
   \   00000026   ....               RCALL   hart_diag_set_diag_value
    376              }
    377          }
   \                     ??ad7715_read_diag_adc_0:
   \   00000028   E0E3               LDI     R30, 3
   \   0000002A   ........           JMP     ?EPILOGUE_B3_L09
    378          

   \                                 In  segment CODE, align 2, keep-with-next
    379          static void HARTDiag_Task(void) {
   \                     HARTDiag_Task:
   \   00000000   938A               ST      -Y, R24
    380              hart_channel_t      current;
    381              hasStartedHartDiag = true;
   \   00000002   E001               LDI     R16, 1
   \   00000004   9300....           STS     hasStartedHartDiag, R16
    382              hart_diag_init();
   \   00000008   ....               RCALL   hart_diag_init
    383          
    384              //ad7715_hard_reset();
    385              while (1) {
    386                  hart_for_each_channel(current) {
   \                     ??HARTDiag_Task_0:
   \   0000000A   E080               LDI     R24, 0
   \                     ??HARTDiag_Task_1:
   \   0000000C   308C               CPI     R24, 12
   \   0000000E   F7E8               BRCC    ??HARTDiag_Task_0
    387                      ad7715_read_diag_adc(current);
   \   00000010   2F08               MOV     R16, R24
   \   00000012   ....               RCALL   ad7715_read_diag_adc
    388                      ad7715_toggle_debug_led();
   \   00000014   ....               RCALL   ad7715_toggle_debug_led
    389                      OS_Delay(200);
   \   00000016   EC08               LDI     R16, 200
   \   00000018   E010               LDI     R17, 0
   \   0000001A   ........           CALL    OS_Delay
    390                  }
   \   0000001E   9583               INC     R24
   \   00000020   CFF5               RJMP    ??HARTDiag_Task_1
    391          #if 0 // for ADC debugging only
    392                  //ad7715_read_diag_adc((hart_channel_t)12);
    393                  //ad7715_read_diag_adc((hart_channel_t)13);
    394                  //
    395                  // 2.5V reference check for debugging
    396                  //
    397                  ad7715_read_diag_adc((hart_channel_t)14);
    398          
    399                  //
    400                  // 0V ground
    401                  //
    402                  ad7715_read_diag_adc((hart_channel_t)15);
    403          #endif
    404              }
    405          }
    406          
    407          ////////////////////////////////////////////////////////////////////////////////
    408          //
    409          // public interfaces
    410          //
    411          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    412          void hart_diag_init(void) {
   \                     hart_diag_init:
    413              hart_diag_configure_adc();
   \   00000000   ....               RCALL   hart_diag_configure_adc
    414              TData.Hart.PortUsed   = 0;
   \   00000002   ....               LDI     R30, LOW((TData + 144))
   \   00000004   ....               LDI     R31, HIGH((TData + 144))
   \   00000006   E000               LDI     R16, 0
   \   00000008   8300               ST      Z, R16
   \   0000000A   E000               LDI     R16, 0
   \   0000000C   8301               STD     Z+1, R16
    415              TData.Hart.HartSensor = 0;
   \   0000000E   ....               LDI     R30, LOW((TData + 146))
   \   00000010   ....               LDI     R31, HIGH((TData + 146))
   \   00000012   E000               LDI     R16, 0
   \   00000014   8300               ST      Z, R16
   \   00000016   E000               LDI     R16, 0
   \   00000018   8301               STD     Z+1, R16
    416              for (char ch = 0; ch < 12; ch++) {
   \   0000001A   E040               LDI     R20, 0
   \                     ??hart_diag_init_0:
   \   0000001C   304C               CPI     R20, 12
   \   0000001E   F008               BRCS    $+2+2
   \   00000020   C041               RJMP    ??hart_diag_init_1
    417                  TData.Hart.Filter[ch]       = 3;
   \   00000022   E050               LDI     R21, 0
   \   00000024   01FA               MOVW    R31:R30, R21:R20
   \   00000026   ....               SUBI    R30, LOW((-(TData + 160) & 0xFFFF))
   \   00000028   ....               SBCI    R31, HIGH((-(TData + 160) & 0xFFFF))
   \   0000002A   E003               LDI     R16, 3
   \   0000002C   8300               ST      Z, R16
    418                  TData.Hart.Gain[ch]         = 1.0 / 1.0028280; // Original gain on AN-ZBANA is 0.9985 or 0.9965
   \   0000002E   2F04               MOV     R16, R20
   \   00000030   E010               LDI     R17, 0
   \   00000032   0F00               LSL     R16
   \   00000034   1F11               ROL     R17
   \   00000036   0F00               LSL     R16
   \   00000038   1F11               ROL     R17
   \   0000003A   01F8               MOVW    R31:R30, R17:R16
   \   0000003C   ....               SUBI    R30, LOW((-(TData + 412) & 0xFFFF))
   \   0000003E   ....               SBCI    R31, HIGH((-(TData + 412) & 0xFFFF))
   \   00000040   E300               LDI     R16, 48
   \   00000042   E417               LDI     R17, 71
   \   00000044   E72F               LDI     R18, 127
   \   00000046   E33F               LDI     R19, 63
   \   00000048   8300               ST      Z, R16
   \   0000004A   8311               STD     Z+1, R17
   \   0000004C   8322               STD     Z+2, R18
   \   0000004E   8333               STD     Z+3, R19
    419                  TData.Hart.Offset[ch]       = 0.0;
   \   00000050   2F04               MOV     R16, R20
   \   00000052   E010               LDI     R17, 0
   \   00000054   0F00               LSL     R16
   \   00000056   1F11               ROL     R17
   \   00000058   0F00               LSL     R16
   \   0000005A   1F11               ROL     R17
   \   0000005C   01F8               MOVW    R31:R30, R17:R16
   \   0000005E   ....               SUBI    R30, LOW((-(TData + 364) & 0xFFFF))
   \   00000060   ....               SBCI    R31, HIGH((-(TData + 364) & 0xFFFF))
   \   00000062   E000               LDI     R16, 0
   \   00000064   8300               ST      Z, R16
   \   00000066   E000               LDI     R16, 0
   \   00000068   8301               STD     Z+1, R16
   \   0000006A   E000               LDI     R16, 0
   \   0000006C   8302               STD     Z+2, R16
   \   0000006E   E000               LDI     R16, 0
   \   00000070   8303               STD     Z+3, R16
    420                  TData.Hart.ADCurrent[ch]    = 4.0;
   \   00000072   2F04               MOV     R16, R20
   \   00000074   E010               LDI     R17, 0
   \   00000076   0F00               LSL     R16
   \   00000078   1F11               ROL     R17
   \   0000007A   0F00               LSL     R16
   \   0000007C   1F11               ROL     R17
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   ....               SUBI    R30, LOW((-(TData + 172) & 0xFFFF))
   \   00000082   ....               SBCI    R31, HIGH((-(TData + 172) & 0xFFFF))
   \   00000084   E000               LDI     R16, 0
   \   00000086   E010               LDI     R17, 0
   \   00000088   E820               LDI     R18, 128
   \   0000008A   E430               LDI     R19, 64
   \   0000008C   8300               ST      Z, R16
   \   0000008E   8311               STD     Z+1, R17
   \   00000090   8322               STD     Z+2, R18
   \   00000092   8333               STD     Z+3, R19
    421                  TData.Hart.HartCmd[ch]      = 1;
   \   00000094   E050               LDI     R21, 0
   \   00000096   01FA               MOVW    R31:R30, R21:R20
   \   00000098   ....               SUBI    R30, LOW((-(TData + 148) & 0xFFFF))
   \   0000009A   ....               SBCI    R31, HIGH((-(TData + 148) & 0xFFFF))
   \   0000009C   E001               LDI     R16, 1
   \   0000009E   8300               ST      Z, R16
    422              }
   \   000000A0   9543               INC     R20
   \   000000A2   CFBC               RJMP    ??hart_diag_init_0
    423          }
   \                     ??hart_diag_init_1:
   \   000000A4   9508               RET
    424          

   \                                 In  segment CODE, align 2, keep-with-next
    425          void hart_diag_task_start(void) {
   \                     hart_diag_task_start:
    426              OS_CREATETASK(&TCB_AD7715, "HARTDiag", HARTDiag_Task, 135, _hart_diag_task_stack);
   \   00000000   E002               LDI     R16, 2
   \   00000002   E010               LDI     R17, 0
   \   00000004   931A               ST      -Y, R17
   \   00000006   930A               ST      -Y, R16
   \   00000008   E20C               LDI     R16, 44
   \   0000000A   E011               LDI     R17, 1
   \   0000000C   931A               ST      -Y, R17
   \   0000000E   930A               ST      -Y, R16
   \   00000010   ....               LDI     R16, LOW(_hart_diag_task_stack)
   \   00000012   ....               LDI     R17, (_hart_diag_task_stack) >> 8
   \   00000014   931A               ST      -Y, R17
   \   00000016   930A               ST      -Y, R16
   \   00000018   ....               LDI     R22, LOW(HARTDiag_Task/2)
   \   0000001A   ....               LDI     R23, (HARTDiag_Task/2) >> 8
   \   0000001C   E847               LDI     R20, 135
   \   0000001E   ....               LDI     R18, LOW(`?<Constant "HARTDiag">`)
   \   00000020   ....               LDI     R19, (`?<Constant "HARTDiag">`) >> 8
   \   00000022   ....               LDI     R16, LOW(TCB_AD7715)
   \   00000024   ....               LDI     R17, (TCB_AD7715) >> 8
   \   00000026   ........           CALL    OS_CreateTask_D
    427          }
   \   0000002A   9508               RET

   \                                 In  segment INTVEC, offset 0x4, root
   \                     `??IntHandler_INT0::??INTVEC 4`:
   \   00000004   ........           JMP     IntHandler_INT0

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "HARTDiag">>`:
   \   00000000   414854526944       DC8 "HARTDiag"
   \              676100      

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for StackTest5>`:
   \   00000000   323134333635       DC8 "123456789"
   \              38370039    

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for StackTest6>`:
   \   00000000   323134333635       DC8 "123456789"
   \              38370039    

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for on_off>`:
   \   00000000   01                 DC8 1

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant "HARTDiag">`:
   \   00000000                      DS8 9
   \   00000009                      REQUIRE `?<Initializer for <Constant "HARTDiag">>`

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      1      2   HARTDiag_Task
        1      2   -> OS_Delay
        1      2   -> ad7715_read_diag_adc
        1      2   -> ad7715_toggle_debug_led
        1      2   -> hart_diag_init
      0      2   INT_Handler_INT0
        0      2   -> OS_SignalEvent
     16      2   IntHandler_INT0
       16      2   -> OS_CallISR_Debug
      0      2   ad7715_do_calibration
        0      2   -> ad7715_put_on_hold
        0      2   -> ad7715_read_sample
        0      2   -> ad7715_wait_for_drdy
        0      2   -> ad7715_write_byte
        0      2   -> hart_gpio_adc_channel_select
      0      2   ad7715_hard_reset
        0      2   -> OS_Delay
        0      2   -> hart_gpio_adc_reset
      0      2   ad7715_put_on_hold
        0      2   -> ad7715_write_byte
      0      2   ad7715_read_byte
      3      2   ad7715_read_diag_adc
        3      2   -> OS_Delay
        3      2   -> ad7715_put_on_hold
        3      2   -> ad7715_read_sample
        3      2   -> ad7715_start_next_sample
        3      2   -> ad7715_wait_for_drdy
        3      2   -> hart_diag_set_diag_value
        3      2   -> hart_gpio_adc_channel_select
      0      2   ad7715_read_sample
        0      2   -> ad7715_read_byte
        0      2   -> ad7715_write_byte
      0      2   ad7715_start_next_sample
        0      2   -> ad7715_write_byte
      0      2   ad7715_toggle_debug_led
        0      2   -> hart_gpio_debug_led
      0      2   ad7715_wait_for_drdy
        0      2   -> OS_WaitSingleEventTimed
      0      2   ad7715_write_byte
      0      2   hart_diag_configure_adc
        0      2   -> OS_Delay
        0      2   -> ad7715_do_calibration
        0      2   -> ad7715_hard_reset
      0      2   hart_diag_init
        0      2   -> hart_diag_configure_adc
     12      2   hart_diag_set_diag_value
       12      2 ?F_ADD_L04
       12      2 ?F_DIV_L04
       12      2 ?F_MUL_L04
       12      2 ?F_SUB_L04
       12      2 ?UL2F_L04
      6      2   hart_diag_task_start
        0      2   -> OS_CreateTask_D


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant "HARTDiag">
       9  ?<Initializer for <Constant "HARTDiag">>
      10  ?<Initializer for StackTest5>
      10  ?<Initializer for StackTest6>
       1  ?<Initializer for on_off>
       1  CriticalADC_Failure
      34  HARTDiag_Task
      20  INT_Handler_INT0
      82  IntHandler_INT0
       4  IntHandler_INT0::??INTVEC 4
       4  Last_ADC_FuckUpTime
       4  Last_ADC_OK_Time
      10  StackTest5
      10  StackTest6
      33  TCB_AD7715
       1  _A_PINL
       1  _A_PORTL
     300  _hart_diag_task_stack
       2  _num_adc_fuckups
      28  ad7715_do_calibration
      44  ad7715_hard_reset
      10  ad7715_put_on_hold
      46  ad7715_read_byte
      46  ad7715_read_diag_adc
      30  ad7715_read_sample
      10  ad7715_start_next_sample
      32  ad7715_toggle_debug_led
      82  ad7715_wait_for_drdy
      60  ad7715_write_byte
      22  hart_diag_configure_adc
     166  hart_diag_init
     414  hart_diag_set_diag_value
      44  hart_diag_task_start
       1  hasStartedHartDiag
       1  on_off
      14  -- Other

 
     2 bytes in segment ABSOLUTE
 1 170 bytes in segment CODE
    14 bytes in segment INITTAB
     4 bytes in segment INTVEC
    30 bytes in segment NEAR_I
    30 bytes in segment NEAR_ID
   345 bytes in segment NEAR_Z
 
 1 200 bytes of CODE memory (+ 18 bytes shared)
   375 bytes of DATA memory (+  2 bytes shared)

Errors: none
Warnings: none
