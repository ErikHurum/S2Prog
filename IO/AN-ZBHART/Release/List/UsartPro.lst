###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       29/Jan/2024  09:35:44
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\UsartPro.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWBD1B.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\UsartPro.c"
#        --cpu=m1280 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Release\Obj" -D
#        OS_LIBMODE_R -D OS_UART=-1 -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Release\List" -y
#        --initializers_in_flash -DENABLE_BIT_DEFINITIONS -e -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\INC\\" -I
#        ..\..\..\Shared\Inc\\ --eeprom_size 4096 --clib -Ohs)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Release\List\UsartPro.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Release\Obj\UsartPro.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\AN-ZBHART\Src\UsartPro.c
      1          /****************************************************************************************
      2          / Com protocol for USART0
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0xc1
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "string.h"
     10          #include "RTOS.h"
     11          #include "hart.h"
     12          #include "externals.h"
     13          #include "version.h"
     14          #include "structs.h"
     15          

   \                                 In  segment ABSOLUTE, at 0x21fd
     16          __no_init int RestartCnt             @0x21FD;
   \                     RestartCnt:
   \   00000000                      DS8 2
     17          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     18          char hasStartedUARTTask = 0;
   \                     hasStartedUARTTask:
   \   00000000                      DS8 1
     19          
     20          //extern __no_init TargetData  TData;                    
     21          /*************************************************************************
     22          *   
     23          *  Handle the ANPRO10 protocol
     24          * 
     25          *  Returns 1 if a reply has been sent
     26          *
     27          *************************************************************************/

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   00000000                      DS8 2
     28          static unsigned LastCommand = 0;

   \                                 In  segment CODE, align 2, keep-with-next
     29          char ANPRO10_UnpackPacket(void) {
   \                     ANPRO10_UnpackPacket:
   \   00000000   927A               ST      -Y, R7
   \   00000002   926A               ST      -Y, R6
   \   00000004   925A               ST      -Y, R5
   \   00000006   924A               ST      -Y, R4
   \   00000008   93BA               ST      -Y, R27
   \   0000000A   93AA               ST      -Y, R26
   \   0000000C   939A               ST      -Y, R25
   \   0000000E   938A               ST      -Y, R24
   \   00000010                      REQUIRE ?Register_R4_is_cg_reg
   \   00000010                      REQUIRE ?Register_R5_is_cg_reg
   \   00000010                      REQUIRE ?Register_R6_is_cg_reg
   \   00000010                      REQUIRE ?Register_R7_is_cg_reg
     30              char *Buf = My485UART.pRxBuffer;
     31              const ANPRO10_PacketHeading *pPH = (ANPRO10_PacketHeading *)Buf;
     32              My485UART.RxCount++;
   \   00000010   9100....           LDS     R16, (My485UART + 673)
   \   00000014   9110....           LDS     R17, (My485UART + 674)
   \   00000018   5F0F               SUBI    R16, 255
   \   0000001A   4F1F               SBCI    R17, 255
   \   0000001C   9300....           STS     (My485UART + 673), R16
   \   00000020   9310....           STS     (My485UART + 674), R17
     33              My485UART.TxAddress   = pPH->txadr;
   \   00000024   ....               LDI     R30, LOW((My485UART + 523))
   \   00000026   ....               LDI     R31, HIGH((My485UART + 523))
   \   00000028   8101               LDD     R16, Z+1
   \   0000002A   9300....           STS     (My485UART + 9), R16
     34              My485UART.TxId        = pPH->txtypeid;
   \   0000002E   8100               LD      R16, Z
   \   00000030   9300....           STS     (My485UART + 8), R16
     35              My485UART.RxSendReply = false;                              // flag for answering set to fault
   \   00000034   E000               LDI     R16, 0
   \   00000036   9300....           STS     (My485UART + 672), R16
     36              My485UART.TxFirst     = 11;                                 // Start pos for first TX command
   \   0000003A   E00B               LDI     R16, 11
   \   0000003C   9300....           STS     My485UART, R16
   \   00000040   E000               LDI     R16, 0
   \   00000042   9300....           STS     (My485UART + 1), R16
     37          
     38              Buf += sizeof(ANPRO10_PacketHeading);
   \   00000046   ....               LDI     R24, LOW((My485UART + 528))
   \   00000048   ....               LDI     R25, HIGH((My485UART + 528))
     39              const char *EndPtr =  (char*)&Buf[pPH->nob];
   \   0000004A   8122               LDD     R18, Z+2
   \   0000004C   8133               LDD     R19, Z+3
   \   0000004E   012C               MOVW    R5:R4, R25:R24
   \   00000050   0E42               ADD     R4, R18
   \   00000052   1E53               ADC     R5, R19
     40              // Sanity check
     41              if ( pPH->nob >= RXSIZE_UART-5 ) {
   \   00000054   8102               LDD     R16, Z+2
   \   00000056   8113               LDD     R17, Z+3
   \   00000058   3901               CPI     R16, 145
   \   0000005A   E000               LDI     R16, 0
   \   0000005C   4010               SBCI    R17, 0
   \   0000005E   F008               BRCS    $+2+2
   \   00000060   C073               RJMP    ??ANPRO10_UnpackPacket_0
     42                  return 0;
     43              }
     44              ANPRO10_CommandHeading *pCH;
     45              char MoreCommands = true;
   \   00000062   E00F               LDI     R16, 15
   \   00000064   2E70               MOV     R7, R16
   \   00000066   2466               CLR     R6
   \   00000068   946A               DEC     R6
     46              do {
     47                  pCH = (ANPRO10_CommandHeading *)Buf;
   \                     ??ANPRO10_UnpackPacket_1:
   \   0000006A   01DC               MOVW    R27:R26, R25:R24
     48                  Buf += sizeof(ANPRO10_CommandHeading);  // ??
   \   0000006C   9604               ADIW    R25:R24, 4
     49                  switch ( pCH->CommandNo ) {
     50                  case ECMD_NMDWOACK:
     51                  case ECMD_NMDRQACK:
     52                      break;
     53                  default:
     54                      LastCommand = pCH->CommandNo;
     55                      break;
     56                  }
     57                  switch ( pCH->CommandNo ) {
   \   0000006E   91ED               LD      R30, X+
   \   00000070   91FC               LD      R31, X
   \   00000072   9711               SBIW    R27:R26, 1
   \   00000074   9630               ADIW    R31:R30, 0
   \   00000076   F409               BRNE    $+2+2
   \   00000078   C060               RJMP    ??ANPRO10_UnpackPacket_2
   \   0000007A   9731               SBIW    R31:R30, 1
   \   0000007C   F409               BRNE    $+2+2
   \   0000007E   C05D               RJMP    ??ANPRO10_UnpackPacket_2
   \   00000080   5EE7               SUBI    R30, 231
   \   00000082   40F3               SBCI    R31, 3
   \   00000084   F0C9               BREQ    ??ANPRO10_UnpackPacket_3
   \   00000086   973A               SBIW    R31:R30, 10
   \   00000088   F0E1               BREQ    ??ANPRO10_UnpackPacket_4
   \   0000008A   973A               SBIW    R31:R30, 10
   \   0000008C   F0E9               BREQ    ??ANPRO10_UnpackPacket_5
   \   0000008E   97F2               SBIW    R31:R30, 50
   \   00000090   F141               BREQ    ??ANPRO10_UnpackPacket_6
   \   00000092   973A               SBIW    R31:R30, 10
   \   00000094   F149               BREQ    ??ANPRO10_UnpackPacket_7
   \   00000096   973A               SBIW    R31:R30, 10
   \   00000098   F151               BREQ    ??ANPRO10_UnpackPacket_8
   \   0000009A   5AE0               SUBI    R30, 160
   \   0000009C   40F0               SBCI    R31, 0
   \   0000009E   F151               BREQ    ??ANPRO10_UnpackPacket_9
   \   000000A0   973A               SBIW    R31:R30, 10
   \   000000A2   F171               BREQ    ??ANPRO10_UnpackPacket_10
   \   000000A4   973A               SBIW    R31:R30, 10
   \   000000A6   F179               BREQ    ??ANPRO10_UnpackPacket_11
   \   000000A8   973A               SBIW    R31:R30, 10
   \   000000AA   F1D1               BREQ    ??ANPRO10_UnpackPacket_12
   \   000000AC   973A               SBIW    R31:R30, 10
   \   000000AE   F1D9               BREQ    ??ANPRO10_UnpackPacket_13
   \   000000B0   56EC               SUBI    R30, 108
   \   000000B2   40F2               SBCI    R31, 2
   \   000000B4   F019               BREQ    ??ANPRO10_UnpackPacket_14
   \   000000B6   C038               RJMP    ??ANPRO10_UnpackPacket_15
     58                  case CMD_REQ_STATUS :                           // Regusest status for target
     59                      BuildStatusData();                          // make package
   \                     ??ANPRO10_UnpackPacket_3:
   \   000000B8   ....               RCALL   BuildStatusData
     60                      break;
   \   000000BA   C036               RJMP    ??ANPRO10_UnpackPacket_15
     61                  case CMD_GET_STACKSTATUS :                      // Request stck status
     62                      BuildStackStatus( Buf);
   \                     ??ANPRO10_UnpackPacket_14:
   \   000000BC   018C               MOVW    R17:R16, R25:R24
   \   000000BE   ....               RCALL   BuildStackStatus
     63                      break;
   \   000000C0   C033               RJMP    ??ANPRO10_UnpackPacket_15
     64                  case CMD_EEPROM_RESET :                         // Reset EEPROM??
     65                      GetResetEEPROM();
   \                     ??ANPRO10_UnpackPacket_4:
   \   000000C2   ........           CALL    EEPROMReset
     66                      break;
   \   000000C6   C030               RJMP    ??ANPRO10_UnpackPacket_15
   \                     ??ANPRO10_UnpackPacket_5:
   \   000000C8   99F9               SBIC    0x1F, 0x01
   \   000000CA   CFFE               RJMP    ??ANPRO10_UnpackPacket_5
   \   000000CC   BC61               OUT     0x21, R6
   \   000000CE   BC72               OUT     0x22, R7
   \   000000D0   E000               LDI     R16, 0
   \   000000D2   BD00               OUT     0x20, R16
   \   000000D4   9AFA               SBI     0x1F, 0x02
   \   000000D6   9AF9               SBI     0x1F, 0x01
   \                     ??ANPRO10_UnpackPacket_16:
   \   000000D8   99F9               SBIC    0x1F, 0x01
   \   000000DA   CFFE               RJMP    ??ANPRO10_UnpackPacket_16
   \   000000DC   940EF000           CALL    0x1E000
     67                  case CMD_GOTO_BOOTLOADER :                      // Goto bootlaoder??
     68                      GetGotoBootloader(Buf);
     69                      break;
   \   000000E0   C023               RJMP    ??ANPRO10_UnpackPacket_15
     70                  case CMD_SND_EEPROM_DATA :                      // Receive EEPROM data
     71                      GetEEPROMData(Buf);
   \                     ??ANPRO10_UnpackPacket_6:
   \   000000E2   018C               MOVW    R17:R16, R25:R24
   \   000000E4   ....               RCALL   GetEEPROMData
     72                      break;
   \   000000E6   C020               RJMP    ??ANPRO10_UnpackPacket_15
     73                  case CMD_REQ_EEPROM_DATA :                      // Request to send EEPROM data
     74                      BuildEEPROMData( Buf);
   \                     ??ANPRO10_UnpackPacket_7:
   \   000000E8   018C               MOVW    R17:R16, R25:R24
   \   000000EA   ....               RCALL   BuildEEPROMData
     75                      break;
   \   000000EC   C01D               RJMP    ??ANPRO10_UnpackPacket_15
     76                  case CMD_REQ_INT_DATA :                         // Request external data
     77                      BuildADInt( Buf);
   \                     ??ANPRO10_UnpackPacket_8:
   \   000000EE   018C               MOVW    R17:R16, R25:R24
   \   000000F0   ....               RCALL   BuildADInt
     78                      break;
   \   000000F2   C01A               RJMP    ??ANPRO10_UnpackPacket_15
     79                  case CMD_SND_HART_SETUP :                       // Receive sertup of AN-RSANA
     80                      GetHartSetup(Buf, pCH->ndb);
   \                     ??ANPRO10_UnpackPacket_9:
   \   000000F4   01FD               MOVW    R31:R30, R27:R26
   \   000000F6   8122               LDD     R18, Z+2
   \   000000F8   8133               LDD     R19, Z+3
   \   000000FA   018C               MOVW    R17:R16, R25:R24
   \   000000FC   ....               RCALL   GetHartSetup
     81                      break;
   \   000000FE   C014               RJMP    ??ANPRO10_UnpackPacket_15
     82                  case CMD_REQ_HART_SETUP :                       // Request for sertup of AN-RSANA
     83                      BuildHartSetup( Buf);
   \                     ??ANPRO10_UnpackPacket_10:
   \   00000100   018C               MOVW    R17:R16, R25:R24
   \   00000102   ....               RCALL   BuildHartSetup
     84                      break;
   \   00000104   C011               RJMP    ??ANPRO10_UnpackPacket_15
     85                  case CMD_SND_HART_FILTER :                      // Receive filter of AN-RSANA
     86                      GetHartFilter(Buf);
   \                     ??ANPRO10_UnpackPacket_11:
   \   00000106   01AC               MOVW    R21:R20, R25:R24
   \   00000108   ....               LDI     R18, LOW((TData + 160))
   \   0000010A   ....               LDI     R19, HIGH((TData + 160))
   \   0000010C   E00C               LDI     R16, 12
   \                     ??ANPRO10_UnpackPacket_17:
   \   0000010E   01FA               MOVW    R31:R30, R21:R20
   \   00000110   9111               LD      R17, Z+
   \   00000112   01AF               MOVW    R21:R20, R31:R30
   \   00000114   01F9               MOVW    R31:R30, R19:R18
   \   00000116   9311               ST      Z+, R17
   \   00000118   019F               MOVW    R19:R18, R31:R30
   \   0000011A   950A               DEC     R16
   \   0000011C   F029               BREQ    ??ANPRO10_UnpackPacket_15
   \   0000011E   CFF7               RJMP    ??ANPRO10_UnpackPacket_17
     87                      break;
     88                  case CMD_REQ_HART_FILTER :                      // Request filter of AN-RSANA
     89                      BuildHartFilter( Buf);
   \                     ??ANPRO10_UnpackPacket_12:
   \   00000120   018C               MOVW    R17:R16, R25:R24
   \   00000122   ....               RCALL   BuildHartFilter
     90                      break;
   \   00000124   C001               RJMP    ??ANPRO10_UnpackPacket_15
     91                  case CMD_REQ_HART_DATA :                        // Request ANA data(4-20ma)
     92                      BuildMDataHart();
   \                     ??ANPRO10_UnpackPacket_13:
   \   00000126   ....               RCALL   BuildMDataHart
     93                      break;
     94          
     95                  case ECMD_NMDWOACK:
     96                  case ECMD_NMDRQACK:
     97                      MoreCommands = false;
     98                      break;
     99                  default:
    100                      break;
    101          
    102                  }
    103                  if ( MoreCommands ) {
    104                      Buf += pCH->ndb;
   \                     ??ANPRO10_UnpackPacket_15:
   \   00000128   01FD               MOVW    R31:R30, R27:R26
   \   0000012A   8102               LDD     R16, Z+2
   \   0000012C   8113               LDD     R17, Z+3
   \   0000012E   0F80               ADD     R24, R16
   \   00000130   1F91               ADC     R25, R17
   \   00000132   1584               CP      R24, R4
   \   00000134   0595               CPC     R25, R5
   \   00000136   F408               BRCC    $+2+2
   \   00000138   CF98               RJMP    ??ANPRO10_UnpackPacket_1
    105                  }
    106              } while ( MoreCommands && (Buf < EndPtr) );
    107              if ( My485UART.RxSendReply ) {                                   //send answer?
   \                     ??ANPRO10_UnpackPacket_2:
   \   0000013A   9100....           LDS     R16, (My485UART + 672)
   \   0000013E   2300               TST     R16
   \   00000140   F009               BREQ    ??ANPRO10_UnpackPacket_18
    108                  My485UART_BuildTail();                                       // yes, build tail (and header) and start sending
   \   00000142   ....               RCALL   My485UART_BuildTail
    109              }
    110              return (My485UART.RxSendReply);
   \                     ??ANPRO10_UnpackPacket_18:
   \   00000144   9100....           LDS     R16, (My485UART + 672)
   \                     ??ANPRO10_UnpackPacket_0:
   \   00000148   9189               LD      R24, Y+
   \   0000014A   9199               LD      R25, Y+
   \   0000014C   91A9               LD      R26, Y+
   \   0000014E   91B9               LD      R27, Y+
   \   00000150   9049               LD      R4, Y+
   \   00000152   9059               LD      R5, Y+
   \   00000154   9069               LD      R6, Y+
   \   00000156   9079               LD      R7, Y+
   \   00000158   9508               RET
   \   0000015A                      REQUIRE _A_EECR
   \   0000015A                      REQUIRE _A_EEAR
   \   0000015A                      REQUIRE _A_EEDR
    111          }
    112          
    113          #define MAX_TIME_BETWEEN_BYTE	15
    114          

   \                                 In  segment CODE, align 2, keep-with-next
    115          void ANPRO10_IO_Receive(void) {
   \                     ANPRO10_IO_Receive:
   \   00000000   929A               ST      -Y, R9
   \   00000002   928A               ST      -Y, R8
   \   00000004   927A               ST      -Y, R7
   \   00000006   926A               ST      -Y, R6
   \   00000008   925A               ST      -Y, R5
   \   0000000A   924A               ST      -Y, R4
   \   0000000C   93BA               ST      -Y, R27
   \   0000000E   93AA               ST      -Y, R26
   \   00000010   939A               ST      -Y, R25
   \   00000012   938A               ST      -Y, R24
   \   00000014                      REQUIRE ?Register_R4_is_cg_reg
   \   00000014                      REQUIRE ?Register_R5_is_cg_reg
   \   00000014                      REQUIRE ?Register_R6_is_cg_reg
   \   00000014                      REQUIRE ?Register_R7_is_cg_reg
   \   00000014                      REQUIRE ?Register_R8_is_cg_reg
   \   00000014                      REQUIRE ?Register_R9_is_cg_reg
   \   00000014   9722               SBIW    R29:R28, 2
    116              unsigned char *RxBuf = (unsigned char *)My485UART.pRxBuffer;
    117              const ANPRO10_PacketHeading *pPH =  (ANPRO10_PacketHeading *)RxBuf;
    118              char Data;
    119              char dataAvailable = 1;
    120              int  SyncCnt       = 1;     // Initialize to 1 as 1 must have been found when exiting the while loop
   \   00000016   E081               LDI     R24, 1
   \   00000018   E090               LDI     R25, 0
    121              char PacketOK      = false; // Assume the worse at the beginning
    122              // Look for ANPRO10_SYN, ignore the rest
    123              do {
    124                  OS_GetMail1(&My485UART.RxMailBox, &Data);
   \                     ??ANPRO10_IO_Receive_0:
   \   0000001A   019E               MOVW    R19:R18, R29:R28
   \   0000001C   ....               LDI     R16, LOW((My485UART + 10))
   \   0000001E   ....               LDI     R17, HIGH((My485UART + 10))
   \   00000020   ........           CALL    OS_GetMail1
    125              }while ( Data != ANPRO10_SYN );
   \   00000024   8108               LD      R16, Y
   \   00000026   3106               CPI     R16, 22
   \   00000028   F7C1               BRNE    ??ANPRO10_IO_Receive_0
    126              // We know we have a ANPRO10_SYN
    127              // A minimum of 2 SYN to accept start
    128              //Message("First SYN");
    129              //SyncCnt = 0;
    130              do {
    131                  dataAvailable = !OS_GetMailTimed(&My485UART.RxMailBox, &Data, MAX_TIME_BETWEEN_BYTE);
   \                     ??ANPRO10_IO_Receive_1:
   \   0000002A   E04F               LDI     R20, 15
   \   0000002C   E050               LDI     R21, 0
   \   0000002E   019E               MOVW    R19:R18, R29:R28
   \   00000030   ....               LDI     R16, LOW((My485UART + 10))
   \   00000032   ....               LDI     R17, HIGH((My485UART + 10))
   \   00000034   ........           CALL    OS_GetMailTimed
   \   00000038   2300               TST     R16
   \   0000003A   F009               BREQ    $+2+2
   \   0000003C   C05D               RJMP    ??ANPRO10_IO_Receive_2
   \   0000003E   8108               LD      R16, Y
   \   00000040   3106               CPI     R16, 22
   \   00000042   F411               BRNE    ??ANPRO10_IO_Receive_3
    132                  if ( dataAvailable && (Data == ANPRO10_SYN) ) SyncCnt++;
   \   00000044   9601               ADIW    R25:R24, 1
   \   00000046   CFF1               RJMP    ??ANPRO10_IO_Receive_1
    133              } while ( dataAvailable && (Data == ANPRO10_SYN) );
    134              if ( dataAvailable && SyncCnt && (Data == ANPRO10_SOH) ) {
   \                     ??ANPRO10_IO_Receive_3:
   \   00000048   2B89               OR      R24, R25
   \   0000004A   F409               BRNE    $+2+2
   \   0000004C   C055               RJMP    ??ANPRO10_IO_Receive_2
   \   0000004E   3001               CPI     R16, 1
   \   00000050   F009               BREQ    $+2+2
   \   00000052   C052               RJMP    ??ANPRO10_IO_Receive_2
    135                  unsigned char *RxPtr = RxBuf;
   \   00000054   ....               LDI     R24, LOW((My485UART + 521))
   \   00000056   ....               LDI     R25, HIGH((My485UART + 521))
   \   00000058   01DC               MOVW    R27:R26, R25:R24
    136                  for ( unsigned i = 0; dataAvailable && i < sizeof(NetHeading); i++ ) {
   \   0000005A   E007               LDI     R16, 7
   \   0000005C   2E40               MOV     R4, R16
    137                      dataAvailable = !OS_GetMailTimed(&My485UART.RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
   \                     ??ANPRO10_IO_Receive_4:
   \   0000005E   E04F               LDI     R20, 15
   \   00000060   E050               LDI     R21, 0
   \   00000062   019D               MOVW    R19:R18, R27:R26
   \   00000064   ....               LDI     R16, LOW((My485UART + 10))
   \   00000066   ....               LDI     R17, HIGH((My485UART + 10))
   \   00000068   ........           CALL    OS_GetMailTimed
   \   0000006C   9611               ADIW    R27:R26, 1
   \   0000006E   2300               TST     R16
   \   00000070   F411               BRNE    ??ANPRO10_IO_Receive_5
   \   00000072   E001               LDI     R16, 1
   \   00000074   C001               RJMP    ??ANPRO10_IO_Receive_6
   \                     ??ANPRO10_IO_Receive_5:
   \   00000076   E000               LDI     R16, 0
    138                  }
   \                     ??ANPRO10_IO_Receive_6:
   \   00000078   944A               DEC     R4
   \   0000007A   2300               TST     R16
   \   0000007C   F1E9               BREQ    ??ANPRO10_IO_Receive_2
   \   0000007E   2044               TST     R4
   \   00000080   F771               BRNE    ??ANPRO10_IO_Receive_4
    139                  if ( dataAvailable ) {
    140                      unsigned char HCSum = 0;
   \   00000082   E040               LDI     R20, 0
    141                      {
    142                          unsigned char *TmpRxPtr = RxBuf;
   \   00000084   018C               MOVW    R17:R16, R25:R24
    143                          for ( unsigned i = 0; i < sizeof(ANPRO10_PacketHeading) - 1; i++ ) {
   \   00000086   E026               LDI     R18, 6
    144                              HCSum     = crc[HCSum ^ *TmpRxPtr++];
   \                     ??ANPRO10_IO_Receive_7:
   \   00000088   01F8               MOVW    R31:R30, R17:R16
   \   0000008A   9131               LD      R19, Z+
   \   0000008C   018F               MOVW    R17:R16, R31:R30
   \   0000008E   2743               EOR     R20, R19
   \   00000090   2FE4               MOV     R30, R20
   \   00000092   E0F0               LDI     R31, 0
   \   00000094   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000096   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000098   ....               LDI     R19, (crc) >> 16
   \   0000009A   BF3B               OUT     0x3B, R19
   \   0000009C   9146               ELPM    R20, Z
    145                          }
   \   0000009E   952A               DEC     R18
   \   000000A0   F799               BRNE    ??ANPRO10_IO_Receive_7
    146          
    147                      }
    148                      if ( HCSum == pPH->HCRC ) {
   \   000000A2   01FC               MOVW    R31:R30, R25:R24
   \   000000A4   8106               LDD     R16, Z+6
   \   000000A6   1740               CP      R20, R16
   \   000000A8   F539               BRNE    ??ANPRO10_IO_Receive_2
    149                          unsigned DataSize = (unsigned)pPH->nob;
   \   000000AA   8084               LDD     R8, Z+4
   \   000000AC   8095               LDD     R9, Z+5
    150                          // Before checked against MAX_ANPRO10_IO_SIZE which is not related to the buffer size for AN-ZBHART
    151                          if ( DataSize > 3 && DataSize < RXSIZE_UART ) { 
   \   000000AE   01F4               MOVW    R31:R30, R9:R8
   \   000000B0   9734               SBIW    R31:R30, 4
   \   000000B2   39E2               CPI     R30, 146
   \   000000B4   40F0               SBCI    R31, 0
   \   000000B6   F500               BRCC    ??ANPRO10_IO_Receive_2
    152                              for ( unsigned i = 0; dataAvailable && i < DataSize - sizeof(ANPRO10_PacketHeading); i++ ) {
   \   000000B8   2444               CLR     R4
   \   000000BA   2455               CLR     R5
   \   000000BC   0134               MOVW    R7:R6, R9:R8
   \   000000BE   EF09               LDI     R16, 249
   \   000000C0   0E60               ADD     R6, R16
   \   000000C2   EF0F               LDI     R16, 255
   \   000000C4   1E70               ADC     R7, R16
   \                     ??ANPRO10_IO_Receive_8:
   \   000000C6   1446               CP      R4, R6
   \   000000C8   0457               CPC     R5, R7
   \   000000CA   F538               BRCC    ??ANPRO10_IO_Receive_9
    153                                  dataAvailable = !OS_GetMailTimed(&My485UART.RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
   \   000000CC   E04F               LDI     R20, 15
   \   000000CE   E050               LDI     R21, 0
   \   000000D0   019D               MOVW    R19:R18, R27:R26
   \   000000D2   ....               LDI     R16, LOW((My485UART + 10))
   \   000000D4   ....               LDI     R17, HIGH((My485UART + 10))
   \   000000D6   ........           CALL    OS_GetMailTimed
   \   000000DA   9611               ADIW    R27:R26, 1
   \   000000DC   2300               TST     R16
   \   000000DE   F411               BRNE    ??ANPRO10_IO_Receive_10
   \   000000E0   E001               LDI     R16, 1
   \   000000E2   C001               RJMP    ??ANPRO10_IO_Receive_11
   \                     ??ANPRO10_IO_Receive_10:
   \   000000E4   E000               LDI     R16, 0
    154                              }
   \                     ??ANPRO10_IO_Receive_11:
   \   000000E6   E011               LDI     R17, 1
   \   000000E8   0E41               ADD     R4, R17
   \   000000EA   E010               LDI     R17, 0
   \   000000EC   1E51               ADC     R5, R17
   \   000000EE   2300               TST     R16
   \   000000F0   F751               BRNE    ??ANPRO10_IO_Receive_8
    155                              if ( dataAvailable ) {
    156                                  RxPtr = RxBuf;
    157                                  volatile unsigned char CSum = 0;
    158          
    159                                  for ( unsigned i = 0; i < DataSize - 2; i++ ) {
    160                                      CSum     = crc[CSum ^ *RxPtr++];
    161                                  }
    162                                  unsigned char  PacketCheckSum = *((unsigned char *)&RxBuf[DataSize - 2]);
    163                                  if ( PacketCheckSum == CSum ) {
    164                                      My485UART.SequenceNumber = RxBuf[DataSize - 3];
    165                                      // U16 EndCommand = *((U16*)&ARxBuf[DataSize-6]);
    166                                      // unsigned char EndData = *((unsigned char*)&ARxBuf[DataSize-4]);
    167                                      unsigned char EOTByte = *((unsigned char *)&RxBuf[DataSize - 1]);
    168                                      if ( EOTByte == ANPRO10_EOT ) {
    169                                          switch ( pPH->txtypeid ) {
    170                                          case DEVICE_TCU :
    171                                              if ( (pPH->rxadr == MyAddress()) && (pPH->rxtypeid == (UnitID + DEVICE_IO)) ) {
    172                                                  ANPRO10_UnpackPacket();
    173                                                  PacketOK = true; // Packet accepted so signal OK!
    174                                              } else {
    175                                                  //Ignore = true;
    176                                              }
    177                                              break;
    178                                          case DEVICE_ZBHART:
    179                                              //Echo = true;
    180                                              break;
    181                                          default:
    182                                              // Ignore message
    183                                              break;
    184                                          }
    185                                      }
    186                                  }
    187                              } else {
    188                                  OS_Delay(0);
   \   000000F2   E000               LDI     R16, 0
   \   000000F4   ........           CALL    OS_Delay
    189                              }
    190                          }
    191                      }
    192                  }
    193              }
    194              if ( !PacketOK ) {
    195                  My485UART.RxFaultCnt++;
   \                     ??ANPRO10_IO_Receive_2:
   \   000000F8   9100....           LDS     R16, (My485UART + 671)
   \   000000FC   9503               INC     R16
   \   000000FE   9300....           STS     (My485UART + 671), R16
    196              }
    197          }
   \                     ??ANPRO10_IO_Receive_12:
   \   00000102   9622               ADIW    R29:R28, 2
   \   00000104   9189               LD      R24, Y+
   \   00000106   9199               LD      R25, Y+
   \   00000108   91A9               LD      R26, Y+
   \   0000010A   91B9               LD      R27, Y+
   \   0000010C   9049               LD      R4, Y+
   \   0000010E   9059               LD      R5, Y+
   \   00000110   9069               LD      R6, Y+
   \   00000112   9079               LD      R7, Y+
   \   00000114   9089               LD      R8, Y+
   \   00000116   9099               LD      R9, Y+
   \   00000118   9508               RET
   \                     ??ANPRO10_IO_Receive_9:
   \   0000011A   01DC               MOVW    R27:R26, R25:R24
   \   0000011C   E000               LDI     R16, 0
   \   0000011E   8309               STD     Y+1, R16
   \   00000120   0184               MOVW    R17:R16, R9:R8
   \   00000122   5002               SUBI    R16, 2
   \   00000124   4010               SBCI    R17, 0
   \   00000126   2F20               MOV     R18, R16
   \   00000128   2B21               OR      R18, R17
   \   0000012A   F071               BREQ    ??ANPRO10_IO_Receive_13
   \                     ??ANPRO10_IO_Receive_14:
   \   0000012C   8129               LDD     R18, Y+1
   \   0000012E   913D               LD      R19, X+
   \   00000130   2723               EOR     R18, R19
   \   00000132   2FE2               MOV     R30, R18
   \   00000134   E0F0               LDI     R31, 0
   \   00000136   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000138   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000013A   ....               LDI     R19, (crc) >> 16
   \   0000013C   BF3B               OUT     0x3B, R19
   \   0000013E   9126               ELPM    R18, Z
   \   00000140   8329               STD     Y+1, R18
   \   00000142   5001               SUBI    R16, 1
   \   00000144   4010               SBCI    R17, 0
   \   00000146   F791               BRNE    ??ANPRO10_IO_Receive_14
   \                     ??ANPRO10_IO_Receive_13:
   \   00000148   ....               LDI     R30, LOW((My485UART + 518))
   \   0000014A   ....               LDI     R31, HIGH((My485UART + 518))
   \   0000014C   0DE8               ADD     R30, R8
   \   0000014E   1DF9               ADC     R31, R9
   \   00000150   8101               LDD     R16, Z+1
   \   00000152   8119               LDD     R17, Y+1
   \   00000154   1701               CP      R16, R17
   \   00000156   F681               BRNE    ??ANPRO10_IO_Receive_2
   \   00000158   8100               LD      R16, Z
   \   0000015A   9300....           STS     (My485UART + 676), R16
   \   0000015E   8102               LDD     R16, Z+2
   \   00000160   3004               CPI     R16, 4
   \   00000162   F651               BRNE    ??ANPRO10_IO_Receive_2
   \   00000164   01FC               MOVW    R31:R30, R25:R24
   \   00000166   8102               LDD     R16, Z+2
   \   00000168   3200               CPI     R16, 32
   \   0000016A   F631               BRNE    ??ANPRO10_IO_Receive_2
   \   0000016C   81A1               LDD     R26, Z+1
   \   0000016E   ........           CALL    MyAddress
   \   00000172   17A0               CP      R26, R16
   \   00000174   F609               BRNE    ??ANPRO10_IO_Receive_2
   \   00000176   01FC               MOVW    R31:R30, R25:R24
   \   00000178   8100               LD      R16, Z
   \   0000017A   E010               LDI     R17, 0
   \   0000017C   91E0....           LDS     R30, UnitID
   \   00000180   E0F0               LDI     R31, 0
   \   00000182   9670               ADIW    R31:R30, 16
   \   00000184   170E               CP      R16, R30
   \   00000186   071F               CPC     R17, R31
   \   00000188   F009               BREQ    $+2+2
   \   0000018A   CFB6               RJMP    ??ANPRO10_IO_Receive_2
   \   0000018C   ....               RCALL   ANPRO10_UnpackPacket
   \   0000018E   CFB9               RJMP    ??ANPRO10_IO_Receive_12
    198          
    199          /*************************************************************************
    200          *   (This is a task)
    201          *  Usart0 handler
    202          *
    203          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    204          void Usart0Handler(void) {
   \                     Usart0Handler:
    205              hasStartedUARTTask = 1;
   \   00000000   E001               LDI     R16, 1
   \   00000002   9300....           STS     hasStartedUARTTask, R16
    206              UCSR0B  = 1 << RXCIE0 | 1 << RXEN0 | 1 << TXEN0;  //0x98;                                       /* tx/ rx enable, int udre/rxon */
   \   00000006   E908               LDI     R16, 152
   \   00000008   9300....           STS     _A_UCSR0B, R16
    207              while ( 1 ) {
    208                  ANPRO10_IO_Receive();
   \                     ??Usart0Handler_0:
   \   0000000C   ....               RCALL   ANPRO10_IO_Receive
   \   0000000E   CFFE               RJMP    ??Usart0Handler_0
   \   00000010                      REQUIRE _A_UCSR0B
    209              }
    210          }
    211          
    212          
    213          
    214          
    215          /*************************************************************************
    216          *
    217          * Build send packet header
    218          *
    219          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    220          void My485UART_BuildHeader(void) {
   \                     My485UART_BuildHeader:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
    221          
    222              My485UART.TxLast  = 0;
   \   00000004   E000               LDI     R16, 0
   \   00000006   9300....           STS     (My485UART + 2), R16
   \   0000000A   9300....           STS     (My485UART + 3), R16
    223              char *txBuf = My485UART.pTxBuffer;
    224          
    225              txBuf[ 0] = ANPRO10_SYN;                        /* Sync */
   \   0000000E   ....               LDI     R26, LOW((My485UART + 121))
   \   00000010   ....               LDI     R27, HIGH((My485UART + 121))
   \   00000012   E106               LDI     R16, 22
   \   00000014   930C               ST      X, R16
    226              txBuf[ 1] = ANPRO10_SYN;                        /* Sync */
   \   00000016   01FD               MOVW    R31:R30, R27:R26
   \   00000018   8301               STD     Z+1, R16
    227              txBuf[ 2] = ANPRO10_SYN;                        /* Sync */
   \   0000001A   8302               STD     Z+2, R16
    228              txBuf[ 3] = ANPRO10_SOH;                        /* Start of header */
   \   0000001C   E001               LDI     R16, 1
   \   0000001E   8303               STD     Z+3, R16
    229              txBuf[ 4] = My485UART.TxId;                        /* RXID */
   \   00000020   9100....           LDS     R16, (My485UART + 8)
   \   00000024   8304               STD     Z+4, R16
    230              txBuf[ 5] = My485UART.TxAddress;                   /* Rx address */
   \   00000026   9100....           LDS     R16, (My485UART + 9)
   \   0000002A   8305               STD     Z+5, R16
    231              txBuf[ 6] = DEVICE_IO + UnitID;                 /* Unit ID */
   \   0000002C   9100....           LDS     R16, UnitID
   \   00000030   5F00               SUBI    R16, 240
   \   00000032   8306               STD     Z+6, R16
    232              txBuf[ 7] = MyAddress();                        /* Tx address */
   \   00000034   ........           CALL    MyAddress
   \   00000038   01FD               MOVW    R31:R30, R27:R26
   \   0000003A   8307               STD     Z+7, R16
    233              txBuf[ 8] = 0;                                  /* packlen HB, don't know yet */
   \   0000003C   E000               LDI     R16, 0
   \   0000003E   8700               STD     Z+8, R16
    234              txBuf[ 9] = 0;                                  /* packlen LB, don't know yet */
   \   00000040   8701               STD     Z+9, R16
    235              txBuf[10] = 0;                                  /* Header checksum, don't know yet */
   \   00000042   8702               STD     Z+10, R16
    236          }
   \   00000044   91A9               LD      R26, Y+
   \   00000046   91B9               LD      R27, Y+
   \   00000048   9508               RET
    237          
    238          /*************************************************************************
    239          *
    240          * Build  packet tail
    241          *
    242          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    243          void My485UART_BuildTail(void) {
   \                     My485UART_BuildTail:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
    244          
    245              My485UART_BuildHeader();                      // fist build the header
   \   00000008   ....               RCALL   My485UART_BuildHeader
    246              char *txBuf = My485UART.pTxBuffer;
    247              txBuf[My485UART.TxFirst++] = ECMD_NMDWOACK & 0xff;    // End command lb
   \   0000000A   9100....           LDS     R16, My485UART
   \   0000000E   9110....           LDS     R17, (My485UART + 1)
   \   00000012   01F8               MOVW    R31:R30, R17:R16
   \   00000014   9631               ADIW    R31:R30, 1
   \   00000016   93E0....           STS     My485UART, R30
   \   0000001A   93F0....           STS     (My485UART + 1), R31
   \   0000001E   01F8               MOVW    R31:R30, R17:R16
   \   00000020   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000022   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000024   E000               LDI     R16, 0
   \   00000026   8300               ST      Z, R16
    248              txBuf[My485UART.TxFirst++] = ECMD_NMDWOACK >> 8;      // End command hb
   \   00000028   9100....           LDS     R16, My485UART
   \   0000002C   9110....           LDS     R17, (My485UART + 1)
   \   00000030   01F8               MOVW    R31:R30, R17:R16
   \   00000032   9631               ADIW    R31:R30, 1
   \   00000034   93E0....           STS     My485UART, R30
   \   00000038   93F0....           STS     (My485UART + 1), R31
   \   0000003C   01F8               MOVW    R31:R30, R17:R16
   \   0000003E   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000040   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000042   E000               LDI     R16, 0
   \   00000044   8300               ST      Z, R16
    249              txBuf[My485UART.TxFirst++] = 0x00;                    // End data
   \   00000046   9100....           LDS     R16, My485UART
   \   0000004A   9110....           LDS     R17, (My485UART + 1)
   \   0000004E   01F8               MOVW    R31:R30, R17:R16
   \   00000050   9631               ADIW    R31:R30, 1
   \   00000052   93E0....           STS     My485UART, R30
   \   00000056   93F0....           STS     (My485UART + 1), R31
   \   0000005A   01F8               MOVW    R31:R30, R17:R16
   \   0000005C   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   0000005E   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000060   E000               LDI     R16, 0
   \   00000062   8300               ST      Z, R16
    250          
    251              txBuf[My485UART.TxFirst++] = My485UART.TxSeqCnt++;  // Sequence counter
   \   00000064   9100....           LDS     R16, My485UART
   \   00000068   9110....           LDS     R17, (My485UART + 1)
   \   0000006C   01F8               MOVW    R31:R30, R17:R16
   \   0000006E   9631               ADIW    R31:R30, 1
   \   00000070   93E0....           STS     My485UART, R30
   \   00000074   93F0....           STS     (My485UART + 1), R31
   \   00000078   9120....           LDS     R18, (My485UART + 7)
   \   0000007C   01F8               MOVW    R31:R30, R17:R16
   \   0000007E   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000080   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000082   8320               ST      Z, R18
   \   00000084   9100....           LDS     R16, (My485UART + 7)
   \   00000088   9503               INC     R16
   \   0000008A   9300....           STS     (My485UART + 7), R16
    252          
    253              txBuf[ 8] = My485UART.TxFirst - 2;                     // correct length because stx's
   \   0000008E   ....               LDI     R16, LOW((My485UART + 129))
   \   00000090   ....               LDI     R17, HIGH((My485UART + 129))
   \   00000092   9120....           LDS     R18, My485UART
   \   00000096   9130....           LDS     R19, (My485UART + 1)
   \   0000009A   5022               SUBI    R18, 2
   \   0000009C   01F8               MOVW    R31:R30, R17:R16
   \   0000009E   8320               ST      Z, R18
    254              txBuf[ 9] = (My485UART.TxFirst - 2) >> 8;              // packet len high
   \   000000A0   91E0....           LDS     R30, My485UART
   \   000000A4   91F0....           LDS     R31, (My485UART + 1)
   \   000000A8   9732               SBIW    R31:R30, 2
   \   000000AA   2F2F               MOV     R18, R31
   \   000000AC   01F8               MOVW    R31:R30, R17:R16
   \   000000AE   8321               STD     Z+1, R18
    255              txBuf[10] = CalcDSTxChecksum( 6);                       // Get header checksum
   \   000000B0   E040               LDI     R20, 0
   \   000000B2   ....               LDI     R26, LOW((My485UART + 125))
   \   000000B4   ....               LDI     R27, HIGH((My485UART + 125))
   \   000000B6   E026               LDI     R18, 6
   \   000000B8   ....               LDI     R19, (crc) >> 16
   \                     ??My485UART_BuildTail_0:
   \   000000BA   2FE4               MOV     R30, R20
   \   000000BC   E0F0               LDI     R31, 0
   \   000000BE   914D               LD      R20, X+
   \   000000C0   27E4               EOR     R30, R20
   \   000000C2   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000C4   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000C6   BF3B               OUT     0x3B, R19
   \   000000C8   9146               ELPM    R20, Z
   \   000000CA   952A               DEC     R18
   \   000000CC   F7B1               BRNE    ??My485UART_BuildTail_0
   \   000000CE   01F8               MOVW    R31:R30, R17:R16
   \   000000D0   8342               STD     Z+2, R20
    256              unsigned PacketStart = My485UART.TxFirst;
   \   000000D2   9140....           LDS     R20, My485UART
   \   000000D6   9150....           LDS     R21, (My485UART + 1)
    257              txBuf[My485UART.TxFirst]      = CalcDSTxChecksum(PacketStart - 4); // Get checksum
   \   000000DA   9160....           LDS     R22, My485UART
   \   000000DE   9170....           LDS     R23, (My485UART + 1)
   \   000000E2   5044               SUBI    R20, 4
   \   000000E4   4050               SBCI    R21, 0
   \   000000E6   E000               LDI     R16, 0
   \   000000E8   E080               LDI     R24, 0
   \   000000EA   E090               LDI     R25, 0
   \   000000EC   ....               LDI     R26, LOW((My485UART + 125))
   \   000000EE   ....               LDI     R27, HIGH((My485UART + 125))
   \   000000F0   2F14               MOV     R17, R20
   \   000000F2   2B15               OR      R17, R21
   \   000000F4   F059               BREQ    ??My485UART_BuildTail_1
   \                     ??My485UART_BuildTail_2:
   \   000000F6   2FE0               MOV     R30, R16
   \   000000F8   E0F0               LDI     R31, 0
   \   000000FA   910D               LD      R16, X+
   \   000000FC   27E0               EOR     R30, R16
   \   000000FE   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000100   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000102   9106               ELPM    R16, Z
   \   00000104   9601               ADIW    R25:R24, 1
   \   00000106   1784               CP      R24, R20
   \   00000108   0795               CPC     R25, R21
   \   0000010A   F3A8               BRCS    ??My485UART_BuildTail_2
   \                     ??My485UART_BuildTail_1:
   \   0000010C   01FB               MOVW    R31:R30, R23:R22
   \   0000010E   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000110   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000112   8300               ST      Z, R16
    258              My485UART.TxFirst++;                                  // OBS!! must be inc here due to ANSI standard !!!!
   \   00000114   9100....           LDS     R16, My485UART
   \   00000118   9110....           LDS     R17, (My485UART + 1)
   \   0000011C   5F0F               SUBI    R16, 255
   \   0000011E   4F1F               SBCI    R17, 255
   \   00000120   9300....           STS     My485UART, R16
   \   00000124   9310....           STS     (My485UART + 1), R17
    259          
    260              txBuf[My485UART.TxFirst++]    = ANPRO10_EOT;          // End of transmission
   \   00000128   9100....           LDS     R16, My485UART
   \   0000012C   9110....           LDS     R17, (My485UART + 1)
   \   00000130   01F8               MOVW    R31:R30, R17:R16
   \   00000132   9631               ADIW    R31:R30, 1
   \   00000134   93E0....           STS     My485UART, R30
   \   00000138   93F0....           STS     (My485UART + 1), R31
   \   0000013C   01F8               MOVW    R31:R30, R17:R16
   \   0000013E   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000140   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000142   E004               LDI     R16, 4
   \   00000144   8300               ST      Z, R16
    261           //   txBuf[My485UART.TxFirst++]    = ANPRO10_EOT;          // End of transmission
    262              My485UART.TxCount             = My485UART.TxFirst;  //bytes to send
   \   00000146   9100....           LDS     R16, My485UART
   \   0000014A   9110....           LDS     R17, (My485UART + 1)
   \   0000014E   9300....           STS     (My485UART + 4), R16
   \   00000152   9310....           STS     (My485UART + 5), R17
    263              My485UART.TxLast 			    = 0;                    // reset cunter
   \   00000156   E000               LDI     R16, 0
   \   00000158   9300....           STS     (My485UART + 2), R16
   \   0000015C   9300....           STS     (My485UART + 3), R16
    264              // Turn on TXE for channel
    265              My_SetBit(PORTE, 0x04);                                 // TXE0 on
   \   00000160   94F8               cli
   \   00000162   9A72               SBI     0x0E, 0x02
   \   00000164   9100....           LDS     R16, (OS_Global + 1)
   \   00000168   2300               TST     R16
   \   0000016A   F409               BRNE    ??My485UART_BuildTail_3
   \   0000016C   9478               sei
    266              OS_Delay(2);                                            // Ensure some settling time
   \                     ??My485UART_BuildTail_3:
   \   0000016E   E002               LDI     R16, 2
   \   00000170   E010               LDI     R17, 0
   \   00000172   ........           CALL    OS_Delay
    267              UCSR0B |= __BIT_MASK(UDRIE0);                           // start sending by enableing interrupt
   \   00000176   910000C1           LDS     R16, 193
   \   0000017A   6200               ORI     R16, 0x20
   \   0000017C   930000C1           STS     193, R16
    268              OS_WaitEvent(UART0_EVENT_TX_COMPLETE);
   \   00000180   E001               LDI     R16, 1
   \   00000182   ........           CALL    OS_WaitEvent
    269          
    270          }
   \   00000186   ....               RJMP    ?Subroutine0
   \   00000188                      REQUIRE _A_PORTE
   \   00000188                      REQUIRE _A_UCSR0B

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   9189               LD      R24, Y+
   \   00000002                      REQUIRE ??Subroutine1_0
   \   00000002                      ;               // Fall through to label ??Subroutine1_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine1_0:
   \   00000000   9199               LD      R25, Y+
   \   00000002   91A9               LD      R26, Y+
   \   00000004   91B9               LD      R27, Y+
   \   00000006   9508               RET
    271          
    272          /*************************************************************************
    273          *
    274          * Build datablock for card status
    275          *
    276          *************************************************************************/
    277          

   \                                 In  segment CODE, align 2, keep-with-next
    278          void BuildStatusData(void) {
   \                     BuildStatusData:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
    279              if ( My485UART.TxFirst < TXSIZE_UART -20 ) {
   \   00000008   9100....           LDS     R16, My485UART
   \   0000000C   9110....           LDS     R17, (My485UART + 1)
   \   00000010   370C               CPI     R16, 124
   \   00000012   E021               LDI     R18, 1
   \   00000014   4011               SBCI    R17, 1
   \   00000016   F008               BRCS    $+2+2
   \   00000018   C11C               RJMP    ??BuildStatusData_0
    280                  short ntna;
    281                  My485UART.RxSendReply = true;                               // flag for answering
   \   0000001A   9320....           STS     (My485UART + 672), R18
    282          
    283                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STATUS & 0xff;
   \   0000001E   9100....           LDS     R16, My485UART
   \   00000022   9110....           LDS     R17, (My485UART + 1)
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   9631               ADIW    R31:R30, 1
   \   0000002A   93E0....           STS     My485UART, R30
   \   0000002E   93F0....           STS     (My485UART + 1), R31
   \   00000032   01F8               MOVW    R31:R30, R17:R16
   \   00000034   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000036   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000038   EE09               LDI     R16, 233
   \   0000003A   8300               ST      Z, R16
    284                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STATUS >> 8;
   \   0000003C   9100....           LDS     R16, My485UART
   \   00000040   9110....           LDS     R17, (My485UART + 1)
   \   00000044   01F8               MOVW    R31:R30, R17:R16
   \   00000046   9631               ADIW    R31:R30, 1
   \   00000048   93E0....           STS     My485UART, R30
   \   0000004C   93F0....           STS     (My485UART + 1), R31
   \   00000050   01F8               MOVW    R31:R30, R17:R16
   \   00000052   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000054   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000056   E003               LDI     R16, 3
   \   00000058   8300               ST      Z, R16
    285                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   0000005A   9180....           LDS     R24, My485UART
   \   0000005E   9190....           LDS     R25, (My485UART + 1)
    286                  My485UART.TxFirst += 2;                                                       // two byte length
   \   00000062   9100....           LDS     R16, My485UART
   \   00000066   9110....           LDS     R17, (My485UART + 1)
   \   0000006A   5F0E               SUBI    R16, 254
   \   0000006C   4F1F               SBCI    R17, 255
   \   0000006E   9300....           STS     My485UART, R16
   \   00000072   9310....           STS     (My485UART + 1), R17
    287                  My485UART.pTxBuffer[My485UART.TxFirst++] = 0;                               // channel fixed to 0
   \   00000076   9100....           LDS     R16, My485UART
   \   0000007A   9110....           LDS     R17, (My485UART + 1)
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   9631               ADIW    R31:R30, 1
   \   00000082   93E0....           STS     My485UART, R30
   \   00000086   93F0....           STS     (My485UART + 1), R31
   \   0000008A   01F8               MOVW    R31:R30, R17:R16
   \   0000008C   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   0000008E   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000090   E000               LDI     R16, 0
   \   00000092   8300               ST      Z, R16
    288                  My485UART.pTxBuffer[My485UART.TxFirst++] = DEVICE_IO + UnitID;              // Product ID
   \   00000094   9120....           LDS     R18, My485UART
   \   00000098   9130....           LDS     R19, (My485UART + 1)
   \   0000009C   01F9               MOVW    R31:R30, R19:R18
   \   0000009E   9631               ADIW    R31:R30, 1
   \   000000A0   93E0....           STS     My485UART, R30
   \   000000A4   93F0....           STS     (My485UART + 1), R31
   \   000000A8   9100....           LDS     R16, UnitID
   \   000000AC   5F00               SUBI    R16, 240
   \   000000AE   01F9               MOVW    R31:R30, R19:R18
   \   000000B0   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000000B2   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000000B4   8300               ST      Z, R16
    289                  My485UART.pTxBuffer[My485UART.TxFirst++] = MyAddress();                     // unit adddress
   \   000000B6   91A0....           LDS     R26, My485UART
   \   000000BA   91B0....           LDS     R27, (My485UART + 1)
   \   000000BE   01FD               MOVW    R31:R30, R27:R26
   \   000000C0   9631               ADIW    R31:R30, 1
   \   000000C2   93E0....           STS     My485UART, R30
   \   000000C6   93F0....           STS     (My485UART + 1), R31
   \   000000CA   ........           CALL    MyAddress
   \   000000CE   01FD               MOVW    R31:R30, R27:R26
   \   000000D0   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000000D2   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000000D4   8300               ST      Z, R16
    290                  My485UART.pTxBuffer[My485UART.TxFirst++] = PROG_VERSION;                    // software version */
   \   000000D6   9100....           LDS     R16, My485UART
   \   000000DA   9110....           LDS     R17, (My485UART + 1)
   \   000000DE   01F8               MOVW    R31:R30, R17:R16
   \   000000E0   9631               ADIW    R31:R30, 1
   \   000000E2   93E0....           STS     My485UART, R30
   \   000000E6   93F0....           STS     (My485UART + 1), R31
   \   000000EA   01F8               MOVW    R31:R30, R17:R16
   \   000000EC   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000000EE   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000000F0   E100               LDI     R16, 16
   \   000000F2   8300               ST      Z, R16
    291                  My485UART.pTxBuffer[My485UART.TxFirst++] = COMP_VERSION;                    // cpmpability version
   \   000000F4   9100....           LDS     R16, My485UART
   \   000000F8   9110....           LDS     R17, (My485UART + 1)
   \   000000FC   01F8               MOVW    R31:R30, R17:R16
   \   000000FE   9631               ADIW    R31:R30, 1
   \   00000100   93E0....           STS     My485UART, R30
   \   00000104   93F0....           STS     (My485UART + 1), R31
   \   00000108   01F8               MOVW    R31:R30, R17:R16
   \   0000010A   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   0000010C   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   0000010E   E002               LDI     R16, 2
   \   00000110   8300               ST      Z, R16
    292                  My485UART.pTxBuffer[My485UART.TxFirst++] = STORE_VERSION;                   // cpmpability version
   \   00000112   9100....           LDS     R16, My485UART
   \   00000116   9110....           LDS     R17, (My485UART + 1)
   \   0000011A   01F8               MOVW    R31:R30, R17:R16
   \   0000011C   9631               ADIW    R31:R30, 1
   \   0000011E   93E0....           STS     My485UART, R30
   \   00000122   93F0....           STS     (My485UART + 1), R31
   \   00000126   01F8               MOVW    R31:R30, R17:R16
   \   00000128   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   0000012A   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   0000012C   E003               LDI     R16, 3
   \   0000012E   8300               ST      Z, R16
    293                  My485UART.pTxBuffer[My485UART.TxFirst++] = (RXSIZE_UART & 0xff);            // rx buffer size
   \   00000130   9100....           LDS     R16, My485UART
   \   00000134   9110....           LDS     R17, (My485UART + 1)
   \   00000138   01F8               MOVW    R31:R30, R17:R16
   \   0000013A   9631               ADIW    R31:R30, 1
   \   0000013C   93E0....           STS     My485UART, R30
   \   00000140   93F0....           STS     (My485UART + 1), R31
   \   00000144   01F8               MOVW    R31:R30, R17:R16
   \   00000146   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000148   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   0000014A   E906               LDI     R16, 150
   \   0000014C   8300               ST      Z, R16
    294                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((RXSIZE_UART >> 8) & 0xff);     // rx buffer size
   \   0000014E   9100....           LDS     R16, My485UART
   \   00000152   9110....           LDS     R17, (My485UART + 1)
   \   00000156   01F8               MOVW    R31:R30, R17:R16
   \   00000158   9631               ADIW    R31:R30, 1
   \   0000015A   93E0....           STS     My485UART, R30
   \   0000015E   93F0....           STS     (My485UART + 1), R31
   \   00000162   01F8               MOVW    R31:R30, R17:R16
   \   00000164   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000166   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000168   E000               LDI     R16, 0
   \   0000016A   8300               ST      Z, R16
    295                  My485UART.pTxBuffer[My485UART.TxFirst++] = (TXSIZE_UART & 0xff);            // tx buffer size
   \   0000016C   9100....           LDS     R16, My485UART
   \   00000170   9110....           LDS     R17, (My485UART + 1)
   \   00000174   01F8               MOVW    R31:R30, R17:R16
   \   00000176   9631               ADIW    R31:R30, 1
   \   00000178   93E0....           STS     My485UART, R30
   \   0000017C   93F0....           STS     (My485UART + 1), R31
   \   00000180   01F8               MOVW    R31:R30, R17:R16
   \   00000182   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000184   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000186   E900               LDI     R16, 144
   \   00000188   8300               ST      Z, R16
    296                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);     // tx buffer size
   \   0000018A   9100....           LDS     R16, My485UART
   \   0000018E   9110....           LDS     R17, (My485UART + 1)
   \   00000192   01F8               MOVW    R31:R30, R17:R16
   \   00000194   9631               ADIW    R31:R30, 1
   \   00000196   93E0....           STS     My485UART, R30
   \   0000019A   93F0....           STS     (My485UART + 1), R31
   \   0000019E   01F8               MOVW    R31:R30, R17:R16
   \   000001A0   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000001A2   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000001A4   E001               LDI     R16, 1
   \   000001A6   8300               ST      Z, R16
    297                  My485UART.pTxBuffer[My485UART.TxFirst++] = RestartStatus;                   // restart flag
   \   000001A8   9100....           LDS     R16, My485UART
   \   000001AC   9110....           LDS     R17, (My485UART + 1)
   \   000001B0   01F8               MOVW    R31:R30, R17:R16
   \   000001B2   9631               ADIW    R31:R30, 1
   \   000001B4   93E0....           STS     My485UART, R30
   \   000001B8   93F0....           STS     (My485UART + 1), R31
   \   000001BC   9120....           LDS     R18, RestartStatus
   \   000001C0   01F8               MOVW    R31:R30, R17:R16
   \   000001C2   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000001C4   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000001C6   8320               ST      Z, R18
    298                  My485UART.pTxBuffer[My485UART.TxFirst++] = PROGTYPE_APP;                    // Application program
   \   000001C8   9100....           LDS     R16, My485UART
   \   000001CC   9110....           LDS     R17, (My485UART + 1)
   \   000001D0   01F8               MOVW    R31:R30, R17:R16
   \   000001D2   9631               ADIW    R31:R30, 1
   \   000001D4   93E0....           STS     My485UART, R30
   \   000001D8   93F0....           STS     (My485UART + 1), R31
   \   000001DC   01F8               MOVW    R31:R30, R17:R16
   \   000001DE   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000001E0   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000001E2   E001               LDI     R16, 1
   \   000001E4   8300               ST      Z, R16
    299                  My485UART.pTxBuffer[My485UART.TxFirst++] = RestartCnt & 0xff;               // Unit restart count
   \   000001E6   9120....           LDS     R18, My485UART
   \   000001EA   9130....           LDS     R19, (My485UART + 1)
   \   000001EE   01F9               MOVW    R31:R30, R19:R18
   \   000001F0   9631               ADIW    R31:R30, 1
   \   000001F2   93E0....           STS     My485UART, R30
   \   000001F6   93F0....           STS     (My485UART + 1), R31
   \   000001FA   9140....           LDS     R20, RestartCnt
   \   000001FE   9100....           LDS     R16, (RestartCnt + 1)
   \   00000202   01F9               MOVW    R31:R30, R19:R18
   \   00000204   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000206   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000208   8340               ST      Z, R20
    300                  My485UART.pTxBuffer[My485UART.TxFirst++] = (RestartCnt >> 8 ) & 0xff;       // Unit restart count
   \   0000020A   9120....           LDS     R18, My485UART
   \   0000020E   9130....           LDS     R19, (My485UART + 1)
   \   00000212   01F9               MOVW    R31:R30, R19:R18
   \   00000214   9631               ADIW    R31:R30, 1
   \   00000216   93E0....           STS     My485UART, R30
   \   0000021A   93F0....           STS     (My485UART + 1), R31
   \   0000021E   01F9               MOVW    R31:R30, R19:R18
   \   00000220   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000222   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000224   8300               ST      Z, R16
    301          
    302                  My485UART.pTxBuffer[ntna] =   (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   00000226   ....               LDI     R30, LOW((My485UART + 121))
   \   00000228   ....               LDI     R31, HIGH((My485UART + 121))
   \   0000022A   0FE8               ADD     R30, R24
   \   0000022C   1FF9               ADC     R31, R25
   \   0000022E   9100....           LDS     R16, My485UART
   \   00000232   9110....           LDS     R17, (My485UART + 1)
   \   00000236   1B08               SUB     R16, R24
   \   00000238   5002               SUBI    R16, 2
   \   0000023A   8300               ST      Z, R16
    303                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000023C   91A0....           LDS     R26, My485UART
   \   00000240   91B0....           LDS     R27, (My485UART + 1)
   \   00000244   1BA8               SUB     R26, R24
   \   00000246   0BB9               SBC     R27, R25
   \   00000248   9712               SBIW    R27:R26, 2
   \   0000024A   83B1               STD     Z+1, R27
    304          
    305                  RestartStatus = 0;                                                       // set reset stat to 0 = read
   \   0000024C   E000               LDI     R16, 0
   \   0000024E   9300....           STS     RestartStatus, R16
    306              }
    307          }
   \                     ??BuildStatusData_0:
   \   00000252                      REQUIRE ?Subroutine0
   \   00000252                      REQUIRE RestartCnt
   \   00000252                      ;               // Fall through to label ?Subroutine0
    308          
    309          /*************************************************************************
    310          *
    311          * Build EEPROM data package
    312          *
    313          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    314          void BuildEEPROMData(char *pointer) {
   \                     BuildEEPROMData:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
    315              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000008   9120....           LDS     R18, My485UART
   \   0000000C   9130....           LDS     R19, (My485UART + 1)
   \   00000010   372C               CPI     R18, 124
   \   00000012   E041               LDI     R20, 1
   \   00000014   4031               SBCI    R19, 1
   \   00000016   F008               BRCS    $+2+2
   \   00000018   C081               RJMP    ??BuildEEPROMData_0
    316                  short ntna;
    317                  char channel;
    318                  My485UART.RxSendReply = true;                               // flag for answering
   \   0000001A   9340....           STS     (My485UART + 672), R20
    319          
    320                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_EEPROM_DATA & 0xff;
   \   0000001E   9120....           LDS     R18, My485UART
   \   00000022   9130....           LDS     R19, (My485UART + 1)
   \   00000026   01F9               MOVW    R31:R30, R19:R18
   \   00000028   9631               ADIW    R31:R30, 1
   \   0000002A   93E0....           STS     My485UART, R30
   \   0000002E   93F0....           STS     (My485UART + 1), R31
   \   00000032   01F9               MOVW    R31:R30, R19:R18
   \   00000034   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000036   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000038   E329               LDI     R18, 57
   \   0000003A   8320               ST      Z, R18
    321                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_EEPROM_DATA >> 8;
   \   0000003C   9120....           LDS     R18, My485UART
   \   00000040   9130....           LDS     R19, (My485UART + 1)
   \   00000044   01F9               MOVW    R31:R30, R19:R18
   \   00000046   9631               ADIW    R31:R30, 1
   \   00000048   93E0....           STS     My485UART, R30
   \   0000004C   93F0....           STS     (My485UART + 1), R31
   \   00000050   01F9               MOVW    R31:R30, R19:R18
   \   00000052   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000054   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000056   E024               LDI     R18, 4
   \   00000058   8320               ST      Z, R18
    322                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   0000005A   91A0....           LDS     R26, My485UART
   \   0000005E   91B0....           LDS     R27, (My485UART + 1)
    323                  My485UART.TxFirst += 2;                                      // two byte length
   \   00000062   9120....           LDS     R18, My485UART
   \   00000066   9130....           LDS     R19, (My485UART + 1)
   \   0000006A   5F2E               SUBI    R18, 254
   \   0000006C   4F3F               SBCI    R19, 255
   \   0000006E   9320....           STS     My485UART, R18
   \   00000072   9330....           STS     (My485UART + 1), R19
    324          
    325                  channel = pointer[0];
   \   00000076   01F8               MOVW    R31:R30, R17:R16
   \   00000078   8100               LD      R16, Z
    326                  My485UART.pTxBuffer[My485UART.TxFirst++] = channel; //channel
   \   0000007A   9120....           LDS     R18, My485UART
   \   0000007E   9130....           LDS     R19, (My485UART + 1)
   \   00000082   01F9               MOVW    R31:R30, R19:R18
   \   00000084   9631               ADIW    R31:R30, 1
   \   00000086   93E0....           STS     My485UART, R30
   \   0000008A   93F0....           STS     (My485UART + 1), R31
   \   0000008E   01F9               MOVW    R31:R30, R19:R18
   \   00000090   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000092   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000094   8300               ST      Z, R16
    327          
    328                  ReadEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&My485UART.pTxBuffer[My485UART.TxFirst]);
   \   00000096   E018               LDI     R17, 8
   \   00000098   9F01               MUL     R16, R17
   \   0000009A   01C0               MOVW    R25:R24, R1:R0
   \   0000009C   ....               LDI     R20, LOW((My485UART + 121))
   \   0000009E   ....               LDI     R21, HIGH((My485UART + 121))
   \   000000A0   9100....           LDS     R16, My485UART
   \   000000A4   9110....           LDS     R17, (My485UART + 1)
   \   000000A8   0F40               ADD     R20, R16
   \   000000AA   1F51               ADC     R21, R17
   \   000000AC   E024               LDI     R18, 4
   \   000000AE   0180               MOVW    R17:R16, R1:R0
   \   000000B0   ........           CALL    ReadEEPROMBuffer
    329                  My485UART.TxFirst += sizeof(float);
   \   000000B4   9100....           LDS     R16, My485UART
   \   000000B8   9110....           LDS     R17, (My485UART + 1)
   \   000000BC   5F0C               SUBI    R16, 252
   \   000000BE   4F1F               SBCI    R17, 255
   \   000000C0   9300....           STS     My485UART, R16
   \   000000C4   9310....           STS     (My485UART + 1), R17
    330                  ReadEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&My485UART.pTxBuffer[My485UART.TxFirst]);
   \   000000C8   ....               LDI     R20, LOW((My485UART + 121))
   \   000000CA   ....               LDI     R21, HIGH((My485UART + 121))
   \   000000CC   9100....           LDS     R16, My485UART
   \   000000D0   9110....           LDS     R17, (My485UART + 1)
   \   000000D4   0F40               ADD     R20, R16
   \   000000D6   1F51               ADC     R21, R17
   \   000000D8   E024               LDI     R18, 4
   \   000000DA   9604               ADIW    R25:R24, 4
   \   000000DC   018C               MOVW    R17:R16, R25:R24
   \   000000DE   ........           CALL    ReadEEPROMBuffer
    331                  My485UART.TxFirst += sizeof(float);
   \   000000E2   9100....           LDS     R16, My485UART
   \   000000E6   9110....           LDS     R17, (My485UART + 1)
   \   000000EA   5F0C               SUBI    R16, 252
   \   000000EC   4F1F               SBCI    R17, 255
   \   000000EE   9300....           STS     My485UART, R16
   \   000000F2   9310....           STS     (My485UART + 1), R17
    332          
    333                  My485UART.pTxBuffer[ntna] = (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000F6   ....               LDI     R30, LOW((My485UART + 121))
   \   000000F8   ....               LDI     R31, HIGH((My485UART + 121))
   \   000000FA   0FEA               ADD     R30, R26
   \   000000FC   1FFB               ADC     R31, R27
   \   000000FE   9100....           LDS     R16, My485UART
   \   00000102   9110....           LDS     R17, (My485UART + 1)
   \   00000106   1B0A               SUB     R16, R26
   \   00000108   5002               SUBI    R16, 2
   \   0000010A   8300               ST      Z, R16
    334                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000010C   9180....           LDS     R24, My485UART
   \   00000110   9190....           LDS     R25, (My485UART + 1)
   \   00000114   1B8A               SUB     R24, R26
   \   00000116   0B9B               SBC     R25, R27
   \   00000118   9702               SBIW    R25:R24, 2
   \   0000011A   8391               STD     Z+1, R25
    335              }
    336          }
   \                     ??BuildEEPROMData_0:
   \   0000011C   ....               RJMP    ?Subroutine0
    337          
    338          
    339          /*************************************************************************
    340          *
    341          * Build datablock for Internal AD
    342          *
    343          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    344          void BuildADInt(char *pointer) {
   \                     BuildADInt:
   \   00000000   2E1B               MOV     R1, R27
   \   00000002   2E2A               MOV     R2, R26
   \   00000004   2F39               MOV     R19, R25
   \   00000006   2E08               MOV     R0, R24
    345              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000008   9100....           LDS     R16, My485UART
   \   0000000C   9110....           LDS     R17, (My485UART + 1)
   \   00000010   370C               CPI     R16, 124
   \   00000012   E021               LDI     R18, 1
   \   00000014   4011               SBCI    R17, 1
   \   00000016   F008               BRCS    $+2+2
   \   00000018   C065               RJMP    ??BuildADInt_0
    346                  short ntna, i;
    347                  My485UART.RxSendReply = true;                               // flag for answering
   \   0000001A   9320....           STS     (My485UART + 672), R18
    348          
    349                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_INT_DATA & 0xff;
   \   0000001E   9100....           LDS     R16, My485UART
   \   00000022   9110....           LDS     R17, (My485UART + 1)
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   9631               ADIW    R31:R30, 1
   \   0000002A   93E0....           STS     My485UART, R30
   \   0000002E   93F0....           STS     (My485UART + 1), R31
   \   00000032   01F8               MOVW    R31:R30, R17:R16
   \   00000034   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000036   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000038   E403               LDI     R16, 67
   \   0000003A   8300               ST      Z, R16
    350                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_INT_DATA >> 8;
   \   0000003C   9100....           LDS     R16, My485UART
   \   00000040   9110....           LDS     R17, (My485UART + 1)
   \   00000044   01F8               MOVW    R31:R30, R17:R16
   \   00000046   9631               ADIW    R31:R30, 1
   \   00000048   93E0....           STS     My485UART, R30
   \   0000004C   93F0....           STS     (My485UART + 1), R31
   \   00000050   01F8               MOVW    R31:R30, R17:R16
   \   00000052   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000054   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000056   E004               LDI     R16, 4
   \   00000058   8300               ST      Z, R16
    351                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   0000005A   9140....           LDS     R20, My485UART
   \   0000005E   9150....           LDS     R21, (My485UART + 1)
    352                  My485UART.TxFirst += 2;                                      // two byte length
   \   00000062   9100....           LDS     R16, My485UART
   \   00000066   9110....           LDS     R17, (My485UART + 1)
   \   0000006A   5F0E               SUBI    R16, 254
   \   0000006C   4F1F               SBCI    R17, 255
   \   0000006E   9300....           STS     My485UART, R16
   \   00000072   9310....           STS     (My485UART + 1), R17
    353          
    354                  for ( i = 0; i < 3; i++ ) {
   \   00000076   ....               LDI     R30, LOW(ADInt)
   \   00000078   ....               LDI     R31, (ADInt) >> 8
   \   0000007A   E003               LDI     R16, 3
    355                      My485UART.pTxBuffer[My485UART.TxFirst++] = ADInt.Result[i];
   \                     ??BuildADInt_1:
   \   0000007C   9160....           LDS     R22, My485UART
   \   00000080   9170....           LDS     R23, (My485UART + 1)
   \   00000084   01CB               MOVW    R25:R24, R23:R22
   \   00000086   9601               ADIW    R25:R24, 1
   \   00000088   9380....           STS     My485UART, R24
   \   0000008C   9390....           STS     (My485UART + 1), R25
   \   00000090   8110               LD      R17, Z
   \   00000092   8121               LDD     R18, Z+1
   \   00000094   01DB               MOVW    R27:R26, R23:R22
   \   00000096   ....               SUBI    R26, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000098   ....               SBCI    R27, HIGH((-(My485UART + 121) & 0xFFFF))
   \   0000009A   931C               ST      X, R17
    356                      My485UART.pTxBuffer[My485UART.TxFirst++] = ADInt.Result[i] >> 8;   // ADresult
   \   0000009C   9160....           LDS     R22, My485UART
   \   000000A0   9170....           LDS     R23, (My485UART + 1)
   \   000000A4   01CB               MOVW    R25:R24, R23:R22
   \   000000A6   9601               ADIW    R25:R24, 1
   \   000000A8   9380....           STS     My485UART, R24
   \   000000AC   9390....           STS     (My485UART + 1), R25
   \   000000B0   01DB               MOVW    R27:R26, R23:R22
   \   000000B2   ....               SUBI    R26, LOW((-(My485UART + 121) & 0xFFFF))
   \   000000B4   ....               SBCI    R27, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000000B6   932C               ST      X, R18
    357                  }
   \   000000B8   9632               ADIW    R31:R30, 2
   \   000000BA   950A               DEC     R16
   \   000000BC   F6F9               BRNE    ??BuildADInt_1
    358          
    359                  My485UART.pTxBuffer[ntna] = (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000BE   ....               LDI     R30, LOW((My485UART + 121))
   \   000000C0   ....               LDI     R31, HIGH((My485UART + 121))
   \   000000C2   0FE4               ADD     R30, R20
   \   000000C4   1FF5               ADC     R31, R21
   \   000000C6   9100....           LDS     R16, My485UART
   \   000000CA   9110....           LDS     R17, (My485UART + 1)
   \   000000CE   1B04               SUB     R16, R20
   \   000000D0   5002               SUBI    R16, 2
   \   000000D2   8300               ST      Z, R16
    360                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000D4   9180....           LDS     R24, My485UART
   \   000000D8   9190....           LDS     R25, (My485UART + 1)
   \   000000DC   1B84               SUB     R24, R20
   \   000000DE   0B95               SBC     R25, R21
   \   000000E0   9702               SBIW    R25:R24, 2
   \   000000E2   8391               STD     Z+1, R25
    361              }
    362          
    363          }
   \                     ??BuildADInt_0:
   \   000000E4   2D80               MOV     R24, R0
   \   000000E6   2F93               MOV     R25, R19
   \   000000E8   2DA2               MOV     R26, R2
   \   000000EA   2DB1               MOV     R27, R1
   \   000000EC   9508               RET
    364          
    365          
    366          /*************************************************************************
    367          *
    368          * Build setup data package for AN-ZBHART
    369          *
    370          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    371          void BuildHartSetup( char *pointer) {
   \                     BuildHartSetup:
   \   00000000   2F79               MOV     R23, R25
   \   00000002   2E08               MOV     R0, R24
    372              if ( My485UART.TxFirst < TXSIZE_UART - 20) {
   \   00000004   9100....           LDS     R16, My485UART
   \   00000008   9110....           LDS     R17, (My485UART + 1)
   \   0000000C   370C               CPI     R16, 124
   \   0000000E   E021               LDI     R18, 1
   \   00000010   4011               SBCI    R17, 1
   \   00000012   F008               BRCS    $+2+2
   \   00000014   C061               RJMP    ??BuildHartSetup_0
    373                  short ntna;
    374                  My485UART.RxSendReply = true;                               // flag for answering
   \   00000016   9320....           STS     (My485UART + 672), R18
    375          
    376                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_SETUP & 0xff;
   \   0000001A   9100....           LDS     R16, My485UART
   \   0000001E   9110....           LDS     R17, (My485UART + 1)
   \   00000022   01F8               MOVW    R31:R30, R17:R16
   \   00000024   9631               ADIW    R31:R30, 1
   \   00000026   93E0....           STS     My485UART, R30
   \   0000002A   93F0....           STS     (My485UART + 1), R31
   \   0000002E   01F8               MOVW    R31:R30, R17:R16
   \   00000030   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000032   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000034   EE0D               LDI     R16, 237
   \   00000036   8300               ST      Z, R16
    377                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_SETUP >> 8;
   \   00000038   9100....           LDS     R16, My485UART
   \   0000003C   9110....           LDS     R17, (My485UART + 1)
   \   00000040   01F8               MOVW    R31:R30, R17:R16
   \   00000042   9631               ADIW    R31:R30, 1
   \   00000044   93E0....           STS     My485UART, R30
   \   00000048   93F0....           STS     (My485UART + 1), R31
   \   0000004C   01F8               MOVW    R31:R30, R17:R16
   \   0000004E   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000050   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000052   E004               LDI     R16, 4
   \   00000054   8300               ST      Z, R16
    378                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   00000056   9120....           LDS     R18, My485UART
   \   0000005A   9130....           LDS     R19, (My485UART + 1)
    379                  My485UART.TxFirst += 2;                                      // two byte length
   \   0000005E   9100....           LDS     R16, My485UART
   \   00000062   9110....           LDS     R17, (My485UART + 1)
   \   00000066   5F0E               SUBI    R16, 254
   \   00000068   4F1F               SBCI    R17, 255
   \   0000006A   9300....           STS     My485UART, R16
   \   0000006E   9310....           STS     (My485UART + 1), R17
    380          
    381                  My485UART.pTxBuffer[My485UART.TxFirst++] = TData.Hart.PortUsed & 0xff;
   \   00000072   9140....           LDS     R20, My485UART
   \   00000076   9150....           LDS     R21, (My485UART + 1)
   \   0000007A   01FA               MOVW    R31:R30, R21:R20
   \   0000007C   9631               ADIW    R31:R30, 1
   \   0000007E   93E0....           STS     My485UART, R30
   \   00000082   93F0....           STS     (My485UART + 1), R31
   \   00000086   9160....           LDS     R22, (TData + 144)
   \   0000008A   9100....           LDS     R16, (TData + 145)
   \   0000008E   01FA               MOVW    R31:R30, R21:R20
   \   00000090   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000092   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000094   8360               ST      Z, R22
    382                  My485UART.pTxBuffer[My485UART.TxFirst++] = (TData.Hart.PortUsed >> 8) & 0xff;
   \   00000096   9140....           LDS     R20, My485UART
   \   0000009A   9150....           LDS     R21, (My485UART + 1)
   \   0000009E   01FA               MOVW    R31:R30, R21:R20
   \   000000A0   9631               ADIW    R31:R30, 1
   \   000000A2   93E0....           STS     My485UART, R30
   \   000000A6   93F0....           STS     (My485UART + 1), R31
   \   000000AA   01FA               MOVW    R31:R30, R21:R20
   \   000000AC   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000000AE   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000000B0   8300               ST      Z, R16
    383          
    384                  My485UART.pTxBuffer[ntna] =  (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000B2   ....               LDI     R30, LOW((My485UART + 121))
   \   000000B4   ....               LDI     R31, HIGH((My485UART + 121))
   \   000000B6   0FE2               ADD     R30, R18
   \   000000B8   1FF3               ADC     R31, R19
   \   000000BA   9100....           LDS     R16, My485UART
   \   000000BE   9110....           LDS     R17, (My485UART + 1)
   \   000000C2   1B02               SUB     R16, R18
   \   000000C4   5002               SUBI    R16, 2
   \   000000C6   8300               ST      Z, R16
    385                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000C8   9180....           LDS     R24, My485UART
   \   000000CC   9190....           LDS     R25, (My485UART + 1)
   \   000000D0   1B82               SUB     R24, R18
   \   000000D2   0B93               SBC     R25, R19
   \   000000D4   9702               SBIW    R25:R24, 2
   \   000000D6   8391               STD     Z+1, R25
    386              }
    387          }
   \                     ??BuildHartSetup_0:
   \   000000D8   2D80               MOV     R24, R0
   \   000000DA   2F97               MOV     R25, R23
   \   000000DC   9508               RET
    388          
    389          /*************************************************************************
    390          *
    391          * Build filter data package for AN-ZBHART
    392          *
    393          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    394          void BuildHartFilter( char *pointer) {
   \                     BuildHartFilter:
   \   00000000   2F39               MOV     R19, R25
   \   00000002   2E08               MOV     R0, R24
    395              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000004   9100....           LDS     R16, My485UART
   \   00000008   9110....           LDS     R17, (My485UART + 1)
   \   0000000C   370C               CPI     R16, 124
   \   0000000E   E021               LDI     R18, 1
   \   00000010   4011               SBCI    R17, 1
   \   00000012   F008               BRCS    $+2+2
   \   00000014   C058               RJMP    ??BuildHartFilter_0
    396                  char port;
    397                  short ntna;
    398                  My485UART.RxSendReply = true;                               // flag for answering
   \   00000016   9320....           STS     (My485UART + 672), R18
    399          
    400                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_FILTER & 0xff;
   \   0000001A   9100....           LDS     R16, My485UART
   \   0000001E   9110....           LDS     R17, (My485UART + 1)
   \   00000022   01F8               MOVW    R31:R30, R17:R16
   \   00000024   9631               ADIW    R31:R30, 1
   \   00000026   93E0....           STS     My485UART, R30
   \   0000002A   93F0....           STS     (My485UART + 1), R31
   \   0000002E   01F8               MOVW    R31:R30, R17:R16
   \   00000030   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000032   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000034   8320               ST      Z, R18
    401                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_HART_FILTER >> 8;
   \   00000036   9100....           LDS     R16, My485UART
   \   0000003A   9110....           LDS     R17, (My485UART + 1)
   \   0000003E   01F8               MOVW    R31:R30, R17:R16
   \   00000040   9631               ADIW    R31:R30, 1
   \   00000042   93E0....           STS     My485UART, R30
   \   00000046   93F0....           STS     (My485UART + 1), R31
   \   0000004A   01F8               MOVW    R31:R30, R17:R16
   \   0000004C   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   0000004E   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000050   E005               LDI     R16, 5
   \   00000052   8300               ST      Z, R16
    402                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   00000054   9140....           LDS     R20, My485UART
   \   00000058   9150....           LDS     R21, (My485UART + 1)
    403                  My485UART.TxFirst += 2;                                      // two byte length
   \   0000005C   9100....           LDS     R16, My485UART
   \   00000060   9110....           LDS     R17, (My485UART + 1)
   \   00000064   5F0E               SUBI    R16, 254
   \   00000066   4F1F               SBCI    R17, 255
   \   00000068   9300....           STS     My485UART, R16
   \   0000006C   9310....           STS     (My485UART + 1), R17
    404          
    405                  for ( port = 0; port < 12; port++ ) {
   \   00000070   E020               LDI     R18, 0
   \   00000072   E00C               LDI     R16, 12
    406                      My485UART.pTxBuffer[My485UART.TxFirst++] = TData.Hart.Filter[port];
   \                     ??BuildHartFilter_1:
   \   00000074   9160....           LDS     R22, My485UART
   \   00000078   9170....           LDS     R23, (My485UART + 1)
   \   0000007C   01FB               MOVW    R31:R30, R23:R22
   \   0000007E   9631               ADIW    R31:R30, 1
   \   00000080   93E0....           STS     My485UART, R30
   \   00000084   93F0....           STS     (My485UART + 1), R31
   \   00000088   E0F0               LDI     R31, 0
   \   0000008A   2FE2               MOV     R30, R18
   \   0000008C   ....               SUBI    R30, LOW((-(TData + 160) & 0xFFFF))
   \   0000008E   ....               SBCI    R31, HIGH((-(TData + 160) & 0xFFFF))
   \   00000090   8110               LD      R17, Z
   \   00000092   01FB               MOVW    R31:R30, R23:R22
   \   00000094   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000096   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000098   8310               ST      Z, R17
    407                  }
   \   0000009A   9523               INC     R18
   \   0000009C   950A               DEC     R16
   \   0000009E   F751               BRNE    ??BuildHartFilter_1
    408          
    409                  My485UART.pTxBuffer[ntna] =  (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000A0   ....               LDI     R30, LOW((My485UART + 121))
   \   000000A2   ....               LDI     R31, HIGH((My485UART + 121))
   \   000000A4   0FE4               ADD     R30, R20
   \   000000A6   1FF5               ADC     R31, R21
   \   000000A8   9100....           LDS     R16, My485UART
   \   000000AC   9110....           LDS     R17, (My485UART + 1)
   \   000000B0   1B04               SUB     R16, R20
   \   000000B2   5002               SUBI    R16, 2
   \   000000B4   8300               ST      Z, R16
    410                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000B6   9180....           LDS     R24, My485UART
   \   000000BA   9190....           LDS     R25, (My485UART + 1)
   \   000000BE   1B84               SUB     R24, R20
   \   000000C0   0B95               SBC     R25, R21
   \   000000C2   9702               SBIW    R25:R24, 2
   \   000000C4   8391               STD     Z+1, R25
    411              }
    412          }
   \                     ??BuildHartFilter_0:
   \   000000C6   2D80               MOV     R24, R0
   \   000000C8   2F93               MOV     R25, R19
   \   000000CA   9508               RET
    413          
    414          /*************************************************************************
    415          *
    416          * Build datablock for Hart (Hart)
    417          *
    418          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    419          void BuildMDataHart(void) {
   \                     BuildMDataHart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   2F38               MOV     R19, R24
    420              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000008   9100....           LDS     R16, My485UART
   \   0000000C   9110....           LDS     R17, (My485UART + 1)
   \   00000010   370C               CPI     R16, 124
   \   00000012   E021               LDI     R18, 1
   \   00000014   4011               SBCI    R17, 1
   \   00000016   F008               BRCS    $+2+2
   \   00000018   C05D               RJMP    ??BuildMDataHart_0
    421                  short Index        = 11; // // Add data after the heading, Heading size is 11
    422                  char *Buf          = My485UART.pTxBuffer;
    423                  My485UART.RxSendReply = true;                               // flag for answering
   \   0000001A   9320....           STS     (My485UART + 672), R18
    424                  Buf[Index++] = CMD_REP_HART_MDATA & 0xff;
   \   0000001E   ....               LDI     R20, LOW((My485UART + 132))
   \   00000020   ....               LDI     R21, HIGH((My485UART + 132))
   \   00000022   01FA               MOVW    R31:R30, R21:R20
   \   00000024   E00B               LDI     R16, 11
   \   00000026   8300               ST      Z, R16
    425                  Buf[Index++] = CMD_REP_HART_MDATA >> 8;
   \   00000028   E005               LDI     R16, 5
   \   0000002A   8301               STD     Z+1, R16
    426                  short ntna = Index;                                  /* remember index */
    427                  Index  += 2;                                      // two byte length
    428          
    429                  Buf[Index++] = (RestartStatus << 4);    // Add restart status
   \   0000002C   9100....           LDS     R16, RestartStatus
   \   00000030   9502               SWAP    R16
   \   00000032   7F00               ANDI    R16, 0xF0
   \   00000034   8304               STD     Z+4, R16
   \   00000036   E100               LDI     R16, 16
   \   00000038   E010               LDI     R17, 0
    430                  // Hart PV
    431                  for ( short i = 0; i < 12; i++ ) {
   \   0000003A   ....               LDI     R24, LOW((My485UART + 141))
   \   0000003C   ....               LDI     R25, HIGH((My485UART + 141))
   \   0000003E   ....               LDI     R30, LOW((TData + 172))
   \   00000040   ....               LDI     R31, HIGH((TData + 172))
   \   00000042   E02C               LDI     R18, 12
    432                      *((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][0];   // Hart 1st
   \                     ??BuildMDataHart_1:
   \   00000044   01BF               MOVW    R23:R22, R31:R30
   \   00000046   5A6C               SUBI    R22, 172
   \   00000048   4070               SBCI    R23, 0
   \   0000004A   01DB               MOVW    R27:R26, R23:R22
   \   0000004C   900D               LD      R0, X+
   \   0000004E   901C               LD      R1, X
   \   00000050   01DC               MOVW    R27:R26, R25:R24
   \   00000052   9714               SBIW    R27:R26, 4
   \   00000054   920D               ST      X+, R0
   \   00000056   921C               ST      X, R1
    433                      Index += sizeof(unsigned short);
    434                      *((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][1];   // Hart 2nd
   \   00000058   01DB               MOVW    R27:R26, R23:R22
   \   0000005A   9612               ADIW    R27:R26, 2
   \   0000005C   916D               LD      R22, X+
   \   0000005E   917C               LD      R23, X
   \   00000060   01DC               MOVW    R27:R26, R25:R24
   \   00000062   9712               SBIW    R27:R26, 2
   \   00000064   936D               ST      X+, R22
   \   00000066   937C               ST      X, R23
    435                      Index += sizeof(unsigned short);
    436                      //hart_channel_lock(&_hart_channels[i]);
    437                      *((float *)&Buf[Index]) = TData.Hart.Distance[i];       // Hart 1st
   \   00000068   01BF               MOVW    R23:R22, R31:R30
   \   0000006A   5A60               SUBI    R22, 160
   \   0000006C   4F7F               SBCI    R23, 255
   \   0000006E   01DB               MOVW    R27:R26, R23:R22
   \   00000070   900D               LD      R0, X+
   \   00000072   901D               LD      R1, X+
   \   00000074   902D               LD      R2, X+
   \   00000076   903C               LD      R3, X
   \   00000078   01DC               MOVW    R27:R26, R25:R24
   \   0000007A   920D               ST      X+, R0
   \   0000007C   921D               ST      X+, R1
   \   0000007E   922D               ST      X+, R2
   \   00000080   923C               ST      X, R3
    438                      Index += sizeof(float);
    439                      *((float *)&Buf[Index]) = TData.Hart.Level[i];          // Hart 2nd
   \   00000082   01DB               MOVW    R27:R26, R23:R22
   \   00000084   96D0               ADIW    R27:R26, 48
   \   00000086   900D               LD      R0, X+
   \   00000088   901D               LD      R1, X+
   \   0000008A   902D               LD      R2, X+
   \   0000008C   903C               LD      R3, X
   \   0000008E   01DC               MOVW    R27:R26, R25:R24
   \   00000090   9614               ADIW    R27:R26, 4
   \   00000092   920D               ST      X+, R0
   \   00000094   921D               ST      X+, R1
   \   00000096   922D               ST      X+, R2
   \   00000098   923C               ST      X, R3
    440                      Index += sizeof(float);
    441                      *((float *)&Buf[Index]) = TData.Hart.ADCurrent[i];      //*TData.Hart.Gain[i] - TData.Hart.Offset[i];   // Measured current via onboard ADC
   \   0000009A   8000               LD      R0, Z
   \   0000009C   8011               LDD     R1, Z+1
   \   0000009E   8022               LDD     R2, Z+2
   \   000000A0   8033               LDD     R3, Z+3
   \   000000A2   01DC               MOVW    R27:R26, R25:R24
   \   000000A4   9618               ADIW    R27:R26, 8
   \   000000A6   920D               ST      X+, R0
   \   000000A8   921D               ST      X+, R1
   \   000000AA   922D               ST      X+, R2
   \   000000AC   923C               ST      X, R3
    442                      Index += sizeof(float);
   \   000000AE   5F00               SUBI    R16, 240
   \   000000B0   4F1F               SBCI    R17, 255
    443                      //*((float *)&Buf[Index]) = TData.Hart.HartCurrent[i];    // mA current from the device
    444                      //Index += sizeof(float);
    445                      //hart_channel_unlock(&_hart_channels[i]);
    446                  }
   \   000000B2   9634               ADIW    R31:R30, 4
   \   000000B4   9640               ADIW    R25:R24, 16
   \   000000B6   952A               DEC     R18
   \   000000B8   F629               BRNE    ??BuildMDataHart_1
    447                  Buf[ntna] = (Index - ntna - 2) & 0xff;      // length of data block lb
   \   000000BA   2F20               MOV     R18, R16
   \   000000BC   502F               SUBI    R18, 15
   \   000000BE   01FA               MOVW    R31:R30, R21:R20
   \   000000C0   8322               STD     Z+2, R18
    448                  Buf[ntna + 1] = ((Index - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000C2   01F8               MOVW    R31:R30, R17:R16
   \   000000C4   973F               SBIW    R31:R30, 15
   \   000000C6   2F2F               MOV     R18, R31
   \   000000C8   01FA               MOVW    R31:R30, R21:R20
   \   000000CA   8323               STD     Z+3, R18
    449                  My485UART.TxFirst = Index; // Add data after the heading
   \   000000CC   9300....           STS     My485UART, R16
   \   000000D0   9310....           STS     (My485UART + 1), R17
    450              }
    451          
    452          
    453          }
   \                     ??BuildMDataHart_0:
   \   000000D4   2F83               MOV     R24, R19
   \   000000D6   ....               RJMP    ??Subroutine1_0
    454          
    455          
    456          /*************************************************************************
    457          *
    458          * Build datablock for Stack status
    459          *
    460          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    461          void BuildStackStatus( char *pointer) {
   \                     BuildStackStatus:
   \   00000000   01AC               MOVW    R21:R20, R25:R24
    462              if ( My485UART.TxFirst < TXSIZE_UART - 20 ) {
   \   00000002   9100....           LDS     R16, My485UART
   \   00000006   9110....           LDS     R17, (My485UART + 1)
   \   0000000A   370C               CPI     R16, 124
   \   0000000C   E021               LDI     R18, 1
   \   0000000E   4011               SBCI    R17, 1
   \   00000010   F008               BRCS    $+2+2
   \   00000012   C0BD               RJMP    ??BuildStackStatus_0
    463                  short ntna, stack;
    464                  My485UART.RxSendReply = true;                               // flag for answering
   \   00000014   9320....           STS     (My485UART + 672), R18
    465          
    466                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STACKSTATUS & 0xff;
   \   00000018   9100....           LDS     R16, My485UART
   \   0000001C   9110....           LDS     R17, (My485UART + 1)
   \   00000020   01F8               MOVW    R31:R30, R17:R16
   \   00000022   9631               ADIW    R31:R30, 1
   \   00000024   93E0....           STS     My485UART, R30
   \   00000028   93F0....           STS     (My485UART + 1), R31
   \   0000002C   01F8               MOVW    R31:R30, R17:R16
   \   0000002E   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000030   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000032   E707               LDI     R16, 119
   \   00000034   8300               ST      Z, R16
    467                  My485UART.pTxBuffer[My485UART.TxFirst++] = CMD_REP_STACKSTATUS >> 8;
   \   00000036   9100....           LDS     R16, My485UART
   \   0000003A   9110....           LDS     R17, (My485UART + 1)
   \   0000003E   01F8               MOVW    R31:R30, R17:R16
   \   00000040   9631               ADIW    R31:R30, 1
   \   00000042   93E0....           STS     My485UART, R30
   \   00000046   93F0....           STS     (My485UART + 1), R31
   \   0000004A   01F8               MOVW    R31:R30, R17:R16
   \   0000004C   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   0000004E   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000050   E007               LDI     R16, 7
   \   00000052   8300               ST      Z, R16
    468                  ntna = My485UART.TxFirst;                                    /* remember index */
   \   00000054   9120....           LDS     R18, My485UART
   \   00000058   9130....           LDS     R19, (My485UART + 1)
    469                  My485UART.TxFirst += 2;                                      // two byte length
   \   0000005C   9100....           LDS     R16, My485UART
   \   00000060   9110....           LDS     R17, (My485UART + 1)
   \   00000064   5F0E               SUBI    R16, 254
   \   00000066   4F1F               SBCI    R17, 255
   \   00000068   9300....           STS     My485UART, R16
   \   0000006C   9310....           STS     (My485UART + 1), R17
    470          
    471                  stack = OS_GetStackSpace(&TCB_USART0);                            // USART 0
    472                  My485UART.pTxBuffer[My485UART.TxFirst++] = (stack & 0xff);
   \   00000070   9100....           LDS     R16, My485UART
   \   00000074   9110....           LDS     R17, (My485UART + 1)
   \   00000078   01F8               MOVW    R31:R30, R17:R16
   \   0000007A   9631               ADIW    R31:R30, 1
   \   0000007C   93E0....           STS     My485UART, R30
   \   00000080   93F0....           STS     (My485UART + 1), R31
   \   00000084   01F8               MOVW    R31:R30, R17:R16
   \   00000086   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000088   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   0000008A   E000               LDI     R16, 0
   \   0000008C   8300               ST      Z, R16
    473                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((stack >> 8) & 0xff);
   \   0000008E   9100....           LDS     R16, My485UART
   \   00000092   9110....           LDS     R17, (My485UART + 1)
   \   00000096   01F8               MOVW    R31:R30, R17:R16
   \   00000098   9631               ADIW    R31:R30, 1
   \   0000009A   93E0....           STS     My485UART, R30
   \   0000009E   93F0....           STS     (My485UART + 1), R31
   \   000000A2   01F8               MOVW    R31:R30, R17:R16
   \   000000A4   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000000A6   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000000A8   E000               LDI     R16, 0
   \   000000AA   8300               ST      Z, R16
    474          
    475                  stack = OS_GetStackSpace(&TCB_WATCHDOG);                            // watchdog
    476                  My485UART.pTxBuffer[My485UART.TxFirst++] = (stack & 0xff);
   \   000000AC   9100....           LDS     R16, My485UART
   \   000000B0   9110....           LDS     R17, (My485UART + 1)
   \   000000B4   01F8               MOVW    R31:R30, R17:R16
   \   000000B6   9631               ADIW    R31:R30, 1
   \   000000B8   93E0....           STS     My485UART, R30
   \   000000BC   93F0....           STS     (My485UART + 1), R31
   \   000000C0   01F8               MOVW    R31:R30, R17:R16
   \   000000C2   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000000C4   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000000C6   E000               LDI     R16, 0
   \   000000C8   8300               ST      Z, R16
    477                  My485UART.pTxBuffer[My485UART.TxFirst++] = ((stack >> 8) & 0xff);
   \   000000CA   9100....           LDS     R16, My485UART
   \   000000CE   9110....           LDS     R17, (My485UART + 1)
   \   000000D2   01F8               MOVW    R31:R30, R17:R16
   \   000000D4   9631               ADIW    R31:R30, 1
   \   000000D6   93E0....           STS     My485UART, R30
   \   000000DA   93F0....           STS     (My485UART + 1), R31
   \   000000DE   01F8               MOVW    R31:R30, R17:R16
   \   000000E0   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   000000E2   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   000000E4   E000               LDI     R16, 0
   \   000000E6   8300               ST      Z, R16
    478                  switch ( UnitID ) {
   \   000000E8   9100....           LDS     R16, UnitID
   \   000000EC   3003               CPI     R16, 3
   \   000000EE   F5E1               BRNE    ??BuildStackStatus_1
    479                  case AN_ZB485 :
    480                  case AN_ZBANA :
    481                      break;
    482                  case AN_ZBHART :
    483                      stack = OS_GetStackSpace(&TCB_AD7715);                            // AD handling
    484                      My485UART.pTxBuffer[My485UART.TxFirst++] = (stack & 0xff);
   \   000000F0   9100....           LDS     R16, My485UART
   \   000000F4   9110....           LDS     R17, (My485UART + 1)
   \   000000F8   01F8               MOVW    R31:R30, R17:R16
   \   000000FA   9631               ADIW    R31:R30, 1
   \   000000FC   93E0....           STS     My485UART, R30
   \   00000100   93F0....           STS     (My485UART + 1), R31
   \   00000104   01F8               MOVW    R31:R30, R17:R16
   \   00000106   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000108   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   0000010A   E000               LDI     R16, 0
   \   0000010C   8300               ST      Z, R16
    485                      My485UART.pTxBuffer[My485UART.TxFirst++] = ((stack >> 8) & 0xff);
   \   0000010E   9100....           LDS     R16, My485UART
   \   00000112   9110....           LDS     R17, (My485UART + 1)
   \   00000116   01F8               MOVW    R31:R30, R17:R16
   \   00000118   9631               ADIW    R31:R30, 1
   \   0000011A   93E0....           STS     My485UART, R30
   \   0000011E   93F0....           STS     (My485UART + 1), R31
   \   00000122   01F8               MOVW    R31:R30, R17:R16
   \   00000124   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000126   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000128   E000               LDI     R16, 0
   \   0000012A   8300               ST      Z, R16
    486                      My485UART.pTxBuffer[My485UART.TxFirst++] = 0;
   \   0000012C   9100....           LDS     R16, My485UART
   \   00000130   9110....           LDS     R17, (My485UART + 1)
   \   00000134   01F8               MOVW    R31:R30, R17:R16
   \   00000136   9631               ADIW    R31:R30, 1
   \   00000138   93E0....           STS     My485UART, R30
   \   0000013C   93F0....           STS     (My485UART + 1), R31
   \   00000140   01F8               MOVW    R31:R30, R17:R16
   \   00000142   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000144   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000146   E000               LDI     R16, 0
   \   00000148   8300               ST      Z, R16
    487                      My485UART.pTxBuffer[My485UART.TxFirst++] = 0;
   \   0000014A   9100....           LDS     R16, My485UART
   \   0000014E   9110....           LDS     R17, (My485UART + 1)
   \   00000152   01F8               MOVW    R31:R30, R17:R16
   \   00000154   9631               ADIW    R31:R30, 1
   \   00000156   93E0....           STS     My485UART, R30
   \   0000015A   93F0....           STS     (My485UART + 1), R31
   \   0000015E   01F8               MOVW    R31:R30, R17:R16
   \   00000160   ....               SUBI    R30, LOW((-(My485UART + 121) & 0xFFFF))
   \   00000162   ....               SBCI    R31, HIGH((-(My485UART + 121) & 0xFFFF))
   \   00000164   E000               LDI     R16, 0
   \   00000166   8300               ST      Z, R16
    488                      break;
    489                  }
    490          
    491                  My485UART.pTxBuffer[ntna] = (My485UART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \                     ??BuildStackStatus_1:
   \   00000168   ....               LDI     R30, LOW((My485UART + 121))
   \   0000016A   ....               LDI     R31, HIGH((My485UART + 121))
   \   0000016C   0FE2               ADD     R30, R18
   \   0000016E   1FF3               ADC     R31, R19
   \   00000170   9100....           LDS     R16, My485UART
   \   00000174   9110....           LDS     R17, (My485UART + 1)
   \   00000178   1B02               SUB     R16, R18
   \   0000017A   5002               SUBI    R16, 2
   \   0000017C   8300               ST      Z, R16
    492                  My485UART.pTxBuffer[ntna + 1] = ((My485UART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000017E   9180....           LDS     R24, My485UART
   \   00000182   9190....           LDS     R25, (My485UART + 1)
   \   00000186   1B82               SUB     R24, R18
   \   00000188   0B93               SBC     R25, R19
   \   0000018A   9702               SBIW    R25:R24, 2
   \   0000018C   8391               STD     Z+1, R25
    493              }
    494          
    495          }
   \                     ??BuildStackStatus_0:
   \   0000018E   01CA               MOVW    R25:R24, R21:R20
   \   00000190   9508               RET
    496          
    497          //////////////////////////////////////////////////////////////////////////////
    498          // Receiving data to IO module here
    499          /////////////////////////////////////////////////////////////////////////////
    500          
    501          /*************************************************************************
    502          *
    503          * Receive Command to Reset the EEPROM
    504          *
    505          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    506          void GetResetEEPROM(void) {
   \                     GetResetEEPROM:
    507          
    508              EEPROMReset();
   \   00000000   ........           JMP     EEPROMReset
    509          }
    510          
    511          
    512          /*************************************************************************
    513          *
    514          * Receive Command to go to the bootloader program
    515          *
    516          *************************************************************************/
    517          extern volatile char RestartCmd;

   \                                 In  segment CODE, align 2, keep-with-next
    518          void GetGotoBootloader( char *pointer) {
   \                     GetGotoBootloader:
    519          
    520              void (*BootApp)(void) = (void(*)())0xF000;
    521              while ( (EECR & 1 << EEPE) != 0 ) //chech if EEPROM is ready
   \                     ??GetGotoBootloader_0:
   \   00000000   99F9               SBIC    0x1F, 0x01
   \   00000002   CFFE               RJMP    ??GetGotoBootloader_0
    522              ;
    523              EEARL = (0x0fff & 0xff);
   \   00000004   EF0F               LDI     R16, 255
   \   00000006   BD01               OUT     0x21, R16
    524              EEARH = (0x0fff >> 8);
   \   00000008   E00F               LDI     R16, 15
   \   0000000A   BD02               OUT     0x22, R16
    525              EEDR = 0x00;
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   BD00               OUT     0x20, R16
    526              EECR |= (1 << EEMPE);
   \   00000010   9AFA               SBI     0x1F, 0x02
    527              EECR |= (1 << EEPE);
   \   00000012   9AF9               SBI     0x1F, 0x01
    528              while ( EECR & (1 << EEPE) );
   \                     ??GetGotoBootloader_1:
   \   00000014   99F9               SBIC    0x1F, 0x01
   \   00000016   CFFE               RJMP    ??GetGotoBootloader_1
    529              //RestartCmd = 1;
    530              BootApp();
   \   00000018   940CF000           JMP     0x1E000
   \   0000001C                      REQUIRE _A_EECR
   \   0000001C                      REQUIRE _A_EEAR
   \   0000001C                      REQUIRE _A_EEDR
    531              //OS_Error(ZB_REBOOT);
    532          }
    533          
    534          /*************************************************************************
    535          *
    536          * Receive EEPROM data
    537          *
    538          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    539          void GetEEPROMData( char *pointer) {
   \                     GetEEPROMData:
   \   00000000   92BA               ST      -Y, R11
   \   00000002   92AA               ST      -Y, R10
   \   00000004   929A               ST      -Y, R9
   \   00000006   928A               ST      -Y, R8
   \   00000008   925A               ST      -Y, R5
   \   0000000A   93BA               ST      -Y, R27
   \   0000000C   93AA               ST      -Y, R26
   \   0000000E   939A               ST      -Y, R25
   \   00000010   938A               ST      -Y, R24
   \   00000012                      REQUIRE ?Register_R5_is_cg_reg
   \   00000012                      REQUIRE ?Register_R8_is_cg_reg
   \   00000012                      REQUIRE ?Register_R9_is_cg_reg
   \   00000012                      REQUIRE ?Register_R10_is_cg_reg
   \   00000012                      REQUIRE ?Register_R11_is_cg_reg
   \   00000012   0158               MOVW    R11:R10, R17:R16
    540          
    541              char channel;
    542              OS_U32 t0;
    543          
    544              channel = pointer[0];
   \   00000014   01F8               MOVW    R31:R30, R17:R16
   \   00000016   8100               LD      R16, Z
    545              switch ( UnitID ) {
   \   00000018   9110....           LDS     R17, UnitID
   \   0000001C   3013               CPI     R17, 3
   \   0000001E   F4F9               BRNE    ??GetEEPROMData_0
    546              case AN_ZBANA:
    547                  break;
    548              case AN_ZBHART:
    549                  if ( channel >= 0x80 ) {
   \   00000020   3800               CPI     R16, 128
   \   00000022   F0E8               BRCS    ??GetEEPROMData_0
    550                      *((float *)&TData.Hart.Offset[channel & 0x0f]) = *((float *)&pointer[1]);  //offset
   \   00000024   ....               LDI     R30, LOW((TData + 364))
   \   00000026   ....               LDI     R31, HIGH((TData + 364))
   \   00000028   2F20               MOV     R18, R16
   \   0000002A   E030               LDI     R19, 0
   \   0000002C   702F               ANDI    R18, 0x0F
   \   0000002E   0F22               LSL     R18
   \   00000030   0F22               LSL     R18
   \   00000032   0FE2               ADD     R30, R18
   \   00000034   1FF3               ADC     R31, R19
   \   00000036   01D5               MOVW    R27:R26, R11:R10
   \   00000038   9611               ADIW    R27:R26, 1
   \   0000003A   914D               LD      R20, X+
   \   0000003C   915D               LD      R21, X+
   \   0000003E   916D               LD      R22, X+
   \   00000040   917C               LD      R23, X
   \   00000042   8340               ST      Z, R20
   \   00000044   8351               STD     Z+1, R21
   \   00000046   8362               STD     Z+2, R22
   \   00000048   8373               STD     Z+3, R23
    551                      *((float *)&TData.Hart.Gain[channel   & 0x0f]) = *((float *)&pointer[5]);  //gain
   \   0000004A   01D5               MOVW    R27:R26, R11:R10
   \   0000004C   9615               ADIW    R27:R26, 5
   \   0000004E   914D               LD      R20, X+
   \   00000050   915D               LD      R21, X+
   \   00000052   916D               LD      R22, X+
   \   00000054   917C               LD      R23, X
   \   00000056   AB40               STD     Z+48, R20
   \   00000058   AB51               STD     Z+49, R21
   \   0000005A   AB62               STD     Z+50, R22
   \   0000005C   AB73               STD     Z+51, R23
    552                  }
    553                  break;
    554              case AN_ZB485:
    555                  break;
    556              }
    557              WriteEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&pointer[1]);
   \                     ??GetEEPROMData_0:
   \   0000005E   E018               LDI     R17, 8
   \   00000060   9F01               MUL     R16, R17
   \   00000062   0140               MOVW    R9:R8, R1:R0
   \   00000064   01A5               MOVW    R21:R20, R11:R10
   \   00000066   5F4F               SUBI    R20, 255
   \   00000068   4F5F               SBCI    R21, 255
   \   0000006A   E024               LDI     R18, 4
   \   0000006C   0180               MOVW    R17:R16, R1:R0
   \   0000006E   ........           CALL    WriteEEPROMBuffer
    558              t0 = OS_GetTime();
   \   00000072   ........           CALL    OS__Gettime
   \   00000076   01C8               MOVW    R25:R24, R17:R16
   \   00000078   0F11               LSL     R17
   \   0000007A   0B11               SBC     R17, R17
   \   0000007C   2FA1               MOV     R26, R17
   \   0000007E   2FB1               MOV     R27, R17
   \   00000080   2455               CLR     R5
    559              do {
    560                  OS_Delay(1);
   \                     ??GetEEPROMData_1:
   \   00000082   E001               LDI     R16, 1
   \   00000084   E010               LDI     R17, 0
   \   00000086   ........           CALL    OS_Delay
    561              }while ( (OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK );  //8.5 ms programming time
   \   0000008A   ........           CALL    OS__Gettime
   \   0000008E   2F21               MOV     R18, R17
   \   00000090   0F22               LSL     R18
   \   00000092   0B22               SBC     R18, R18
   \   00000094   2F32               MOV     R19, R18
   \   00000096   1B08               SUB     R16, R24
   \   00000098   0B19               SBC     R17, R25
   \   0000009A   0B2A               SBC     R18, R26
   \   0000009C   0B3B               SBC     R19, R27
   \   0000009E   3204               CPI     R16, 36
   \   000000A0   4010               SBCI    R17, 0
   \   000000A2   4020               SBCI    R18, 0
   \   000000A4   4030               SBCI    R19, 0
   \   000000A6   F420               BRCC    ??GetEEPROMData_2
   \   000000A8   9100....           LDS     R16, EEPWriteOK
   \   000000AC   2300               TST     R16
   \   000000AE   F349               BREQ    ??GetEEPROMData_1
    562              WriteEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&pointer[5]);
   \                     ??GetEEPROMData_2:
   \   000000B0   E005               LDI     R16, 5
   \   000000B2   0EA0               ADD     R10, R16
   \   000000B4   1CB5               ADC     R11, R5
   \   000000B6   01A5               MOVW    R21:R20, R11:R10
   \   000000B8   E024               LDI     R18, 4
   \   000000BA   0E82               ADD     R8, R18
   \   000000BC   1C95               ADC     R9, R5
   \   000000BE   0184               MOVW    R17:R16, R9:R8
   \   000000C0   ........           CALL    WriteEEPROMBuffer
    563              t0 = OS_GetTime();
   \   000000C4   ........           CALL    OS__Gettime
   \   000000C8   01C8               MOVW    R25:R24, R17:R16
   \   000000CA   0F11               LSL     R17
   \   000000CC   0B11               SBC     R17, R17
   \   000000CE   2FA1               MOV     R26, R17
   \   000000D0   2FB1               MOV     R27, R17
    564              do {
    565                  OS_Delay(1);
   \                     ??GetEEPROMData_3:
   \   000000D2   E001               LDI     R16, 1
   \   000000D4   E010               LDI     R17, 0
   \   000000D6   ........           CALL    OS_Delay
    566              }while ( (OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK );
   \   000000DA   ........           CALL    OS__Gettime
   \   000000DE   2F21               MOV     R18, R17
   \   000000E0   0F22               LSL     R18
   \   000000E2   0B22               SBC     R18, R18
   \   000000E4   2F32               MOV     R19, R18
   \   000000E6   1B08               SUB     R16, R24
   \   000000E8   0B19               SBC     R17, R25
   \   000000EA   0B2A               SBC     R18, R26
   \   000000EC   0B3B               SBC     R19, R27
   \   000000EE   3204               CPI     R16, 36
   \   000000F0   4010               SBCI    R17, 0
   \   000000F2   4020               SBCI    R18, 0
   \   000000F4   4030               SBCI    R19, 0
   \   000000F6   F420               BRCC    ??GetEEPROMData_4
   \   000000F8   9100....           LDS     R16, EEPWriteOK
   \   000000FC   2300               TST     R16
   \   000000FE   F349               BREQ    ??GetEEPROMData_3
    567          }
   \                     ??GetEEPROMData_4:
   \   00000100   9189               LD      R24, Y+
   \   00000102   9199               LD      R25, Y+
   \   00000104   91A9               LD      R26, Y+
   \   00000106   91B9               LD      R27, Y+
   \   00000108   9059               LD      R5, Y+
   \   0000010A   9089               LD      R8, Y+
   \   0000010C   9099               LD      R9, Y+
   \   0000010E   90A9               LD      R10, Y+
   \   00000110   90B9               LD      R11, Y+
   \   00000112   9508               RET
    568          
    569          
    570          
    571          /*************************************************************************
    572          *
    573          * Receive AN-ZBHART setup
    574          *
    575          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    576          void GetHartSetup( char *pointer, unsigned Size) {
   \                     GetHartSetup:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   01D8               MOVW    R27:R26, R17:R16
    577              switch ( Size ) {
   \   00000006   5024               SUBI    R18, 4
   \   00000008   4030               SBCI    R19, 0
   \   0000000A   F021               BREQ    ??GetHartSetup_0
   \   0000000C   5022               SUBI    R18, 2
   \   0000000E   4030               SBCI    R19, 0
   \   00000010   F119               BREQ    ??GetHartSetup_1
   \   00000012   C04C               RJMP    ??GetHartSetup_2
    578              case 4:
    579                  TData.Hart.PortUsed     = pointer[0] + (pointer[1] << 8);  //Get the setup
   \                     ??GetHartSetup_0:
   \   00000014   ....               LDI     R30, LOW((TData + 144))
   \   00000016   ....               LDI     R31, HIGH((TData + 144))
   \   00000018   910D               LD      R16, X+
   \   0000001A   911D               LD      R17, X+
   \   0000001C   8300               ST      Z, R16
   \   0000001E   8311               STD     Z+1, R17
    580                  TData.Hart.HartSensor   = pointer[2] + (pointer[3] << 8);  //Get the setup
   \   00000020   910D               LD      R16, X+
   \   00000022   911C               LD      R17, X
   \   00000024   9713               SBIW    R27:R26, 3
   \   00000026   8302               STD     Z+2, R16
   \   00000028   8313               STD     Z+3, R17
    581                  WriteEEPROMByte(EEPROM_PORTSETUP, pointer[0]);     // store in EEPROM
   \   0000002A   912C               LD      R18, X
   \   0000002C   E002               LDI     R16, 2
   \   0000002E   E010               LDI     R17, 0
   \   00000030   ........           CALL    WriteEEPROMByte
    582                  WriteEEPROMByte(EEPROM_HART_SNS , pointer[2]);
   \   00000034   01FD               MOVW    R31:R30, R27:R26
   \   00000036   8122               LDD     R18, Z+2
   \   00000038   E004               LDI     R16, 4
   \   0000003A   E010               LDI     R17, 0
   \   0000003C   ........           CALL    WriteEEPROMByte
    583                  for ( char i = 0; i < 12; i++ ) {
   \   00000040   ....               LDI     R30, LOW(TData)
   \   00000042   ....               LDI     R31, (TData) >> 8
   \   00000044   E00C               LDI     R16, 12
   \   00000046   E020               LDI     R18, 0
    584                      TData.Hart.FailCnt[i][0] = 0;
   \                     ??GetHartSetup_3:
   \   00000048   8320               ST      Z, R18
   \   0000004A   8321               STD     Z+1, R18
    585                      TData.Hart.FailCnt[i][1] = 0;
   \   0000004C   8322               STD     Z+2, R18
   \   0000004E   8323               STD     Z+3, R18
    586                  }
   \   00000050   9634               ADIW    R31:R30, 4
   \   00000052   950A               DEC     R16
   \   00000054   F159               BREQ    ??GetHartSetup_2
   \   00000056   CFF8               RJMP    ??GetHartSetup_3
    587                  break;
    588              case 6:
    589                  {
    590                      TData.Hart.PortUsed     = pointer[0] + (pointer[1] << 8);  //Get the setup
   \                     ??GetHartSetup_1:
   \   00000058   ....               LDI     R30, LOW((TData + 144))
   \   0000005A   ....               LDI     R31, HIGH((TData + 144))
   \   0000005C   910D               LD      R16, X+
   \   0000005E   911D               LD      R17, X+
   \   00000060   8300               ST      Z, R16
   \   00000062   8311               STD     Z+1, R17
    591                      TData.Hart.HartSensor   = pointer[2] + (pointer[3] << 8);  //Get the setup
   \   00000064   910D               LD      R16, X+
   \   00000066   911C               LD      R17, X
   \   00000068   9713               SBIW    R27:R26, 3
   \   0000006A   8302               STD     Z+2, R16
   \   0000006C   8313               STD     Z+3, R17
    592                      unsigned AdditionalCmd  = pointer[4] + (pointer[5] << 8);  //Get the extra command
    593                      if ( AdditionalCmd & 1 ) {
   \   0000006E   01FD               MOVW    R31:R30, R27:R26
   \   00000070   8104               LDD     R16, Z+4
   \   00000072   FF00               SBRS    R16, 0
   \   00000074   C01B               RJMP    ??GetHartSetup_2
    594                          WriteEEPROMByte(EEPROM_PORTSETUP, pointer[0]);     // store in EEPROM
   \   00000076   8120               LD      R18, Z
   \   00000078   E002               LDI     R16, 2
   \   0000007A   E010               LDI     R17, 0
   \   0000007C   ........           CALL    WriteEEPROMByte
    595                          WriteEEPROMByte(EEPROM_HART_SNS , pointer[2]);
   \   00000080   01FD               MOVW    R31:R30, R27:R26
   \   00000082   8122               LDD     R18, Z+2
   \   00000084   E004               LDI     R16, 4
   \   00000086   E010               LDI     R17, 0
   \   00000088   ........           CALL    WriteEEPROMByte
    596                          RestartCnt  = 0;
   \   0000008C   E000               LDI     R16, 0
   \   0000008E   9300....           STS     RestartCnt, R16
   \   00000092   9300....           STS     (RestartCnt + 1), R16
    597                          for ( char i = 0; i < 12; i++ ) {
   \   00000096   ....               LDI     R30, LOW(TData)
   \   00000098   ....               LDI     R31, (TData) >> 8
   \   0000009A   E00C               LDI     R16, 12
   \   0000009C   E020               LDI     R18, 0
    598                              TData.Hart.FailCnt[i][0] = 0;
   \                     ??GetHartSetup_4:
   \   0000009E   8320               ST      Z, R18
   \   000000A0   8321               STD     Z+1, R18
    599                              TData.Hart.FailCnt[i][1] = 0;
   \   000000A2   8322               STD     Z+2, R18
   \   000000A4   8323               STD     Z+3, R18
    600                          }
   \   000000A6   9634               ADIW    R31:R30, 4
   \   000000A8   950A               DEC     R16
   \   000000AA   F7C9               BRNE    ??GetHartSetup_4
    601                      }
    602                      
    603                  }
    604                  break;
    605              }
    606                                                                         
    607          
    608          }
   \                     ??GetHartSetup_2:
   \   000000AC   91A9               LD      R26, Y+
   \   000000AE   91B9               LD      R27, Y+
   \   000000B0   9508               RET
   \   000000B2                      REQUIRE RestartCnt
    609          
    610          /*************************************************************************
    611          *
    612          * Receive AN-ZBHART filter
    613          *
    614          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    615          void GetHartFilter( char *pointer) {
   \                     GetHartFilter:
   \   00000000   01AD               MOVW    R21:R20, R27:R26
    616          
    617              for ( int port = 0; port < 12; port++ ) {
   \   00000002   ....               LDI     R26, LOW((TData + 160))
   \   00000004   ....               LDI     R27, HIGH((TData + 160))
   \   00000006   E02C               LDI     R18, 12
    618                  TData.Hart.Filter[port] = *pointer++;  //Get the filter
   \                     ??GetHartFilter_0:
   \   00000008   01F8               MOVW    R31:R30, R17:R16
   \   0000000A   9131               LD      R19, Z+
   \   0000000C   018F               MOVW    R17:R16, R31:R30
   \   0000000E   933D               ST      X+, R19
    619              }
   \   00000010   952A               DEC     R18
   \   00000012   F7D1               BRNE    ??GetHartFilter_0
    620          }
   \   00000014   01DA               MOVW    R27:R26, R21:R20
   \   00000016   9508               RET
    621          
    622          
    623          /*************************************************************************
    624          *
    625          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    626          *
    627          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    628          char CalcDSTxChecksum(unsigned  Length) {
   \                     CalcDSTxChecksum:
   \   00000000   01BD               MOVW    R23:R22, R27:R26
   \   00000002   01AC               MOVW    R21:R20, R25:R24
    629              unsigned char csum = 0;
   \   00000004   E020               LDI     R18, 0
    630              for ( short cnt = 0; cnt < Length; cnt++ ) {
   \   00000006   E080               LDI     R24, 0
   \   00000008   E090               LDI     R25, 0
   \   0000000A   ....               LDI     R26, LOW((My485UART + 125))
   \   0000000C   ....               LDI     R27, HIGH((My485UART + 125))
   \   0000000E   2F30               MOV     R19, R16
   \   00000010   2B31               OR      R19, R17
   \   00000012   F069               BREQ    ??CalcDSTxChecksum_0
    631                  csum = crc[csum ^ My485UART.pTxBuffer[cnt + 4]];
   \                     ??CalcDSTxChecksum_1:
   \   00000014   2FE2               MOV     R30, R18
   \   00000016   E0F0               LDI     R31, 0
   \   00000018   912D               LD      R18, X+
   \   0000001A   27E2               EOR     R30, R18
   \   0000001C   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000001E   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000020   ....               LDI     R19, (crc) >> 16
   \   00000022   BF3B               OUT     0x3B, R19
   \   00000024   9126               ELPM    R18, Z
    632              }
   \   00000026   9601               ADIW    R25:R24, 1
   \   00000028   1780               CP      R24, R16
   \   0000002A   0791               CPC     R25, R17
   \   0000002C   F398               BRCS    ??CalcDSTxChecksum_1
    633              return csum;
   \                     ??CalcDSTxChecksum_0:
   \   0000002E   2F02               MOV     R16, R18
   \   00000030   01CA               MOVW    R25:R24, R21:R20
   \   00000032   01DB               MOVW    R27:R26, R23:R22
   \   00000034   9508               RET
    634          }
    635          
    636          

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
     12      2   ANPRO10_IO_Receive
       12      2   -> ANPRO10_UnpackPacket
       12      2   -> MyAddress
       12      2   -> OS_Delay
       12      2   -> OS_GetMail1
       12      2   -> OS_GetMailTimed
      8      2   ANPRO10_UnpackPacket
        8      2   -- Indirect call
        8      2   -> BuildADInt
        8      2   -> BuildEEPROMData
        8      2   -> BuildHartFilter
        8      2   -> BuildHartSetup
        8      2   -> BuildMDataHart
        8      2   -> BuildStackStatus
        8      2   -> BuildStatusData
        8      2   -> EEPROMReset
        8      2   -> GetEEPROMData
        8      2   -> GetHartSetup
        8      2   -> My485UART_BuildTail
      0      2   BuildADInt
      4      2   BuildEEPROMData
        4      2   -> ReadEEPROMBuffer
      0      2   BuildHartFilter
      0      2   BuildHartSetup
      3      2   BuildMDataHart
      0      2   BuildStackStatus
      4      2   BuildStatusData
        4      2   -> MyAddress
      0      2   CalcDSTxChecksum
      9      2   GetEEPROMData
        9      2   -> OS_Delay
        9      2   -> OS__Gettime
        9      2   -> WriteEEPROMBuffer
      0      2   GetGotoBootloader
        0      2   -- Indirect call
      0      2   GetHartFilter
      2      2   GetHartSetup
        2      2   -> WriteEEPROMByte
      0      2   GetResetEEPROM
        0      2   -> EEPROMReset
      2      2   My485UART_BuildHeader
        2      2   -> MyAddress
      4      2   My485UART_BuildTail
        4      2   -> My485UART_BuildHeader
        4      2   -> OS_Delay
        4      2   -> OS_WaitEvent
      0      2   Usart0Handler
        0      2   -> ANPRO10_IO_Receive


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine1_0
       2  ?Subroutine0
     400  ANPRO10_IO_Receive
     346  ANPRO10_UnpackPacket
     238  BuildADInt
     286  BuildEEPROMData
     204  BuildHartFilter
     222  BuildHartSetup
     216  BuildMDataHart
     402  BuildStackStatus
     594  BuildStatusData
      54  CalcDSTxChecksum
     276  GetEEPROMData
      28  GetGotoBootloader
      24  GetHartFilter
     178  GetHartSetup
       4  GetResetEEPROM
       2  LastCommand
      74  My485UART_BuildHeader
     392  My485UART_BuildTail
       2  RestartCnt
      16  Usart0Handler
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_UCSR0B
       1  hasStartedUARTTask
       7  -- Other

 
     8 bytes in segment ABSOLUTE
 3 964 bytes in segment CODE
     7 bytes in segment INITTAB
     3 bytes in segment NEAR_Z
 
 3 964 bytes of CODE memory (+ 7 bytes shared)
     3 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: 1
