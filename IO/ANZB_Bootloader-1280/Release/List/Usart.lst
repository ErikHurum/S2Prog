###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       01/Feb/2023  09:02:19
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\ANZB_Bootloader-1280\Src\Usart.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW7420.tmp
#        (D:\S2Prog\IO\ANZB_Bootloader-1280\Src\Usart.c --cpu=m1280 -ms -o
#        D:\S2Prog\IO\ANZB_Bootloader-1280\Release\Obj -D SPEED=38400 -D PORT0
#        -D __ATMEGA_1280__ -lC D:\S2Prog\IO\ANZB_Bootloader-1280\Release\List
#        -y --initializers_in_flash --no_tbaa -DENABLE_BIT_DEFINITIONS -e -I
#        D:\S2Prog\IO\ANZB_Bootloader-1280\INC\\ -I
#        D:\S2Prog\IO\ANZB_Bootloader-1280\..\..\SHARED\INC\\ --eeprom_size
#        4096 --clib -Oh)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\ANZB_Bootloader-1280\Release\List\Usart.lst
#    Object file  =  D:\S2Prog\IO\ANZB_Bootloader-1280\Release\Obj\Usart.r90
#
###############################################################################

D:\S2Prog\IO\ANZB_Bootloader-1280\Src\Usart.c
      1          /****************************************************************************************
      2          / Com protocol for USART0 
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5b
   \   union <unnamed> volatile __io _A_RAMPZ
   \                     _A_RAMPZ:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1
      7          #include "stdio.h"
      8          #include "string.h"
      9          #include "math.h"
     10          #include "externals.h"
     11          #include "assembly.h"
     12          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     13          __near char TxBufferCh0[TXSIZE_UART];            // set up buffer size
   \                     TxBufferCh0:
   \   00000000                      DS8 350

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     14          __near char RxBufferCh0[RXSIZE_UART];
   \                     RxBufferCh0:
   \   00000000                      DS8 350
     15          
     16          
     17          /*************************************************************************
     18          *
     19          *  Check the incoming packages
     20          *
     21          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     22          void UsartCheckPackage(void) {
   \                     UsartCheckPackage:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
     23          
     24              unsigned short pointer;
     25              char retval;
     26          
     27              myUART.RxSendReply = false;                           // flag for answering set to fault
   \   00000004   E000               LDI     R16, 0
   \   00000006   9300....           STS     (myUART + 24), R16
     28              myUART.TxFirst = 11;                        // Startpos for fist TX command
   \   0000000A   E00B               LDI     R16, 11
   \   0000000C   9300....           STS     myUART, R16
   \   00000010   E000               LDI     R16, 0
   \   00000012   9300....           STS     (myUART + 1), R16
     29              pointer = 7;
   \   00000016   E087               LDI     R24, 7
   \   00000018   E090               LDI     R25, 0
     30              do {
     31                  retval = CheckActionUart(pointer);
   \                     ??UsartCheckPackage_0:
   \   0000001A   018C               MOVW    R17:R16, R25:R24
   \   0000001C   ....               RCALL   CheckActionUart
     32                  pointer = pointer + RxBufferCh0[pointer + 2]
     33                      + (RxBufferCh0[pointer + 3] * 256) + 4;            // Point to a command cmd hb/lb
   \   0000001E   ....               LDI     R30, LOW(RxBufferCh0)
   \   00000020   ....               LDI     R31, (RxBufferCh0) >> 8
   \   00000022   0FE8               ADD     R30, R24
   \   00000024   1FF9               ADC     R31, R25
   \   00000026   8112               LDD     R17, Z+2
   \   00000028   81F3               LDD     R31, Z+3
   \   0000002A   2FE1               MOV     R30, R17
   \   0000002C   9634               ADIW    R31:R30, 4
   \   0000002E   0F8E               ADD     R24, R30
   \   00000030   1F9F               ADC     R25, R31
     34              } while ( retval && (pointer < (myUART.RxPacklen - 4)) );
   \   00000032   2300               TST     R16
   \   00000034   F041               BREQ    ??UsartCheckPackage_1
   \   00000036   91E0....           LDS     R30, (myUART + 20)
   \   0000003A   91F0....           LDS     R31, (myUART + 21)
   \   0000003E   9734               SBIW    R31:R30, 4
   \   00000040   178E               CP      R24, R30
   \   00000042   079F               CPC     R25, R31
   \   00000044   F350               BRCS    ??UsartCheckPackage_0
     35              if ( myUART.RxSendReply ) {                              //send answer
   \                     ??UsartCheckPackage_1:
   \   00000046   9100....           LDS     R16, (myUART + 24)
   \   0000004A   2300               TST     R16
   \   0000004C   F009               BREQ    ??UsartCheckPackage_2
     36                  Uart_BuildTail();
   \   0000004E   ....               RCALL   Uart_BuildTail
     37              }
     38              GoToSyncUART();                                    // go to sync modus for recive
   \                     ??UsartCheckPackage_2:
   \   00000050   ....               RCALL   GoToSyncUART
     39          }
   \   00000052   9189               LD      R24, Y+
   \   00000054   9199               LD      R25, Y+
   \   00000056   9508               RET
     40          
     41          /*************************************************************************
     42          *
     43          *  Check action on received data
     44          *
     45          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     46          char CheckActionUart(unsigned short pointer) {
   \                     CheckActionUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
     47          
     48              const char ch = 0;
     49              unsigned short   command;
     50              char    retval = true;
   \   00000006   E081               LDI     R24, 1
     51          
     52              command = RxBufferCh0[pointer] | (RxBufferCh0[pointer + 1] << 8);
   \   00000008   ....               LDI     R30, LOW(RxBufferCh0)
   \   0000000A   ....               LDI     R31, (RxBufferCh0) >> 8
   \   0000000C   0FE0               ADD     R30, R16
   \   0000000E   1FF1               ADC     R31, R17
   \   00000010   8120               LD      R18, Z
   \   00000012   8131               LDD     R19, Z+1
     53              switch ( command ) {                                      // check action
   \   00000014   01F9               MOVW    R31:R30, R19:R18
   \   00000016   5EE8               SUBI    R30, 232
   \   00000018   40F3               SBCI    R31, 3
   \   0000001A   F081               BREQ    ??CheckActionUart_0
   \   0000001C   5AEC               SUBI    R30, 172
   \   0000001E   40F3               SBCI    R31, 3
   \   00000020   F081               BREQ    ??CheckActionUart_1
   \   00000022   973A               SBIW    R31:R30, 10
   \   00000024   F409               BRNE    $+2+2
   \   00000026   C086               RJMP    ??CheckActionUart_2
   \   00000028   973A               SBIW    R31:R30, 10
   \   0000002A   F409               BRNE    $+2+2
   \   0000002C   C085               RJMP    ??CheckActionUart_3
   \   0000002E   973A               SBIW    R31:R30, 10
   \   00000030   F409               BRNE    $+2+2
   \   00000032   C086               RJMP    ??CheckActionUart_4
   \   00000034   9774               SBIW    R31:R30, 20
   \   00000036   F409               BRNE    $+2+2
   \   00000038   C087               RJMP    ??CheckActionUart_5
   \   0000003A   C096               RJMP    ??CheckActionUart_6
     54              case CMD_REQ_STATUS :                                    // Regusest status for target
     55                  BuildStatusData(ch);
   \                     ??CheckActionUart_0:
   \   0000003C   E000               LDI     R16, 0
   \   0000003E   ....               RCALL   BuildStatusData
     56                  break;
   \   00000040   C097               RJMP    ??CheckActionUart_7
     57          
     58              case CMD_FLASH_ID :                                     // Send flash ID
     59                  BuildFlashID(ch);
   \                     ??CheckActionUart_1:
   \   00000042   9380....           STS     (myUART + 24), R24
   \   00000046   91E0....           LDS     R30, myUART
   \   0000004A   91F0....           LDS     R31, (myUART + 1)
   \   0000004E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000050   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000052   E905               LDI     R16, 149
   \   00000054   8300               ST      Z, R16
   \   00000056   9100....           LDS     R16, myUART
   \   0000005A   9110....           LDS     R17, (myUART + 1)
   \   0000005E   5F0F               SUBI    R16, 255
   \   00000060   4F1F               SBCI    R17, 255
   \   00000062   9300....           STS     myUART, R16
   \   00000066   9310....           STS     (myUART + 1), R17
   \   0000006A   01F8               MOVW    R31:R30, R17:R16
   \   0000006C   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000006E   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000070   E007               LDI     R16, 7
   \   00000072   8300               ST      Z, R16
   \   00000074   9100....           LDS     R16, myUART
   \   00000078   9110....           LDS     R17, (myUART + 1)
   \   0000007C   5F0F               SUBI    R16, 255
   \   0000007E   4F1F               SBCI    R17, 255
   \   00000080   9300....           STS     myUART, R16
   \   00000084   9310....           STS     (myUART + 1), R17
   \   00000088   9120....           LDS     R18, myUART
   \   0000008C   9130....           LDS     R19, (myUART + 1)
   \   00000090   5F0E               SUBI    R16, 254
   \   00000092   4F1F               SBCI    R17, 255
   \   00000094   9300....           STS     myUART, R16
   \   00000098   9310....           STS     (myUART + 1), R17
   \   0000009C   01F8               MOVW    R31:R30, R17:R16
   \   0000009E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000A0   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000A2   E404               LDI     R16, 68
   \   000000A4   8300               ST      Z, R16
   \   000000A6   9100....           LDS     R16, myUART
   \   000000AA   9110....           LDS     R17, (myUART + 1)
   \   000000AE   5F0F               SUBI    R16, 255
   \   000000B0   4F1F               SBCI    R17, 255
   \   000000B2   9300....           STS     myUART, R16
   \   000000B6   9310....           STS     (myUART + 1), R17
   \   000000BA   01F8               MOVW    R31:R30, R17:R16
   \   000000BC   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000BE   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000C0   E10E               LDI     R16, 30
   \   000000C2   8300               ST      Z, R16
   \   000000C4   9100....           LDS     R16, myUART
   \   000000C8   9110....           LDS     R17, (myUART + 1)
   \   000000CC   5F0F               SUBI    R16, 255
   \   000000CE   4F1F               SBCI    R17, 255
   \   000000D0   9300....           STS     myUART, R16
   \   000000D4   9310....           STS     (myUART + 1), R17
   \   000000D8   01F8               MOVW    R31:R30, R17:R16
   \   000000DA   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000DC   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000DE   E907               LDI     R16, 151
   \   000000E0   8300               ST      Z, R16
   \   000000E2   9100....           LDS     R16, myUART
   \   000000E6   9110....           LDS     R17, (myUART + 1)
   \   000000EA   5F0F               SUBI    R16, 255
   \   000000EC   4F1F               SBCI    R17, 255
   \   000000EE   9300....           STS     myUART, R16
   \   000000F2   9310....           STS     (myUART + 1), R17
   \   000000F6   01F8               MOVW    R31:R30, R17:R16
   \   000000F8   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000FA   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000FC   E002               LDI     R16, 2
   \   000000FE   8300               ST      Z, R16
   \   00000100   9100....           LDS     R16, myUART
   \   00000104   9110....           LDS     R17, (myUART + 1)
   \   00000108   5F0F               SUBI    R16, 255
   \   0000010A   4F1F               SBCI    R17, 255
   \   0000010C   9300....           STS     myUART, R16
   \   00000110   9310....           STS     (myUART + 1), R17
   \   00000114   ....               LDI     R30, LOW(TxBufferCh0)
   \   00000116   ....               LDI     R31, (TxBufferCh0) >> 8
   \   00000118   0FE2               ADD     R30, R18
   \   0000011A   1FF3               ADC     R31, R19
   \   0000011C   91A0....           LDS     R26, myUART
   \   00000120   91B0....           LDS     R27, (myUART + 1)
   \   00000124   1B02               SUB     R16, R18
   \   00000126   5002               SUBI    R16, 2
   \   00000128   8300               ST      Z, R16
   \   0000012A   1BA2               SUB     R26, R18
   \   0000012C   0BB3               SBC     R27, R19
   \   0000012E   9712               SBIW    R27:R26, 2
   \   00000130   83B1               STD     Z+1, R27
     60                  break;
   \   00000132   C01E               RJMP    ??CheckActionUart_7
     61          
     62              case CMD_FLASH_ERASE :                                 // Erase flash
     63                  EraseFlash();
   \                     ??CheckActionUart_2:
   \   00000134   ....               RCALL   EraseFlash
     64                  break;
   \   00000136   C01C               RJMP    ??CheckActionUart_7
     65          
     66              case CMD_FLASH_PROG :                                   // Prog flash
     67                  ProgramFlash(pointer + 4);
   \                     ??CheckActionUart_3:
   \   00000138   5F0C               SUBI    R16, 252
   \   0000013A   4F1F               SBCI    R17, 255
   \   0000013C   ....               RCALL   ProgramFlash
     68                  break;
   \   0000013E   C018               RJMP    ??CheckActionUart_7
     69          
     70              case CMD_FLASH_READ :                                   // Read flash
     71                  ReadFlash(pointer + 4);
   \                     ??CheckActionUart_4:
   \   00000140   5F0C               SUBI    R16, 252
   \   00000142   4F1F               SBCI    R17, 255
   \   00000144   ....               RCALL   ReadFlash
     72                  break;
   \   00000146   C014               RJMP    ??CheckActionUart_7
   \                     ??CheckActionUart_5:
   \   00000148   99F9               SBIC    0x1F, 0x01
   \   0000014A   CFFE               RJMP    ??CheckActionUart_5
   \   0000014C   EF0F               LDI     R16, 255
   \   0000014E   BD01               OUT     0x21, R16
   \   00000150   E00F               LDI     R16, 15
   \   00000152   BD02               OUT     0x22, R16
   \   00000154   EA0A               LDI     R16, 170
   \   00000156   BD00               OUT     0x20, R16
   \   00000158   9AFA               SBI     0x1F, 0x02
   \   0000015A   9AF9               SBI     0x1F, 0x01
   \                     ??CheckActionUart_8:
   \   0000015C   99F9               SBIC    0x1F, 0x01
   \   0000015E   CFFE               RJMP    ??CheckActionUart_8
   \   00000160   E008               LDI     R16, 8
   \   00000162   9300....           STS     _A_WDTCSR, R16
     73          
     74              case CMD_EXIT_BOOTLOADER :                                // Leave bootlaoder
     75                  ExitBootloader(ch);
     76                  break;
   \   00000166   C004               RJMP    ??CheckActionUart_7
     77          
     78              default:
     79                  if ( command < MAX_ECMD ) {                           // handle end commands
   \                     ??CheckActionUart_6:
   \   00000168   3624               CPI     R18, 100
   \   0000016A   4030               SBCI    R19, 0
   \   0000016C   F408               BRCC    ??CheckActionUart_7
     80                      retval = false;
   \   0000016E   E080               LDI     R24, 0
     81                  }
     82                  break;
     83          
     84              }
     85              return retval;
   \                     ??CheckActionUart_7:
   \   00000170   2F08               MOV     R16, R24
   \   00000172   9189               LD      R24, Y+
   \   00000174   91A9               LD      R26, Y+
   \   00000176   91B9               LD      R27, Y+
   \   00000178   9508               RET
   \   0000017A                      REQUIRE _A_EECR
   \   0000017A                      REQUIRE _A_EEAR
   \   0000017A                      REQUIRE _A_EEDR
   \   0000017A                      REQUIRE _A_WDTCSR
     86          }
     87          
     88          //#include <intrinsics.h>
     89          
     90          /*************************************************************************
     91          *
     92          * Build send packet header
     93          *
     94          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     95          void Uart_BuildHeader(void) {
   \                     Uart_BuildHeader:
     96              //__disable_interrupt();
     97              myUART.RxFirst = 0;                                // Reset pointers
   \   00000000   E000               LDI     R16, 0
   \   00000002   9300....           STS     (myUART + 10), R16
   \   00000006   9300....           STS     (myUART + 11), R16
     98              myUART.RxLast  = 0;
   \   0000000A   9300....           STS     (myUART + 12), R16
   \   0000000E   9300....           STS     (myUART + 13), R16
     99              myUART.TxLast  = 0;
   \   00000012   9300....           STS     (myUART + 2), R16
   \   00000016   9300....           STS     (myUART + 3), R16
    100          
    101          
    102              TxBufferCh0[0] = ANPRO10_SYN;                        /* Sync */
   \   0000001A   E106               LDI     R16, 22
   \   0000001C   9300....           STS     TxBufferCh0, R16
    103              TxBufferCh0[1] = ANPRO10_SYN;                        /* Sync */
   \   00000020   9300....           STS     (TxBufferCh0 + 1), R16
    104              TxBufferCh0[2] = ANPRO10_SYN;                        /* Sync */
   \   00000024   9300....           STS     (TxBufferCh0 + 2), R16
    105              TxBufferCh0[3] = ANPRO10_SOH;                        /* Start of header */
   \   00000028   E001               LDI     R16, 1
   \   0000002A   9300....           STS     (TxBufferCh0 + 3), R16
    106              TxBufferCh0[4] = RxBufferCh0[2];      /* RXID */
   \   0000002E   9100....           LDS     R16, (RxBufferCh0 + 2)
   \   00000032   9300....           STS     (TxBufferCh0 + 4), R16
    107              TxBufferCh0[5] = RxBufferCh0[3];      /* Rx address */
   \   00000036   9100....           LDS     R16, (RxBufferCh0 + 3)
   \   0000003A   9300....           STS     (TxBufferCh0 + 5), R16
    108              TxBufferCh0[6] = 0x10 + UnitID;              /* Unit ID */
   \   0000003E   9100....           LDS     R16, UnitID
   \   00000042   5F00               SUBI    R16, 240
   \   00000044   9300....           STS     (TxBufferCh0 + 6), R16
    109              TxBufferCh0[7] = MyAddress();                /* Tx address */
   \   00000048   ........           CALL    MyAddress
   \   0000004C   9300....           STS     (TxBufferCh0 + 7), R16
    110              TxBufferCh0[8] = 0;                         /* packlen HB, don't know yet */
   \   00000050   E000               LDI     R16, 0
   \   00000052   9300....           STS     (TxBufferCh0 + 8), R16
    111              TxBufferCh0[9] = 0;                         /* packlen LB, don't know yet */
   \   00000056   9300....           STS     (TxBufferCh0 + 9), R16
    112              TxBufferCh0[10] = 0;                        /* header checksum, don't know yet */
   \   0000005A   9300....           STS     (TxBufferCh0 + 10), R16
    113          
    114              //__enable_interrupt();
    115          }
   \   0000005E   9508               RET
    116          
    117          /*************************************************************************
    118          *
    119          * Build  packet tail
    120          *
    121          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    122          void Uart_BuildTail(void) {
   \                     Uart_BuildTail:
    123              Uart_BuildHeader();                                    // fist build the header
   \   00000000   ....               RCALL   Uart_BuildHeader
    124          
    125              TxBufferCh0[myUART.TxFirst++] = ECMD_NMDWOACK & 0xff;  // End command lb
   \   00000002   91E0....           LDS     R30, myUART
   \   00000006   91F0....           LDS     R31, (myUART + 1)
   \   0000000A   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000000C   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000000E   E000               LDI     R16, 0
   \   00000010   8300               ST      Z, R16
   \   00000012   9100....           LDS     R16, myUART
   \   00000016   9110....           LDS     R17, (myUART + 1)
   \   0000001A   5F0F               SUBI    R16, 255
   \   0000001C   4F1F               SBCI    R17, 255
   \   0000001E   9300....           STS     myUART, R16
   \   00000022   9310....           STS     (myUART + 1), R17
    126              TxBufferCh0[myUART.TxFirst++] = ECMD_NMDWOACK >> 8;    // End command hb
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000002A   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000002C   E000               LDI     R16, 0
   \   0000002E   8300               ST      Z, R16
   \   00000030   9100....           LDS     R16, myUART
   \   00000034   9110....           LDS     R17, (myUART + 1)
   \   00000038   5F0F               SUBI    R16, 255
   \   0000003A   4F1F               SBCI    R17, 255
   \   0000003C   9300....           STS     myUART, R16
   \   00000040   9310....           STS     (myUART + 1), R17
    127              TxBufferCh0[myUART.TxFirst++] = 0x00;                  // End data
   \   00000044   01F8               MOVW    R31:R30, R17:R16
   \   00000046   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000048   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000004A   E000               LDI     R16, 0
   \   0000004C   8300               ST      Z, R16
   \   0000004E   9100....           LDS     R16, myUART
   \   00000052   9110....           LDS     R17, (myUART + 1)
   \   00000056   5F0F               SUBI    R16, 255
   \   00000058   4F1F               SBCI    R17, 255
   \   0000005A   9300....           STS     myUART, R16
   \   0000005E   9310....           STS     (myUART + 1), R17
    128          
    129              TxBufferCh0[myUART.TxFirst++] = myUART.TxSeqCnt++;   // Sequence counter
   \   00000062   9100....           LDS     R16, (myUART + 9)
   \   00000066   91E0....           LDS     R30, myUART
   \   0000006A   91F0....           LDS     R31, (myUART + 1)
   \   0000006E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000070   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000072   8300               ST      Z, R16
   \   00000074   9100....           LDS     R16, (myUART + 9)
   \   00000078   9503               INC     R16
   \   0000007A   9300....           STS     (myUART + 9), R16
   \   0000007E   9100....           LDS     R16, myUART
   \   00000082   9110....           LDS     R17, (myUART + 1)
   \   00000086   5F0F               SUBI    R16, 255
   \   00000088   4F1F               SBCI    R17, 255
   \   0000008A   9300....           STS     myUART, R16
   \   0000008E   9310....           STS     (myUART + 1), R17
    130          
    131              TxBufferCh0[8] = myUART.TxFirst - 2;                // correct length because stx's
   \   00000092   9160....           LDS     R22, myUART
   \   00000096   9170....           LDS     R23, (myUART + 1)
   \   0000009A   5002               SUBI    R16, 2
   \   0000009C   9300....           STS     (TxBufferCh0 + 8), R16
    132              TxBufferCh0[9] = (myUART.TxFirst - 2) >> 8;           // packet len high
   \   000000A0   01FB               MOVW    R31:R30, R23:R22
   \   000000A2   9732               SBIW    R31:R30, 2
   \   000000A4   93F0....           STS     (TxBufferCh0 + 9), R31
    133          
    134              TxBufferCh0[10] = CalcDSTxChecksum(10);         // Get header checksum
   \   000000A8   E00A               LDI     R16, 10
   \   000000AA   E010               LDI     R17, 0
   \   000000AC   ....               RCALL   CalcDSTxChecksum
   \   000000AE   9300....           STS     (TxBufferCh0 + 10), R16
    135          
    136              TxBufferCh0[myUART.TxFirst] = CalcDSTxChecksum(myUART.TxFirst); // Get checksum
   \   000000B2   018B               MOVW    R17:R16, R23:R22
   \   000000B4   ....               RCALL   CalcDSTxChecksum
   \   000000B6   01FB               MOVW    R31:R30, R23:R22
   \   000000B8   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000BA   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000BC   8300               ST      Z, R16
    137              myUART.TxFirst++;                                       // OBS!! must be inc here
   \   000000BE   9100....           LDS     R16, myUART
   \   000000C2   9110....           LDS     R17, (myUART + 1)
   \   000000C6   5F0F               SUBI    R16, 255
   \   000000C8   4F1F               SBCI    R17, 255
   \   000000CA   9300....           STS     myUART, R16
   \   000000CE   9310....           STS     (myUART + 1), R17
    138          
    139              TxBufferCh0[myUART.TxFirst++] = ANPRO10_EOT;            // End of transmission
   \   000000D2   01F8               MOVW    R31:R30, R17:R16
   \   000000D4   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000D6   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000D8   E004               LDI     R16, 4
   \   000000DA   8300               ST      Z, R16
   \   000000DC   9100....           LDS     R16, myUART
   \   000000E0   9110....           LDS     R17, (myUART + 1)
   \   000000E4   5F0F               SUBI    R16, 255
   \   000000E6   4F1F               SBCI    R17, 255
   \   000000E8   9300....           STS     myUART, R16
   \   000000EC   9310....           STS     (myUART + 1), R17
    140              TxBufferCh0[myUART.TxFirst++] = 0x00;            //switch off transmitter delay
   \   000000F0   01F8               MOVW    R31:R30, R17:R16
   \   000000F2   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000F4   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000F6   E000               LDI     R16, 0
   \   000000F8   8300               ST      Z, R16
   \   000000FA   9100....           LDS     R16, myUART
   \   000000FE   9110....           LDS     R17, (myUART + 1)
   \   00000102   5F0F               SUBI    R16, 255
   \   00000104   4F1F               SBCI    R17, 255
   \   00000106   9300....           STS     myUART, R16
   \   0000010A   9310....           STS     (myUART + 1), R17
    141          
    142              myUART.TxCount = myUART.TxFirst;                      //bytes to send
   \   0000010E   9300....           STS     (myUART + 4), R16
   \   00000112   9310....           STS     (myUART + 5), R17
    143              myUART.TxLast = 0;                                     // reset cunter
   \   00000116   E000               LDI     R16, 0
   \   00000118   9300....           STS     (myUART + 2), R16
   \   0000011C   9300....           STS     (myUART + 3), R16
    144              myUART.TxPkCnt++;                                     // Count sent packages
   \   00000120   9100....           LDS     R16, (myUART + 6)
   \   00000124   9110....           LDS     R17, (myUART + 7)
   \   00000128   5F0F               SUBI    R16, 255
   \   0000012A   4F1F               SBCI    R17, 255
   \   0000012C   9300....           STS     (myUART + 6), R16
   \   00000130   9310....           STS     (myUART + 7), R17
    145              PORTE |= 0x04;                                     // TXE0 on
   \   00000134   9A72               SBI     0x0E, 0x02
    146              SendPacketUart();                                     // send answer
   \   00000136   ....               RJMP    SendPacketUart
   \   00000138                      REQUIRE _A_PORTE
    147          }
    148          
    149          
    150          /*************************************************************************
    151          *
    152          * Build datablock for card status
    153          *
    154          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    155          void BuildStatusData(char ch) {
   \                     BuildStatusData:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
    156          
    157              short ntna;
    158              myUART.RxSendReply = true;                               // flag for answering
   \   00000008   E011               LDI     R17, 1
   \   0000000A   9310....           STS     (myUART + 24), R17
    159          
    160              TxBufferCh0[myUART.TxFirst++] = CMD_REP_STATUS & 0xff;
   \   0000000E   91E0....           LDS     R30, myUART
   \   00000012   91F0....           LDS     R31, (myUART + 1)
   \   00000016   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000018   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000001A   EE19               LDI     R17, 233
   \   0000001C   8310               ST      Z, R17
   \   0000001E   9120....           LDS     R18, myUART
   \   00000022   9130....           LDS     R19, (myUART + 1)
   \   00000026   5F2F               SUBI    R18, 255
   \   00000028   4F3F               SBCI    R19, 255
   \   0000002A   9320....           STS     myUART, R18
   \   0000002E   9330....           STS     (myUART + 1), R19
    161              TxBufferCh0[myUART.TxFirst++] = CMD_REP_STATUS >> 8;
   \   00000032   01F9               MOVW    R31:R30, R19:R18
   \   00000034   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000036   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000038   E013               LDI     R17, 3
   \   0000003A   8310               ST      Z, R17
   \   0000003C   9120....           LDS     R18, myUART
   \   00000040   9130....           LDS     R19, (myUART + 1)
   \   00000044   5F2F               SUBI    R18, 255
   \   00000046   4F3F               SBCI    R19, 255
   \   00000048   9320....           STS     myUART, R18
   \   0000004C   9330....           STS     (myUART + 1), R19
    162              ntna = myUART.TxFirst;                                    /* remember index */
   \   00000050   9180....           LDS     R24, myUART
   \   00000054   9190....           LDS     R25, (myUART + 1)
    163              myUART.TxFirst += 2;                                      // two byte length
   \   00000058   5F2E               SUBI    R18, 254
   \   0000005A   4F3F               SBCI    R19, 255
   \   0000005C   9320....           STS     myUART, R18
   \   00000060   9330....           STS     (myUART + 1), R19
    164              TxBufferCh0[myUART.TxFirst++] = ch;                // channel
   \   00000064   01F9               MOVW    R31:R30, R19:R18
   \   00000066   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000068   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000006A   8300               ST      Z, R16
   \   0000006C   9100....           LDS     R16, myUART
   \   00000070   9110....           LDS     R17, (myUART + 1)
   \   00000074   5F0F               SUBI    R16, 255
   \   00000076   4F1F               SBCI    R17, 255
   \   00000078   9300....           STS     myUART, R16
   \   0000007C   9310....           STS     (myUART + 1), R17
    165              TxBufferCh0[myUART.TxFirst++] = 0x10 + UnitID;               // Product ID
   \   00000080   91A0....           LDS     R26, myUART
   \   00000084   91B0....           LDS     R27, (myUART + 1)
   \   00000088   9100....           LDS     R16, UnitID
   \   0000008C   5F00               SUBI    R16, 240
   \   0000008E   01FD               MOVW    R31:R30, R27:R26
   \   00000090   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000092   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000094   8300               ST      Z, R16
    166              TxBufferCh0[myUART.TxFirst++] = MyAddress();           // unit address				/* get the address */
   \   00000096   9611               ADIW    R27:R26, 1
   \   00000098   01FD               MOVW    R31:R30, R27:R26
   \   0000009A   9631               ADIW    R31:R30, 1
   \   0000009C   93E0....           STS     myUART, R30
   \   000000A0   93F0....           STS     (myUART + 1), R31
   \   000000A4   ........           CALL    MyAddress
   \   000000A8   01FD               MOVW    R31:R30, R27:R26
   \   000000AA   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000AC   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000AE   8300               ST      Z, R16
    167              TxBufferCh0[myUART.TxFirst++] = PROG_VERSION;       // software version */
   \   000000B0   91E0....           LDS     R30, myUART
   \   000000B4   91F0....           LDS     R31, (myUART + 1)
   \   000000B8   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000BA   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000BC   E008               LDI     R16, 8
   \   000000BE   8300               ST      Z, R16
   \   000000C0   9100....           LDS     R16, myUART
   \   000000C4   9110....           LDS     R17, (myUART + 1)
   \   000000C8   5F0F               SUBI    R16, 255
   \   000000CA   4F1F               SBCI    R17, 255
   \   000000CC   9300....           STS     myUART, R16
   \   000000D0   9310....           STS     (myUART + 1), R17
    168              TxBufferCh0[myUART.TxFirst++] = COMP_VERSION;        // cpmpability version
   \   000000D4   01F8               MOVW    R31:R30, R17:R16
   \   000000D6   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000D8   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000DA   E001               LDI     R16, 1
   \   000000DC   8300               ST      Z, R16
   \   000000DE   9100....           LDS     R16, myUART
   \   000000E2   9110....           LDS     R17, (myUART + 1)
   \   000000E6   5F0F               SUBI    R16, 255
   \   000000E8   4F1F               SBCI    R17, 255
   \   000000EA   9300....           STS     myUART, R16
   \   000000EE   9310....           STS     (myUART + 1), R17
    169              TxBufferCh0[myUART.TxFirst++] = STORE_VERSION;        // cpmpability version
   \   000000F2   01F8               MOVW    R31:R30, R17:R16
   \   000000F4   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000F6   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000F8   E002               LDI     R16, 2
   \   000000FA   8300               ST      Z, R16
   \   000000FC   9100....           LDS     R16, myUART
   \   00000100   9110....           LDS     R17, (myUART + 1)
   \   00000104   5F0F               SUBI    R16, 255
   \   00000106   4F1F               SBCI    R17, 255
   \   00000108   9300....           STS     myUART, R16
   \   0000010C   9310....           STS     (myUART + 1), R17
    170              TxBufferCh0[myUART.TxFirst++] = (RXSIZE_UART & 0xff);         // rx buffer size
   \   00000110   01F8               MOVW    R31:R30, R17:R16
   \   00000112   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000114   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000116   E50E               LDI     R16, 94
   \   00000118   8300               ST      Z, R16
   \   0000011A   9100....           LDS     R16, myUART
   \   0000011E   9110....           LDS     R17, (myUART + 1)
   \   00000122   5F0F               SUBI    R16, 255
   \   00000124   4F1F               SBCI    R17, 255
   \   00000126   9300....           STS     myUART, R16
   \   0000012A   9310....           STS     (myUART + 1), R17
    171              TxBufferCh0[myUART.TxFirst++] = ((RXSIZE_UART >> 8) & 0xff); // rx buffer size
   \   0000012E   01F8               MOVW    R31:R30, R17:R16
   \   00000130   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000132   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000134   E001               LDI     R16, 1
   \   00000136   8300               ST      Z, R16
   \   00000138   9100....           LDS     R16, myUART
   \   0000013C   9110....           LDS     R17, (myUART + 1)
   \   00000140   5F0F               SUBI    R16, 255
   \   00000142   4F1F               SBCI    R17, 255
   \   00000144   9300....           STS     myUART, R16
   \   00000148   9310....           STS     (myUART + 1), R17
    172              TxBufferCh0[myUART.TxFirst++] = (TXSIZE_UART & 0xff);         // tx buffer size
   \   0000014C   01F8               MOVW    R31:R30, R17:R16
   \   0000014E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000150   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000152   E50E               LDI     R16, 94
   \   00000154   8300               ST      Z, R16
   \   00000156   9100....           LDS     R16, myUART
   \   0000015A   9110....           LDS     R17, (myUART + 1)
   \   0000015E   5F0F               SUBI    R16, 255
   \   00000160   4F1F               SBCI    R17, 255
   \   00000162   9300....           STS     myUART, R16
   \   00000166   9310....           STS     (myUART + 1), R17
    173              TxBufferCh0[myUART.TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);  // tx buffer size
   \   0000016A   01F8               MOVW    R31:R30, R17:R16
   \   0000016C   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000016E   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000170   E001               LDI     R16, 1
   \   00000172   8300               ST      Z, R16
   \   00000174   9100....           LDS     R16, myUART
   \   00000178   9110....           LDS     R17, (myUART + 1)
   \   0000017C   5F0F               SUBI    R16, 255
   \   0000017E   4F1F               SBCI    R17, 255
   \   00000180   9300....           STS     myUART, R16
   \   00000184   9310....           STS     (myUART + 1), R17
    174              TxBufferCh0[myUART.TxFirst++] = ResetStatus;                  // restart flag
   \   00000188   9100....           LDS     R16, ResetStatus
   \   0000018C   91E0....           LDS     R30, myUART
   \   00000190   91F0....           LDS     R31, (myUART + 1)
   \   00000194   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000196   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000198   8300               ST      Z, R16
   \   0000019A   9100....           LDS     R16, myUART
   \   0000019E   9110....           LDS     R17, (myUART + 1)
   \   000001A2   5F0F               SUBI    R16, 255
   \   000001A4   4F1F               SBCI    R17, 255
   \   000001A6   9300....           STS     myUART, R16
   \   000001AA   9310....           STS     (myUART + 1), R17
    175              TxBufferCh0[myUART.TxFirst++] = PROGTYPE_BOOT;                // Boot program
   \   000001AE   01F8               MOVW    R31:R30, R17:R16
   \   000001B0   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000001B2   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000001B4   E000               LDI     R16, 0
   \   000001B6   8300               ST      Z, R16
   \   000001B8   9100....           LDS     R16, myUART
   \   000001BC   9110....           LDS     R17, (myUART + 1)
   \   000001C0   5F0F               SUBI    R16, 255
   \   000001C2   4F1F               SBCI    R17, 255
   \   000001C4   9300....           STS     myUART, R16
   \   000001C8   9310....           STS     (myUART + 1), R17
    176          
    177              TxBufferCh0[ntna] = (myUART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000001CC   ....               LDI     R30, LOW(TxBufferCh0)
   \   000001CE   ....               LDI     R31, (TxBufferCh0) >> 8
   \   000001D0   0FE8               ADD     R30, R24
   \   000001D2   1FF9               ADC     R31, R25
   \   000001D4   91A0....           LDS     R26, myUART
   \   000001D8   91B0....           LDS     R27, (myUART + 1)
   \   000001DC   1B08               SUB     R16, R24
   \   000001DE   5002               SUBI    R16, 2
   \   000001E0   8300               ST      Z, R16
    178              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000001E2   1BA8               SUB     R26, R24
   \   000001E4   0BB9               SBC     R27, R25
   \   000001E6   9712               SBIW    R27:R26, 2
   \   000001E8   83B1               STD     Z+1, R27
    179          
    180              ResetStatus = 0;                                                       // set reset stat to 0 = read
   \   000001EA   E000               LDI     R16, 0
   \   000001EC   9300....           STS     ResetStatus, R16
    181          }
   \   000001F0   ....               RJMP    ?Subroutine0
    182          
    183          /*************************************************************************
    184          *
    185          * Build datablock for Flash ID
    186          *
    187          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    188          void BuildFlashID(char ch) {
   \                     BuildFlashID:
   \   00000000   01AC               MOVW    R21:R20, R25:R24
    189          
    190              short ntna;
    191              myUART.RxSendReply = true;                               // flag for answering
   \   00000002   E001               LDI     R16, 1
   \   00000004   9300....           STS     (myUART + 24), R16
    192          
    193              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_ID & 0xff;
   \   00000008   91E0....           LDS     R30, myUART
   \   0000000C   91F0....           LDS     R31, (myUART + 1)
   \   00000010   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000012   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000014   E905               LDI     R16, 149
   \   00000016   8300               ST      Z, R16
   \   00000018   9100....           LDS     R16, myUART
   \   0000001C   9110....           LDS     R17, (myUART + 1)
   \   00000020   5F0F               SUBI    R16, 255
   \   00000022   4F1F               SBCI    R17, 255
   \   00000024   9300....           STS     myUART, R16
   \   00000028   9310....           STS     (myUART + 1), R17
    194              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_ID >> 8;
   \   0000002C   01F8               MOVW    R31:R30, R17:R16
   \   0000002E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000030   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000032   E007               LDI     R16, 7
   \   00000034   8300               ST      Z, R16
   \   00000036   9100....           LDS     R16, myUART
   \   0000003A   9110....           LDS     R17, (myUART + 1)
   \   0000003E   5F0F               SUBI    R16, 255
   \   00000040   4F1F               SBCI    R17, 255
   \   00000042   9300....           STS     myUART, R16
   \   00000046   9310....           STS     (myUART + 1), R17
    195              ntna = myUART.TxFirst;                                    // remember index
   \   0000004A   9120....           LDS     R18, myUART
   \   0000004E   9130....           LDS     R19, (myUART + 1)
    196              myUART.TxFirst += 2;                                      // two byte length
   \   00000052   5F0E               SUBI    R16, 254
   \   00000054   4F1F               SBCI    R17, 255
   \   00000056   9300....           STS     myUART, R16
   \   0000005A   9310....           STS     (myUART + 1), R17
    197          
    198              TxBufferCh0[myUART.TxFirst++] = PARTCODE;
   \   0000005E   01F8               MOVW    R31:R30, R17:R16
   \   00000060   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000062   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000064   E404               LDI     R16, 68
   \   00000066   8300               ST      Z, R16
   \   00000068   9100....           LDS     R16, myUART
   \   0000006C   9110....           LDS     R17, (myUART + 1)
   \   00000070   5F0F               SUBI    R16, 255
   \   00000072   4F1F               SBCI    R17, 255
   \   00000074   9300....           STS     myUART, R16
   \   00000078   9310....           STS     (myUART + 1), R17
    199              TxBufferCh0[myUART.TxFirst++] = SIGNATURE_BYTE_1;
   \   0000007C   01F8               MOVW    R31:R30, R17:R16
   \   0000007E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000080   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000082   E10E               LDI     R16, 30
   \   00000084   8300               ST      Z, R16
   \   00000086   9100....           LDS     R16, myUART
   \   0000008A   9110....           LDS     R17, (myUART + 1)
   \   0000008E   5F0F               SUBI    R16, 255
   \   00000090   4F1F               SBCI    R17, 255
   \   00000092   9300....           STS     myUART, R16
   \   00000096   9310....           STS     (myUART + 1), R17
    200              TxBufferCh0[myUART.TxFirst++] = SIGNATURE_BYTE_2;
   \   0000009A   01F8               MOVW    R31:R30, R17:R16
   \   0000009C   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000009E   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000A0   E907               LDI     R16, 151
   \   000000A2   8300               ST      Z, R16
   \   000000A4   9100....           LDS     R16, myUART
   \   000000A8   9110....           LDS     R17, (myUART + 1)
   \   000000AC   5F0F               SUBI    R16, 255
   \   000000AE   4F1F               SBCI    R17, 255
   \   000000B0   9300....           STS     myUART, R16
   \   000000B4   9310....           STS     (myUART + 1), R17
    201              TxBufferCh0[myUART.TxFirst++] = SIGNATURE_BYTE_3;
   \   000000B8   01F8               MOVW    R31:R30, R17:R16
   \   000000BA   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000BC   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000BE   E002               LDI     R16, 2
   \   000000C0   8300               ST      Z, R16
   \   000000C2   9100....           LDS     R16, myUART
   \   000000C6   9110....           LDS     R17, (myUART + 1)
   \   000000CA   5F0F               SUBI    R16, 255
   \   000000CC   4F1F               SBCI    R17, 255
   \   000000CE   9300....           STS     myUART, R16
   \   000000D2   9310....           STS     (myUART + 1), R17
    202          
    203          
    204              TxBufferCh0[ntna] = (myUART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000D6   ....               LDI     R30, LOW(TxBufferCh0)
   \   000000D8   ....               LDI     R31, (TxBufferCh0) >> 8
   \   000000DA   0FE2               ADD     R30, R18
   \   000000DC   1FF3               ADC     R31, R19
   \   000000DE   9180....           LDS     R24, myUART
   \   000000E2   9190....           LDS     R25, (myUART + 1)
   \   000000E6   1B02               SUB     R16, R18
   \   000000E8   5002               SUBI    R16, 2
   \   000000EA   8300               ST      Z, R16
    205              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000EC   1B82               SUB     R24, R18
   \   000000EE   0B93               SBC     R25, R19
   \   000000F0   9702               SBIW    R25:R24, 2
   \   000000F2   8391               STD     Z+1, R25
    206          
    207          }
   \   000000F4   01CA               MOVW    R25:R24, R21:R20
   \   000000F6   9508               RET
    208          
    209          /*************************************************************************
    210          *
    211          * Erase Flash 
    212          *
    213          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    214          void EraseFlash(void) {
   \                     EraseFlash:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
    215          
    216              unsigned short ntna, address;
    217              myUART.RxSendReply = true;                               // flag for answering
   \   00000008   E001               LDI     R16, 1
   \   0000000A   9300....           STS     (myUART + 24), R16
    218          
    219              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_ERASE & 0xff;
   \   0000000E   91E0....           LDS     R30, myUART
   \   00000012   91F0....           LDS     R31, (myUART + 1)
   \   00000016   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000018   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000001A   E90F               LDI     R16, 159
   \   0000001C   8300               ST      Z, R16
   \   0000001E   9100....           LDS     R16, myUART
   \   00000022   9110....           LDS     R17, (myUART + 1)
   \   00000026   5F0F               SUBI    R16, 255
   \   00000028   4F1F               SBCI    R17, 255
   \   0000002A   9300....           STS     myUART, R16
   \   0000002E   9310....           STS     (myUART + 1), R17
    220              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_ERASE >> 8;
   \   00000032   01F8               MOVW    R31:R30, R17:R16
   \   00000034   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000036   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000038   E007               LDI     R16, 7
   \   0000003A   8300               ST      Z, R16
   \   0000003C   9100....           LDS     R16, myUART
   \   00000040   9110....           LDS     R17, (myUART + 1)
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   9300....           STS     myUART, R16
   \   0000004C   9310....           STS     (myUART + 1), R17
    221              ntna = myUART.TxFirst;                                    // remember index
   \   00000050   91A0....           LDS     R26, myUART
   \   00000054   91B0....           LDS     R27, (myUART + 1)
    222              myUART.TxFirst += 2;                                      // two byte length
   \   00000058   5F0E               SUBI    R16, 254
   \   0000005A   4F1F               SBCI    R17, 255
   \   0000005C   9300....           STS     myUART, R16
   \   00000060   9310....           STS     (myUART + 1), R17
    223          
    224          #ifdef LARGE_MEMORY               //SPM uses Z pointer but the pointer is only 16bit and
    225              RAMPZ = 0x00;                     //can only address up to 64Kbytes FLASH to adresse higher
   \   00000064   E000               LDI     R16, 0
   \   00000066   BF0B               OUT     0x3B, R16
    226              //location it require the use of RAMPZ
    227          
    228              for ( address = 0; ((address < (unsigned int)(APP_END & 0xFFFF)) | (RAMPZ == 0x00)); address += PAGESIZE ) {
   \   00000068   E080               LDI     R24, 0
   \   0000006A   E090               LDI     R25, 0
   \                     ??EraseFlash_0:
   \   0000006C   E001               LDI     R16, 1
   \   0000006E   C012               RJMP    ??EraseFlash_1
    229                  write_page(address, (1 << PGERS) + (1 << SPMEN));              //Perform page erase
   \                     ??EraseFlash_2:
   \   00000070   E023               LDI     R18, 3
   \   00000072   018C               MOVW    R17:R16, R25:R24
   \   00000074   ........           CALL    write_page
    230                  write_page(address, (1 << REENABLE_RWW_BIT) + (1 << SPMEN));  //Re-enable the RWW section
   \   00000078   E121               LDI     R18, 17
   \   0000007A   018C               MOVW    R17:R16, R25:R24
   \   0000007C   ........           CALL    write_page
    231          
    232                  if ( address >= (0xFFFF - PAGESIZE) ) //Last section on lower 64k segment is erased
   \   00000080   3F8F               CPI     R24, 255
   \   00000082   EF0E               LDI     R16, 254
   \   00000084   0790               CPC     R25, R16
   \   00000086   F010               BRCS    ??EraseFlash_3
    233                      RAMPZ = (1 << RAMPZ0);         //RAMPZ has to incremented into upper 64k segment
   \   00000088   E001               LDI     R16, 1
   \   0000008A   BF0B               OUT     0x3B, R16
    234              }
   \                     ??EraseFlash_3:
   \   0000008C   9593               INC     R25
   \   0000008E   3E90               CPI     R25, 224
   \   00000090   F368               BRCS    ??EraseFlash_0
   \   00000092   E000               LDI     R16, 0
   \                     ??EraseFlash_1:
   \   00000094   B71B               IN      R17, 0x3B
   \   00000096   2311               TST     R17
   \   00000098   F359               BREQ    ??EraseFlash_2
   \   0000009A   2300               TST     R16
   \   0000009C   F749               BRNE    ??EraseFlash_2
    235              RAMPZ = 0x00;                     //Clear RAMPZ pointer
   \   0000009E   BF8B               OUT     0x3B, R24
    236          
    237          #else
    238          
    239              for ( address = 0; address < APP_END; address += PAGESIZE ) {  //Application section = 60 pages
    240                  write_page(address, (1 << PGERS) + (1 << SPMEN));       //Perform page erase
    241                  write_page(address, (1 << REENABLE_RWW_BIT) + (1 << SPMEN));  //Re-enable the RWW section
    242              }
    243          
    244          #endif
    245              TxBufferCh0[myUART.TxFirst++] = FLASH_ERASE_OK;                 // Answer that the erase is OK
   \   000000A0   91E0....           LDS     R30, myUART
   \   000000A4   91F0....           LDS     R31, (myUART + 1)
   \   000000A8   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000AA   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000AC   8380               ST      Z, R24
   \   000000AE   9100....           LDS     R16, myUART
   \   000000B2   9110....           LDS     R17, (myUART + 1)
   \   000000B6   5F0F               SUBI    R16, 255
   \   000000B8   4F1F               SBCI    R17, 255
   \   000000BA   9300....           STS     myUART, R16
   \   000000BE   9310....           STS     (myUART + 1), R17
    246          
    247              TxBufferCh0[ntna] = (myUART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000C2   ....               LDI     R30, LOW(TxBufferCh0)
   \   000000C4   ....               LDI     R31, (TxBufferCh0) >> 8
   \   000000C6   0FEA               ADD     R30, R26
   \   000000C8   1FFB               ADC     R31, R27
   \   000000CA   9180....           LDS     R24, myUART
   \   000000CE   9190....           LDS     R25, (myUART + 1)
   \   000000D2   1B0A               SUB     R16, R26
   \   000000D4   5002               SUBI    R16, 2
   \   000000D6   8300               ST      Z, R16
    248              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000D8   1B8A               SUB     R24, R26
   \   000000DA   0B9B               SBC     R25, R27
   \   000000DC   9702               SBIW    R25:R24, 2
   \   000000DE   8391               STD     Z+1, R25
    249          
    250          }
   \   000000E0                      REQUIRE ?Subroutine0
   \   000000E0                      REQUIRE _A_RAMPZ
   \   000000E0                      ;               // Fall through to label ?Subroutine0
    251          
    252          /*************************************************************************
    253          *
    254          * Program Flash 
    255          *
    256          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    257          void ProgramFlash(unsigned Pointer) {
   \                     ProgramFlash:
   \   00000000   92DA               ST      -Y, R13
   \   00000002   92CA               ST      -Y, R12
   \   00000004   92BA               ST      -Y, R11
   \   00000006   92AA               ST      -Y, R10
   \   00000008   929A               ST      -Y, R9
   \   0000000A   928A               ST      -Y, R8
   \   0000000C   927A               ST      -Y, R7
   \   0000000E   926A               ST      -Y, R6
   \   00000010   925A               ST      -Y, R5
   \   00000012   924A               ST      -Y, R4
   \   00000014   93BA               ST      -Y, R27
   \   00000016   93AA               ST      -Y, R26
   \   00000018   939A               ST      -Y, R25
   \   0000001A   938A               ST      -Y, R24
   \   0000001C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R6_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R7_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R8_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R9_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R10_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R11_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R12_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R13_is_cg_reg
   \   0000001C   0128               MOVW    R5:R4, R17:R16
    258          
    259              unsigned ntna;
    260              myUART.RxSendReply = true;                               // flag for answering
   \   0000001E   E001               LDI     R16, 1
   \   00000020   9300....           STS     (myUART + 24), R16
    261          
    262              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_PROG & 0xff;
   \   00000024   91E0....           LDS     R30, myUART
   \   00000028   91F0....           LDS     R31, (myUART + 1)
   \   0000002C   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000002E   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000030   EA09               LDI     R16, 169
   \   00000032   8300               ST      Z, R16
   \   00000034   9100....           LDS     R16, myUART
   \   00000038   9110....           LDS     R17, (myUART + 1)
   \   0000003C   5F0F               SUBI    R16, 255
   \   0000003E   4F1F               SBCI    R17, 255
   \   00000040   9300....           STS     myUART, R16
   \   00000044   9310....           STS     (myUART + 1), R17
    263              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_PROG >> 8;
   \   00000048   01F8               MOVW    R31:R30, R17:R16
   \   0000004A   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000004C   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000004E   E007               LDI     R16, 7
   \   00000050   8300               ST      Z, R16
   \   00000052   9100....           LDS     R16, myUART
   \   00000056   9110....           LDS     R17, (myUART + 1)
   \   0000005A   5F0F               SUBI    R16, 255
   \   0000005C   4F1F               SBCI    R17, 255
   \   0000005E   9300....           STS     myUART, R16
   \   00000062   9310....           STS     (myUART + 1), R17
    264              ntna = myUART.TxFirst;                                    // remember index
   \   00000066   90C0....           LDS     R12, myUART
   \   0000006A   90D0....           LDS     R13, (myUART + 1)
    265              myUART.TxFirst += 2;                                      // two byte length
   \   0000006E   5F0E               SUBI    R16, 254
   \   00000070   4F1F               SBCI    R17, 255
   \   00000072   9300....           STS     myUART, R16
   \   00000076   9310....           STS     (myUART + 1), R17
    266          
    267              unsigned Address = RxBufferCh0[Pointer + 0] + (RxBufferCh0[Pointer + 1] << 8); // save address
   \   0000007A   ....               LDI     R30, LOW(RxBufferCh0)
   \   0000007C   ....               LDI     R31, (RxBufferCh0) >> 8
   \   0000007E   0DE4               ADD     R30, R4
   \   00000080   1DF5               ADC     R31, R5
   \   00000082   8180               LD      R24, Z
   \   00000084   8191               LDD     R25, Z+1
    268              unsigned Nobytes = RxBufferCh0[Pointer + 2] + (RxBufferCh0[Pointer + 3] << 8); // save address
   \   00000086   8062               LDD     R6, Z+2
   \   00000088   8073               LDD     R7, Z+3
    269              Pointer += 4;
   \   0000008A   E004               LDI     R16, 4
   \   0000008C   0E40               ADD     R4, R16
   \   0000008E   E000               LDI     R16, 0
   \   00000090   1E50               ADC     R5, R16
    270              unsigned Ptr = Pointer;
    271              if ( Nobytes > PAGESIZE ) {
   \   00000092   E001               LDI     R16, 1
   \   00000094   1660               CP      R6, R16
   \   00000096   0670               CPC     R7, R16
   \   00000098   F088               BRCS    ??ProgramFlash_0
    272                  TxBufferCh0[myUART.TxFirst++] = FLASH_PROG_PAGEF;               // Answer with Page fault
   \   0000009A   91E0....           LDS     R30, myUART
   \   0000009E   2FF1               MOV     R31, R17
   \   000000A0   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000A2   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000A4   8300               ST      Z, R16
   \   000000A6   9100....           LDS     R16, myUART
   \   000000AA   9110....           LDS     R17, (myUART + 1)
   \   000000AE   5F0F               SUBI    R16, 255
   \   000000B0   4F1F               SBCI    R17, 255
   \   000000B2   9300....           STS     myUART, R16
   \   000000B6   9310....           STS     (myUART + 1), R17
   \   000000BA   C06B               RJMP    ??ProgramFlash_1
    273              } else {
    274          #ifdef LARGE_MEMORY
    275                  if ( Address >= 0x7FFF ) {
   \                     ??ProgramFlash_0:
   \   000000BC   3F8F               CPI     R24, 255
   \   000000BE   E70F               LDI     R16, 127
   \   000000C0   0790               CPC     R25, R16
   \   000000C2   F010               BRCS    ??ProgramFlash_2
    276                      RAMPZ = (1 << RAMPZ0);
   \   000000C4   E001               LDI     R16, 1
   \   000000C6   C001               RJMP    ??ProgramFlash_3
    277                  } else {
    278                      RAMPZ = 0;
   \                     ??ProgramFlash_2:
   \   000000C8   E000               LDI     R16, 0
   \                     ??ProgramFlash_3:
   \   000000CA   BF0B               OUT     0x3B, R16
    279                  }
    280          #endif
    281                  Address = Address << 1;                                     // convert from byte address to word address
   \   000000CC   0F88               LSL     R24
   \   000000CE   1F99               ROL     R25
    282                  unsigned Addr = Address;                                             // mirror the address
   \   000000D0   015C               MOVW    R11:R10, R25:R24
    283                  for ( unsigned i = 0; i < Nobytes; i += 2, Address += 2, Pointer += 2 ) {              // write data to flash
   \   000000D2   2488               CLR     R8
   \   000000D4   2499               CLR     R9
   \   000000D6   2D06               MOV     R16, R6
   \   000000D8   2907               OR      R16, R7
   \   000000DA   F099               BREQ    ??ProgramFlash_4
   \   000000DC   ....               LDI     R26, LOW(RxBufferCh0)
   \   000000DE   ....               LDI     R27, (RxBufferCh0) >> 8
   \   000000E0   0DA4               ADD     R26, R4
   \   000000E2   1DB5               ADC     R27, R5
    284                      fill_temp_buffer(RxBufferCh0[Pointer] + (RxBufferCh0[Pointer + 1] << 8), (Address)); //call asm routine.
   \                     ??ProgramFlash_5:
   \   000000E4   019C               MOVW    R19:R18, R25:R24
   \   000000E6   910C               LD      R16, X
   \   000000E8   01FD               MOVW    R31:R30, R27:R26
   \   000000EA   8111               LDD     R17, Z+1
   \   000000EC   ........           CALL    fill_temp_buffer
    285                  }
   \   000000F0   E002               LDI     R16, 2
   \   000000F2   0E80               ADD     R8, R16
   \   000000F4   E000               LDI     R16, 0
   \   000000F6   1E90               ADC     R9, R16
   \   000000F8   9602               ADIW    R25:R24, 2
   \   000000FA   9612               ADIW    R27:R26, 2
   \   000000FC   1486               CP      R8, R6
   \   000000FE   0497               CPC     R9, R7
   \   00000100   F388               BRCS    ??ProgramFlash_5
    286                  write_page(Addr, (1 << PGWRT) + (1 << SPMEN));                  //Perform page write
   \                     ??ProgramFlash_4:
   \   00000102   E025               LDI     R18, 5
   \   00000104   0185               MOVW    R17:R16, R11:R10
   \   00000106   ........           CALL    write_page
    287                  write_page(Addr, (1 << REENABLE_RWW_BIT) + (1 << SPMEN));       //Re-enable the RWW section
   \   0000010A   E121               LDI     R18, 17
   \   0000010C   0185               MOVW    R17:R16, R11:R10
   \   0000010E   ........           CALL    write_page
    288                  TxBufferCh0[myUART.TxFirst++] = FLASH_PROG_OK;       // OK
   \   00000112   91E0....           LDS     R30, myUART
   \   00000116   91F0....           LDS     R31, (myUART + 1)
   \   0000011A   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000011C   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000011E   E000               LDI     R16, 0
   \   00000120   8300               ST      Z, R16
   \   00000122   9100....           LDS     R16, myUART
   \   00000126   9110....           LDS     R17, (myUART + 1)
   \   0000012A   5F0F               SUBI    R16, 255
   \   0000012C   4F1F               SBCI    R17, 255
   \   0000012E   9300....           STS     myUART, R16
   \   00000132   9310....           STS     (myUART + 1), R17
    289          
    290                  for ( unsigned i = 0; i < Nobytes; i += 2, Addr += 2 ) {         // check the whole buffer
   \   00000136   E080               LDI     R24, 0
   \   00000138   E090               LDI     R25, 0
   \   0000013A   2D06               MOV     R16, R6
   \   0000013C   2907               OR      R16, R7
   \   0000013E   F149               BREQ    ??ProgramFlash_1
   \   00000140   ....               LDI     R26, LOW(RxBufferCh0)
   \   00000142   ....               LDI     R27, (RxBufferCh0) >> 8
   \   00000144   0DA4               ADD     R26, R4
   \   00000146   1DB5               ADC     R27, R5
   \   00000148   E002               LDI     R16, 2
   \   0000014A   2E40               MOV     R4, R16
    291                      unsigned intval = read_program_memory(Addr, 0x00);
   \                     ??ProgramFlash_6:
   \   0000014C   E020               LDI     R18, 0
   \   0000014E   0185               MOVW    R17:R16, R11:R10
   \   00000150   ........           CALL    read_program_memory
    292                      if ( RxBufferCh0[Ptr++] != (intval & 0xff) ) {
   \   00000154   914C               LD      R20, X
   \   00000156   E050               LDI     R21, 0
   \   00000158   1740               CP      R20, R16
   \   0000015A   0755               CPC     R21, R21
   \   0000015C   F039               BREQ    ??ProgramFlash_7
    293                          TxBufferCh0[myUART.TxFirst - 1] = FLASH_PROG_ERROR;       // compare error
   \   0000015E   91E0....           LDS     R30, myUART
   \   00000162   91F0....           LDS     R31, (myUART + 1)
   \   00000166   ....               SUBI    R30, LOW((-(TxBufferCh0 - 1) & 0xFFFF))
   \   00000168   ....               SBCI    R31, HIGH((-(TxBufferCh0 - 1) & 0xFFFF))
   \   0000016A   8240               ST      Z, R4
    294                      }
    295                      if ( RxBufferCh0[Ptr++] != ((intval >> 8) & 0xff) ) {
   \                     ??ProgramFlash_7:
   \   0000016C   01FD               MOVW    R31:R30, R27:R26
   \   0000016E   8101               LDD     R16, Z+1
   \   00000170   1701               CP      R16, R17
   \   00000172   0755               CPC     R21, R21
   \   00000174   F039               BREQ    ??ProgramFlash_8
    296                          TxBufferCh0[myUART.TxFirst - 1] = FLASH_PROG_ERROR;       // compare error
   \   00000176   91E0....           LDS     R30, myUART
   \   0000017A   91F0....           LDS     R31, (myUART + 1)
   \   0000017E   ....               SUBI    R30, LOW((-(TxBufferCh0 - 1) & 0xFFFF))
   \   00000180   ....               SBCI    R31, HIGH((-(TxBufferCh0 - 1) & 0xFFFF))
   \   00000182   8240               ST      Z, R4
    297                      }
    298                  }
   \                     ??ProgramFlash_8:
   \   00000184   9602               ADIW    R25:R24, 2
   \   00000186   0CA4               ADD     R10, R4
   \   00000188   1EB5               ADC     R11, R21
   \   0000018A   9612               ADIW    R27:R26, 2
   \   0000018C   1586               CP      R24, R6
   \   0000018E   0597               CPC     R25, R7
   \   00000190   F2E8               BRCS    ??ProgramFlash_6
    299              }
    300          
    301              TxBufferCh0[ntna] = (myUART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \                     ??ProgramFlash_1:
   \   00000192   ....               LDI     R30, LOW(TxBufferCh0)
   \   00000194   ....               LDI     R31, (TxBufferCh0) >> 8
   \   00000196   0DEC               ADD     R30, R12
   \   00000198   1DFD               ADC     R31, R13
   \   0000019A   9180....           LDS     R24, myUART
   \   0000019E   9190....           LDS     R25, (myUART + 1)
   \   000001A2   2F08               MOV     R16, R24
   \   000001A4   190C               SUB     R16, R12
   \   000001A6   5002               SUBI    R16, 2
   \   000001A8   8300               ST      Z, R16
    302              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000001AA   198C               SUB     R24, R12
   \   000001AC   099D               SBC     R25, R13
   \   000001AE   9702               SBIW    R25:R24, 2
   \   000001B0   8391               STD     Z+1, R25
    303          
    304          }
   \   000001B2   9189               LD      R24, Y+
   \   000001B4   9199               LD      R25, Y+
   \   000001B6   91A9               LD      R26, Y+
   \   000001B8   91B9               LD      R27, Y+
   \   000001BA   9049               LD      R4, Y+
   \   000001BC   9059               LD      R5, Y+
   \   000001BE   9069               LD      R6, Y+
   \   000001C0   9079               LD      R7, Y+
   \   000001C2   9089               LD      R8, Y+
   \   000001C4   9099               LD      R9, Y+
   \   000001C6   90A9               LD      R10, Y+
   \   000001C8   90B9               LD      R11, Y+
   \   000001CA   90C9               LD      R12, Y+
   \   000001CC   90D9               LD      R13, Y+
   \   000001CE   9508               RET
   \   000001D0                      REQUIRE _A_RAMPZ
    305          
    306          /*************************************************************************
    307          *
    308          * Read Flash 
    309          *
    310          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    311          void ReadFlash(unsigned Pointer) {
   \                     ReadFlash:
   \   00000000   927A               ST      -Y, R7
   \   00000002   926A               ST      -Y, R6
   \   00000004   925A               ST      -Y, R5
   \   00000006   924A               ST      -Y, R4
   \   00000008   93BA               ST      -Y, R27
   \   0000000A   93AA               ST      -Y, R26
   \   0000000C   939A               ST      -Y, R25
   \   0000000E   938A               ST      -Y, R24
   \   00000010                      REQUIRE ?Register_R4_is_cg_reg
   \   00000010                      REQUIRE ?Register_R5_is_cg_reg
   \   00000010                      REQUIRE ?Register_R6_is_cg_reg
   \   00000010                      REQUIRE ?Register_R7_is_cg_reg
    312          
    313              unsigned short ntna, intval;
                                          ^
Warning[Pe177]: variable "intval" was declared but never referenced
    314              myUART.RxSendReply = true;                               // flag for answering
   \   00000010   E021               LDI     R18, 1
   \   00000012   9320....           STS     (myUART + 24), R18
    315          
    316              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_READ & 0xff;
   \   00000016   91E0....           LDS     R30, myUART
   \   0000001A   91F0....           LDS     R31, (myUART + 1)
   \   0000001E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000020   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000022   EB23               LDI     R18, 179
   \   00000024   8320               ST      Z, R18
   \   00000026   9120....           LDS     R18, myUART
   \   0000002A   9130....           LDS     R19, (myUART + 1)
   \   0000002E   5F2F               SUBI    R18, 255
   \   00000030   4F3F               SBCI    R19, 255
   \   00000032   9320....           STS     myUART, R18
   \   00000036   9330....           STS     (myUART + 1), R19
    317              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_READ >> 8;
   \   0000003A   01F9               MOVW    R31:R30, R19:R18
   \   0000003C   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000003E   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000040   E027               LDI     R18, 7
   \   00000042   8320               ST      Z, R18
   \   00000044   9120....           LDS     R18, myUART
   \   00000048   9130....           LDS     R19, (myUART + 1)
   \   0000004C   5F2F               SUBI    R18, 255
   \   0000004E   4F3F               SBCI    R19, 255
   \   00000050   9320....           STS     myUART, R18
   \   00000054   9330....           STS     (myUART + 1), R19
    318              ntna = myUART.TxFirst;                                    // remember index
   \   00000058   9060....           LDS     R6, myUART
   \   0000005C   9070....           LDS     R7, (myUART + 1)
    319              myUART.TxFirst += 2;                                      // two byte length
   \   00000060   5F2E               SUBI    R18, 254
   \   00000062   4F3F               SBCI    R19, 255
   \   00000064   9320....           STS     myUART, R18
   \   00000068   9330....           STS     (myUART + 1), R19
    320          
    321              for ( unsigned i = 0; i < 4; i++ ) {
   \   0000006C   ....               LDI     R26, LOW(RxBufferCh0)
   \   0000006E   ....               LDI     R27, (RxBufferCh0) >> 8
   \   00000070   0FA0               ADD     R26, R16
   \   00000072   1FB1               ADC     R27, R17
   \   00000074   018D               MOVW    R17:R16, R27:R26
   \   00000076   E024               LDI     R18, 4
    322                  TxBufferCh0[myUART.TxFirst++] = RxBufferCh0[Pointer + i]; // ansver with address and nob
   \                     ??ReadFlash_0:
   \   00000078   01F8               MOVW    R31:R30, R17:R16
   \   0000007A   9131               LD      R19, Z+
   \   0000007C   018F               MOVW    R17:R16, R31:R30
   \   0000007E   91E0....           LDS     R30, myUART
   \   00000082   91F0....           LDS     R31, (myUART + 1)
   \   00000086   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000088   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000008A   8330               ST      Z, R19
   \   0000008C   9140....           LDS     R20, myUART
   \   00000090   9150....           LDS     R21, (myUART + 1)
   \   00000094   5F4F               SUBI    R20, 255
   \   00000096   4F5F               SBCI    R21, 255
   \   00000098   9340....           STS     myUART, R20
   \   0000009C   9350....           STS     (myUART + 1), R21
    323              }
   \   000000A0   952A               DEC     R18
   \   000000A2   F751               BRNE    ??ReadFlash_0
    324          
    325              unsigned Address = RxBufferCh0[Pointer + 0] + (RxBufferCh0[Pointer + 1] << 8); // save address
   \   000000A4   918C               LD      R24, X
   \   000000A6   01FD               MOVW    R31:R30, R27:R26
   \   000000A8   8191               LDD     R25, Z+1
    326              unsigned Nobytes = RxBufferCh0[Pointer + 2] + (RxBufferCh0[Pointer + 3] << 8); // save address
   \   000000AA   8042               LDD     R4, Z+2
   \   000000AC   8053               LDD     R5, Z+3
    327              if ( Nobytes > PAGESIZE ) {
   \   000000AE   E001               LDI     R16, 1
   \   000000B0   1640               CP      R4, R16
   \   000000B2   0650               CPC     R5, R16
   \   000000B4   F090               BRCS    ??ReadFlash_1
    328                  TxBufferCh0[myUART.TxFirst++] = FLASH_PROG_PAGEF;               // Answer with Page fault
   \   000000B6   91E0....           LDS     R30, myUART
   \   000000BA   91F0....           LDS     R31, (myUART + 1)
   \   000000BE   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000C0   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000C2   8300               ST      Z, R16
   \   000000C4   9100....           LDS     R16, myUART
   \   000000C8   9110....           LDS     R17, (myUART + 1)
   \   000000CC   5F0F               SUBI    R16, 255
   \   000000CE   4F1F               SBCI    R17, 255
   \   000000D0   9300....           STS     myUART, R16
   \   000000D4   9310....           STS     (myUART + 1), R17
   \   000000D8   C038               RJMP    ??ReadFlash_2
    329              } else {
    330          #ifdef LARGE_MEMORY
    331                  if ( Address >= 0x7FFF ) {
   \                     ??ReadFlash_1:
   \   000000DA   3F8F               CPI     R24, 255
   \   000000DC   E70F               LDI     R16, 127
   \   000000DE   0790               CPC     R25, R16
   \   000000E0   F010               BRCS    ??ReadFlash_3
    332                      RAMPZ = (1 << RAMPZ0);
   \   000000E2   E001               LDI     R16, 1
   \   000000E4   C001               RJMP    ??ReadFlash_4
    333                  } else {
    334                      RAMPZ = 0;
   \                     ??ReadFlash_3:
   \   000000E6   E000               LDI     R16, 0
   \                     ??ReadFlash_4:
   \   000000E8   BF0B               OUT     0x3B, R16
    335                  }
    336          #endif
    337                  Address = Address << 1;             // convert from byte address to word address
   \   000000EA   0F88               LSL     R24
   \   000000EC   1F99               ROL     R25
    338                  for ( unsigned i = 0; i < Nobytes; i += 2, Address += 2 ) {   // receive the whole buffer
   \   000000EE   E0A0               LDI     R26, 0
   \   000000F0   E0B0               LDI     R27, 0
   \   000000F2   2D04               MOV     R16, R4
   \   000000F4   2905               OR      R16, R5
   \   000000F6   F149               BREQ    ??ReadFlash_2
    339                      unsigned intval = read_program_memory(Address, 0x00);
   \                     ??ReadFlash_5:
   \   000000F8   E020               LDI     R18, 0
   \   000000FA   018C               MOVW    R17:R16, R25:R24
   \   000000FC   ........           CALL    read_program_memory
   \   00000100   2F31               MOV     R19, R17
    340                      TxBufferCh0[myUART.TxFirst++] = intval & 0xff;
   \   00000102   91E0....           LDS     R30, myUART
   \   00000106   91F0....           LDS     R31, (myUART + 1)
   \   0000010A   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000010C   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000010E   8300               ST      Z, R16
   \   00000110   9100....           LDS     R16, myUART
   \   00000114   9110....           LDS     R17, (myUART + 1)
   \   00000118   5F0F               SUBI    R16, 255
   \   0000011A   4F1F               SBCI    R17, 255
   \   0000011C   9300....           STS     myUART, R16
   \   00000120   9310....           STS     (myUART + 1), R17
    341                      TxBufferCh0[myUART.TxFirst++] = (intval >> 8) & 0xff;
   \   00000124   01F8               MOVW    R31:R30, R17:R16
   \   00000126   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000128   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000012A   8330               ST      Z, R19
   \   0000012C   9100....           LDS     R16, myUART
   \   00000130   9110....           LDS     R17, (myUART + 1)
   \   00000134   5F0F               SUBI    R16, 255
   \   00000136   4F1F               SBCI    R17, 255
   \   00000138   9300....           STS     myUART, R16
   \   0000013C   9310....           STS     (myUART + 1), R17
    342                  }
   \   00000140   9612               ADIW    R27:R26, 2
   \   00000142   9602               ADIW    R25:R24, 2
   \   00000144   15A4               CP      R26, R4
   \   00000146   05B5               CPC     R27, R5
   \   00000148   F2B8               BRCS    ??ReadFlash_5
    343              }
    344          
    345              TxBufferCh0[ntna] = (myUART.TxFirst  - ntna - 2) & 0xff;      // length of data block lb
   \                     ??ReadFlash_2:
   \   0000014A   ....               LDI     R30, LOW(TxBufferCh0)
   \   0000014C   ....               LDI     R31, (TxBufferCh0) >> 8
   \   0000014E   0DE6               ADD     R30, R6
   \   00000150   1DF7               ADC     R31, R7
   \   00000152   9180....           LDS     R24, myUART
   \   00000156   9190....           LDS     R25, (myUART + 1)
   \   0000015A   2F08               MOV     R16, R24
   \   0000015C   1906               SUB     R16, R6
   \   0000015E   5002               SUBI    R16, 2
   \   00000160   8300               ST      Z, R16
    346              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000162   1986               SUB     R24, R6
   \   00000164   0997               SBC     R25, R7
   \   00000166   9702               SBIW    R25:R24, 2
   \   00000168   8391               STD     Z+1, R25
    347          
    348          }
   \   0000016A   9189               LD      R24, Y+
   \   0000016C   9199               LD      R25, Y+
   \   0000016E   91A9               LD      R26, Y+
   \   00000170   91B9               LD      R27, Y+
   \   00000172   9049               LD      R4, Y+
   \   00000174   9059               LD      R5, Y+
   \   00000176   9069               LD      R6, Y+
   \   00000178   9079               LD      R7, Y+
   \   0000017A   9508               RET
   \   0000017C                      REQUIRE _A_RAMPZ
    349          
    350          /*************************************************************************
    351          *
    352          *  Exit bootloader program
    353          *
    354          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    355          void ExitBootloader(char ch) {
   \                     ExitBootloader:
    356          
    357          
    358              while ( (EECR & 1 << EEPE) != 0 ) //chech if EEPROM is ready
   \                     ??ExitBootloader_0:
   \   00000000   99F9               SBIC    0x1F, 0x01
   \   00000002   CFFE               RJMP    ??ExitBootloader_0
    359              ;
    360              EEARL = (0x0fff & 0xff);
   \   00000004   EF0F               LDI     R16, 255
   \   00000006   BD01               OUT     0x21, R16
    361              EEARH = (0x0fff >> 8);
   \   00000008   E00F               LDI     R16, 15
   \   0000000A   BD02               OUT     0x22, R16
    362              EEDR = 0xaa;
   \   0000000C   EA0A               LDI     R16, 170
   \   0000000E   BD00               OUT     0x20, R16
    363              EECR |= (1 << EEMPE);
   \   00000010   9AFA               SBI     0x1F, 0x02
    364              EECR |= (1 << EEPE);
   \   00000012   9AF9               SBI     0x1F, 0x01
    365              while ( EECR & (1 << EEPE) );
   \                     ??ExitBootloader_1:
   \   00000014   99F9               SBIC    0x1F, 0x01
   \   00000016   CFFE               RJMP    ??ExitBootloader_1
    366              WDTCSR = 0x08;               //Start watchdog to genetate restart
   \   00000018   E008               LDI     R16, 8
   \   0000001A   9300....           STS     _A_WDTCSR, R16
    367              //AppStart();        					// Jump to Reset vector 0x0000 in Application Section
    368          
    369          }
   \   0000001E   9508               RET
   \   00000020                      REQUIRE _A_EECR
   \   00000020                      REQUIRE _A_EEAR
   \   00000020                      REQUIRE _A_EEDR
   \   00000020                      REQUIRE _A_WDTCSR
    370          
    371          
    372          /*************************************************************************
    373          *
    374          *  Transmitting data on USARTs
    375          *
    376          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    377          void SendPacketUart(void) {
   \                     SendPacketUart:
    378              unsigned cnt = 0;
    379          
    380              for ( unsigned delay = 0; delay < 0xffff; delay++ ) {
   \   00000000   EFEF               LDI     R30, 255
   \   00000002   EFFF               LDI     R31, 255
    381                  asm("nop");
   \                     ??SendPacketUart_0:
   \   00000004   0000               nop
    382                  cnt++;
    383              }
   \   00000006   9731               SBIW    R31:R30, 1
   \   00000008   F7E9               BRNE    ??SendPacketUart_0
    384          
    385              while ( myUART.TxCount > 0 ) {               // Any characters to send?
   \                     ??SendPacketUart_1:
   \   0000000A   9100....           LDS     R16, (myUART + 4)
   \   0000000E   9110....           LDS     R17, (myUART + 5)
   \   00000012   2B01               OR      R16, R17
   \   00000014   F119               BREQ    ??SendPacketUart_2
    386                  sendchar(TxBufferCh0[myUART.TxLast]);  // Send a character
   \   00000016   91E0....           LDS     R30, (myUART + 2)
   \   0000001A   91F0....           LDS     R31, (myUART + 3)
   \   0000001E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000020   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000022   8100               LD      R16, Z
   \   00000024   ........           CALL    sendchar
    387          
    388                  if ( (++myUART.TxLast) > TXSIZE_UART ) {     // End of buffer?
   \   00000028   91E0....           LDS     R30, (myUART + 2)
   \   0000002C   91F0....           LDS     R31, (myUART + 3)
   \   00000030   9631               ADIW    R31:R30, 1
   \   00000032   35EF               CPI     R30, 95
   \   00000034   E001               LDI     R16, 1
   \   00000036   07F0               CPC     R31, R16
   \   00000038   F010               BRCS    ??SendPacketUart_3
    389                      myUART.TxLast = 0;                     // yes, reset pointer
   \   0000003A   E0E0               LDI     R30, 0
   \   0000003C   E0F0               LDI     R31, 0
   \                     ??SendPacketUart_3:
   \   0000003E   93E0....           STS     (myUART + 2), R30
   \   00000042   93F0....           STS     (myUART + 3), R31
    390                  }
    391                  myUART.TxCount--;
   \   00000046   9100....           LDS     R16, (myUART + 4)
   \   0000004A   9110....           LDS     R17, (myUART + 5)
   \   0000004E   5001               SUBI    R16, 1
   \   00000050   4010               SBCI    R17, 0
   \   00000052   9300....           STS     (myUART + 4), R16
   \   00000056   9310....           STS     (myUART + 5), R17
   \   0000005A   CFD7               RJMP    ??SendPacketUart_1
    392              }
    393              PORTE &= ~0x04;                                     // TXE0 off
   \                     ??SendPacketUart_2:
   \   0000005C   9872               CBI     0x0E, 0x02
    394              cnt = 0;
    395          }
   \   0000005E   9508               RET
   \   00000060                      REQUIRE _A_PORTE
    396          
    397          /*************************************************************************
    398          *
    399          *  Receive data on USARTs
    400          *
    401          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    402          void ReceivePacketUart(char ch) {
   \                     ReceivePacketUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
    403          
    404              switch ( myUART.RxState ) {                  // check status
   \   00000008   9100....           LDS     R16, (myUART + 16)
   \   0000000C   2300               TST     R16
   \   0000000E   F409               BRNE    $+2+2
   \   00000010   C094               RJMP    ??ReceivePacketUart_0
   \   00000012   950A               DEC     R16
   \   00000014   F039               BREQ    ??ReceivePacketUart_1
   \   00000016   950A               DEC     R16
   \   00000018   F409               BRNE    $+2+2
   \   0000001A   C04C               RJMP    ??ReceivePacketUart_2
   \   0000001C   5008               SUBI    R16, 8
   \   0000001E   F409               BRNE    $+2+2
   \   00000020   C08C               RJMP    ??ReceivePacketUart_0
   \   00000022   C08A               RJMP    ??ReceivePacketUart_3
    405              case SYNC :
    406                  // all functionallity in inerrupt routine
    407                  break;
    408              case HEADER :
    409                  if ( myUART.RxLast >= 6 ) {             // receive header
   \                     ??ReceivePacketUart_1:
   \   00000024   9180....           LDS     R24, (myUART + 12)
   \   00000028   9190....           LDS     R25, (myUART + 13)
   \   0000002C   3086               CPI     R24, 6
   \   0000002E   E000               LDI     R16, 0
   \   00000030   0790               CPC     R25, R16
   \   00000032   F408               BRCC    $+2+2
   \   00000034   C082               RJMP    ??ReceivePacketUart_0
    410                      myUART.RxPacklen = (RxBufferCh0[4] +
    411                                          (RxBufferCh0[5] * 256));    // Find length of package
   \   00000036   9100....           LDS     R16, (RxBufferCh0 + 4)
   \   0000003A   9110....           LDS     R17, (RxBufferCh0 + 5)
   \   0000003E   9300....           STS     (myUART + 20), R16
   \   00000042   9310....           STS     (myUART + 21), R17
    412                      if ( CalcDSRxChecksum(ch, 6) && (RxBufferCh0[0] == (0x10 + UnitID)) ) {
   \   00000046   E010               LDI     R17, 0
   \   00000048   ....               LDI     R26, LOW(RxBufferCh0)
   \   0000004A   ....               LDI     R27, (RxBufferCh0) >> 8
   \   0000004C   E006               LDI     R16, 6
   \   0000004E   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_4:
   \   00000050   E0F0               LDI     R31, 0
   \   00000052   912D               LD      R18, X+
   \   00000054   2712               EOR     R17, R18
   \   00000056   2FE1               MOV     R30, R17
   \   00000058   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000005A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000005C   BF3B               OUT     0x3B, R19
   \   0000005E   9116               ELPM    R17, Z
   \   00000060   950A               DEC     R16
   \   00000062   F7B1               BRNE    ??ReceivePacketUart_4
   \   00000064   9100....           LDS     R16, (RxBufferCh0 + 6)
   \   00000068   1710               CP      R17, R16
   \   0000006A   F009               BREQ    $+2+2
   \   0000006C   C065               RJMP    ??ReceivePacketUart_3
   \   0000006E   9100....           LDS     R16, RxBufferCh0
   \   00000072   E010               LDI     R17, 0
   \   00000074   91E0....           LDS     R30, UnitID
   \   00000078   E0F0               LDI     R31, 0
   \   0000007A   9670               ADIW    R31:R30, 16
   \   0000007C   170E               CP      R16, R30
   \   0000007E   071F               CPC     R17, R31
   \   00000080   F009               BREQ    $+2+2
   \   00000082   C05A               RJMP    ??ReceivePacketUart_3
    413                          // header checksum OK and to me
    414                          if ( (myUART.RxPacklen < ((short)RXSIZE_UART - myUART.RxLast)) &&    /* chk. header */
    415                               (myUART.RxPacklen >= MIN_PACK_LEN) ) {
   \   00000084   91E0....           LDS     R30, (myUART + 20)
   \   00000088   91F0....           LDS     R31, (myUART + 21)
   \   0000008C   E50E               LDI     R16, 94
   \   0000008E   E011               LDI     R17, 1
   \   00000090   1B08               SUB     R16, R24
   \   00000092   0B19               SBC     R17, R25
   \   00000094   17E0               CP      R30, R16
   \   00000096   07F1               CPC     R31, R17
   \   00000098   F008               BRCS    $+2+2
   \   0000009A   C04E               RJMP    ??ReceivePacketUart_3
   \   0000009C   9737               SBIW    R31:R30, 7
   \   0000009E   F408               BRCC    $+2+2
   \   000000A0   C04B               RJMP    ??ReceivePacketUart_3
    416                              myUART.RxState = RECEIVE;       // Header ok og to data receive state
   \   000000A2   E002               LDI     R16, 2
   \   000000A4   9300....           STS     (myUART + 16), R16
    417                              myUART.RxCount = myUART.RxLast + 1;    // Set receive counter
   \   000000A8   9601               ADIW    R25:R24, 1
   \   000000AA   9380....           STS     (myUART + 14), R24
   \   000000AE   9390....           STS     (myUART + 15), R25
   \   000000B2   C043               RJMP    ??ReceivePacketUart_0
    418                          } else {
    419                              GoToSyncUART();                        // go to sync modus for recive
    420                          }
    421                      } else {
    422                          GoToSyncUART();                            // go to sync modus for recive
    423                      }
    424                  }
    425                  break;
    426              case RECEIVE :
    427                  if ( ++myUART.RxCount >= myUART.RxPacklen ) {
   \                     ??ReceivePacketUart_2:
   \   000000B4   9100....           LDS     R16, (myUART + 14)
   \   000000B8   9110....           LDS     R17, (myUART + 15)
   \   000000BC   5F0F               SUBI    R16, 255
   \   000000BE   4F1F               SBCI    R17, 255
   \   000000C0   9300....           STS     (myUART + 14), R16
   \   000000C4   9310....           STS     (myUART + 15), R17
   \   000000C8   9140....           LDS     R20, (myUART + 20)
   \   000000CC   9150....           LDS     R21, (myUART + 21)
   \   000000D0   1704               CP      R16, R20
   \   000000D2   0715               CPC     R17, R21
   \   000000D4   F190               BRCS    ??ReceivePacketUart_0
    428                      if ( (RxBufferCh0[myUART.RxPacklen - 1]) == ANPRO10_EOT ) {
   \   000000D6   01FA               MOVW    R31:R30, R21:R20
   \   000000D8   ....               SUBI    R30, LOW((-(RxBufferCh0 - 1) & 0xFFFF))
   \   000000DA   ....               SBCI    R31, HIGH((-(RxBufferCh0 - 1) & 0xFFFF))
   \   000000DC   8100               LD      R16, Z
   \   000000DE   3004               CPI     R16, 4
   \   000000E0   F559               BRNE    ??ReceivePacketUart_3
    429                          if ( CalcDSRxChecksum(ch, myUART.RxPacklen - 2) ) {
   \   000000E2   5042               SUBI    R20, 2
   \   000000E4   4050               SBCI    R21, 0
   \   000000E6   E000               LDI     R16, 0
   \   000000E8   2F14               MOV     R17, R20
   \   000000EA   2B15               OR      R17, R21
   \   000000EC   F071               BREQ    ??ReceivePacketUart_5
   \   000000EE   ....               LDI     R26, LOW(RxBufferCh0)
   \   000000F0   ....               LDI     R27, (RxBufferCh0) >> 8
   \   000000F2   01CA               MOVW    R25:R24, R21:R20
   \   000000F4   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_6:
   \   000000F6   2FE0               MOV     R30, R16
   \   000000F8   E0F0               LDI     R31, 0
   \   000000FA   910D               LD      R16, X+
   \   000000FC   27E0               EOR     R30, R16
   \   000000FE   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000100   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000102   BF3B               OUT     0x3B, R19
   \   00000104   9106               ELPM    R16, Z
   \   00000106   9701               SBIW    R25:R24, 1
   \   00000108   F7B1               BRNE    ??ReceivePacketUart_6
   \                     ??ReceivePacketUart_5:
   \   0000010A   01FA               MOVW    R31:R30, R21:R20
   \   0000010C   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   0000010E   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000110   8110               LD      R17, Z
   \   00000112   1701               CP      R16, R17
   \   00000114   F489               BRNE    ??ReceivePacketUart_3
    430                              if ( (RxBufferCh0[1] == MyAddress()) ||       // message to me? or
    431                                   (RxBufferCh0[1] == 0xff) ) {            // broadcast
   \   00000116   ........           CALL    MyAddress
   \   0000011A   2F10               MOV     R17, R16
   \   0000011C   9100....           LDS     R16, (RxBufferCh0 + 1)
   \   00000120   1701               CP      R16, R17
   \   00000122   F011               BREQ    ??ReceivePacketUart_7
   \   00000124   3F0F               CPI     R16, 255
   \   00000126   F441               BRNE    ??ReceivePacketUart_3
    432                                  hostAddress = RxBufferCh0[3];            // address to sender (host)
   \                     ??ReceivePacketUart_7:
   \   00000128   9100....           LDS     R16, (RxBufferCh0 + 3)
   \   0000012C   9300....           STS     hostAddress, R16
    433                                  myUART.RxState = HANDLE;                     // Package OK
   \   00000130   E00A               LDI     R16, 10
   \   00000132   9300....           STS     (myUART + 16), R16
   \   00000136   C001               RJMP    ??ReceivePacketUart_0
    434                              } else {
    435                                  GoToSyncUART();                             // go to sync modus for recive
    436                              }
    437                          } else {
    438                              GoToSyncUART();                                // go to sync modus for recive
    439                          }
    440                      } else {
    441                          GoToSyncUART();                                    // go to sync modus for recive
    442                      }
    443                  }
    444                  break;
    445              case HANDLE :
    446                  break;
    447              default :
    448                  GoToSyncUART();                                            // go to sync modus for recive
   \                     ??ReceivePacketUart_3:
   \   00000138   ....               RCALL   GoToSyncUART
    449                  break;
    450              }                                                           // end switch
    451              if ( ++myUART.RxLast >= RXSIZE_UART ) {                     // check pointer
   \                     ??ReceivePacketUart_0:
   \   0000013A   91E0....           LDS     R30, (myUART + 12)
   \   0000013E   91F0....           LDS     R31, (myUART + 13)
   \   00000142   9631               ADIW    R31:R30, 1
   \   00000144   35EE               CPI     R30, 94
   \   00000146   E001               LDI     R16, 1
   \   00000148   07F0               CPC     R31, R16
   \   0000014A   F010               BRCS    ??ReceivePacketUart_8
    452                  myUART.RxLast = 0;                                     // reset pointer
   \   0000014C   E0E0               LDI     R30, 0
   \   0000014E   E0F0               LDI     R31, 0
   \                     ??ReceivePacketUart_8:
   \   00000150   93E0....           STS     (myUART + 12), R30
   \   00000154   93F0....           STS     (myUART + 13), R31
    453              }
    454          }
   \   00000158   ....               RJMP    ?Subroutine0
    455          /*************************************************************************
    456          *
    457          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    458          *
    459          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    460          char CalcDSTxChecksum(unsigned short len) {
   \                     CalcDSTxChecksum:
   \   00000000   01AD               MOVW    R21:R20, R27:R26
    461          
    462              unsigned short  cnt;
    463              unsigned char   csum;
    464          
    465              csum = 0;
   \   00000002   E020               LDI     R18, 0
    466              for ( cnt = 4; cnt < len; cnt++ ) {
   \   00000004   3005               CPI     R16, 5
   \   00000006   0712               CPC     R17, R18
   \   00000008   F080               BRCS    ??CalcDSTxChecksum_0
   \   0000000A   ....               LDI     R26, LOW((TxBufferCh0 + 4))
   \   0000000C   ....               LDI     R27, HIGH((TxBufferCh0 + 4))
   \   0000000E   5004               SUBI    R16, 4
   \   00000010   4010               SBCI    R17, 0
   \   00000012   ....               LDI     R19, (crc) >> 16
    467                  csum = crc[csum ^ TxBufferCh0[cnt]];
   \                     ??CalcDSTxChecksum_1:
   \   00000014   2FE2               MOV     R30, R18
   \   00000016   E0F0               LDI     R31, 0
   \   00000018   912D               LD      R18, X+
   \   0000001A   27E2               EOR     R30, R18
   \   0000001C   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000001E   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000020   BF3B               OUT     0x3B, R19
   \   00000022   9126               ELPM    R18, Z
    468              }
   \   00000024   5001               SUBI    R16, 1
   \   00000026   4010               SBCI    R17, 0
   \   00000028   F7A9               BRNE    ??CalcDSTxChecksum_1
    469              return csum;
   \                     ??CalcDSTxChecksum_0:
   \   0000002A   2F02               MOV     R16, R18
   \   0000002C   01DA               MOVW    R27:R26, R21:R20
   \   0000002E   9508               RET
    470          }
    471          
    472          /*************************************************************************
    473          *
    474          * Calculate rx packet checksum (header and package) using Dallas Semiconductor one-wire CRC
    475          *
    476          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    477          short CalcDSRxChecksum(char ch, unsigned short len) {
   \                     CalcDSRxChecksum:
   \   00000000   010D               MOVW    R1:R0, R27:R26
   \   00000002   01BC               MOVW    R23:R22, R25:R24
   \   00000004   01A9               MOVW    R21:R20, R19:R18
    478          
    479              unsigned short  cnt;
    480              unsigned char   csum;
    481          
    482              csum = 0;
   \   00000006   E000               LDI     R16, 0
    483              for ( cnt = 0; cnt < len; cnt++ ) {
   \   00000008   2B25               OR      R18, R21
   \   0000000A   F079               BREQ    ??CalcDSRxChecksum_0
   \   0000000C   ....               LDI     R26, LOW(RxBufferCh0)
   \   0000000E   ....               LDI     R27, (RxBufferCh0) >> 8
   \   00000010   2F84               MOV     R24, R20
   \   00000012   2F93               MOV     R25, R19
   \   00000014   ....               LDI     R19, (crc) >> 16
    484                  csum = crc[csum ^ RxBufferCh0[cnt]];
   \                     ??CalcDSRxChecksum_1:
   \   00000016   2FE0               MOV     R30, R16
   \   00000018   E0F0               LDI     R31, 0
   \   0000001A   910D               LD      R16, X+
   \   0000001C   27E0               EOR     R30, R16
   \   0000001E   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000020   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000022   BF3B               OUT     0x3B, R19
   \   00000024   9106               ELPM    R16, Z
    485              }
   \   00000026   9701               SBIW    R25:R24, 1
   \   00000028   F7B1               BRNE    ??CalcDSRxChecksum_1
    486              if ( csum == RxBufferCh0[len] ) {
   \                     ??CalcDSRxChecksum_0:
   \   0000002A   01FA               MOVW    R31:R30, R21:R20
   \   0000002C   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   0000002E   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000030   8110               LD      R17, Z
   \   00000032   1701               CP      R16, R17
   \   00000034   F411               BRNE    ??CalcDSRxChecksum_2
    487                  return true;
   \   00000036   E001               LDI     R16, 1
   \   00000038   C001               RJMP    ??CalcDSRxChecksum_3
    488              } else {
    489                  return false;
   \                     ??CalcDSRxChecksum_2:
   \   0000003A   E000               LDI     R16, 0
   \                     ??CalcDSRxChecksum_3:
   \   0000003C   E010               LDI     R17, 0
   \   0000003E   01CB               MOVW    R25:R24, R23:R22
   \   00000040   01D0               MOVW    R27:R26, R1:R0
   \   00000042   9508               RET
    490              }
    491          }
    492          
    493          /*************************************************************************
    494          *
    495          * Goes to sync mode
    496          *
    497          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    498          __monitor void GoToSyncUART() {
   \                     GoToSyncUART:
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002   94F8               CLI
    499          
    500              myUART.SyncCnt = 0;                        // ready for sync
   \   00000004   E000               LDI     R16, 0
   \   00000006   9300....           STS     (myUART + 17), R16
    501              myUART.RxState = SYNC;
   \   0000000A   9300....           STS     (myUART + 16), R16
    502              myUART.RxFirst = 0;
   \   0000000E   9300....           STS     (myUART + 10), R16
   \   00000012   9300....           STS     (myUART + 11), R16
    503          }
   \   00000016   BF1F               OUT     0x3F, R17
   \   00000018   9508               RET

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   BuildFlashID
      4      2   BuildStatusData
        4      2   -> MyAddress
      0      2   CalcDSRxChecksum
      0      2   CalcDSTxChecksum
      3      2   CheckActionUart
        3      2   -> BuildStatusData
        3      2   -> EraseFlash
        3      2   -> ProgramFlash
        3      2   -> ReadFlash
      4      2   EraseFlash
        4      2   -> write_page
      0      2   ExitBootloader
      0      2   GoToSyncUART
     14      2   ProgramFlash
       14      2   -> fill_temp_buffer
       14      2   -> read_program_memory
       14      2   -> write_page
      8      2   ReadFlash
        8      2   -> read_program_memory
      4      2   ReceivePacketUart
        4      2   -> GoToSyncUART
        4      2   -> MyAddress
      0      2   SendPacketUart
        0      2   -> sendchar
      0      2   Uart_BuildHeader
        0      2   -> MyAddress
      0      2   Uart_BuildTail
        0      2   -> CalcDSTxChecksum
        0      2   -> SendPacketUart
        0      2   -> Uart_BuildHeader
      2      2   UsartCheckPackage
        2      2   -> CheckActionUart
        2      2   -> GoToSyncUART
        2      2   -> Uart_BuildTail


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?Subroutine0
     248  BuildFlashID
     498  BuildStatusData
      68  CalcDSRxChecksum
      48  CalcDSTxChecksum
     378  CheckActionUart
     224  EraseFlash
      32  ExitBootloader
      26  GoToSyncUART
     464  ProgramFlash
     380  ReadFlash
     346  ReceivePacketUart
     350  RxBufferCh0
      96  SendPacketUart
     350  TxBufferCh0
      96  Uart_BuildHeader
     312  Uart_BuildTail
      88  UsartCheckPackage
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_RAMPZ
       1  _A_WDTCSR
       7  -- Other

 
     7 bytes in segment ABSOLUTE
 3 314 bytes in segment CODE
     7 bytes in segment INITTAB
   700 bytes in segment NEAR_Z
 
 3 314 bytes of CODE memory (+ 7 bytes shared)
   700 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: 1
