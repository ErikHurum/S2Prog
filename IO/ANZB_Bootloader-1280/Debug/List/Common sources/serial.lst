###############################################################################
#
# IAR C/C++ Compiler V8.10.1.1784/W64 for Microchip AVR   26/Apr/2023  10:28:45
# Copyright 1996-2023 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file           =  D:\S2Prog\IO\ANZB_Bootloader-1280\Src\serial.c
#    Command line          =
#        -f "D:\S2Prog\IO\ANZB_Bootloader-1280\Debug\Obj\Common
#        sources\serial.r90.rsp"
#        (D:\S2Prog\IO\ANZB_Bootloader-1280\Src\serial.c --cpu=m1280 -ms -o
#        "D:\S2Prog\IO\ANZB_Bootloader-1280\Debug\Obj\Common sources" -D
#        SPEED=38400 -D PORT0 -D __ATMEGA_1280__ -lCN
#        "D:\S2Prog\IO\ANZB_Bootloader-1280\Debug\List\Common sources" -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\ANZB_Bootloader-1280\INC\
#        -I D:\S2Prog\IO\ANZB_Bootloader-1280\..\..\SHARED\INC\ --eeprom_size
#        4096 --clib -On) --dependencies=n
#        "D:\S2Prog\IO\ANZB_Bootloader-1280\Debug\Obj\Common
#        sources\serial.r90.iar_deps"
#    Locale                =  C
#    List file             =
#        D:\S2Prog\IO\ANZB_Bootloader-1280\Debug\List\Common sources\serial.lst
#    Object file           =
#        D:\S2Prog\IO\ANZB_Bootloader-1280\Debug\Obj\Common sources\serial.r90
#    Runtime model:           
#      __64bit_doubles     =  disabled
#      __SystemLibrary     =  CLib
#      __architecture      =  *
#      __cpu               =  3
#      __cpu_name          =  ATmega1280
#      __dlib_version      =  clib
#      __enhanced_core     =  enabled
#      __enhanced_core_mul =  enabled
#      __has_elpm          =  true
#      __memory_model      =  2
#      __mex               =  disabled
#      __no_rampd          =  enabled
#      __rt_version        =  3
#      __vtable_memory     =  __nearflash
#
###############################################################################

D:\S2Prog\IO\ANZB_Bootloader-1280\Src\serial.c
      1          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0xc6
   \   __no_init union <unnamed>#133 volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   __no_init union <unnamed>#149 volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1
      2          #include "stdio.h"
      3          #include "math.h"
      4          #include "externals.h"
      5          

   \                                 In  segment CODE, align 2, keep-with-next
      6          void sendchar(char c){
   \                     sendchar:
      7              UART_DATA_REG0 = c;                                   // prepare transmission
   \   00000000   930000C6           STS     198, R16
      8              while (!(UART_STATUS_REG0 & (1 << TRANSMIT_COMPLETE_BIT0)));// wait until byte sendt
   \                     ??sendchar_0:
   \   00000004   911000C0           LDS     R17, 192
   \   00000008   FF16               SBRS    R17, 6
   \   0000000A   CFFC               RJMP    ??sendchar_0
      9              UART_STATUS_REG0 |= (1 << TRANSMIT_COMPLETE_BIT0);          // delete TXCflag
   \   0000000C   911000C0           LDS     R17, 192
   \   00000010   6410               ORI     R17, 0x40
   \   00000012   931000C0           STS     192, R17
     10          }
   \   00000016   9508               RET
   \   00000018                      REQUIRE _A_UDR0
   \   00000018                      REQUIRE _A_UCSR0A
     11          
     12          

   \                                 In  segment CODE, align 2, keep-with-next
     13          void recchar(void){
   \                     recchar:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
     14            if((UART_STATUS_REG0 & (1 << RECEIVE_COMPLETE_BIT0)) ||(UART_STATUS_REG0 & 0x10)){
   \   00000004   910000C0           LDS     R16, 192
   \   00000008   FD07               SBRC    R16, 7
   \   0000000A   C004               RJMP    ??recchar_0
   \   0000000C   910000C0           LDS     R16, 192
   \   00000010   FF04               SBRS    R16, 4
   \   00000012   C061               RJMP    ??recchar_1
     15              RxBufferCh0[ myUART.RxFirst ] = UART_DATA_REG0;                     // Read the character 
   \                     ??recchar_0:
   \   00000014   910000C6           LDS     R16, 198
   \   00000018   ....               LDI     R30, LOW(myUART)
   \   0000001A   ....               LDI     R31, (myUART) >> 8
   \   0000001C   85A2               LDD     R26, Z+10
   \   0000001E   85B3               LDD     R27, Z+11
   \   00000020   ....               SUBI    R26, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000022   ....               SBCI    R27, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000024   930C               ST      X, R16
     16              if (myUART.RxState != HANDLE) {        // ok to receive? 
   \   00000026   9100....           LDS     R16, (myUART + 16)
   \   0000002A   300A               CPI     R16, 10
   \   0000002C   F409               BRNE    $+2+2
   \   0000002E   C053               RJMP    ??recchar_1
     17                  switch (myUART.RxState) {                   // Yes, check state
   \   00000030   9100....           LDS     R16, (myUART + 16)
   \   00000034   2300               TST     R16
   \   00000036   F5C9               BRNE    ??recchar_2
     18                  case SYNC :
     19                      if ( RxBufferCh0[ myUART.RxFirst ] == ANPRO10_SYN) {
   \   00000038   ....               LDI     R30, LOW(myUART)
   \   0000003A   ....               LDI     R31, (myUART) >> 8
   \   0000003C   85A2               LDD     R26, Z+10
   \   0000003E   85B3               LDD     R27, Z+11
   \   00000040   ....               SUBI    R26, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000042   ....               SBCI    R27, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000044   910C               LD      R16, X
   \   00000046   3106               CPI     R16, 22
   \   00000048   F461               BRNE    ??recchar_3
     20                          myUART.SyncCnt ++ ;                 // count sync
   \   0000004A   ....               LDI     R30, LOW(myUART)
   \   0000004C   ....               LDI     R31, (myUART) >> 8
   \   0000004E   8901               LDD     R16, Z+17
   \   00000050   9503               INC     R16
   \   00000052   8B01               STD     Z+17, R16
     21                          myUART.RxFirst = 0;                 // start at start of buff
   \   00000054   E000               LDI     R16, 0
   \   00000056   E010               LDI     R17, 0
   \   00000058   ....               LDI     R30, LOW(myUART)
   \   0000005A   ....               LDI     R31, (myUART) >> 8
   \   0000005C   8702               STD     Z+10, R16
   \   0000005E   8713               STD     Z+11, R17
   \   00000060   C03A               RJMP    ??recchar_1
     22                      } else if ((myUART.SyncCnt >= 2) && 
     23                                 (RxBufferCh0[ myUART.RxFirst ] == ANPRO10_SOH)) {       // minimum two sync bytes
   \                     ??recchar_3:
   \   00000062   9100....           LDS     R16, (myUART + 17)
   \   00000066   3002               CPI     R16, 2
   \   00000068   F0E0               BRCS    ??recchar_4
   \   0000006A   ....               LDI     R30, LOW(myUART)
   \   0000006C   ....               LDI     R31, (myUART) >> 8
   \   0000006E   85A2               LDD     R26, Z+10
   \   00000070   85B3               LDD     R27, Z+11
   \   00000072   ....               SUBI    R26, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000074   ....               SBCI    R27, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000076   910C               LD      R16, X
   \   00000078   3001               CPI     R16, 1
   \   0000007A   F499               BRNE    ??recchar_4
     24                          myUART.SyncCnt = 0 ;                // reset counter
   \   0000007C   E000               LDI     R16, 0
   \   0000007E   9300....           STS     (myUART + 17), R16
     25                          myUART.RxState = HEADER ;
   \   00000082   E001               LDI     R16, 1
   \   00000084   9300....           STS     (myUART + 16), R16
     26                          myUART.RxLast = 0 ;
   \   00000088   E000               LDI     R16, 0
   \   0000008A   E010               LDI     R17, 0
   \   0000008C   ....               LDI     R30, LOW(myUART)
   \   0000008E   ....               LDI     R31, (myUART) >> 8
   \   00000090   8704               STD     Z+12, R16
   \   00000092   8715               STD     Z+13, R17
     27                          myUART.RxTimeout = RX_TO_TIME ;   // reset timeout
   \   00000094   EF0A               LDI     R16, 250
   \   00000096   E010               LDI     R17, 0
   \   00000098   ....               LDI     R30, LOW(myUART)
   \   0000009A   ....               LDI     R31, (myUART) >> 8
   \   0000009C   8B02               STD     Z+18, R16
   \   0000009E   8B13               STD     Z+19, R17
   \   000000A0   C01A               RJMP    ??recchar_1
     28                      } else {
     29                          myUART.SyncCnt = 0 ;                // start over once more
   \                     ??recchar_4:
   \   000000A2   E000               LDI     R16, 0
   \   000000A4   9300....           STS     (myUART + 17), R16
     30                      }
     31                      break;
   \   000000A8   C016               RJMP    ??recchar_1
     32                  default :
     33                      if ((++myUART.RxFirst) > RXSIZE_UART) { // Point to next location
   \                     ??recchar_2:
   \   000000AA   ....               LDI     R30, LOW(myUART)
   \   000000AC   ....               LDI     R31, (myUART) >> 8
   \   000000AE   8502               LDD     R16, Z+10
   \   000000B0   8513               LDD     R17, Z+11
   \   000000B2   5F0F               SUBI    R16, 255
   \   000000B4   4F1F               SBCI    R17, 255
   \   000000B6   8702               STD     Z+10, R16
   \   000000B8   8713               STD     Z+11, R17
   \   000000BA   ....               LDI     R30, LOW(myUART)
   \   000000BC   ....               LDI     R31, (myUART) >> 8
   \   000000BE   8502               LDD     R16, Z+10
   \   000000C0   8513               LDD     R17, Z+11
   \   000000C2   350F               CPI     R16, 95
   \   000000C4   E021               LDI     R18, 1
   \   000000C6   0712               CPC     R17, R18
   \   000000C8   F018               BRCS    ??recchar_5
     34                          GoToSyncUART() ;                       // go to sync mode
   \   000000CA   ........           CALL    GoToSyncUART
   \   000000CE   C003               RJMP    ??recchar_1
     35                      } else {
     36                          ReceivePacketUart(0) ;              // Check package
   \                     ??recchar_5:
   \   000000D0   E000               LDI     R16, 0
   \   000000D2   ........           CALL    ReceivePacketUart
     37                      }
     38                      break ;   
     39                  }
     40              }
     41            }
     42          }
   \                     ??recchar_1:
   \   000000D6   91A9               LD      R26, Y+
   \   000000D8   91B9               LD      R27, Y+
   \   000000DA   9508               RET
   \   000000DC                      REQUIRE _A_UCSR0A
   \   000000DC                      REQUIRE _A_UDR0

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      2      2   recchar
        2      2   -> GoToSyncUART
        2      2   -> ReceivePacketUart
      0      2   sendchar


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  _A_UCSR0A
       1  _A_UDR0
     220  recchar
      24  sendchar

 
   2 bytes in segment ABSOLUTE
 244 bytes in segment CODE
 
 244 bytes of CODE memory
   0 bytes of DATA memory (+ 2 bytes shared)

Errors: none
Warnings: none
