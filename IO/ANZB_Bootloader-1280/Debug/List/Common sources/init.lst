###############################################################################
#
# IAR C/C++ Compiler V8.10.1.1784/W64 for Microchip AVR   02/Oct/2023  15:15:14
# Copyright 1996-2023 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file           =
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\Src\init.c
#    Command line          =
#        -f "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\Debug\Obj\Common
#        sources\init.r90.rsp" ("C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\Src\init.c"
#        --cpu=m1280 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\Debug\Obj\Common
#        sources" -D SPEED=38400 -D PORT0 -D __ATMEGA_1280__ -lCN
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\Debug\List\Common
#        sources" -y --initializers_in_flash --no_cse --no_inline
#        --no_code_motion --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -On) --dependencies=n "C:\Users\ESY\OneDrive
#        -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\Debug\Obj\Common
#        sources\init.r90.iar_deps"
#    Locale                =  C
#    List file             =
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\Debug\List\Common
#        sources\init.lst
#    Object file           =
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\Debug\Obj\Common
#        sources\init.r90
#    Runtime model:           
#      __64bit_doubles     =  disabled
#      __SystemLibrary     =  CLib
#      __architecture      =  *
#      __cpu               =  3
#      __cpu_name          =  ATmega1280
#      __dlib_version      =  clib
#      __enhanced_core     =  enabled
#      __enhanced_core_mul =  enabled
#      __has_elpm          =  true
#      __memory_model      =  2
#      __mex               =  disabled
#      __no_rampd          =  enabled
#      __rt_version        =  3
#      __vtable_memory     =  __nearflash
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1280\Src\init.c
      1          /****************************************************************************************
      2          / Init the project
      3          /
      4          ***************************************************************************************/
      5          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0xc4
   \   __no_init union <unnamed>#136 volatile __io _A_UBRR0
   \                     _A_UBRR0:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xc2
   \   __no_init union <unnamed>#142 volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   __no_init union <unnamed>#146 volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   __no_init union <unnamed>#149 volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x98
   \   __no_init union <unnamed>#239 volatile __io _A_OCR3A
   \                     _A_OCR3A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x91
   \   __no_init union <unnamed>#260 volatile __io _A_TCCR3B
   \                     _A_TCCR3B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x90
   \   __no_init union <unnamed>#263 volatile __io _A_TCCR3A
   \                     _A_TCCR3A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x75
   \   __no_init union <unnamed>#329 volatile __io _A_XMCRB
   \                     _A_XMCRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x74
   \   __no_init union <unnamed>#332 volatile __io _A_XMCRA
   \                     _A_XMCRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6e
   \   __no_init union <unnamed>#350 volatile __io _A_TIMSK0
   \                     _A_TIMSK0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6a
   \   __no_init union <unnamed>#362 volatile __io _A_EICRB
   \                     _A_EICRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x69
   \   __no_init union <unnamed>#365 volatile __io _A_EICRA
   \                     _A_EICRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   __no_init union <unnamed>#383 volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5f
   \   __no_init union <unnamed>#386 volatile __io _A_SREG
   \                     _A_SREG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x55
   \   __no_init union <unnamed>#401 volatile __io _A_MCUCR
   \                     _A_MCUCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x47
   \   __no_init union <unnamed>#435 volatile __io _A_OCR0A
   \                     _A_OCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x46
   \   __no_init union <unnamed>#438 volatile __io _A_TCNT0
   \                     _A_TCNT0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x45
   \   __no_init union <unnamed>#441 volatile __io _A_TCCR0B
   \                     _A_TCCR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x44
   \   __no_init union <unnamed>#444 volatile __io _A_TCCR0A
   \                     _A_TCCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   __no_init union <unnamed>#465 volatile __io _A_EIMSK
   \                     _A_EIMSK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x35
   \   __no_init union <unnamed>#489 volatile __io _A_TIFR0
   \                     _A_TIFR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   __no_init union <unnamed>#492 volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33
   \   __no_init union <unnamed>#495 volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   __no_init union <unnamed>#501 volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   __no_init union <unnamed>#504 volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   __no_init union <unnamed>#510 volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d
   \   __no_init union <unnamed>#513 volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2b
   \   __no_init union <unnamed>#519 volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   __no_init union <unnamed>#522 volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x28
   \   __no_init union <unnamed>#528 volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   __no_init union <unnamed>#531 volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   __no_init union <unnamed>#537 volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   __no_init union <unnamed>#540 volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x23
   \   __no_init union <unnamed>#543 volatile __io _A_PINB
   \                     _A_PINB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x22
   \   __no_init union <unnamed>#546 volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21
   \   __no_init union <unnamed>#549 volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "inavr.h"
     10          #include "string.h"
     11          
     12          /*
     13          **===========================================================================
     14          ** Init the system according to board type
     15          **===========================================================================
     16          */

   \                                 In  segment CODE, align 2, keep-with-next
     17          void InitSystem(void) {
   \                     InitSystem:
     18          
     19          
     20              Init_CPU();                         // init all processes
   \   00000000   ....               RCALL   Init_CPU
     21              Init_IO();
   \   00000002   ....               RCALL   Init_IO
     22              Init_TMR();
   \   00000004   ....               RCALL   Init_TMR
     23              Init_USART( SPEED) ;              // Init uarts
   \   00000006   E000               LDI     R16, 0
   \   00000008   E916               LDI     R17, 150
   \   0000000A   E020               LDI     R18, 0
   \   0000000C   E030               LDI     R19, 0
   \   0000000E   ....               RCALL   Init_USART
     24              UnitID  = (PINB >> 2) & 0x03;          //get the unit ID
   \   00000010   B103               IN      R16, 0x03
   \   00000012   9506               LSR     R16
   \   00000014   9506               LSR     R16
   \   00000016   7003               ANDI    R16, 0x03
   \   00000018   9300....           STS     UnitID, R16
     25          }
   \   0000001C   9508               RET
   \   0000001E                      REQUIRE _A_PINB
     26          
     27          /*
     28          **===========================================================================
     29          ** Init the CPU related registers
     30          **===========================================================================
     31          */

   \                                 In  segment CODE, align 2, keep-with-next
     32          void Init_CPU(void) {
   \                     Init_CPU:
     33              __disable_interrupt();
   \   00000000   94F8               CLI
     34          
     35              EIMSK = 0x00;        // External interrupt mask register
   \   00000002   E000               LDI     R16, 0
   \   00000004   BB0D               OUT     0x1D, R16
     36              EICRA = 0x00;       // External interrupt control register Int 0/1 on low level
   \   00000006   E000               LDI     R16, 0
   \   00000008   93000069           STS     105, R16
     37              EICRB = 0x00;        // External interrupt control register Int 0/1 enabled
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   9300006A           STS     106, R16
     38              EIMSK = 0x00;        // External interrupt mask register
   \   00000012   E000               LDI     R16, 0
   \   00000014   BB0D               OUT     0x1D, R16
     39              MCUCR = 0x00;        // MCU control register  External Ram + wait state
   \   00000016   E000               LDI     R16, 0
   \   00000018   BF05               OUT     0x35, R16
     40              XMCRA = 0x00;       // maximum wait states
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   93000074           STS     116, R16
     41              XMCRB = 0x00;       // Full 16 bit bus + bus keeper
   \   00000020   E000               LDI     R16, 0
   \   00000022   93000075           STS     117, R16
     42              SREG  = 0x00;        // glabal interrupt
   \   00000026   E000               LDI     R16, 0
   \   00000028   BF0F               OUT     0x3F, R16
     43          
     44              ResetStatus = MCUCR;       // Remember reset source
   \   0000002A   B705               IN      R16, 0x35
   \   0000002C   9300....           STS     ResetStatus, R16
     45              MCUCR = 0x00;              // and reset
   \   00000030   E000               LDI     R16, 0
   \   00000032   BF05               OUT     0x35, R16
     46              /*--- Initialize buffer ---*/
     47              // enable bootloader interrupt HKim code
     48              char temp = MCUCR;
   \   00000034   B715               IN      R17, 0x35
     49              MCUCR = temp | (1 << IVCE);       // enable change of interrupt vectors
   \   00000036   2F01               MOV     R16, R17
   \   00000038   6001               ORI     R16, 0x01
   \   0000003A   BF05               OUT     0x35, R16
     50              MCUCR = temp | (1 << IVSEL);      // move inerrupt vectors to boot flash section
   \   0000003C   2F01               MOV     R16, R17
   \   0000003E   6002               ORI     R16, 0x02
   \   00000040   BF05               OUT     0x35, R16
     51          
     52          }
   \   00000042   9508               RET
   \   00000044                      REQUIRE _A_EIMSK
   \   00000044                      REQUIRE _A_EICRA
   \   00000044                      REQUIRE _A_EICRB
   \   00000044                      REQUIRE _A_MCUCR
   \   00000044                      REQUIRE _A_XMCRA
   \   00000044                      REQUIRE _A_XMCRB
   \   00000044                      REQUIRE _A_SREG
     53          
     54          /*
     55          **===========================================================================
     56          ** Init the watchdog registers
     57          **===========================================================================
     58          */

   \                                 In  segment CODE, align 2, keep-with-next
     59          __monitor void Init_Watchdog(void) {
   \                     Init_Watchdog:
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002   94F8               CLI
     60          
     61              asm("WDR");                             // kick the dog!!
   \   00000004   95A8               WDR
     62              WDTCSR = 0x0f;
   \   00000006   E00F               LDI     R16, 15
   \   00000008   93000060           STS     96, R16
     63              asm("WDR");                             // kick the dog!!
   \   0000000C   95A8               WDR
     64          
     65          }
   \   0000000E   BF1F               OUT     0x3F, R17
   \   00000010   9508               RET
   \   00000012                      REQUIRE _A_WDTCSR
     66          
     67          /*
     68          **===========================================================================
     69          ** Init the IO related registers
     70          **===========================================================================
     71          */

   \                                 In  segment CODE, align 2, keep-with-next
     72          void Init_IO(void) {
   \                     Init_IO:
     73          
     74              DDRA   =  0x00;      // Port A data
   \   00000000   E000               LDI     R16, 0
   \   00000002   B901               OUT     0x01, R16
     75              PORTA  =  0x00;      // Port A data
   \   00000004   E000               LDI     R16, 0
   \   00000006   B902               OUT     0x02, R16
     76              DDRB   =  0x00;      // Port B data
   \   00000008   E000               LDI     R16, 0
   \   0000000A   B904               OUT     0x04, R16
     77              PORTB  =  0xC0;      // Port B data
   \   0000000C   EC00               LDI     R16, 192
   \   0000000E   B905               OUT     0x05, R16
     78              DDRC   =  0x00;      // Port C data
   \   00000010   E000               LDI     R16, 0
   \   00000012   B907               OUT     0x07, R16
     79              PORTC  =  0x00;      // Port C data
   \   00000014   E000               LDI     R16, 0
   \   00000016   B908               OUT     0x08, R16
     80              DDRD   =  0x00;      // Port D data
   \   00000018   E000               LDI     R16, 0
   \   0000001A   B90A               OUT     0x0A, R16
     81              PORTD  =  0xf0;      // Port D data  //pullup addr
   \   0000001C   EF00               LDI     R16, 240
   \   0000001E   B90B               OUT     0x0B, R16
     82              DDRE   =  0x0E;      // Port E data bit 7-4 Address in, Bit 3 -1 out, bit 0 rxd in
   \   00000020   E00E               LDI     R16, 14
   \   00000022   B90D               OUT     0x0D, R16
     83              PORTE  =  0x00;      // Port E data
   \   00000024   E000               LDI     R16, 0
   \   00000026   B90E               OUT     0x0E, R16
     84              DDRF   =  0x00;      // Port F data
   \   00000028   E000               LDI     R16, 0
   \   0000002A   BB00               OUT     0x10, R16
     85              PORTF  =  0x00;      // Port F data
   \   0000002C   E000               LDI     R16, 0
   \   0000002E   BB01               OUT     0x11, R16
     86              DDRG   =  0x00;      // Port G data
   \   00000030   E000               LDI     R16, 0
   \   00000032   BB03               OUT     0x13, R16
     87              PORTG  =  0x00;      // Port G data
   \   00000034   E000               LDI     R16, 0
   \   00000036   BB04               OUT     0x14, R16
     88          }
   \   00000038   9508               RET
   \   0000003A                      REQUIRE _A_DDRA
   \   0000003A                      REQUIRE _A_PORTA
   \   0000003A                      REQUIRE _A_DDRB
   \   0000003A                      REQUIRE _A_PORTB
   \   0000003A                      REQUIRE _A_DDRC
   \   0000003A                      REQUIRE _A_PORTC
   \   0000003A                      REQUIRE _A_DDRD
   \   0000003A                      REQUIRE _A_PORTD
   \   0000003A                      REQUIRE _A_DDRE
   \   0000003A                      REQUIRE _A_PORTE
   \   0000003A                      REQUIRE _A_DDRF
   \   0000003A                      REQUIRE _A_PORTF
   \   0000003A                      REQUIRE _A_DDRG
   \   0000003A                      REQUIRE _A_PORTG
     89          
     90          /*
     91          **===========================================================================
     92          ** Init the timer related registers
     93          **===========================================================================
     94          */

   \                                 In  segment CODE, align 2, keep-with-next
     95          void Init_TMR(void) {
   \                     Init_TMR:
     96              /*--- Timer control (disable clock inputs) ---*/
     97          
     98              //TCCR0A  =  0x99;             // Timer control register 0
     99              //OCR0A    =  7;               // Timer output compare register 0, 1MHZ //16MHz xtal
    100              //
    101              // to provide ADC with 1 Mhz clock, OC3A (PE3) is connected to ADC clock
    102              //
    103              // we will use TC3 to generate 1 Mhz clock by setting
    104              //
    105              // 1) TCCR3A    : 01000000   = 0x40
    106              //    a) Bit 7:6,     COM3A1/COM3A0   :   01  - Toggle OC3A(PE3) on compare match
    107              //    b) Bit 5:2,     don't care. all zero
    108              //    c) Bit 1:0,     WGM31/WGM30     :   00 for CTC mode
    109              //
    110              // 2) TCCR3B    : 00001001 = 0x09
    111              //    a) Bit 7,       noise canceler. don't care. 0
    112              //    b) Bit 6,       edge select for input. don't care. 0
    113              //    c) Bit 5,       reserved, 0
    114              //    d) Bit 4:3,     WGM33/WGM32     : 01 for CTC mode with OCR3A as TOP
    115              //    e) Bit 2:0,     CS32/CS31/CS30  : Clock Select, 001 : 16 Mhz with no divider
    116              //
    117              // 3) OCR3A     : 7, compare match at 8 tick at 16 Mhz will generate 1 MHz Clock
    118              //
    119              //
    120              TCCR3A    = 0x40;
   \   00000000   E400               LDI     R16, 64
   \   00000002   93000090           STS     144, R16
    121              TCCR3B    = 0x09;
   \   00000006   E009               LDI     R16, 9
   \   00000008   93000091           STS     145, R16
    122              OCR3A     = 7;
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   93000099           STS     (152 + 1), R16
   \   00000012   E007               LDI     R16, 7
   \   00000014   93000098           STS     152, R16
    123          
    124              TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.        */
    125                  (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.   */
    126                  (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.   */
   \   00000018   E002               LDI     R16, 2
   \   0000001A   BD04               OUT     0x24, R16
    127              TCCR0B  = (0 << WGM02) | (1 << CS01) | (1 << CS00);    /* CTC mode., 64 prescale  */
   \   0000001C   E003               LDI     R16, 3
   \   0000001E   BD05               OUT     0x25, R16
    128              OCR0A   = TIMER_TICK_COUNT_FOR_1MS - 1;
   \   00000020   EF09               LDI     R16, 249
   \   00000022   BD07               OUT     0x27, R16
    129              TCNT0   = 0;                                           /* Reset counter.   */
   \   00000024   E000               LDI     R16, 0
   \   00000026   BD06               OUT     0x26, R16
    130              TIFR0   = (1 << OCF0A);                                /* Reset pending.   */
   \   00000028   E002               LDI     R16, 2
   \   0000002A   BB05               OUT     0x15, R16
    131              TIMSK0  = (1 << OCIE0A);                               /* IRQ on compare.  */
   \   0000002C   E002               LDI     R16, 2
   \   0000002E   9300006E           STS     110, R16
    132          
    133          
    134          }
   \   00000032   9508               RET
   \   00000034                      REQUIRE _A_TCCR3A
   \   00000034                      REQUIRE _A_TCCR3B
   \   00000034                      REQUIRE _A_OCR3A
   \   00000034                      REQUIRE _A_TCCR0A
   \   00000034                      REQUIRE _A_TCCR0B
   \   00000034                      REQUIRE _A_OCR0A
   \   00000034                      REQUIRE _A_TCNT0
   \   00000034                      REQUIRE _A_TIFR0
   \   00000034                      REQUIRE _A_TIMSK0
    135          
    136          /*
    137          **===========================================================================
    138          ** Init the USARTs registers
    139          **===========================================================================
    140          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    141          void Init_USART( unsigned long baud ) {
   \                     Init_USART:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   01D9               MOVW    R27:R26, R19:R18
    142          
    143              /*--- Configure UART data block ---*/
    144              myUART.TxFirst   = 0x00;
   \   00000008   E000               LDI     R16, 0
   \   0000000A   E010               LDI     R17, 0
   \   0000000C   ....               LDI     R30, LOW(myUART)
   \   0000000E   ....               LDI     R31, (myUART) >> 8
   \   00000010   8300               ST      Z, R16
   \   00000012   8311               STD     Z+1, R17
    145              myUART.TxLast    = 0x00;
   \   00000014   E000               LDI     R16, 0
   \   00000016   E010               LDI     R17, 0
   \   00000018   ....               LDI     R30, LOW(myUART)
   \   0000001A   ....               LDI     R31, (myUART) >> 8
   \   0000001C   8302               STD     Z+2, R16
   \   0000001E   8313               STD     Z+3, R17
    146              myUART.TxCount   = 0x00;
   \   00000020   E000               LDI     R16, 0
   \   00000022   E010               LDI     R17, 0
   \   00000024   ....               LDI     R30, LOW(myUART)
   \   00000026   ....               LDI     R31, (myUART) >> 8
   \   00000028   8304               STD     Z+4, R16
   \   0000002A   8315               STD     Z+5, R17
    147              myUART.RxFirst   = 0x00;
   \   0000002C   E000               LDI     R16, 0
   \   0000002E   E010               LDI     R17, 0
   \   00000030   ....               LDI     R30, LOW(myUART)
   \   00000032   ....               LDI     R31, (myUART) >> 8
   \   00000034   8702               STD     Z+10, R16
   \   00000036   8713               STD     Z+11, R17
    148              myUART.RxLast    = 0x00;
   \   00000038   E000               LDI     R16, 0
   \   0000003A   E010               LDI     R17, 0
   \   0000003C   ....               LDI     R30, LOW(myUART)
   \   0000003E   ....               LDI     R31, (myUART) >> 8
   \   00000040   8704               STD     Z+12, R16
   \   00000042   8715               STD     Z+13, R17
    149              myUART.RxCount   = 0x00;
   \   00000044   E000               LDI     R16, 0
   \   00000046   E010               LDI     R17, 0
   \   00000048   ....               LDI     R30, LOW(myUART)
   \   0000004A   ....               LDI     R31, (myUART) >> 8
   \   0000004C   8706               STD     Z+14, R16
   \   0000004E   8717               STD     Z+15, R17
    150              myUART.RxState   = SYNC;
   \   00000050   E000               LDI     R16, 0
   \   00000052   9300....           STS     (myUART + 16), R16
    151              myUART.SyncCnt   = 0 ;
   \   00000056   E000               LDI     R16, 0
   \   00000058   9300....           STS     (myUART + 17), R16
    152              myUART.TxStatus  = 0x00;
   \   0000005C   E000               LDI     R16, 0
   \   0000005E   9300....           STS     (myUART + 8), R16
    153          
    154              myUART.RxTimeout = RX_TO_TIME ;   // reset timeout
   \   00000062   EF0A               LDI     R16, 250
   \   00000064   E010               LDI     R17, 0
   \   00000066   ....               LDI     R30, LOW(myUART)
   \   00000068   ....               LDI     R31, (myUART) >> 8
   \   0000006A   8B02               STD     Z+18, R16
   \   0000006C   8B13               STD     Z+19, R17
    155              UCSR0A  = 0x00; 
   \   0000006E   E000               LDI     R16, 0
   \   00000070   930000C0           STS     192, R16
    156              UBRR0L  = ((XTAL_CPU / 16 / baud )-1) & 0xff;
   \   00000074   01AC               MOVW    R21:R20, R25:R24
   \   00000076   01BD               MOVW    R23:R22, R27:R26
   \   00000078   E400               LDI     R16, 64
   \   0000007A   E412               LDI     R17, 66
   \   0000007C   E02F               LDI     R18, 15
   \   0000007E   E030               LDI     R19, 0
   \   00000080   ........           CALL    ?UL_DIVMOD_L03
   \   00000084   950A               DEC     R16
   \   00000086   930000C4           STS     196, R16
    157              UBRR0H  = (((XTAL_CPU / 16 / baud )-1)>> 8) & 0xff;
   \   0000008A   01AC               MOVW    R21:R20, R25:R24
   \   0000008C   01BD               MOVW    R23:R22, R27:R26
   \   0000008E   E400               LDI     R16, 64
   \   00000090   E412               LDI     R17, 66
   \   00000092   E02F               LDI     R18, 15
   \   00000094   E030               LDI     R19, 0
   \   00000096   ........           CALL    ?UL_DIVMOD_L03
   \   0000009A   5001               SUBI    R16, 1
   \   0000009C   4010               SBCI    R17, 0
   \   0000009E   2F01               MOV     R16, R17
   \   000000A0   E010               LDI     R17, 0
   \   000000A2   930000C5           STS     197, R16
    158              UCSR0B  = (1<<RXEN0) | (1<<TXEN0);        // Enable recieve and transmit
   \   000000A6   E108               LDI     R16, 24
   \   000000A8   930000C1           STS     193, R16
    159              UCSR0C  = 0x06;       /* n,8,1 */
   \   000000AC   E006               LDI     R16, 6
   \   000000AE   930000C2           STS     194, R16
    160          }
   \   000000B2   E0E4               LDI     R30, 4
   \   000000B4   ........           JMP     ?EPILOGUE_B4_L09
   \   000000B8                      REQUIRE _A_UCSR0A
   \   000000B8                      REQUIRE _A_UBRR0
   \   000000B8                      REQUIRE _A_UCSR0B
   \   000000B8                      REQUIRE _A_UCSR0C
    161          

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   InitSystem
        0      2   -> Init_CPU
        0      2   -> Init_IO
        0      2   -> Init_TMR
        0      2   -> Init_USART
      0      2   Init_CPU
      0      2   Init_IO
      0      2   Init_TMR
      4      2   Init_USART
        4      2 ?UL_DIVMOD_L03
      0      2   Init_Watchdog


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      30  InitSystem
      68  Init_CPU
      58  Init_IO
      52  Init_TMR
     184  Init_USART
      18  Init_Watchdog
       1  _A_DDRA
       1  _A_DDRB
       1  _A_DDRC
       1  _A_DDRD
       1  _A_DDRE
       1  _A_DDRF
       1  _A_DDRG
       1  _A_EICRA
       1  _A_EICRB
       1  _A_EIMSK
       1  _A_MCUCR
       1  _A_OCR0A
       2  _A_OCR3A
       1  _A_PINB
       1  _A_PORTA
       1  _A_PORTB
       1  _A_PORTC
       1  _A_PORTD
       1  _A_PORTE
       1  _A_PORTF
       1  _A_PORTG
       1  _A_SREG
       1  _A_TCCR0A
       1  _A_TCCR0B
       1  _A_TCCR3A
       1  _A_TCCR3B
       1  _A_TCNT0
       1  _A_TIFR0
       1  _A_TIMSK0
       2  _A_UBRR0
       1  _A_UCSR0A
       1  _A_UCSR0B
       1  _A_UCSR0C
       1  _A_WDTCSR
       1  _A_XMCRA
       1  _A_XMCRB

 
  38 bytes in segment ABSOLUTE
 410 bytes in segment CODE
 
 410 bytes of CODE memory
   0 bytes of DATA memory (+ 38 bytes shared)

Errors: none
Warnings: none
