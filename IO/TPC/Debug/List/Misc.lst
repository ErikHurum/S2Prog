###############################################################################
#
# IAR C/C++ Compiler V6.70.1.929 for Atmel AVR            18/Jan/2017  16:22:12
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Atmel AVR 6.80
#
#    Source file  =  D:\S2Prog\IO\TPC\Src\Misc.c
#    Command line =  
#        D:\S2Prog\IO\TPC\Src\Misc.c --cpu=m128 -ms -o
#        D:\S2Prog\IO\TPC\Debug\Obj -D OS_LIBMODE_D -D OS_UART=-1 -lCN
#        D:\S2Prog\IO\TPC\Debug\List -y --initializers_in_flash --no_cse
#        --no_inline --no_code_motion --no_cross_call --no_clustering --no_tbaa
#        --debug -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\TPC\INC\ -I
#        D:\S2Prog\IO\TPC\..\..\SHARED\INC\ --eeprom_size 4096 --clib -On
#    List file    =  D:\S2Prog\IO\TPC\Debug\List\Misc.lst
#    Object file  =  D:\S2Prog\IO\TPC\Debug\Obj\Misc.r90
#
###############################################################################

D:\S2Prog\IO\TPC\Src\Misc.c
      1          /****************************************************************************************
      2          /  Misc. routines
      3          /
      4          ***************************************************************************************/
      5          #include "iom128.h"

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_WDTCR
   \                     _A_WDTCR:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          #include "string.h"
     12          
     13          /*************************************************************************
     14          *   (This is a task)
     15          *  Watchdog handler
     16          *
     17          *   NB!
     18          *  This task runs on the lovest priority and all othr tasks will run.
     19          *  In case of faul a task on higher priority will use all resources and
     20          *  the watchdog will kick the CPU.
     21          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     22          void WatchDogHandler(void) {
   \                     WatchDogHandler:
     23          
     24              OS_Delay(100);                         // wait 2 seconds for other tasks to start and set TaskStatus
   \   00000000   E604               LDI     R16, 100
   \   00000002   E010               LDI     R17, 0
   \   00000004   ........           CALL    OS_Delay
     25              asm("WDR");                             // kick the dog!!
   \   00000008   95A8               WDR
     26              WDTCR = 0x1f;
   \   0000000A   E10F               LDI     R16, 31
   \   0000000C   BD01               OUT     0x21, R16
     27              WDTCR = 0x0f;
   \   0000000E   E00F               LDI     R16, 15
   \   00000010   BD01               OUT     0x21, R16
     28              asm("WDR");                             // kick the dog!!
   \   00000012   95A8               WDR
     29              while (1) {
     30                  OS_Delay(100);
   \                     ??WatchDogHandler_0:
   \   00000014   E604               LDI     R16, 100
   \   00000016   E010               LDI     R17, 0
   \   00000018   ........           CALL    OS_Delay
     31                  __watchdog_reset();               //kick the dog
   \   0000001C   95A8               WDR
   \   0000001E   CFFA               RJMP    ??WatchDogHandler_0
   \   00000020                      REQUIRE _A_WDTCR
     32              }
     33          }
     34          
     35          
     36          /*************************************************************************
     37          *
     38          *  Get my address
     39          *
     40          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     41          char MyAddress(void) {
   \                     MyAddress:
     42          
     43          #if (OS_UART == 0)
     44          #else
     45              MyPriAddress = ReadEEPROMByte(EEPROM_PRI_ADDR) ; // Get sec address from EEPROM
   \   00000000   E001               LDI     R16, 1
   \   00000002   E010               LDI     R17, 0
   \   00000004   ........           CALL    ReadEEPROMByte
   \   00000008   9300....           STS     MyPriAddress, R16
     46              MySecAddress = ReadEEPROMByte(EEPROM_SEC_ADDR) ; // Get sec address from EEPROM
   \   0000000C   E002               LDI     R16, 2
   \   0000000E   E010               LDI     R17, 0
   \   00000010   ........           CALL    ReadEEPROMByte
   \   00000014   9300....           STS     MySecAddress, R16
     47              return MySecAddress;
   \   00000018   9100....           LDS     R16, MySecAddress
   \   0000001C   9508               RET
     48              //return 0x00;
     49          #endif
     50          }
     51          
     52          /*************************************************************************
     53          *
     54          * 	Convert char to ASCII
     55          *
     56          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     57          void CharToAscii(char data, char * buf){
   \                     CharToAscii:
   \   00000000   2F5B               MOV     R21, R27
   \   00000002   2F6A               MOV     R22, R26
   \   00000004   2F10               MOV     R17, R16
   \   00000006   01D9               MOVW    R27:R26, R19:R18
     58              char i ;
     59              
     60              i= (data / 100) ;
   \   00000008   E644               LDI     R20, 100
   \   0000000A   2F01               MOV     R16, R17
   \   0000000C   ........           CALL    ?UC_DIVMOD_L01
   \   00000010   2F20               MOV     R18, R16
     61              buf[0] = i + 0x30 ;
   \   00000012   2F02               MOV     R16, R18
   \   00000014   5D00               SUBI    R16, 208
   \   00000016   930C               ST      X, R16
     62              data -= (i * 100) ;
   \   00000018   E604               LDI     R16, 100
   \   0000001A   9F20               MUL     R18, R16
   \   0000001C   1910               SUB     R17, R0
     63              i= data /10 ;
   \   0000001E   E04A               LDI     R20, 10
   \   00000020   2F01               MOV     R16, R17
   \   00000022   ........           CALL    ?UC_DIVMOD_L01
   \   00000026   2F20               MOV     R18, R16
     64              buf[1] = i + 0x30 ;
   \   00000028   2F02               MOV     R16, R18
   \   0000002A   5D00               SUBI    R16, 208
   \   0000002C   01FD               MOVW    R31:R30, R27:R26
   \   0000002E   8301               STD     Z+1, R16
     65              data -= (i *10) ;
   \   00000030   E00A               LDI     R16, 10
   \   00000032   9F20               MUL     R18, R16
   \   00000034   1910               SUB     R17, R0
     66              buf[2] = data + 0x30 ;
   \   00000036   2F01               MOV     R16, R17
   \   00000038   5D00               SUBI    R16, 208
   \   0000003A   01FD               MOVW    R31:R30, R27:R26
   \   0000003C   8302               STD     Z+2, R16
     67              if (buf[0] == 0x30) {
   \   0000003E   910C               LD      R16, X
   \   00000040   3300               CPI     R16, 48
   \   00000042   F411               BRNE    ??CharToAscii_0
     68                  buf[0] = 0x20 ; // space
   \   00000044   E200               LDI     R16, 32
   \   00000046   930C               ST      X, R16
     69              }
     70              if ((buf[1] == 0x30) && (buf[0] == 0x20)) {
   \                     ??CharToAscii_0:
   \   00000048   01FD               MOVW    R31:R30, R27:R26
   \   0000004A   8101               LDD     R16, Z+1
   \   0000004C   3300               CPI     R16, 48
   \   0000004E   F431               BRNE    ??CharToAscii_1
   \   00000050   910C               LD      R16, X
   \   00000052   3200               CPI     R16, 32
   \   00000054   F419               BRNE    ??CharToAscii_1
     71                  buf[1] = 0x20 ; // space
   \   00000056   E200               LDI     R16, 32
   \   00000058   01FD               MOVW    R31:R30, R27:R26
   \   0000005A   8301               STD     Z+1, R16
     72              }
     73          }
   \                     ??CharToAscii_1:
   \   0000005C   2FA6               MOV     R26, R22
   \   0000005E   2FB5               MOV     R27, R21
   \   00000060   9508               RET
     74          

   Maximum stack usage in bytes:

   RSTACK Function
   ------ --------
      2   CharToAscii
        2 ?UC_DIVMOD_L01
      2   MyAddress
        2   -> ReadEEPROMByte
      2   WatchDogHandler
        2   -> OS_Delay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      98  CharToAscii
      30  MyAddress
      32  WatchDogHandler
       1  _A_WDTCR

 
   1 byte  in segment ABSOLUTE
 160 bytes in segment CODE
 
 160 bytes of CODE memory
   0 bytes of DATA memory (+ 1 byte shared)

Errors: none
Warnings: none
