###############################################################################
#
# IAR C/C++ Compiler V6.70.1.929 for Atmel AVR            23/Jan/2017  13:07:11
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Atmel AVR 6.80
#
#    Source file  =  D:\S2Prog\IO\TPC\Src\UsartPro.c
#    Command line =  
#        D:\S2Prog\IO\TPC\Src\UsartPro.c --cpu=m128 -ms -o
#        D:\S2Prog\IO\TPC\Release\Obj -D OS_LIBMODE_S -D OS_UART=-1 -lCN
#        D:\S2Prog\IO\TPC\Release\List -y --initializers_in_flash --no_tbaa
#        -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\TPC\INC\ -I
#        D:\S2Prog\IO\TPC\..\..\SHARED\INC\ --eeprom_size 4096 --clib -Ohs
#    List file    =  D:\S2Prog\IO\TPC\Release\List\UsartPro.lst
#    Object file  =  D:\S2Prog\IO\TPC\Release\Obj\UsartPro.r90
#
###############################################################################

D:\S2Prog\IO\TPC\Src\UsartPro.c
      1          /****************************************************************************************
      2          / Com protocol for USART0 
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom128.h"

   \                                 In  segment ABSOLUTE, at 0x23
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3c
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3e
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_WDTCR
   \                     _A_WDTCR:
   \   00000000                      DS8 1
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "externals.h"
     10          #include "version.h"
     11          
     12          /*************************************************************************
     13          *   (This is a timer calback)
     14          *  Timout timer USART 0
     15          *
     16          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     17          void TimoutUSART0(void) {
   \                     TimoutUSART0:
     18          
     19              UCSR0B &= ~(__BIT_MASK( UDRIE0)) ;            // transmission end, disable int.
   \   00000000   9855               CBI     0x0A, 0x05
     20              ClrBit(PORTE, 0x04) ;                              // TXE0 off
   \   00000002   981A               CBI     0x03, 0x02
     21              OS_StopTimer(&TimerUSART0);                    // and stop timer
   \   00000004   ....               LDI     R16, LOW(TimerUSART0)
   \   00000006   ....               LDI     R17, (TimerUSART0) >> 8
   \   00000008   ........           JMP     OS_StopTimer
   \   0000000C                      REQUIRE _A_UCSR0B
   \   0000000C                      REQUIRE _A_PORTE
     22          }
     23          
     24          /*************************************************************************
     25          *   (This is a task)
     26          *  Usart0 handler
     27          *
     28          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     29          void Usart0Handler(void) {
   \                     Usart0Handler:
   \   00000000   924A               ST      -Y, R4
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R4_is_cg_reg
     30              char stat, FailCount;
     31              
     32              
     33              FailCount = 0 ;
   \   0000000A   E080               LDI     R24, 0
   \   0000000C   ....               LDI     R26, LOW(UART)
   \   0000000E   ....               LDI     R27, (UART) >> 8
   \   00000010   C039               RJMP    ??Usart0Handler_0
     34              while (1) {
     35                  stat = OS_WaitEventTimed(1,10000);  // Time out 10 sec
     36                  if (stat & 0x01) {
     37                      OS_Use(&UARTSEND);
   \                     ??Usart0Handler_1:
   \   00000012   ....               LDI     R16, LOW(UARTSEND)
   \   00000014   ....               LDI     R17, (UARTSEND) >> 8
   \   00000016   ........           CALL    OS_Use
     38                      UsartCheckPackage(0) ; 
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   9300....           STS     (UART + 28), R16
   \   00000020   E006               LDI     R16, 6
   \   00000022   E010               LDI     R17, 0
   \   00000024   01FD               MOVW    R31:R30, R27:R26
   \   00000026   8302               STD     Z+2, R16
   \   00000028   8313               STD     Z+3, R17
   \   0000002A   E084               LDI     R24, 4
   \   0000002C   E090               LDI     R25, 0
   \                     ??Usart0Handler_2:
   \   0000002E   019C               MOVW    R19:R18, R25:R24
   \   00000030   E000               LDI     R16, 0
   \   00000032   ....               RCALL   CheckActionUart
   \   00000034   2E40               MOV     R4, R16
   \   00000036   01FD               MOVW    R31:R30, R27:R26
   \   00000038   8504               LDD     R16, Z+12
   \   0000003A   8515               LDD     R17, Z+13
   \   0000003C   0F08               ADD     R16, R24
   \   0000003E   1F19               ADC     R17, R25
   \   00000040   01F8               MOVW    R31:R30, R17:R16
   \   00000042   8101               LDD     R16, Z+1
   \   00000044   E010               LDI     R17, 0
   \   00000046   5F0E               SUBI    R16, 254
   \   00000048   4F1F               SBCI    R17, 255
   \   0000004A   0F80               ADD     R24, R16
   \   0000004C   1F91               ADC     R25, R17
   \   0000004E   E000               LDI     R16, 0
   \   00000050   E010               LDI     R17, 0
   \   00000052   ........           CALL    OS_Delay
   \   00000056   2044               TST     R4
   \   00000058   F041               BREQ    ??Usart0Handler_3
   \   0000005A   01FD               MOVW    R31:R30, R27:R26
   \   0000005C   8D00               LDD     R16, Z+24
   \   0000005E   8D11               LDD     R17, Z+25
   \   00000060   5002               SUBI    R16, 2
   \   00000062   4010               SBCI    R17, 0
   \   00000064   1780               CP      R24, R16
   \   00000066   0791               CPC     R25, R17
   \   00000068   F310               BRCS    ??Usart0Handler_2
   \                     ??Usart0Handler_3:
   \   0000006A   9100....           LDS     R16, (UART + 28)
   \   0000006E   2300               TST     R16
   \   00000070   F011               BREQ    ??Usart0Handler_4
   \   00000072   E000               LDI     R16, 0
   \   00000074   ....               RCALL   Uart_BuildTail
   \                     ??Usart0Handler_4:
   \   00000076   E000               LDI     R16, 0
   \   00000078   ....               RCALL   GoToSyncUART
     39                      OS_Unuse(&UARTSEND);
   \   0000007A   ....               LDI     R16, LOW(UARTSEND)
   \   0000007C   ....               LDI     R17, (UARTSEND) >> 8
   \   0000007E   ........           CALL    OS_Unuse
     40                      FailCount = 0;
   \   00000082   E080               LDI     R24, 0
     41                  } else if (!stat) {
   \                     ??Usart0Handler_0:
   \   00000084   E120               LDI     R18, 16
   \   00000086   E237               LDI     R19, 39
   \   00000088   E001               LDI     R16, 1
   \   0000008A   ........           CALL    OS_WaitEventTimed
   \   0000008E   FB00               BST     R16, 0
   \   00000090   F206               BRTS    ??Usart0Handler_1
   \   00000092   2300               TST     R16
   \   00000094   F7B9               BRNE    ??Usart0Handler_0
     42                      if (FailCount++ > 12) {         // More than 2 minutes
   \   00000096   2F08               MOV     R16, R24
   \   00000098   9583               INC     R24
   \   0000009A   300D               CPI     R16, 13
   \   0000009C   F068               BRCS    ??Usart0Handler_5
     43                        if (!RXTimeout) {
   \   0000009E   9100....           LDS     R16, RXTimeout
   \   000000A2   2300               TST     R16
   \   000000A4   F441               BRNE    ??Usart0Handler_6
     44                          PrintComError("No Rx", ALARM_FLASH);
   \   000000A6   E022               LDI     R18, 2
   \   000000A8   ....               LDI     R16, LOW(`?<Constant "No Rx">`)
   \   000000AA   ....               LDI     R17, (`?<Constant "No Rx">`) >> 8
   \   000000AC   ........           CALL    PrintComError
     45                          RXTimeout = true;
   \   000000B0   E001               LDI     R16, 1
   \   000000B2   9300....           STS     RXTimeout, R16
     46                        }
     47                        FailCount = 0;
   \                     ??Usart0Handler_6:
   \   000000B6   E080               LDI     R24, 0
     48                      }
     49                      GoToSyncUART(0) ;                                    // go to sync modus for recive
   \                     ??Usart0Handler_5:
   \   000000B8   E000               LDI     R16, 0
   \   000000BA   ....               RCALL   ?Subroutine3
     50                  }
     51              }
   \                     ??CrossCallReturnLabel_0:
   \   000000BC   CFE3               RJMP    ??Usart0Handler_0
     52          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   ........           JMP     GoToSyncUART
     53          
     54          /*************************************************************************
     55          *
     56          *  Check the incoming packages (ANPRO1)
     57          *
     58          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9049               LD      R4, Y+
   \   0000000A   9059               LD      R5, Y+
   \   0000000C   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
     59          void UsartCheckPackage(char ch) {
   \                     UsartCheckPackage:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C   2E40               MOV     R4, R16
     60          
     61              unsigned short pointer;
     62              char    retval ;
     63          
     64              UART[ch].RxSendReply = false ;                           // flag for answering set to fault
   \   0000000E   E10D               LDI     R16, 29
   \   00000010   9E40               MUL     R4, R16
   \   00000012   ....               LDI     R26, LOW(UART)
   \   00000014   ....               LDI     R27, (UART) >> 8
   \   00000016   0DA0               ADD     R26, R0
   \   00000018   1DB1               ADC     R27, R1
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   01FD               MOVW    R31:R30, R27:R26
   \   0000001E   8F04               STD     Z+28, R16
     65              UART[ch].TxFirst = 6 ;                                 // Start pos for first TX command
   \   00000020   E006               LDI     R16, 6
   \   00000022   E010               LDI     R17, 0
   \   00000024   8302               STD     Z+2, R16
   \   00000026   8313               STD     Z+3, R17
     66              pointer = 4 ;
   \   00000028   E084               LDI     R24, 4
   \   0000002A   E090               LDI     R25, 0
     67              do {
     68                  retval = CheckActionUart(ch, pointer);
   \                     ??UsartCheckPackage_0:
   \   0000002C   019C               MOVW    R19:R18, R25:R24
   \   0000002E   2D04               MOV     R16, R4
   \   00000030   ....               RCALL   CheckActionUart
   \   00000032   2E50               MOV     R5, R16
     69                  pointer = pointer + UART[ch].pRxBuffer[pointer+1] + 2;        // Point to a command cmd hb/lb
   \   00000034   01FD               MOVW    R31:R30, R27:R26
   \   00000036   8504               LDD     R16, Z+12
   \   00000038   8515               LDD     R17, Z+13
   \   0000003A   0F08               ADD     R16, R24
   \   0000003C   1F19               ADC     R17, R25
   \   0000003E   01F8               MOVW    R31:R30, R17:R16
   \   00000040   81E1               LDD     R30, Z+1
   \   00000042   E0F0               LDI     R31, 0
   \   00000044   9632               ADIW    R31:R30, 2
   \   00000046   0F8E               ADD     R24, R30
   \   00000048   1F9F               ADC     R25, R31
     70                  OS_Delay(0);
   \   0000004A   E000               LDI     R16, 0
   \   0000004C   E010               LDI     R17, 0
   \   0000004E   ........           CALL    OS_Delay
     71              } while (retval && (pointer < (UART[ch].RxPacklen - 2 )));
   \   00000052   2055               TST     R5
   \   00000054   F041               BREQ    ??UsartCheckPackage_1
   \   00000056   01FD               MOVW    R31:R30, R27:R26
   \   00000058   8D00               LDD     R16, Z+24
   \   0000005A   8D11               LDD     R17, Z+25
   \   0000005C   5002               SUBI    R16, 2
   \   0000005E   4010               SBCI    R17, 0
   \   00000060   1780               CP      R24, R16
   \   00000062   0791               CPC     R25, R17
   \   00000064   F318               BRCS    ??UsartCheckPackage_0
     72              if (UART[ch].RxSendReply) {                              //send answer
   \                     ??UsartCheckPackage_1:
   \   00000066   01FD               MOVW    R31:R30, R27:R26
   \   00000068   8D04               LDD     R16, Z+28
   \   0000006A   2300               TST     R16
   \   0000006C   F011               BREQ    ??UsartCheckPackage_2
     73                  Uart_BuildTail(ch);
   \   0000006E   2D04               MOV     R16, R4
   \   00000070   ....               RCALL   Uart_BuildTail
     74              }
     75              GoToSyncUART(ch) ;                                    // go to sync modus for recive
   \                     ??UsartCheckPackage_2:
   \   00000072   2D04               MOV     R16, R4
   \   00000074   ....               RCALL   ?Subroutine3
     76          }
   \                     ??CrossCallReturnLabel_1:
   \   00000076   ....               RJMP    ?Subroutine1
     77          
     78          /*************************************************************************
     79          *
     80          *  Check action on received data (ANPRO1)
     81          *
     82          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     83          char CheckActionUart(char ch, unsigned short pointer) {
   \                     CheckActionUart:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C   2E40               MOV     R4, R16
   \   0000000E   01C9               MOVW    R25:R24, R19:R18
     84          
     85              unsigned short   command;
     86              char    retval = true;
   \   00000010   2455               CLR     R5
   \   00000012   9453               INC     R5
     87              float test = 2.0;
     88          
     89              test *= pointer; 
     90              test = 0;
     91              
     92              if (UART[ch].pRxBuffer[pointer+2] == MySecAddress) {	  // reset com error cnt. if lagal address
   \   00000014   E10D               LDI     R16, 29
   \   00000016   9E40               MUL     R4, R16
   \   00000018   ....               LDI     R26, LOW(UART)
   \   0000001A   ....               LDI     R27, (UART) >> 8
   \   0000001C   0DA0               ADD     R26, R0
   \   0000001E   1DB1               ADC     R27, R1
   \   00000020   01FD               MOVW    R31:R30, R27:R26
   \   00000022   8504               LDD     R16, Z+12
   \   00000024   8515               LDD     R17, Z+13
   \   00000026   0F02               ADD     R16, R18
   \   00000028   1F13               ADC     R17, R19
   \   0000002A   01F8               MOVW    R31:R30, R17:R16
   \   0000002C   8102               LDD     R16, Z+2
   \   0000002E   9110....           LDS     R17, MySecAddress
   \   00000032   1701               CP      R16, R17
   \   00000034   F461               BRNE    ??CheckActionUart_0
     93                if (RXTimeout) {
   \   00000036   9100....           LDS     R16, RXTimeout
   \   0000003A   2300               TST     R16
   \   0000003C   F029               BREQ    ??CheckActionUart_1
     94                  PrintComError(" OK", ALARM_OFF) ;
   \   0000003E   E020               LDI     R18, 0
   \   00000040   ....               LDI     R16, LOW(`?<Constant " OK">`)
   \   00000042   ....               LDI     R17, (`?<Constant " OK">`) >> 8
   \   00000044   ........           CALL    PrintComError
     95                }
     96                RXTimeout = false;
   \                     ??CheckActionUart_1:
   \   00000048   E000               LDI     R16, 0
   \   0000004A   9300....           STS     RXTimeout, R16
     97              }
     98          
     99              command = UART[ch].pRxBuffer[pointer];
   \                     ??CheckActionUart_0:
   \   0000004E   01FD               MOVW    R31:R30, R27:R26
   \   00000050   8524               LDD     R18, Z+12
   \   00000052   8535               LDD     R19, Z+13
   \   00000054   0189               MOVW    R17:R16, R19:R18
   \   00000056   0F08               ADD     R16, R24
   \   00000058   1F19               ADC     R17, R25
   \   0000005A   01F8               MOVW    R31:R30, R17:R16
   \   0000005C   8160               LD      R22, Z
    100              switch (command) {                                  // check action 
   \   0000005E   2F46               MOV     R20, R22
   \   00000060   5E46               SUBI    R20, 230
   \   00000062   354F               CPI     R20, 95
   \   00000064   F008               BRCS    $+2+2
   \   00000066   C11D               RJMP    ??CheckActionUart_2
   \   00000068   ....               LDI     R31, (`?<Jumptable for CheckActionUart>_0`) >> 16
   \   0000006A   BFFB               OUT     0x3B, R31
   \   0000006C   E0F2               LDI     R31, 2
   \   0000006E   9F4F               MUL     R20, R31
   \   00000070   01F0               MOVW    R31:R30, R1:R0
   \   00000072   ....               SUBI    R30, LOW((-(`?<Jumptable for CheckActionUart>_0`) & 0xFFFF))
   \   00000074   ....               SBCI    R31, (-(`?<Jumptable for CheckActionUart>_0`) & 0xFFFF) >> 8
   \   00000076   9007               ELPM    R0, Z+
   \   00000078   9016               ELPM    R1, Z
   \   0000007A   01F0               MOVW    R31:R30, R1:R0
   \   0000007C   9409               IJMP
    101          
    102              case ANP1_SND_XTXT :                        // Receive data for X-Displays
    103                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_3:
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   8102               LDD     R16, Z+2
   \   00000082   9110....           LDS     R17, MySecAddress
   \   00000086   1701               CP      R16, R17
   \   00000088   F009               BREQ    $+2+2
   \   0000008A   C11D               RJMP    ??CheckActionUart_4
    104                  RecXText(ch, pointer+3);
   \   0000008C   9603               ADIW    R25:R24, 3
   \   0000008E   019C               MOVW    R19:R18, R25:R24
   \   00000090   2D04               MOV     R16, R4
   \   00000092   ....               RCALL   RecXText
   \   00000094   C118               RJMP    ??CheckActionUart_4
    105                }
    106                break;
    107          
    108              case ANP1_SND_LOTXT :                        // Receive data for low display
    109                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_5:
   \   00000096   01F8               MOVW    R31:R30, R17:R16
   \   00000098   8102               LDD     R16, Z+2
   \   0000009A   9110....           LDS     R17, MySecAddress
   \   0000009E   1701               CP      R16, R17
   \   000000A0   F009               BREQ    $+2+2
   \   000000A2   C111               RJMP    ??CheckActionUart_4
    110                  RecLowText(ch, pointer+3);
   \   000000A4   9603               ADIW    R25:R24, 3
   \   000000A6   019C               MOVW    R19:R18, R25:R24
   \   000000A8   2D04               MOV     R16, R4
   \   000000AA   ....               RCALL   RecLowText
   \   000000AC   C10C               RJMP    ??CheckActionUart_4
    111                }
    112                break;
    113          
    114              case ANP1_SND_HITXT :                        // Receive data for high display
    115                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_6:
   \   000000AE   01F8               MOVW    R31:R30, R17:R16
   \   000000B0   8102               LDD     R16, Z+2
   \   000000B2   9110....           LDS     R17, MySecAddress
   \   000000B6   1701               CP      R16, R17
   \   000000B8   F009               BREQ    $+2+2
   \   000000BA   C105               RJMP    ??CheckActionUart_4
    116                  RecHighText(ch, pointer+3);
   \   000000BC   9603               ADIW    R25:R24, 3
   \   000000BE   019C               MOVW    R19:R18, R25:R24
   \   000000C0   2D04               MOV     R16, R4
   \   000000C2   ....               RCALL   RecHighText
   \   000000C4   C100               RJMP    ??CheckActionUart_4
    117                }
    118                break; 
    119                
    120              case ANP1_SND_BAVAL :                        // Receive data for pri bar graph
    121                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_7:
   \   000000C6   01F8               MOVW    R31:R30, R17:R16
   \   000000C8   8102               LDD     R16, Z+2
   \   000000CA   9110....           LDS     R17, MySecAddress
   \   000000CE   1701               CP      R16, R17
   \   000000D0   F009               BREQ    $+2+2
   \   000000D2   C0F9               RJMP    ??CheckActionUart_4
    122                  RecPriBarVal(ch, pointer+3);
   \   000000D4   9603               ADIW    R25:R24, 3
   \   000000D6   019C               MOVW    R19:R18, R25:R24
   \   000000D8   2D04               MOV     R16, R4
   \   000000DA   ....               RCALL   RecPriBarVal
   \   000000DC   C0F4               RJMP    ??CheckActionUart_4
    123                }
    124                break;
    125                
    126              case ANP1_SND_BAVOL :                        // Receive data for sec bar graph
    127                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_8:
   \   000000DE   01F8               MOVW    R31:R30, R17:R16
   \   000000E0   8102               LDD     R16, Z+2
   \   000000E2   9110....           LDS     R17, MySecAddress
   \   000000E6   1701               CP      R16, R17
   \   000000E8   F009               BREQ    $+2+2
   \   000000EA   C0ED               RJMP    ??CheckActionUart_4
    128                  RecSecBarVal(ch, pointer+3);
   \   000000EC   9603               ADIW    R25:R24, 3
   \   000000EE   019C               MOVW    R19:R18, R25:R24
   \   000000F0   2D04               MOV     R16, R4
   \   000000F2   ....               RCALL   RecSecBarVal
   \   000000F4   C0E8               RJMP    ??CheckActionUart_4
    129                }
    130                break; 
    131                
    132              case ANP1_SND_ALSTA :                        // Receive data for alarm status
    133                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_9:
   \   000000F6   01F8               MOVW    R31:R30, R17:R16
   \   000000F8   8122               LDD     R18, Z+2
   \   000000FA   9130....           LDS     R19, MySecAddress
   \   000000FE   1723               CP      R18, R19
   \   00000100   F009               BREQ    $+2+2
   \   00000102   C0E1               RJMP    ??CheckActionUart_4
    134                  RecAlStatus(ch, pointer+3);
   \   00000104   8103               LDD     R16, Z+3
   \   00000106   9300....           STS     (Disp + 1751), R16
   \   0000010A   9100....           LDS     R16, (Disp + 1752)
   \   0000010E   2300               TST     R16
   \   00000110   F009               BREQ    $+2+2
   \   00000112   C0D9               RJMP    ??CheckActionUart_4
   \   00000114   9100....           LDS     R16, (Disp + 1752)
   \   00000118   ........           CALL    RefreshDisplay
   \   0000011C   C0D4               RJMP    ??CheckActionUart_4
    135                }
    136                break; 
    137                
    138               case ANP1_REQ_ACKSTAT :                     // Receive data acknowledge status
    139                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_10:
   \   0000011E   01F8               MOVW    R31:R30, R17:R16
   \   00000120   8102               LDD     R16, Z+2
   \   00000122   9110....           LDS     R17, MySecAddress
   \   00000126   1701               CP      R16, R17
   \   00000128   F009               BREQ    $+2+2
   \   0000012A   C0CD               RJMP    ??CheckActionUart_4
    140                  RecAckStatus(ch, pointer+3);
   \   0000012C   ....               LDI     R30, LOW(tx_status)
   \   0000012E   ....               LDI     R31, (tx_status) >> 8
   \   00000130   8100               LD      R16, Z
   \   00000132   7F0D               ANDI    R16, 0xFD
   \   00000134   8300               ST      Z, R16
    141                }
   \   00000136   C0C7               RJMP    ??CheckActionUart_4
    142                break; 
    143                
    144               case ANP1_SND_LOGRA :                     // Receive image for low disp
    145                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_11:
   \   00000138   01F8               MOVW    R31:R30, R17:R16
   \   0000013A   8102               LDD     R16, Z+2
   \   0000013C   9110....           LDS     R17, MySecAddress
   \   00000140   1701               CP      R16, R17
   \   00000142   F009               BREQ    $+2+2
   \   00000144   C0C0               RJMP    ??CheckActionUart_4
    146                  RecLoGraph(ch, pointer+3);
   \   00000146   9603               ADIW    R25:R24, 3
   \   00000148   019C               MOVW    R19:R18, R25:R24
   \   0000014A   2D04               MOV     R16, R4
   \   0000014C   ....               RCALL   RecLoGraph
   \   0000014E   C0BB               RJMP    ??CheckActionUart_4
    147                }
    148                break;
    149          
    150               case ANP1_SND_HIIMG :                     // Receive image for bar graph
    151                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_12:
   \   00000150   01F8               MOVW    R31:R30, R17:R16
   \   00000152   8102               LDD     R16, Z+2
   \   00000154   9110....           LDS     R17, MySecAddress
   \   00000158   1701               CP      R16, R17
   \   0000015A   F009               BREQ    $+2+2
   \   0000015C   C0B4               RJMP    ??CheckActionUart_4
    152                  RecHiImage(ch, pointer+3);
   \   0000015E   9603               ADIW    R25:R24, 3
   \   00000160   019C               MOVW    R19:R18, R25:R24
   \   00000162   2D04               MOV     R16, R4
   \   00000164   ....               RCALL   RecHiImage
   \   00000166   C0AF               RJMP    ??CheckActionUart_4
    153                }
    154                break;
    155          
    156               case ANP1_SND_DVAL :                     // Receive Display window
    157                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_13:
   \   00000168   01F8               MOVW    R31:R30, R17:R16
   \   0000016A   8102               LDD     R16, Z+2
   \   0000016C   9110....           LDS     R17, MySecAddress
   \   00000170   1701               CP      R16, R17
   \   00000172   F009               BREQ    $+2+2
   \   00000174   C0A8               RJMP    ??CheckActionUart_4
    158                  RecValDisp(ch, pointer+3);
   \   00000176   9603               ADIW    R25:R24, 3
   \   00000178   019C               MOVW    R19:R18, R25:R24
   \   0000017A   2D04               MOV     R16, R4
   \   0000017C   ....               RCALL   RecValDisp
   \   0000017E   C0A3               RJMP    ??CheckActionUart_4
    159                }
    160                break;
    161                
    162               case ANP1_SND_DISDVAL :                     // Receive disable window command
    163                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_14:
   \   00000180   01F8               MOVW    R31:R30, R17:R16
   \   00000182   8102               LDD     R16, Z+2
   \   00000184   9110....           LDS     R17, MySecAddress
   \   00000188   1701               CP      R16, R17
   \   0000018A   F009               BREQ    $+2+2
   \   0000018C   C09C               RJMP    ??CheckActionUart_4
    164                  RecDisableDisp(ch, pointer+3);
   \   0000018E   9603               ADIW    R25:R24, 3
   \   00000190   019C               MOVW    R19:R18, R25:R24
   \   00000192   2D04               MOV     R16, R4
   \   00000194   ....               RCALL   RecDisableDisp
   \   00000196   C097               RJMP    ??CheckActionUart_4
    165                }
    166                break;
    167                
    168               case ANP1_SND_EEPDATA :                     // Receive Eepromdata
    169                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_15:
   \   00000198   01F8               MOVW    R31:R30, R17:R16
   \   0000019A   8102               LDD     R16, Z+2
   \   0000019C   9110....           LDS     R17, MySecAddress
   \   000001A0   1701               CP      R16, R17
   \   000001A2   F009               BREQ    $+2+2
   \   000001A4   C090               RJMP    ??CheckActionUart_4
    170                  RecEepData(ch, pointer+3);
   \   000001A6   9603               ADIW    R25:R24, 3
   \   000001A8   019C               MOVW    R19:R18, R25:R24
   \   000001AA   2D04               MOV     R16, R4
   \   000001AC   ....               RCALL   RecEepData
   \   000001AE   C08B               RJMP    ??CheckActionUart_4
    171                }
    172                break;
    173          
    174               case ANP1_SND_CASET :                     // Receive card setup
    175                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_16:
   \   000001B0   01F8               MOVW    R31:R30, R17:R16
   \   000001B2   8102               LDD     R16, Z+2
   \   000001B4   9110....           LDS     R17, MySecAddress
   \   000001B8   1701               CP      R16, R17
   \   000001BA   F009               BREQ    $+2+2
   \   000001BC   C084               RJMP    ??CheckActionUart_4
    176                  RecSetupData(ch, pointer+3);
   \   000001BE   9603               ADIW    R25:R24, 3
   \   000001C0   0F28               ADD     R18, R24
   \   000001C2   1F39               ADC     R19, R25
   \   000001C4   01F9               MOVW    R31:R30, R19:R18
   \   000001C6   8120               LD      R18, Z
   \   000001C8   E001               LDI     R16, 1
   \   000001CA   E010               LDI     R17, 0
   \   000001CC   ........           CALL    WriteEEPROMByte
   \   000001D0   01FD               MOVW    R31:R30, R27:R26
   \   000001D2   8504               LDD     R16, Z+12
   \   000001D4   8515               LDD     R17, Z+13
   \   000001D6   0F08               ADD     R16, R24
   \   000001D8   1F19               ADC     R17, R25
   \   000001DA   01F8               MOVW    R31:R30, R17:R16
   \   000001DC   8121               LDD     R18, Z+1
   \   000001DE   E002               LDI     R16, 2
   \   000001E0   E010               LDI     R17, 0
   \   000001E2   ........           CALL    WriteEEPROMByte
    177                }
   \   000001E6   C06F               RJMP    ??CheckActionUart_4
    178                break;
    179          
    180                //*//
    181              case ANP1_REQ_TXEEP :                         // Request eepromdata
    182                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_17:
   \   000001E8   01F8               MOVW    R31:R30, R17:R16
   \   000001EA   8102               LDD     R16, Z+2
   \   000001EC   9110....           LDS     R17, MySecAddress
   \   000001F0   1701               CP      R16, R17
   \   000001F2   F009               BREQ    $+2+2
   \   000001F4   C068               RJMP    ??CheckActionUart_4
    183                  BuildEepData(ch, pointer+3);
   \   000001F6   9603               ADIW    R25:R24, 3
   \   000001F8   019C               MOVW    R19:R18, R25:R24
   \   000001FA   2D04               MOV     R16, R4
   \   000001FC   ....               RCALL   BuildEepData
   \   000001FE   C063               RJMP    ??CheckActionUart_4
    184                }
    185                break;
    186                
    187              case ANP1_SND_WEEP :                         // Write eeprom (dallas type)
    188                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_18:
   \   00000200   01F8               MOVW    R31:R30, R17:R16
   \   00000202   8102               LDD     R16, Z+2
   \   00000204   9110....           LDS     R17, MySecAddress
   \   00000208   1701               CP      R16, R17
   \   0000020A   F009               BREQ    $+2+2
   \   0000020C   C05C               RJMP    ??CheckActionUart_4
    189                  BuildEEPWriteData(ch, pointer+3);
   \   0000020E   9603               ADIW    R25:R24, 3
   \   00000210   019C               MOVW    R19:R18, R25:R24
   \   00000212   2D04               MOV     R16, R4
   \   00000214   ....               RCALL   BuildEEPWriteData
   \   00000216   C057               RJMP    ??CheckActionUart_4
    190                }
    191                break;
    192          
    193              case ANP1_SND_WAPR :                         // Write AP register
    194                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_19:
   \   00000218   01F8               MOVW    R31:R30, R17:R16
   \   0000021A   8102               LDD     R16, Z+2
   \   0000021C   9110....           LDS     R17, MySecAddress
   \   00000220   1701               CP      R16, R17
   \   00000222   F009               BREQ    $+2+2
   \   00000224   C050               RJMP    ??CheckActionUart_4
    195                  BuildAPWriteData(ch, pointer+3);
   \   00000226   9603               ADIW    R25:R24, 3
   \   00000228   019C               MOVW    R19:R18, R25:R24
   \   0000022A   2D04               MOV     R16, R4
   \   0000022C   ....               RCALL   BuildAPWriteData
   \   0000022E   C04B               RJMP    ??CheckActionUart_4
    196                }
    197                break;
    198          
    199              case ANP1_REQ_TXSER :                         // Ask for dallas ID
    200                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_20:
   \   00000230   01F8               MOVW    R31:R30, R17:R16
   \   00000232   8102               LDD     R16, Z+2
   \   00000234   9110....           LDS     R17, MySecAddress
   \   00000238   1701               CP      R16, R17
   \   0000023A   F009               BREQ    $+2+2
   \   0000023C   C044               RJMP    ??CheckActionUart_4
    201                  BuildDallasData(ch, pointer+3);
   \   0000023E   9603               ADIW    R25:R24, 3
   \   00000240   019C               MOVW    R19:R18, R25:R24
   \   00000242   2D04               MOV     R16, R4
   \   00000244   ....               RCALL   BuildDallasData
   \   00000246   C03F               RJMP    ??CheckActionUart_4
    202                }
    203                break;
    204          
    205              case ANP1_REQ_STAT :                         // Request card status
    206                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_21:
   \   00000248   01F8               MOVW    R31:R30, R17:R16
   \   0000024A   8102               LDD     R16, Z+2
   \   0000024C   9110....           LDS     R17, MySecAddress
   \   00000250   1701               CP      R16, R17
   \   00000252   F5C9               BRNE    ??CheckActionUart_4
    207                  BuildStatusData(ch, pointer+3);
   \   00000254   9603               ADIW    R25:R24, 3
   \   00000256   019C               MOVW    R19:R18, R25:R24
   \   00000258   2D04               MOV     R16, R4
   \   0000025A   ....               RCALL   BuildStatusData
   \   0000025C   C034               RJMP    ??CheckActionUart_4
    208                }
    209                break;
    210          
    211              case ANP1_REQ_STACKSTATUS :                        // Request stck status
    212                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_22:
   \   0000025E   01F8               MOVW    R31:R30, R17:R16
   \   00000260   8102               LDD     R16, Z+2
   \   00000262   9110....           LDS     R17, MySecAddress
   \   00000266   1701               CP      R16, R17
   \   00000268   F571               BRNE    ??CheckActionUart_4
    213                  BuildStackStatus(ch, pointer+3) ;                     // receive package	
   \   0000026A   9603               ADIW    R25:R24, 3
   \   0000026C   019C               MOVW    R19:R18, R25:R24
   \   0000026E   2D04               MOV     R16, R4
   \   00000270   ....               RCALL   BuildStackStatus
   \   00000272   C029               RJMP    ??CheckActionUart_4
    214                }
    215                break ;
    216              case ANP1_GOTO_BOOTLOADER :                        // Goto bootlaoder??
    217                if (UART[ch].pRxBuffer[pointer+2]== MySecAddress) {
   \                     ??CheckActionUart_23:
   \   00000274   01F8               MOVW    R31:R30, R17:R16
   \   00000276   8102               LDD     R16, Z+2
   \   00000278   9110....           LDS     R17, MySecAddress
   \   0000027C   1701               CP      R16, R17
   \   0000027E   F519               BRNE    ??CheckActionUart_4
   \                     ??CheckActionUart_24:
   \   00000280   99E1               SBIC    0x1C, 0x01
   \   00000282   CFFE               RJMP    ??CheckActionUart_24
   \   00000284   EF0F               LDI     R16, 255
   \   00000286   BB0E               OUT     0x1E, R16
   \   00000288   E00F               LDI     R16, 15
   \   0000028A   BB0F               OUT     0x1F, R16
   \   0000028C   EF0F               LDI     R16, 255
   \   0000028E   BB0D               OUT     0x1D, R16
   \   00000290   9AE2               SBI     0x1C, 0x02
   \   00000292   9AE1               SBI     0x1C, 0x01
   \                     ??CheckActionUart_25:
   \   00000294   99E1               SBIC    0x1C, 0x01
   \   00000296   CFFE               RJMP    ??CheckActionUart_25
   \   00000298   E108               LDI     R16, 24
   \   0000029A   BD01               OUT     0x21, R16
   \   0000029C   E008               LDI     R16, 8
   \   0000029E   BD01               OUT     0x21, R16
   \   000002A0   C012               RJMP    ??CheckActionUart_4
    218                  GetGotoBootloader(ch, pointer+3) ;                     // receive package	
    219                }
    220                break ;
    221          
    222              default:
    223                  if (command < ANP1_MAX_ECMD) {                   // handle end commands
   \                     ??CheckActionUart_2:
   \   000002A2   306A               CPI     R22, 10
   \   000002A4   F480               BRCC    ??CheckActionUart_4
    224                     switch (command) {                                  // check action 
   \   000002A6   3062               CPI     R22, 2
   \   000002A8   F469               BRNE    ??CheckActionUart_26
    225                        case ANP1_ECMD_SNDOK :								/* OK to send data*/
    226                          if (tx_status & ALARM_SEND) {
   \   000002AA   9100....           LDS     R16, tx_status
   \   000002AE   FF01               SBRS    R16, 1
   \   000002B0   C009               RJMP    ??CheckActionUart_26
    227                              BuildCardData(ch, pointer+3);
   \   000002B2   9603               ADIW    R25:R24, 3
   \   000002B4   019C               MOVW    R19:R18, R25:R24
   \   000002B6   2D04               MOV     R16, R4
   \   000002B8   ....               RCALL   BuildCardData
    228                              tx_status &= ~TX_SENDOK ;       // sent once
   \   000002BA   ....               LDI     R30, LOW(tx_status)
   \   000002BC   ....               LDI     R31, (tx_status) >> 8
   \   000002BE   8100               LD      R16, Z
   \   000002C0   7F0E               ANDI    R16, 0xFE
   \   000002C2   8300               ST      Z, R16
    229                          }
    230                        break ;
    231                     }   
    232                     retval = false ;
   \                     ??CheckActionUart_26:
   \   000002C4   2455               CLR     R5
    233                  }
    234                  break;
    235          
    236              }
    237              return retval;
   \                     ??CheckActionUart_4:
   \   000002C6   2D05               MOV     R16, R5
   \   000002C8                      REQUIRE ?Subroutine1
   \   000002C8                      REQUIRE _A_EECR
   \   000002C8                      REQUIRE _A_EEAR
   \   000002C8                      REQUIRE _A_EEDR
   \   000002C8                      REQUIRE _A_WDTCR
   \   000002C8                      ;               // Fall through to label ?Subroutine1
    238          }
    239          
    240          /*************************************************************************
    241          *
    242          * Build send packet header (ANPRO1)
    243          *
    244          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    245          void Uart_BuildHeader(char ch) {
   \                     Uart_BuildHeader:
   \   00000000   019D               MOVW    R19:R18, R27:R26
    246          
    247              UART[ch].RxFirst = 0;                                // Reset pointers
   \   00000002   E11D               LDI     R17, 29
   \   00000004   9F01               MUL     R16, R17
   \   00000006   ....               LDI     R26, LOW(UART)
   \   00000008   ....               LDI     R27, (UART) >> 8
   \   0000000A   0DA0               ADD     R26, R0
   \   0000000C   1DB1               ADC     R27, R1
   \   0000000E   E000               LDI     R16, 0
   \   00000010   E010               LDI     R17, 0
   \   00000012   01FD               MOVW    R31:R30, R27:R26
   \   00000014   8706               STD     Z+14, R16
   \   00000016   8707               STD     Z+15, R16
    248              UART[ch].RxLast  = 0;
   \   00000018   8B00               STD     Z+16, R16
   \   0000001A   8B01               STD     Z+17, R16
    249              UART[ch].TxLast  = 0;
   \   0000001C   8304               STD     Z+4, R16
   \   0000001E   8305               STD     Z+5, R16
    250          
    251              UART[ch].pTxBuffer[0] = ANPRO1_SYN ;                        /* Sync */
   \   00000020   E002               LDI     R16, 2
   \   00000022   91ED               LD      R30, X+
   \   00000024   91FC               LD      R31, X
   \   00000026   9711               SBIW    R27:R26, 1
   \   00000028   8300               ST      Z, R16
    252              UART[ch].pTxBuffer[1] = ANPRO1_SYN ;                        /* Sync */
   \   0000002A   91ED               LD      R30, X+
   \   0000002C   91FC               LD      R31, X
   \   0000002E   961B               ADIW    R27:R26, 11
   \   00000030   8301               STD     Z+1, R16
    253              UART[ch].pTxBuffer[2] = UART[ch].pRxBuffer[1] ;      /* RXID */
   \   00000032   91ED               LD      R30, X+
   \   00000034   91FC               LD      R31, X
   \   00000036   971D               SBIW    R27:R26, 13
   \   00000038   8101               LDD     R16, Z+1
   \   0000003A   91ED               LD      R30, X+
   \   0000003C   91FC               LD      R31, X
   \   0000003E   9711               SBIW    R27:R26, 1
   \   00000040   8302               STD     Z+2, R16
    254              UART[ch].pTxBuffer[3] = MyPriAddress;                 /* Tx address pri*/
   \   00000042   9100....           LDS     R16, MyPriAddress
   \   00000046   91ED               LD      R30, X+
   \   00000048   91FC               LD      R31, X
   \   0000004A   9711               SBIW    R27:R26, 1
   \   0000004C   8303               STD     Z+3, R16
    255              UART[ch].pTxBuffer[4] = 0 ;                          /* packlen HB, don't know yet */
   \   0000004E   91ED               LD      R30, X+
   \   00000050   91FC               LD      R31, X
   \   00000052   9711               SBIW    R27:R26, 1
   \   00000054   8314               STD     Z+4, R17
    256              UART[ch].pTxBuffer[5] = 0 ;                          /* packlen LB, don't know yet */
   \   00000056   91ED               LD      R30, X+
   \   00000058   91FC               LD      R31, X
   \   0000005A   8315               STD     Z+5, R17
    257          }
   \   0000005C   01D9               MOVW    R27:R26, R19:R18
   \   0000005E   9508               RET
    258          
    259          /*************************************************************************
    260          *
    261          * Build  packet tail (ANPRO1)
    262          *
    263          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    264          void Uart_BuildTail(char ch) {
   \                     Uart_BuildTail:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008   2F40               MOV     R20, R16
    265          
    266              Uart_BuildHeader(ch);                                    // fist build the header
   \   0000000A   ....               RCALL   Uart_BuildHeader
    267          
    268              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_ECMD_NMDWOACK ;  // End command 
   \   0000000C   E10D               LDI     R16, 29
   \   0000000E   9F40               MUL     R20, R16
   \   00000010   ....               LDI     R16, LOW(UART)
   \   00000012   ....               LDI     R17, (UART) >> 8
   \   00000014   0D00               ADD     R16, R0
   \   00000016   1D11               ADC     R17, R1
   \   00000018   E050               LDI     R21, 0
   \   0000001A   01F8               MOVW    R31:R30, R17:R16
   \   0000001C   8120               LD      R18, Z
   \   0000001E   8131               LDD     R19, Z+1
   \   00000020   8162               LDD     R22, Z+2
   \   00000022   8173               LDD     R23, Z+3
   \   00000024   0F26               ADD     R18, R22
   \   00000026   1F37               ADC     R19, R23
   \   00000028   01F9               MOVW    R31:R30, R19:R18
   \   0000002A   8350               ST      Z, R21
   \   0000002C   01F8               MOVW    R31:R30, R17:R16
   \   0000002E   8122               LDD     R18, Z+2
   \   00000030   8133               LDD     R19, Z+3
   \   00000032   5F2F               SUBI    R18, 255
   \   00000034   4F3F               SBCI    R19, 255
   \   00000036   8322               STD     Z+2, R18
   \   00000038   8333               STD     Z+3, R19
    269              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0x00 ;                  // End data 
   \   0000003A   8120               LD      R18, Z
   \   0000003C   8131               LDD     R19, Z+1
   \   0000003E   8162               LDD     R22, Z+2
   \   00000040   8173               LDD     R23, Z+3
   \   00000042   0F26               ADD     R18, R22
   \   00000044   1F37               ADC     R19, R23
   \   00000046   01F9               MOVW    R31:R30, R19:R18
   \   00000048   8350               ST      Z, R21
   \   0000004A   01F8               MOVW    R31:R30, R17:R16
   \   0000004C   8122               LDD     R18, Z+2
   \   0000004E   8133               LDD     R19, Z+3
   \   00000050   5F2F               SUBI    R18, 255
   \   00000052   4F3F               SBCI    R19, 255
   \   00000054   8322               STD     Z+2, R18
   \   00000056   8333               STD     Z+3, R19
    270          
    271              UART[ch].pTxBuffer[5] = UART[ch].TxFirst;                    // correct length because stx's
   \   00000058   2F52               MOV     R21, R18
   \   0000005A   8120               LD      R18, Z
   \   0000005C   81F1               LDD     R31, Z+1
   \   0000005E   2FE2               MOV     R30, R18
   \   00000060   8355               STD     Z+5, R21
    272              UART[ch].pTxBuffer[4] = (UART[ch].TxFirst) >> 8 ;             // packet len high 
   \   00000062   01F8               MOVW    R31:R30, R17:R16
   \   00000064   8153               LDD     R21, Z+3
   \   00000066   8120               LD      R18, Z
   \   00000068   81F1               LDD     R31, Z+1
   \   0000006A   2FE2               MOV     R30, R18
   \   0000006C   8354               STD     Z+4, R21
    273          
    274              UART[ch].pTxBuffer[UART[ch].TxFirst] = CalcDSTxChecksum(ch, UART[ch].TxFirst) ; // Get checksum 
   \   0000006E   01F8               MOVW    R31:R30, R17:R16
   \   00000070   8182               LDD     R24, Z+2
   \   00000072   8193               LDD     R25, Z+3
   \   00000074   E020               LDI     R18, 0
   \   00000076   8160               LD      R22, Z
   \   00000078   8171               LDD     R23, Z+1
   \   0000007A   3083               CPI     R24, 3
   \   0000007C   0792               CPC     R25, R18
   \   0000007E   F078               BRCS    ??Uart_BuildTail_0
   \   00000080   01DB               MOVW    R27:R26, R23:R22
   \   00000082   9612               ADIW    R27:R26, 2
   \   00000084   9702               SBIW    R25:R24, 2
   \   00000086   ....               LDI     R19, (crc) >> 16
   \                     ??Uart_BuildTail_1:
   \   00000088   2E02               MOV     R0, R18
   \   0000008A   27FF               CLR     R31
   \   0000008C   912D               LD      R18, X+
   \   0000008E   2602               EOR     R0, R18
   \   00000090   2DE0               MOV     R30, R0
   \   00000092   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000094   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000096   BF3B               OUT     0x3B, R19
   \   00000098   9126               ELPM    R18, Z
   \   0000009A   9701               SBIW    R25:R24, 1
   \   0000009C   F7A9               BRNE    ??Uart_BuildTail_1
   \                     ??Uart_BuildTail_0:
   \   0000009E   01F8               MOVW    R31:R30, R17:R16
   \   000000A0   8002               LDD     R0, Z+2
   \   000000A2   8013               LDD     R1, Z+3
   \   000000A4   0D60               ADD     R22, R0
   \   000000A6   1D71               ADC     R23, R1
   \   000000A8   01FB               MOVW    R31:R30, R23:R22
   \   000000AA   8320               ST      Z, R18
    275              UART[ch].TxFirst++ ;                                        // OBS!! must be inc here due
   \   000000AC   01F8               MOVW    R31:R30, R17:R16
   \   000000AE   8122               LDD     R18, Z+2
   \   000000B0   8133               LDD     R19, Z+3
   \   000000B2   5F2F               SUBI    R18, 255
   \   000000B4   4F3F               SBCI    R19, 255
   \   000000B6   8322               STD     Z+2, R18
   \   000000B8   8333               STD     Z+3, R19
    276                                                                          // to ANSI standard !!!!
    277          
    278              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANPRO1_EOT ;            // End of transmission 
   \   000000BA   E053               LDI     R21, 3
   \   000000BC   8120               LD      R18, Z
   \   000000BE   8131               LDD     R19, Z+1
   \   000000C0   8162               LDD     R22, Z+2
   \   000000C2   8173               LDD     R23, Z+3
   \   000000C4   0F26               ADD     R18, R22
   \   000000C6   1F37               ADC     R19, R23
   \   000000C8   01F9               MOVW    R31:R30, R19:R18
   \   000000CA   8350               ST      Z, R21
   \   000000CC   01F8               MOVW    R31:R30, R17:R16
   \   000000CE   8122               LDD     R18, Z+2
   \   000000D0   8133               LDD     R19, Z+3
   \   000000D2   5F2F               SUBI    R18, 255
   \   000000D4   4F3F               SBCI    R19, 255
   \   000000D6   8322               STD     Z+2, R18
   \   000000D8   8333               STD     Z+3, R19
    279              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0x00 ;            //switch off transmitter delay 
   \   000000DA   E050               LDI     R21, 0
   \   000000DC   8120               LD      R18, Z
   \   000000DE   8131               LDD     R19, Z+1
   \   000000E0   8162               LDD     R22, Z+2
   \   000000E2   8173               LDD     R23, Z+3
   \   000000E4   0F26               ADD     R18, R22
   \   000000E6   1F37               ADC     R19, R23
   \   000000E8   01F9               MOVW    R31:R30, R19:R18
   \   000000EA   8350               ST      Z, R21
   \   000000EC   01F8               MOVW    R31:R30, R17:R16
   \   000000EE   8122               LDD     R18, Z+2
   \   000000F0   8133               LDD     R19, Z+3
   \   000000F2   5F2F               SUBI    R18, 255
   \   000000F4   4F3F               SBCI    R19, 255
   \   000000F6   8322               STD     Z+2, R18
   \   000000F8   8333               STD     Z+3, R19
    280          
    281              UART[ch].TxCount = UART[ch].TxFirst;                      //bytes to send 
   \   000000FA   8326               STD     Z+6, R18
   \   000000FC   8337               STD     Z+7, R19
    282              UART[ch].TxLast = 0;                                     // reset cunter
   \   000000FE   8354               STD     Z+4, R21
   \   00000100   8355               STD     Z+5, R21
    283              UART[ch].TxPkCnt++ ;                                     // Count sent packages
   \   00000102   8500               LDD     R16, Z+8
   \   00000104   8511               LDD     R17, Z+9
   \   00000106   5F0F               SUBI    R16, 255
   \   00000108   4F1F               SBCI    R17, 255
   \   0000010A   8700               STD     Z+8, R16
   \   0000010C   8711               STD     Z+9, R17
    284              if (ch == 0) {                                           // Turn on TXE for channel
   \   0000010E   2344               TST     R20
   \   00000110   F451               BRNE    ??Uart_BuildTail_2
    285                  OS_RetriggerTimer(&TimerUSART0);                    // and start timeout timer
   \   00000112   ....               LDI     R16, LOW(TimerUSART0)
   \   00000114   ....               LDI     R17, (TimerUSART0) >> 8
   \   00000116   ........           CALL    OS_RetriggerTimer
    286                  SetBit(PORTE, 0x04) ;                                     // TXE0 on
   \   0000011A   9A1A               SBI     0x03, 0x02
    287                  OS_Delay(20);                                       // Wait (ms) for tx stable
   \   0000011C   E104               LDI     R16, 20
   \   0000011E   E010               LDI     R17, 0
   \   00000120   ........           CALL    OS_Delay
    288                  UCSR0B |= __BIT_MASK( UDRIE0) ;                     // start sending by enableing interrupt
   \   00000124   9A55               SBI     0x0A, 0x05
    289              } else if (ch ==1) {
    290                  // not used
    291              }
    292          }
   \                     ??Uart_BuildTail_2:
   \   00000126   ....               RJMP    ?Subroutine2
   \   00000128                      REQUIRE _A_PORTE
   \   00000128                      REQUIRE _A_UCSR0B

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9508               RET
    293          
    294          /*************************************************************************
    295          *
    296          * Build datablock for eeprom data
    297          *
    298          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    299          void BuildEepData(char ch, short pointer){
   \                     BuildEepData:
   \   00000000   011D               MOVW    R3:R2, R27:R26
    300          
    301          	short i, ntna;
    302              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000002   E11D               LDI     R17, 29
   \   00000004   9F01               MUL     R16, R17
   \   00000006   ....               LDI     R30, LOW(UART)
   \   00000008   ....               LDI     R31, (UART) >> 8
   \   0000000A   0DE0               ADD     R30, R0
   \   0000000C   1DF1               ADC     R31, R1
   \   0000000E   E001               LDI     R16, 1
   \   00000010   8F04               STD     Z+28, R16
    303          	
    304              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_EEP;     
   \   00000012   E504               LDI     R16, 84
   \   00000014   81A0               LD      R26, Z
   \   00000016   81B1               LDD     R27, Z+1
   \   00000018   8122               LDD     R18, Z+2
   \   0000001A   8133               LDD     R19, Z+3
   \   0000001C   0FA2               ADD     R26, R18
   \   0000001E   1FB3               ADC     R27, R19
   \   00000020   930C               ST      X, R16
   \   00000022   8102               LDD     R16, Z+2
   \   00000024   8113               LDD     R17, Z+3
   \   00000026   5F0F               SUBI    R16, 255
   \   00000028   4F1F               SBCI    R17, 255
   \   0000002A   8302               STD     Z+2, R16
   \   0000002C   8313               STD     Z+3, R17
    305              ntna = UART[ch].TxFirst++ ;                                    /* remember index */
   \   0000002E   0198               MOVW    R19:R18, R17:R16
   \   00000030   5F0F               SUBI    R16, 255
   \   00000032   4F1F               SBCI    R17, 255
   \   00000034   8302               STD     Z+2, R16
   \   00000036   8313               STD     Z+3, R17
    306          
    307          	  UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress ;			// Secondary address
   \   00000038   9100....           LDS     R16, MySecAddress
   \   0000003C   81A0               LD      R26, Z
   \   0000003E   81B1               LDD     R27, Z+1
   \   00000040   8142               LDD     R20, Z+2
   \   00000042   0FA4               ADD     R26, R20
   \   00000044   1FB1               ADC     R27, R17
   \   00000046   930C               ST      X, R16
   \   00000048   8102               LDD     R16, Z+2
   \   0000004A   8113               LDD     R17, Z+3
   \   0000004C   5F0F               SUBI    R16, 255
   \   0000004E   4F1F               SBCI    R17, 255
   \   00000050   8302               STD     Z+2, R16
   \   00000052   8313               STD     Z+3, R17
    308          	  for (i = 0; i < PACKED_DATA_SIZE; i++) {
   \   00000054   ....               LDI     R16, LOW(packed_data)
   \   00000056   ....               LDI     R17, (packed_data) >> 8
   \   00000058   E248               LDI     R20, 40
    309          		  UART[ch].pTxBuffer[UART[ch].TxFirst++] = packed_data[i]; /* data */
   \                     ??BuildEepData_0:
   \   0000005A   01D8               MOVW    R27:R26, R17:R16
   \   0000005C   915D               LD      R21, X+
   \   0000005E   018D               MOVW    R17:R16, R27:R26
   \   00000060   81A0               LD      R26, Z
   \   00000062   81B1               LDD     R27, Z+1
   \   00000064   8162               LDD     R22, Z+2
   \   00000066   8173               LDD     R23, Z+3
   \   00000068   0FA6               ADD     R26, R22
   \   0000006A   1FB7               ADC     R27, R23
   \   0000006C   935C               ST      X, R21
   \   0000006E   8162               LDD     R22, Z+2
   \   00000070   8173               LDD     R23, Z+3
   \   00000072   5F6F               SUBI    R22, 255
   \   00000074   4F7F               SBCI    R23, 255
   \   00000076   8362               STD     Z+2, R22
   \   00000078   8373               STD     Z+3, R23
    310          	  }
   \   0000007A   954A               DEC     R20
   \   0000007C   F771               BRNE    ??BuildEepData_0
    311              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \   0000007E   8142               LDD     R20, Z+2
   \   00000080   1B42               SUB     R20, R18
   \   00000082   954A               DEC     R20
   \   00000084   8100               LD      R16, Z
   \   00000086   8111               LDD     R17, Z+1
   \   00000088   0F02               ADD     R16, R18
   \   0000008A   1F13               ADC     R17, R19
   \   0000008C   01F8               MOVW    R31:R30, R17:R16
   \   0000008E   8340               ST      Z, R20
    312          }
   \   00000090   01D1               MOVW    R27:R26, R3:R2
   \   00000092   9508               RET
    313          
    314          /*************************************************************************
    315          *
    316          * Build answer for writing eeprom (Dallas type)
    317          *
    318          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   8100               LD      R16, Z
   \   00000002   8111               LDD     R17, Z+1
   \   00000004   8142               LDD     R20, Z+2
   \   00000006   8153               LDD     R21, Z+3
   \   00000008   0F04               ADD     R16, R20
   \   0000000A   1F15               ADC     R17, R21
   \   0000000C   01F8               MOVW    R31:R30, R17:R16
   \   0000000E   8320               ST      Z, R18
   \   00000010   01FD               MOVW    R31:R30, R27:R26
   \   00000012   8102               LDD     R16, Z+2
   \   00000014   8113               LDD     R17, Z+3
   \   00000016   5F0F               SUBI    R16, 255
   \   00000018   4F1F               SBCI    R17, 255
   \   0000001A   8302               STD     Z+2, R16
   \   0000001C   8313               STD     Z+3, R17
   \   0000001E   0138               MOVW    R7:R6, R17:R16
   \   00000020   5F0F               SUBI    R16, 255
   \   00000022   4F1F               SBCI    R17, 255
   \   00000024   8302               STD     Z+2, R16
   \   00000026   8313               STD     Z+3, R17
   \   00000028   E080               LDI     R24, 0
   \   0000002A   E090               LDI     R25, 0
   \   0000002C   ....               LDI     R16, LOW(packed_data)
   \   0000002E   2E40               MOV     R4, R16
   \   00000030   ....               LDI     R16, (packed_data) >> 8
   \   00000032   2E50               MOV     R5, R16
   \                     ??Subroutine0_0:
   \   00000034   01F2               MOVW    R31:R30, R5:R4
   \   00000036   9121               LD      R18, Z+
   \   00000038   012F               MOVW    R5:R4, R31:R30
   \   0000003A   018C               MOVW    R17:R16, R25:R24
   \   0000003C   5F0D               SUBI    R16, 253
   \   0000003E   4F1F               SBCI    R17, 255
   \   00000040   ........           CALL    WriteEEPROMByte
   \   00000044   9601               ADIW    R25:R24, 1
   \   00000046   3288               CPI     R24, 40
   \   00000048   E000               LDI     R16, 0
   \   0000004A   0790               CPC     R25, R16
   \   0000004C   F39C               BRLT    ??Subroutine0_0
   \   0000004E   E080               LDI     R24, 0
   \   00000050   E090               LDI     R25, 0
   \   00000052   ....               LDI     R16, LOW(packed_data)
   \   00000054   2E40               MOV     R4, R16
   \   00000056   ....               LDI     R16, (packed_data) >> 8
   \   00000058   2E50               MOV     R5, R16
   \                     ??Subroutine0_1:
   \   0000005A   018C               MOVW    R17:R16, R25:R24
   \   0000005C   5F0D               SUBI    R16, 253
   \   0000005E   4F1F               SBCI    R17, 255
   \   00000060   ........           CALL    ReadEEPROMByte
   \   00000064   01F2               MOVW    R31:R30, R5:R4
   \   00000066   8110               LD      R17, Z
   \   00000068   1701               CP      R16, R17
   \   0000006A   F009               BREQ    ??Subroutine0_2
   \   0000006C   2488               CLR     R8
   \                     ??Subroutine0_2:
   \   0000006E   9601               ADIW    R25:R24, 1
   \   00000070   E001               LDI     R16, 1
   \   00000072   0E40               ADD     R4, R16
   \   00000074   E000               LDI     R16, 0
   \   00000076   1E50               ADC     R5, R16
   \   00000078   3288               CPI     R24, 40
   \   0000007A   0790               CPC     R25, R16
   \   0000007C   F374               BRLT    ??Subroutine0_1
   \   0000007E   9120....           LDS     R18, MySecAddress
   \   00000082   910D               LD      R16, X+
   \   00000084   911C               LD      R17, X
   \   00000086   9711               SBIW    R27:R26, 1
   \   00000088   01FD               MOVW    R31:R30, R27:R26
   \   0000008A   8142               LDD     R20, Z+2
   \   0000008C   8153               LDD     R21, Z+3
   \   0000008E   0F04               ADD     R16, R20
   \   00000090   1F15               ADC     R17, R21
   \   00000092   01F8               MOVW    R31:R30, R17:R16
   \   00000094   8320               ST      Z, R18
   \   00000096   01FD               MOVW    R31:R30, R27:R26
   \   00000098   8102               LDD     R16, Z+2
   \   0000009A   8113               LDD     R17, Z+3
   \   0000009C   5F0F               SUBI    R16, 255
   \   0000009E   4F1F               SBCI    R17, 255
   \   000000A0   8302               STD     Z+2, R16
   \   000000A2   8313               STD     Z+3, R17
   \   000000A4   8100               LD      R16, Z
   \   000000A6   8111               LDD     R17, Z+1
   \   000000A8   8122               LDD     R18, Z+2
   \   000000AA   8133               LDD     R19, Z+3
   \   000000AC   0F02               ADD     R16, R18
   \   000000AE   1F13               ADC     R17, R19
   \   000000B0   01F8               MOVW    R31:R30, R17:R16
   \   000000B2   8280               ST      Z, R8
   \   000000B4   01FD               MOVW    R31:R30, R27:R26
   \   000000B6   8102               LDD     R16, Z+2
   \   000000B8   8113               LDD     R17, Z+3
   \   000000BA   5F0F               SUBI    R16, 255
   \   000000BC   4F1F               SBCI    R17, 255
   \   000000BE   8302               STD     Z+2, R16
   \   000000C0   8313               STD     Z+3, R17
   \   000000C2   1906               SUB     R16, R6
   \   000000C4   950A               DEC     R16
   \   000000C6   91ED               LD      R30, X+
   \   000000C8   91FC               LD      R31, X
   \   000000CA   0DE6               ADD     R30, R6
   \   000000CC   1DF7               ADC     R31, R7
   \   000000CE   8300               ST      Z, R16
   \   000000D0   9189               LD      R24, Y+
   \   000000D2   9199               LD      R25, Y+
   \   000000D4   91A9               LD      R26, Y+
   \   000000D6   91B9               LD      R27, Y+
   \   000000D8   9049               LD      R4, Y+
   \   000000DA   9059               LD      R5, Y+
   \   000000DC   9069               LD      R6, Y+
   \   000000DE   9079               LD      R7, Y+
   \   000000E0   9089               LD      R8, Y+
   \   000000E2   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    319          void BuildEEPWriteData(char ch, short pointer){
   \                     BuildEEPWriteData:
   \   00000000   928A               ST      -Y, R8
   \   00000002   927A               ST      -Y, R7
   \   00000004   926A               ST      -Y, R6
   \   00000006   925A               ST      -Y, R5
   \   00000008   924A               ST      -Y, R4
   \   0000000A   93BA               ST      -Y, R27
   \   0000000C   93AA               ST      -Y, R26
   \   0000000E   939A               ST      -Y, R25
   \   00000010   938A               ST      -Y, R24
   \   00000012                      REQUIRE ?Register_R4_is_cg_reg
   \   00000012                      REQUIRE ?Register_R5_is_cg_reg
   \   00000012                      REQUIRE ?Register_R6_is_cg_reg
   \   00000012                      REQUIRE ?Register_R7_is_cg_reg
   \   00000012                      REQUIRE ?Register_R8_is_cg_reg
    320          
    321              char retval = true;
   \   00000012   2488               CLR     R8
   \   00000014   9483               INC     R8
    322          	short i, ntna;
    323              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000016   E11D               LDI     R17, 29
   \   00000018   9F01               MUL     R16, R17
   \   0000001A   ....               LDI     R26, LOW(UART)
   \   0000001C   ....               LDI     R27, (UART) >> 8
   \   0000001E   0DA0               ADD     R26, R0
   \   00000020   1DB1               ADC     R27, R1
   \   00000022   01FD               MOVW    R31:R30, R27:R26
   \   00000024   8E84               STD     Z+28, R8
    324          	
    325              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_ACKWEEP;     
   \   00000026   E522               LDI     R18, 82
   \   00000028   ....               RJMP    ?Subroutine0
    326              ntna = UART[ch].TxFirst++ ;                                    /* remember index */
    327              
    328              for (i = 0; i < PACKED_DATA_SIZE; i++) {          //copy data from eeprom to ram
    329                 WriteEEPROMByte(EEPROM_EEPROMDATA+i, packed_data[i]);
    330              }
    331          
    332              for (i = 0; i < PACKED_DATA_SIZE; i++) {          //verify data from eeprom to ram
    333                 if (ReadEEPROMByte(EEPROM_EEPROMDATA+i) != packed_data[i]) {
    334                    retval = false ;
    335                 }
    336              }
    337          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress ;			// Secondary address
    338          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = retval ;			// Secondary address
    339              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
    340          }
    341          
    342          /*************************************************************************
    343          *
    344          * Build answer for writing AP register
    345          *
    346          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    347          void BuildAPWriteData(char ch, short pointer){
   \                     BuildAPWriteData:
   \   00000000   928A               ST      -Y, R8
   \   00000002   927A               ST      -Y, R7
   \   00000004   926A               ST      -Y, R6
   \   00000006   925A               ST      -Y, R5
   \   00000008   924A               ST      -Y, R4
   \   0000000A   93BA               ST      -Y, R27
   \   0000000C   93AA               ST      -Y, R26
   \   0000000E   939A               ST      -Y, R25
   \   00000010   938A               ST      -Y, R24
   \   00000012                      REQUIRE ?Register_R4_is_cg_reg
   \   00000012                      REQUIRE ?Register_R5_is_cg_reg
   \   00000012                      REQUIRE ?Register_R6_is_cg_reg
   \   00000012                      REQUIRE ?Register_R7_is_cg_reg
   \   00000012                      REQUIRE ?Register_R8_is_cg_reg
    348          
    349              char retval = true;
   \   00000012   2488               CLR     R8
   \   00000014   9483               INC     R8
    350          	short i, ntna;
    351              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000016   E11D               LDI     R17, 29
   \   00000018   9F01               MUL     R16, R17
   \   0000001A   ....               LDI     R26, LOW(UART)
   \   0000001C   ....               LDI     R27, (UART) >> 8
   \   0000001E   0DA0               ADD     R26, R0
   \   00000020   1DB1               ADC     R27, R1
   \   00000022   01FD               MOVW    R31:R30, R27:R26
   \   00000024   8E84               STD     Z+28, R8
    352          	
    353              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_ACKWAPR;     
   \   00000026   E523               LDI     R18, 83
   \   00000028                      REQUIRE ?Subroutine0
   \   00000028                      ;               // Fall through to label ?Subroutine0
    354              ntna = UART[ch].TxFirst++ ;                                    /* remember index */
    355              
    356              for (i = 0; i < PACKED_DATA_SIZE; i++) {          //copy data from eeprom to ram
    357                 WriteEEPROMByte(EEPROM_EEPROMDATA+i, packed_data[i]);
    358              }
    359          
    360              for (i = 0; i < PACKED_DATA_SIZE; i++) {          //verify data from eeprom to ram
    361                 if (ReadEEPROMByte(EEPROM_EEPROMDATA+i) != packed_data[i]) {
    362                    retval = false ;
    363                 }
    364              }
    365          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress ;			// Secondary address
    366          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = retval ;			// Secondary address
    367              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
    368          }
    369          
    370          /*************************************************************************
    371          *
    372          * Build answer for Dallas EEprom 
    373          *   !OBS: Does not have Dallas her, dummy for protocol matching with older products
    374          *
    375          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    376          void BuildDallasData(char ch, short pointer){
   \                     BuildDallasData:
   \   00000000   01BD               MOVW    R23:R22, R27:R26
    377          
    378          	short i, ntna;
    379              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000002   E11D               LDI     R17, 29
   \   00000004   9F01               MUL     R16, R17
   \   00000006   ....               LDI     R30, LOW(UART)
   \   00000008   ....               LDI     R31, (UART) >> 8
   \   0000000A   0DE0               ADD     R30, R0
   \   0000000C   1DF1               ADC     R31, R1
   \   0000000E   E001               LDI     R16, 1
   \   00000010   8F04               STD     Z+28, R16
    380          	
    381              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_EEPSER;     
   \   00000012   E508               LDI     R16, 88
   \   00000014   81A0               LD      R26, Z
   \   00000016   81B1               LDD     R27, Z+1
   \   00000018   8122               LDD     R18, Z+2
   \   0000001A   8133               LDD     R19, Z+3
   \   0000001C   0FA2               ADD     R26, R18
   \   0000001E   1FB3               ADC     R27, R19
   \   00000020   930C               ST      X, R16
   \   00000022   8102               LDD     R16, Z+2
   \   00000024   8113               LDD     R17, Z+3
   \   00000026   5F0F               SUBI    R16, 255
   \   00000028   4F1F               SBCI    R17, 255
   \   0000002A   8302               STD     Z+2, R16
   \   0000002C   8313               STD     Z+3, R17
    382              ntna = UART[ch].TxFirst++ ;                                    /* remember index */
   \   0000002E   0198               MOVW    R19:R18, R17:R16
   \   00000030   5F0F               SUBI    R16, 255
   \   00000032   4F1F               SBCI    R17, 255
   \   00000034   8302               STD     Z+2, R16
   \   00000036   8313               STD     Z+3, R17
    383          
    384          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress ;			// Secondary address
   \   00000038   9100....           LDS     R16, MySecAddress
   \   0000003C   81A0               LD      R26, Z
   \   0000003E   81B1               LDD     R27, Z+1
   \   00000040   8142               LDD     R20, Z+2
   \   00000042   0FA4               ADD     R26, R20
   \   00000044   1FB1               ADC     R27, R17
   \   00000046   930C               ST      X, R16
   \   00000048   8102               LDD     R16, Z+2
   \   0000004A   8113               LDD     R17, Z+3
   \   0000004C   5F0F               SUBI    R16, 255
   \   0000004E   4F1F               SBCI    R17, 255
   \   00000050   8302               STD     Z+2, R16
   \   00000052   8313               STD     Z+3, R17
    385              for (i = 0; i < 10; i++) {                                       //Send 10 0-es for fault
   \   00000054   E00A               LDI     R16, 10
   \   00000056   E010               LDI     R17, 0
    386                 UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0;
   \                     ??BuildDallasData_0:
   \   00000058   81A0               LD      R26, Z
   \   0000005A   81B1               LDD     R27, Z+1
   \   0000005C   8142               LDD     R20, Z+2
   \   0000005E   8153               LDD     R21, Z+3
   \   00000060   0FA4               ADD     R26, R20
   \   00000062   1FB5               ADC     R27, R21
   \   00000064   931C               ST      X, R17
   \   00000066   8142               LDD     R20, Z+2
   \   00000068   8153               LDD     R21, Z+3
   \   0000006A   5F4F               SUBI    R20, 255
   \   0000006C   4F5F               SBCI    R21, 255
   \   0000006E   8342               STD     Z+2, R20
   \   00000070   8353               STD     Z+3, R21
    387              }
   \   00000072   950A               DEC     R16
   \   00000074   F789               BRNE    ??BuildDallasData_0
    388          
    389              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \   00000076   8142               LDD     R20, Z+2
   \   00000078   1B42               SUB     R20, R18
   \   0000007A   954A               DEC     R20
   \   0000007C   8100               LD      R16, Z
   \   0000007E   8111               LDD     R17, Z+1
   \   00000080   0F02               ADD     R16, R18
   \   00000082   1F13               ADC     R17, R19
   \   00000084   01F8               MOVW    R31:R30, R17:R16
   \   00000086   8340               ST      Z, R20
    390          }
   \   00000088   01DB               MOVW    R27:R26, R23:R22
   \   0000008A   9508               RET
    391          
    392          /*************************************************************************
    393          *
    394          * Build datablock for card status
    395          *
    396          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    397          void BuildStatusData(char ch, short pointer){
   \                     BuildStatusData:
   \   00000000   2F5B               MOV     R21, R27
   \   00000002   2F6A               MOV     R22, R26
    398          
    399              short ntna ;
    400              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   E001               LDI     R16, 1
   \   00000012   8F04               STD     Z+28, R16
    401          
    402              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_STAT;     
   \   00000014   E40F               LDI     R16, 79
   \   00000016   81A0               LD      R26, Z
   \   00000018   81B1               LDD     R27, Z+1
   \   0000001A   8122               LDD     R18, Z+2
   \   0000001C   8133               LDD     R19, Z+3
   \   0000001E   0FA2               ADD     R26, R18
   \   00000020   1FB3               ADC     R27, R19
   \   00000022   930C               ST      X, R16
   \   00000024   8102               LDD     R16, Z+2
   \   00000026   8113               LDD     R17, Z+3
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   8302               STD     Z+2, R16
   \   0000002E   8313               STD     Z+3, R17
    403              ntna = UART[ch].TxFirst++ ;                                    /* remember index */
   \   00000030   0198               MOVW    R19:R18, R17:R16
   \   00000032   5F2F               SUBI    R18, 255
   \   00000034   4F3F               SBCI    R19, 255
   \   00000036   8322               STD     Z+2, R18
   \   00000038   8333               STD     Z+3, R19
    404          
    405              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress;           // unit adddress sec
   \   0000003A   9120....           LDS     R18, MySecAddress
   \   0000003E   81A0               LD      R26, Z
   \   00000040   81B1               LDD     R27, Z+1
   \   00000042   8142               LDD     R20, Z+2
   \   00000044   0FA4               ADD     R26, R20
   \   00000046   1FB3               ADC     R27, R19
   \   00000048   932C               ST      X, R18
   \   0000004A   8122               LDD     R18, Z+2
   \   0000004C   8133               LDD     R19, Z+3
   \   0000004E   5F2F               SUBI    R18, 255
   \   00000050   4F3F               SBCI    R19, 255
   \   00000052   8322               STD     Z+2, R18
   \   00000054   8333               STD     Z+3, R19
    406              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROG_VERSION ;       // software version */
   \   00000056   E12C               LDI     R18, 28
   \   00000058   81A0               LD      R26, Z
   \   0000005A   81B1               LDD     R27, Z+1
   \   0000005C   8142               LDD     R20, Z+2
   \   0000005E   0FA4               ADD     R26, R20
   \   00000060   1FB3               ADC     R27, R19
   \   00000062   932C               ST      X, R18
   \   00000064   8122               LDD     R18, Z+2
   \   00000066   8133               LDD     R19, Z+3
   \   00000068   5F2F               SUBI    R18, 255
   \   0000006A   4F3F               SBCI    R19, 255
   \   0000006C   8322               STD     Z+2, R18
   \   0000006E   8333               STD     Z+3, R19
    407              UART[ch].pTxBuffer[UART[ch].TxFirst++] = UnitID ;       // software version */
   \   00000070   9120....           LDS     R18, UnitID
   \   00000074   81A0               LD      R26, Z
   \   00000076   81B1               LDD     R27, Z+1
   \   00000078   8142               LDD     R20, Z+2
   \   0000007A   0FA4               ADD     R26, R20
   \   0000007C   1FB3               ADC     R27, R19
   \   0000007E   932C               ST      X, R18
   \   00000080   8122               LDD     R18, Z+2
   \   00000082   8133               LDD     R19, Z+3
   \   00000084   5F2F               SUBI    R18, 255
   \   00000086   4F3F               SBCI    R19, 255
   \   00000088   8322               STD     Z+2, R18
   \   0000008A   8333               STD     Z+3, R19
    408              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (RXSIZE_UART & 0xff);         // rx buffer size
   \   0000008C   EF2F               LDI     R18, 255
   \   0000008E   81A0               LD      R26, Z
   \   00000090   81B1               LDD     R27, Z+1
   \   00000092   8142               LDD     R20, Z+2
   \   00000094   0FA4               ADD     R26, R20
   \   00000096   1FB3               ADC     R27, R19
   \   00000098   932C               ST      X, R18
   \   0000009A   8122               LDD     R18, Z+2
   \   0000009C   8133               LDD     R19, Z+3
   \   0000009E   5F2F               SUBI    R18, 255
   \   000000A0   4F3F               SBCI    R19, 255
   \   000000A2   8322               STD     Z+2, R18
   \   000000A4   8333               STD     Z+3, R19
    409              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (( RXSIZE_UART >> 8) & 0xff); // rx buffer size
   \   000000A6   E020               LDI     R18, 0
   \   000000A8   81A0               LD      R26, Z
   \   000000AA   81B1               LDD     R27, Z+1
   \   000000AC   8142               LDD     R20, Z+2
   \   000000AE   0FA4               ADD     R26, R20
   \   000000B0   1FB3               ADC     R27, R19
   \   000000B2   932C               ST      X, R18
   \   000000B4   8122               LDD     R18, Z+2
   \   000000B6   8133               LDD     R19, Z+3
   \   000000B8   5F2F               SUBI    R18, 255
   \   000000BA   4F3F               SBCI    R19, 255
   \   000000BC   8322               STD     Z+2, R18
   \   000000BE   8333               STD     Z+3, R19
    410              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TXSIZE_UART & 0xff);         // tx buffer size
   \   000000C0   E926               LDI     R18, 150
   \   000000C2   81A0               LD      R26, Z
   \   000000C4   81B1               LDD     R27, Z+1
   \   000000C6   8142               LDD     R20, Z+2
   \   000000C8   0FA4               ADD     R26, R20
   \   000000CA   1FB3               ADC     R27, R19
   \   000000CC   932C               ST      X, R18
   \   000000CE   8122               LDD     R18, Z+2
   \   000000D0   8133               LDD     R19, Z+3
   \   000000D2   5F2F               SUBI    R18, 255
   \   000000D4   4F3F               SBCI    R19, 255
   \   000000D6   8322               STD     Z+2, R18
   \   000000D8   8333               STD     Z+3, R19
    411              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);  // tx buffer size
   \   000000DA   E020               LDI     R18, 0
   \   000000DC   81A0               LD      R26, Z
   \   000000DE   81B1               LDD     R27, Z+1
   \   000000E0   8142               LDD     R20, Z+2
   \   000000E2   0FA4               ADD     R26, R20
   \   000000E4   1FB3               ADC     R27, R19
   \   000000E6   932C               ST      X, R18
   \   000000E8   8122               LDD     R18, Z+2
   \   000000EA   8133               LDD     R19, Z+3
   \   000000EC   5F2F               SUBI    R18, 255
   \   000000EE   4F3F               SBCI    R19, 255
   \   000000F0   8322               STD     Z+2, R18
   \   000000F2   8333               STD     Z+3, R19
    412              UART[ch].pTxBuffer[UART[ch].TxFirst++] = RestartStatus ;               // restart flag
   \   000000F4   9120....           LDS     R18, RestartStatus
   \   000000F8   81A0               LD      R26, Z
   \   000000FA   81B1               LDD     R27, Z+1
   \   000000FC   8142               LDD     R20, Z+2
   \   000000FE   0FA4               ADD     R26, R20
   \   00000100   1FB3               ADC     R27, R19
   \   00000102   932C               ST      X, R18
   \   00000104   8122               LDD     R18, Z+2
   \   00000106   8133               LDD     R19, Z+3
   \   00000108   5F2F               SUBI    R18, 255
   \   0000010A   4F3F               SBCI    R19, 255
   \   0000010C   8322               STD     Z+2, R18
   \   0000010E   8333               STD     Z+3, R19
   \   00000110   9120....           LDS     R18, packed_data
   \   00000114   81A0               LD      R26, Z
   \   00000116   81B1               LDD     R27, Z+1
   \   00000118   8142               LDD     R20, Z+2
   \   0000011A   0FA4               ADD     R26, R20
   \   0000011C   1FB3               ADC     R27, R19
   \   0000011E   932C               ST      X, R18
   \   00000120   8122               LDD     R18, Z+2
   \   00000122   8133               LDD     R19, Z+3
   \   00000124   5F2F               SUBI    R18, 255
   \   00000126   4F3F               SBCI    R19, 255
   \   00000128   8322               STD     Z+2, R18
   \   0000012A   8333               STD     Z+3, R19
    413              UART[ch].pTxBuffer[UART[ch].TxFirst++] = packed_data[0];              //Ser no1 ;
    414              UART[ch].pTxBuffer[UART[ch].TxFirst++] = packed_data[1];              //Ser no2 ;
   \   0000012C   9120....           LDS     R18, (packed_data + 1)
   \   00000130   81A0               LD      R26, Z
   \   00000132   81B1               LDD     R27, Z+1
   \   00000134   8142               LDD     R20, Z+2
   \   00000136   0FA4               ADD     R26, R20
   \   00000138   1FB3               ADC     R27, R19
   \   0000013A   932C               ST      X, R18
   \   0000013C   8122               LDD     R18, Z+2
   \   0000013E   8133               LDD     R19, Z+3
   \   00000140   5F2F               SUBI    R18, 255
   \   00000142   4F3F               SBCI    R19, 255
   \   00000144   8322               STD     Z+2, R18
   \   00000146   8333               STD     Z+3, R19
    415              UART[ch].pTxBuffer[UART[ch].TxFirst++] = packed_data[2];              //Ser no3 ;
   \   00000148   9120....           LDS     R18, (packed_data + 2)
   \   0000014C   81A0               LD      R26, Z
   \   0000014E   81B1               LDD     R27, Z+1
   \   00000150   8142               LDD     R20, Z+2
   \   00000152   0FA4               ADD     R26, R20
   \   00000154   1FB3               ADC     R27, R19
   \   00000156   932C               ST      X, R18
   \   00000158   8122               LDD     R18, Z+2
   \   0000015A   8133               LDD     R19, Z+3
   \   0000015C   5F2F               SUBI    R18, 255
   \   0000015E   4F3F               SBCI    R19, 255
   \   00000160   8322               STD     Z+2, R18
   \   00000162   8333               STD     Z+3, R19
    416              UART[ch].pTxBuffer[UART[ch].TxFirst++] = packed_data[3];              //Ser no4 ;
   \   00000164   9120....           LDS     R18, (packed_data + 3)
   \   00000168   81A0               LD      R26, Z
   \   0000016A   81B1               LDD     R27, Z+1
   \   0000016C   8142               LDD     R20, Z+2
   \   0000016E   0FA4               ADD     R26, R20
   \   00000170   1FB3               ADC     R27, R19
   \   00000172   932C               ST      X, R18
   \   00000174   8122               LDD     R18, Z+2
   \   00000176   8133               LDD     R19, Z+3
   \   00000178   5F2F               SUBI    R18, 255
   \   0000017A   4F3F               SBCI    R19, 255
   \   0000017C   8322               STD     Z+2, R18
   \   0000017E   8333               STD     Z+3, R19
    417          
    418              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \   00000180   1B20               SUB     R18, R16
   \   00000182   952A               DEC     R18
   \   00000184   2F42               MOV     R20, R18
   \   00000186   8120               LD      R18, Z
   \   00000188   8131               LDD     R19, Z+1
   \   0000018A   0F20               ADD     R18, R16
   \   0000018C   1F31               ADC     R19, R17
   \   0000018E   01F9               MOVW    R31:R30, R19:R18
   \   00000190   8340               ST      Z, R20
    419          
    420              RestartStatus = 0 ;                                                  // set reset stat to 0 = read    
   \   00000192   E000               LDI     R16, 0
   \   00000194   9300....           STS     RestartStatus, R16
    421          }
   \   00000198   2FA6               MOV     R26, R22
   \   0000019A   2FB5               MOV     R27, R21
   \   0000019C   9508               RET
    422          
    423          /*************************************************************************
    424          *
    425          * Build send package for card data 
    426          *
    427          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    428          void BuildCardData(char ch, short pointer){
   \                     BuildCardData:
   \   00000000   2F5B               MOV     R21, R27
   \   00000002   2F6A               MOV     R22, R26
    429              
    430              unsigned char ntna ;
    431          
    432              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   E001               LDI     R16, 1
   \   00000012   8F04               STD     Z+28, R16
    433              
    434              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_DATA;     
   \   00000014   E40B               LDI     R16, 75
   \   00000016   81A0               LD      R26, Z
   \   00000018   81B1               LDD     R27, Z+1
   \   0000001A   8122               LDD     R18, Z+2
   \   0000001C   8133               LDD     R19, Z+3
   \   0000001E   0FA2               ADD     R26, R18
   \   00000020   1FB3               ADC     R27, R19
   \   00000022   930C               ST      X, R16
   \   00000024   8102               LDD     R16, Z+2
   \   00000026   8113               LDD     R17, Z+3
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   8302               STD     Z+2, R16
   \   0000002E   8313               STD     Z+3, R17
    435              ntna = UART[ch].TxFirst++ ;                                    /* remember index */
   \   00000030   0198               MOVW    R19:R18, R17:R16
   \   00000032   5F2F               SUBI    R18, 255
   \   00000034   4F3F               SBCI    R19, 255
   \   00000036   8322               STD     Z+2, R18
   \   00000038   8333               STD     Z+3, R19
    436          
    437          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress ;			// Secondary address
   \   0000003A   9110....           LDS     R17, MySecAddress
   \   0000003E   81A0               LD      R26, Z
   \   00000040   81B1               LDD     R27, Z+1
   \   00000042   8122               LDD     R18, Z+2
   \   00000044   0FA2               ADD     R26, R18
   \   00000046   1FB3               ADC     R27, R19
   \   00000048   931C               ST      X, R17
   \   0000004A   8122               LDD     R18, Z+2
   \   0000004C   8133               LDD     R19, Z+3
   \   0000004E   5F2F               SUBI    R18, 255
   \   00000050   4F3F               SBCI    R19, 255
   \   00000052   8322               STD     Z+2, R18
   \   00000054   8333               STD     Z+3, R19
    438          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = Disp.alarmLED;				// status of led 
   \   00000056   9110....           LDS     R17, (Disp + 1751)
   \   0000005A   81A0               LD      R26, Z
   \   0000005C   81B1               LDD     R27, Z+1
   \   0000005E   8122               LDD     R18, Z+2
   \   00000060   0FA2               ADD     R26, R18
   \   00000062   1FB3               ADC     R27, R19
   \   00000064   931C               ST      X, R17
   \   00000066   8122               LDD     R18, Z+2
   \   00000068   8133               LDD     R19, Z+3
   \   0000006A   5F2F               SUBI    R18, 255
   \   0000006C   4F3F               SBCI    R19, 255
   \   0000006E   8322               STD     Z+2, R18
   \   00000070   8333               STD     Z+3, R19
    439          	UART[ch].pTxBuffer[UART[ch].TxFirst++]  = 0x00 ;
   \   00000072   E010               LDI     R17, 0
   \   00000074   81A0               LD      R26, Z
   \   00000076   81B1               LDD     R27, Z+1
   \   00000078   8122               LDD     R18, Z+2
   \   0000007A   0FA2               ADD     R26, R18
   \   0000007C   1FB3               ADC     R27, R19
   \   0000007E   931C               ST      X, R17
   \   00000080   8122               LDD     R18, Z+2
   \   00000082   8133               LDD     R19, Z+3
   \   00000084   5F2F               SUBI    R18, 255
   \   00000086   4F3F               SBCI    R19, 255
   \   00000088   8322               STD     Z+2, R18
   \   0000008A   8333               STD     Z+3, R19
    440          
    441              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \   0000008C   1B20               SUB     R18, R16
   \   0000008E   952A               DEC     R18
   \   00000090   2F42               MOV     R20, R18
   \   00000092   8120               LD      R18, Z
   \   00000094   8131               LDD     R19, Z+1
   \   00000096   0F20               ADD     R18, R16
   \   00000098   1F31               ADC     R19, R17
   \   0000009A   01F9               MOVW    R31:R30, R19:R18
   \   0000009C   8340               ST      Z, R20
    442          }
   \   0000009E   2FA6               MOV     R26, R22
   \   000000A0   2FB5               MOV     R27, R21
   \   000000A2   9508               RET
    443          
    444          /*************************************************************************
    445          *
    446          * Build stack status package 
    447          *
    448          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    449          void BuildStackStatus(char ch, short pointer){
   \                     BuildStackStatus:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
    450            unsigned char ntna;
    451            unsigned short stack ;
    452          
    453              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R26, LOW(UART)
   \   0000000E   ....               LDI     R27, (UART) >> 8
   \   00000010   0DA0               ADD     R26, R0
   \   00000012   1DB1               ADC     R27, R1
   \   00000014   E001               LDI     R16, 1
   \   00000016   01FD               MOVW    R31:R30, R27:R26
   \   00000018   8F04               STD     Z+28, R16
    454              
    455              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_STACKSTATUS;     
   \   0000001A   EE27               LDI     R18, 231
   \   0000001C   8100               LD      R16, Z
   \   0000001E   8111               LDD     R17, Z+1
   \   00000020   8142               LDD     R20, Z+2
   \   00000022   8153               LDD     R21, Z+3
   \   00000024   0F04               ADD     R16, R20
   \   00000026   1F15               ADC     R17, R21
   \   00000028   01F8               MOVW    R31:R30, R17:R16
   \   0000002A   8320               ST      Z, R18
   \   0000002C   01FD               MOVW    R31:R30, R27:R26
   \   0000002E   8102               LDD     R16, Z+2
   \   00000030   8113               LDD     R17, Z+3
   \   00000032   5F0F               SUBI    R16, 255
   \   00000034   4F1F               SBCI    R17, 255
   \   00000036   8302               STD     Z+2, R16
   \   00000038   8313               STD     Z+3, R17
    456              ntna = UART[ch].TxFirst++ ;                                    /* remember index */
   \   0000003A   2F80               MOV     R24, R16
   \   0000003C   5F0F               SUBI    R16, 255
   \   0000003E   4F1F               SBCI    R17, 255
   \   00000040   8302               STD     Z+2, R16
   \   00000042   8313               STD     Z+3, R17
    457          
    458              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress;           // unit adddress sec
   \   00000044   9120....           LDS     R18, MySecAddress
   \   00000048   8100               LD      R16, Z
   \   0000004A   8111               LDD     R17, Z+1
   \   0000004C   8142               LDD     R20, Z+2
   \   0000004E   8153               LDD     R21, Z+3
   \   00000050   0F04               ADD     R16, R20
   \   00000052   1F15               ADC     R17, R21
   \   00000054   01F8               MOVW    R31:R30, R17:R16
   \   00000056   8320               ST      Z, R18
   \   00000058   01FD               MOVW    R31:R30, R27:R26
   \   0000005A   8102               LDD     R16, Z+2
   \   0000005C   8113               LDD     R17, Z+3
   \   0000005E   5F0F               SUBI    R16, 255
   \   00000060   4F1F               SBCI    R17, 255
   \   00000062   8302               STD     Z+2, R16
   \   00000064   8313               STD     Z+3, R17
    459              stack = OS_GetStackSpace(&TCB_USART0);                            // USART 0
   \   00000066   ....               LDI     R16, LOW(TCB_USART0)
   \   00000068   ....               LDI     R17, (TCB_USART0) >> 8
   \   0000006A   ........           CALL    OS_GetStackSpace
    460              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
   \   0000006E   912D               LD      R18, X+
   \   00000070   913C               LD      R19, X
   \   00000072   9711               SBIW    R27:R26, 1
   \   00000074   01FD               MOVW    R31:R30, R27:R26
   \   00000076   8162               LDD     R22, Z+2
   \   00000078   8173               LDD     R23, Z+3
   \   0000007A   0F26               ADD     R18, R22
   \   0000007C   1F37               ADC     R19, R23
   \   0000007E   01F9               MOVW    R31:R30, R19:R18
   \   00000080   8300               ST      Z, R16
   \   00000082   01FD               MOVW    R31:R30, R27:R26
   \   00000084   8122               LDD     R18, Z+2
   \   00000086   8133               LDD     R19, Z+3
   \   00000088   5F2F               SUBI    R18, 255
   \   0000008A   4F3F               SBCI    R19, 255
   \   0000008C   8322               STD     Z+2, R18
   \   0000008E   8333               STD     Z+3, R19
    461              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
   \   00000090   2F21               MOV     R18, R17
   \   00000092   8100               LD      R16, Z
   \   00000094   8111               LDD     R17, Z+1
   \   00000096   8142               LDD     R20, Z+2
   \   00000098   0F04               ADD     R16, R20
   \   0000009A   1F13               ADC     R17, R19
   \   0000009C   01F8               MOVW    R31:R30, R17:R16
   \   0000009E   8320               ST      Z, R18
   \   000000A0   01FD               MOVW    R31:R30, R27:R26
   \   000000A2   8102               LDD     R16, Z+2
   \   000000A4   8113               LDD     R17, Z+3
   \   000000A6   5F0F               SUBI    R16, 255
   \   000000A8   4F1F               SBCI    R17, 255
   \   000000AA   8302               STD     Z+2, R16
   \   000000AC   8313               STD     Z+3, R17
    462              stack = OS_GetStackSpace(&TCB_Blink);                            // Blink
   \   000000AE   ....               LDI     R16, LOW(TCB_Blink)
   \   000000B0   ....               LDI     R17, (TCB_Blink) >> 8
   \   000000B2   ........           CALL    OS_GetStackSpace
    463              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
   \   000000B6   912D               LD      R18, X+
   \   000000B8   913C               LD      R19, X
   \   000000BA   9711               SBIW    R27:R26, 1
   \   000000BC   01FD               MOVW    R31:R30, R27:R26
   \   000000BE   8162               LDD     R22, Z+2
   \   000000C0   8173               LDD     R23, Z+3
   \   000000C2   0F26               ADD     R18, R22
   \   000000C4   1F37               ADC     R19, R23
   \   000000C6   01F9               MOVW    R31:R30, R19:R18
   \   000000C8   8300               ST      Z, R16
   \   000000CA   01FD               MOVW    R31:R30, R27:R26
   \   000000CC   8122               LDD     R18, Z+2
   \   000000CE   8133               LDD     R19, Z+3
   \   000000D0   5F2F               SUBI    R18, 255
   \   000000D2   4F3F               SBCI    R19, 255
   \   000000D4   8322               STD     Z+2, R18
   \   000000D6   8333               STD     Z+3, R19
    464              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
   \   000000D8   2F21               MOV     R18, R17
   \   000000DA   8100               LD      R16, Z
   \   000000DC   8111               LDD     R17, Z+1
   \   000000DE   8142               LDD     R20, Z+2
   \   000000E0   0F04               ADD     R16, R20
   \   000000E2   1F13               ADC     R17, R19
   \   000000E4   01F8               MOVW    R31:R30, R17:R16
   \   000000E6   8320               ST      Z, R18
   \   000000E8   01FD               MOVW    R31:R30, R27:R26
   \   000000EA   8102               LDD     R16, Z+2
   \   000000EC   8113               LDD     R17, Z+3
   \   000000EE   5F0F               SUBI    R16, 255
   \   000000F0   4F1F               SBCI    R17, 255
   \   000000F2   8302               STD     Z+2, R16
   \   000000F4   8313               STD     Z+3, R17
    465              stack = OS_GetStackSpace(&TCB_WATCHDOG);                            // watchdog
   \   000000F6   ....               LDI     R16, LOW(TCB_WATCHDOG)
   \   000000F8   ....               LDI     R17, (TCB_WATCHDOG) >> 8
   \   000000FA   ........           CALL    OS_GetStackSpace
    466              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
   \   000000FE   912D               LD      R18, X+
   \   00000100   913C               LD      R19, X
   \   00000102   9711               SBIW    R27:R26, 1
   \   00000104   01FD               MOVW    R31:R30, R27:R26
   \   00000106   8162               LDD     R22, Z+2
   \   00000108   8173               LDD     R23, Z+3
   \   0000010A   0F26               ADD     R18, R22
   \   0000010C   1F37               ADC     R19, R23
   \   0000010E   01F9               MOVW    R31:R30, R19:R18
   \   00000110   8300               ST      Z, R16
   \   00000112   01FD               MOVW    R31:R30, R27:R26
   \   00000114   8122               LDD     R18, Z+2
   \   00000116   8133               LDD     R19, Z+3
   \   00000118   5F2F               SUBI    R18, 255
   \   0000011A   4F3F               SBCI    R19, 255
   \   0000011C   8322               STD     Z+2, R18
   \   0000011E   8333               STD     Z+3, R19
    467              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
   \   00000120   2F21               MOV     R18, R17
   \   00000122   8100               LD      R16, Z
   \   00000124   8111               LDD     R17, Z+1
   \   00000126   8142               LDD     R20, Z+2
   \   00000128   0F04               ADD     R16, R20
   \   0000012A   1F13               ADC     R17, R19
   \   0000012C   01F8               MOVW    R31:R30, R17:R16
   \   0000012E   8320               ST      Z, R18
   \   00000130   01FD               MOVW    R31:R30, R27:R26
   \   00000132   8102               LDD     R16, Z+2
   \   00000134   8113               LDD     R17, Z+3
   \   00000136   5F0F               SUBI    R16, 255
   \   00000138   4F1F               SBCI    R17, 255
   \   0000013A   8302               STD     Z+2, R16
   \   0000013C   8313               STD     Z+3, R17
    468              stack = OS_GetStackSpace(&TCB_Info);                              // Info
   \   0000013E   ....               LDI     R16, LOW(TCB_Info)
   \   00000140   ....               LDI     R17, (TCB_Info) >> 8
   \   00000142   ........           CALL    OS_GetStackSpace
    469              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
   \   00000146   912D               LD      R18, X+
   \   00000148   913C               LD      R19, X
   \   0000014A   9711               SBIW    R27:R26, 1
   \   0000014C   01FD               MOVW    R31:R30, R27:R26
   \   0000014E   8162               LDD     R22, Z+2
   \   00000150   8173               LDD     R23, Z+3
   \   00000152   0F26               ADD     R18, R22
   \   00000154   1F37               ADC     R19, R23
   \   00000156   01F9               MOVW    R31:R30, R19:R18
   \   00000158   8300               ST      Z, R16
   \   0000015A   01FD               MOVW    R31:R30, R27:R26
   \   0000015C   8122               LDD     R18, Z+2
   \   0000015E   8133               LDD     R19, Z+3
   \   00000160   5F2F               SUBI    R18, 255
   \   00000162   4F3F               SBCI    R19, 255
   \   00000164   8322               STD     Z+2, R18
   \   00000166   8333               STD     Z+3, R19
    470              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
   \   00000168   2F21               MOV     R18, R17
   \   0000016A   8100               LD      R16, Z
   \   0000016C   8111               LDD     R17, Z+1
   \   0000016E   8142               LDD     R20, Z+2
   \   00000170   0F04               ADD     R16, R20
   \   00000172   1F13               ADC     R17, R19
   \   00000174   01F8               MOVW    R31:R30, R17:R16
   \   00000176   8320               ST      Z, R18
   \   00000178   01FD               MOVW    R31:R30, R27:R26
   \   0000017A   8102               LDD     R16, Z+2
   \   0000017C   8113               LDD     R17, Z+3
   \   0000017E   5F0F               SUBI    R16, 255
   \   00000180   4F1F               SBCI    R17, 255
   \   00000182   8302               STD     Z+2, R16
   \   00000184   8313               STD     Z+3, R17
    471              stack = OS_GetStackSpace(&TCB_DispCtl);                            // Diaplay
   \   00000186   ....               LDI     R16, LOW(TCB_DispCtl)
   \   00000188   ....               LDI     R17, (TCB_DispCtl) >> 8
   \   0000018A   ........           CALL    OS_GetStackSpace
    472              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
   \   0000018E   912D               LD      R18, X+
   \   00000190   913C               LD      R19, X
   \   00000192   9711               SBIW    R27:R26, 1
   \   00000194   01FD               MOVW    R31:R30, R27:R26
   \   00000196   8162               LDD     R22, Z+2
   \   00000198   8173               LDD     R23, Z+3
   \   0000019A   0F26               ADD     R18, R22
   \   0000019C   1F37               ADC     R19, R23
   \   0000019E   01F9               MOVW    R31:R30, R19:R18
   \   000001A0   8300               ST      Z, R16
   \   000001A2   01FD               MOVW    R31:R30, R27:R26
   \   000001A4   8122               LDD     R18, Z+2
   \   000001A6   8133               LDD     R19, Z+3
   \   000001A8   5F2F               SUBI    R18, 255
   \   000001AA   4F3F               SBCI    R19, 255
   \   000001AC   8322               STD     Z+2, R18
   \   000001AE   8333               STD     Z+3, R19
    473              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
   \   000001B0   2F21               MOV     R18, R17
   \   000001B2   8100               LD      R16, Z
   \   000001B4   8111               LDD     R17, Z+1
   \   000001B6   8142               LDD     R20, Z+2
   \   000001B8   0F04               ADD     R16, R20
   \   000001BA   1F13               ADC     R17, R19
   \   000001BC   01F8               MOVW    R31:R30, R17:R16
   \   000001BE   8320               ST      Z, R18
   \   000001C0   01FD               MOVW    R31:R30, R27:R26
   \   000001C2   8102               LDD     R16, Z+2
   \   000001C4   8113               LDD     R17, Z+3
   \   000001C6   5F0F               SUBI    R16, 255
   \   000001C8   4F1F               SBCI    R17, 255
   \   000001CA   8302               STD     Z+2, R16
   \   000001CC   8313               STD     Z+3, R17
    474          
    475             UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \   000001CE   1B08               SUB     R16, R24
   \   000001D0   950A               DEC     R16
   \   000001D2   91ED               LD      R30, X+
   \   000001D4   91FC               LD      R31, X
   \   000001D6   E090               LDI     R25, 0
   \   000001D8   0FE8               ADD     R30, R24
   \   000001DA   1FF9               ADC     R31, R25
   \   000001DC   8300               ST      Z, R16
    476          }
   \   000001DE   ....               RJMP    ?Subroutine2
    477          
    478          /*************************************************************************
    479          *
    480          * Build datablock for ??
    481          *
    482          *************************************************************************/
    483          /*void Build??(char ch){
    484          
    485              short ntna ;
    486              UART[ch].RxSendReply = true ;                               // flag for answering 
    487          
    488              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ??;     
    489              ntna = UART[ch].TxFirst++ ;                                    // remember index 
    490          
    491              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ?? ;               // restart flag
    492          
    493              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
    494          
    495          }*/
    496          
    497          
    498          //////////////////////////////////////////////////////////////////////////////
    499          // Receiving data to IO module here
    500          /////////////////////////////////////////////////////////////////////////////
    501          /*************************************************************************
    502          *
    503          * Receive data for tPC196 displays
    504          *
    505          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    506          void RecXText(char ch, short pointer){
   \                     RecXText:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   8564               LDD     R22, Z+12
   \   00000012   8575               LDD     R23, Z+13
   \   00000014   01FB               MOVW    R31:R30, R23:R22
   \   00000016   0FE2               ADD     R30, R18
   \   00000018   1FF3               ADC     R31, R19
   \   0000001A   8110               LD      R17, Z
    507          	char i, disno;
    508          	disno = UART[ch].pRxBuffer[pointer] ;					        // display no 0 high (green), 1 low yellow)
    509          	if (disno < NO_OF_XDISP) {
   \   0000001C   3015               CPI     R17, 5
   \   0000001E   F548               BRCC    ??RecXText_0
    510          		Disp.x_data[disno][0] = (UART[ch].pRxBuffer[pointer-2] - 2);	// no of char
   \   00000020   E006               LDI     R16, 6
   \   00000022   9F10               MUL     R17, R16
   \   00000024   ....               LDI     R20, LOW(Disp)
   \   00000026   ....               LDI     R21, (Disp) >> 8
   \   00000028   0D40               ADD     R20, R0
   \   0000002A   1D51               ADC     R21, R1
   \   0000002C   01DA               MOVW    R27:R26, R21:R20
   \   0000002E   52A4               SUBI    R26, 36
   \   00000030   4FBA               SBCI    R27, 250
   \   00000032   9732               SBIW    R31:R30, 2
   \   00000034   8100               LD      R16, Z
   \   00000036   5002               SUBI    R16, 2
   \   00000038   930C               ST      X, R16
    511          		if (Disp.x_data[disno][0] > NO_OF_XCH) {
   \   0000003A   910C               LD      R16, X
   \   0000003C   3006               CPI     R16, 6
   \   0000003E   F010               BRCS    ??RecXText_1
    512          			Disp.x_data[disno][0] = NO_OF_XCH ;
   \   00000040   E005               LDI     R16, 5
   \   00000042   930C               ST      X, R16
    513          		}
    514          		for (i = 1; i <= Disp.x_data[disno][0]; i++) {
   \                     ??RecXText_1:
   \   00000044   E001               LDI     R16, 1
   \   00000046   C00F               RJMP    ??RecXText_2
    515          			Disp.x_data[disno][i] = UART[ch].pRxBuffer[pointer+i] ;		// store
   \                     ??RecXText_3:
   \   00000048   2411               CLR     R1
   \   0000004A   0119               MOVW    R3:R2, R19:R18
   \   0000004C   0E20               ADD     R2, R16
   \   0000004E   1C31               ADC     R3, R1
   \   00000050   01FB               MOVW    R31:R30, R23:R22
   \   00000052   0DE2               ADD     R30, R2
   \   00000054   1DF3               ADC     R31, R3
   \   00000056   8020               LD      R2, Z
   \   00000058   01FA               MOVW    R31:R30, R21:R20
   \   0000005A   0FE0               ADD     R30, R16
   \   0000005C   1DF1               ADC     R31, R1
   \   0000005E   52E4               SUBI    R30, 36
   \   00000060   4FFA               SBCI    R31, 250
   \   00000062   8220               ST      Z, R2
    516          		}
   \   00000064   9503               INC     R16
   \                     ??RecXText_2:
   \   00000066   900C               LD      R0, X
   \   00000068   1600               CP      R0, R16
   \   0000006A   F770               BRCC    ??RecXText_3
    517          		printXDi(disno) ;        
   \   0000006C   2F01               MOV     R16, R17
   \   0000006E   ........           CALL    printXDi
    518          	}
    519          }
   \                     ??RecXText_0:
   \   00000072   91A9               LD      R26, Y+
   \   00000074   91B9               LD      R27, Y+
   \   00000076   9508               RET
    520          
    521          
    522          /*************************************************************************
    523          *
    524          * Receive data for low display
    525          *
    526          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    527          void RecLowText(char ch, short pointer){
   \                     RecLowText:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
   \   00000006   01A9               MOVW    R21:R20, R19:R18
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   8564               LDD     R22, Z+12
   \   00000016   8575               LDD     R23, Z+13
   \   00000018   01DB               MOVW    R27:R26, R23:R22
   \   0000001A   0FA2               ADD     R26, R18
   \   0000001C   1FB3               ADC     R27, R19
   \   0000001E   912C               LD      R18, X
    528          	char i, set;
    529          
    530          	set = UART[ch].pRxBuffer[pointer] ;					// value set
    531          	if (set < NO_OF_VT) {
   \   00000020   3624               CPI     R18, 100
   \   00000022   F008               BRCS    $+2+2
   \   00000024   C044               RJMP    ??RecLowText_0
    532          		Disp.window_enable[set] = true ;			// mark as legal for display
   \   00000026   2E22               MOV     R2, R18
   \   00000028   2433               CLR     R3
   \   0000002A   E001               LDI     R16, 1
   \   0000002C   2FE2               MOV     R30, R18
   \   0000002E   E0F0               LDI     R31, 0
   \   00000030   ....               SUBI    R30, LOW((-(Disp + 100) & 0xFFFF))
   \   00000032   ....               SBCI    R31, HIGH((-(Disp + 100) & 0xFFFF))
   \   00000034   8300               ST      Z, R16
    533          	//	Disp.vt_status |= (0x01 << set) ;			// mark as legal for display
    534          		Disp.lo_data[set][0] = (UART[ch].pRxBuffer[pointer-2] - 2);	// no of char
   \   00000036   0C22               LSL     R2
   \   00000038   1C33               ROL     R3
   \   0000003A   0C22               LSL     R2
   \   0000003C   1C33               ROL     R3
   \   0000003E   0C22               LSL     R2
   \   00000040   1C33               ROL     R3
   \   00000042   ....               LDI     R16, LOW(Disp)
   \   00000044   2E00               MOV     R0, R16
   \   00000046   ....               LDI     R16, (Disp) >> 8
   \   00000048   0C02               ADD     R0, R2
   \   0000004A   1D03               ADC     R16, R3
   \   0000004C   2E10               MOV     R1, R16
   \   0000004E   0180               MOVW    R17:R16, R1:R0
   \   00000050   5308               SUBI    R16, 56
   \   00000052   4F1F               SBCI    R17, 255
   \   00000054   9712               SBIW    R27:R26, 2
   \   00000056   913C               LD      R19, X
   \   00000058   5032               SUBI    R19, 2
   \   0000005A   01F8               MOVW    R31:R30, R17:R16
   \   0000005C   8330               ST      Z, R19
    535          		if (Disp.lo_data[set][0] > NO_OF_LOCH) {
   \   0000005E   8130               LD      R19, Z
   \   00000060   3038               CPI     R19, 8
   \   00000062   F010               BRCS    ??RecLowText_1
    536          			Disp.lo_data[set][0] = NO_OF_LOCH ;
   \   00000064   E037               LDI     R19, 7
   \   00000066   8330               ST      Z, R19
    537          		}
    538          		for (i = 1; i <= Disp.lo_data[set][0]; i++) {
   \                     ??RecLowText_1:
   \   00000068   E081               LDI     R24, 1
   \   0000006A   C00F               RJMP    ??RecLowText_2
    539          			Disp.lo_data[set][i] = UART[ch].pRxBuffer[pointer+i] ;		// store
   \                     ??RecLowText_3:
   \   0000006C   2433               CLR     R3
   \   0000006E   01DA               MOVW    R27:R26, R21:R20
   \   00000070   0FA8               ADD     R26, R24
   \   00000072   1DB3               ADC     R27, R3
   \   00000074   01FB               MOVW    R31:R30, R23:R22
   \   00000076   0FEA               ADD     R30, R26
   \   00000078   1FFB               ADC     R31, R27
   \   0000007A   8130               LD      R19, Z
   \   0000007C   01F0               MOVW    R31:R30, R1:R0
   \   0000007E   0FE8               ADD     R30, R24
   \   00000080   1DF3               ADC     R31, R3
   \   00000082   53E8               SUBI    R30, 56
   \   00000084   4FFF               SBCI    R31, 255
   \   00000086   8330               ST      Z, R19
    540          		}
   \   00000088   9583               INC     R24
   \                     ??RecLowText_2:
   \   0000008A   01F8               MOVW    R31:R30, R17:R16
   \   0000008C   8130               LD      R19, Z
   \   0000008E   1738               CP      R19, R24
   \   00000090   F768               BRCC    ??RecLowText_3
    541          
    542          		if (Disp.lo_grdata[20] == set) {
   \   00000092   9100....           LDS     R16, (Disp + 1750)
   \   00000096   1702               CP      R16, R18
   \   00000098   F419               BRNE    ??RecLowText_4
    543          			Disp.lo_grdata[20] = ALARM_VT ;			// do not show graph data any more
   \   0000009A   E000               LDI     R16, 0
   \   0000009C   9300....           STS     (Disp + 1750), R16
    544          		}
    545          		if (Disp.disp_vt == set) { // New data to display
   \                     ??RecLowText_4:
   \   000000A0   9100....           LDS     R16, (Disp + 1752)
   \   000000A4   1702               CP      R16, R18
   \   000000A6   F419               BRNE    ??RecLowText_0
    546          			printLoDi(set) ;        
   \   000000A8   2F02               MOV     R16, R18
   \   000000AA   ........           CALL    printLoDi
    547          		}
    548          	}
    549          }
   \                     ??RecLowText_0:
   \   000000AE   9189               LD      R24, Y+
   \   000000B0   91A9               LD      R26, Y+
   \   000000B2   91B9               LD      R27, Y+
   \   000000B4   9508               RET
    550          
    551          
    552          /*************************************************************************
    553          *
    554          * Receive data for High display
    555          *
    556          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    557          void RecHighText(char ch, short pointer){
   \                     RecHighText:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
   \   00000006   E11D               LDI     R17, 29
   \   00000008   9F01               MUL     R16, R17
   \   0000000A   ....               LDI     R30, LOW(UART)
   \   0000000C   ....               LDI     R31, (UART) >> 8
   \   0000000E   0DE0               ADD     R30, R0
   \   00000010   1DF1               ADC     R31, R1
   \   00000012   8564               LDD     R22, Z+12
   \   00000014   8575               LDD     R23, Z+13
   \   00000016   01DB               MOVW    R27:R26, R23:R22
   \   00000018   0FA2               ADD     R26, R18
   \   0000001A   1FB3               ADC     R27, R19
   \   0000001C   910C               LD      R16, X
    558          	char i, set;
    559          
    560          	set = UART[ch].pRxBuffer[pointer] ;					        // value set
    561          	if (set < NO_OF_VT) {
   \   0000001E   3604               CPI     R16, 100
   \   00000020   F588               BRCC    ??RecHighText_0
    562          		Disp.window_enable[set] = true ;			// mark as legal for display
   \   00000022   2E20               MOV     R2, R16
   \   00000024   E001               LDI     R16, 1
   \   00000026   2DE2               MOV     R30, R2
   \   00000028   E0F0               LDI     R31, 0
   \   0000002A   ....               SUBI    R30, LOW((-(Disp + 100) & 0xFFFF))
   \   0000002C   ....               SBCI    R31, HIGH((-(Disp + 100) & 0xFFFF))
   \   0000002E   8300               ST      Z, R16
    563          //		Disp.vt_status |= (0x01 << set) ;		            // mark as legal for display
    564          		Disp.hi_data[set][0] = (UART[ch].pRxBuffer[pointer-2] - 2); 	// no of char
   \   00000030   E005               LDI     R16, 5
   \   00000032   9E20               MUL     R2, R16
   \   00000034   ....               LDI     R20, LOW(Disp)
   \   00000036   ....               LDI     R21, (Disp) >> 8
   \   00000038   0D40               ADD     R20, R0
   \   0000003A   1D51               ADC     R21, R1
   \   0000003C   018A               MOVW    R17:R16, R21:R20
   \   0000003E   5108               SUBI    R16, 24
   \   00000040   4F1C               SBCI    R17, 252
   \   00000042   9712               SBIW    R27:R26, 2
   \   00000044   918C               LD      R24, X
   \   00000046   5082               SUBI    R24, 2
   \   00000048   01F8               MOVW    R31:R30, R17:R16
   \   0000004A   8380               ST      Z, R24
    565          		if (Disp.hi_data[set][0] > NO_OF_HICH) {
   \   0000004C   8180               LD      R24, Z
   \   0000004E   3085               CPI     R24, 5
   \   00000050   F010               BRCS    ??RecHighText_1
    566          			Disp.hi_data[set][0] = NO_OF_HICH ;
   \   00000052   E084               LDI     R24, 4
   \   00000054   8380               ST      Z, R24
    567          		}
    568          		for (i = 0; i < Disp.hi_data[set][0]; i++) {
   \                     ??RecHighText_1:
   \   00000056   E080               LDI     R24, 0
   \   00000058   C00F               RJMP    ??RecHighText_2
    569          			Disp.hi_data[set][i+1] = UART[ch].pRxBuffer[pointer+i+1] ; 	// store
   \                     ??RecHighText_3:
   \   0000005A   2411               CLR     R1
   \   0000005C   0119               MOVW    R3:R2, R19:R18
   \   0000005E   0E28               ADD     R2, R24
   \   00000060   1C31               ADC     R3, R1
   \   00000062   01FB               MOVW    R31:R30, R23:R22
   \   00000064   0DE2               ADD     R30, R2
   \   00000066   1DF3               ADC     R31, R3
   \   00000068   8021               LDD     R2, Z+1
   \   0000006A   01FA               MOVW    R31:R30, R21:R20
   \   0000006C   0FE8               ADD     R30, R24
   \   0000006E   1DF1               ADC     R31, R1
   \   00000070   51E7               SUBI    R30, 23
   \   00000072   4FFC               SBCI    R31, 252
   \   00000074   8220               ST      Z, R2
    570          		}
   \   00000076   9583               INC     R24
   \                     ??RecHighText_2:
   \   00000078   01F8               MOVW    R31:R30, R17:R16
   \   0000007A   8000               LD      R0, Z
   \   0000007C   1580               CP      R24, R0
   \   0000007E   F368               BRCS    ??RecHighText_3
    571          
    572          		if (Disp.disp_vt == set) {                           // New data to display
   \   00000080   9100....           LDS     R16, (Disp + 1752)
    573          		//AStmark not defined 	Write2416Data(set) ;        
    574          		}
    575          	}
    576          }
   \                     ??RecHighText_0:
   \   00000084   9189               LD      R24, Y+
   \   00000086   91A9               LD      R26, Y+
   \   00000088   91B9               LD      R27, Y+
   \   0000008A   9508               RET
    577          
    578          /*************************************************************************
    579          *
    580          * Receive data for pri. bar graph         
    581          *
    582          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    583          void RecPriBarVal(char ch, short pointer){
   \                     RecPriBarVal:
   \   00000000   01AD               MOVW    R21:R20, R27:R26
   \   00000002   E11D               LDI     R17, 29
   \   00000004   9F01               MUL     R16, R17
   \   00000006   ....               LDI     R30, LOW(UART)
   \   00000008   ....               LDI     R31, (UART) >> 8
   \   0000000A   0DE0               ADD     R30, R0
   \   0000000C   1DF1               ADC     R31, R1
   \   0000000E   85A4               LDD     R26, Z+12
   \   00000010   85B5               LDD     R27, Z+13
   \   00000012   0FA2               ADD     R26, R18
   \   00000014   1FB3               ADC     R27, R19
   \   00000016   910D               LD      R16, X+
    584          	char set;
    585          
    586          	set = UART[ch].pRxBuffer[pointer] ;					// value set
    587          	if (set < NO_OF_VT) {
   \   00000018   3604               CPI     R16, 100
   \   0000001A   F4B8               BRCC    ??RecPriBarVal_0
    588          		Disp.window_enable[set] = true ;			// mark as legal for display
   \   0000001C   2F20               MOV     R18, R16
   \   0000001E   E030               LDI     R19, 0
   \   00000020   ....               LDI     R16, LOW(Disp)
   \   00000022   ....               LDI     R17, (Disp) >> 8
   \   00000024   0F02               ADD     R16, R18
   \   00000026   1F13               ADC     R17, R19
   \   00000028   E021               LDI     R18, 1
   \   0000002A   01F8               MOVW    R31:R30, R17:R16
   \   0000002C   59EC               SUBI    R30, 156
   \   0000002E   4FFF               SBCI    R31, 255
   \   00000030   8320               ST      Z, R18
    589          //		Disp.vt_status |= (0x01 << set) ;			// mark as legal for display
    590          		Disp.ba_pdata[set] = UART[ch].pRxBuffer[pointer+1] ;
   \   00000032   5006               SUBI    R16, 6
   \   00000034   4F1A               SBCI    R17, 250
   \   00000036   912C               LD      R18, X
   \   00000038   01F8               MOVW    R31:R30, R17:R16
   \   0000003A   8320               ST      Z, R18
    591          		if (Disp.ba_pdata[set] > 100) {
   \   0000003C   8120               LD      R18, Z
   \   0000003E   3625               CPI     R18, 101
   \   00000040   F010               BRCS    ??RecPriBarVal_1
    592          			Disp.ba_pdata[set] = 100 ;
   \   00000042   E624               LDI     R18, 100
   \   00000044   8320               ST      Z, R18
    593          		}
    594          		if (Disp.disp_vt == set) { // New data to display
   \                     ??RecPriBarVal_1:
   \   00000046   9100....           LDS     R16, (Disp + 1752)
    595          			// AStmark not defined yet  printBar(set) ;
    596          		}
    597          	}
    598          }
   \                     ??RecPriBarVal_0:
   \   0000004A   01DA               MOVW    R27:R26, R21:R20
   \   0000004C   9508               RET
    599          /*************************************************************************
    600          *
    601          * Receive data for bar sec. graph         
    602          *
    603          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    604          void RecSecBarVal(char ch, short pointer){
   \                     RecSecBarVal:
   \   00000000   01AD               MOVW    R21:R20, R27:R26
    605          	char set;
    606          
    607          	Disp.bar_status |= SECBARUSED ;					  // data to second bar
   \   00000002   ....               LDI     R30, LOW((Disp + 1754))
   \   00000004   ....               LDI     R31, HIGH((Disp + 1754))
   \   00000006   8110               LD      R17, Z
   \   00000008   6110               ORI     R17, 0x10
   \   0000000A   8310               ST      Z, R17
   \   0000000C   E11D               LDI     R17, 29
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   ....               LDI     R30, LOW(UART)
   \   00000012   ....               LDI     R31, (UART) >> 8
   \   00000014   0DE0               ADD     R30, R0
   \   00000016   1DF1               ADC     R31, R1
   \   00000018   85A4               LDD     R26, Z+12
   \   0000001A   85B5               LDD     R27, Z+13
   \   0000001C   0FA2               ADD     R26, R18
   \   0000001E   1FB3               ADC     R27, R19
   \   00000020   910D               LD      R16, X+
    608          	set = UART[ch].pRxBuffer[pointer] ;					// value set
    609          	if (set < NO_OF_VT) {
   \   00000022   3604               CPI     R16, 100
   \   00000024   F4B8               BRCC    ??RecSecBarVal_0
    610          		Disp.window_enable[set] = true ;			// mark as legal for display
   \   00000026   2F20               MOV     R18, R16
   \   00000028   E030               LDI     R19, 0
   \   0000002A   ....               LDI     R16, LOW(Disp)
   \   0000002C   ....               LDI     R17, (Disp) >> 8
   \   0000002E   0F02               ADD     R16, R18
   \   00000030   1F13               ADC     R17, R19
   \   00000032   E021               LDI     R18, 1
   \   00000034   01F8               MOVW    R31:R30, R17:R16
   \   00000036   59EC               SUBI    R30, 156
   \   00000038   4FFF               SBCI    R31, 255
   \   0000003A   8320               ST      Z, R18
    611          //		Disp.vt_status |= (0x01 << set) ;			// mark as legal for display
    612          		Disp.ba_sdata[set] = UART[ch].pRxBuffer[pointer+1] ;
   \   0000003C   5A02               SUBI    R16, 162
   \   0000003E   4F19               SBCI    R17, 249
   \   00000040   912C               LD      R18, X
   \   00000042   01F8               MOVW    R31:R30, R17:R16
   \   00000044   8320               ST      Z, R18
    613          		if (Disp.ba_sdata[set] > 100) {
   \   00000046   8120               LD      R18, Z
   \   00000048   3625               CPI     R18, 101
   \   0000004A   F010               BRCS    ??RecSecBarVal_1
    614          			Disp.ba_sdata[set] = 100 ;
   \   0000004C   E624               LDI     R18, 100
   \   0000004E   8320               ST      Z, R18
    615          		}
    616          		if (Disp.disp_vt == set) {				// New data to display
   \                     ??RecSecBarVal_1:
   \   00000050   9100....           LDS     R16, (Disp + 1752)
    617          			// AStmark not defined yet printBarSec(set) ;
    618          		}
    619          	}
    620          }
   \                     ??RecSecBarVal_0:
   \   00000054   01DA               MOVW    R27:R26, R21:R20
   \   00000056   9508               RET
    621          
    622          /*************************************************************************
    623          *
    624          * Receive alarm status         
    625          *
    626          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    627          void RecAlStatus(char ch, short pointer){
   \                     RecAlStatus:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
    628          
    629          	Disp.alarmLED = UART[ch].pRxBuffer[pointer];
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   01F0               MOVW    R31:R30, R1:R0
   \   0000000A   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000000C   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000000E   85A4               LDD     R26, Z+12
   \   00000010   85B5               LDD     R27, Z+13
   \   00000012   0FA2               ADD     R26, R18
   \   00000014   1FB3               ADC     R27, R19
   \   00000016   910C               LD      R16, X
   \   00000018   9300....           STS     (Disp + 1751), R16
    630          	if (Disp.disp_vt == ALARM_VT) {	 // new value set to display
   \   0000001C   9100....           LDS     R16, (Disp + 1752)
   \   00000020   2300               TST     R16
   \   00000022   F421               BRNE    ??RecAlStatus_0
    631          		RefreshDisplay(Disp.disp_vt) ;
   \   00000024   9100....           LDS     R16, (Disp + 1752)
   \   00000028   ........           CALL    RefreshDisplay
    632          	}
    633          }
   \                     ??RecAlStatus_0:
   \   0000002C   91A9               LD      R26, Y+
   \   0000002E   91B9               LD      R27, Y+
   \   00000030   9508               RET
    634          
    635          /*************************************************************************
    636          *
    637          * Receive ack status  from host        
    638          *
    639          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    640          void RecAckStatus(char ch, short pointer){   
   \                     RecAckStatus:
    641          
    642          	tx_status &= ~ALARM_SEND ;			// Received ok by host
   \   00000000   ....               LDI     R30, LOW(tx_status)
   \   00000002   ....               LDI     R31, (tx_status) >> 8
   \   00000004   8100               LD      R16, Z
   \   00000006   7F0D               ANDI    R16, 0xFD
   \   00000008   8300               ST      Z, R16
    643          }
   \   0000000A   9508               RET
    644          
    645          
    646          /*************************************************************************
    647          *
    648          * Receive data for low graphic         
    649          *
    650          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    651          void RecLoGraph(char ch, short pointer){
   \                     RecLoGraph:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   8544               LDD     R20, Z+12
   \   00000012   8555               LDD     R21, Z+13
   \   00000014   01FA               MOVW    R31:R30, R21:R20
   \   00000016   0FE2               ADD     R30, R18
   \   00000018   1FF3               ADC     R31, R19
   \   0000001A   8100               LD      R16, Z
   \   0000001C   3604               CPI     R16, 100
   \   0000001E   F008               BRCS    $+2+2
   \   00000020   C042               RJMP    ??RecLoGraph_0
    652          	int i, j, k;
    653          
    654          	if (UART[ch].pRxBuffer[pointer] < NO_OF_VT) {
    655          		Disp.lo_grdata[20] = UART[ch].pRxBuffer[pointer++] ;	// value type
   \   00000022   9300....           STS     (Disp + 1750), R16
    656          		Disp.window_enable[Disp.lo_grdata[20]] = true ;			// mark as legal for display
   \   00000026   E001               LDI     R16, 1
   \   00000028   9160....           LDS     R22, (Disp + 1750)
   \   0000002C   E0F0               LDI     R31, 0
   \   0000002E   2FE6               MOV     R30, R22
   \   00000030   ....               SUBI    R30, LOW((-(Disp + 100) & 0xFFFF))
   \   00000032   ....               SBCI    R31, HIGH((-(Disp + 100) & 0xFFFF))
   \   00000034   8300               ST      Z, R16
    657          //		Disp.vt_status |= (0x01 << Disp.lo_grdata[20]) ;	// mark as legal for display
    658          
    659          		if (UART[ch].pRxBuffer[pointer++]) {			  // Clear display
   \   00000036   5F2F               SUBI    R18, 255
   \   00000038   4F3F               SBCI    R19, 255
   \   0000003A   0189               MOVW    R17:R16, R19:R18
   \   0000003C   5F2F               SUBI    R18, 255
   \   0000003E   4F3F               SBCI    R19, 255
   \   00000040   01FA               MOVW    R31:R30, R21:R20
   \   00000042   0FE0               ADD     R30, R16
   \   00000044   1FF1               ADC     R31, R17
   \   00000046   8100               LD      R16, Z
   \   00000048   2300               TST     R16
   \   0000004A   F039               BREQ    ??RecLoGraph_1
    660          			for (i=0; i<20; i++) {
   \   0000004C   ....               LDI     R30, LOW((Disp + 1730))
   \   0000004E   ....               LDI     R31, HIGH((Disp + 1730))
   \   00000050   E104               LDI     R16, 20
   \   00000052   E010               LDI     R17, 0
    661          				Disp.lo_grdata[i] = 0x00 ;
   \                     ??RecLoGraph_2:
   \   00000054   9311               ST      Z+, R17
    662          			}
   \   00000056   950A               DEC     R16
   \   00000058   F7E9               BRNE    ??RecLoGraph_2
    663          		}
    664          		j = (UART[ch].pRxBuffer[pointer-4]-3);				// bytes to display
   \                     ??RecLoGraph_1:
   \   0000005A   0F42               ADD     R20, R18
   \   0000005C   1F53               ADC     R21, R19
   \   0000005E   01FA               MOVW    R31:R30, R21:R20
   \   00000060   9734               SBIW    R31:R30, 4
   \   00000062   81E0               LD      R30, Z
   \   00000064   E0F0               LDI     R31, 0
   \   00000066   9733               SBIW    R31:R30, 3
    665          		if (j >20) {						  // Check for legal image pos.
   \   00000068   31E5               CPI     R30, 21
   \   0000006A   E000               LDI     R16, 0
   \   0000006C   07F0               CPC     R31, R16
   \   0000006E   F01C               BRLT    ??RecLoGraph_3
    666          			j = 20 ;
   \   00000070   E1E4               LDI     R30, 20
   \   00000072   E0F0               LDI     R31, 0
   \   00000074   C003               RJMP    ??RecLoGraph_4
    667          		}
    668          		for (i =0 ;i < j; i++) {
   \                     ??RecLoGraph_3:
   \   00000076   30E1               CPI     R30, 1
   \   00000078   07F0               CPC     R31, R16
   \   0000007A   F08C               BRLT    ??RecLoGraph_5
   \                     ??RecLoGraph_4:
   \   0000007C   018A               MOVW    R17:R16, R21:R20
   \   0000007E   01CF               MOVW    R25:R24, R31:R30
    669          			for (k=19; k>0; k--) {
   \                     ??RecLoGraph_6:
   \   00000080   ....               LDI     R30, LOW((Disp + 1748))
   \   00000082   ....               LDI     R31, HIGH((Disp + 1748))
   \   00000084   E123               LDI     R18, 19
    670          				Disp.lo_grdata[k] = Disp.lo_grdata[k-1] ;
   \                     ??RecLoGraph_7:
   \   00000086   8130               LD      R19, Z
   \   00000088   8331               STD     Z+1, R19
    671          			}
   \   0000008A   9731               SBIW    R31:R30, 1
   \   0000008C   952A               DEC     R18
   \   0000008E   F7D9               BRNE    ??RecLoGraph_7
    672          			Disp.lo_grdata[0] = UART[ch].pRxBuffer[pointer++] ; //ASTmark invert graf
   \   00000090   01F8               MOVW    R31:R30, R17:R16
   \   00000092   9121               LD      R18, Z+
   \   00000094   018F               MOVW    R17:R16, R31:R30
   \   00000096   9320....           STS     (Disp + 1730), R18
    673          		}
   \   0000009A   9701               SBIW    R25:R24, 1
   \   0000009C   F789               BRNE    ??RecLoGraph_6
    674          		printLoDi(Disp.disp_vt) ;        
   \                     ??RecLoGraph_5:
   \   0000009E   9100....           LDS     R16, (Disp + 1752)
   \   000000A2   ........           CALL    printLoDi
    675          	}
    676          }
   \                     ??RecLoGraph_0:
   \   000000A6   9189               LD      R24, Y+
   \   000000A8   9199               LD      R25, Y+
   \   000000AA   9508               RET
    677          
    678          /*************************************************************************
    679          *
    680          * Receive data for Bar Image         
    681          *
    682          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    683          void RecHiImage(char ch, short pointer){
   \                     RecHiImage:
   \   00000000   01BD               MOVW    R23:R22, R27:R26
   \   00000002   01AC               MOVW    R21:R20, R25:R24
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   8504               LDD     R16, Z+12
   \   00000012   8515               LDD     R17, Z+13
   \   00000014   0F02               ADD     R16, R18
   \   00000016   1F13               ADC     R17, R19
   \   00000018   01F8               MOVW    R31:R30, R17:R16
   \   0000001A   9732               SBIW    R31:R30, 2
   \   0000001C   8180               LD      R24, Z
   \   0000001E   E090               LDI     R25, 0
   \   00000020   9642               ADIW    R25:R24, 18
    684          	int i, j;
    685          	
    686          	j=20+UART[ch].pRxBuffer[pointer-2]-2;		// packet size
    687          	if (j >50) {					// Check for legal image pos.
   \   00000022   3383               CPI     R24, 51
   \   00000024   E020               LDI     R18, 0
   \   00000026   0792               CPC     R25, R18
   \   00000028   F01C               BRLT    ??RecHiImage_0
    688          		j = 50 ;
   \   0000002A   E382               LDI     R24, 50
   \   0000002C   E090               LDI     R25, 0
   \   0000002E   C003               RJMP    ??RecHiImage_1
    689          	}
    690          	for (i =20;i < j; i++) {
   \                     ??RecHiImage_0:
   \   00000030   3185               CPI     R24, 21
   \   00000032   0792               CPC     R25, R18
   \   00000034   F04C               BRLT    ??RecHiImage_2
   \                     ??RecHiImage_1:
   \   00000036   01F8               MOVW    R31:R30, R17:R16
   \   00000038   ....               LDI     R26, LOW((Disp + 40))
   \   0000003A   ....               LDI     R27, HIGH((Disp + 40))
   \   0000003C   9744               SBIW    R25:R24, 20
    691          		Disp.image[i] = UART[ch].pRxBuffer[pointer++] ;
   \                     ??RecHiImage_3:
   \   0000003E   9101               LD      R16, Z+
   \   00000040   930D               ST      X+, R16
   \   00000042   932D               ST      X+, R18
    692          	}
   \   00000044   9701               SBIW    R25:R24, 1
   \   00000046   F7D9               BRNE    ??RecHiImage_3
    693          }
   \                     ??RecHiImage_2:
   \   00000048   01CA               MOVW    R25:R24, R21:R20
   \   0000004A   01DB               MOVW    R27:R26, R23:R22
   \   0000004C   9508               RET
    694          
    695          /*************************************************************************
    696          *
    697          * Receive data for value set to display         
    698          *
    699          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    700          void RecValDisp(char ch, short pointer){
   \                     RecValDisp:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   85A4               LDD     R26, Z+12
   \   00000012   85B5               LDD     R27, Z+13
   \   00000014   0FA2               ADD     R26, R18
   \   00000016   1FB3               ADC     R27, R19
   \   00000018   910C               LD      R16, X
   \   0000001A   3604               CPI     R16, 100
   \   0000001C   F468               BRCC    ??RecValDisp_0
    701          
    702            if (UART[ch].pRxBuffer[pointer] < NO_OF_VT) {
    703               if (Disp.window_enable[UART[ch].pRxBuffer[pointer]] == true) {
   \   0000001E   E0F0               LDI     R31, 0
   \   00000020   2FE0               MOV     R30, R16
   \   00000022   ....               SUBI    R30, LOW((-(Disp + 100) & 0xFFFF))
   \   00000024   ....               SBCI    R31, HIGH((-(Disp + 100) & 0xFFFF))
   \   00000026   8110               LD      R17, Z
   \   00000028   3011               CPI     R17, 1
   \   0000002A   F431               BRNE    ??RecValDisp_0
    704          //    if ((Disp.vt_status >> UART[ch].pRxBuffer[pointer]) & 0x01) {
    705              	Disp.disp_vt = UART[ch].pRxBuffer[pointer] ;	
   \   0000002C   9300....           STS     (Disp + 1752), R16
    706              	RefreshDisplay( Disp.disp_vt );
   \   00000030   9100....           LDS     R16, (Disp + 1752)
   \   00000034   ........           CALL    RefreshDisplay
    707              }
    708            }
    709          }
   \                     ??RecValDisp_0:
   \   00000038   91A9               LD      R26, Y+
   \   0000003A   91B9               LD      R27, Y+
   \   0000003C   9508               RET
    710          
    711          /*************************************************************************
    712          *
    713          * Receive data to disable a window         
    714          *
    715          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    716          void RecDisableDisp(char ch, short pointer){
   \                     RecDisableDisp:
   \   00000000   01AD               MOVW    R21:R20, R27:R26
   \   00000002   E11D               LDI     R17, 29
   \   00000004   9F01               MUL     R16, R17
   \   00000006   ....               LDI     R30, LOW(UART)
   \   00000008   ....               LDI     R31, (UART) >> 8
   \   0000000A   0DE0               ADD     R30, R0
   \   0000000C   1DF1               ADC     R31, R1
   \   0000000E   85A4               LDD     R26, Z+12
   \   00000010   85B5               LDD     R27, Z+13
   \   00000012   0FA2               ADD     R26, R18
   \   00000014   1FB3               ADC     R27, R19
   \   00000016   910C               LD      R16, X
   \   00000018   3604               CPI     R16, 100
   \   0000001A   F448               BRCC    ??RecDisableDisp_0
    717          
    718            if (UART[ch].pRxBuffer[pointer] < NO_OF_VT) {
    719               if (Disp.window_enable[UART[ch].pRxBuffer[pointer]] == true) {
   \   0000001C   ....               LDI     R30, LOW((Disp + 100))
   \   0000001E   ....               LDI     R31, HIGH((Disp + 100))
   \   00000020   E010               LDI     R17, 0
   \   00000022   0FE0               ADD     R30, R16
   \   00000024   1FF1               ADC     R31, R17
   \   00000026   8100               LD      R16, Z
   \   00000028   3001               CPI     R16, 1
   \   0000002A   F409               BRNE    ??RecDisableDisp_0
    720                Disp.window_enable[UART[ch].pRxBuffer[pointer]] = false;
   \   0000002C   8310               ST      Z, R17
    721              }
    722            }
    723          }
   \                     ??RecDisableDisp_0:
   \   0000002E   01DA               MOVW    R27:R26, R21:R20
   \   00000030   9508               RET
    724          
    725          /*************************************************************************
    726          *
    727          * Receive eeprom data
    728          *
    729          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    730          void RecEepData(char ch, short pointer){
   \                     RecEepData:
   \   00000000   2F5B               MOV     R21, R27
   \   00000002   2E2A               MOV     R2, R26
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   8504               LDD     R16, Z+12
   \   00000012   8515               LDD     R17, Z+13
   \   00000014   0F02               ADD     R16, R18
   \   00000016   1F13               ADC     R17, R19
   \   00000018   01D8               MOVW    R27:R26, R17:R16
   \   0000001A   9618               ADIW    R27:R26, 8
   \   0000001C   E040               LDI     R20, 0
   \   0000001E   E12F               LDI     R18, 31
   \   00000020   ....               LDI     R19, (crc) >> 16
   \                     ??RecEepData_0:
   \   00000022   E0F0               LDI     R31, 0
   \   00000024   916D               LD      R22, X+
   \   00000026   2746               EOR     R20, R22
   \   00000028   2FE4               MOV     R30, R20
   \   0000002A   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000002C   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000002E   BF3B               OUT     0x3B, R19
   \   00000030   9146               ELPM    R20, Z
   \   00000032   952A               DEC     R18
   \   00000034   F7B1               BRNE    ??RecEepData_0
   \   00000036   912C               LD      R18, X
   \   00000038   1742               CP      R20, R18
   \   0000003A   F521               BRNE    ??RecEepData_1
   \   0000003C   01D8               MOVW    R27:R26, R17:R16
    731          
    732          //	unsigned char temp_data[PACKED_DATA_SIZE];
    733          	char   *e_data, *a_data, i ;
    734          
    735          	a_data = &UART[ch].pRxBuffer[pointer] ;
    736          	e_data = &UART[ch].pRxBuffer[pointer + 8] ;
    737          
    738          	if (CheckEepData(e_data) && CheckADData(a_data) &&
    739          		(UART[ch].pRxBuffer[pointer + PACKED_DATA_SIZE] & 0x01)) {	// check legale packet 
   \   0000003E   E020               LDI     R18, 0
   \   00000040   E060               LDI     R22, 0
   \   00000042   E047               LDI     R20, 7
   \                     ??RecEepData_2:
   \   00000044   913C               LD      R19, X
   \   00000046   2333               TST     R19
   \   00000048   F009               BREQ    ??RecEepData_3
   \   0000004A   E021               LDI     R18, 1
   \                     ??RecEepData_3:
   \   0000004C   01FD               MOVW    R31:R30, R27:R26
   \   0000004E   9631               ADIW    R31:R30, 1
   \   00000050   01DF               MOVW    R27:R26, R31:R30
   \   00000052   2763               EOR     R22, R19
   \   00000054   2FE6               MOV     R30, R22
   \   00000056   E0F0               LDI     R31, 0
   \   00000058   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000005A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000005C   9166               ELPM    R22, Z
   \   0000005E   954A               DEC     R20
   \   00000060   F789               BRNE    ??RecEepData_2
   \   00000062   913C               LD      R19, X
   \   00000064   1763               CP      R22, R19
   \   00000066   F471               BRNE    ??RecEepData_1
   \   00000068   FB20               BST     R18, 0
   \   0000006A   F466               BRTC    ??RecEepData_1
   \   0000006C   01F8               MOVW    R31:R30, R17:R16
   \   0000006E   A520               LDD     R18, Z+40
   \   00000070   FF20               SBRS    R18, 0
   \   00000072   C008               RJMP    ??RecEepData_1
    740          		for (i = 0; i < PACKED_DATA_SIZE; i++) {
   \   00000074   01D8               MOVW    R27:R26, R17:R16
   \   00000076   ....               LDI     R30, LOW(packed_data)
   \   00000078   ....               LDI     R31, (packed_data) >> 8
   \   0000007A   E208               LDI     R16, 40
    741          			packed_data[i] = UART[ch].pRxBuffer[pointer++];			// copy data
   \                     ??RecEepData_4:
   \   0000007C   911D               LD      R17, X+
   \   0000007E   9311               ST      Z+, R17
    742          		}
   \   00000080   950A               DEC     R16
   \   00000082   F7E1               BRNE    ??RecEepData_4
    743          	//	eep_type &= ~0x0f ;
    744          		//eep_type |= 0x09 ;				 // use PC data 
    745          	} else {
    746          //		eep_type &= ~0x0f ;
    747          	//	eep_type |= 0x02 ;				 // fail from pc 
    748          	}
    749          }
   \                     ??RecEepData_1:
   \   00000084   2DA2               MOV     R26, R2
   \   00000086   2FB5               MOV     R27, R21
   \   00000088   9508               RET
    750          
    751          
    752          /*************************************************************************
    753          *
    754          * Receive setup
    755          *
    756          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    757          void RecSetupData(char ch, short pointer){
   \                     RecSetupData:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008   01C9               MOVW    R25:R24, R19:R18
    758          
    759              WriteEEPROMByte(EEPROM_PRI_ADDR, UART[ch].pRxBuffer[pointer]);
   \   0000000A   E11D               LDI     R17, 29
   \   0000000C   9F01               MUL     R16, R17
   \   0000000E   ....               LDI     R26, LOW(UART)
   \   00000010   ....               LDI     R27, (UART) >> 8
   \   00000012   0DA0               ADD     R26, R0
   \   00000014   1DB1               ADC     R27, R1
   \   00000016   01FD               MOVW    R31:R30, R27:R26
   \   00000018   8504               LDD     R16, Z+12
   \   0000001A   8515               LDD     R17, Z+13
   \   0000001C   0F02               ADD     R16, R18
   \   0000001E   1F13               ADC     R17, R19
   \   00000020   01F8               MOVW    R31:R30, R17:R16
   \   00000022   8120               LD      R18, Z
   \   00000024   E001               LDI     R16, 1
   \   00000026   E010               LDI     R17, 0
   \   00000028   ........           CALL    WriteEEPROMByte
    760              WriteEEPROMByte(EEPROM_SEC_ADDR, UART[ch].pRxBuffer[pointer+1]);
   \   0000002C   01FD               MOVW    R31:R30, R27:R26
   \   0000002E   8504               LDD     R16, Z+12
   \   00000030   8515               LDD     R17, Z+13
   \   00000032   0F08               ADD     R16, R24
   \   00000034   1F19               ADC     R17, R25
   \   00000036   01F8               MOVW    R31:R30, R17:R16
   \   00000038   8121               LDD     R18, Z+1
   \   0000003A   E002               LDI     R16, 2
   \   0000003C   E010               LDI     R17, 0
   \   0000003E   ........           CALL    WriteEEPROMByte
    761          
    762              // AStmark don't saved for brightness tpc350
    763          }
   \   00000042                      REQUIRE ?Subroutine2
   \   00000042                      ;               // Fall through to label ?Subroutine2
    764          
    765          /*************************************************************************
    766          *
    767          * Receive Command to go to the bootloader program
    768          *
    769          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    770          void GetGotoBootloader(char ch, short pointer) {   
   \                     GetGotoBootloader:
   \                     ??GetGotoBootloader_0:
    771          
    772          //    void (*BootApp)(void) = (void(*)())0xF000;
    773          
    774              while ( (EECR & 1<<EEWE) != 0 ) //chech if EEPROM is ready
   \   00000000   99E1               SBIC    0x1C, 0x01
   \   00000002   CFFE               RJMP    ??GetGotoBootloader_0
    775                  ;
    776              EEARL = (0x0fff & 0xff);
   \   00000004   EF0F               LDI     R16, 255
   \   00000006   BB0E               OUT     0x1E, R16
    777              EEARH = (0x0fff >> 8);
   \   00000008   E00F               LDI     R16, 15
   \   0000000A   BB0F               OUT     0x1F, R16
    778              EEDR = 0xff;
   \   0000000C   EF0F               LDI     R16, 255
   \   0000000E   BB0D               OUT     0x1D, R16
    779              EECR |= (1<<EEMWE);
   \   00000010   9AE2               SBI     0x1C, 0x02
    780              EECR |= (1<<EEWE);
   \   00000012   9AE1               SBI     0x1C, 0x01
    781              while (EECR & (1<<EEWE))
   \                     ??GetGotoBootloader_1:
   \   00000014   99E1               SBIC    0x1C, 0x01
   \   00000016   CFFE               RJMP    ??GetGotoBootloader_1
    782                  ;
    783          
    784              WDTCR = 0x18;               //Start watchdog to genetate restart
   \   00000018   E108               LDI     R16, 24
   \   0000001A   BD01               OUT     0x21, R16
    785              WDTCR = 0x08;               //Start watchdog to genetate restart
   \   0000001C   E008               LDI     R16, 8
   \   0000001E   BD01               OUT     0x21, R16
    786          }
   \   00000020   9508               RET
   \   00000022                      REQUIRE _A_EECR
   \   00000022                      REQUIRE _A_EEAR
   \   00000022                      REQUIRE _A_EEDR
   \   00000022                      REQUIRE _A_WDTCR
    787          
    788          
    789          /*************************************************************************
    790          *
    791          *  Receive data on USARTs (ANPRO1)
    792          *
    793          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    794          void ReceivePacketUart(char ch) {
   \                     ReceivePacketUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
    795          
    796              switch (UART[ch].RxState) {                  // check status 
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R26, LOW(UART)
   \   0000000E   ....               LDI     R27, (UART) >> 8
   \   00000010   0DA0               ADD     R26, R0
   \   00000012   1DB1               ADC     R27, R1
   \   00000014   01FD               MOVW    R31:R30, R27:R26
   \   00000016   8914               LDD     R17, Z+20
   \   00000018   2311               TST     R17
   \   0000001A   F409               BRNE    $+2+2
   \   0000001C   C070               RJMP    ??CrossCallReturnLabel_2
   \   0000001E   951A               DEC     R17
   \   00000020   F031               BREQ    ??ReceivePacketUart_0
   \   00000022   951A               DEC     R17
   \   00000024   F0F1               BREQ    ??ReceivePacketUart_1
   \   00000026   5018               SUBI    R17, 8
   \   00000028   F409               BRNE    $+2+2
   \   0000002A   C069               RJMP    ??CrossCallReturnLabel_2
   \   0000002C   C067               RJMP    ??ReceivePacketUart_2
    797              case SYNC :
    798                  // all functionallity in inerrupt routine 
    799                  break ;
    800              case HEADER :
    801                   if (UART[ch].RxLast >= 3) {             // receive header 
   \                     ??ReceivePacketUart_0:
   \   0000002E   8980               LDD     R24, Z+16
   \   00000030   8991               LDD     R25, Z+17
   \   00000032   3083               CPI     R24, 3
   \   00000034   4090               SBCI    R25, 0
   \   00000036   F408               BRCC    $+2+2
   \   00000038   C062               RJMP    ??CrossCallReturnLabel_2
    802                    UART[ch].RxPacklen = (UART[ch].pRxBuffer[2] * 256)+ UART[ch].pRxBuffer[3] ; // Find length of package
   \   0000003A   8524               LDD     R18, Z+12
   \   0000003C   85F5               LDD     R31, Z+13
   \   0000003E   2FE2               MOV     R30, R18
   \   00000040   8152               LDD     R21, Z+2
   \   00000042   8123               LDD     R18, Z+3
   \   00000044   01FD               MOVW    R31:R30, R27:R26
   \   00000046   8F20               STD     Z+24, R18
   \   00000048   8F51               STD     Z+25, R21
    803                    if (UART[ch].RxPacklen >= MIN_PACK_LEN) {
   \   0000004A   3027               CPI     R18, 7
   \   0000004C   4050               SBCI    R21, 0
   \   0000004E   F408               BRCC    $+2+2
   \   00000050   C055               RJMP    ??ReceivePacketUart_2
    804                      UART[ch].RxState = RECEIVE ;       // Header ok go to data receive state
   \   00000052   E002               LDI     R16, 2
   \   00000054   8B04               STD     Z+20, R16
    805                      UART[ch].RxCount = UART[ch].RxLast + 1 ;    // Set receive counter
   \   00000056   8980               LDD     R24, Z+16
   \   00000058   8991               LDD     R25, Z+17
   \   0000005A   9601               ADIW    R25:R24, 1
   \   0000005C   8B82               STD     Z+18, R24
   \   0000005E   8B93               STD     Z+19, R25
   \   00000060   C04E               RJMP    ??CrossCallReturnLabel_2
    806                    } else {
    807                      GoToSyncUART(ch) ;                        // go to sync modus for recive
    808                    }
    809                  }
    810                  break ;
    811              case RECEIVE :
    812                  if (++UART[ch].RxCount >= UART[ch].RxPacklen) {
   \                     ??ReceivePacketUart_1:
   \   00000062   8922               LDD     R18, Z+18
   \   00000064   8933               LDD     R19, Z+19
   \   00000066   5F2F               SUBI    R18, 255
   \   00000068   4F3F               SBCI    R19, 255
   \   0000006A   8B22               STD     Z+18, R18
   \   0000006C   8B33               STD     Z+19, R19
   \   0000006E   8D40               LDD     R20, Z+24
   \   00000070   8D51               LDD     R21, Z+25
   \   00000072   1724               CP      R18, R20
   \   00000074   0735               CPC     R19, R21
   \   00000076   F408               BRCC    $+2+2
   \   00000078   C042               RJMP    ??CrossCallReturnLabel_2
    813                     if ((UART[ch].pRxBuffer[UART[ch].RxPacklen -1]) == ANPRO1_EOT) {
   \   0000007A   010A               MOVW    R1:R0, R21:R20
   \   0000007C   8524               LDD     R18, Z+12
   \   0000007E   8535               LDD     R19, Z+13
   \   00000080   0F24               ADD     R18, R20
   \   00000082   1F35               ADC     R19, R21
   \   00000084   5021               SUBI    R18, 1
   \   00000086   4030               SBCI    R19, 0
   \   00000088   01F9               MOVW    R31:R30, R19:R18
   \   0000008A   8110               LD      R17, Z
   \   0000008C   3013               CPI     R17, 3
   \   0000008E   F5B1               BRNE    ??ReceivePacketUart_2
    814                          if (CalcDSRxChecksum(ch, UART[ch].RxPacklen-2)) {
   \   00000090   EF1E               LDI     R17, 254
   \   00000092   0E01               ADD     R0, R17
   \   00000094   EF1F               LDI     R17, 255
   \   00000096   1E11               ADC     R1, R17
   \   00000098   2422               CLR     R2
   \   0000009A   01FD               MOVW    R31:R30, R27:R26
   \   0000009C   8544               LDD     R20, Z+12
   \   0000009E   8555               LDD     R21, Z+13
   \   000000A0   2D10               MOV     R17, R0
   \   000000A2   2911               OR      R17, R1
   \   000000A4   F079               BREQ    ??ReceivePacketUart_3
   \   000000A6   01BA               MOVW    R23:R22, R21:R20
   \   000000A8   01C0               MOVW    R25:R24, R1:R0
   \   000000AA   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_4:
   \   000000AC   01FB               MOVW    R31:R30, R23:R22
   \   000000AE   9121               LD      R18, Z+
   \   000000B0   01BF               MOVW    R23:R22, R31:R30
   \   000000B2   2622               EOR     R2, R18
   \   000000B4   2DE2               MOV     R30, R2
   \   000000B6   E0F0               LDI     R31, 0
   \   000000B8   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000BA   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000BC   BF3B               OUT     0x3B, R19
   \   000000BE   9026               ELPM    R2, Z
   \   000000C0   9701               SBIW    R25:R24, 1
   \   000000C2   F7A1               BRNE    ??ReceivePacketUart_4
   \                     ??ReceivePacketUart_3:
   \   000000C4   01FA               MOVW    R31:R30, R21:R20
   \   000000C6   0DE0               ADD     R30, R0
   \   000000C8   1DF1               ADC     R31, R1
   \   000000CA   8110               LD      R17, Z
   \   000000CC   1621               CP      R2, R17
   \   000000CE   F4B1               BRNE    ??ReceivePacketUart_2
    815                              if ((UART[ch].pRxBuffer[0] == MyPriAddress)||      // message to tpc140 or
    816                                  (UART[ch].pRxBuffer[0] == 0xff)) {            // broadcast
   \   000000D0   01FA               MOVW    R31:R30, R21:R20
   \   000000D2   8110               LD      R17, Z
   \   000000D4   9120....           LDS     R18, MyPriAddress
   \   000000D8   1712               CP      R17, R18
   \   000000DA   F011               BREQ    ??ReceivePacketUart_5
   \   000000DC   3F1F               CPI     R17, 255
   \   000000DE   F471               BRNE    ??ReceivePacketUart_2
    817                                  HostAddress = UART[ch].pRxBuffer[1];            // address to sender (host)
   \                     ??ReceivePacketUart_5:
   \   000000E0   8111               LDD     R17, Z+1
   \   000000E2   9310....           STS     HostAddress, R17
    818                                  UART[ch].RxState = HANDLE ;                     // Package OK
   \   000000E6   E01A               LDI     R17, 10
   \   000000E8   01FD               MOVW    R31:R30, R27:R26
   \   000000EA   8B14               STD     Z+20, R17
    819                                  if (ch == 0) {
   \   000000EC   2300               TST     R16
   \   000000EE   F439               BRNE    ??CrossCallReturnLabel_2
    820                                      OS_SignalEvent(1, &TCB_USART0);
   \   000000F0   ....               LDI     R18, LOW(TCB_USART0)
   \   000000F2   ....               LDI     R19, (TCB_USART0) >> 8
   \   000000F4   E001               LDI     R16, 1
   \   000000F6   ........           CALL    OS_SignalEvent
   \   000000FA   C001               RJMP    ??CrossCallReturnLabel_2
    821                                  } else if (ch == 1) {
    822                                       //Not used
    823                                  }
    824                              } else {
    825                                  GoToSyncUART(ch) ;                             // go to sync modus for recive
    826                              }
    827                          } else {
    828                              GoToSyncUART(ch) ;                                // go to sync modus for recive
    829                          }
    830                      } else {
    831                          GoToSyncUART(ch) ;                                    // go to sync modus for recive
    832                      }
    833                  }
    834                  break ;
    835              case HANDLE :
    836                  break;
    837              default :
    838                  GoToSyncUART(ch) ;                                            // go to sync modus for recive
   \                     ??ReceivePacketUart_2:
   \   000000FC   ....               RCALL   ?Subroutine3
    839                  break ;
    840              }                                                           // end switch 
    841              if (++UART[ch].RxLast >= RXSIZE_UART) {                     // check pointer 
   \                     ??CrossCallReturnLabel_2:
   \   000000FE   01FD               MOVW    R31:R30, R27:R26
   \   00000100   8900               LDD     R16, Z+16
   \   00000102   8911               LDD     R17, Z+17
   \   00000104   5F0F               SUBI    R16, 255
   \   00000106   4F1F               SBCI    R17, 255
   \   00000108   8B00               STD     Z+16, R16
   \   0000010A   8B11               STD     Z+17, R17
   \   0000010C   3F0F               CPI     R16, 255
   \   0000010E   E020               LDI     R18, 0
   \   00000110   4010               SBCI    R17, 0
   \   00000112   F010               BRCS    ??ReceivePacketUart_6
    842                  UART[ch].RxLast = 0;                                     // reset pointer
   \   00000114   8B20               STD     Z+16, R18
   \   00000116   8B21               STD     Z+17, R18
    843              }
    844          }
   \                     ??ReceivePacketUart_6:
   \   00000118   ....               RJMP    ?Subroutine2
    845          
    846          
    847          /*************************************************************************
    848          *
    849          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    850          *
    851          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    852          char CalcDSTxChecksum(char ch, unsigned short len) {
   \                     CalcDSTxChecksum:
   \   00000000   01BD               MOVW    R23:R22, R27:R26
   \   00000002   01AC               MOVW    R21:R20, R25:R24
   \   00000004   2F10               MOV     R17, R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
    853          
    854              unsigned short  cnt ;
    855              unsigned char   csum ;
    856          
    857              csum = 0 ;
   \   00000008   E000               LDI     R16, 0
    858              for (cnt = 2 ; cnt < len ; cnt++) {
   \   0000000A   3023               CPI     R18, 3
   \   0000000C   4030               SBCI    R19, 0
   \   0000000E   F0A0               BRCS    ??CalcDSTxChecksum_0
   \   00000010   E12D               LDI     R18, 29
   \   00000012   9F12               MUL     R17, R18
   \   00000014   01F0               MOVW    R31:R30, R1:R0
   \   00000016   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000018   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000001A   81A0               LD      R26, Z
   \   0000001C   81B1               LDD     R27, Z+1
   \   0000001E   9612               ADIW    R27:R26, 2
   \   00000020   9702               SBIW    R25:R24, 2
   \   00000022   ....               LDI     R19, (crc) >> 16
    859                  csum = crc[csum ^ UART[ch].pTxBuffer[cnt]] ;
   \                     ??CalcDSTxChecksum_1:
   \   00000024   E0F0               LDI     R31, 0
   \   00000026   912D               LD      R18, X+
   \   00000028   2702               EOR     R16, R18
   \   0000002A   2FE0               MOV     R30, R16
   \   0000002C   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000002E   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000030   BF3B               OUT     0x3B, R19
   \   00000032   9106               ELPM    R16, Z
    860              }
   \   00000034   9701               SBIW    R25:R24, 1
   \   00000036   F7B1               BRNE    ??CalcDSTxChecksum_1
    861              return csum ;
   \                     ??CalcDSTxChecksum_0:
   \   00000038   01CA               MOVW    R25:R24, R21:R20
   \   0000003A   01DB               MOVW    R27:R26, R23:R22
   \   0000003C   9508               RET
    862          }
    863          
    864          /*************************************************************************
    865          *
    866          * Calculate rx packet checksum (header and package) using Dallas Semiconductor one-wire CRC
    867          *
    868          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    869          short CalcDSRxChecksum(char ch, unsigned short len) {
   \                     CalcDSRxChecksum:
   \   00000000   011C               MOVW    R3:R2, R25:R24
   \   00000002   01A9               MOVW    R21:R20, R19:R18
    870          
    871              unsigned short  cnt ;
    872              unsigned char   csum ;
    873          
    874              csum = 0 ;
   \   00000004   E020               LDI     R18, 0
   \   00000006   E11D               LDI     R17, 29
   \   00000008   9F01               MUL     R16, R17
   \   0000000A   ....               LDI     R30, LOW(UART)
   \   0000000C   ....               LDI     R31, (UART) >> 8
   \   0000000E   0DE0               ADD     R30, R0
   \   00000010   1DF1               ADC     R31, R1
   \   00000012   8564               LDD     R22, Z+12
   \   00000014   8575               LDD     R23, Z+13
   \   00000016   2F04               MOV     R16, R20
   \   00000018   2B03               OR      R16, R19
   \   0000001A   F089               BREQ    ??CalcDSRxChecksum_0
   \   0000001C   018B               MOVW    R17:R16, R23:R22
   \   0000001E   2F84               MOV     R24, R20
   \   00000020   2F93               MOV     R25, R19
   \   00000022   ....               LDI     R19, (crc) >> 16
    875              for (cnt=0 ; cnt < len ; cnt++) {
    876                  csum = crc[csum ^ UART[ch].pRxBuffer[cnt]] ;
   \                     ??CalcDSRxChecksum_1:
   \   00000024   2E02               MOV     R0, R18
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   9121               LD      R18, Z+
   \   0000002A   018F               MOVW    R17:R16, R31:R30
   \   0000002C   2602               EOR     R0, R18
   \   0000002E   2DE0               MOV     R30, R0
   \   00000030   E0F0               LDI     R31, 0
   \   00000032   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000034   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000036   BF3B               OUT     0x3B, R19
   \   00000038   9126               ELPM    R18, Z
    877              }
   \   0000003A   9701               SBIW    R25:R24, 1
   \   0000003C   F799               BRNE    ??CalcDSRxChecksum_1
    878              if (csum == UART[ch].pRxBuffer[len]) {
   \                     ??CalcDSRxChecksum_0:
   \   0000003E   0F64               ADD     R22, R20
   \   00000040   1F75               ADC     R23, R21
   \   00000042   01FB               MOVW    R31:R30, R23:R22
   \   00000044   8100               LD      R16, Z
   \   00000046   1720               CP      R18, R16
   \   00000048   F411               BRNE    ??CalcDSRxChecksum_2
    879                  return true ;
   \   0000004A   E001               LDI     R16, 1
   \   0000004C   C001               RJMP    ??CalcDSRxChecksum_3
    880              } else {
    881                  return false ; 
   \                     ??CalcDSRxChecksum_2:
   \   0000004E   E000               LDI     R16, 0
   \                     ??CalcDSRxChecksum_3:
   \   00000050   E010               LDI     R17, 0
   \   00000052   01C1               MOVW    R25:R24, R3:R2
   \   00000054   9508               RET
    882              }
    883          }
    884          /*************************************************************************
    885          *
    886          * Check AppData checksum
    887          *
    888          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    889          char CheckADData(char *data)
   \                     CheckADData:
    890          {
    891          
    892          	int             cnt ;
    893          	unsigned char   csum, ok ;
    894          
    895          	ok = false ;
   \   00000000   E040               LDI     R20, 0
    896          	csum = 0 ;
   \   00000002   E060               LDI     R22, 0
    897          	for (cnt = 0 ; cnt < 7 ; cnt++) {
   \   00000004   E027               LDI     R18, 7
    898          		if (*data != 0x00) {
   \                     ??CheckADData_0:
   \   00000006   01F8               MOVW    R31:R30, R17:R16
   \   00000008   9131               LD      R19, Z+
   \   0000000A   2333               TST     R19
   \   0000000C   F009               BREQ    ??CheckADData_1
    899          			ok = true ;
   \   0000000E   E041               LDI     R20, 1
    900          		}
    901          		csum = crc[csum ^ *data++] ;
   \                     ??CheckADData_1:
   \   00000010   018F               MOVW    R17:R16, R31:R30
   \   00000012   2763               EOR     R22, R19
   \   00000014   2FE6               MOV     R30, R22
   \   00000016   E0F0               LDI     R31, 0
   \   00000018   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000001A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000001C   ....               LDI     R19, (crc) >> 16
   \   0000001E   BF3B               OUT     0x3B, R19
   \   00000020   9166               ELPM    R22, Z
    902          	}
   \   00000022   952A               DEC     R18
   \   00000024   F781               BRNE    ??CheckADData_0
    903          	if ((csum == *data) && (ok == true)) {
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   8100               LD      R16, Z
   \   0000002A   1760               CP      R22, R16
   \   0000002C   F421               BRNE    ??CheckADData_2
   \   0000002E   FB40               BST     R20, 0
   \   00000030   F416               BRTC    ??CheckADData_2
    904          		return true ;
   \   00000032   E001               LDI     R16, 1
   \   00000034   9508               RET
    905          	} else {
    906          		return false ;
   \                     ??CheckADData_2:
   \   00000036   E000               LDI     R16, 0
   \   00000038   9508               RET
    907          
    908          	}
    909          }
    910          
    911          
    912          /*************************************************************************
    913          *
    914          * Check Eepdata checksum
    915          *
    916          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    917          char CheckEepData(char *data)
   \                     CheckEepData:
    918          {
    919          
    920          	int             cnt ;
    921          	unsigned char   csum ;
    922          
    923          	csum = 0 ;
   \   00000000   E040               LDI     R20, 0
    924          	for (cnt = 8 ; cnt < (PACKED_DATA_SIZE -1) ; cnt++) {
   \   00000002   E12F               LDI     R18, 31
   \   00000004   ....               LDI     R19, (crc) >> 16
    925          		csum = crc[csum ^ *data++] ;
   \                     ??CheckEepData_0:
   \   00000006   01F8               MOVW    R31:R30, R17:R16
   \   00000008   9161               LD      R22, Z+
   \   0000000A   018F               MOVW    R17:R16, R31:R30
   \   0000000C   2746               EOR     R20, R22
   \   0000000E   2FE4               MOV     R30, R20
   \   00000010   E0F0               LDI     R31, 0
   \   00000012   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000014   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000016   BF3B               OUT     0x3B, R19
   \   00000018   9146               ELPM    R20, Z
    926          	}
   \   0000001A   952A               DEC     R18
   \   0000001C   F7A1               BRNE    ??CheckEepData_0
    927          	if (csum == *data) {
   \   0000001E   01F8               MOVW    R31:R30, R17:R16
   \   00000020   8100               LD      R16, Z
   \   00000022   1740               CP      R20, R16
   \   00000024   F411               BRNE    ??CheckEepData_1
    928          		return true ;
   \   00000026   E001               LDI     R16, 1
   \   00000028   9508               RET
    929          	} else {
    930          		return false ;
   \                     ??CheckEepData_1:
   \   0000002A   E000               LDI     R16, 0
   \   0000002C   9508               RET
    931          	}
    932          }
    933          
    934          
    935          /*************************************************************************
    936          *
    937          * Goes to sync mode
    938          *
    939          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    940          __monitor void GoToSyncUART(char ch) {
   \                     GoToSyncUART:
   \   00000000   B72F               IN      R18, 0x3F
   \   00000002   94F8               CLI
    941          
    942              if (ch < 2) {
   \   00000004   3002               CPI     R16, 2
   \   00000006   F458               BRCC    ??GoToSyncUART_0
    943                  UART[ch].SyncCnt = 0 ;                        // ready for sync
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E000               LDI     R16, 0
   \   00000016   8B05               STD     Z+21, R16
    944                  UART[ch].RxState = SYNC ;
   \   00000018   8B04               STD     Z+20, R16
    945                  UART[ch].RxFirst = 0 ;
   \   0000001A   8706               STD     Z+14, R16
   \   0000001C   8707               STD     Z+15, R16
    946              }
    947          }
   \                     ??GoToSyncUART_0:
   \   0000001E   BF2F               OUT     0x3F, R18
   \   00000020   9508               RET

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "No Rx">>`:
   \   00000000   6F4E52200078       DC8 "No Rx"

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant " OK">>`:
   \   00000000   4F20004B           DC8 " OK"

   \                                 In  segment SWITCH, align 2, keep-with-next
   \                     `?<Jumptable for CheckActionUart>_0`:
   \   00000000   ....               DW      (??CheckActionUart_22) /2
   \   00000002   ....               DW      (??CheckActionUart_2) /2
   \   00000004   ....               DW      (??CheckActionUart_2) /2
   \   00000006   ....               DW      (??CheckActionUart_2) /2
   \   00000008   ....               DW      (??CheckActionUart_2) /2
   \   0000000A   ....               DW      (??CheckActionUart_2) /2
   \   0000000C   ....               DW      (??CheckActionUart_2) /2
   \   0000000E   ....               DW      (??CheckActionUart_2) /2
   \   00000010   ....               DW      (??CheckActionUart_2) /2
   \   00000012   ....               DW      (??CheckActionUart_2) /2
   \   00000014   ....               DW      (??CheckActionUart_2) /2
   \   00000016   ....               DW      (??CheckActionUart_2) /2
   \   00000018   ....               DW      (??CheckActionUart_2) /2
   \   0000001A   ....               DW      (??CheckActionUart_2) /2
   \   0000001C   ....               DW      (??CheckActionUart_2) /2
   \   0000001E   ....               DW      (??CheckActionUart_2) /2
   \   00000020   ....               DW      (??CheckActionUart_2) /2
   \   00000022   ....               DW      (??CheckActionUart_2) /2
   \   00000024   ....               DW      (??CheckActionUart_23) /2
   \   00000026   ....               DW      (??CheckActionUart_2) /2
   \   00000028   ....               DW      (??CheckActionUart_2) /2
   \   0000002A   ....               DW      (??CheckActionUart_2) /2
   \   0000002C   ....               DW      (??CheckActionUart_2) /2
   \   0000002E   ....               DW      (??CheckActionUart_2) /2
   \   00000030   ....               DW      (??CheckActionUart_2) /2
   \   00000032   ....               DW      (??CheckActionUart_2) /2
   \   00000034   ....               DW      (??CheckActionUart_2) /2
   \   00000036   ....               DW      (??CheckActionUart_2) /2
   \   00000038   ....               DW      (??CheckActionUart_2) /2
   \   0000003A   ....               DW      (??CheckActionUart_2) /2
   \   0000003C   ....               DW      (??CheckActionUart_2) /2
   \   0000003E   ....               DW      (??CheckActionUart_2) /2
   \   00000040   ....               DW      (??CheckActionUart_2) /2
   \   00000042   ....               DW      (??CheckActionUart_2) /2
   \   00000044   ....               DW      (??CheckActionUart_2) /2
   \   00000046   ....               DW      (??CheckActionUart_2) /2
   \   00000048   ....               DW      (??CheckActionUart_2) /2
   \   0000004A   ....               DW      (??CheckActionUart_2) /2
   \   0000004C   ....               DW      (??CheckActionUart_2) /2
   \   0000004E   ....               DW      (??CheckActionUart_2) /2
   \   00000050   ....               DW      (??CheckActionUart_2) /2
   \   00000052   ....               DW      (??CheckActionUart_2) /2
   \   00000054   ....               DW      (??CheckActionUart_2) /2
   \   00000056   ....               DW      (??CheckActionUart_2) /2
   \   00000058   ....               DW      (??CheckActionUart_2) /2
   \   0000005A   ....               DW      (??CheckActionUart_2) /2
   \   0000005C   ....               DW      (??CheckActionUart_2) /2
   \   0000005E   ....               DW      (??CheckActionUart_2) /2
   \   00000060   ....               DW      (??CheckActionUart_2) /2
   \   00000062   ....               DW      (??CheckActionUart_2) /2
   \   00000064   ....               DW      (??CheckActionUart_2) /2
   \   00000066   ....               DW      (??CheckActionUart_2) /2
   \   00000068   ....               DW      (??CheckActionUart_2) /2
   \   0000006A   ....               DW      (??CheckActionUart_2) /2
   \   0000006C   ....               DW      (??CheckActionUart_2) /2
   \   0000006E   ....               DW      (??CheckActionUart_2) /2
   \   00000070   ....               DW      (??CheckActionUart_2) /2
   \   00000072   ....               DW      (??CheckActionUart_2) /2
   \   00000074   ....               DW      (??CheckActionUart_2) /2
   \   00000076   ....               DW      (??CheckActionUart_2) /2
   \   00000078   ....               DW      (??CheckActionUart_2) /2
   \   0000007A   ....               DW      (??CheckActionUart_2) /2
   \   0000007C   ....               DW      (??CheckActionUart_2) /2
   \   0000007E   ....               DW      (??CheckActionUart_2) /2
   \   00000080   ....               DW      (??CheckActionUart_2) /2
   \   00000082   ....               DW      (??CheckActionUart_2) /2
   \   00000084   ....               DW      (??CheckActionUart_2) /2
   \   00000086   ....               DW      (??CheckActionUart_2) /2
   \   00000088   ....               DW      (??CheckActionUart_2) /2
   \   0000008A   ....               DW      (??CheckActionUart_2) /2
   \   0000008C   ....               DW      (??CheckActionUart_2) /2
   \   0000008E   ....               DW      (??CheckActionUart_2) /2
   \   00000090   ....               DW      (??CheckActionUart_2) /2
   \   00000092   ....               DW      (??CheckActionUart_2) /2
   \   00000094   ....               DW      (??CheckActionUart_2) /2
   \   00000096   ....               DW      (??CheckActionUart_2) /2
   \   00000098   ....               DW      (??CheckActionUart_5) /2
   \   0000009A   ....               DW      (??CheckActionUart_6) /2
   \   0000009C   ....               DW      (??CheckActionUart_7) /2
   \   0000009E   ....               DW      (??CheckActionUart_8) /2
   \   000000A0   ....               DW      (??CheckActionUart_9) /2
   \   000000A2   ....               DW      (??CheckActionUart_10) /2
   \   000000A4   ....               DW      (??CheckActionUart_11) /2
   \   000000A6   ....               DW      (??CheckActionUart_12) /2
   \   000000A8   ....               DW      (??CheckActionUart_15) /2
   \   000000AA   ....               DW      (??CheckActionUart_21) /2
   \   000000AC   ....               DW      (??CheckActionUart_16) /2
   \   000000AE   ....               DW      (??CheckActionUart_3) /2
   \   000000B0   ....               DW      (??CheckActionUart_18) /2
   \   000000B2   ....               DW      (??CheckActionUart_19) /2
   \   000000B4   ....               DW      (??CheckActionUart_17) /2
   \   000000B6   ....               DW      (??CheckActionUart_2) /2
   \   000000B8   ....               DW      (??CheckActionUart_13) /2
   \   000000BA   ....               DW      (??CheckActionUart_14) /2
   \   000000BC   ....               DW      (??CheckActionUart_20) /2

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant "No Rx">`:
   \   00000000                      DS8 6
   \   00000006                      REQUIRE `?<Initializer for <Constant "No Rx">>`

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant " OK">`:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for <Constant " OK">>`

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      9      2   BuildAPWriteData
        9      2   -> ReadEEPROMByte
        9      2   -> WriteEEPROMByte
      0      2   BuildCardData
      0      2   BuildDallasData
      9      2   BuildEEPWriteData
        9      2   -> ReadEEPROMByte
        9      2   -> WriteEEPROMByte
      0      2   BuildEepData
      4      2   BuildStackStatus
        4      2   -> OS_GetStackSpace
      0      2   BuildStatusData
      0      2   CalcDSRxChecksum
      0      2   CalcDSTxChecksum
      0      2   CheckADData
      6      2   CheckActionUart
        6      2   -> BuildAPWriteData
        6      2   -> BuildCardData
        6      2   -> BuildDallasData
        6      2   -> BuildEEPWriteData
        6      2   -> BuildEepData
        6      2   -> BuildStackStatus
        6      2   -> BuildStatusData
        6      2   -> PrintComError
        6      2   -> RecDisableDisp
        6      2   -> RecEepData
        6      2   -> RecHiImage
        6      2   -> RecHighText
        6      2   -> RecLoGraph
        6      2   -> RecLowText
        6      2   -> RecPriBarVal
        6      2   -> RecSecBarVal
        6      2   -> RecValDisp
        6      2   -> RecXText
        6      2   -> RefreshDisplay
        6      2   -> WriteEEPROMByte
      0      2   CheckEepData
      0      2   GetGotoBootloader
      0      2   GoToSyncUART
      0      2   RecAckStatus
      2      2   RecAlStatus
        2      2   -> RefreshDisplay
      0      2   RecDisableDisp
      0      2   RecEepData
      0      2   RecHiImage
      3      2   RecHighText
      2      2   RecLoGraph
        2      2   -> printLoDi
      3      2   RecLowText
        3      2   -> printLoDi
      0      2   RecPriBarVal
      0      2   RecSecBarVal
      4      2   RecSetupData
        4      2   -> WriteEEPROMByte
      2      2   RecValDisp
        2      2   -> RefreshDisplay
      2      2   RecXText
        2      2   -> printXDi
      4      2   ReceivePacketUart
        4      2   -> GoToSyncUART
        4      2   -> OS_SignalEvent
      0      2   TimoutUSART0
        0      2   -> OS_StopTimer
      0      2   Uart_BuildHeader
      4      2   Uart_BuildTail
        4      2   -> OS_Delay
        4      2   -> OS_RetriggerTimer
        4      2   -> Uart_BuildHeader
      5      2   Usart0Handler
        5      2   -> CheckActionUart
        5      2   -> GoToSyncUART
        5      2   -> OS_Delay
        5      2   -> OS_Unuse
        5      2   -> OS_Use
        5      2   -> OS_WaitEventTimed
        5      2   -> PrintComError
        5      2   -> Uart_BuildTail
      6      2   UsartCheckPackage
        6      2   -> CheckActionUart
        6      2   -> GoToSyncUART
        6      2   -> OS_Delay
        6      2   -> Uart_BuildTail


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant " OK">
       6  ?<Constant "No Rx">
       4  ?<Initializer for <Constant " OK">>
       6  ?<Initializer for <Constant "No Rx">>
     190  ?<Jumptable for CheckActionUart>_0
     228  ?Subroutine0
      14  ?Subroutine1
      10  ?Subroutine2
       4  ?Subroutine3
      40  BuildAPWriteData
     164  BuildCardData
     140  BuildDallasData
      42  BuildEEPWriteData
     148  BuildEepData
     480  BuildStackStatus
     414  BuildStatusData
      86  CalcDSRxChecksum
      62  CalcDSTxChecksum
      58  CheckADData
     712  CheckActionUart
      46  CheckEepData
      34  GetGotoBootloader
      34  GoToSyncUART
      12  RecAckStatus
      50  RecAlStatus
      50  RecDisableDisp
     138  RecEepData
      78  RecHiImage
     140  RecHighText
     172  RecLoGraph
     182  RecLowText
      78  RecPriBarVal
      88  RecSecBarVal
      66  RecSetupData
      62  RecValDisp
     120  RecXText
     282  ReceivePacketUart
      12  TimoutUSART0
      96  Uart_BuildHeader
     296  Uart_BuildTail
     190  Usart0Handler
     120  UsartCheckPackage
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_UCSR0B
       1  _A_WDTCR
       7  -- Other

 
     7 bytes in segment ABSOLUTE
 4 948 bytes in segment CODE
     7 bytes in segment INITTAB
    10 bytes in segment NEAR_I
    10 bytes in segment NEAR_ID
   190 bytes in segment SWITCH
 
 5 148 bytes of CODE memory (+ 7 bytes shared)
    10 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
