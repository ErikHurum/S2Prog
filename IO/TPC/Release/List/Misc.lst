###############################################################################
#
# IAR C/C++ Compiler V6.70.1.929 for Atmel AVR            23/Jan/2017  13:07:10
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Atmel AVR 6.80
#
#    Source file  =  D:\S2Prog\IO\TPC\Src\Misc.c
#    Command line =  
#        D:\S2Prog\IO\TPC\Src\Misc.c --cpu=m128 -ms -o
#        D:\S2Prog\IO\TPC\Release\Obj -D OS_LIBMODE_S -D OS_UART=-1 -lCN
#        D:\S2Prog\IO\TPC\Release\List -y --initializers_in_flash --no_tbaa
#        -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\TPC\INC\ -I
#        D:\S2Prog\IO\TPC\..\..\SHARED\INC\ --eeprom_size 4096 --clib -Ohs
#    List file    =  D:\S2Prog\IO\TPC\Release\List\Misc.lst
#    Object file  =  D:\S2Prog\IO\TPC\Release\Obj\Misc.r90
#
###############################################################################

D:\S2Prog\IO\TPC\Src\Misc.c
      1          /****************************************************************************************
      2          /  Misc. routines
      3          /
      4          ***************************************************************************************/
      5          #include "iom128.h"

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_WDTCR
   \                     _A_WDTCR:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          #include "string.h"
     12          
     13          /*************************************************************************
     14          *   (This is a task)
     15          *  Watchdog handler
     16          *
     17          *   NB!
     18          *  This task runs on the lovest priority and all othr tasks will run.
     19          *  In case of faul a task on higher priority will use all resources and
     20          *  the watchdog will kick the CPU.
     21          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     22          void WatchDogHandler(void) {
   \                     WatchDogHandler:
     23          
     24              OS_Delay(100);                         // wait 2 seconds for other tasks to start and set TaskStatus
   \   00000000   E604               LDI     R16, 100
   \   00000002   E010               LDI     R17, 0
   \   00000004   ........           CALL    OS_Delay
     25              asm("WDR");                             // kick the dog!!
   \   00000008   95A8               WDR
     26              WDTCR = 0x1f;
   \   0000000A   E10F               LDI     R16, 31
   \   0000000C   BD01               OUT     0x21, R16
     27              WDTCR = 0x0f;
   \   0000000E   E00F               LDI     R16, 15
   \   00000010   BD01               OUT     0x21, R16
     28              asm("WDR");                             // kick the dog!!
   \   00000012   95A8               WDR
     29              while (1) {
     30                  OS_Delay(100);
   \                     ??WatchDogHandler_0:
   \   00000014   E604               LDI     R16, 100
   \   00000016   E010               LDI     R17, 0
   \   00000018   ........           CALL    OS_Delay
     31                  __watchdog_reset();               //kick the dog
   \   0000001C   95A8               WDR
   \   0000001E   CFFA               RJMP    ??WatchDogHandler_0
   \   00000020                      REQUIRE _A_WDTCR
     32              }
     33          }
     34          
     35          
     36          /*************************************************************************
     37          *
     38          *  Get my address
     39          *
     40          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     41          char MyAddress(void) {
   \                     MyAddress:
     42          
     43          #if (OS_UART == 0)
     44          #else
     45              MyPriAddress = ReadEEPROMByte(EEPROM_PRI_ADDR) ; // Get sec address from EEPROM
   \   00000000   E001               LDI     R16, 1
   \   00000002   E010               LDI     R17, 0
   \   00000004   ........           CALL    ReadEEPROMByte
   \   00000008   9300....           STS     MyPriAddress, R16
     46              MySecAddress = ReadEEPROMByte(EEPROM_SEC_ADDR) ; // Get sec address from EEPROM
   \   0000000C   E002               LDI     R16, 2
   \   0000000E   E010               LDI     R17, 0
   \   00000010   ........           CALL    ReadEEPROMByte
   \   00000014   9300....           STS     MySecAddress, R16
     47              return MySecAddress;
   \   00000018   9508               RET
     48              //return 0x00;
     49          #endif
     50          }
     51          
     52          /*************************************************************************
     53          *
     54          * 	Convert char to ASCII
     55          *
     56          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     57          void CharToAscii(char data, char * buf){
   \                     CharToAscii:
   \   00000000   2F50               MOV     R21, R16
     58              char i ;
     59              
     60              i= (data / 100) ;
   \   00000002   E644               LDI     R20, 100
   \   00000004   ........           CALL    ?UC_DIVMOD_L01
     61              buf[0] = i + 0x30 ;
   \   00000008   2F10               MOV     R17, R16
   \   0000000A   5D10               SUBI    R17, 208
   \   0000000C   01F9               MOVW    R31:R30, R19:R18
   \   0000000E   8310               ST      Z, R17
     62              data -= (i * 100) ;
   \   00000010   E644               LDI     R20, 100
   \   00000012   9F04               MUL     R16, R20
   \   00000014   1950               SUB     R21, R0
     63              i= data /10 ;
   \   00000016   E04A               LDI     R20, 10
   \   00000018   2F05               MOV     R16, R21
   \   0000001A   ........           CALL    ?UC_DIVMOD_L01
     64              buf[1] = i + 0x30 ;
   \   0000001E   2F40               MOV     R20, R16
   \   00000020   5D40               SUBI    R20, 208
   \   00000022   2FE2               MOV     R30, R18
   \   00000024   8341               STD     Z+1, R20
     65              data -= (i *10) ;
     66              buf[2] = data + 0x30 ;
   \   00000026   E06A               LDI     R22, 10
   \   00000028   9F06               MUL     R16, R22
   \   0000002A   1950               SUB     R21, R0
   \   0000002C   5D50               SUBI    R21, 208
   \   0000002E   8352               STD     Z+2, R21
     67              if (buf[0] == 0x30) {
   \   00000030   3310               CPI     R17, 48
   \   00000032   F411               BRNE    ??CharToAscii_0
     68                  buf[0] = 0x20 ; // space
   \   00000034   E200               LDI     R16, 32
   \   00000036   8300               ST      Z, R16
     69              }
     70              if ((buf[1] == 0x30) && (buf[0] == 0x20)) {
   \                     ??CharToAscii_0:
   \   00000038   3340               CPI     R20, 48
   \   0000003A   F429               BRNE    ??CharToAscii_1
   \   0000003C   8100               LD      R16, Z
   \   0000003E   3200               CPI     R16, 32
   \   00000040   F411               BRNE    ??CharToAscii_1
     71                  buf[1] = 0x20 ; // space
   \   00000042   E200               LDI     R16, 32
   \   00000044   8301               STD     Z+1, R16
     72              }
     73          }
   \                     ??CharToAscii_1:
   \   00000046   9508               RET
     74          

   Maximum stack usage in bytes:

   RSTACK Function
   ------ --------
      2   CharToAscii
        2 ?UC_DIVMOD_L01
      2   MyAddress
        2   -> ReadEEPROMByte
      2   WatchDogHandler
        2   -> OS_Delay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      72  CharToAscii
      26  MyAddress
      32  WatchDogHandler
       1  _A_WDTCR

 
   1 byte  in segment ABSOLUTE
 130 bytes in segment CODE
 
 130 bytes of CODE memory
   0 bytes of DATA memory (+ 1 byte shared)

Errors: none
Warnings: none
