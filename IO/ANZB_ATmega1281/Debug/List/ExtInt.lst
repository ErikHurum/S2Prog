###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       15/Feb/2024  16:44:02
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\ExtInt.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW4B57.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\ExtInt.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Debug\Obj" -D
#        OS_LIBMODE_D -D OS_UART=-1 -D USE_16552_DRIVER_TASK=1 -D
#        USE_1281_RX_INT_TASK=1 -D USE_MODBUS_PROTOCOL=0 -D ANZBANA_V8=1 -D
#        __ATMEGA_1281__ -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Debug\List" -y
#        --no_cse --no_inline --no_code_motion --no_cross_call --no_clustering
#        --no_tbaa --debug -DENABLE_BIT_DEFINITIONS -e -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Debug\List\ExtInt.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Debug\Obj\ExtInt.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\ExtInt.c
      1          /****************************************************************************************
      2          / AD converter handling , AD7715
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom1281.h"
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "externals.h"
     10          #pragma diag_suppress=Pa082
     11          #pragma diag_suppress=Pe767
     12          
     13          #if USE_16552_DRIVER_TASK == 1

   \                                 In  segment CODE, align 2, keep-with-next
     14          void _16552_Rx_handler(void *pData) {
   \                     _16552_Rx_handler:
   \   00000000   ........           CALL    ?PROLOGUE6_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004   9721               SBIW    R29:R28, 1
   \   00000006   0128               MOVW    R5:R4, R17:R16
     15              const char Ch = (char)pData;
   \   00000008   2D84               MOV     R24, R4
     16              char *RxBuff = UART16552[Ch].pRxBuffer;
   \   0000000A   ....               LDI     R26, LOW((UART16552 + 68))
   \   0000000C   ....               LDI     R27, HIGH((UART16552 + 68))
   \   0000000E   2F08               MOV     R16, R24
   \   00000010   E010               LDI     R17, 0
   \   00000012   E04B               LDI     R20, 11
   \   00000014   E051               LDI     R21, 1
   \   00000016   ........           CALL    ?S_EC_MUL_L02
   \   0000001A   0FA0               ADD     R26, R16
   \   0000001C   1FB1               ADC     R27, R17
     17              OS_WaitEvent(0x01);
   \   0000001E   E001               LDI     R16, 1
   \   00000020   ........           CALL    OS_WaitEvent
     18              while (true) {
     19                  char RxByte;
     20                  OS_GetMail1(&UART16552[Ch].RxMailBox, &RxByte);
   \                     ??_16552_Rx_handler_0:
   \   00000024   019E               MOVW    R19:R18, R29:R28
   \   00000026   ....               LDI     R22, LOW((UART16552 + 253))
   \   00000028   ....               LDI     R23, HIGH((UART16552 + 253))
   \   0000002A   2F08               MOV     R16, R24
   \   0000002C   E010               LDI     R17, 0
   \   0000002E   E04B               LDI     R20, 11
   \   00000030   E051               LDI     R21, 1
   \   00000032   ........           CALL    ?S_EC_MUL_L02
   \   00000036   0F60               ADD     R22, R16
   \   00000038   1F71               ADC     R23, R17
   \   0000003A   018B               MOVW    R17:R16, R23:R22
   \   0000003C   ........           CALL    OS_GetMail1
     21                  RxBuff[UART16552[Ch].RxFirst] = RxByte;
   \   00000040   8128               LD      R18, Y
   \   00000042   2F08               MOV     R16, R24
   \   00000044   E010               LDI     R17, 0
   \   00000046   E04B               LDI     R20, 11
   \   00000048   E051               LDI     R21, 1
   \   0000004A   ........           CALL    ?S_EC_MUL_L02
   \   0000004E   01F8               MOVW    R31:R30, R17:R16
   \   00000050   ....               SUBI    R30, LOW((-(UART16552 + 188) & 0xFFFF))
   \   00000052   ....               SBCI    R31, HIGH((-(UART16552 + 188) & 0xFFFF))
   \   00000054   8100               LD      R16, Z
   \   00000056   8111               LDD     R17, Z+1
   \   00000058   01FD               MOVW    R31:R30, R27:R26
   \   0000005A   0FE0               ADD     R30, R16
   \   0000005C   1FF1               ADC     R31, R17
   \   0000005E   8320               ST      Z, R18
     22                  if (UART16552[Ch].RxState != HANDLE) {                 // ok to receive?
   \   00000060   2F08               MOV     R16, R24
   \   00000062   E010               LDI     R17, 0
   \   00000064   E04B               LDI     R20, 11
   \   00000066   E051               LDI     R21, 1
   \   00000068   ........           CALL    ?S_EC_MUL_L02
   \   0000006C   01F8               MOVW    R31:R30, R17:R16
   \   0000006E   ....               SUBI    R30, LOW((-(UART16552 + 194) & 0xFFFF))
   \   00000070   ....               SBCI    R31, HIGH((-(UART16552 + 194) & 0xFFFF))
   \   00000072   8100               LD      R16, Z
   \   00000074   300A               CPI     R16, 10
   \   00000076   F2B1               BREQ    ??_16552_Rx_handler_0
     23                      switch (UART16552[Ch].RxState) {                   // Yes, check state
   \   00000078   2F08               MOV     R16, R24
   \   0000007A   E010               LDI     R17, 0
   \   0000007C   E04B               LDI     R20, 11
   \   0000007E   E051               LDI     R21, 1
   \   00000080   ........           CALL    ?S_EC_MUL_L02
   \   00000084   01F8               MOVW    R31:R30, R17:R16
   \   00000086   ....               SUBI    R30, LOW((-(UART16552 + 194) & 0xFFFF))
   \   00000088   ....               SBCI    R31, HIGH((-(UART16552 + 194) & 0xFFFF))
   \   0000008A   8100               LD      R16, Z
   \   0000008C   2300               TST     R16
   \   0000008E   F009               BREQ    $+2+2
   \   00000090   C079               RJMP    ??_16552_Rx_handler_1
     24                      case SYNC :
     25                          if (RxByte == ANPRO1_SYN) {
   \   00000092   8108               LD      R16, Y
   \   00000094   3002               CPI     R16, 2
   \   00000096   F4D1               BRNE    ??_16552_Rx_handler_2
     26                              UART16552[Ch].SyncCnt++;                 // count sync
   \   00000098   2F08               MOV     R16, R24
   \   0000009A   E010               LDI     R17, 0
   \   0000009C   E04B               LDI     R20, 11
   \   0000009E   E051               LDI     R21, 1
   \   000000A0   ........           CALL    ?S_EC_MUL_L02
   \   000000A4   01F8               MOVW    R31:R30, R17:R16
   \   000000A6   ....               SUBI    R30, LOW((-(UART16552 + 195) & 0xFFFF))
   \   000000A8   ....               SBCI    R31, HIGH((-(UART16552 + 195) & 0xFFFF))
   \   000000AA   8100               LD      R16, Z
   \   000000AC   9503               INC     R16
   \   000000AE   8300               ST      Z, R16
     27                              UART16552[Ch].RxFirst = 0;                 // start at start of buff
   \   000000B0   2F08               MOV     R16, R24
   \   000000B2   E010               LDI     R17, 0
   \   000000B4   E04B               LDI     R20, 11
   \   000000B6   E051               LDI     R21, 1
   \   000000B8   ........           CALL    ?S_EC_MUL_L02
   \   000000BC   01F8               MOVW    R31:R30, R17:R16
   \   000000BE   ....               SUBI    R30, LOW((-(UART16552 + 188) & 0xFFFF))
   \   000000C0   ....               SBCI    R31, HIGH((-(UART16552 + 188) & 0xFFFF))
   \   000000C2   E000               LDI     R16, 0
   \   000000C4   E010               LDI     R17, 0
   \   000000C6   8300               ST      Z, R16
   \   000000C8   8311               STD     Z+1, R17
   \   000000CA   CFAC               RJMP    ??_16552_Rx_handler_0
     28                          } else if (UART16552[Ch].SyncCnt >= 2) {       // minimum two sync bytes
   \                     ??_16552_Rx_handler_2:
   \   000000CC   2F08               MOV     R16, R24
   \   000000CE   E010               LDI     R17, 0
   \   000000D0   E04B               LDI     R20, 11
   \   000000D2   E051               LDI     R21, 1
   \   000000D4   ........           CALL    ?S_EC_MUL_L02
   \   000000D8   01F8               MOVW    R31:R30, R17:R16
   \   000000DA   ....               SUBI    R30, LOW((-(UART16552 + 195) & 0xFFFF))
   \   000000DC   ....               SBCI    R31, HIGH((-(UART16552 + 195) & 0xFFFF))
   \   000000DE   8100               LD      R16, Z
   \   000000E0   3002               CPI     R16, 2
   \   000000E2   F408               BRCC    $+2+2
   \   000000E4   C043               RJMP    ??_16552_Rx_handler_3
     29                              UART16552[Ch].SyncCnt = 0;                // reset counter
   \   000000E6   2F08               MOV     R16, R24
   \   000000E8   E010               LDI     R17, 0
   \   000000EA   E04B               LDI     R20, 11
   \   000000EC   E051               LDI     R21, 1
   \   000000EE   ........           CALL    ?S_EC_MUL_L02
   \   000000F2   01F8               MOVW    R31:R30, R17:R16
   \   000000F4   ....               SUBI    R30, LOW((-(UART16552 + 195) & 0xFFFF))
   \   000000F6   ....               SBCI    R31, HIGH((-(UART16552 + 195) & 0xFFFF))
   \   000000F8   E000               LDI     R16, 0
   \   000000FA   8300               ST      Z, R16
     30                              UART16552[Ch].RxState = HEADER;
   \   000000FC   2F08               MOV     R16, R24
   \   000000FE   E010               LDI     R17, 0
   \   00000100   E04B               LDI     R20, 11
   \   00000102   E051               LDI     R21, 1
   \   00000104   ........           CALL    ?S_EC_MUL_L02
   \   00000108   01F8               MOVW    R31:R30, R17:R16
   \   0000010A   ....               SUBI    R30, LOW((-(UART16552 + 194) & 0xFFFF))
   \   0000010C   ....               SBCI    R31, HIGH((-(UART16552 + 194) & 0xFFFF))
   \   0000010E   E001               LDI     R16, 1
   \   00000110   8300               ST      Z, R16
     31                              UART16552[Ch].RxLast = 0;
   \   00000112   2F08               MOV     R16, R24
   \   00000114   E010               LDI     R17, 0
   \   00000116   E04B               LDI     R20, 11
   \   00000118   E051               LDI     R21, 1
   \   0000011A   ........           CALL    ?S_EC_MUL_L02
   \   0000011E   01F8               MOVW    R31:R30, R17:R16
   \   00000120   ....               SUBI    R30, LOW((-(UART16552 + 190) & 0xFFFF))
   \   00000122   ....               SBCI    R31, HIGH((-(UART16552 + 190) & 0xFFFF))
   \   00000124   E000               LDI     R16, 0
   \   00000126   E010               LDI     R17, 0
   \   00000128   8300               ST      Z, R16
   \   0000012A   8311               STD     Z+1, R17
     32                              UART16552[Ch].RxTimeout = RX_TO_TIME;   // reset timeout
   \   0000012C   2F08               MOV     R16, R24
   \   0000012E   E010               LDI     R17, 0
   \   00000130   E04B               LDI     R20, 11
   \   00000132   E051               LDI     R21, 1
   \   00000134   ........           CALL    ?S_EC_MUL_L02
   \   00000138   01F8               MOVW    R31:R30, R17:R16
   \   0000013A   ....               SUBI    R30, LOW((-(UART16552 + 196) & 0xFFFF))
   \   0000013C   ....               SBCI    R31, HIGH((-(UART16552 + 196) & 0xFFFF))
   \   0000013E   EF0A               LDI     R16, 250
   \   00000140   E010               LDI     R17, 0
   \   00000142   8300               ST      Z, R16
   \   00000144   8311               STD     Z+1, R17
     33                              UART16552[Ch].RxFirst++;                 //  1. char OK, start on next
   \   00000146   2F08               MOV     R16, R24
   \   00000148   E010               LDI     R17, 0
   \   0000014A   E04B               LDI     R20, 11
   \   0000014C   E051               LDI     R21, 1
   \   0000014E   ........           CALL    ?S_EC_MUL_L02
   \   00000152   01F8               MOVW    R31:R30, R17:R16
   \   00000154   ....               SUBI    R30, LOW((-(UART16552 + 188) & 0xFFFF))
   \   00000156   ....               SBCI    R31, HIGH((-(UART16552 + 188) & 0xFFFF))
   \   00000158   8100               LD      R16, Z
   \   0000015A   8111               LDD     R17, Z+1
   \   0000015C   5F0F               SUBI    R16, 255
   \   0000015E   4F1F               SBCI    R17, 255
   \   00000160   8300               ST      Z, R16
   \   00000162   8311               STD     Z+1, R17
     34                              ReceivePacketUart16552(Ch);              // Check package
   \   00000164   2F08               MOV     R16, R24
   \   00000166   ........           CALL    ReceivePacketUart16552
   \   0000016A   CF5C               RJMP    ??_16552_Rx_handler_0
     35                          } else {
     36                              UART16552[Ch].SyncCnt = 0;                // start over once more
   \                     ??_16552_Rx_handler_3:
   \   0000016C   2F08               MOV     R16, R24
   \   0000016E   E010               LDI     R17, 0
   \   00000170   E04B               LDI     R20, 11
   \   00000172   E051               LDI     R21, 1
   \   00000174   ........           CALL    ?S_EC_MUL_L02
   \   00000178   01F8               MOVW    R31:R30, R17:R16
   \   0000017A   ....               SUBI    R30, LOW((-(UART16552 + 195) & 0xFFFF))
   \   0000017C   ....               SBCI    R31, HIGH((-(UART16552 + 195) & 0xFFFF))
   \   0000017E   E000               LDI     R16, 0
   \   00000180   8300               ST      Z, R16
     37                          }
     38                          break;
   \   00000182   CF50               RJMP    ??_16552_Rx_handler_0
     39                      default :
     40                          if ((++UART16552[Ch].RxFirst) > RXSIZE_UART_16552) { // Point to next location
   \                     ??_16552_Rx_handler_1:
   \   00000184   2F08               MOV     R16, R24
   \   00000186   E010               LDI     R17, 0
   \   00000188   E04B               LDI     R20, 11
   \   0000018A   E051               LDI     R21, 1
   \   0000018C   ........           CALL    ?S_EC_MUL_L02
   \   00000190   01F8               MOVW    R31:R30, R17:R16
   \   00000192   ....               SUBI    R30, LOW((-(UART16552 + 188) & 0xFFFF))
   \   00000194   ....               SBCI    R31, HIGH((-(UART16552 + 188) & 0xFFFF))
   \   00000196   8120               LD      R18, Z
   \   00000198   8131               LDD     R19, Z+1
   \   0000019A   5F2F               SUBI    R18, 255
   \   0000019C   4F3F               SBCI    R19, 255
   \   0000019E   2F08               MOV     R16, R24
   \   000001A0   E010               LDI     R17, 0
   \   000001A2   E04B               LDI     R20, 11
   \   000001A4   E051               LDI     R21, 1
   \   000001A6   ........           CALL    ?S_EC_MUL_L02
   \   000001AA   01F8               MOVW    R31:R30, R17:R16
   \   000001AC   ....               SUBI    R30, LOW((-(UART16552 + 188) & 0xFFFF))
   \   000001AE   ....               SBCI    R31, HIGH((-(UART16552 + 188) & 0xFFFF))
   \   000001B0   8320               ST      Z, R18
   \   000001B2   8331               STD     Z+1, R19
   \   000001B4   3729               CPI     R18, 121
   \   000001B6   E000               LDI     R16, 0
   \   000001B8   0730               CPC     R19, R16
   \   000001BA   F020               BRCS    ??_16552_Rx_handler_4
     41                              GoToSyncUART16552(Ch);                       // go to sync mode
   \   000001BC   2F08               MOV     R16, R24
   \   000001BE   ........           CALL    GoToSyncUART16552
   \   000001C2   CF30               RJMP    ??_16552_Rx_handler_0
     42                          } else {
     43                              ReceivePacketUart16552(Ch);              // Check package
   \                     ??_16552_Rx_handler_4:
   \   000001C4   2F08               MOV     R16, R24
   \   000001C6   ........           CALL    ReceivePacketUart16552
     44                          }
     45                          break;
   \   000001CA   CF2C               RJMP    ??_16552_Rx_handler_0
     46                      }
     47                  }
     48              }
     49          }
     50          
     51          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     52          OS_TASK TCB_16552_RxHandler1;
   \                     TCB_16552_RxHandler1:
   \   00000000                      DS8 33

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     53          OS_TASK TCB_16552_RxHandler2;
   \                     TCB_16552_RxHandler2:
   \   00000000                      DS8 33

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     54          static OS_STACKPTR int stack1[300]; /* Task stacks */
   \                     stack1:
   \   00000000                      DS8 600

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     55          static OS_STACKPTR int stack2[300]; /* Task stacks */
   \                     stack2:
   \   00000000                      DS8 600
     56          

   \                                 In  segment CODE, align 2, keep-with-next
     57          void _16552_driver_task_init(void) {
   \                     _16552_driver_task_init:
     58          
     59              OS_CREATETASK_EX(&TCB_16552_RxHandler1, "16552_RX_Handler 0", _16552_Rx_handler, 96, stack1, (void *)0);
   \   00000000   E000               LDI     R16, 0
   \   00000002   E010               LDI     R17, 0
   \   00000004   931A               ST      -Y, R17
   \   00000006   930A               ST      -Y, R16
   \   00000008   E002               LDI     R16, 2
   \   0000000A   E010               LDI     R17, 0
   \   0000000C   931A               ST      -Y, R17
   \   0000000E   930A               ST      -Y, R16
   \   00000010   E508               LDI     R16, 88
   \   00000012   E012               LDI     R17, 2
   \   00000014   931A               ST      -Y, R17
   \   00000016   930A               ST      -Y, R16
   \   00000018   ....               LDI     R16, LOW(stack1)
   \   0000001A   ....               LDI     R17, (stack1) >> 8
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   ....               LDI     R22, LOW(_16552_Rx_handler/2)
   \   00000022   ....               LDI     R23, (_16552_Rx_handler/2) >> 8
   \   00000024   E640               LDI     R20, 96
   \   00000026   ....               LDI     R18, LOW(`?<Constant "16552_RX_Handler 0">`)
   \   00000028   ....               LDI     R19, (`?<Constant "16552_RX_Handler 0">`) >> 8
   \   0000002A   ....               LDI     R16, LOW(TCB_16552_RxHandler1)
   \   0000002C   ....               LDI     R17, (TCB_16552_RxHandler1) >> 8
   \   0000002E   ........           CALL    OS_CreateTaskEx_D
     60              OS_CREATETASK_EX(&TCB_16552_RxHandler2, "16552_RX_Handler 1", _16552_Rx_handler, 95, stack2, (void *)1);
   \   00000032   E001               LDI     R16, LOW(1)
   \   00000034   E010               LDI     R17, (1) >> 8
   \   00000036   931A               ST      -Y, R17
   \   00000038   930A               ST      -Y, R16
   \   0000003A   E002               LDI     R16, 2
   \   0000003C   E010               LDI     R17, 0
   \   0000003E   931A               ST      -Y, R17
   \   00000040   930A               ST      -Y, R16
   \   00000042   E508               LDI     R16, 88
   \   00000044   E012               LDI     R17, 2
   \   00000046   931A               ST      -Y, R17
   \   00000048   930A               ST      -Y, R16
   \   0000004A   ....               LDI     R16, LOW(stack2)
   \   0000004C   ....               LDI     R17, (stack2) >> 8
   \   0000004E   931A               ST      -Y, R17
   \   00000050   930A               ST      -Y, R16
   \   00000052   ....               LDI     R22, LOW(_16552_Rx_handler/2)
   \   00000054   ....               LDI     R23, (_16552_Rx_handler/2) >> 8
   \   00000056   E54F               LDI     R20, 95
   \   00000058   ....               LDI     R18, LOW(`?<Constant "16552_RX_Handler 1">`)
   \   0000005A   ....               LDI     R19, (`?<Constant "16552_RX_Handler 1">`) >> 8
   \   0000005C   ....               LDI     R16, LOW(TCB_16552_RxHandler2)
   \   0000005E   ....               LDI     R17, (TCB_16552_RxHandler2) >> 8
   \   00000060   ........           CALL    OS_CreateTaskEx_D
     61          }
   \   00000064   9508               RET
     62          #endif
     63          
     64          /*************************************************************************
     65          *
     66          *  External int 0 (UART PC16554 on AN-ZB485 or ADready on AN-ZBANA)
     67          *
     68          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     69          void Int_Handler_INT0(void) {               //Int handler for ext int 0
   \                     Int_Handler_INT0:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
     70          
     71              // OBS!!!
     72              // Uses UART16552[].TxStatus as intreason and
     73              // UART16552[].TxSeqCnt as counter because these needs to be globale
     74              // by using OS_EnterIntStack()
     75          
     76          
     77              switch (UnitID) {
   \   00000004   9100....           LDS     R16, UnitID
   \   00000008   5000               SUBI    R16, 0
   \   0000000A   F021               BREQ    ??Int_Handler_INT0_0
   \   0000000C   950A               DEC     R16
   \   0000000E   F409               BRNE    $+2+2
   \   00000010   C07E               RJMP    ??Int_Handler_INT0_1
   \   00000012   C082               RJMP    ??Int_Handler_INT0_2
     78              case 0x00:                  // AN-ZB485
     79          #if USE_16552_DRIVER_TASK == 0
     80                  UART16552[0].TxStatus = (U0_IIR & 0x0f);          // reason for interrupt
     81                  do {
     82                      switch (UART16552[0].TxStatus) {
     83                      case 0x02 :             // transmit holding reg emty
     84                          if (UART16552[0].TxCount == 0) {
     85                              U0_MCR  &= ~RTS;        // set RTS off
     86                              UART16552[0].RxState = SYNC;
     87                              //OS_StopTimer(&TimerUART0);                    // and stop timer
     88                          } else {
     89                              for (UART16552[0].TxSeqCnt = 0; (UART16552[0].TxSeqCnt < FIFO_TX_BUFSIZE) && (UART16552[0].TxCount > 0); UART16552[0].TxSeqCnt++, --UART16552[0].TxCount) {
     90                                  U0_THR = UART16552[0].pTxBuffer[UART16552[0].TxLast++];
     91                              }
     92                          }
     93                          break;
     94                      case 0x04 :             // Receive data available
     95                      case 0x0C :             // or caracter timeout (FIFO)
     96                          if (UART16552[0].RxState == SEND) {
     97                              while (U0_LSR & DATA_READY) {
     98                                  U0_RBR;
     99                              }
    100                          } else while (U0_LSR & DATA_READY) {
    101                              UART16552[0].pRxBuffer[UART16552[0].RxFirst] = U0_RBR;             // Read the character
    102          
    103                              if (UART16552[0].RxState != HANDLE) {                 // ok to receive?
    104                                  switch (UART16552[0].RxState) {                   // Yes, check state
    105                                  case SYNC :
    106                                      if (UART16552[0].pRxBuffer[UART16552[0].RxFirst] == ANPRO1_SYN) {
    107                                          UART16552[0].SyncCnt++;                 // count sync
    108                                          UART16552[0].RxFirst = 0;                 // start at start of buff
    109                                      } else if (UART16552[0].SyncCnt >= 2) {       // minimum two sync bytes
    110                                          UART16552[0].SyncCnt = 0;                // reset counter
    111                                          UART16552[0].RxState = HEADER;
    112                                          UART16552[0].RxLast = 0;
    113                                          UART16552[0].RxTimeout = RX_TO_TIME;   // reset timeout
    114                                          UART16552[0].RxFirst++;                 //  1. char OK, start on next
    115                                          ReceivePacketUart16552(0);              // Check package
    116                                      } else {
    117                                          UART16552[0].SyncCnt = 0;                // start over once more
    118                                      }
    119                                      break;
    120                                  default :
    121                                      if ((++UART16552[0].RxFirst) > RXSIZE_UART_16552) { // Point to next location
    122                                          GoToSyncUART16552(0);                       // go to sync mode
    123                                      } else {
    124                                          ReceivePacketUart16552(0);              // Check package
    125                                      }
    126                                      break;
    127                                  }
    128                              }
    129                          }
    130                          break;
    131                      case 0x06 :                 // Receiver line status, OR, PE, FR, Break int.
    132                          U0_LSR;      // Dummy read to empty register
    133                          break;
    134                      case 0x00 :                 // Modem status.
    135                          U0_MSR;      // Dummy read to empty register
    136                          break;
    137                      }
    138                      UART16552[0].TxStatus = (U0_IIR & 0x0f);      // reason for interrupt,
    139                      // check again before exit to avoid lost int. and hang
    140                  } while ((UART16552[0].TxStatus & 0x01) != 0x01);
    141          #else
    142                  UART16552[0].TxStatus = (U0_IIR & IIR_MASK);          // reason for interrupt
   \                     ??Int_Handler_INT0_0:
   \   00000014   9100220A           LDS     R16, 8714
   \   00000018   700F               ANDI    R16, 0x0F
   \   0000001A   9300....           STS     (UART16552 + 66), R16
    143                  do {
    144                      switch (UART16552[0].TxStatus) {
   \                     ??Int_Handler_INT0_3:
   \   0000001E   9100....           LDS     R16, (UART16552 + 66)
   \   00000022   5000               SUBI    R16, 0
   \   00000024   F409               BRNE    $+2+2
   \   00000026   C066               RJMP    ??Int_Handler_INT0_4
   \   00000028   5002               SUBI    R16, 2
   \   0000002A   F049               BREQ    ??Int_Handler_INT0_5
   \   0000002C   5002               SUBI    R16, 2
   \   0000002E   F409               BRNE    $+2+2
   \   00000030   C042               RJMP    ??Int_Handler_INT0_6
   \   00000032   5002               SUBI    R16, 2
   \   00000034   F409               BRNE    $+2+2
   \   00000036   C05B               RJMP    ??Int_Handler_INT0_7
   \   00000038   5006               SUBI    R16, 6
   \   0000003A   F1E9               BREQ    ??Int_Handler_INT0_6
   \   0000003C   C05D               RJMP    ??Int_Handler_INT0_8
    145                      case IIR_THRE :             // transmit holding reg emty
    146                          if (UART16552[0].TxCount == 0) {
   \                     ??Int_Handler_INT0_5:
   \   0000003E   ....               LDI     R30, LOW((UART16552 + 64))
   \   00000040   ....               LDI     R31, HIGH((UART16552 + 64))
   \   00000042   8100               LD      R16, Z
   \   00000044   8111               LDD     R17, Z+1
   \   00000046   2B01               OR      R16, R17
   \   00000048   F449               BRNE    ??Int_Handler_INT0_9
    147                              U0_MCR &= ~RTS;        // set RTS off
   \   0000004A   E0EC               LDI     R30, LOW(8716)
   \   0000004C   E2F2               LDI     R31, (8716) >> 8
   \   0000004E   8100               LD      R16, Z
   \   00000050   7F0D               ANDI    R16, 0xFD
   \   00000052   8300               ST      Z, R16
    148                              UART16552[0].RxState = SYNC;
   \   00000054   E000               LDI     R16, 0
   \   00000056   9300....           STS     (UART16552 + 194), R16
   \   0000005A   C04E               RJMP    ??Int_Handler_INT0_8
    149                              //OS_StopTimer(&TimerUART0);                    // and stop timer
    150                          } else {
    151                              for (UART16552[0].TxSeqCnt = 0; (UART16552[0].TxSeqCnt < FIFO_TX_BUFSIZE) && (UART16552[0].TxCount > 0); UART16552[0].TxSeqCnt++, --UART16552[0].TxCount) {
   \                     ??Int_Handler_INT0_9:
   \   0000005C   E000               LDI     R16, 0
   \   0000005E   9300....           STS     (UART16552 + 67), R16
   \                     ??Int_Handler_INT0_10:
   \   00000062   9100....           LDS     R16, (UART16552 + 67)
   \   00000066   3100               CPI     R16, 16
   \   00000068   F528               BRCC    ??Int_Handler_INT0_11
   \   0000006A   ....               LDI     R30, LOW((UART16552 + 64))
   \   0000006C   ....               LDI     R31, HIGH((UART16552 + 64))
   \   0000006E   8100               LD      R16, Z
   \   00000070   8111               LDD     R17, Z+1
   \   00000072   2B01               OR      R16, R17
   \   00000074   F409               BRNE    $+2+2
   \   00000076   C040               RJMP    ??Int_Handler_INT0_8
    152                                  U0_THR = UART16552[0].pTxBuffer[UART16552[0].TxLast++];
   \   00000078   ....               LDI     R30, LOW((UART16552 + 62))
   \   0000007A   ....               LDI     R31, HIGH((UART16552 + 62))
   \   0000007C   8100               LD      R16, Z
   \   0000007E   8111               LDD     R17, Z+1
   \   00000080   01C8               MOVW    R25:R24, R17:R16
   \   00000082   9601               ADIW    R25:R24, 1
   \   00000084   ....               LDI     R30, LOW((UART16552 + 62))
   \   00000086   ....               LDI     R31, HIGH((UART16552 + 62))
   \   00000088   8380               ST      Z, R24
   \   0000008A   8391               STD     Z+1, R25
   \   0000008C   01F8               MOVW    R31:R30, R17:R16
   \   0000008E   ....               SUBI    R30, LOW((-(UART16552) & 0xFFFF))
   \   00000090   ....               SBCI    R31, (-(UART16552) & 0xFFFF) >> 8
   \   00000092   8100               LD      R16, Z
   \   00000094   93002208           STS     8712, R16
    153                              }
   \   00000098   9100....           LDS     R16, (UART16552 + 67)
   \   0000009C   9503               INC     R16
   \   0000009E   9300....           STS     (UART16552 + 67), R16
   \   000000A2   ....               LDI     R30, LOW((UART16552 + 64))
   \   000000A4   ....               LDI     R31, HIGH((UART16552 + 64))
   \   000000A6   8100               LD      R16, Z
   \   000000A8   8111               LDD     R17, Z+1
   \   000000AA   5001               SUBI    R16, 1
   \   000000AC   4010               SBCI    R17, 0
   \   000000AE   8300               ST      Z, R16
   \   000000B0   8311               STD     Z+1, R17
   \   000000B2   CFD7               RJMP    ??Int_Handler_INT0_10
    154                          }
    155                          break;
   \                     ??Int_Handler_INT0_11:
   \   000000B4   C021               RJMP    ??Int_Handler_INT0_8
    156                      case IIR_TOUT:          // Receive data available
    157                      case IIR_RBRF:          // or caracter timeout (FIFO)
    158                          if (UART16552[0].RxState == SEND) {
   \                     ??Int_Handler_INT0_6:
   \   000000B6   9100....           LDS     R16, (UART16552 + 194)
   \   000000BA   3003               CPI     R16, 3
   \   000000BC   F441               BRNE    ??Int_Handler_INT0_12
    159                              while (U0_LSR & DATA_READY) {
   \                     ??Int_Handler_INT0_13:
   \   000000BE   E0ED               LDI     R30, LOW(8717)
   \   000000C0   E2F2               LDI     R31, (8717) >> 8
   \   000000C2   8100               LD      R16, Z
   \   000000C4   FF00               SBRS    R16, 0
   \   000000C6   C018               RJMP    ??Int_Handler_INT0_8
    160                                  U0_RBR;
   \   000000C8   91002208           LDS     R16, 8712
   \   000000CC   CFF8               RJMP    ??Int_Handler_INT0_13
    161                              }
    162                          } else {
    163                              while (U0_LSR & DATA_READY) {
   \                     ??Int_Handler_INT0_12:
   \   000000CE   E0ED               LDI     R30, LOW(8717)
   \   000000D0   E2F2               LDI     R31, (8717) >> 8
   \   000000D2   8100               LD      R16, Z
   \   000000D4   FF00               SBRS    R16, 0
   \   000000D6   C010               RJMP    ??Int_Handler_INT0_8
    164                                  UART16552[0].RxByte = U0_RBR;    // Read the character
   \   000000D8   91002208           LDS     R16, 8712
   \   000000DC   9300....           STS     (UART16552 + 202), R16
    165                                  OS_PutMailCond1(&UART16552[0].RxMailBox, &UART16552[0].RxByte);
   \   000000E0   ....               LDI     R18, LOW((UART16552 + 202))
   \   000000E2   ....               LDI     R19, HIGH((UART16552 + 202))
   \   000000E4   ....               LDI     R16, LOW((UART16552 + 253))
   \   000000E6   ....               LDI     R17, HIGH((UART16552 + 253))
   \   000000E8   ........           CALL    OS_PutMailCond1
   \   000000EC   CFF0               RJMP    ??Int_Handler_INT0_12
    166                              }
    167                          }
    168                          break;
    169                      case IIR_SEOB:   // Receiver line status, OR, PE, FR, Break int.
    170                          U0_LSR;      // Dummy read to empty register
   \                     ??Int_Handler_INT0_7:
   \   000000EE   9100220D           LDS     R16, 8717
    171                          break;
   \   000000F2   C002               RJMP    ??Int_Handler_INT0_8
    172                      case IIR_MSTAT :                 // Modem status.
    173                          U0_MSR;      // Dummy read to empty register
   \                     ??Int_Handler_INT0_4:
   \   000000F4   9100220E           LDS     R16, 8718
    174                          break;
    175                      }
    176                      UART16552[0].TxStatus = (U0_IIR & IIR_MASK);      // reason for interrupt,
   \                     ??Int_Handler_INT0_8:
   \   000000F8   9100220A           LDS     R16, 8714
   \   000000FC   700F               ANDI    R16, 0x0F
   \   000000FE   9300....           STS     (UART16552 + 66), R16
    177                      // check again before exit to avoid lost int. and hang
    178                  } while ((UART16552[0].TxStatus & 0x01) == 0x00);
   \   00000102   ....               LDI     R30, LOW((UART16552 + 66))
   \   00000104   ....               LDI     R31, HIGH((UART16552 + 66))
   \   00000106   8100               LD      R16, Z
   \   00000108   FF00               SBRS    R16, 0
   \   0000010A   CF89               RJMP    ??Int_Handler_INT0_3
    179          
    180          #endif
    181                  break;
   \   0000010C   C005               RJMP    ??Int_Handler_INT0_2
    182              case 0x01:                  // AN-ZBANA ADready
    183                  OS_SignalEvent(1, &TCB_AD7715);
   \                     ??Int_Handler_INT0_1:
   \   0000010E   ....               LDI     R18, LOW(TCB_AD7715)
   \   00000110   ....               LDI     R19, (TCB_AD7715) >> 8
   \   00000112   E001               LDI     R16, 1
   \   00000114   ........           CALL    OS_SignalEvent
    184                  break;
    185              }
    186          }
   \                     ??Int_Handler_INT0_2:
   \   00000118   9189               LD      R24, Y+
   \   0000011A   9199               LD      R25, Y+
   \   0000011C   9508               RET
    187          
    188          
    189          #pragma vector=INT0_vect

   \                                 In  segment CODE, align 2, keep-with-next
    190          __interrupt void IntHandler_INT0(void) {               //Int handler for ext int 0
   \                     IntHandler_INT0:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    191              OS_CallISR(Int_Handler_INT0);
   \   00000024   ....               LDI     R16, LOW(Int_Handler_INT0/2)
   \   00000026   ....               LDI     R17, (Int_Handler_INT0/2) >> 8
   \   00000028   ........           CALL    OS_CallISR_Debug
    192          }
   \   0000002C   BF9B               OUT     0x3B, R25
   \   0000002E   BF8F               OUT     0x3F, R24
   \   00000030   9109               LD      R16, Y+
   \   00000032   9119               LD      R17, Y+
   \   00000034   9129               LD      R18, Y+
   \   00000036   9139               LD      R19, Y+
   \   00000038   9149               LD      R20, Y+
   \   0000003A   9159               LD      R21, Y+
   \   0000003C   9169               LD      R22, Y+
   \   0000003E   9179               LD      R23, Y+
   \   00000040   9009               LD      R0, Y+
   \   00000042   9019               LD      R1, Y+
   \   00000044   9029               LD      R2, Y+
   \   00000046   9039               LD      R3, Y+
   \   00000048   91E9               LD      R30, Y+
   \   0000004A   91F9               LD      R31, Y+
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9518               RETI
    193          
    194          /*************************************************************************
    195          *
    196          *  External int 1 (UART PC16554 on AN-ZB485)
    197          *
    198          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    199          void Int_Handler_INT1(void) {               //Int handler for Ext int 1
   \                     Int_Handler_INT1:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
    200          
    201              // OBS!!!
    202              // Uses UART16552[].TxStatus as int reason and
    203              // UART16552[].TxSeqCnt as counter because these needs to be globale
    204              // by using OS_EnterIntStack()
    205          
    206              switch (UnitID) {
   \   00000004   9100....           LDS     R16, UnitID
   \   00000008   5000               SUBI    R16, 0
   \   0000000A   F021               BREQ    ??Int_Handler_INT1_0
   \   0000000C   950A               DEC     R16
   \   0000000E   F409               BRNE    $+2+2
   \   00000010   C07D               RJMP    ??Int_Handler_INT1_1
   \   00000012   C07C               RJMP    ??Int_Handler_INT1_1
    207              case 0x00:                  // AN-ZB485
    208          #if USE_16552_DRIVER_TASK == 0
    209                  UART16552[1].TxStatus = (U1_IIR & 0x0f);          // reason for interrupt
    210                  do {
    211                      switch (UART16552[1].TxStatus) {
    212                      case 0x02 :             // transmit holding reg emty
    213                          if (UART16552[1].TxCount == 0) {
    214                              U1_MCR &= ~RTS;        // set RTS off
    215                              UART16552[1].RxState = SYNC;
    216                              //OS_StopTimer(&TimerUART1);                    // and stop timer
    217                          } else {
    218                              for (UART16552[1].TxSeqCnt = 0; (UART16552[1].TxSeqCnt < FIFO_TX_BUFSIZE) && (UART16552[1].TxCount > 0); UART16552[1].TxSeqCnt++, UART16552[1].TxCount--) {
    219                                  U1_THR = UART16552[1].pTxBuffer[UART16552[1].TxLast++];
    220                              }
    221                          }
    222                          break;
    223                      case 0x04 :             // Receive data available
    224                      case 0x0C :             // or caracter timeout (FIFO)
    225                          if (UART16552[1].RxState == SEND) {
    226                              while (U1_LSR & DATA_READY) {
    227                                  U1_RBR;
    228                              }
    229                          } else while (U1_LSR & DATA_READY) {
    230                              UART16552[1].pRxBuffer[UART16552[1].RxFirst] = U1_RBR;             // Read the character
    231          
    232                              if (UART16552[1].RxState != HANDLE) {        // ok to receive?
    233                                  switch (UART16552[1].RxState) {                   // Yes, check state
    234                                  case SYNC :
    235                                      if (UART16552[1].pRxBuffer[UART16552[1].RxFirst] == ANPRO1_SYN) {
    236                                          UART16552[1].SyncCnt++;                 // count sync
    237                                          UART16552[1].RxFirst = 0;                 // start at start of buff
    238                                      } else if (UART16552[1].SyncCnt >= 2) {       // minimum two sync bytes
    239                                          UART16552[1].SyncCnt = 0;                // reset counter
    240                                          UART16552[1].RxState = HEADER;
    241                                          UART16552[1].RxLast = 0;
    242                                          UART16552[1].RxTimeout = RX_TO_TIME;     // reset timeout
    243                                          UART16552[1].RxFirst++;                  //  1. char OK, start on next
    244                                          ReceivePacketUart16552(1);               // Check package
    245                                      } else {
    246                                          UART16552[1].SyncCnt = 0;                // start over once more
    247                                      }
    248                                      break;
    249                                  default :
    250                                      if ((++UART16552[1].RxFirst) > RXSIZE_UART_16552) { // Point to next location
    251                                          GoToSyncUART16552(1);                       // go to sync mode
    252                                      } else {
    253                                          ReceivePacketUart16552(1);              // Check package
    254                                      }
    255                                      break;
    256                                  }
    257                              }
    258                          }
    259                          break;
    260                      case 0x06 :                 // Receiver line status, OR, PE, FR, Break int.
    261                          U1_LSR;      // Dummy read to empty register
    262                          break;
    263                      case 0x00 :                 // Modem status.
    264                          U1_MSR;      // Dummy read to empty register
    265                          break;
    266                      }
    267                      UART16552[1].TxStatus = (U1_IIR & 0x0f);      // reason for interrupt,
    268                      // check again before exit to avoid lost int. and hang
    269                  } while ((UART16552[1].TxStatus & 0x01) != 0x01);
    270          #else
    271                  UART16552[1].TxStatus = (U1_IIR & IIR_MASK);          // reason for interrupt
   \                     ??Int_Handler_INT1_0:
   \   00000014   91002202           LDS     R16, 8706
   \   00000018   700F               ANDI    R16, 0x0F
   \   0000001A   9300....           STS     (UART16552 + 333), R16
    272                  do {
    273                      switch (UART16552[1].TxStatus) {
   \                     ??Int_Handler_INT1_2:
   \   0000001E   9100....           LDS     R16, (UART16552 + 333)
   \   00000022   5000               SUBI    R16, 0
   \   00000024   F409               BRNE    $+2+2
   \   00000026   C066               RJMP    ??Int_Handler_INT1_3
   \   00000028   5002               SUBI    R16, 2
   \   0000002A   F049               BREQ    ??Int_Handler_INT1_4
   \   0000002C   5002               SUBI    R16, 2
   \   0000002E   F409               BRNE    $+2+2
   \   00000030   C042               RJMP    ??Int_Handler_INT1_5
   \   00000032   5002               SUBI    R16, 2
   \   00000034   F409               BRNE    $+2+2
   \   00000036   C05B               RJMP    ??Int_Handler_INT1_6
   \   00000038   5006               SUBI    R16, 6
   \   0000003A   F1E9               BREQ    ??Int_Handler_INT1_5
   \   0000003C   C05D               RJMP    ??Int_Handler_INT1_7
    274                      case IIR_THRE :             // transmit holding reg emty
    275                          if (UART16552[1].TxCount == 0) {
   \                     ??Int_Handler_INT1_4:
   \   0000003E   ....               LDI     R30, LOW((UART16552 + 331))
   \   00000040   ....               LDI     R31, HIGH((UART16552 + 331))
   \   00000042   8100               LD      R16, Z
   \   00000044   8111               LDD     R17, Z+1
   \   00000046   2B01               OR      R16, R17
   \   00000048   F449               BRNE    ??Int_Handler_INT1_8
    276                              U1_MCR &= ~RTS;        // set RTS off
   \   0000004A   E0E4               LDI     R30, LOW(8708)
   \   0000004C   E2F2               LDI     R31, (8708) >> 8
   \   0000004E   8100               LD      R16, Z
   \   00000050   7F0D               ANDI    R16, 0xFD
   \   00000052   8300               ST      Z, R16
    277                              UART16552[1].RxState = SYNC;
   \   00000054   E000               LDI     R16, 0
   \   00000056   9300....           STS     (UART16552 + 461), R16
   \   0000005A   C04E               RJMP    ??Int_Handler_INT1_7
    278                              //OS_StopTimer(&TimerUART0);                    // and stop timer
    279                          } else {
    280                              for (UART16552[1].TxSeqCnt = 0; (UART16552[1].TxSeqCnt < FIFO_TX_BUFSIZE) && (UART16552[1].TxCount > 0); UART16552[1].TxSeqCnt++, --UART16552[1].TxCount) {
   \                     ??Int_Handler_INT1_8:
   \   0000005C   E000               LDI     R16, 0
   \   0000005E   9300....           STS     (UART16552 + 334), R16
   \                     ??Int_Handler_INT1_9:
   \   00000062   9100....           LDS     R16, (UART16552 + 334)
   \   00000066   3100               CPI     R16, 16
   \   00000068   F528               BRCC    ??Int_Handler_INT1_10
   \   0000006A   ....               LDI     R30, LOW((UART16552 + 331))
   \   0000006C   ....               LDI     R31, HIGH((UART16552 + 331))
   \   0000006E   8100               LD      R16, Z
   \   00000070   8111               LDD     R17, Z+1
   \   00000072   2B01               OR      R16, R17
   \   00000074   F409               BRNE    $+2+2
   \   00000076   C040               RJMP    ??Int_Handler_INT1_7
    281                                  U1_THR = UART16552[1].pTxBuffer[UART16552[1].TxLast++];
   \   00000078   ....               LDI     R30, LOW((UART16552 + 329))
   \   0000007A   ....               LDI     R31, HIGH((UART16552 + 329))
   \   0000007C   8100               LD      R16, Z
   \   0000007E   8111               LDD     R17, Z+1
   \   00000080   01C8               MOVW    R25:R24, R17:R16
   \   00000082   9601               ADIW    R25:R24, 1
   \   00000084   ....               LDI     R30, LOW((UART16552 + 329))
   \   00000086   ....               LDI     R31, HIGH((UART16552 + 329))
   \   00000088   8380               ST      Z, R24
   \   0000008A   8391               STD     Z+1, R25
   \   0000008C   01F8               MOVW    R31:R30, R17:R16
   \   0000008E   ....               SUBI    R30, LOW((-(UART16552 + 267) & 0xFFFF))
   \   00000090   ....               SBCI    R31, HIGH((-(UART16552 + 267) & 0xFFFF))
   \   00000092   8100               LD      R16, Z
   \   00000094   93002200           STS     8704, R16
    282                              }
   \   00000098   9100....           LDS     R16, (UART16552 + 334)
   \   0000009C   9503               INC     R16
   \   0000009E   9300....           STS     (UART16552 + 334), R16
   \   000000A2   ....               LDI     R30, LOW((UART16552 + 331))
   \   000000A4   ....               LDI     R31, HIGH((UART16552 + 331))
   \   000000A6   8100               LD      R16, Z
   \   000000A8   8111               LDD     R17, Z+1
   \   000000AA   5001               SUBI    R16, 1
   \   000000AC   4010               SBCI    R17, 0
   \   000000AE   8300               ST      Z, R16
   \   000000B0   8311               STD     Z+1, R17
   \   000000B2   CFD7               RJMP    ??Int_Handler_INT1_9
    283                          }
    284                          break;
   \                     ??Int_Handler_INT1_10:
   \   000000B4   C021               RJMP    ??Int_Handler_INT1_7
    285                      case IIR_TOUT:          // Receive data available
    286                      case IIR_RBRF:          // or caracter timeout (FIFO)
    287                          if (UART16552[1].RxState == SEND) {
   \                     ??Int_Handler_INT1_5:
   \   000000B6   9100....           LDS     R16, (UART16552 + 461)
   \   000000BA   3003               CPI     R16, 3
   \   000000BC   F441               BRNE    ??Int_Handler_INT1_11
    288                              while (U1_LSR & DATA_READY) {
   \                     ??Int_Handler_INT1_12:
   \   000000BE   E0E5               LDI     R30, LOW(8709)
   \   000000C0   E2F2               LDI     R31, (8709) >> 8
   \   000000C2   8100               LD      R16, Z
   \   000000C4   FF00               SBRS    R16, 0
   \   000000C6   C018               RJMP    ??Int_Handler_INT1_7
    289                                  U1_RBR;
   \   000000C8   91002200           LDS     R16, 8704
   \   000000CC   CFF8               RJMP    ??Int_Handler_INT1_12
    290                              }
    291                          } else {
    292                              while (U1_LSR & DATA_READY) {
   \                     ??Int_Handler_INT1_11:
   \   000000CE   E0E5               LDI     R30, LOW(8709)
   \   000000D0   E2F2               LDI     R31, (8709) >> 8
   \   000000D2   8100               LD      R16, Z
   \   000000D4   FF00               SBRS    R16, 0
   \   000000D6   C010               RJMP    ??Int_Handler_INT1_7
    293                                  UART16552[1].RxByte = U1_RBR;    // Read the character
   \   000000D8   91002200           LDS     R16, 8704
   \   000000DC   9300....           STS     (UART16552 + 469), R16
    294                                  OS_PutMailCond1(&UART16552[1].RxMailBox, &UART16552[1].RxByte);
   \   000000E0   ....               LDI     R18, LOW((UART16552 + 469))
   \   000000E2   ....               LDI     R19, HIGH((UART16552 + 469))
   \   000000E4   ....               LDI     R16, LOW((UART16552 + 520))
   \   000000E6   ....               LDI     R17, HIGH((UART16552 + 520))
   \   000000E8   ........           CALL    OS_PutMailCond1
   \   000000EC   CFF0               RJMP    ??Int_Handler_INT1_11
    295                              }
    296                          }
    297                          break;
    298                      case IIR_SEOB:   // Receiver line status, OR, PE, FR, Break int.
    299                          U1_LSR;      // Dummy read to empty register
   \                     ??Int_Handler_INT1_6:
   \   000000EE   91002205           LDS     R16, 8709
    300                          break;
   \   000000F2   C002               RJMP    ??Int_Handler_INT1_7
    301                      case IIR_MSTAT :                 // Modem status.
    302                          U1_MSR;      // Dummy read to empty register
   \                     ??Int_Handler_INT1_3:
   \   000000F4   91002206           LDS     R16, 8710
    303                          break;
    304                      }
    305                      UART16552[1].TxStatus = (U1_IIR & IIR_MASK);      // reason for interrupt,
   \                     ??Int_Handler_INT1_7:
   \   000000F8   91002202           LDS     R16, 8706
   \   000000FC   700F               ANDI    R16, 0x0F
   \   000000FE   9300....           STS     (UART16552 + 333), R16
    306                      // check again before exit to avoid lost int. and hang
    307                  } while ((UART16552[1].TxStatus & 0x01) == 0x00);
   \   00000102   ....               LDI     R30, LOW((UART16552 + 333))
   \   00000104   ....               LDI     R31, HIGH((UART16552 + 333))
   \   00000106   8100               LD      R16, Z
   \   00000108   FF00               SBRS    R16, 0
   \   0000010A   CF89               RJMP    ??Int_Handler_INT1_2
    308          #endif
    309                  break;
    310              case 0x01:                  // AN-ZBANA Not connected!
    311                  break;
    312              }
    313          }
   \                     ??Int_Handler_INT1_1:
   \   0000010C   9189               LD      R24, Y+
   \   0000010E   9199               LD      R25, Y+
   \   00000110   9508               RET
    314          
    315          
    316          #pragma vector=INT1_vect

   \                                 In  segment CODE, align 2, keep-with-next
    317          __interrupt void IntHandler_INT1(void) {               //Int handler for Ext int 1
   \                     IntHandler_INT1:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    318          
    319              OS_CallISR(Int_Handler_INT1);
   \   00000024   ....               LDI     R16, LOW(Int_Handler_INT1/2)
   \   00000026   ....               LDI     R17, (Int_Handler_INT1/2) >> 8
   \   00000028   ........           CALL    OS_CallISR_Debug
    320          }
   \   0000002C   BF9B               OUT     0x3B, R25
   \   0000002E   BF8F               OUT     0x3F, R24
   \   00000030   9109               LD      R16, Y+
   \   00000032   9119               LD      R17, Y+
   \   00000034   9129               LD      R18, Y+
   \   00000036   9139               LD      R19, Y+
   \   00000038   9149               LD      R20, Y+
   \   0000003A   9159               LD      R21, Y+
   \   0000003C   9169               LD      R22, Y+
   \   0000003E   9179               LD      R23, Y+
   \   00000040   9009               LD      R0, Y+
   \   00000042   9019               LD      R1, Y+
   \   00000044   9029               LD      R2, Y+
   \   00000046   9039               LD      R3, Y+
   \   00000048   91E9               LD      R30, Y+
   \   0000004A   91F9               LD      R31, Y+
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9518               RETI

   \                                 In  segment INTVEC, offset 0x4, root
   \                     `??IntHandler_INT0::??INTVEC 4`:
   \   00000004   ........           JMP     IntHandler_INT0

   \                                 In  segment INTVEC, offset 0x8, root
   \                     `??IntHandler_INT1::??INTVEC 8`:
   \   00000008   ........           JMP     IntHandler_INT1

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "16552_RX_Handler `:
   \   00000000   363135355F32       DC8 "16552_RX_Handler 0"
   \              5852485F6E61
   \              6C6472653020
   \              00          

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "16552_RX_Handler _1`:
   \   00000000   363135355F32       DC8 "16552_RX_Handler 1"
   \              5852485F6E61
   \              6C6472653120
   \              00          

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant "16552_RX_Handler 0">`:
   \   00000000                      DS8 19
   \   00000013                      REQUIRE `?<Initializer for <Constant "16552_RX_Handler `

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant "16552_RX_Handler 1">`:
   \   00000000                      DS8 19
   \   00000013                      REQUIRE `?<Initializer for <Constant "16552_RX_Handler _1`

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
     16      2   IntHandler_INT0
       16      2   -> OS_CallISR_Debug
     16      2   IntHandler_INT1
       16      2   -> OS_CallISR_Debug
      2      2   Int_Handler_INT0
        2      2   -> OS_PutMailCond1
        2      2   -> OS_SignalEvent
      2      2   Int_Handler_INT1
        2      2   -> OS_PutMailCond1
      7      2   _16552_Rx_handler
        7      2   -> GoToSyncUART16552
        7      2   -> OS_GetMail1
        7      2   -> OS_WaitEvent
        7      2   -> ReceivePacketUart16552
        7      2 ?S_EC_MUL_L02
      8      2   _16552_driver_task_init
        0      2   -> OS_CreateTaskEx_D


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      19  ?<Constant "16552_RX_Handler 0">
      19  ?<Constant "16552_RX_Handler 1">
      19  ?<Initializer for <Constant "16552_RX_Handler
      19  ?<Initializer for <Constant "16552_RX_Handler _1
      82  IntHandler_INT0
       4  IntHandler_INT0::??INTVEC 4
      82  IntHandler_INT1
       4  IntHandler_INT1::??INTVEC 8
     286  Int_Handler_INT0
     274  Int_Handler_INT1
      33  TCB_16552_RxHandler1
      33  TCB_16552_RxHandler2
     460  _16552_Rx_handler
     102  _16552_driver_task_init
     600  stack1
     600  stack2
      14  -- Other

 
 1 286 bytes in segment CODE
    14 bytes in segment INITTAB
     8 bytes in segment INTVEC
    38 bytes in segment NEAR_I
    38 bytes in segment NEAR_ID
 1 266 bytes in segment NEAR_Z
 
 1 324 bytes of CODE memory (+ 22 bytes shared)
 1 304 bytes of DATA memory

Errors: none
Warnings: none
