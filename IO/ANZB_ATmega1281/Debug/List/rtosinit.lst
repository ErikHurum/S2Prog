###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       26/Feb/2024  12:14:10
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWAD5E.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Debug\Obj" -D
#        OS_LIBMODE_D -D OS_UART=-1 -D USE_16552_DRIVER_TASK=1 -D
#        USE_1281_RX_INT_TASK=1 -D USE_MODBUS_PROTOCOL=0 -D ANZBANA_V8=0 -D
#        __ATMEGA_1281__ -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Debug\List" -y
#        --no_cse --no_inline --no_code_motion --no_cross_call --no_clustering
#        --no_tbaa --debug -DENABLE_BIT_DEFINITIONS -e -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Debug\List\rtosinit.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Debug\Obj\rtosinit.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c
      1          /*********************************************************************
      2          *               SEGGER MICROCONTROLLER GmbH & Co KG                  *
      3          *       Solutions for real time microcontroller applications         *
      4          **********************************************************************
      5          *                                                                    *
      6          *       (c) 1995 - 2012  SEGGER Microcontroller GmbH & Co KG         *
      7          *                                                                    *
      8          *       www.segger.com     Support: support@segger.com               *
      9          *                                                                    *
     10          **********************************************************************
     11          *                                                                    *
     12          *       embOS * Real time operating system for microcontrollers      *
     13          *                                                                    *
     14          *                                                                    *
     15          *       Please note:                                                 *
     16          *                                                                    *
     17          *       Knowledge of this file may under no circumstances            *
     18          *       be used to write a similar product or a real-time            *
     19          *       operating system for in-house use.                           *
     20          *
     21          *                                                                    *       Thank you for your fairness !                                *
     22          *                                                                    *
     23          **********************************************************************
     24          *                                                                    *
     25          *       OS version: 3.86g                                            *
     26          *                                                                    *
     27          **********************************************************************
     28          
     29          ----------------------------------------------------------------------
     30          Licensing information
     31          Licensor:                 SEGGER Microcontroller GmbH
     32          Licensed to:              Scanjet Ariston AS, Moen  12, 3948  Porsgrunn, Norway
     33          Licensed SEGGER software: embOS
     34          License number:           OS-01417
     35          License model:            SOL [Single Developer Single Platform Object Code License]
     36          Licensed product:         -
     37          Licensed platform:        AtMega 128, IAR
     38          Licensed number of seats: 1
     39          ----------------------------------------------------------------------
     40          Support and Update Agreement (SUA)
     41          SUA period:               2022-12-21 - 2023-06-22
     42          Contact to extend SUA:    sales@segger.com
     43          ----------------------------------------------------------------------
     44          File    : RTOSInit_ATmega128.c for ATmega128 CPU and IAR compiler
     45          
     46          Purpose : Initializes and handles the hardware for embOS as far
     47                    as required by embOS
     48                    Feel free to modify this file acc. to your target system.
     49          --------  END-OF-HEADER  ---------------------------------------------
     50          */
     51          
     52          #include "RTOS.h"
     53          #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0x88
   \   union <unnamed> volatile __io _A_OCR1A
   \                     _A_OCR1A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x84
   \   union <unnamed> volatile __io _A_TCNT1
   \                     _A_TCNT1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x81
   \   union <unnamed> volatile __io _A_TCCR1B
   \                     _A_TCCR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x80
   \   union <unnamed> volatile __io _A_TCCR1A
   \                     _A_TCCR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6f
   \   union <unnamed> volatile __io _A_TIMSK1
   \                     _A_TIMSK1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x36
   \   union <unnamed> volatile __io _A_TIFR1
   \                     _A_TIFR1:
   \   00000000                      DS8 1
     54          #include "constants.h"
     55          #include "inavr.h"
     56          /*
     57          #if (((__TID__ >> 4) & 0x0F) == 1)
     58            #include "IO8535.H"
     59          #elif (((__TID__ >> 4) & 0x0F) == 3)
     60            #include "IOM603.H"
     61          #else
     62            #error "This CPU version (selected by -v) is not supported !"
     63          #endif
     64          */
     65          
     66          /*********************************************************************
     67          *
     68          *       Configuration
     69          *
     70          **********************************************************************
     71          */
     72          
     73          /*********************************************************************
     74          *
     75          *       Clock frequency settings
     76          */
     77          #ifndef   OS_FSYS                   /* CPU Main clock frequency     */
     78          #define OS_FSYS 16000000LuL        /* Assume 16 MHz            */
     79          #endif
     80          
     81          #ifndef   OS_PCLK_TIMER             /* Peripheral clock for timer   */
     82              #define OS_PCLK_TIMER (OS_FSYS)   /* May vary from CPU clock      */
     83          #endif                              /* depending on CPU             */
     84          
     85          #ifndef   OS_PCLK_UART              /* Peripheral clock for UART    */
     86              #define OS_PCLK_UART (OS_FSYS)    /* May vary from CPU clock      */
     87          #endif                              /* depending on CPU             */
     88          
     89          #ifndef   OS_TICK_FREQ
     90              #define OS_TICK_FREQ (1000)
     91          #endif
     92          
     93          /*********************************************************************
     94          *
     95          *       Configuration of communication to OSView
     96          */
     97          #ifndef   OS_VIEW_ENABLE            // Global enable of communication
     98              #define OS_VIEW_ENABLE    (1)     // Default: on
     99          #endif
    100          
    101          #ifndef   OS_VIEW_USE_UART          // If set, UART will be used for communication
    102              #define OS_VIEW_USE_UART  (1)     // Default: 1 => Uart is used
    103          #endif                              // if OS_VIEW_ENABLE is on
    104          
    105          /*********************************************************************
    106          *
    107          *       UART settings for OSView
    108          *       If you do not want (or can not due to hardware limitations)
    109          *       to dedicate a UART to OSView, please define it to be -1
    110          *       Currently UART1 is supported and the standard
    111          *       setup enables UART1 per default
    112          */
    113          #ifndef   OS_UART
    114              #define OS_UART (0)
    115          #endif
    116          
    117          #ifndef   OS_BAUDRATE
    118              #define OS_BAUDRATE (19200)
    119          #endif
    120          
    121          /****** End of configurable options *********************************/
    122          
    123          #define OS_UART_USED  ((OS_VIEW_ENABLE && (OS_VIEW_USE_UART != 0)) && ((OS_UART == 0)))
    124          
    125          #if OS_UART_USED
    126              #define OS_COM_INIT() OS_COM_Init()
    127          #else
    128              #define OS_COM_INIT()
    129          #endif
    130          
    131          #define OS_TIMER_RELOAD (OS_PCLK_TIMER / OS_TICK_FREQ)
    132          
    133          /*********************************************************************
    134          *
    135          *       Check configuration
    136          *
    137          **********************************************************************
    138          */
    139          
    140          #ifndef   DEBUG     /* Should normally be defined as project option */
    141              #define DEBUG  (0)
    142          #endif
    143          
    144          /*********************************************************************
    145          *
    146          *       Local defines (sfrs used in RTOSInit.c)
    147          *
    148          **********************************************************************
    149          */
    150          
    151          /*********************************************************************
    152          *
    153          *       Static data
    154          *
    155          **********************************************************************
    156          */
    157          
    158          /*********************************************************************
    159          *
    160          *       Local functions
    161          *
    162          **********************************************************************
    163          */
    164          
    165          /*********************************************************************
    166          *
    167          *       _ReadHWTimer()
    168          *
    169          */

   \                                 In  segment CODE, align 2, keep-with-next
    170          static int _ReadHWTimer(void) {
   \                     _ReadHWTimer:
    171              OS_U16 r = TCNT1L;
   \   00000000   9100....           LDS     R16, _A_TCNT1
   \   00000004   E010               LDI     R17, 0
    172              asm("nop");
   \   00000006   0000               nop
    173              return r | (TCNT1H << 8);
   \   00000008   91300085           LDS     R19, 133
   \   0000000C   E020               LDI     R18, 0
   \   0000000E   2B02               OR      R16, R18
   \   00000010   2B13               OR      R17, R19
   \   00000012   9508               RET
   \   00000014                      REQUIRE _A_TCNT1
    174          }
    175          
    176          /*********************************************************************
    177          *
    178          *       OS_ISR_Tick()
    179          *       The embOS timer tick interrupt Handler
    180          */
    181          static void OS_ISR_Tick_Handler(void);

   \                                 In  segment CODE, align 2, keep-with-next
    182          static void OS_ISR_Tick_Handler(void) {
   \                     OS_ISR_Tick_Handler:
    183              OS_TICK_Handle();
   \   00000000   ........           CALL    OS_TICK_Handle
    184          }
   \   00000004   9508               RET
    185          
    186          /*********************************************************************
    187          *
    188          *       OS_ISR_Tick()
    189          *       The embOS timer tick interrupt Handler
    190          */
    191          #pragma vector = TIMER1_COMPA_vect
    192          __interrupt void OS_ISR_Tick(void);
    193          #pragma vector = TIMER1_COMPA_vect

   \                                 In  segment CODE, align 2, keep-with-next
    194          __interrupt void OS_ISR_Tick(void) {
   \                     OS_ISR_Tick:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    195              OS_CallISR(OS_ISR_Tick_Handler);
   \   00000024   ....               LDI     R16, LOW(OS_ISR_Tick_Handler/2)
   \   00000026   ....               LDI     R17, (OS_ISR_Tick_Handler/2) >> 8
   \   00000028   ........           CALL    OS_CallISR_Debug
    196          }
   \   0000002C   BF9B               OUT     0x3B, R25
   \   0000002E   BF8F               OUT     0x3F, R24
   \   00000030   9109               LD      R16, Y+
   \   00000032   9119               LD      R17, Y+
   \   00000034   9129               LD      R18, Y+
   \   00000036   9139               LD      R19, Y+
   \   00000038   9149               LD      R20, Y+
   \   0000003A   9159               LD      R21, Y+
   \   0000003C   9169               LD      R22, Y+
   \   0000003E   9179               LD      R23, Y+
   \   00000040   9009               LD      R0, Y+
   \   00000042   9019               LD      R1, Y+
   \   00000044   9029               LD      R2, Y+
   \   00000046   9039               LD      R3, Y+
   \   00000048   91E9               LD      R30, Y+
   \   0000004A   91F9               LD      R31, Y+
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9518               RETI
    197          
    198          /*********************************************************************
    199          *
    200          *       Global functions
    201          *
    202          **********************************************************************
    203          */
    204          
    205          /*********************************************************************
    206          *
    207          *       OS_InitHW()
    208          *
    209          *       Initialize the hardware (timer) required for embOS to run.
    210          *       May be modified, if an other timer should be used
    211          */
    212          
    213          

   \                                 In  segment CODE, align 2, keep-with-next
    214          void OS_InitHW(void) {
   \                     OS_InitHW:
    215              TCCR1A_COM1A1 = 0;    // 0: No output
   \   00000000   91000080           LDS     R16, 128
   \   00000004   770F               ANDI    R16, 0x7F
   \   00000006   93000080           STS     128, R16
    216              TCCR1A_COM1A0 = 0;    // 0: No output
   \   0000000A   91000080           LDS     R16, 128
   \   0000000E   7B0F               ANDI    R16, 0xBF
   \   00000010   93000080           STS     128, R16
    217              TCCR1A_WGM11  = 0;    // 0: No PWM
   \   00000014   91000080           LDS     R16, 128
   \   00000018   7F0D               ANDI    R16, 0xFD
   \   0000001A   93000080           STS     128, R16
    218              TCCR1A_WGM10  = 0;    // 0: No PWM
   \   0000001E   91000080           LDS     R16, 128
   \   00000022   7F0E               ANDI    R16, 0xFE
   \   00000024   93000080           STS     128, R16
    219          
    220              TCCR1B_ICNC1  = 0;     // 0: Disable noise canceler
   \   00000028   91000081           LDS     R16, 129
   \   0000002C   770F               ANDI    R16, 0x7F
   \   0000002E   93000081           STS     129, R16
    221              TCCR1B_ICES1  = 0;     // 0: capturee edge
   \   00000032   91000081           LDS     R16, 129
   \   00000036   7B0F               ANDI    R16, 0xBF
   \   00000038   93000081           STS     129, R16
    222              TCCR1B_WGM12  = 1;     // 1: Reset on compare match
   \   0000003C   91000081           LDS     R16, 129
   \   00000040   6008               ORI     R16, 0x08
   \   00000042   93000081           STS     129, R16
    223              TCCR1B_CS12   = 0;     // Clock-Source: 001 = CK/1 no prescaler
   \   00000046   91000081           LDS     R16, 129
   \   0000004A   7F0B               ANDI    R16, 0xFB
   \   0000004C   93000081           STS     129, R16
    224              TCCR1B_CS11   = 0;     // Clock-Source: 010 = CK/8
   \   00000050   91000081           LDS     R16, 129
   \   00000054   7F0D               ANDI    R16, 0xFD
   \   00000056   93000081           STS     129, R16
    225              TCCR1B_CS10   = 1;     // Clock-Source: 001 = CK/1
   \   0000005A   91000081           LDS     R16, 129
   \   0000005E   6001               ORI     R16, 0x01
   \   00000060   93000081           STS     129, R16
    226                            
    227              OCR1A         = (OS_TIMER_RELOAD); // generate 1ms interrupts
   \   00000064   E800               LDI     R16, 128
   \   00000066   E31E               LDI     R17, 62
   \   00000068   9310....           STS     (_A_OCR1A + 1), R17
   \   0000006C   9300....           STS     _A_OCR1A, R16
    228              TIMSK1_OCIE1A = 1;      // Output CompareA Match Interrupt Enable
   \   00000070   9100006F           LDS     R16, 111
   \   00000074   6002               ORI     R16, 0x02
   \   00000076   9300006F           STS     111, R16
    229          
    230              /*
    231              TCCR1A=  (0<<6)       // 0: No output
    232                       |(0<<4)             // 0: No output
    233                       |(0<<0);            // No PWM
    234              TCCR1B=  (1<<7)       // 0: Disable noise canceler
    235                       |(0<<6)             // X: Capture edge
    236                       |(1<<3)             // 1: Reset on compare match
    237                       |(1<<0);            // 1: clock source CK/1
    238              OCR1A = (XTAL_CPU/1000)-1;         // generate 1ms interrupts
    239              TIMSK1 |= (1<<1);      // Output CompareA Match Interrupt Enable
    240              */
    241              //  SREG  = 0x80 ;        // global interrupt
    242              OS_COM_INIT();        // Initialize communication to embOSView
    243          }
   \   0000007A   9508               RET
   \   0000007C                      REQUIRE _A_TCCR1A
   \   0000007C                      REQUIRE _A_TCCR1B
   \   0000007C                      REQUIRE _A_OCR1A
   \   0000007C                      REQUIRE _A_TIMSK1
    244          
    245          /*********************************************************************
    246          *
    247          *       OS_Idle()
    248          *
    249          *       Please note:
    250          *       This is basically the "core" of the idle loop.
    251          *       This core loop can be changed, but:
    252          *       The idle loop does not have a stack of its own, therefore no
    253          *       functionality should be implemented that relies on the stack
    254          *       to be preserved. However, a simple program loop can be programmed
    255          *       (like toggeling an output or incrementing a counter)
    256          */

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    257          static OS_I32 WatchDogTime = 0;
   \                     WatchDogTime:
   \   00000000                      DS8 4

   \                                 In  segment CODE, align 2, keep-with-next
    258          void OS_Idle(void) {          // Idle loop: No task is ready to execute
   \                     OS_Idle:
    259              while (1) {           // Nothing to do ... wait for interrupt
    260                  if ( OS_Time > WatchDogTime) {
   \                     ??OS_Idle_0:
   \   00000000   ....               LDI     R30, LOW(WatchDogTime)
   \   00000002   ....               LDI     R31, (WatchDogTime) >> 8
   \   00000004   8100               LD      R16, Z
   \   00000006   8111               LDD     R17, Z+1
   \   00000008   8122               LDD     R18, Z+2
   \   0000000A   8133               LDD     R19, Z+3
   \   0000000C   ....               LDI     R30, LOW(OS_Global)
   \   0000000E   ....               LDI     R31, (OS_Global) >> 8
   \   00000010   8942               LDD     R20, Z+18
   \   00000012   8953               LDD     R21, Z+19
   \   00000014   8964               LDD     R22, Z+20
   \   00000016   8975               LDD     R23, Z+21
   \   00000018   1704               CP      R16, R20
   \   0000001A   0715               CPC     R17, R21
   \   0000001C   0726               CPC     R18, R22
   \   0000001E   0737               CPC     R19, R23
   \   00000020   F77C               BRGE    ??OS_Idle_0
    261                      WatchDogTime = OS_Time + 500;
   \   00000022   ....               LDI     R30, LOW(OS_Global)
   \   00000024   ....               LDI     R31, (OS_Global) >> 8
   \   00000026   8902               LDD     R16, Z+18
   \   00000028   8913               LDD     R17, Z+19
   \   0000002A   8924               LDD     R18, Z+20
   \   0000002C   8935               LDD     R19, Z+21
   \   0000002E   500C               SUBI    R16, 12
   \   00000030   4F1E               SBCI    R17, 254
   \   00000032   4F2F               SBCI    R18, 255
   \   00000034   4F3F               SBCI    R19, 255
   \   00000036   ....               LDI     R30, LOW(WatchDogTime)
   \   00000038   ....               LDI     R31, (WatchDogTime) >> 8
   \   0000003A   8300               ST      Z, R16
   \   0000003C   8311               STD     Z+1, R17
   \   0000003E   8322               STD     Z+2, R18
   \   00000040   8333               STD     Z+3, R19
    262                      __watchdog_reset();               //kick the dog
   \   00000042   95A8               WDR
   \   00000044   CFDD               RJMP    ??OS_Idle_0
    263                  }
    264          #if (DEBUG == 0)
    265                  // Switch CPU into sleep mode
    266          #endif
    267              }
    268          }
    269          
    270          /*********************************************************************
    271          *
    272          *       OS_GetTime_Cycles()
    273          *
    274          *       This routine is required for task-info via OSView or high
    275          *       resolution time measurement functions.
    276          *       It returns the system time in timer clock cycles.
    277          */

   \                                 In  segment CODE, align 2, keep-with-next
    278          OS_U32 OS_GetTime_Cycles(void) {
   \                     OS_GetTime_Cycles:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    279              OS_U32 Time;
    280              OS_U32 Cnt;
    281          
    282              Time = OS_Time;
   \   00000004   ....               LDI     R30, LOW(OS_Global)
   \   00000006   ....               LDI     R31, (OS_Global) >> 8
   \   00000008   8902               LDD     R16, Z+18
   \   0000000A   8913               LDD     R17, Z+19
   \   0000000C   8924               LDD     R18, Z+20
   \   0000000E   8935               LDD     R19, Z+21
   \   00000010   01A8               MOVW    R21:R20, R17:R16
   \   00000012   01B9               MOVW    R23:R22, R19:R18
    283              Cnt  = _ReadHWTimer();
   \   00000014   ....               RCALL   _ReadHWTimer
   \   00000016   2F21               MOV     R18, R17
   \   00000018   0F22               LSL     R18
   \   0000001A   0B22               SBC     R18, R18
   \   0000001C   2F32               MOV     R19, R18
   \   0000001E   01C8               MOVW    R25:R24, R17:R16
   \   00000020   01D9               MOVW    R27:R26, R19:R18
    284              //
    285              // Check if timer interrupt pending ...
    286              //
    287              if (TIFR1 & (1 << 4)) {  // Check if timer interrupt pending ...
   \   00000022   9BB4               SBIS    0x16, 0x04
   \   00000024   C00B               RJMP    ??OS_GetTime_Cycles_0
    288                  Cnt = _ReadHWTimer();
   \   00000026   ....               RCALL   _ReadHWTimer
   \   00000028   2F21               MOV     R18, R17
   \   0000002A   0F22               LSL     R18
   \   0000002C   0B22               SBC     R18, R18
   \   0000002E   2F32               MOV     R19, R18
   \   00000030   01C8               MOVW    R25:R24, R17:R16
   \   00000032   01D9               MOVW    R27:R26, R19:R18
    289                  Time++;
   \   00000034   5F4F               SUBI    R20, 255
   \   00000036   4F5F               SBCI    R21, 255
   \   00000038   4F6F               SBCI    R22, 255
   \   0000003A   4F7F               SBCI    R23, 255
    290              }
    291              return (OS_TIMER_RELOAD * Time) + Cnt;
   \                     ??OS_GetTime_Cycles_0:
   \   0000003C   E800               LDI     R16, 128
   \   0000003E   E31E               LDI     R17, 62
   \   00000040   E020               LDI     R18, 0
   \   00000042   E030               LDI     R19, 0
   \   00000044   ........           CALL    ?L_EC_MUL_L03
   \   00000048   0F08               ADD     R16, R24
   \   0000004A   1F19               ADC     R17, R25
   \   0000004C   1F2A               ADC     R18, R26
   \   0000004E   1F3B               ADC     R19, R27
   \   00000050   E0E4               LDI     R30, 4
   \   00000052   ........           JMP     ?EPILOGUE_B4_L09
   \   00000056                      REQUIRE _A_TIFR1
    292          }
    293          
    294          /*********************************************************************
    295          *
    296          *       OS_ConvertCycles2us()
    297          *
    298          *       Convert Cycles into micro seconds.
    299          *
    300          *       If your clock frequency is not a multiple of 1 MHz,
    301          *       you may have to modify this routine in order to get proper
    302          *       diagnostics.
    303          *
    304          *       This routine is required for profiling or high resolution time
    305          *       measurement only.
    306             It does not affect operation of the OS.
    307          */
    308          

   \                                 In  segment CODE, align 2, keep-with-next
    309          OS_U32 OS_ConvertCycles2us(OS_U32 Cycles) {
   \                     OS_ConvertCycles2us:
    310              return Cycles / (OS_PCLK_TIMER / 1000000);
   \   00000000   E044               LDI     R20, 4
   \   00000002   ........           CALL    ?UL_SHR_L03
   \   00000006   9508               RET
    311          }
    312          
    313          /*********************************************************************
    314          *
    315          *       Optional communication with embOSView
    316          *
    317          **********************************************************************
    318          */
    319          #if OS_UART_USED
    320              #define OS_BAUDDIVIDE ((OS_FSYS+OS_BAUDRATE*8L)/(OS_BAUDRATE*16L)-1)
    321          
    322          /*********************************************************************
    323          *
    324          *       OS_COM_Init()
    325          */
    326          void OS_COM_Init(void) {
    327              UBRR0H  = OS_BAUDDIVIDE >> 8;
    328              UBRR0L = OS_BAUDDIVIDE;
    329              UCSR0B =  (0 << 0)      // X
    330                  | (0 << 1)      // X
    331                  | (0 << 2)      // CHR9: 9-bit Characters
    332                  | (1 << 3)      // TXEN: Transmitter Enable
    333                  | (1 << 4)      // RXEN: Receiver Enable
    334                  | (0 << 5)      // UDRIE: UART Data Register Empty Interrupt Enable
    335                  | (0 << 6)      // TXCIE Tx complete interrupt enable
    336                  | (0 << 7);     // RXCIE Rx complete interrupt enable
    337              UCSR0B =  (0 << 0)      // X
    338                  | (0 << 1)      // X
    339                  | (0 << 2)      // CHR9: 9-bit Characters
    340                  | (1 << 3)      // TXEN: Transmitter Enable
    341                  | (1 << 4)      // RXEN: Receiver Enable
    342                  | (1 << 5)      // UDRIE: UART Data Register Empty Interrupt Enable
    343                  | (0 << 6)      // TXCIE Tx complete interrupt enable
    344                  | (1 << 7);     // RXCIE Rx complete interrupt enable
    345          }
    346          
    347          /*********************************************************************
    348          *
    349          *       OS_COM_Send1()
    350          *       Send one character via UART.
    351          *       Never call this function from your application
    352          */
    353          void OS_COM_Send1(unsigned char c) {
    354              UDR0 = c;
    355              UCSR0B |=  (1 << 5);      // Generate interrupt on transmit buffer emtpy
    356          }
    357          
    358          /*********************************************************************
    359          *
    360          *       OS_ISR_rx_Handler()
    361          *       embOS UART rx interrupt handler
    362          */
    363          void OS_ISR_rx_Handler(void);
    364          void OS_ISR_rx_Handler(void) {
    365              UCSR0B &=  ~(1 << 7);     // Avoid nesting itself !!!
    366              OS_OnRx(UDR0);
    367              OS_DI();             // Disable before allowing Rx interrupt
    368              UCSR0B |=  (1 << 7);
    369          }
    370          
    371          /*********************************************************************
    372          *
    373          *       OS_ISR_rx()
    374          *       embOS UART rx interrupt handler
    375          */
    376              #pragma vector = USART0_RXC_vect
    377          __interrupt void OS_ISR_rx(void);
    378              #pragma vector = USART0_RXC_vect
    379          __interrupt void OS_ISR_rx(void) {
    380              OS_CallISR(OS_ISR_rx_Handler);
    381          }
    382          
    383          /*********************************************************************
    384          *
    385          *       OS_ISR_tx_Handler()
    386          *       embOS UART tx interrupt handler
    387          */
    388          void OS_ISR_tx_Handler(void);
    389          void OS_ISR_tx_Handler(void) {
    390              UCSR0B &=  ~(1 << 5);   // Do not generate any more interrupts
    391              if (OS_OnTx() == 0) {
    392                  OS_DI();             // Disable before allowing Tx interrupt
    393                  UCSR0B |=  (1 << 5);   // Re-enable Tx interrupts
    394              }
    395          }
    396          
    397          /*********************************************************************
    398          *
    399          *       OS_ISR_tx()
    400          *       embOS UART tx interrupt handler
    401          */
    402              #pragma vector = USART0_UDRE_vect
    403          __interrupt void OS_ISR_tx(void);
    404              #pragma vector = USART0_UDRE_vect
    405          __interrupt void OS_ISR_tx(void) {
    406              OS_CallISR(OS_ISR_tx_Handler);
    407          }
    408          
    409          #else  /* UART for communication not used, define dummy functions */
    410          

   \                                 In  segment CODE, align 2, keep-with-next
    411          void OS_COM_Send1(OS_U8 c) {
   \                     OS_COM_Send1:
   \   00000000   938A               ST      -Y, R24
   \   00000002   2F80               MOV     R24, R16
    412              OS_USEPARA(c);           /* Avoid compiler warning */
    413              OS_COM_ClearTxActive();    /* Let the OS know that Tx is not busy */
   \   00000004   ........           CALL    OS_COM_ClearTxActive
    414          }
   \   00000008   9189               LD      R24, Y+
   \   0000000A   9508               RET

   \                                 In  segment INTVEC, offset 0x44, root
   \                     `??OS_ISR_Tick::??INTVEC 68`:
   \   00000044   ........           JMP     OS_ISR_Tick
    415          #endif
    416          
    417          /****** End Of File *************************************************/

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      1      2   OS_COM_Send1
        1      2   -> OS_COM_ClearTxActive
      0      2   OS_ConvertCycles2us
        0      2 ?UL_SHR_L03
      4      2   OS_GetTime_Cycles
        4      2   -> _ReadHWTimer
        4      2 ?L_EC_MUL_L03
     16      2   OS_ISR_Tick
       16      2   -> OS_CallISR_Debug
      0      2   OS_ISR_Tick_Handler
        0      2   -> OS_TICK_Handle
      0      2   OS_Idle
      0      2   OS_InitHW
      0      2   _ReadHWTimer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      12  OS_COM_Send1
       8  OS_ConvertCycles2us
      86  OS_GetTime_Cycles
      82  OS_ISR_Tick
       4  OS_ISR_Tick::??INTVEC 68
       6  OS_ISR_Tick_Handler
      70  OS_Idle
     124  OS_InitHW
       4  WatchDogTime
       2  _A_OCR1A
       1  _A_TCCR1A
       1  _A_TCCR1B
       2  _A_TCNT1
       1  _A_TIFR1
       1  _A_TIMSK1
      20  _ReadHWTimer
       7  -- Other

 
   8 bytes in segment ABSOLUTE
 408 bytes in segment CODE
   7 bytes in segment INITTAB
   4 bytes in segment INTVEC
   4 bytes in segment NEAR_Z
 
 408 bytes of CODE memory (+ 11 bytes shared)
   4 bytes of DATA memory (+  8 bytes shared)

Errors: none
Warnings: none
