###############################################################################
#
# IAR C/C++ Compiler V8.10.1.1784/W64 for Microchip AVR   02/May/2023  12:40:43
# Copyright 1996-2023 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file           =  D:\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c
#    Command line          =
#        -f D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj\embOS\rtosinit.r90.rsp
#        (D:\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c --cpu=m1281 -ms -o
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj\embOS -D OS_LIBMODE_S -D
#        OS_UART=-1 -D USE_16552_DRIVER_TASK=1 -lCN
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\List\embOS -y
#        --initializers_in_flash --no_tbaa --enable_external_bus
#        -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\ANZB_ATmega1281\INC\ -I
#        D:\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\ --eeprom_size 4096
#        --clib -Oh) --dependencies=n
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj\embOS\rtosinit.r90.iar_deps
#    Locale                =  C
#    List file             =
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\List\embOS\rtosinit.lst
#    Object file           =
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj\embOS\rtosinit.r90
#    Runtime model:           
#      __64bit_doubles     =  disabled
#      __SystemLibrary     =  CLib
#      __architecture      =  *
#      __cpu               =  3
#      __cpu_name          =  ATmega1281
#      __dlib_version      =  clib
#      __enhanced_core     =  enabled
#      __enhanced_core_mul =  enabled
#      __has_elpm          =  true
#      __memory_model      =  2
#      __mex               =  disabled
#      __no_rampd          =  enabled
#      __rt_version        =  3
#      __vtable_memory     =  __nearflash
#
###############################################################################

D:\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c
      1          /*********************************************************************
      2          *               SEGGER MICROCONTROLLER GmbH & Co KG                  *
      3          *       Solutions for real time microcontroller applications         *
      4          **********************************************************************
      5          *                                                                    *
      6          *       (c) 1995 - 2012  SEGGER Microcontroller GmbH & Co KG         *
      7          *                                                                    *
      8          *       www.segger.com     Support: support@segger.com               *
      9          *                                                                    *
     10          **********************************************************************
     11          *                                                                    *
     12          *       embOS * Real time operating system for microcontrollers      *
     13          *                                                                    *
     14          *                                                                    *
     15          *       Please note:                                                 *
     16          *                                                                    *
     17          *       Knowledge of this file may under no circumstances            *
     18          *       be used to write a similar product or a real-time            *
     19          *       operating system for in-house use.                           *
     20          *
     21          *                                                                    *       Thank you for your fairness !                                *
     22          *                                                                    *
     23          **********************************************************************
     24          *                                                                    *
     25          *       OS version: 3.86g                                            *
     26          *                                                                    *
     27          **********************************************************************
     28          
     29          ----------------------------------------------------------------------
     30          Licensing information
     31          Licensor:                 SEGGER Microcontroller GmbH
     32          Licensed to:              Scanjet Ariston AS, Moen  12, 3948  Porsgrunn, Norway
     33          Licensed SEGGER software: embOS
     34          License number:           OS-01417
     35          License model:            SOL [Single Developer Single Platform Object Code License]
     36          Licensed product:         -
     37          Licensed platform:        AtMega 128, IAR
     38          Licensed number of seats: 1
     39          ----------------------------------------------------------------------
     40          Support and Update Agreement (SUA)
     41          SUA period:               2022-12-21 - 2023-06-22
     42          Contact to extend SUA:    sales@segger.com
     43          ----------------------------------------------------------------------
     44          File    : RTOSInit_ATmega128.c for ATmega128 CPU and IAR compiler
     45          
     46          Purpose : Initializes and handles the hardware for embOS as far
     47                    as required by embOS
     48                    Feel free to modify this file acc. to your target system.
     49          --------  END-OF-HEADER  ---------------------------------------------
     50          */
     51          
     52          #include "RTOS.h"
     53          #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0x88
   \   __no_init union <unnamed>#213 volatile __io _A_OCR1A
   \                     _A_OCR1A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x84
   \   __no_init union <unnamed>#225 volatile __io _A_TCNT1
   \                     _A_TCNT1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x81
   \   __no_init union <unnamed>#234 volatile __io _A_TCCR1B
   \                     _A_TCCR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x80
   \   __no_init union <unnamed>#237 volatile __io _A_TCCR1A
   \                     _A_TCCR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6f
   \   __no_init union <unnamed>#282 volatile __io _A_TIMSK1
   \                     _A_TIMSK1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x36
   \   __no_init union <unnamed>#421 volatile __io _A_TIFR1
   \                     _A_TIFR1:
   \   00000000                      DS8 1
     54          #include "constants.h"
     55          /*
     56          #if (((__TID__ >> 4) & 0x0F) == 1)
     57            #include "IO8535.H"
     58          #elif (((__TID__ >> 4) & 0x0F) == 3)
     59            #include "IOM603.H"
     60          #else
     61            #error "This CPU version (selected by -v) is not supported !"
     62          #endif
     63          */
     64          
     65          /*********************************************************************
     66          *
     67          *       Configuration
     68          *
     69          **********************************************************************
     70          */
     71          
     72          /*********************************************************************
     73          *
     74          *       Clock frequency settings
     75          */
     76          #ifndef   OS_FSYS                   /* CPU Main clock frequency     */
     77          #define OS_FSYS 7372800LuL        /* Assume 7.3728 MHz            */
     78          #endif
     79          
     80          #ifndef   OS_PCLK_TIMER             /* Peripheral clock for timer   */
     81              #define OS_PCLK_TIMER (OS_FSYS)   /* May vary from CPU clock      */
     82          #endif                              /* depending on CPU             */
     83          
     84          #ifndef   OS_PCLK_UART              /* Peripheral clock for UART    */
     85              #define OS_PCLK_UART (OS_FSYS)    /* May vary from CPU clock      */
     86          #endif                              /* depending on CPU             */
     87          
     88          #ifndef   OS_TICK_FREQ
     89              #define OS_TICK_FREQ (1000)
     90          #endif
     91          
     92          /*********************************************************************
     93          *
     94          *       Configuration of communication to OSView
     95          */
     96          #ifndef   OS_VIEW_ENABLE            // Global enable of communication
     97              #define OS_VIEW_ENABLE    (1)     // Default: on
     98          #endif
     99          
    100          #ifndef   OS_VIEW_USE_UART          // If set, UART will be used for communication
    101              #define OS_VIEW_USE_UART  (1)     // Default: 1 => Uart is used
    102          #endif                              // if OS_VIEW_ENABLE is on
    103          
    104          /*********************************************************************
    105          *
    106          *       UART settings for OSView
    107          *       If you do not want (or can not due to hardware limitations)
    108          *       to dedicate a UART to OSView, please define it to be -1
    109          *       Currently UART1 is supported and the standard
    110          *       setup enables UART1 per default
    111          */
    112          #ifndef   OS_UART
    113              #define OS_UART (0)
    114          #endif
    115          
    116          #ifndef   OS_BAUDRATE
    117              #define OS_BAUDRATE (19200)
    118          #endif
    119          
    120          /****** End of configurable options *********************************/
    121          
    122          #define OS_UART_USED  ((OS_VIEW_ENABLE && (OS_VIEW_USE_UART != 0)) && ((OS_UART == 0)))
    123          
    124          #if OS_UART_USED
    125              #define OS_COM_INIT() OS_COM_Init()
    126          #else
    127              #define OS_COM_INIT()
    128          #endif
    129          
    130          #define OS_TIMER_RELOAD (OS_PCLK_TIMER / OS_TICK_FREQ)
    131          
    132          /*********************************************************************
    133          *
    134          *       Check configuration
    135          *
    136          **********************************************************************
    137          */
    138          
    139          #ifndef   DEBUG     /* Should normally be defined as project option */
    140              #define DEBUG  (0)
    141          #endif
    142          
    143          /*********************************************************************
    144          *
    145          *       Local defines (sfrs used in RTOSInit.c)
    146          *
    147          **********************************************************************
    148          */
    149          
    150          /*********************************************************************
    151          *
    152          *       Static data
    153          *
    154          **********************************************************************
    155          */
    156          
    157          /*********************************************************************
    158          *
    159          *       Local functions
    160          *
    161          **********************************************************************
    162          */
    163          
    164          /*********************************************************************
    165          *
    166          *       _ReadHWTimer()
    167          *
    168          */

   \                                 In  segment CODE, align 2, keep-with-next
    169          static int _ReadHWTimer(void) {
   \                     _ReadHWTimer:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    170              OS_U16 r = TCNT1L;
   \   00000000   91000084           LDS     R16, 132
    171              asm("nop");
   \   00000004   0000               nop
    172              return r | (TCNT1H << 8);
   \   00000006   91100085           LDS     R17, 133
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_TCNT1
    173          }
    174          
    175          /*********************************************************************
    176          *
    177          *       OS_ISR_Tick()
    178          *       The embOS timer tick interrupt Handler
    179          */
    180          static void OS_ISR_Tick_Handler(void);

   \                                 In  segment CODE, align 2, keep-with-next
    181          static void OS_ISR_Tick_Handler(void) {
   \                     OS_ISR_Tick_Handler:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    182              OS_TICK_Handle();
   \   00000000   ........           JMP     OS_TICK_Handle
    183          }
    184          
    185          /*********************************************************************
    186          *
    187          *       OS_ISR_Tick()
    188          *       The embOS timer tick interrupt Handler
    189          */
    190          #pragma vector = TIMER1_COMPA_vect
    191          __interrupt void OS_ISR_Tick(void);
    192          #pragma vector = TIMER1_COMPA_vect

   \                                 In  segment CODE, align 2, keep-with-next
    193          __interrupt void OS_ISR_Tick(void) {
   \                     OS_ISR_Tick:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
   \   00000024                      REQUIRE __RSTACK_in_external_ram_new_way
    194              OS_CallISR(OS_ISR_Tick_Handler);
   \   00000024   ....               LDI     R16, LOW(OS_ISR_Tick_Handler/2)
   \   00000026   ....               LDI     R17, (OS_ISR_Tick_Handler/2) >> 8
   \   00000028   ........           CALL    OS_CallISR
    195          }
   \   0000002C   BF9B               OUT     0x3B, R25
   \   0000002E   BF8F               OUT     0x3F, R24
   \   00000030   9109               LD      R16, Y+
   \   00000032   9119               LD      R17, Y+
   \   00000034   9129               LD      R18, Y+
   \   00000036   9139               LD      R19, Y+
   \   00000038   9149               LD      R20, Y+
   \   0000003A   9159               LD      R21, Y+
   \   0000003C   9169               LD      R22, Y+
   \   0000003E   9179               LD      R23, Y+
   \   00000040   9009               LD      R0, Y+
   \   00000042   9019               LD      R1, Y+
   \   00000044   9029               LD      R2, Y+
   \   00000046   9039               LD      R3, Y+
   \   00000048   91E9               LD      R30, Y+
   \   0000004A   91F9               LD      R31, Y+
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9518               RETI
    196          
    197          /*********************************************************************
    198          *
    199          *       Global functions
    200          *
    201          **********************************************************************
    202          */
    203          
    204          /*********************************************************************
    205          *
    206          *       OS_InitHW()
    207          *
    208          *       Initialize the hardware (timer) required for embOS to run.
    209          *       May be modified, if an other timer should be used
    210          */
    211          
    212          

   \                                 In  segment CODE, align 2, keep-with-next
    213          void OS_InitHW(void) {
   \                     OS_InitHW:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    214              TCCR1A = 0x00;            // No output, no PWM
   \   00000000   E000               LDI     R16, 0
   \   00000002   93000080           STS     128, R16
    215              TCCR1B = 0x09;              // Disable noise canceler, capture edge, Reset on compare match, clock source CK/1
   \   00000006   E009               LDI     R16, 9
   \   00000008   93000081           STS     129, R16
    216              OCR1A = (OS_TIMER_RELOAD);         // Generate 1 msec interrupts
   \   0000000C   E10C               LDI     R16, 28
   \   0000000E   93000089           STS     (136 + 1), R16
   \   00000012   EC0C               LDI     R16, 204
   \   00000014   93000088           STS     136, R16
    217              TIMSK1 |= (1uL << 4);      // Output CompareA Match Interrupt Enable
   \   00000018   9100006F           LDS     R16, 111
   \   0000001C   6100               ORI     R16, 0x10
   \   0000001E   9300006F           STS     111, R16
    218              OS_COM_INIT();        // Initialize communication to embOSView
    219          }
   \   00000022   9508               RET
   \   00000024                      REQUIRE _A_TCCR1A
   \   00000024                      REQUIRE _A_TCCR1B
   \   00000024                      REQUIRE _A_OCR1A
   \   00000024                      REQUIRE _A_TIMSK1
    220          
    221          /*********************************************************************
    222          *
    223          *       OS_Idle()
    224          *
    225          *       Please note:
    226          *       This is basically the "core" of the idle loop.
    227          *       This core loop can be changed, but:
    228          *       The idle loop does not have a stack of its own, therefore no
    229          *       functionality should be implemented that relies on the stack
    230          *       to be preserved. However, a simple program loop can be programmed
    231          *       (like toggeling an output or incrementing a counter)
    232          */
    233          

   \                                 In  segment CODE, align 2, keep-with-next
    234          void OS_Idle(void) {          // Idle loop: No task is ready to execute
   \                     OS_Idle:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    235              while (1) {           // Nothing to do ... wait for interrupt
   \                     ??OS_Idle_0:
   \   00000000   CFFF               RJMP    ??OS_Idle_0
    236          #if (DEBUG == 0)
    237                  // Switch CPU into sleep mode
    238          #endif
    239              }
    240          }
    241          
    242          /*********************************************************************
    243          *
    244          *       OS_GetTime_Cycles()
    245          *
    246          *       This routine is required for task-info via OSView or high
    247          *       resolution time measurement functions.
    248          *       It returns the system time in timer clock cycles.
    249          */

   \                                 In  segment CODE, align 2, keep-with-next
    250          OS_U32 OS_GetTime_Cycles(void) {
   \                     OS_GetTime_Cycles:
   \   00000000   01FD               MOVW    R31:R30, R27:R26
   \   00000002   011C               MOVW    R3:R2, R25:R24
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
    251              OS_U32 Time;
    252              OS_U32 Cnt;
    253          
    254              Time = OS_Time;
   \   00000004   9140....           LDS     R20, (OS_Global + 18)
   \   00000008   9150....           LDS     R21, (OS_Global + 19)
   \   0000000C   9160....           LDS     R22, (OS_Global + 20)
   \   00000010   9170....           LDS     R23, (OS_Global + 21)
    255              Cnt  = _ReadHWTimer();
   \   00000014   ....               RCALL   _ReadHWTimer
   \   00000016   01C8               MOVW    R25:R24, R17:R16
   \   00000018   0F11               LSL     R17
   \   0000001A   2FA1               MOV     R26, R17
   \   0000001C   0BAA               SBC     R26, R26
   \   0000001E   2FBA               MOV     R27, R26
    256              //
    257              // Check if timer interrupt pending ...
    258              //
    259              if (TIFR1 & (1 << 4)) {  // Check if timer interrupt pending ...
   \   00000020   9BB4               SBIS    0x16, 0x04
   \   00000022   C00A               RJMP    ??OS_GetTime_Cycles_0
    260                  Cnt = _ReadHWTimer();
   \   00000024   ....               RCALL   _ReadHWTimer
   \   00000026   01C8               MOVW    R25:R24, R17:R16
   \   00000028   0F11               LSL     R17
   \   0000002A   2FA1               MOV     R26, R17
   \   0000002C   0BAA               SBC     R26, R26
   \   0000002E   2FBA               MOV     R27, R26
    261                  Time++;
   \   00000030   5F4F               SUBI    R20, 255
   \   00000032   4F5F               SBCI    R21, 255
   \   00000034   4F6F               SBCI    R22, 255
   \   00000036   4F7F               SBCI    R23, 255
    262              }
    263              return (OS_TIMER_RELOAD * Time) + Cnt;
   \                     ??OS_GetTime_Cycles_0:
   \   00000038   EC0C               LDI     R16, 204
   \   0000003A   E11C               LDI     R17, 28
   \   0000003C   E020               LDI     R18, 0
   \   0000003E   9F70               MUL     R23, R16
   \   00000040   2D70               MOV     R23, R0
   \   00000042   9F61               MUL     R22, R17
   \   00000044   0D70               ADD     R23, R0
   \   00000046   9F60               MUL     R22, R16
   \   00000048   2D60               MOV     R22, R0
   \   0000004A   0D71               ADD     R23, R1
   \   0000004C   9F51               MUL     R21, R17
   \   0000004E   0D60               ADD     R22, R0
   \   00000050   1D71               ADC     R23, R1
   \   00000052   9F50               MUL     R21, R16
   \   00000054   2D50               MOV     R21, R0
   \   00000056   0D61               ADD     R22, R1
   \   00000058   1F72               ADC     R23, R18
   \   0000005A   9F41               MUL     R20, R17
   \   0000005C   0D50               ADD     R21, R0
   \   0000005E   1D61               ADC     R22, R1
   \   00000060   1F72               ADC     R23, R18
   \   00000062   9F40               MUL     R20, R16
   \   00000064   0D51               ADD     R21, R1
   \   00000066   1F62               ADC     R22, R18
   \   00000068   1F72               ADC     R23, R18
   \   0000006A   0E08               ADD     R0, R24
   \   0000006C   2D40               MOV     R20, R0
   \   0000006E   1F59               ADC     R21, R25
   \   00000070   1F6A               ADC     R22, R26
   \   00000072   1F7B               ADC     R23, R27
   \   00000074   018A               MOVW    R17:R16, R21:R20
   \   00000076   019B               MOVW    R19:R18, R23:R22
   \   00000078   01C1               MOVW    R25:R24, R3:R2
   \   0000007A   01DF               MOVW    R27:R26, R31:R30
   \   0000007C   9508               RET
   \   0000007E                      REQUIRE _A_TIFR1
    264          }
    265          
    266          /*********************************************************************
    267          *
    268          *       OS_ConvertCycles2us()
    269          *
    270          *       Convert Cycles into micro seconds.
    271          *
    272          *       If your clock frequency is not a multiple of 1 MHz,
    273          *       you may have to modify this routine in order to get proper
    274          *       diagnostics.
    275          *
    276          *       This routine is required for profiling or high resolution time
    277          *       measurement only.
    278             It does not affect operation of the OS.
    279          */
    280          

   \                                 In  segment CODE, align 2, keep-with-next
    281          OS_U32 OS_ConvertCycles2us(OS_U32 Cycles) {
   \                     OS_ConvertCycles2us:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    282              return Cycles / (OS_PCLK_TIMER / 1000000);
   \   00000000   E047               LDI     R20, 7
   \   00000002   E050               LDI     R21, 0
   \   00000004   E060               LDI     R22, 0
   \   00000006   E070               LDI     R23, 0
   \   00000008   ........           JMP     ?UL_DIVMOD_S_L03
    283          }
    284          
    285          /*********************************************************************
    286          *
    287          *       Optional communication with embOSView
    288          *
    289          **********************************************************************
    290          */
    291          #if OS_UART_USED
    292              #define OS_BAUDDIVIDE ((OS_FSYS+OS_BAUDRATE*8L)/(OS_BAUDRATE*16L)-1)
    293          
    294          /*********************************************************************
    295          *
    296          *       OS_COM_Init()
    297          */
    298          void OS_COM_Init(void) {
    299              UBRR0H  = OS_BAUDDIVIDE >> 8;
    300              UBRR0L = OS_BAUDDIVIDE;
    301              UCSR0B =  (0 << 0)      // X
    302                  | (0 << 1)      // X
    303                  | (0 << 2)      // CHR9: 9-bit Characters
    304                  | (1 << 3)      // TXEN: Transmitter Enable
    305                  | (1 << 4)      // RXEN: Receiver Enable
    306                  | (0 << 5)      // UDRIE: UART Data Register Empty Interrupt Enable
    307                  | (0 << 6)      // TXCIE Tx complete interrupt enable
    308                  | (0 << 7);     // RXCIE Rx complete interrupt enable
    309              UCSR0B =  (0 << 0)      // X
    310                  | (0 << 1)      // X
    311                  | (0 << 2)      // CHR9: 9-bit Characters
    312                  | (1 << 3)      // TXEN: Transmitter Enable
    313                  | (1 << 4)      // RXEN: Receiver Enable
    314                  | (1 << 5)      // UDRIE: UART Data Register Empty Interrupt Enable
    315                  | (0 << 6)      // TXCIE Tx complete interrupt enable
    316                  | (1 << 7);     // RXCIE Rx complete interrupt enable
    317          }
    318          
    319          /*********************************************************************
    320          *
    321          *       OS_COM_Send1()
    322          *       Send one character via UART.
    323          *       Never call this function from your application
    324          */
    325          void OS_COM_Send1(unsigned char c) {
    326              UDR0 = c;
    327              UCSR0B |=  (1 << 5);      // Generate interrupt on transmit buffer emtpy
    328          }
    329          
    330          /*********************************************************************
    331          *
    332          *       OS_ISR_rx_Handler()
    333          *       embOS UART rx interrupt handler
    334          */
    335          void OS_ISR_rx_Handler(void);
    336          void OS_ISR_rx_Handler(void) {
    337              UCSR0B &=  ~(1 << 7);     // Avoid nesting itself !!!
    338              OS_OnRx(UDR0);
    339              OS_DI();             // Disable before allowing Rx interrupt
    340              UCSR0B |=  (1 << 7);
    341          }
    342          
    343          /*********************************************************************
    344          *
    345          *       OS_ISR_rx()
    346          *       embOS UART rx interrupt handler
    347          */
    348              #pragma vector = USART0_RXC_vect
    349          __interrupt void OS_ISR_rx(void);
    350              #pragma vector = USART0_RXC_vect
    351          __interrupt void OS_ISR_rx(void) {
    352              OS_CallISR(OS_ISR_rx_Handler);
    353          }
    354          
    355          /*********************************************************************
    356          *
    357          *       OS_ISR_tx_Handler()
    358          *       embOS UART tx interrupt handler
    359          */
    360          void OS_ISR_tx_Handler(void);
    361          void OS_ISR_tx_Handler(void) {
    362              UCSR0B &=  ~(1 << 5);   // Do not generate any more interrupts
    363              if (OS_OnTx() == 0) {
    364                  OS_DI();             // Disable before allowing Tx interrupt
    365                  UCSR0B |=  (1 << 5);   // Re-enable Tx interrupts
    366              }
    367          }
    368          
    369          /*********************************************************************
    370          *
    371          *       OS_ISR_tx()
    372          *       embOS UART tx interrupt handler
    373          */
    374              #pragma vector = USART0_UDRE_vect
    375          __interrupt void OS_ISR_tx(void);
    376              #pragma vector = USART0_UDRE_vect
    377          __interrupt void OS_ISR_tx(void) {
    378              OS_CallISR(OS_ISR_tx_Handler);
    379          }
    380          
    381          #else  /* UART for communication not used, define dummy functions */
    382          

   \                                 In  segment CODE, align 2, keep-with-next
    383          void OS_COM_Send1(OS_U8 c) {
   \                     OS_COM_Send1:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    384              OS_USEPARA(c);           /* Avoid compiler warning */
    385              OS_COM_ClearTxActive();    /* Let the OS know that Tx is not busy */
   \   00000000   ........           JMP     OS_COM_ClearTxActive
    386          }

   \                                 In  segment INTVEC, offset 0x44, root
   \                     `??OS_ISR_Tick::??INTVEC 68`:
   \   00000044   ........           JMP     OS_ISR_Tick
    387          #endif
    388          
    389          /****** End Of File *************************************************/

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   OS_COM_Send1
        0      2   -> OS_COM_ClearTxActive
      0      2   OS_ConvertCycles2us
        0      2 ?UL_DIVMOD_S_L03
      0      2   OS_GetTime_Cycles
        0      2   -> _ReadHWTimer
     16      2   OS_ISR_Tick
       16      2   -> OS_CallISR
      0      2   OS_ISR_Tick_Handler
        0      2   -> OS_TICK_Handle
      0      2   OS_Idle
      0      2   OS_InitHW
      0      2   _ReadHWTimer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  OS_COM_Send1
      12  OS_ConvertCycles2us
     126  OS_GetTime_Cycles
      82  OS_ISR_Tick
       4  OS_ISR_Tick::??INTVEC 68
       4  OS_ISR_Tick_Handler
       2  OS_Idle
      36  OS_InitHW
       2  _A_OCR1A
       1  _A_TCCR1A
       1  _A_TCCR1B
       2  _A_TCNT1
       1  _A_TIFR1
       1  _A_TIMSK1
      12  _ReadHWTimer

 
   8 bytes in segment ABSOLUTE
 278 bytes in segment CODE
   4 bytes in segment INTVEC
 
 278 bytes of CODE memory (+ 4 bytes shared)
   0 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: none
