###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       02/Jan/2024  12:42:52
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\UsartPro.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWD6E4.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\UsartPro.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj" -D
#        OS_LIBMODE_R -D OS_UART=-1 -D USE_16552_DRIVER_TASK=1 -D
#        USE_1281_RX_INT_TASK=1 -D USE_MODBUS_PROTOCOL=0 -D ANZBANA_V8=0 -D
#        __ATMEGA_1281__ -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List" -y
#        --initializers_in_flash -DENABLE_BIT_DEFINITIONS -e -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -Ohs)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List\UsartPro.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj\UsartPro.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\UsartPro.c
      1          /****************************************************************************************
      2          / Com protocol for USART0&1
      3          /
      4          ***************************************************************************************/
      5          
      6          #ifdef __ATMEGA_1280__
      7              #include	"iom1280.h"
      8          #endif
      9          
     10          #ifdef __ATMEGA_1281__
     11              #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0xc9
   \   union <unnamed> volatile __io _A_UCSR1B
   \                     _A_UCSR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1
     12          #endif
     13          #include "stdio.h"
     14          #include "math.h"
     15          #include "string.h"
     16          #include "externals.h"
     17          #include "version.h"
     18          
     19          /*************************************************************************
     20          *   (This is a timer calback)
     21          *  Timout timer USART 0
     22          *
     23          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     24          void TimoutUSART0(void) {
   \                     TimoutUSART0:
     25          
     26              UCSR0B &= ~(__BIT_MASK(UDRIE0));            // transmission end, disable int.
   \   00000000   910000C1           LDS     R16, 193
   \   00000004   7D0F               ANDI    R16, 0xDF
   \   00000006   930000C1           STS     193, R16
     27              ClrBit(PORTE, 0x04);                              // TXE0 off
   \   0000000A   94F8               cli
   \   0000000C   9872               CBI     0x0E, 0x02
   \   0000000E   9100....           LDS     R16, (OS_Global + 1)
   \   00000012   2300               TST     R16
   \   00000014   F409               BRNE    ??TimoutUSART0_0
   \   00000016   9478               sei
     28          #if USE_1281_RX_INT_TASK == 0
     29              OS_StopTimer(&TimerUSART0);                    // and stop timer
     30          #endif
     31              GoToSyncUART(0);                                    // go to sync modus for recive
   \                     ??TimoutUSART0_0:
   \   00000018   E000               LDI     R16, 0
   \   0000001A   ....               RJMP    GoToSyncUART
   \   0000001C                      REQUIRE _A_UCSR0B
   \   0000001C                      REQUIRE _A_PORTE
     32          }
     33          
     34          /*************************************************************************
     35          *   (This is a timer calback)
     36          *  Timer USART 0 on before TX
     37          *
     38          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     39          void TimoutUSART0On(void) {
   \                     TimoutUSART0On:
     40          
     41              UCSR0B |= __BIT_MASK(UDRIE0);                     // start sending by enableing interrupt
   \   00000000   910000C1           LDS     R16, 193
   \   00000004   6200               ORI     R16, 0x20
   \   00000006   930000C1           STS     193, R16
     42          #if USE_1281_RX_INT_TASK == 0
     43              OS_StopTimer(&TimerUSART0On);                    // and stop timer
     44          #endif
     45          }
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_UCSR0B
     46          
     47          /*************************************************************************
     48          *   (This is a timer calback)
     49          *  Timout timer USART 1
     50          *
     51          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     52          void TimoutUSART1(void) {
   \                     TimoutUSART1:
     53          
     54              UCSR1B &= ~(__BIT_MASK(UDRIE1));            // transmission end, disable int.
   \   00000000   910000C9           LDS     R16, 201
   \   00000004   7D0F               ANDI    R16, 0xDF
   \   00000006   930000C9           STS     201, R16
     55              ClrBit(PORTE, 0x08);                              // TXE1 off
   \   0000000A   94F8               cli
   \   0000000C   9873               CBI     0x0E, 0x03
   \   0000000E   9100....           LDS     R16, (OS_Global + 1)
   \   00000012   2300               TST     R16
   \   00000014   F409               BRNE    ??TimoutUSART1_0
   \   00000016   9478               sei
     56          #if USE_1281_RX_INT_TASK == 0
     57              OS_StopTimer(&TimerUSART1);                    // and stop timer
     58          #endif
     59              GoToSyncUART(1);                                    // go to sync modus for recive
   \                     ??TimoutUSART1_0:
   \   00000018   E001               LDI     R16, 1
   \   0000001A   ....               RJMP    GoToSyncUART
   \   0000001C                      REQUIRE _A_UCSR1B
   \   0000001C                      REQUIRE _A_PORTE
     60          }
     61          
     62          
     63          /*************************************************************************
     64          *   (This is a timer calback)
     65          *  Timer USART 1 on before TX
     66          *
     67          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     68          void TimoutUSART1On(void) {
   \                     TimoutUSART1On:
     69          
     70              UCSR1B |= __BIT_MASK(UDRIE1);                     // start sending by enableing interrupt
   \   00000000   910000C9           LDS     R16, 201
   \   00000004   6200               ORI     R16, 0x20
   \   00000006   930000C9           STS     201, R16
     71          #if USE_1281_RX_INT_TASK == 0
     72              OS_StopTimer(&TimerUSART1On);                    // and stop timer
     73          #endif
     74          }
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_UCSR1B
     75          
     76          
     77          #if USE_1281_RX_INT_TASK==0
     78          /*************************************************************************
     79          *   (This is a task)
     80          *  Usart0 handler
     81          *
     82          *************************************************************************/
     83          void Usart0Handler(void) {
     84          
     85              while (1) {
     86                  OS_WaitEvent(1);
     87                  OS_Use(&UARTSEND);
     88                  UsartCheckPackage(0);
     89                  OS_Unuse(&UARTSEND);
     90              }
     91          }
     92          
     93          /*************************************************************************
     94          *   (This is a task)
     95          *  Usart1 handler
     96          *
     97          *************************************************************************/
     98          void Usart1Handler(void) {
     99          
    100              while (1) {
    101                  OS_WaitEvent(1);
    102                  OS_Use(&UARTSEND);
    103                  UsartCheckPackage(1);
    104                  OS_Unuse(&UARTSEND);
    105              }
    106          }
    107          #endif
    108          /*************************************************************************
    109          *
    110          *  Check the incoming packages
    111          *
    112          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    113          void UsartCheckPackage(char ch) {
   \                     UsartCheckPackage:
   \   00000000   926A               ST      -Y, R6
   \   00000002   925A               ST      -Y, R5
   \   00000004   924A               ST      -Y, R4
   \   00000006   93BA               ST      -Y, R27
   \   00000008   93AA               ST      -Y, R26
   \   0000000A   939A               ST      -Y, R25
   \   0000000C   938A               ST      -Y, R24
   \   0000000E                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000E                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000E                      REQUIRE ?Register_R6_is_cg_reg
   \   0000000E   2E60               MOV     R6, R16
    114          
    115              unsigned short pointer;
    116              char    retval;
    117          
    118              UART[ch].RxSendReply = false;                              // flag for answering set to fault
   \   00000010   2F20               MOV     R18, R16
   \   00000012   EF0D               LDI     R16, 253
   \   00000014   E011               LDI     R17, 1
   \   00000016   9F21               MUL     R18, R17
   \   00000018   2D30               MOV     R19, R0
   \   0000001A   9F20               MUL     R18, R16
   \   0000001C   0D31               ADD     R19, R1
   \   0000001E   ....               LDI     R16, LOW(UART)
   \   00000020   2E40               MOV     R4, R16
   \   00000022   ....               LDI     R16, (UART) >> 8
   \   00000024   0C40               ADD     R4, R0
   \   00000026   1F03               ADC     R16, R19
   \   00000028   2E50               MOV     R5, R16
   \   0000002A   01D2               MOVW    R27:R26, R5:R4
   \   0000002C   54A5               SUBI    R26, 69
   \   0000002E   4FBE               SBCI    R27, 254
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   E000               LDI     R16, 0
   \   00000034   8303               STD     Z+3, R16
    119              UART[ch].TxFirst = 11;                                     // Start pos for first TX command
   \   00000036   01F2               MOVW    R31:R30, R5:R4
   \   00000038   5EED               SUBI    R30, 237
   \   0000003A   4FFE               SBCI    R31, 254
   \   0000003C   E00B               LDI     R16, 11
   \   0000003E   8300               ST      Z, R16
   \   00000040   E000               LDI     R16, 0
   \   00000042   8301               STD     Z+1, R16
    120              pointer = 7;
   \   00000044   E087               LDI     R24, 7
   \   00000046   E090               LDI     R25, 0
    121              do {
    122                  retval = CheckActionUart(ch, pointer);
   \                     ??UsartCheckPackage_0:
   \   00000048   019C               MOVW    R19:R18, R25:R24
   \   0000004A   2D06               MOV     R16, R6
   \   0000004C   ....               RCALL   CheckActionUart
    123                  pointer = pointer + UART[ch].pRxBuffer[pointer + 2]
    124                      + (UART[ch].pRxBuffer[pointer + 3] * 256) + 4;      // Point to a command cmd hb/lb
   \   0000004E   01F2               MOVW    R31:R30, R5:R4
   \   00000050   0FE8               ADD     R30, R24
   \   00000052   1FF9               ADC     R31, R25
   \   00000054   5EE3               SUBI    R30, 227
   \   00000056   4FFE               SBCI    R31, 254
   \   00000058   8110               LD      R17, Z
   \   0000005A   81F1               LDD     R31, Z+1
   \   0000005C   2FE1               MOV     R30, R17
   \   0000005E   9634               ADIW    R31:R30, 4
   \   00000060   0F8E               ADD     R24, R30
   \   00000062   1F9F               ADC     R25, R31
    125              } while (retval && (pointer < (UART[ch].RxPacklen - 4)));
   \   00000064   2300               TST     R16
   \   00000066   F039               BREQ    ??UsartCheckPackage_1
   \   00000068   91ED               LD      R30, X+
   \   0000006A   91FC               LD      R31, X
   \   0000006C   9711               SBIW    R27:R26, 1
   \   0000006E   9734               SBIW    R31:R30, 4
   \   00000070   178E               CP      R24, R30
   \   00000072   079F               CPC     R25, R31
   \   00000074   F348               BRCS    ??UsartCheckPackage_0
    126              if (UART[ch].RxSendReply) {                                   //send answer?
   \                     ??UsartCheckPackage_1:
   \   00000076   01FD               MOVW    R31:R30, R27:R26
   \   00000078   8103               LDD     R16, Z+3
   \   0000007A   2300               TST     R16
   \   0000007C   2D06               MOV     R16, R6
   \   0000007E   F019               BREQ    ??UsartCheckPackage_2
    127                  Uart_BuildTail(ch);                                       // yes, build tail (and header) and start sending
   \   00000080   ........           CALL    Uart_BuildTail
   \   00000084   C002               RJMP    ??UsartCheckPackage_3
    128              } else {
    129                  GoToSyncUART(ch);                                        // go to sync modus here if not reply
   \                     ??UsartCheckPackage_2:
   \   00000086   ........           CALL    GoToSyncUART
    130              }
    131          }
   \                     ??UsartCheckPackage_3:
   \   0000008A   9189               LD      R24, Y+
   \   0000008C   9199               LD      R25, Y+
   \   0000008E   91A9               LD      R26, Y+
   \   00000090   91B9               LD      R27, Y+
   \   00000092   9049               LD      R4, Y+
   \   00000094   9059               LD      R5, Y+
   \   00000096   9069               LD      R6, Y+
   \   00000098   9508               RET
    132          
    133          
    134          /*************************************************************************
    135          *
    136          *  Check action on received data
    137          *
    138          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    139          char CheckActionUart(char ch, unsigned short pointer) {
   \                     CheckActionUart:
   \   00000000   929A               ST      -Y, R9
   \   00000002   928A               ST      -Y, R8
   \   00000004   927A               ST      -Y, R7
   \   00000006   926A               ST      -Y, R6
   \   00000008   925A               ST      -Y, R5
   \   0000000A   924A               ST      -Y, R4
   \   0000000C   93BA               ST      -Y, R27
   \   0000000E   93AA               ST      -Y, R26
   \   00000010   939A               ST      -Y, R25
   \   00000012   938A               ST      -Y, R24
   \   00000014                      REQUIRE ?Register_R4_is_cg_reg
   \   00000014                      REQUIRE ?Register_R5_is_cg_reg
   \   00000014                      REQUIRE ?Register_R6_is_cg_reg
   \   00000014                      REQUIRE ?Register_R7_is_cg_reg
   \   00000014                      REQUIRE ?Register_R8_is_cg_reg
   \   00000014                      REQUIRE ?Register_R9_is_cg_reg
   \   00000014   2F80               MOV     R24, R16
   \   00000016   01D9               MOVW    R27:R26, R19:R18
    140          
    141              unsigned short   command;
    142              char    retval = true;
   \   00000018   E091               LDI     R25, 1
    143          
    144              command = UART[ch].pRxBuffer[pointer] | (UART[ch].pRxBuffer[pointer + 1] << 8);
   \   0000001A   2F20               MOV     R18, R16
   \   0000001C   EF0D               LDI     R16, 253
   \   0000001E   9F29               MUL     R18, R25
   \   00000020   2D30               MOV     R19, R0
   \   00000022   9F20               MUL     R18, R16
   \   00000024   0D31               ADD     R19, R1
   \   00000026   ....               LDI     R16, LOW(UART)
   \   00000028   2E60               MOV     R6, R16
   \   0000002A   ....               LDI     R16, (UART) >> 8
   \   0000002C   0C60               ADD     R6, R0
   \   0000002E   1F03               ADC     R16, R19
   \   00000030   0E6A               ADD     R6, R26
   \   00000032   1F0B               ADC     R16, R27
   \   00000034   2E70               MOV     R7, R16
   \   00000036   2C46               MOV     R4, R6
   \   00000038   2E50               MOV     R5, R16
   \   0000003A   E10B               LDI     R16, 27
   \   0000003C   0E40               ADD     R4, R16
   \   0000003E   1E59               ADC     R5, R25
   \   00000040   01F2               MOVW    R31:R30, R5:R4
   \   00000042   8080               LD      R8, Z
   \   00000044   8091               LDD     R9, Z+1
    145              switch (command) {                                  // check action
   \   00000046   0184               MOVW    R17:R16, R9:R8
   \   00000048   ....               LDI     R30, LOW(`?<Jumptable for CheckActionUart>_0`)
   \   0000004A   ....               LDI     R31, (`?<Jumptable for CheckActionUart>_0`) >> 16
   \   0000004C   BFFB               OUT     0x3B, R31
   \   0000004E   ....               LDI     R31, HIGH(`?<Jumptable for CheckActionUart>_0`)
   \   00000050   ........           JMP     ?SV_SWITCH_L06
    146              case CMD_REQ_STATUS :                           // Regusest status for target
    147                  BuildStatusData(ch);                         // make package
   \                     ??CheckActionUart_0:
   \   00000054   2F08               MOV     R16, R24
   \   00000056   ....               RCALL   BuildStatusData
    148                  break;
   \   00000058   C0BD               RJMP    ??CheckActionUart_1
    149          
    150              case CMD_GET_STACKSTATUS :                        // Request stck status
    151                  BuildStackStatus(ch, pointer + 4);                     // receive package
   \                     ??CheckActionUart_2:
   \   0000005A   9614               ADIW    R27:R26, 4
   \   0000005C   019D               MOVW    R19:R18, R27:R26
   \   0000005E   2F08               MOV     R16, R24
   \   00000060   ....               RCALL   BuildStackStatus
    152                  break;
   \   00000062   C0B8               RJMP    ??CheckActionUart_1
    153          
    154              case CMD_EEPROM_RESET :                        // Reset EEPROM??
    155                  GetResetEEPROM(ch, pointer + 4);                     // receive package
   \                     ??CheckActionUart_3:
   \   00000064   ........           CALL    EEPROMReset
    156                  break;
   \   00000068   C0B5               RJMP    ??CheckActionUart_1
   \                     ??CheckActionUart_4:
   \   0000006A   99F9               SBIC    0x1F, 0x01
   \   0000006C   CFFE               RJMP    ??CheckActionUart_4
   \   0000006E   EF0F               LDI     R16, 255
   \   00000070   BD01               OUT     0x21, R16
   \   00000072   E00F               LDI     R16, 15
   \   00000074   BD02               OUT     0x22, R16
   \   00000076   EF0F               LDI     R16, 255
   \   00000078   BD00               OUT     0x20, R16
   \   0000007A   9AFA               SBI     0x1F, 0x02
   \   0000007C   9AF9               SBI     0x1F, 0x01
   \   0000007E   E108               LDI     R16, 24
   \   00000080   C002               RJMP    ??CheckActionUart_5
   \                     ??CheckActionUart_6:
   \   00000082   9300....           STS     _A_WDTCSR, R16
   \                     ??CheckActionUart_5:
   \   00000086   99F9               SBIC    0x1F, 0x01
   \   00000088   CFFC               RJMP    ??CheckActionUart_6
   \   0000008A   E008               LDI     R16, 8
   \   0000008C   9300....           STS     _A_WDTCSR, R16
    157          
    158              case CMD_GOTO_BOOTLOADER :                        // Goto bootlaoder??
    159                  GetGotoBootloader(ch, pointer + 4);                     // receive package
    160                  break;
   \   00000090   C0A1               RJMP    ??CheckActionUart_1
    161          
    162              case CMD_SND_EEPROM_DATA :                              // Receive EEPROM data
    163                  GetEEPROMData(ch, pointer + 4);                     // receive package
   \                     ??CheckActionUart_7:
   \   00000092   9614               ADIW    R27:R26, 4
   \   00000094   019D               MOVW    R19:R18, R27:R26
   \   00000096   2F08               MOV     R16, R24
   \   00000098   ....               RCALL   GetEEPROMData
    164                  break;
   \   0000009A   C09C               RJMP    ??CheckActionUart_1
    165          
    166              case CMD_REQ_EEPROM_DATA :                              // Request to send EEPROM data
    167                  BuildEEPROMData(ch, pointer + 4);                     // receive package
   \                     ??CheckActionUart_8:
   \   0000009C   9614               ADIW    R27:R26, 4
   \   0000009E   019D               MOVW    R19:R18, R27:R26
   \   000000A0   2F08               MOV     R16, R24
   \   000000A2   ....               RCALL   BuildEEPROMData
    168                  break;
   \   000000A4   C097               RJMP    ??CheckActionUart_1
    169          
    170              case CMD_REQ_INT_DATA :                              // Request external data
    171                  BuildADInt(ch, pointer + 4);                     // receive package
   \                     ??CheckActionUart_9:
   \   000000A6   9614               ADIW    R27:R26, 4
   \   000000A8   019D               MOVW    R19:R18, R27:R26
   \   000000AA   2F08               MOV     R16, R24
   \   000000AC   ....               RCALL   BuildADInt
    172                  break;
   \   000000AE   C092               RJMP    ??CheckActionUart_1
    173          
    174              case CMD_SND_RS4_SETUP :                              // Receive sertup of AN-RS485
    175                  if (UnitID == AN_ZB485) {
   \                     ??CheckActionUart_10:
   \   000000B0   9100....           LDS     R16, UnitID
   \   000000B4   2300               TST     R16
   \   000000B6   F009               BREQ    $+2+2
   \   000000B8   C08D               RJMP    ??CheckActionUart_1
    176                      GetRS4Setup(ch, pointer + 4);                     // receive package
   \   000000BA   9614               ADIW    R27:R26, 4
   \   000000BC   019D               MOVW    R19:R18, R27:R26
   \   000000BE   2F08               MOV     R16, R24
   \   000000C0   ....               RCALL   GetRS4Setup
   \   000000C2   C088               RJMP    ??CheckActionUart_1
    177                  }
    178                  break;
    179          
    180              case CMD_REQ_RS4_SETUP :                              // Request for sertup of AN-RS485
    181                  if (UnitID == AN_ZB485) {
   \                     ??CheckActionUart_11:
   \   000000C4   9100....           LDS     R16, UnitID
   \   000000C8   2300               TST     R16
   \   000000CA   F009               BREQ    $+2+2
   \   000000CC   C083               RJMP    ??CheckActionUart_1
    182                      BuildRS4Setup(ch, pointer + 4);                     // receive package
   \   000000CE   9614               ADIW    R27:R26, 4
   \   000000D0   019D               MOVW    R19:R18, R27:R26
   \   000000D2   2F08               MOV     R16, R24
   \   000000D4   ....               RCALL   BuildRS4Setup
   \   000000D6   C07E               RJMP    ??CheckActionUart_1
    183                  }
    184                  break;
    185          
    186              case CMD_SND_RS4_ADBUF :                              // Request external AD data
    187                  if (UnitID == AN_ZB485) {
   \                     ??CheckActionUart_12:
   \   000000D8   9100....           LDS     R16, UnitID
   \   000000DC   2300               TST     R16
   \   000000DE   F009               BREQ    $+2+2
   \   000000E0   C079               RJMP    ??CheckActionUart_1
    188                      GetADData(ch, pointer + 4);                     // receive package
   \   000000E2   9614               ADIW    R27:R26, 4
   \   000000E4   019D               MOVW    R19:R18, R27:R26
   \   000000E6   2F08               MOV     R16, R24
   \   000000E8   ....               RCALL   GetADData
   \   000000EA   C074               RJMP    ??CheckActionUart_1
    189                  }
    190                  break;
    191          
    192              case CMD_REQ_RS4_DATA :                              // Request external AD eeprom data
    193                  if (UnitID == AN_ZB485) {
   \                     ??CheckActionUart_13:
   \   000000EC   9100....           LDS     R16, UnitID
   \   000000F0   2300               TST     R16
   \   000000F2   F009               BREQ    $+2+2
   \   000000F4   C06F               RJMP    ??CheckActionUart_1
    194                      switch (UART[ch].pRxBuffer[pointer + 4]) {
   \   000000F6   01F2               MOVW    R31:R30, R5:R4
   \   000000F8   8104               LDD     R16, Z+4
   \   000000FA   2300               TST     R16
   \   000000FC   F019               BREQ    ??CheckActionUart_14
   \   000000FE   950A               DEC     R16
   \   00000100   F139               BREQ    ??CheckActionUart_15
   \   00000102   C068               RJMP    ??CheckActionUart_1
    195                      case 0:                                         // Measure data
    196                          BuildMData485(ch, pointer + 5);              // receive package
   \                     ??CheckActionUart_14:
   \   00000104   9615               ADIW    R27:R26, 5
   \   00000106   013D               MOVW    R7:R6, R27:R26
   \   00000108   019D               MOVW    R19:R18, R27:R26
   \   0000010A   2F08               MOV     R16, R24
   \   0000010C   ....               RCALL   BuildMData485
    197                          if (TData.RS4.FromTargetBuffer[0][0] == true) {     // send eepromdata ch 0?
   \   0000010E   ....               LDI     R26, LOW((TData + 1428))
   \   00000110   ....               LDI     R27, HIGH((TData + 1428))
   \   00000112   910C               LD      R16, X
   \   00000114   3001               CPI     R16, 1
   \   00000116   F429               BRNE    ??CheckActionUart_16
    198                              BuildADEpromdata(ch, 0);
   \   00000118   E010               LDI     R17, 0
   \   0000011A   2F08               MOV     R16, R24
   \   0000011C   ....               RCALL   BuildADEpromdata
    199                              TData.RS4.FromTargetBuffer[0][0] = false;  // Marked as sent
   \   0000011E   E000               LDI     R16, 0
   \   00000120   930C               ST      X, R16
    200                          }
    201                          if (TData.RS4.FromTargetBuffer[1][0] == true) {     // send eepromdata ch 1?
   \                     ??CheckActionUart_16:
   \   00000122   01FD               MOVW    R31:R30, R27:R26
   \   00000124   A902               LDD     R16, Z+50
   \   00000126   3001               CPI     R16, 1
   \   00000128   F429               BRNE    ??CheckActionUart_17
    202                              BuildADEpromdata(ch, 1);                  // channel 1
   \   0000012A   018C               MOVW    R17:R16, R25:R24
   \   0000012C   ....               RCALL   BuildADEpromdata
    203                              TData.RS4.FromTargetBuffer[1][0] = false;  // Marked as sent
   \   0000012E   01FD               MOVW    R31:R30, R27:R26
   \   00000130   E000               LDI     R16, 0
   \   00000132   AB02               STD     Z+50, R16
    204                          }
    205                          if ((TData.RS4.WHDataAvailable >> UART[ch].pRxBuffer[pointer + 5]) & 0x01) {
   \                     ??CheckActionUart_17:
   \   00000134   9100....           LDS     R16, (TData + 1267)
   \   00000138   E010               LDI     R17, 0
   \   0000013A   01F2               MOVW    R31:R30, R5:R4
   \   0000013C   8145               LDD     R20, Z+5
   \   0000013E   ........           CALL    ?SS_SHR_L02
   \   00000142   7001               ANDI    R16, 0x01
   \   00000144   F409               BRNE    $+2+2
   \   00000146   C046               RJMP    ??CheckActionUart_1
    206                              BuildWHdata(ch, pointer + 5);
   \   00000148   0193               MOVW    R19:R18, R7:R6
   \   0000014A   2F08               MOV     R16, R24
   \   0000014C   ....               RCALL   BuildWHdata
   \   0000014E   C042               RJMP    ??CheckActionUart_1
    207                              //TData.RS4.WHDataAvailable &= ~(0x01 << UART[ch].pRxBuffer[pointer+5]);
    208                          }
    209                          break;
    210                      case 1:                                         // Raw and cal data
    211                          BuildRData485(ch, pointer + 5);                     // receive package
   \                     ??CheckActionUart_15:
   \   00000150   9615               ADIW    R27:R26, 5
   \   00000152   019D               MOVW    R19:R18, R27:R26
   \   00000154   2F08               MOV     R16, R24
   \   00000156   ....               RCALL   BuildRData485
    212                          break;
   \   00000158   C03D               RJMP    ??CheckActionUart_1
    213                      }
    214                  }
    215                  break;
    216          
    217              case CMD_SND_ANA_SETUP :                              // Receive sertup of AN-RSANA
    218                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_18:
   \   0000015A   9100....           LDS     R16, UnitID
   \   0000015E   3001               CPI     R16, 1
   \   00000160   F5C9               BRNE    ??CheckActionUart_1
    219                      GetANASetup(ch, pointer + 4);                     // receive package
   \   00000162   9614               ADIW    R27:R26, 4
   \   00000164   019D               MOVW    R19:R18, R27:R26
   \   00000166   2F08               MOV     R16, R24
   \   00000168   ....               RCALL   GetANASetup
   \   0000016A   C034               RJMP    ??CheckActionUart_1
    220                  }
    221                  break;
    222          
    223              case CMD_REQ_ANA_SETUP :                              // Request for sertup of AN-RSANA
    224                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_19:
   \   0000016C   9100....           LDS     R16, UnitID
   \   00000170   3001               CPI     R16, 1
   \   00000172   F581               BRNE    ??CheckActionUart_1
    225                      BuildANASetup(ch, pointer + 4);                     // receive package
   \   00000174   9614               ADIW    R27:R26, 4
   \   00000176   019D               MOVW    R19:R18, R27:R26
   \   00000178   2F08               MOV     R16, R24
   \   0000017A   ........           CALL    BuildANASetup
   \   0000017E   C02A               RJMP    ??CheckActionUart_1
    226                  }
    227                  break;
    228          
    229              case CMD_SND_ANA_FILTER :                              // Receive filter of AN-RSANA
    230                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_20:
   \   00000180   9100....           LDS     R16, UnitID
   \   00000184   3001               CPI     R16, 1
   \   00000186   F531               BRNE    ??CheckActionUart_1
    231                      GetANAFilter(ch, pointer + 4);                     // receive package
   \   00000188   E10F               LDI     R16, 31
   \   0000018A   0E60               ADD     R6, R16
   \   0000018C   1E79               ADC     R7, R25
   \   0000018E   01F3               MOVW    R31:R30, R7:R6
   \   00000190   ....               LDI     R26, LOW((TData + 2))
   \   00000192   ....               LDI     R27, HIGH((TData + 2))
   \   00000194   E00C               LDI     R16, 12
   \                     ??CheckActionUart_21:
   \   00000196   9111               LD      R17, Z+
   \   00000198   931D               ST      X+, R17
   \   0000019A   950A               DEC     R16
   \   0000019C   F0D9               BREQ    ??CheckActionUart_1
   \   0000019E   CFFB               RJMP    ??CheckActionUart_21
    232                  }
    233                  break;
    234          
    235              case CMD_REQ_ANA_FILTER :                              // Request filter of AN-RSANA
    236                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_22:
   \   000001A0   9100....           LDS     R16, UnitID
   \   000001A4   3001               CPI     R16, 1
   \   000001A6   F4B1               BRNE    ??CheckActionUart_1
    237                      BuildANAFilter(ch, pointer + 4);                     // receive package
   \   000001A8   9614               ADIW    R27:R26, 4
   \   000001AA   019D               MOVW    R19:R18, R27:R26
   \   000001AC   2F08               MOV     R16, R24
   \   000001AE   ........           CALL    BuildANAFilter
   \   000001B2   C010               RJMP    ??CheckActionUart_1
    238                  }
    239                  break;
    240          
    241              case CMD_REQ_ANA_DATA :                              // Request ANA data(4-20ma)
    242                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_23:
   \   000001B4   9100....           LDS     R16, UnitID
   \   000001B8   3001               CPI     R16, 1
   \   000001BA   F461               BRNE    ??CheckActionUart_1
    243                      BuildMDataANA(ch, pointer + 4);                     // receive
   \   000001BC   9614               ADIW    R27:R26, 4
   \   000001BE   019D               MOVW    R19:R18, R27:R26
   \   000001C0   2F08               MOV     R16, R24
   \   000001C2   ........           CALL    BuildMDataANA
   \   000001C6   C006               RJMP    ??CheckActionUart_1
    244                  }
    245                  break;
    246          
    247              default:
    248                  if (command < MAX_ECMD) {                   // handle end commands
   \                     ??CheckActionUart_24:
   \   000001C8   E604               LDI     R16, 100
   \   000001CA   1680               CP      R8, R16
   \   000001CC   E000               LDI     R16, 0
   \   000001CE   0690               CPC     R9, R16
   \   000001D0   F408               BRCC    ??CheckActionUart_1
    249                      retval = false;
   \   000001D2   E090               LDI     R25, 0
    250                  }
    251                  break;
    252          
    253              }
    254              return retval;
   \                     ??CheckActionUart_1:
   \   000001D4   2F09               MOV     R16, R25
   \   000001D6   9189               LD      R24, Y+
   \   000001D8   9199               LD      R25, Y+
   \   000001DA   91A9               LD      R26, Y+
   \   000001DC   91B9               LD      R27, Y+
   \   000001DE   9049               LD      R4, Y+
   \   000001E0   9059               LD      R5, Y+
   \   000001E2   9069               LD      R6, Y+
   \   000001E4   9079               LD      R7, Y+
   \   000001E6   9089               LD      R8, Y+
   \   000001E8   9099               LD      R9, Y+
   \   000001EA   9508               RET
   \   000001EC                      REQUIRE _A_EECR
   \   000001EC                      REQUIRE _A_EEAR
   \   000001EC                      REQUIRE _A_EEDR
   \   000001EC                      REQUIRE _A_WDTCSR
    255          }
    256          
    257          /*************************************************************************
    258          *
    259          * Build send packet header
    260          *
    261          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    262          void Uart_BuildHeader(char ch) {
   \                     Uart_BuildHeader:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
    263          
    264              UART[ch].RxFirst = 0;                                // Reset pointers
   \   00000004   2F20               MOV     R18, R16
   \   00000006   EF0D               LDI     R16, 253
   \   00000008   E011               LDI     R17, 1
   \   0000000A   9F21               MUL     R18, R17
   \   0000000C   2D30               MOV     R19, R0
   \   0000000E   9F20               MUL     R18, R16
   \   00000010   0D31               ADD     R19, R1
   \   00000012   ....               LDI     R26, LOW(UART)
   \   00000014   ....               LDI     R27, (UART) >> 8
   \   00000016   0DA0               ADD     R26, R0
   \   00000018   1FB3               ADC     R27, R19
   \   0000001A   01FD               MOVW    R31:R30, R27:R26
   \   0000001C   54EF               SUBI    R30, 79
   \   0000001E   4FFE               SBCI    R31, 254
   \   00000020   E000               LDI     R16, 0
   \   00000022   8300               ST      Z, R16
   \   00000024   8301               STD     Z+1, R16
    265              UART[ch].RxLast  = 0;
   \   00000026   8302               STD     Z+2, R16
   \   00000028   8303               STD     Z+3, R16
    266              UART[ch].TxLast  = 0;
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   5EEB               SUBI    R30, 235
   \   0000002E   4FFE               SBCI    R31, 254
   \   00000030   8300               ST      Z, R16
   \   00000032   8301               STD     Z+1, R16
    267          
    268              UART[ch].pTxBuffer[0] = ANPRO10_SYN;                        /* Sync */
   \   00000034   E106               LDI     R16, 22
   \   00000036   930D               ST      X+, R16
    269              UART[ch].pTxBuffer[1] = ANPRO10_SYN;                        /* Sync */
   \   00000038   930D               ST      X+, R16
    270              UART[ch].pTxBuffer[2] = ANPRO10_SYN;                        /* Sync */
   \   0000003A   930D               ST      X+, R16
    271              UART[ch].pTxBuffer[3] = ANPRO10_SOH;                        /* Start of header */
   \   0000003C   931C               ST      X, R17
   \   0000003E   9611               ADIW    R27:R26, 1
    272              UART[ch].pTxBuffer[4] = UART[ch].pRxBuffer[2];      /* RXID */
   \   00000040   8500               LDD     R16, Z+8
   \   00000042   930C               ST      X, R16
   \   00000044   9714               SBIW    R27:R26, 4
    273              UART[ch].pTxBuffer[5] = UART[ch].pRxBuffer[3];      /* Rx address */
   \   00000046   8501               LDD     R16, Z+9
   \   00000048   01FD               MOVW    R31:R30, R27:R26
   \   0000004A   8305               STD     Z+5, R16
    274              UART[ch].pTxBuffer[6] = 0x10 + UnitID;              /* Unit ID */
   \   0000004C   9100....           LDS     R16, UnitID
   \   00000050   5F00               SUBI    R16, 240
   \   00000052   8306               STD     Z+6, R16
    275              UART[ch].pTxBuffer[7] = MyAddress();                 /* Tx address */
   \   00000054   ........           CALL    MyAddress
   \   00000058   01FD               MOVW    R31:R30, R27:R26
   \   0000005A   8307               STD     Z+7, R16
    276              UART[ch].pTxBuffer[8] = 0;                          /* packlen HB, don't know yet */
   \   0000005C   E000               LDI     R16, 0
   \   0000005E   8700               STD     Z+8, R16
    277              UART[ch].pTxBuffer[9] = 0;                          /* packlen LB, don't know yet */
   \   00000060   8701               STD     Z+9, R16
    278              UART[ch].pTxBuffer[10] = 0;                         /* Header checksum, don't know yet */
   \   00000062   8702               STD     Z+10, R16
    279          }
   \   00000064   91A9               LD      R26, Y+
   \   00000066   91B9               LD      R27, Y+
   \   00000068   9508               RET
    280          
    281          /*************************************************************************
    282          *
    283          * Build  packet tail
    284          *
    285          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    286          void Uart_BuildTail(char ch) {
   \                     Uart_BuildTail:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
   \   00000006   2F80               MOV     R24, R16
    287          
    288              Uart_BuildHeader(ch);                                    // fist build the header
   \   00000008   ....               RCALL   Uart_BuildHeader
    289          
    290              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ECMD_NMDWOACK & 0xff;  // End command lb
   \   0000000A   2F28               MOV     R18, R24
   \   0000000C   EF0D               LDI     R16, 253
   \   0000000E   E011               LDI     R17, 1
   \   00000010   9F21               MUL     R18, R17
   \   00000012   2D30               MOV     R19, R0
   \   00000014   9F20               MUL     R18, R16
   \   00000016   0D31               ADD     R19, R1
   \   00000018   ....               LDI     R16, LOW(UART)
   \   0000001A   ....               LDI     R17, (UART) >> 8
   \   0000001C   0D00               ADD     R16, R0
   \   0000001E   1F13               ADC     R17, R19
   \   00000020   01D8               MOVW    R27:R26, R17:R16
   \   00000022   5EAD               SUBI    R26, 237
   \   00000024   4FBE               SBCI    R27, 254
   \   00000026   01FD               MOVW    R31:R30, R27:R26
   \   00000028   8120               LD      R18, Z
   \   0000002A   8131               LDD     R19, Z+1
   \   0000002C   01F9               MOVW    R31:R30, R19:R18
   \   0000002E   9631               ADIW    R31:R30, 1
   \   00000030   93ED               ST      X+, R30
   \   00000032   93FC               ST      X, R31
   \   00000034   9711               SBIW    R27:R26, 1
   \   00000036   01F8               MOVW    R31:R30, R17:R16
   \   00000038   0FE2               ADD     R30, R18
   \   0000003A   1FF3               ADC     R31, R19
   \   0000003C   E020               LDI     R18, 0
   \   0000003E   8320               ST      Z, R18
    291              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ECMD_NMDWOACK >> 8;    // End command hb
   \   00000040   912D               LD      R18, X+
   \   00000042   913C               LD      R19, X
   \   00000044   9711               SBIW    R27:R26, 1
   \   00000046   01F9               MOVW    R31:R30, R19:R18
   \   00000048   9631               ADIW    R31:R30, 1
   \   0000004A   93ED               ST      X+, R30
   \   0000004C   93FC               ST      X, R31
   \   0000004E   9711               SBIW    R27:R26, 1
   \   00000050   01F8               MOVW    R31:R30, R17:R16
   \   00000052   0FE2               ADD     R30, R18
   \   00000054   1FF3               ADC     R31, R19
   \   00000056   E020               LDI     R18, 0
   \   00000058   8320               ST      Z, R18
    292              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0x00;                  // End data
   \   0000005A   912D               LD      R18, X+
   \   0000005C   913C               LD      R19, X
   \   0000005E   9711               SBIW    R27:R26, 1
   \   00000060   01F9               MOVW    R31:R30, R19:R18
   \   00000062   9631               ADIW    R31:R30, 1
   \   00000064   93ED               ST      X+, R30
   \   00000066   93FC               ST      X, R31
   \   00000068   9711               SBIW    R27:R26, 1
   \   0000006A   01F8               MOVW    R31:R30, R17:R16
   \   0000006C   0FE2               ADD     R30, R18
   \   0000006E   1FF3               ADC     R31, R19
   \   00000070   E020               LDI     R18, 0
   \   00000072   8320               ST      Z, R18
    293          
    294              UART[ch].pTxBuffer[UART[ch].TxFirst] = UART[ch].TxSeqCnt;   // Sequence counter
   \   00000074   912D               LD      R18, X+
   \   00000076   913C               LD      R19, X
   \   00000078   9711               SBIW    R27:R26, 1
   \   0000007A   01FD               MOVW    R31:R30, R27:R26
   \   0000007C   8147               LDD     R20, Z+7
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   0FE2               ADD     R30, R18
   \   00000082   1FF3               ADC     R31, R19
   \   00000084   8340               ST      Z, R20
    295              UART[ch].TxFirst++;
   \   00000086   912D               LD      R18, X+
   \   00000088   913C               LD      R19, X
   \   0000008A   5F2F               SUBI    R18, 255
   \   0000008C   4F3F               SBCI    R19, 255
   \   0000008E   933C               ST      X, R19
   \   00000090   932E               ST      -X, R18
    296              UART[ch].TxSeqCnt++;
   \   00000092   01F8               MOVW    R31:R30, R17:R16
   \   00000094   5EE6               SUBI    R30, 230
   \   00000096   4FFE               SBCI    R31, 254
   \   00000098   8120               LD      R18, Z
   \   0000009A   9523               INC     R18
   \   0000009C   8320               ST      Z, R18
    297          
    298              UART[ch].pTxBuffer[8] = UART[ch].TxFirst - 2;                    // correct length because stx's
   \   0000009E   912D               LD      R18, X+
   \   000000A0   913C               LD      R19, X
   \   000000A2   9711               SBIW    R27:R26, 1
   \   000000A4   5022               SUBI    R18, 2
   \   000000A6   01F8               MOVW    R31:R30, R17:R16
   \   000000A8   8720               STD     Z+8, R18
    299              UART[ch].pTxBuffer[9] = (UART[ch].TxFirst - 2) >> 8;             // packet len high
   \   000000AA   91ED               LD      R30, X+
   \   000000AC   91FC               LD      R31, X
   \   000000AE   9711               SBIW    R27:R26, 1
   \   000000B0   9732               SBIW    R31:R30, 2
   \   000000B2   2F2F               MOV     R18, R31
   \   000000B4   01F8               MOVW    R31:R30, R17:R16
   \   000000B6   8721               STD     Z+9, R18
    300          
    301              UART[ch].pTxBuffer[10] = CalcDSTxChecksum(ch, 10);         // Get header checksum
   \   000000B8   E060               LDI     R22, 0
   \   000000BA   01A8               MOVW    R21:R20, R17:R16
   \   000000BC   5F4C               SUBI    R20, 252
   \   000000BE   4F5F               SBCI    R21, 255
   \   000000C0   E026               LDI     R18, 6
   \   000000C2   ....               LDI     R19, (crc) >> 16
   \                     ??Uart_BuildTail_0:
   \   000000C4   01FA               MOVW    R31:R30, R21:R20
   \   000000C6   9001               LD      R0, Z+
   \   000000C8   01AF               MOVW    R21:R20, R31:R30
   \   000000CA   2560               EOR     R22, R0
   \   000000CC   2FE6               MOV     R30, R22
   \   000000CE   E0F0               LDI     R31, 0
   \   000000D0   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000D2   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000D4   BF3B               OUT     0x3B, R19
   \   000000D6   9166               ELPM    R22, Z
   \   000000D8   952A               DEC     R18
   \   000000DA   F7A1               BRNE    ??Uart_BuildTail_0
   \   000000DC   01F8               MOVW    R31:R30, R17:R16
   \   000000DE   8762               STD     Z+10, R22
    302          
    303              UART[ch].pTxBuffer[UART[ch].TxFirst] = CalcDSTxChecksum(ch, UART[ch].TxFirst); // Get checksum
   \   000000E0   902D               LD      R2, X+
   \   000000E2   903C               LD      R3, X
   \   000000E4   9711               SBIW    R27:R26, 1
   \   000000E6   916D               LD      R22, X+
   \   000000E8   917C               LD      R23, X
   \   000000EA   9711               SBIW    R27:R26, 1
   \   000000EC   2400               CLR     R0
   \   000000EE   3065               CPI     R22, 5
   \   000000F0   0570               CPC     R23, R0
   \   000000F2   F088               BRCS    ??Uart_BuildTail_1
   \   000000F4   01A8               MOVW    R21:R20, R17:R16
   \   000000F6   5F4C               SUBI    R20, 252
   \   000000F8   4F5F               SBCI    R21, 255
   \   000000FA   5064               SUBI    R22, 4
   \   000000FC   4070               SBCI    R23, 0
   \                     ??Uart_BuildTail_2:
   \   000000FE   01FA               MOVW    R31:R30, R21:R20
   \   00000100   9121               LD      R18, Z+
   \   00000102   01AF               MOVW    R21:R20, R31:R30
   \   00000104   2602               EOR     R0, R18
   \   00000106   2DE0               MOV     R30, R0
   \   00000108   E0F0               LDI     R31, 0
   \   0000010A   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000010C   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000010E   9006               ELPM    R0, Z
   \   00000110   5061               SUBI    R22, 1
   \   00000112   4070               SBCI    R23, 0
   \   00000114   F7A1               BRNE    ??Uart_BuildTail_2
   \                     ??Uart_BuildTail_1:
   \   00000116   01F8               MOVW    R31:R30, R17:R16
   \   00000118   0DE2               ADD     R30, R2
   \   0000011A   1DF3               ADC     R31, R3
   \   0000011C   8200               ST      Z, R0
    304              UART[ch].TxFirst++;                                        // OBS!! must be inc here due to ANSI standard !!!!
   \   0000011E   912D               LD      R18, X+
   \   00000120   913C               LD      R19, X
   \   00000122   5F2F               SUBI    R18, 255
   \   00000124   4F3F               SBCI    R19, 255
   \   00000126   933C               ST      X, R19
   \   00000128   932E               ST      -X, R18
    305          
    306              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANPRO10_EOT;            // End of transmission
   \   0000012A   912D               LD      R18, X+
   \   0000012C   913C               LD      R19, X
   \   0000012E   9711               SBIW    R27:R26, 1
   \   00000130   01F9               MOVW    R31:R30, R19:R18
   \   00000132   9631               ADIW    R31:R30, 1
   \   00000134   93ED               ST      X+, R30
   \   00000136   93FC               ST      X, R31
   \   00000138   9711               SBIW    R27:R26, 1
   \   0000013A   01F8               MOVW    R31:R30, R17:R16
   \   0000013C   0FE2               ADD     R30, R18
   \   0000013E   1FF3               ADC     R31, R19
   \   00000140   E024               LDI     R18, 4
   \   00000142   8320               ST      Z, R18
    307              UART[ch].TxCount = UART[ch].TxFirst;                      //bytes to send
   \   00000144   912D               LD      R18, X+
   \   00000146   913C               LD      R19, X
   \   00000148   9711               SBIW    R27:R26, 1
   \   0000014A   01FD               MOVW    R31:R30, R27:R26
   \   0000014C   8324               STD     Z+4, R18
   \   0000014E   8335               STD     Z+5, R19
    308              UART[ch].TxLast = 0;                                     // reset cunter
   \   00000150   E020               LDI     R18, 0
   \   00000152   8322               STD     Z+2, R18
   \   00000154   8323               STD     Z+3, R18
    309              UART[ch].RxState = SEND;
   \   00000156   5409               SUBI    R16, 73
   \   00000158   4F1E               SBCI    R17, 254
   \   0000015A   01F8               MOVW    R31:R30, R17:R16
   \   0000015C   E003               LDI     R16, 3
   \   0000015E   8300               ST      Z, R16
    310              if (ch == 0) {                                           // Turn on TXE for channel
   \   00000160   2388               TST     R24
   \   00000162   F451               BRNE    ??Uart_BuildTail_3
    311          #if USE_1281_RX_INT_TASK == 0
    312                  OS_RetriggerTimer(&TimerUSART0);                     // and start timeout TX timer
    313          #endif
    314                  SetBit(PORTE, 0x04);                                 // TXE0 on
   \   00000164   94F8               cli
   \   00000166   9A72               SBI     0x0E, 0x02
   \   00000168   9100....           LDS     R16, (OS_Global + 1)
   \   0000016C   2300               TST     R16
   \   0000016E   F409               BRNE    ??Uart_BuildTail_4
   \   00000170   9478               sei
    315                  OS_RetriggerTimer(&TimerUSART0On);                           // and start timer for on before TX
   \                     ??Uart_BuildTail_4:
   \   00000172   ....               LDI     R16, LOW(TimerUSART0On)
   \   00000174   ....               LDI     R17, (TimerUSART0On) >> 8
   \   00000176   C00B               RJMP    ??Uart_BuildTail_5
    316              } else if (ch == 1) {
   \                     ??Uart_BuildTail_3:
   \   00000178   3081               CPI     R24, 1
   \   0000017A   F459               BRNE    ??Uart_BuildTail_6
    317                  //       OS_RetriggerTimer(&TimerUSART1);                     // and start timeout TX timer
    318                  SetBit(PORTE, 0x08);                                // TXE1 on
   \   0000017C   94F8               cli
   \   0000017E   9A73               SBI     0x0E, 0x03
   \   00000180   9100....           LDS     R16, (OS_Global + 1)
   \   00000184   2300               TST     R16
   \   00000186   F409               BRNE    ??Uart_BuildTail_7
   \   00000188   9478               sei
    319                  OS_RetriggerTimer(&TimerUSART1On);                     // and start timer for on before TX
   \                     ??Uart_BuildTail_7:
   \   0000018A   ....               LDI     R16, LOW(TimerUSART1On)
   \   0000018C   ....               LDI     R17, (TimerUSART1On) >> 8
   \                     ??Uart_BuildTail_5:
   \   0000018E   ........           CALL    OS_RetriggerTimer
    320              }
    321          }
   \                     ??Uart_BuildTail_6:
   \   00000192   9189               LD      R24, Y+
   \   00000194   91A9               LD      R26, Y+
   \   00000196   91B9               LD      R27, Y+
   \   00000198   9508               RET
   \   0000019A                      REQUIRE _A_PORTE
    322          
    323          /*************************************************************************
    324          *
    325          * Build datablock for card status
    326          *
    327          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    328          void BuildStatusData(char ch) {
   \                     BuildStatusData:
   \   00000000   927A               ST      -Y, R7
   \   00000002   926A               ST      -Y, R6
   \   00000004   925A               ST      -Y, R5
   \   00000006   924A               ST      -Y, R4
   \   00000008   93BA               ST      -Y, R27
   \   0000000A   93AA               ST      -Y, R26
   \   0000000C   939A               ST      -Y, R25
   \   0000000E   938A               ST      -Y, R24
   \   00000010                      REQUIRE ?Register_R4_is_cg_reg
   \   00000010                      REQUIRE ?Register_R5_is_cg_reg
   \   00000010                      REQUIRE ?Register_R6_is_cg_reg
   \   00000010                      REQUIRE ?Register_R7_is_cg_reg
    329          
    330              short ntna;
    331              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000010   2F40               MOV     R20, R16
   \   00000012   EF2D               LDI     R18, 253
   \   00000014   E031               LDI     R19, 1
   \   00000016   9F43               MUL     R20, R19
   \   00000018   2D50               MOV     R21, R0
   \   0000001A   9F42               MUL     R20, R18
   \   0000001C   0D51               ADD     R21, R1
   \   0000001E   ....               LDI     R24, LOW(UART)
   \   00000020   ....               LDI     R25, (UART) >> 8
   \   00000022   0D80               ADD     R24, R0
   \   00000024   1F95               ADC     R25, R21
   \   00000026   01FC               MOVW    R31:R30, R25:R24
   \   00000028   54E2               SUBI    R30, 66
   \   0000002A   4FFE               SBCI    R31, 254
   \   0000002C   8330               ST      Z, R19
    332          
    333              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STATUS & 0xff;
   \   0000002E   01DC               MOVW    R27:R26, R25:R24
   \   00000030   5EAD               SUBI    R26, 237
   \   00000032   4FBE               SBCI    R27, 254
   \   00000034   912D               LD      R18, X+
   \   00000036   913C               LD      R19, X
   \   00000038   9711               SBIW    R27:R26, 1
   \   0000003A   01F9               MOVW    R31:R30, R19:R18
   \   0000003C   9631               ADIW    R31:R30, 1
   \   0000003E   93ED               ST      X+, R30
   \   00000040   93FC               ST      X, R31
   \   00000042   9711               SBIW    R27:R26, 1
   \   00000044   01FC               MOVW    R31:R30, R25:R24
   \   00000046   0FE2               ADD     R30, R18
   \   00000048   1FF3               ADC     R31, R19
   \   0000004A   EE19               LDI     R17, 233
   \   0000004C   8310               ST      Z, R17
    334              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STATUS >> 8;
   \   0000004E   912D               LD      R18, X+
   \   00000050   913C               LD      R19, X
   \   00000052   9711               SBIW    R27:R26, 1
   \   00000054   01F9               MOVW    R31:R30, R19:R18
   \   00000056   9631               ADIW    R31:R30, 1
   \   00000058   93ED               ST      X+, R30
   \   0000005A   93FC               ST      X, R31
   \   0000005C   9711               SBIW    R27:R26, 1
   \   0000005E   01FC               MOVW    R31:R30, R25:R24
   \   00000060   0FE2               ADD     R30, R18
   \   00000062   1FF3               ADC     R31, R19
   \   00000064   E013               LDI     R17, 3
   \   00000066   8310               ST      Z, R17
    335              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000068   906D               LD      R6, X+
   \   0000006A   907C               LD      R7, X
   \   0000006C   9711               SBIW    R27:R26, 1
    336              UART[ch].TxFirst += 2;                                      // two byte length
   \   0000006E   912D               LD      R18, X+
   \   00000070   913C               LD      R19, X
   \   00000072   5F2E               SUBI    R18, 254
   \   00000074   4F3F               SBCI    R19, 255
   \   00000076   933C               ST      X, R19
   \   00000078   932E               ST      -X, R18
    337              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ch;               // channel
   \   0000007A   912D               LD      R18, X+
   \   0000007C   913C               LD      R19, X
   \   0000007E   9711               SBIW    R27:R26, 1
   \   00000080   01F9               MOVW    R31:R30, R19:R18
   \   00000082   9631               ADIW    R31:R30, 1
   \   00000084   93ED               ST      X+, R30
   \   00000086   93FC               ST      X, R31
   \   00000088   9711               SBIW    R27:R26, 1
   \   0000008A   01FC               MOVW    R31:R30, R25:R24
   \   0000008C   0FE2               ADD     R30, R18
   \   0000008E   1FF3               ADC     R31, R19
   \   00000090   8340               ST      Z, R20
    338              UART[ch].pTxBuffer[UART[ch].TxFirst++] = DEVICE_IO + UnitID;   // Product ID
   \   00000092   912D               LD      R18, X+
   \   00000094   913C               LD      R19, X
   \   00000096   9711               SBIW    R27:R26, 1
   \   00000098   01F9               MOVW    R31:R30, R19:R18
   \   0000009A   9631               ADIW    R31:R30, 1
   \   0000009C   93ED               ST      X+, R30
   \   0000009E   93FC               ST      X, R31
   \   000000A0   9711               SBIW    R27:R26, 1
   \   000000A2   9100....           LDS     R16, UnitID
   \   000000A6   5F00               SUBI    R16, 240
   \   000000A8   01FC               MOVW    R31:R30, R25:R24
   \   000000AA   0FE2               ADD     R30, R18
   \   000000AC   1FF3               ADC     R31, R19
   \   000000AE   8300               ST      Z, R16
    339              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MyAddress();           // unit adddress
   \   000000B0   904D               LD      R4, X+
   \   000000B2   905C               LD      R5, X
   \   000000B4   9711               SBIW    R27:R26, 1
   \   000000B6   01F2               MOVW    R31:R30, R5:R4
   \   000000B8   9631               ADIW    R31:R30, 1
   \   000000BA   93ED               ST      X+, R30
   \   000000BC   93FC               ST      X, R31
   \   000000BE   9711               SBIW    R27:R26, 1
   \   000000C0   ........           CALL    MyAddress
   \   000000C4   01FC               MOVW    R31:R30, R25:R24
   \   000000C6   0DE4               ADD     R30, R4
   \   000000C8   1DF5               ADC     R31, R5
   \   000000CA   8300               ST      Z, R16
    340              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROG_VERSION;       // software version */
   \   000000CC   910D               LD      R16, X+
   \   000000CE   911C               LD      R17, X
   \   000000D0   9711               SBIW    R27:R26, 1
   \   000000D2   01F8               MOVW    R31:R30, R17:R16
   \   000000D4   9631               ADIW    R31:R30, 1
   \   000000D6   93ED               ST      X+, R30
   \   000000D8   93FC               ST      X, R31
   \   000000DA   9711               SBIW    R27:R26, 1
   \   000000DC   01FC               MOVW    R31:R30, R25:R24
   \   000000DE   0FE0               ADD     R30, R16
   \   000000E0   1FF1               ADC     R31, R17
   \   000000E2   E20E               LDI     R16, 46
   \   000000E4   8300               ST      Z, R16
    341              UART[ch].pTxBuffer[UART[ch].TxFirst++] = COMP_VERSION;        // cpmpability version
   \   000000E6   910D               LD      R16, X+
   \   000000E8   911C               LD      R17, X
   \   000000EA   9711               SBIW    R27:R26, 1
   \   000000EC   01F8               MOVW    R31:R30, R17:R16
   \   000000EE   9631               ADIW    R31:R30, 1
   \   000000F0   93ED               ST      X+, R30
   \   000000F2   93FC               ST      X, R31
   \   000000F4   9711               SBIW    R27:R26, 1
   \   000000F6   01FC               MOVW    R31:R30, R25:R24
   \   000000F8   0FE0               ADD     R30, R16
   \   000000FA   1FF1               ADC     R31, R17
   \   000000FC   E001               LDI     R16, 1
   \   000000FE   8300               ST      Z, R16
    342              UART[ch].pTxBuffer[UART[ch].TxFirst++] = STORE_VERSION;        // cpmpability version
   \   00000100   910D               LD      R16, X+
   \   00000102   911C               LD      R17, X
   \   00000104   9711               SBIW    R27:R26, 1
   \   00000106   01F8               MOVW    R31:R30, R17:R16
   \   00000108   9631               ADIW    R31:R30, 1
   \   0000010A   93ED               ST      X+, R30
   \   0000010C   93FC               ST      X, R31
   \   0000010E   9711               SBIW    R27:R26, 1
   \   00000110   01FC               MOVW    R31:R30, R25:R24
   \   00000112   0FE0               ADD     R30, R16
   \   00000114   1FF1               ADC     R31, R17
   \   00000116   E002               LDI     R16, 2
   \   00000118   8300               ST      Z, R16
    343              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (RXSIZE_UART & 0xff);         // rx buffer size
   \   0000011A   910D               LD      R16, X+
   \   0000011C   911C               LD      R17, X
   \   0000011E   9711               SBIW    R27:R26, 1
   \   00000120   01F8               MOVW    R31:R30, R17:R16
   \   00000122   9631               ADIW    R31:R30, 1
   \   00000124   93ED               ST      X+, R30
   \   00000126   93FC               ST      X, R31
   \   00000128   9711               SBIW    R27:R26, 1
   \   0000012A   01FC               MOVW    R31:R30, R25:R24
   \   0000012C   0FE0               ADD     R30, R16
   \   0000012E   1FF1               ADC     R31, R17
   \   00000130   E906               LDI     R16, 150
   \   00000132   8300               ST      Z, R16
    344              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((RXSIZE_UART >> 8) & 0xff); // rx buffer size
   \   00000134   910D               LD      R16, X+
   \   00000136   911C               LD      R17, X
   \   00000138   9711               SBIW    R27:R26, 1
   \   0000013A   01F8               MOVW    R31:R30, R17:R16
   \   0000013C   9631               ADIW    R31:R30, 1
   \   0000013E   93ED               ST      X+, R30
   \   00000140   93FC               ST      X, R31
   \   00000142   9711               SBIW    R27:R26, 1
   \   00000144   01FC               MOVW    R31:R30, R25:R24
   \   00000146   0FE0               ADD     R30, R16
   \   00000148   1FF1               ADC     R31, R17
   \   0000014A   E000               LDI     R16, 0
   \   0000014C   8300               ST      Z, R16
    345              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TXSIZE_UART & 0xff);         // tx buffer size
   \   0000014E   910D               LD      R16, X+
   \   00000150   911C               LD      R17, X
   \   00000152   9711               SBIW    R27:R26, 1
   \   00000154   01F8               MOVW    R31:R30, R17:R16
   \   00000156   9631               ADIW    R31:R30, 1
   \   00000158   93ED               ST      X+, R30
   \   0000015A   93FC               ST      X, R31
   \   0000015C   9711               SBIW    R27:R26, 1
   \   0000015E   01FC               MOVW    R31:R30, R25:R24
   \   00000160   0FE0               ADD     R30, R16
   \   00000162   1FF1               ADC     R31, R17
   \   00000164   E103               LDI     R16, 19
   \   00000166   8300               ST      Z, R16
    346              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);  // tx buffer size
   \   00000168   910D               LD      R16, X+
   \   0000016A   911C               LD      R17, X
   \   0000016C   9711               SBIW    R27:R26, 1
   \   0000016E   01F8               MOVW    R31:R30, R17:R16
   \   00000170   9631               ADIW    R31:R30, 1
   \   00000172   93ED               ST      X+, R30
   \   00000174   93FC               ST      X, R31
   \   00000176   9711               SBIW    R27:R26, 1
   \   00000178   01FC               MOVW    R31:R30, R25:R24
   \   0000017A   0FE0               ADD     R30, R16
   \   0000017C   1FF1               ADC     R31, R17
   \   0000017E   E001               LDI     R16, 1
   \   00000180   8300               ST      Z, R16
    347              UART[ch].pTxBuffer[UART[ch].TxFirst++] = RestartStatus;                  // restart flag
   \   00000182   910D               LD      R16, X+
   \   00000184   911C               LD      R17, X
   \   00000186   9711               SBIW    R27:R26, 1
   \   00000188   01F8               MOVW    R31:R30, R17:R16
   \   0000018A   9631               ADIW    R31:R30, 1
   \   0000018C   93ED               ST      X+, R30
   \   0000018E   93FC               ST      X, R31
   \   00000190   9711               SBIW    R27:R26, 1
   \   00000192   9120....           LDS     R18, RestartStatus
   \   00000196   01FC               MOVW    R31:R30, R25:R24
   \   00000198   0FE0               ADD     R30, R16
   \   0000019A   1FF1               ADC     R31, R17
   \   0000019C   8320               ST      Z, R18
    348              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROGTYPE_APP;                // Application program
   \   0000019E   910D               LD      R16, X+
   \   000001A0   911C               LD      R17, X
   \   000001A2   9711               SBIW    R27:R26, 1
   \   000001A4   01F8               MOVW    R31:R30, R17:R16
   \   000001A6   9631               ADIW    R31:R30, 1
   \   000001A8   93ED               ST      X+, R30
   \   000001AA   93FC               ST      X, R31
   \   000001AC   9711               SBIW    R27:R26, 1
   \   000001AE   01FC               MOVW    R31:R30, R25:R24
   \   000001B0   0FE0               ADD     R30, R16
   \   000001B2   1FF1               ADC     R31, R17
   \   000001B4   E001               LDI     R16, 1
   \   000001B6   8300               ST      Z, R16
    349          
    350              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000001B8   0D86               ADD     R24, R6
   \   000001BA   1D97               ADC     R25, R7
   \   000001BC   01FC               MOVW    R31:R30, R25:R24
   \   000001BE   910D               LD      R16, X+
   \   000001C0   911C               LD      R17, X
   \   000001C2   9711               SBIW    R27:R26, 1
   \   000001C4   1906               SUB     R16, R6
   \   000001C6   5002               SUBI    R16, 2
   \   000001C8   8300               ST      Z, R16
    351              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000001CA   918D               LD      R24, X+
   \   000001CC   919C               LD      R25, X
   \   000001CE   1986               SUB     R24, R6
   \   000001D0   0997               SBC     R25, R7
   \   000001D2   9702               SBIW    R25:R24, 2
   \   000001D4   8391               STD     Z+1, R25
    352          
    353              RestartStatus = 0;                                                       // set reset stat to 0 = read
   \   000001D6   E000               LDI     R16, 0
   \   000001D8   9300....           STS     RestartStatus, R16
    354          }
   \   000001DC                      REQUIRE ?Subroutine1
   \   000001DC                      ;               // Fall through to label ?Subroutine1

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   9189               LD      R24, Y+
   \   00000002                      REQUIRE ??Subroutine7_0
   \   00000002                      ;               // Fall through to label ??Subroutine7_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine7_0:
   \   00000000   9199               LD      R25, Y+
   \   00000002   91A9               LD      R26, Y+
   \   00000004   91B9               LD      R27, Y+
   \   00000006   9049               LD      R4, Y+
   \   00000008   9059               LD      R5, Y+
   \   0000000A   9069               LD      R6, Y+
   \   0000000C   9079               LD      R7, Y+
   \   0000000E   9508               RET
    355          
    356          /*************************************************************************
    357          *
    358          * Build EEPROM data package
    359          *
    360          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    361          void BuildEEPROMData(char ch, short pointer) {
   \                     BuildEEPROMData:
   \   00000000   927A               ST      -Y, R7
   \   00000002   926A               ST      -Y, R6
   \   00000004   925A               ST      -Y, R5
   \   00000006   924A               ST      -Y, R4
   \   00000008   93BA               ST      -Y, R27
   \   0000000A   93AA               ST      -Y, R26
   \   0000000C   939A               ST      -Y, R25
   \   0000000E   938A               ST      -Y, R24
   \   00000010                      REQUIRE ?Register_R4_is_cg_reg
   \   00000010                      REQUIRE ?Register_R5_is_cg_reg
   \   00000010                      REQUIRE ?Register_R6_is_cg_reg
   \   00000010                      REQUIRE ?Register_R7_is_cg_reg
    362          
    363              short ntna;
    364              char channel;
    365              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000010   2F40               MOV     R20, R16
   \   00000012   EF0D               LDI     R16, 253
   \   00000014   E011               LDI     R17, 1
   \   00000016   9F41               MUL     R20, R17
   \   00000018   2D50               MOV     R21, R0
   \   0000001A   9F40               MUL     R20, R16
   \   0000001C   0D51               ADD     R21, R1
   \   0000001E   ....               LDI     R24, LOW(UART)
   \   00000020   ....               LDI     R25, (UART) >> 8
   \   00000022   0D80               ADD     R24, R0
   \   00000024   1F95               ADC     R25, R21
   \   00000026   01FC               MOVW    R31:R30, R25:R24
   \   00000028   54E2               SUBI    R30, 66
   \   0000002A   4FFE               SBCI    R31, 254
   \   0000002C   8310               ST      Z, R17
    366          
    367              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_EEPROM_DATA & 0xff;
   \   0000002E   01DC               MOVW    R27:R26, R25:R24
   \   00000030   5EAD               SUBI    R26, 237
   \   00000032   4FBE               SBCI    R27, 254
   \   00000034   910D               LD      R16, X+
   \   00000036   911C               LD      R17, X
   \   00000038   9711               SBIW    R27:R26, 1
   \   0000003A   01F8               MOVW    R31:R30, R17:R16
   \   0000003C   9631               ADIW    R31:R30, 1
   \   0000003E   93ED               ST      X+, R30
   \   00000040   93FC               ST      X, R31
   \   00000042   9711               SBIW    R27:R26, 1
   \   00000044   01FC               MOVW    R31:R30, R25:R24
   \   00000046   0FE0               ADD     R30, R16
   \   00000048   1FF1               ADC     R31, R17
   \   0000004A   E309               LDI     R16, 57
   \   0000004C   8300               ST      Z, R16
    368              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_EEPROM_DATA >> 8;
   \   0000004E   910D               LD      R16, X+
   \   00000050   911C               LD      R17, X
   \   00000052   9711               SBIW    R27:R26, 1
   \   00000054   01F8               MOVW    R31:R30, R17:R16
   \   00000056   9631               ADIW    R31:R30, 1
   \   00000058   93ED               ST      X+, R30
   \   0000005A   93FC               ST      X, R31
   \   0000005C   9711               SBIW    R27:R26, 1
   \   0000005E   01FC               MOVW    R31:R30, R25:R24
   \   00000060   0FE0               ADD     R30, R16
   \   00000062   1FF1               ADC     R31, R17
   \   00000064   E004               LDI     R16, 4
   \   00000066   8300               ST      Z, R16
    369              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000068   906D               LD      R6, X+
   \   0000006A   907C               LD      R7, X
   \   0000006C   9711               SBIW    R27:R26, 1
    370              UART[ch].TxFirst += 2;                                      // two byte length
   \   0000006E   910D               LD      R16, X+
   \   00000070   911C               LD      R17, X
   \   00000072   5F0E               SUBI    R16, 254
   \   00000074   4F1F               SBCI    R17, 255
   \   00000076   931C               ST      X, R17
   \   00000078   930E               ST      -X, R16
    371          
    372              channel = UART[ch].pRxBuffer[pointer];
   \   0000007A   01FC               MOVW    R31:R30, R25:R24
   \   0000007C   0FE2               ADD     R30, R18
   \   0000007E   1FF3               ADC     R31, R19
   \   00000080   5EE5               SUBI    R30, 229
   \   00000082   4FFE               SBCI    R31, 254
   \   00000084   8100               LD      R16, Z
    373              UART[ch].pTxBuffer[UART[ch].TxFirst++] = channel; //channel
   \   00000086   912D               LD      R18, X+
   \   00000088   913C               LD      R19, X
   \   0000008A   9711               SBIW    R27:R26, 1
   \   0000008C   01F9               MOVW    R31:R30, R19:R18
   \   0000008E   9631               ADIW    R31:R30, 1
   \   00000090   93ED               ST      X+, R30
   \   00000092   93FC               ST      X, R31
   \   00000094   9711               SBIW    R27:R26, 1
   \   00000096   01FC               MOVW    R31:R30, R25:R24
   \   00000098   0FE2               ADD     R30, R18
   \   0000009A   1FF3               ADC     R31, R19
   \   0000009C   8300               ST      Z, R16
    374          
    375              ReadEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&UART[ch].pTxBuffer[UART[ch].TxFirst]);
   \   0000009E   E018               LDI     R17, 8
   \   000000A0   9F01               MUL     R16, R17
   \   000000A2   0120               MOVW    R5:R4, R1:R0
   \   000000A4   910D               LD      R16, X+
   \   000000A6   911C               LD      R17, X
   \   000000A8   9711               SBIW    R27:R26, 1
   \   000000AA   01AC               MOVW    R21:R20, R25:R24
   \   000000AC   0F40               ADD     R20, R16
   \   000000AE   1F51               ADC     R21, R17
   \   000000B0   E024               LDI     R18, 4
   \   000000B2   0180               MOVW    R17:R16, R1:R0
   \   000000B4   ........           CALL    ReadEEPROMBuffer
    376              UART[ch].TxFirst += sizeof(float);
   \   000000B8   910D               LD      R16, X+
   \   000000BA   911C               LD      R17, X
   \   000000BC   5F0C               SUBI    R16, 252
   \   000000BE   4F1F               SBCI    R17, 255
   \   000000C0   931C               ST      X, R17
   \   000000C2   930E               ST      -X, R16
    377              ReadEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&UART[ch].pTxBuffer[UART[ch].TxFirst]);
   \   000000C4   910D               LD      R16, X+
   \   000000C6   911C               LD      R17, X
   \   000000C8   9711               SBIW    R27:R26, 1
   \   000000CA   01AC               MOVW    R21:R20, R25:R24
   \   000000CC   0F40               ADD     R20, R16
   \   000000CE   1F51               ADC     R21, R17
   \   000000D0   E024               LDI     R18, 4
   \   000000D2   0E42               ADD     R4, R18
   \   000000D4   E000               LDI     R16, 0
   \   000000D6   1E50               ADC     R5, R16
   \   000000D8   0182               MOVW    R17:R16, R5:R4
   \   000000DA   ........           CALL    ReadEEPROMBuffer
    378              UART[ch].TxFirst += sizeof(float);
   \   000000DE   910D               LD      R16, X+
   \   000000E0   911C               LD      R17, X
   \   000000E2   5F0C               SUBI    R16, 252
   \   000000E4   4F1F               SBCI    R17, 255
   \   000000E6   931C               ST      X, R17
   \   000000E8   930E               ST      -X, R16
    379          
    380              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000EA   0D86               ADD     R24, R6
   \   000000EC   1D97               ADC     R25, R7
   \   000000EE   01FC               MOVW    R31:R30, R25:R24
   \   000000F0   910D               LD      R16, X+
   \   000000F2   911C               LD      R17, X
   \   000000F4   9711               SBIW    R27:R26, 1
   \   000000F6   1906               SUB     R16, R6
   \   000000F8   5002               SUBI    R16, 2
   \   000000FA   8300               ST      Z, R16
    381              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000FC   918D               LD      R24, X+
   \   000000FE   919C               LD      R25, X
   \   00000100   1986               SUB     R24, R6
   \   00000102   0997               SBC     R25, R7
   \   00000104   9702               SBIW    R25:R24, 2
   \   00000106   8391               STD     Z+1, R25
    382          }
   \   00000108   ....               RJMP    ?Subroutine1
    383          
    384          
    385          /*************************************************************************
    386          *
    387          * Build datablock for Internal AD
    388          *
    389          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0F02               ADD     R16, R18
   \   00000002   1F13               ADC     R17, R19
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \   00000006   8100               LD      R16, Z
   \   00000008   8111               LDD     R17, Z+1
   \   0000000A   1B02               SUB     R16, R18
   \   0000000C   5002               SUBI    R16, 2
   \   0000000E   930C               ST      X, R16
   \   00000010   8180               LD      R24, Z
   \   00000012   8191               LDD     R25, Z+1
   \   00000014   1B82               SUB     R24, R18
   \   00000016   0B93               SBC     R25, R19
   \   00000018   9702               SBIW    R25:R24, 2
   \   0000001A   01FD               MOVW    R31:R30, R27:R26
   \   0000001C                      REQUIRE ??Subroutine5_0
   \   0000001C                      ;               // Fall through to label ??Subroutine5_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine5_0:
   \   00000000   8391               STD     Z+1, R25
   \   00000002                      REQUIRE ??Subroutine6_0
   \   00000002                      ;               // Fall through to label ??Subroutine6_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine6_0:
   \   00000000   01C1               MOVW    R25:R24, R3:R2
   \   00000002   91A9               LD      R26, Y+
   \   00000004   91B9               LD      R27, Y+
   \   00000006   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    390          void BuildADInt(char ch, short pointer) {
   \                     BuildADInt:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   011C               MOVW    R3:R2, R25:R24
    391          
    392              short ntna, i;
    393              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000006   2F20               MOV     R18, R16
   \   00000008   EF0D               LDI     R16, 253
   \   0000000A   E011               LDI     R17, 1
   \   0000000C   9F21               MUL     R18, R17
   \   0000000E   2D30               MOV     R19, R0
   \   00000010   9F20               MUL     R18, R16
   \   00000012   0D31               ADD     R19, R1
   \   00000014   ....               LDI     R16, LOW(UART)
   \   00000016   ....               LDI     R17, (UART) >> 8
   \   00000018   0D00               ADD     R16, R0
   \   0000001A   1F13               ADC     R17, R19
   \   0000001C   01F8               MOVW    R31:R30, R17:R16
   \   0000001E   54E2               SUBI    R30, 66
   \   00000020   4FFE               SBCI    R31, 254
   \   00000022   E021               LDI     R18, 1
   \   00000024   8320               ST      Z, R18
    394          
    395              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_INT_DATA & 0xff;
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   5EED               SUBI    R30, 237
   \   0000002A   4FFE               SBCI    R31, 254
   \   0000002C   8120               LD      R18, Z
   \   0000002E   8131               LDD     R19, Z+1
   \   00000030   01C9               MOVW    R25:R24, R19:R18
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   8380               ST      Z, R24
   \   00000036   8391               STD     Z+1, R25
   \   00000038   01D8               MOVW    R27:R26, R17:R16
   \   0000003A   0FA2               ADD     R26, R18
   \   0000003C   1FB3               ADC     R27, R19
   \   0000003E   E423               LDI     R18, 67
   \   00000040   932C               ST      X, R18
    396              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_INT_DATA >> 8;
   \   00000042   8120               LD      R18, Z
   \   00000044   8131               LDD     R19, Z+1
   \   00000046   01C9               MOVW    R25:R24, R19:R18
   \   00000048   9601               ADIW    R25:R24, 1
   \   0000004A   8380               ST      Z, R24
   \   0000004C   8391               STD     Z+1, R25
   \   0000004E   01D8               MOVW    R27:R26, R17:R16
   \   00000050   0FA2               ADD     R26, R18
   \   00000052   1FB3               ADC     R27, R19
   \   00000054   E024               LDI     R18, 4
   \   00000056   932C               ST      X, R18
    397              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000058   8120               LD      R18, Z
   \   0000005A   8131               LDD     R19, Z+1
    398              UART[ch].TxFirst += 2;                                      // two byte length
   \   0000005C   8140               LD      R20, Z
   \   0000005E   8151               LDD     R21, Z+1
   \   00000060   5F4E               SUBI    R20, 254
   \   00000062   4F5F               SBCI    R21, 255
   \   00000064   8340               ST      Z, R20
   \   00000066   8351               STD     Z+1, R21
    399          
    400              for (i = 0; i < 3; i++) {
   \   00000068   ....               LDI     R24, LOW(ADInt)
   \   0000006A   ....               LDI     R25, (ADInt) >> 8
   \   0000006C   E043               LDI     R20, 3
    401                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ADInt.Result[i];
   \                     ??BuildADInt_0:
   \   0000006E   8000               LD      R0, Z
   \   00000070   8011               LDD     R1, Z+1
   \   00000072   01D0               MOVW    R27:R26, R1:R0
   \   00000074   9611               ADIW    R27:R26, 1
   \   00000076   83A0               ST      Z, R26
   \   00000078   83B1               STD     Z+1, R27
   \   0000007A   01DC               MOVW    R27:R26, R25:R24
   \   0000007C   916D               LD      R22, X+
   \   0000007E   917C               LD      R23, X
   \   00000080   01D8               MOVW    R27:R26, R17:R16
   \   00000082   0DA0               ADD     R26, R0
   \   00000084   1DB1               ADC     R27, R1
   \   00000086   936C               ST      X, R22
    402                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ADInt.Result[i] >> 8;   // ADresult
   \   00000088   8000               LD      R0, Z
   \   0000008A   8011               LDD     R1, Z+1
   \   0000008C   01D0               MOVW    R27:R26, R1:R0
   \   0000008E   9611               ADIW    R27:R26, 1
   \   00000090   83A0               ST      Z, R26
   \   00000092   83B1               STD     Z+1, R27
   \   00000094   01D8               MOVW    R27:R26, R17:R16
   \   00000096   0DA0               ADD     R26, R0
   \   00000098   1DB1               ADC     R27, R1
   \   0000009A   937C               ST      X, R23
    403              }
   \   0000009C   9602               ADIW    R25:R24, 2
   \   0000009E   954A               DEC     R20
   \   000000A0   F731               BRNE    ??BuildADInt_0
    404          
    405              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000A2   ....               RJMP    ?Subroutine0
    406              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
    407          
    408          }
    409          
    410          
    411          /*************************************************************************
    412          *
    413          * Build datablock for eeprom on ADcard
    414          *
    415          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    416          void BuildADEpromdata(char ch, char portch) {
   \                     BuildADEpromdata:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   011C               MOVW    R3:R2, R25:R24
   \   00000006   2F61               MOV     R22, R17
    417          
    418              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000008   2F40               MOV     R20, R16
   \   0000000A   EF0D               LDI     R16, 253
   \   0000000C   E011               LDI     R17, 1
   \   0000000E   9F41               MUL     R20, R17
   \   00000010   2D50               MOV     R21, R0
   \   00000012   9F40               MUL     R20, R16
   \   00000014   0D51               ADD     R21, R1
   \   00000016   ....               LDI     R18, LOW(UART)
   \   00000018   ....               LDI     R19, (UART) >> 8
   \   0000001A   0D20               ADD     R18, R0
   \   0000001C   1F35               ADC     R19, R21
   \   0000001E   01F9               MOVW    R31:R30, R19:R18
   \   00000020   54E2               SUBI    R30, 66
   \   00000022   4FFE               SBCI    R31, 254
   \   00000024   8310               ST      Z, R17
    419          
    420              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_ADBUF & 0xff;
   \   00000026   01F9               MOVW    R31:R30, R19:R18
   \   00000028   5EED               SUBI    R30, 237
   \   0000002A   4FFE               SBCI    R31, 254
   \   0000002C   8100               LD      R16, Z
   \   0000002E   8111               LDD     R17, Z+1
   \   00000030   01C8               MOVW    R25:R24, R17:R16
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   8380               ST      Z, R24
   \   00000036   8391               STD     Z+1, R25
   \   00000038   01D9               MOVW    R27:R26, R19:R18
   \   0000003A   0FA0               ADD     R26, R16
   \   0000003C   1FB1               ADC     R27, R17
   \   0000003E   E809               LDI     R16, 137
   \   00000040   930C               ST      X, R16
    421              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_ADBUF >> 8;
   \   00000042   8100               LD      R16, Z
   \   00000044   8111               LDD     R17, Z+1
   \   00000046   01C8               MOVW    R25:R24, R17:R16
   \   00000048   9601               ADIW    R25:R24, 1
   \   0000004A   8380               ST      Z, R24
   \   0000004C   8391               STD     Z+1, R25
   \   0000004E   01D9               MOVW    R27:R26, R19:R18
   \   00000050   0FA0               ADD     R26, R16
   \   00000052   1FB1               ADC     R27, R17
   \   00000054   E004               LDI     R16, 4
   \   00000056   930C               ST      X, R16
    422              short ntna = UART[ch].TxFirst;                                    // remember index
   \   00000058   8140               LD      R20, Z
   \   0000005A   8151               LDD     R21, Z+1
    423              UART[ch].TxFirst += 2;                                      // two byte length
   \   0000005C   8100               LD      R16, Z
   \   0000005E   8111               LDD     R17, Z+1
   \   00000060   5F0E               SUBI    R16, 254
   \   00000062   4F1F               SBCI    R17, 255
   \   00000064   8300               ST      Z, R16
   \   00000066   8311               STD     Z+1, R17
    424          
    425              for (short i = 0; i < 44; i++) {
   \   00000068   ....               LDI     R16, LOW((TData + 1428))
   \   0000006A   ....               LDI     R17, HIGH((TData + 1428))
   \   0000006C   E372               LDI     R23, 50
   \   0000006E   9F67               MUL     R22, R23
   \   00000070   0D00               ADD     R16, R0
   \   00000072   1D11               ADC     R17, R1
   \   00000074   E26C               LDI     R22, 44
    426                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.FromTargetBuffer[portch][i];
   \                     ??BuildADEpromdata_0:
   \   00000076   8000               LD      R0, Z
   \   00000078   8011               LDD     R1, Z+1
   \   0000007A   01C0               MOVW    R25:R24, R1:R0
   \   0000007C   9601               ADIW    R25:R24, 1
   \   0000007E   8380               ST      Z, R24
   \   00000080   8391               STD     Z+1, R25
   \   00000082   01D8               MOVW    R27:R26, R17:R16
   \   00000084   917D               LD      R23, X+
   \   00000086   018D               MOVW    R17:R16, R27:R26
   \   00000088   01D9               MOVW    R27:R26, R19:R18
   \   0000008A   0DA0               ADD     R26, R0
   \   0000008C   1DB1               ADC     R27, R1
   \   0000008E   937C               ST      X, R23
    427              }
   \   00000090   956A               DEC     R22
   \   00000092   F789               BRNE    ??BuildADEpromdata_0
    428              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   00000094   0F24               ADD     R18, R20
   \   00000096   1F35               ADC     R19, R21
   \   00000098   01D9               MOVW    R27:R26, R19:R18
   \   0000009A   8100               LD      R16, Z
   \   0000009C   8111               LDD     R17, Z+1
   \   0000009E   1B04               SUB     R16, R20
   \   000000A0   5002               SUBI    R16, 2
   \   000000A2   930C               ST      X, R16
    429              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000A4   8180               LD      R24, Z
   \   000000A6   8191               LDD     R25, Z+1
   \   000000A8   1B84               SUB     R24, R20
   \   000000AA   0B95               SBC     R25, R21
   \   000000AC   9702               SBIW    R25:R24, 2
   \   000000AE   01F9               MOVW    R31:R30, R19:R18
   \   000000B0   ....               RJMP    ??Subroutine5_0
    430          
    431          }
    432          
    433          /*************************************************************************
    434          *
    435          * Build datablock for WHData on ADcard
    436          *
    437          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    438          void BuildWHdata(char ch, short pointer) {
   \                     BuildWHdata:
   \   00000000   927A               ST      -Y, R7
   \   00000002   926A               ST      -Y, R6
   \   00000004   925A               ST      -Y, R5
   \   00000006   924A               ST      -Y, R4
   \   00000008   93BA               ST      -Y, R27
   \   0000000A   93AA               ST      -Y, R26
   \   0000000C   939A               ST      -Y, R25
   \   0000000E   938A               ST      -Y, R24
   \   00000010                      REQUIRE ?Register_R4_is_cg_reg
   \   00000010                      REQUIRE ?Register_R5_is_cg_reg
   \   00000010                      REQUIRE ?Register_R6_is_cg_reg
   \   00000010                      REQUIRE ?Register_R7_is_cg_reg
   \   00000010   2F40               MOV     R20, R16
   \   00000012   0189               MOVW    R17:R16, R19:R18
    439          
    440              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000014   EF2D               LDI     R18, 253
   \   00000016   E031               LDI     R19, 1
   \   00000018   9F43               MUL     R20, R19
   \   0000001A   2D50               MOV     R21, R0
   \   0000001C   9F42               MUL     R20, R18
   \   0000001E   0D51               ADD     R21, R1
   \   00000020   ....               LDI     R18, LOW(UART)
   \   00000022   ....               LDI     R19, (UART) >> 8
   \   00000024   0D20               ADD     R18, R0
   \   00000026   1F35               ADC     R19, R21
   \   00000028   01F9               MOVW    R31:R30, R19:R18
   \   0000002A   54E2               SUBI    R30, 66
   \   0000002C   4FFE               SBCI    R31, 254
   \   0000002E   E041               LDI     R20, 1
   \   00000030   8340               ST      Z, R20
    441          
    442              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_SND_RS4_WHBUF & 0xff;
   \   00000032   01F9               MOVW    R31:R30, R19:R18
   \   00000034   5EED               SUBI    R30, 237
   \   00000036   4FFE               SBCI    R31, 254
   \   00000038   8140               LD      R20, Z
   \   0000003A   8151               LDD     R21, Z+1
   \   0000003C   01CA               MOVW    R25:R24, R21:R20
   \   0000003E   9601               ADIW    R25:R24, 1
   \   00000040   8380               ST      Z, R24
   \   00000042   8391               STD     Z+1, R25
   \   00000044   01D9               MOVW    R27:R26, R19:R18
   \   00000046   0FA4               ADD     R26, R20
   \   00000048   1FB5               ADC     R27, R21
   \   0000004A   E94C               LDI     R20, 156
   \   0000004C   934C               ST      X, R20
    443              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_SND_RS4_WHBUF >> 8;
   \   0000004E   8140               LD      R20, Z
   \   00000050   8151               LDD     R21, Z+1
   \   00000052   01CA               MOVW    R25:R24, R21:R20
   \   00000054   9601               ADIW    R25:R24, 1
   \   00000056   8380               ST      Z, R24
   \   00000058   8391               STD     Z+1, R25
   \   0000005A   01D9               MOVW    R27:R26, R19:R18
   \   0000005C   0FA4               ADD     R26, R20
   \   0000005E   1FB5               ADC     R27, R21
   \   00000060   E044               LDI     R20, 4
   \   00000062   934C               ST      X, R20
    444              short ntna = UART[ch].TxFirst;                          // remember index
   \   00000064   8140               LD      R20, Z
   \   00000066   8151               LDD     R21, Z+1
    445              UART[ch].TxFirst += 2;                                  // two byte length
   \   00000068   8160               LD      R22, Z
   \   0000006A   8171               LDD     R23, Z+1
   \   0000006C   5F6E               SUBI    R22, 254
   \   0000006E   4F7F               SBCI    R23, 255
   \   00000070   8360               ST      Z, R22
   \   00000072   8371               STD     Z+1, R23
    446          
    447              OS_EnterRegion();
   \   00000074   9160....           LDS     R22, OS_Global
   \   00000078   9563               INC     R22
   \   0000007A   9360....           STS     OS_Global, R22
    448              for (short i = 0; i < 4; i++) {
   \   0000007E   E080               LDI     R24, 0
   \   00000080   E090               LDI     R25, 0
   \   00000082   E064               LDI     R22, 4
   \   00000084   0F02               ADD     R16, R18
   \   00000086   1F13               ADC     R17, R19
   \   00000088   5E05               SUBI    R16, 229
   \   0000008A   4F1E               SBCI    R17, 254
   \   0000008C   E078               LDI     R23, 8
    449                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.WTrackCnt[UART[ch].pRxBuffer[pointer]][i] & 0xff; // WashTrackcnt
   \                     ??BuildWHdata_0:
   \   0000008E   8060               LD      R6, Z
   \   00000090   8071               LDD     R7, Z+1
   \   00000092   01D3               MOVW    R27:R26, R7:R6
   \   00000094   9611               ADIW    R27:R26, 1
   \   00000096   83A0               ST      Z, R26
   \   00000098   83B1               STD     Z+1, R27
   \   0000009A   011C               MOVW    R3:R2, R25:R24
   \   0000009C   0C22               LSL     R2
   \   0000009E   1C33               ROL     R3
   \   000000A0   ....               LDI     R26, LOW((TData + 1179))
   \   000000A2   2E4A               MOV     R4, R26
   \   000000A4   ....               LDI     R26, HIGH((TData + 1179))
   \   000000A6   0C42               ADD     R4, R2
   \   000000A8   1DA3               ADC     R26, R3
   \   000000AA   2E5A               MOV     R5, R26
   \   000000AC   01D8               MOVW    R27:R26, R17:R16
   \   000000AE   900C               LD      R0, X
   \   000000B0   9E07               MUL     R0, R23
   \   000000B2   0C40               ADD     R4, R0
   \   000000B4   1C51               ADC     R5, R1
   \   000000B6   01D2               MOVW    R27:R26, R5:R4
   \   000000B8   900D               LD      R0, X+
   \   000000BA   01D9               MOVW    R27:R26, R19:R18
   \   000000BC   0DA6               ADD     R26, R6
   \   000000BE   1DB7               ADC     R27, R7
   \   000000C0   920C               ST      X, R0
    450                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.RS4.WTrackCnt[UART[ch].pRxBuffer[pointer]][i] >> 8) & 0xff; // WashTrackcnt
   \   000000C2   8040               LD      R4, Z
   \   000000C4   8051               LDD     R5, Z+1
   \   000000C6   01D2               MOVW    R27:R26, R5:R4
   \   000000C8   9611               ADIW    R27:R26, 1
   \   000000CA   83A0               ST      Z, R26
   \   000000CC   83B1               STD     Z+1, R27
   \   000000CE   ....               LDI     R26, LOW((TData + 1179))
   \   000000D0   2E6A               MOV     R6, R26
   \   000000D2   ....               LDI     R26, HIGH((TData + 1179))
   \   000000D4   0C62               ADD     R6, R2
   \   000000D6   1DA3               ADC     R26, R3
   \   000000D8   2E7A               MOV     R7, R26
   \   000000DA   01D8               MOVW    R27:R26, R17:R16
   \   000000DC   900C               LD      R0, X
   \   000000DE   9E07               MUL     R0, R23
   \   000000E0   0C60               ADD     R6, R0
   \   000000E2   1C71               ADC     R7, R1
   \   000000E4   01D3               MOVW    R27:R26, R7:R6
   \   000000E6   9611               ADIW    R27:R26, 1
   \   000000E8   900C               LD      R0, X
   \   000000EA   01D9               MOVW    R27:R26, R19:R18
   \   000000EC   0DA4               ADD     R26, R4
   \   000000EE   1DB5               ADC     R27, R5
   \   000000F0   920C               ST      X, R0
    451              }
   \   000000F2   9601               ADIW    R25:R24, 1
   \   000000F4   956A               DEC     R22
   \   000000F6   F659               BRNE    ??BuildWHdata_0
    452              UART[ch].pTxBuffer[UART[ch].TxFirst++] =  TData.RS4.LevelSwitch[UART[ch].pRxBuffer[pointer]];
   \   000000F8   8000               LD      R0, Z
   \   000000FA   8011               LDD     R1, Z+1
   \   000000FC   01C0               MOVW    R25:R24, R1:R0
   \   000000FE   9601               ADIW    R25:R24, 1
   \   00000100   8380               ST      Z, R24
   \   00000102   8391               STD     Z+1, R25
   \   00000104   01D8               MOVW    R27:R26, R17:R16
   \   00000106   91AC               LD      R26, X
   \   00000108   E0B0               LDI     R27, 0
   \   0000010A   ....               SUBI    R26, LOW((-(TData + 1243) & 0xFFFF))
   \   0000010C   ....               SBCI    R27, HIGH((-(TData + 1243) & 0xFFFF))
   \   0000010E   916C               LD      R22, X
   \   00000110   01D9               MOVW    R27:R26, R19:R18
   \   00000112   0DA0               ADD     R26, R0
   \   00000114   1DB1               ADC     R27, R1
   \   00000116   936C               ST      X, R22
    453              UART[ch].pTxBuffer[UART[ch].TxFirst++] =  TData.RS4.WTTime[UART[ch].pRxBuffer[pointer]] & 0xff; // WashTrackcnt
   \   00000118   8020               LD      R2, Z
   \   0000011A   8031               LDD     R3, Z+1
   \   0000011C   01C1               MOVW    R25:R24, R3:R2
   \   0000011E   9601               ADIW    R25:R24, 1
   \   00000120   8380               ST      Z, R24
   \   00000122   8391               STD     Z+1, R25
   \   00000124   01D8               MOVW    R27:R26, R17:R16
   \   00000126   916C               LD      R22, X
   \   00000128   E072               LDI     R23, 2
   \   0000012A   9F67               MUL     R22, R23
   \   0000012C   01D0               MOVW    R27:R26, R1:R0
   \   0000012E   ....               SUBI    R26, LOW((-(TData + 1251) & 0xFFFF))
   \   00000130   ....               SBCI    R27, HIGH((-(TData + 1251) & 0xFFFF))
   \   00000132   916D               LD      R22, X+
   \   00000134   01D9               MOVW    R27:R26, R19:R18
   \   00000136   0DA2               ADD     R26, R2
   \   00000138   1DB3               ADC     R27, R3
   \   0000013A   936C               ST      X, R22
    454              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.RS4.WTTime[UART[ch].pRxBuffer[pointer]] >> 8) & 0xff; // WashTrackcnt
   \   0000013C   8160               LD      R22, Z
   \   0000013E   8171               LDD     R23, Z+1
   \   00000140   01CB               MOVW    R25:R24, R23:R22
   \   00000142   9601               ADIW    R25:R24, 1
   \   00000144   8380               ST      Z, R24
   \   00000146   8391               STD     Z+1, R25
   \   00000148   01D8               MOVW    R27:R26, R17:R16
   \   0000014A   910C               LD      R16, X
   \   0000014C   E012               LDI     R17, 2
   \   0000014E   9F01               MUL     R16, R17
   \   00000150   01D0               MOVW    R27:R26, R1:R0
   \   00000152   ....               SUBI    R26, LOW((-(TData + 1251) & 0xFFFF))
   \   00000154   ....               SBCI    R27, HIGH((-(TData + 1251) & 0xFFFF))
   \   00000156   9611               ADIW    R27:R26, 1
   \   00000158   910C               LD      R16, X
   \   0000015A   01D9               MOVW    R27:R26, R19:R18
   \   0000015C   0FA6               ADD     R26, R22
   \   0000015E   1FB7               ADC     R27, R23
   \   00000160   930C               ST      X, R16
    455              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   00000162   0F24               ADD     R18, R20
   \   00000164   1F35               ADC     R19, R21
   \   00000166   01D9               MOVW    R27:R26, R19:R18
   \   00000168   8100               LD      R16, Z
   \   0000016A   8111               LDD     R17, Z+1
   \   0000016C   1B04               SUB     R16, R20
   \   0000016E   5002               SUBI    R16, 2
   \   00000170   930C               ST      X, R16
    456              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000172   8180               LD      R24, Z
   \   00000174   8191               LDD     R25, Z+1
   \   00000176   1B84               SUB     R24, R20
   \   00000178   0B95               SBC     R25, R21
   \   0000017A   9702               SBIW    R25:R24, 2
   \   0000017C   01F9               MOVW    R31:R30, R19:R18
   \   0000017E   8391               STD     Z+1, R25
    457              OS_LeaveRegion();
   \   00000180   ........           CALL    OS_LeaveRegion
    458          }
   \   00000184   ....               RJMP    ?Subroutine1
    459          
    460          
    461          
    462          /*************************************************************************
    463          *
    464          * Build setup dat package for AN-ZB485
    465          *
    466          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   2D82               MOV     R24, R2
   \   00000002   2F97               MOV     R25, R23
   \   00000004   2DA3               MOV     R26, R3
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    467          void BuildRS4Setup(char ch, short pointer) {
   \                     BuildRS4Setup:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F79               MOV     R23, R25
   \   00000006   2E28               MOV     R2, R24
    468          
    469              short ntna;
    470              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000008   2F40               MOV     R20, R16
   \   0000000A   EF0D               LDI     R16, 253
   \   0000000C   E011               LDI     R17, 1
   \   0000000E   9F41               MUL     R20, R17
   \   00000010   2D50               MOV     R21, R0
   \   00000012   9F40               MUL     R20, R16
   \   00000014   0D51               ADD     R21, R1
   \   00000016   ....               LDI     R18, LOW(UART)
   \   00000018   ....               LDI     R19, (UART) >> 8
   \   0000001A   0D20               ADD     R18, R0
   \   0000001C   1F35               ADC     R19, R21
   \   0000001E   01F9               MOVW    R31:R30, R19:R18
   \   00000020   54E2               SUBI    R30, 66
   \   00000022   4FFE               SBCI    R31, 254
   \   00000024   8310               ST      Z, R17
    471          
    472              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_SETUP & 0xff;
   \   00000026   01F9               MOVW    R31:R30, R19:R18
   \   00000028   5EED               SUBI    R30, 237
   \   0000002A   4FFE               SBCI    R31, 254
   \   0000002C   8100               LD      R16, Z
   \   0000002E   8111               LDD     R17, Z+1
   \   00000030   01C8               MOVW    R25:R24, R17:R16
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   8380               ST      Z, R24
   \   00000036   8391               STD     Z+1, R25
   \   00000038   01D9               MOVW    R27:R26, R19:R18
   \   0000003A   0FA0               ADD     R26, R16
   \   0000003C   1FB1               ADC     R27, R17
   \   0000003E   E507               LDI     R16, 87
   \   00000040   930C               ST      X, R16
    473              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_SETUP >> 8;
   \   00000042   8100               LD      R16, Z
   \   00000044   8111               LDD     R17, Z+1
   \   00000046   01C8               MOVW    R25:R24, R17:R16
   \   00000048   9601               ADIW    R25:R24, 1
   \   0000004A   8380               ST      Z, R24
   \   0000004C   8391               STD     Z+1, R25
   \   0000004E   01D9               MOVW    R27:R26, R19:R18
   \   00000050   0FA0               ADD     R26, R16
   \   00000052   1FB1               ADC     R27, R17
   \   00000054   E004               LDI     R16, 4
   \   00000056   930C               ST      X, R16
    474              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000058   8100               LD      R16, Z
   \   0000005A   8111               LDD     R17, Z+1
    475              UART[ch].TxFirst += 2;                                      // two byte length
   \   0000005C   8140               LD      R20, Z
   \   0000005E   8151               LDD     R21, Z+1
   \   00000060   5F4E               SUBI    R20, 254
   \   00000062   4F5F               SBCI    R21, 255
   \   00000064   8340               ST      Z, R20
   \   00000066   8351               STD     Z+1, R21
    476          
    477              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.PortUsed;  // send the setup
   \   00000068   8140               LD      R20, Z
   \   0000006A   8151               LDD     R21, Z+1
   \   0000006C   01CA               MOVW    R25:R24, R21:R20
   \   0000006E   9601               ADIW    R25:R24, 1
   \   00000070   8380               ST      Z, R24
   \   00000072   8391               STD     Z+1, R25
   \   00000074   9160....           LDS     R22, TData
   \   00000078   01D9               MOVW    R27:R26, R19:R18
   \   0000007A   0FA4               ADD     R26, R20
   \   0000007C   1FB5               ADC     R27, R21
   \   0000007E   936C               ST      X, R22
    478              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.SensorType[0];  // send the sensor type
   \   00000080   8140               LD      R20, Z
   \   00000082   8151               LDD     R21, Z+1
   \   00000084   01CA               MOVW    R25:R24, R21:R20
   \   00000086   9601               ADIW    R25:R24, 1
   \   00000088   8380               ST      Z, R24
   \   0000008A   8391               STD     Z+1, R25
   \   0000008C   9160....           LDS     R22, (TData + 1)
   \   00000090   01D9               MOVW    R27:R26, R19:R18
   \   00000092   0FA4               ADD     R26, R20
   \   00000094   1FB5               ADC     R27, R21
   \   00000096   936C               ST      X, R22
    479              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.SensorType[1];  // send the sensor type
   \   00000098   8140               LD      R20, Z
   \   0000009A   8151               LDD     R21, Z+1
   \   0000009C   01CA               MOVW    R25:R24, R21:R20
   \   0000009E   9601               ADIW    R25:R24, 1
   \   000000A0   8380               ST      Z, R24
   \   000000A2   8391               STD     Z+1, R25
   \   000000A4   9160....           LDS     R22, (TData + 2)
   \   000000A8   01D9               MOVW    R27:R26, R19:R18
   \   000000AA   0FA4               ADD     R26, R20
   \   000000AC   1FB5               ADC     R27, R21
   \   000000AE   936C               ST      X, R22
    480          
    481              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000B0   0F20               ADD     R18, R16
   \   000000B2   1F31               ADC     R19, R17
   \   000000B4   01D9               MOVW    R27:R26, R19:R18
   \   000000B6   8120               LD      R18, Z
   \   000000B8   8131               LDD     R19, Z+1
   \   000000BA   1B20               SUB     R18, R16
   \   000000BC   5022               SUBI    R18, 2
   \   000000BE   932C               ST      X, R18
    482              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000C0   8180               LD      R24, Z
   \   000000C2   8191               LDD     R25, Z+1
   \   000000C4   1B80               SUB     R24, R16
   \   000000C6   0B91               SBC     R25, R17
   \   000000C8   9702               SBIW    R25:R24, 2
   \   000000CA   01FD               MOVW    R31:R30, R27:R26
   \   000000CC   8391               STD     Z+1, R25
    483          }
   \   000000CE   ....               RJMP    ?Subroutine3
    484          
    485          /*************************************************************************
    486          *
    487          * Build datablock of measured data for ADcard
    488          *
    489          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    490          void BuildMData485(char ch, short pointer) {
   \                     BuildMData485:
   \   00000000   927A               ST      -Y, R7
   \   00000002   926A               ST      -Y, R6
   \   00000004   925A               ST      -Y, R5
   \   00000006   924A               ST      -Y, R4
   \   00000008   93BA               ST      -Y, R27
   \   0000000A   93AA               ST      -Y, R26
   \   0000000C   939A               ST      -Y, R25
   \   0000000E   2E38               MOV     R3, R24
   \   00000010                      REQUIRE ?Register_R4_is_cg_reg
   \   00000010                      REQUIRE ?Register_R5_is_cg_reg
   \   00000010                      REQUIRE ?Register_R6_is_cg_reg
   \   00000010                      REQUIRE ?Register_R7_is_cg_reg
   \   00000010   2F40               MOV     R20, R16
   \   00000012   0189               MOVW    R17:R16, R19:R18
    491              short ntna, i;
    492              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000014   EF2D               LDI     R18, 253
   \   00000016   E031               LDI     R19, 1
   \   00000018   9F43               MUL     R20, R19
   \   0000001A   2D50               MOV     R21, R0
   \   0000001C   9F42               MUL     R20, R18
   \   0000001E   0D51               ADD     R21, R1
   \   00000020   ....               LDI     R18, LOW(UART)
   \   00000022   ....               LDI     R19, (UART) >> 8
   \   00000024   0D20               ADD     R18, R0
   \   00000026   1F35               ADC     R19, R21
   \   00000028   01F9               MOVW    R31:R30, R19:R18
   \   0000002A   54E2               SUBI    R30, 66
   \   0000002C   4FFE               SBCI    R31, 254
   \   0000002E   E041               LDI     R20, 1
   \   00000030   8340               ST      Z, R20
    493          
    494              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_MDATA & 0xff;
   \   00000032   01F9               MOVW    R31:R30, R19:R18
   \   00000034   5EED               SUBI    R30, 237
   \   00000036   4FFE               SBCI    R31, 254
   \   00000038   8140               LD      R20, Z
   \   0000003A   8151               LDD     R21, Z+1
   \   0000003C   01CA               MOVW    R25:R24, R21:R20
   \   0000003E   9601               ADIW    R25:R24, 1
   \   00000040   8380               ST      Z, R24
   \   00000042   8391               STD     Z+1, R25
   \   00000044   01D9               MOVW    R27:R26, R19:R18
   \   00000046   0FA4               ADD     R26, R20
   \   00000048   1FB5               ADC     R27, R21
   \   0000004A   E745               LDI     R20, 117
   \   0000004C   934C               ST      X, R20
    495              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_MDATA >> 8;
   \   0000004E   8140               LD      R20, Z
   \   00000050   8151               LDD     R21, Z+1
   \   00000052   01CA               MOVW    R25:R24, R21:R20
   \   00000054   9601               ADIW    R25:R24, 1
   \   00000056   8380               ST      Z, R24
   \   00000058   8391               STD     Z+1, R25
   \   0000005A   01D9               MOVW    R27:R26, R19:R18
   \   0000005C   0FA4               ADD     R26, R20
   \   0000005E   1FB5               ADC     R27, R21
   \   00000060   E044               LDI     R20, 4
   \   00000062   934C               ST      X, R20
    496              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000064   8040               LD      R4, Z
   \   00000066   8051               LDD     R5, Z+1
    497              UART[ch].TxFirst += 2;                                      // two byte length
   \   00000068   8140               LD      R20, Z
   \   0000006A   8151               LDD     R21, Z+1
   \   0000006C   5F4E               SUBI    R20, 254
   \   0000006E   4F5F               SBCI    R21, 255
   \   00000070   8340               ST      Z, R20
   \   00000072   8351               STD     Z+1, R21
    498          
    499              UART[ch].pTxBuffer[UART[ch].TxFirst++] = UART[ch].pRxBuffer[pointer];
   \   00000074   8160               LD      R22, Z
   \   00000076   8171               LDD     R23, Z+1
   \   00000078   01CB               MOVW    R25:R24, R23:R22
   \   0000007A   9601               ADIW    R25:R24, 1
   \   0000007C   8380               ST      Z, R24
   \   0000007E   8391               STD     Z+1, R25
   \   00000080   0F02               ADD     R16, R18
   \   00000082   1F13               ADC     R17, R19
   \   00000084   5E05               SUBI    R16, 229
   \   00000086   4F1E               SBCI    R17, 254
   \   00000088   01D8               MOVW    R27:R26, R17:R16
   \   0000008A   914C               LD      R20, X
   \   0000008C   01D9               MOVW    R27:R26, R19:R18
   \   0000008E   0FA6               ADD     R26, R22
   \   00000090   1FB7               ADC     R27, R23
   \   00000092   934C               ST      X, R20
    500              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.IOUnitStatus[UART[ch].pRxBuffer[pointer]] | (RestartStatus << 4); // IOUnit status +  restart status
   \   00000094   8160               LD      R22, Z
   \   00000096   8171               LDD     R23, Z+1
   \   00000098   01CB               MOVW    R25:R24, R23:R22
   \   0000009A   9601               ADIW    R25:R24, 1
   \   0000009C   8380               ST      Z, R24
   \   0000009E   8391               STD     Z+1, R25
   \   000000A0   01D8               MOVW    R27:R26, R17:R16
   \   000000A2   91AC               LD      R26, X
   \   000000A4   E0B0               LDI     R27, 0
   \   000000A6   ....               SUBI    R26, LOW((-(TData + 3) & 0xFFFF))
   \   000000A8   ....               SBCI    R27, HIGH((-(TData + 3) & 0xFFFF))
   \   000000AA   914C               LD      R20, X
   \   000000AC   9150....           LDS     R21, RestartStatus
   \   000000B0   9552               SWAP    R21
   \   000000B2   7F50               ANDI    R21, 0xF0
   \   000000B4   2B45               OR      R20, R21
   \   000000B6   01D9               MOVW    R27:R26, R19:R18
   \   000000B8   0FA6               ADD     R26, R22
   \   000000BA   1FB7               ADC     R27, R23
   \   000000BC   934C               ST      X, R20
    501              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.FailCnt[UART[ch].pRxBuffer[pointer]][0] & 0xff; // Failcnt error
   \   000000BE   8160               LD      R22, Z
   \   000000C0   8171               LDD     R23, Z+1
   \   000000C2   01CB               MOVW    R25:R24, R23:R22
   \   000000C4   9601               ADIW    R25:R24, 1
   \   000000C6   8380               ST      Z, R24
   \   000000C8   8391               STD     Z+1, R25
   \   000000CA   01D8               MOVW    R27:R26, R17:R16
   \   000000CC   914C               LD      R20, X
   \   000000CE   E054               LDI     R21, 4
   \   000000D0   9F45               MUL     R20, R21
   \   000000D2   01D0               MOVW    R27:R26, R1:R0
   \   000000D4   ....               SUBI    R26, LOW((-(TData + 11) & 0xFFFF))
   \   000000D6   ....               SBCI    R27, HIGH((-(TData + 11) & 0xFFFF))
   \   000000D8   914D               LD      R20, X+
   \   000000DA   01D9               MOVW    R27:R26, R19:R18
   \   000000DC   0FA6               ADD     R26, R22
   \   000000DE   1FB7               ADC     R27, R23
   \   000000E0   934C               ST      X, R20
    502              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.RS4.FailCnt[UART[ch].pRxBuffer[pointer]][0] >> 8) & 0xff; // Failcnt error
   \   000000E2   8160               LD      R22, Z
   \   000000E4   8171               LDD     R23, Z+1
   \   000000E6   01CB               MOVW    R25:R24, R23:R22
   \   000000E8   9601               ADIW    R25:R24, 1
   \   000000EA   8380               ST      Z, R24
   \   000000EC   8391               STD     Z+1, R25
   \   000000EE   01D8               MOVW    R27:R26, R17:R16
   \   000000F0   914C               LD      R20, X
   \   000000F2   9F45               MUL     R20, R21
   \   000000F4   01D0               MOVW    R27:R26, R1:R0
   \   000000F6   ....               SUBI    R26, LOW((-(TData + 11) & 0xFFFF))
   \   000000F8   ....               SBCI    R27, HIGH((-(TData + 11) & 0xFFFF))
   \   000000FA   9611               ADIW    R27:R26, 1
   \   000000FC   914C               LD      R20, X
   \   000000FE   01D9               MOVW    R27:R26, R19:R18
   \   00000100   0FA6               ADD     R26, R22
   \   00000102   1FB7               ADC     R27, R23
   \   00000104   934C               ST      X, R20
    503              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.FailCnt[UART[ch].pRxBuffer[pointer]][1] & 0xff; // Failcnt total
   \   00000106   8160               LD      R22, Z
   \   00000108   8171               LDD     R23, Z+1
   \   0000010A   01CB               MOVW    R25:R24, R23:R22
   \   0000010C   9601               ADIW    R25:R24, 1
   \   0000010E   8380               ST      Z, R24
   \   00000110   8391               STD     Z+1, R25
   \   00000112   01D8               MOVW    R27:R26, R17:R16
   \   00000114   914C               LD      R20, X
   \   00000116   9F45               MUL     R20, R21
   \   00000118   01D0               MOVW    R27:R26, R1:R0
   \   0000011A   ....               SUBI    R26, LOW((-(TData + 13) & 0xFFFF))
   \   0000011C   ....               SBCI    R27, HIGH((-(TData + 13) & 0xFFFF))
   \   0000011E   914D               LD      R20, X+
   \   00000120   01D9               MOVW    R27:R26, R19:R18
   \   00000122   0FA6               ADD     R26, R22
   \   00000124   1FB7               ADC     R27, R23
   \   00000126   934C               ST      X, R20
    504              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.RS4.FailCnt[UART[ch].pRxBuffer[pointer]][1] >> 8) & 0xff; // Failcnt total
   \   00000128   8160               LD      R22, Z
   \   0000012A   8171               LDD     R23, Z+1
   \   0000012C   01CB               MOVW    R25:R24, R23:R22
   \   0000012E   9601               ADIW    R25:R24, 1
   \   00000130   8380               ST      Z, R24
   \   00000132   8391               STD     Z+1, R25
   \   00000134   01D8               MOVW    R27:R26, R17:R16
   \   00000136   914C               LD      R20, X
   \   00000138   9F45               MUL     R20, R21
   \   0000013A   01D0               MOVW    R27:R26, R1:R0
   \   0000013C   ....               SUBI    R26, LOW((-(TData + 13) & 0xFFFF))
   \   0000013E   ....               SBCI    R27, HIGH((-(TData + 13) & 0xFFFF))
   \   00000140   9611               ADIW    R27:R26, 1
   \   00000142   914C               LD      R20, X
   \   00000144   01D9               MOVW    R27:R26, R19:R18
   \   00000146   0FA6               ADD     R26, R22
   \   00000148   1FB7               ADC     R27, R23
   \   0000014A   934C               ST      X, R20
    505              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.TargetStatusSWVer[UART[ch].pRxBuffer[pointer]]; // Target status byte 1
   \   0000014C   8160               LD      R22, Z
   \   0000014E   8171               LDD     R23, Z+1
   \   00000150   01CB               MOVW    R25:R24, R23:R22
   \   00000152   9601               ADIW    R25:R24, 1
   \   00000154   8380               ST      Z, R24
   \   00000156   8391               STD     Z+1, R25
   \   00000158   01D8               MOVW    R27:R26, R17:R16
   \   0000015A   91AC               LD      R26, X
   \   0000015C   E050               LDI     R21, 0
   \   0000015E   E0B0               LDI     R27, 0
   \   00000160   ....               SUBI    R26, LOW((-(TData + 43) & 0xFFFF))
   \   00000162   ....               SBCI    R27, HIGH((-(TData + 43) & 0xFFFF))
   \   00000164   914C               LD      R20, X
   \   00000166   01D9               MOVW    R27:R26, R19:R18
   \   00000168   0FA6               ADD     R26, R22
   \   0000016A   1FB7               ADC     R27, R23
   \   0000016C   934C               ST      X, R20
    506              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.TargetStatusAddress[UART[ch].pRxBuffer[pointer]]; // Target status byte 2
   \   0000016E   8160               LD      R22, Z
   \   00000170   8171               LDD     R23, Z+1
   \   00000172   01CB               MOVW    R25:R24, R23:R22
   \   00000174   9601               ADIW    R25:R24, 1
   \   00000176   8380               ST      Z, R24
   \   00000178   8391               STD     Z+1, R25
   \   0000017A   01D8               MOVW    R27:R26, R17:R16
   \   0000017C   91AC               LD      R26, X
   \   0000017E   E0B0               LDI     R27, 0
   \   00000180   ....               SUBI    R26, LOW((-(TData + 51) & 0xFFFF))
   \   00000182   ....               SBCI    R27, HIGH((-(TData + 51) & 0xFFFF))
   \   00000184   914C               LD      R20, X
   \   00000186   01D9               MOVW    R27:R26, R19:R18
   \   00000188   0FA6               ADD     R26, R22
   \   0000018A   1FB7               ADC     R27, R23
   \   0000018C   934C               ST      X, R20
    507          
    508              TData.RS4.TargetStatusAddress[UART[ch].pRxBuffer[pointer]] &= ~0x80;                                  //reset restart flag for adcard
   \   0000018E   01D8               MOVW    R27:R26, R17:R16
   \   00000190   91AC               LD      R26, X
   \   00000192   ....               SUBI    R26, LOW((-(TData + 51) & 0xFFFF))
   \   00000194   ....               SBCI    R21, HIGH((-(TData + 51) & 0xFFFF))
   \   00000196   2FB5               MOV     R27, R21
   \   00000198   914C               LD      R20, X
   \   0000019A   774F               ANDI    R20, 0x7F
   \   0000019C   934C               ST      X, R20
    509          
    510              for (i = 0; i < 14; i++) {
   \   0000019E   E080               LDI     R24, 0
   \   000001A0   E090               LDI     R25, 0
   \   000001A2   E04E               LDI     R20, 14
   \   000001A4   2E24               MOV     R2, R20
    511                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.TargetSetup1[UART[ch].pRxBuffer[pointer]][i];
   \                     ??BuildMData485_0:
   \   000001A6   8060               LD      R6, Z
   \   000001A8   8071               LDD     R7, Z+1
   \   000001AA   01A3               MOVW    R21:R20, R7:R6
   \   000001AC   5F4F               SUBI    R20, 255
   \   000001AE   4F5F               SBCI    R21, 255
   \   000001B0   8340               ST      Z, R20
   \   000001B2   8351               STD     Z+1, R21
   \   000001B4   ....               LDI     R20, LOW((TData + 59))
   \   000001B6   ....               LDI     R21, HIGH((TData + 59))
   \   000001B8   0F48               ADD     R20, R24
   \   000001BA   1F59               ADC     R21, R25
   \   000001BC   01D8               MOVW    R27:R26, R17:R16
   \   000001BE   917C               LD      R23, X
   \   000001C0   E06E               LDI     R22, 14
   \   000001C2   9F76               MUL     R23, R22
   \   000001C4   0D40               ADD     R20, R0
   \   000001C6   1D51               ADC     R21, R1
   \   000001C8   01DA               MOVW    R27:R26, R21:R20
   \   000001CA   914C               LD      R20, X
   \   000001CC   01D9               MOVW    R27:R26, R19:R18
   \   000001CE   0DA6               ADD     R26, R6
   \   000001D0   1DB7               ADC     R27, R7
   \   000001D2   934C               ST      X, R20
    512                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.TargetSetup2[UART[ch].pRxBuffer[pointer]][i];
   \   000001D4   8060               LD      R6, Z
   \   000001D6   8071               LDD     R7, Z+1
   \   000001D8   01A3               MOVW    R21:R20, R7:R6
   \   000001DA   5F4F               SUBI    R20, 255
   \   000001DC   4F5F               SBCI    R21, 255
   \   000001DE   8340               ST      Z, R20
   \   000001E0   8351               STD     Z+1, R21
   \   000001E2   ....               LDI     R20, LOW((TData + 171))
   \   000001E4   ....               LDI     R21, HIGH((TData + 171))
   \   000001E6   0F48               ADD     R20, R24
   \   000001E8   1F59               ADC     R21, R25
   \   000001EA   01D8               MOVW    R27:R26, R17:R16
   \   000001EC   917C               LD      R23, X
   \   000001EE   9F76               MUL     R23, R22
   \   000001F0   0D40               ADD     R20, R0
   \   000001F2   1D51               ADC     R21, R1
   \   000001F4   01DA               MOVW    R27:R26, R21:R20
   \   000001F6   914C               LD      R20, X
   \   000001F8   01D9               MOVW    R27:R26, R19:R18
   \   000001FA   0DA6               ADD     R26, R6
   \   000001FC   1DB7               ADC     R27, R7
   \   000001FE   934C               ST      X, R20
    513                  *((float *)&UART[ch].pTxBuffer[UART[ch].TxFirst]) = *((float *)&TData.RS4.Result[UART[ch].pRxBuffer[pointer]][i]);   // ADresult
   \   00000200   ....               LDI     R20, LOW((TData + 731))
   \   00000202   ....               LDI     R21, HIGH((TData + 731))
   \   00000204   01BC               MOVW    R23:R22, R25:R24
   \   00000206   0F66               LSL     R22
   \   00000208   1F77               ROL     R23
   \   0000020A   0F66               LSL     R22
   \   0000020C   1F77               ROL     R23
   \   0000020E   0F46               ADD     R20, R22
   \   00000210   1F57               ADC     R21, R23
   \   00000212   01D8               MOVW    R27:R26, R17:R16
   \   00000214   917C               LD      R23, X
   \   00000216   E368               LDI     R22, 56
   \   00000218   9F76               MUL     R23, R22
   \   0000021A   0D40               ADD     R20, R0
   \   0000021C   1D51               ADC     R21, R1
   \   0000021E   01DA               MOVW    R27:R26, R21:R20
   \   00000220   914D               LD      R20, X+
   \   00000222   915D               LD      R21, X+
   \   00000224   916D               LD      R22, X+
   \   00000226   917C               LD      R23, X
   \   00000228   8000               LD      R0, Z
   \   0000022A   8011               LDD     R1, Z+1
   \   0000022C   01D9               MOVW    R27:R26, R19:R18
   \   0000022E   0DA0               ADD     R26, R0
   \   00000230   1DB1               ADC     R27, R1
   \   00000232   934D               ST      X+, R20
   \   00000234   935D               ST      X+, R21
   \   00000236   936D               ST      X+, R22
   \   00000238   937C               ST      X, R23
    514                  UART[ch].TxFirst += sizeof(float);
   \   0000023A   8140               LD      R20, Z
   \   0000023C   8151               LDD     R21, Z+1
   \   0000023E   5F4C               SUBI    R20, 252
   \   00000240   4F5F               SBCI    R21, 255
   \   00000242   8340               ST      Z, R20
   \   00000244   8351               STD     Z+1, R21
    515              }
   \   00000246   9601               ADIW    R25:R24, 1
   \   00000248   942A               DEC     R2
   \   0000024A   F009               BREQ    $+2+2
   \   0000024C   CFAC               RJMP    ??BuildMData485_0
    516          
    517              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   0000024E   0D24               ADD     R18, R4
   \   00000250   1D35               ADC     R19, R5
   \   00000252   01D9               MOVW    R27:R26, R19:R18
   \   00000254   8100               LD      R16, Z
   \   00000256   8111               LDD     R17, Z+1
   \   00000258   1904               SUB     R16, R4
   \   0000025A   5002               SUBI    R16, 2
   \   0000025C   930C               ST      X, R16
    518              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000025E   8180               LD      R24, Z
   \   00000260   8191               LDD     R25, Z+1
   \   00000262   1984               SUB     R24, R4
   \   00000264   0995               SBC     R25, R5
   \   00000266   9702               SBIW    R25:R24, 2
   \   00000268   01F9               MOVW    R31:R30, R19:R18
   \   0000026A   8391               STD     Z+1, R25
    519          
    520          }
   \   0000026C   2D83               MOV     R24, R3
   \   0000026E   ....               RJMP    ??Subroutine7_0
    521          
    522          /*************************************************************************
    523          *
    524          * Build datablock of raw and cal data for ADcard
    525          *
    526          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   8391               STD     Z+1, R25
   \   00000002                      REQUIRE ??Subroutine4_0
   \   00000002                      ;               // Fall through to label ??Subroutine4_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine4_0:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9049               LD      R4, Y+
   \   0000000A   9059               LD      R5, Y+
   \   0000000C   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    527          void BuildRData485(char ch, short pointer) {
   \                     BuildRData485:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
    528              short ntna, i;
    529              UART[ch].RxSendReply = true;                               // flag for answering
   \   0000000C   2F40               MOV     R20, R16
   \   0000000E   EF0D               LDI     R16, 253
   \   00000010   E011               LDI     R17, 1
   \   00000012   9F41               MUL     R20, R17
   \   00000014   2D50               MOV     R21, R0
   \   00000016   9F40               MUL     R20, R16
   \   00000018   0D51               ADD     R21, R1
   \   0000001A   ....               LDI     R16, LOW(UART)
   \   0000001C   ....               LDI     R17, (UART) >> 8
   \   0000001E   0D00               ADD     R16, R0
   \   00000020   1F15               ADC     R17, R21
   \   00000022   01F8               MOVW    R31:R30, R17:R16
   \   00000024   54E2               SUBI    R30, 66
   \   00000026   4FFE               SBCI    R31, 254
   \   00000028   E041               LDI     R20, 1
   \   0000002A   8340               ST      Z, R20
    530          
    531              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_RDATA & 0xff;
   \   0000002C   01F8               MOVW    R31:R30, R17:R16
   \   0000002E   5EED               SUBI    R30, 237
   \   00000030   4FFE               SBCI    R31, 254
   \   00000032   8140               LD      R20, Z
   \   00000034   8151               LDD     R21, Z+1
   \   00000036   01CA               MOVW    R25:R24, R21:R20
   \   00000038   9601               ADIW    R25:R24, 1
   \   0000003A   8380               ST      Z, R24
   \   0000003C   8391               STD     Z+1, R25
   \   0000003E   01D8               MOVW    R27:R26, R17:R16
   \   00000040   0FA4               ADD     R26, R20
   \   00000042   1FB5               ADC     R27, R21
   \   00000044   E746               LDI     R20, 118
   \   00000046   934C               ST      X, R20
    532              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_RDATA >> 8;
   \   00000048   8140               LD      R20, Z
   \   0000004A   8151               LDD     R21, Z+1
   \   0000004C   01CA               MOVW    R25:R24, R21:R20
   \   0000004E   9601               ADIW    R25:R24, 1
   \   00000050   8380               ST      Z, R24
   \   00000052   8391               STD     Z+1, R25
   \   00000054   01D8               MOVW    R27:R26, R17:R16
   \   00000056   0FA4               ADD     R26, R20
   \   00000058   1FB5               ADC     R27, R21
   \   0000005A   E044               LDI     R20, 4
   \   0000005C   934C               ST      X, R20
    533              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   0000005E   8140               LD      R20, Z
   \   00000060   8151               LDD     R21, Z+1
    534              UART[ch].TxFirst += 2;                                      // two byte length
   \   00000062   8160               LD      R22, Z
   \   00000064   8171               LDD     R23, Z+1
   \   00000066   5F6E               SUBI    R22, 254
   \   00000068   4F7F               SBCI    R23, 255
   \   0000006A   8360               ST      Z, R22
   \   0000006C   8371               STD     Z+1, R23
    535          
    536              UART[ch].pTxBuffer[UART[ch].TxFirst++] = UART[ch].pRxBuffer[pointer];
   \   0000006E   8000               LD      R0, Z
   \   00000070   8011               LDD     R1, Z+1
   \   00000072   01C0               MOVW    R25:R24, R1:R0
   \   00000074   9601               ADIW    R25:R24, 1
   \   00000076   8380               ST      Z, R24
   \   00000078   8391               STD     Z+1, R25
   \   0000007A   0F20               ADD     R18, R16
   \   0000007C   1F31               ADC     R19, R17
   \   0000007E   5E25               SUBI    R18, 229
   \   00000080   4F3E               SBCI    R19, 254
   \   00000082   01D9               MOVW    R27:R26, R19:R18
   \   00000084   916C               LD      R22, X
   \   00000086   01D8               MOVW    R27:R26, R17:R16
   \   00000088   0DA0               ADD     R26, R0
   \   0000008A   1DB1               ADC     R27, R1
   \   0000008C   936C               ST      X, R22
    537              for (i = 0; i < 14; i++) {
   \   0000008E   E080               LDI     R24, 0
   \   00000090   E090               LDI     R25, 0
   \   00000092   E06E               LDI     R22, 14
   \   00000094   E17C               LDI     R23, 28
    538                  *((short *)&UART[ch].pTxBuffer[UART[ch].TxFirst]) = *((short *)&TData.RS4.Raw[UART[ch].pRxBuffer[pointer]][i]);   // Raw data
   \                     ??BuildRData485_0:
   \   00000096   011C               MOVW    R3:R2, R25:R24
   \   00000098   0C22               LSL     R2
   \   0000009A   1C33               ROL     R3
   \   0000009C   ....               LDI     R26, LOW((TData + 283))
   \   0000009E   2E4A               MOV     R4, R26
   \   000000A0   ....               LDI     R26, HIGH((TData + 283))
   \   000000A2   0C42               ADD     R4, R2
   \   000000A4   1DA3               ADC     R26, R3
   \   000000A6   2E5A               MOV     R5, R26
   \   000000A8   01D9               MOVW    R27:R26, R19:R18
   \   000000AA   900C               LD      R0, X
   \   000000AC   9E07               MUL     R0, R23
   \   000000AE   0C40               ADD     R4, R0
   \   000000B0   1C51               ADC     R5, R1
   \   000000B2   01D2               MOVW    R27:R26, R5:R4
   \   000000B4   900D               LD      R0, X+
   \   000000B6   901C               LD      R1, X
   \   000000B8   8040               LD      R4, Z
   \   000000BA   8051               LDD     R5, Z+1
   \   000000BC   01D8               MOVW    R27:R26, R17:R16
   \   000000BE   0DA4               ADD     R26, R4
   \   000000C0   1DB5               ADC     R27, R5
   \   000000C2   920D               ST      X+, R0
   \   000000C4   921C               ST      X, R1
    539                  UART[ch].TxFirst += sizeof(short);
   \   000000C6   81A0               LD      R26, Z
   \   000000C8   81B1               LDD     R27, Z+1
   \   000000CA   9612               ADIW    R27:R26, 2
   \   000000CC   83A0               ST      Z, R26
   \   000000CE   83B1               STD     Z+1, R27
    540                  *((short *)&UART[ch].pTxBuffer[UART[ch].TxFirst]) = *((short *)&TData.RS4.Cal[UART[ch].pRxBuffer[pointer]][i]);   // Cal data
   \   000000D0   ....               LDI     R26, LOW((TData + 507))
   \   000000D2   2E4A               MOV     R4, R26
   \   000000D4   ....               LDI     R26, HIGH((TData + 507))
   \   000000D6   0C42               ADD     R4, R2
   \   000000D8   1DA3               ADC     R26, R3
   \   000000DA   2E5A               MOV     R5, R26
   \   000000DC   01D9               MOVW    R27:R26, R19:R18
   \   000000DE   900C               LD      R0, X
   \   000000E0   9E07               MUL     R0, R23
   \   000000E2   0C40               ADD     R4, R0
   \   000000E4   1C51               ADC     R5, R1
   \   000000E6   01D2               MOVW    R27:R26, R5:R4
   \   000000E8   900D               LD      R0, X+
   \   000000EA   901C               LD      R1, X
   \   000000EC   8020               LD      R2, Z
   \   000000EE   8031               LDD     R3, Z+1
   \   000000F0   01D8               MOVW    R27:R26, R17:R16
   \   000000F2   0DA2               ADD     R26, R2
   \   000000F4   1DB3               ADC     R27, R3
   \   000000F6   920D               ST      X+, R0
   \   000000F8   921C               ST      X, R1
    541                  UART[ch].TxFirst += sizeof(short);
   \   000000FA   81A0               LD      R26, Z
   \   000000FC   81B1               LDD     R27, Z+1
   \   000000FE   9612               ADIW    R27:R26, 2
   \   00000100   83A0               ST      Z, R26
   \   00000102   83B1               STD     Z+1, R27
    542              }
   \   00000104   9601               ADIW    R25:R24, 1
   \   00000106   956A               DEC     R22
   \   00000108   F631               BRNE    ??BuildRData485_0
    543          
    544              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   0000010A   0F04               ADD     R16, R20
   \   0000010C   1F15               ADC     R17, R21
   \   0000010E   01D8               MOVW    R27:R26, R17:R16
   \   00000110   8100               LD      R16, Z
   \   00000112   8111               LDD     R17, Z+1
   \   00000114   1B04               SUB     R16, R20
   \   00000116   5002               SUBI    R16, 2
   \   00000118   930C               ST      X, R16
    545              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000011A   8180               LD      R24, Z
   \   0000011C   8191               LDD     R25, Z+1
   \   0000011E   1B84               SUB     R24, R20
   \   00000120   0B95               SBC     R25, R21
   \   00000122   9702               SBIW    R25:R24, 2
   \   00000124   01FD               MOVW    R31:R30, R27:R26
   \   00000126   ....               RJMP    ?Subroutine2
    546          
    547          }
    548          
    549          /*************************************************************************
    550          *
    551          * Build setup data package for AN-ZBANA
    552          *
    553          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    554          void BuildANASetup(char ch, short pointer) {
   \                     BuildANASetup:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   011C               MOVW    R3:R2, R25:R24
    555          
    556              short ntna;
    557              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000006   2F20               MOV     R18, R16
   \   00000008   EF0D               LDI     R16, 253
   \   0000000A   E011               LDI     R17, 1
   \   0000000C   9F21               MUL     R18, R17
   \   0000000E   2D30               MOV     R19, R0
   \   00000010   9F20               MUL     R18, R16
   \   00000012   0D31               ADD     R19, R1
   \   00000014   ....               LDI     R16, LOW(UART)
   \   00000016   ....               LDI     R17, (UART) >> 8
   \   00000018   0D00               ADD     R16, R0
   \   0000001A   1F13               ADC     R17, R19
   \   0000001C   01F8               MOVW    R31:R30, R17:R16
   \   0000001E   54E2               SUBI    R30, 66
   \   00000020   4FFE               SBCI    R31, 254
   \   00000022   E021               LDI     R18, 1
   \   00000024   8320               ST      Z, R18
    558          
    559              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_SETUP & 0xff;
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   5EED               SUBI    R30, 237
   \   0000002A   4FFE               SBCI    R31, 254
   \   0000002C   8120               LD      R18, Z
   \   0000002E   8131               LDD     R19, Z+1
   \   00000030   01C9               MOVW    R25:R24, R19:R18
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   8380               ST      Z, R24
   \   00000036   8391               STD     Z+1, R25
   \   00000038   01D8               MOVW    R27:R26, R17:R16
   \   0000003A   0FA2               ADD     R26, R18
   \   0000003C   1FB3               ADC     R27, R19
   \   0000003E   EB2B               LDI     R18, 187
   \   00000040   932C               ST      X, R18
    560              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_SETUP >> 8;
   \   00000042   8120               LD      R18, Z
   \   00000044   8131               LDD     R19, Z+1
   \   00000046   01C9               MOVW    R25:R24, R19:R18
   \   00000048   9601               ADIW    R25:R24, 1
   \   0000004A   8380               ST      Z, R24
   \   0000004C   8391               STD     Z+1, R25
   \   0000004E   01D8               MOVW    R27:R26, R17:R16
   \   00000050   0FA2               ADD     R26, R18
   \   00000052   1FB3               ADC     R27, R19
   \   00000054   E024               LDI     R18, 4
   \   00000056   932C               ST      X, R18
    561              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000058   8120               LD      R18, Z
   \   0000005A   8131               LDD     R19, Z+1
    562              UART[ch].TxFirst += 2;                                      // two byte length
   \   0000005C   8140               LD      R20, Z
   \   0000005E   8151               LDD     R21, Z+1
   \   00000060   5F4E               SUBI    R20, 254
   \   00000062   4F5F               SBCI    R21, 255
   \   00000064   8340               ST      Z, R20
   \   00000066   8351               STD     Z+1, R21
    563          
    564              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.Ana.PortUsed & 0xff;
   \   00000068   8160               LD      R22, Z
   \   0000006A   8171               LDD     R23, Z+1
   \   0000006C   01CB               MOVW    R25:R24, R23:R22
   \   0000006E   9601               ADIW    R25:R24, 1
   \   00000070   8380               ST      Z, R24
   \   00000072   8391               STD     Z+1, R25
   \   00000074   9000....           LDS     R0, TData
   \   00000078   9140....           LDS     R20, (TData + 1)
   \   0000007C   01D8               MOVW    R27:R26, R17:R16
   \   0000007E   0FA6               ADD     R26, R22
   \   00000080   1FB7               ADC     R27, R23
   \   00000082   920C               ST      X, R0
    565              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.Ana.PortUsed >> 8) & 0xff;
   \   00000084   8160               LD      R22, Z
   \   00000086   8171               LDD     R23, Z+1
   \   00000088   01CB               MOVW    R25:R24, R23:R22
   \   0000008A   9601               ADIW    R25:R24, 1
   \   0000008C   8380               ST      Z, R24
   \   0000008E   8391               STD     Z+1, R25
   \   00000090   01D8               MOVW    R27:R26, R17:R16
   \   00000092   0FA6               ADD     R26, R22
   \   00000094   1FB7               ADC     R27, R23
   \   00000096   934C               ST      X, R20
    566          
    567              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   00000098   ....               RJMP    ?Subroutine0
    568              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
    569          }
    570          
    571          /*************************************************************************
    572          *
    573          * Build filter data package for AN-ZBANA
    574          *
    575          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    576          void BuildANAFilter(char ch, short pointer) {
   \                     BuildANAFilter:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   011C               MOVW    R3:R2, R25:R24
    577          
    578              char port;
    579              short ntna;
    580              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000006   2F40               MOV     R20, R16
   \   00000008   EF0D               LDI     R16, 253
   \   0000000A   E011               LDI     R17, 1
   \   0000000C   9F41               MUL     R20, R17
   \   0000000E   2D50               MOV     R21, R0
   \   00000010   9F40               MUL     R20, R16
   \   00000012   0D51               ADD     R21, R1
   \   00000014   ....               LDI     R18, LOW(UART)
   \   00000016   ....               LDI     R19, (UART) >> 8
   \   00000018   0D20               ADD     R18, R0
   \   0000001A   1F35               ADC     R19, R21
   \   0000001C   01F9               MOVW    R31:R30, R19:R18
   \   0000001E   54E2               SUBI    R30, 66
   \   00000020   4FFE               SBCI    R31, 254
   \   00000022   8310               ST      Z, R17
    581          
    582              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_FILTER & 0xff;
   \   00000024   01F9               MOVW    R31:R30, R19:R18
   \   00000026   5EED               SUBI    R30, 237
   \   00000028   4FFE               SBCI    R31, 254
   \   0000002A   8100               LD      R16, Z
   \   0000002C   8111               LDD     R17, Z+1
   \   0000002E   01C8               MOVW    R25:R24, R17:R16
   \   00000030   9601               ADIW    R25:R24, 1
   \   00000032   8380               ST      Z, R24
   \   00000034   8391               STD     Z+1, R25
   \   00000036   01D9               MOVW    R27:R26, R19:R18
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   EC0F               LDI     R16, 207
   \   0000003E   930C               ST      X, R16
    583              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_FILTER >> 8;
   \   00000040   8100               LD      R16, Z
   \   00000042   8111               LDD     R17, Z+1
   \   00000044   01C8               MOVW    R25:R24, R17:R16
   \   00000046   9601               ADIW    R25:R24, 1
   \   00000048   8380               ST      Z, R24
   \   0000004A   8391               STD     Z+1, R25
   \   0000004C   01D9               MOVW    R27:R26, R19:R18
   \   0000004E   0FA0               ADD     R26, R16
   \   00000050   1FB1               ADC     R27, R17
   \   00000052   E004               LDI     R16, 4
   \   00000054   930C               ST      X, R16
    584              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000056   8160               LD      R22, Z
   \   00000058   8171               LDD     R23, Z+1
    585              UART[ch].TxFirst += 2;                                      // two byte length
   \   0000005A   8100               LD      R16, Z
   \   0000005C   8111               LDD     R17, Z+1
   \   0000005E   5F0E               SUBI    R16, 254
   \   00000060   4F1F               SBCI    R17, 255
   \   00000062   8300               ST      Z, R16
   \   00000064   8311               STD     Z+1, R17
    586          
    587              for (port = 0; port < 12; port++) {
   \   00000066   ....               LDI     R16, LOW((TData + 2))
   \   00000068   ....               LDI     R17, HIGH((TData + 2))
   \   0000006A   E04C               LDI     R20, 12
    588          #if USE_MODBUS_PROTOCOL == 1
    589                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (char)TData.Ana.Filter[port];
    590          #else
    591                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.Ana.Filter[port];
   \                     ??BuildANAFilter_0:
   \   0000006C   8000               LD      R0, Z
   \   0000006E   8011               LDD     R1, Z+1
   \   00000070   01C0               MOVW    R25:R24, R1:R0
   \   00000072   9601               ADIW    R25:R24, 1
   \   00000074   8380               ST      Z, R24
   \   00000076   8391               STD     Z+1, R25
   \   00000078   01D8               MOVW    R27:R26, R17:R16
   \   0000007A   915D               LD      R21, X+
   \   0000007C   018D               MOVW    R17:R16, R27:R26
   \   0000007E   01D9               MOVW    R27:R26, R19:R18
   \   00000080   0DA0               ADD     R26, R0
   \   00000082   1DB1               ADC     R27, R1
   \   00000084   935C               ST      X, R21
    592          #endif
    593              }
   \   00000086   954A               DEC     R20
   \   00000088   F789               BRNE    ??BuildANAFilter_0
    594          
    595              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   0000008A   0F26               ADD     R18, R22
   \   0000008C   1F37               ADC     R19, R23
   \   0000008E   01D9               MOVW    R27:R26, R19:R18
   \   00000090   8100               LD      R16, Z
   \   00000092   8111               LDD     R17, Z+1
   \   00000094   1B06               SUB     R16, R22
   \   00000096   5002               SUBI    R16, 2
   \   00000098   930C               ST      X, R16
    596              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000009A   8180               LD      R24, Z
   \   0000009C   8191               LDD     R25, Z+1
   \   0000009E   1B86               SUB     R24, R22
   \   000000A0   0B97               SBC     R25, R23
   \   000000A2   9702               SBIW    R25:R24, 2
   \   000000A4   01F9               MOVW    R31:R30, R19:R18
   \   000000A6   ....               RJMP    ??Subroutine5_0
    597          }
    598          
    599          /*************************************************************************
    600          *
    601          * Build datablock for External AD (ANA)
    602          *
    603          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    604          void BuildMDataANA(char ch, short pointer) {
   \                     BuildMDataANA:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
    605          
    606              short ntna, i;
    607              UART[ch].RxSendReply = true;                               // flag for answering
   \   0000000C   2F20               MOV     R18, R16
   \   0000000E   EF0D               LDI     R16, 253
   \   00000010   E011               LDI     R17, 1
   \   00000012   9F21               MUL     R18, R17
   \   00000014   2D30               MOV     R19, R0
   \   00000016   9F20               MUL     R18, R16
   \   00000018   0D31               ADD     R19, R1
   \   0000001A   ....               LDI     R16, LOW(UART)
   \   0000001C   ....               LDI     R17, (UART) >> 8
   \   0000001E   0D00               ADD     R16, R0
   \   00000020   1F13               ADC     R17, R19
   \   00000022   01F8               MOVW    R31:R30, R17:R16
   \   00000024   54E2               SUBI    R30, 66
   \   00000026   4FFE               SBCI    R31, 254
   \   00000028   E021               LDI     R18, 1
   \   0000002A   8320               ST      Z, R18
    608          
    609              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_MDATA & 0xff;
   \   0000002C   01D8               MOVW    R27:R26, R17:R16
   \   0000002E   5EAD               SUBI    R26, 237
   \   00000030   4FBE               SBCI    R27, 254
   \   00000032   912D               LD      R18, X+
   \   00000034   913C               LD      R19, X
   \   00000036   9711               SBIW    R27:R26, 1
   \   00000038   01F9               MOVW    R31:R30, R19:R18
   \   0000003A   9631               ADIW    R31:R30, 1
   \   0000003C   93ED               ST      X+, R30
   \   0000003E   93FC               ST      X, R31
   \   00000040   9711               SBIW    R27:R26, 1
   \   00000042   01F8               MOVW    R31:R30, R17:R16
   \   00000044   0FE2               ADD     R30, R18
   \   00000046   1FF3               ADC     R31, R19
   \   00000048   ED29               LDI     R18, 217
   \   0000004A   8320               ST      Z, R18
    610              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_MDATA >> 8;
   \   0000004C   912D               LD      R18, X+
   \   0000004E   913C               LD      R19, X
   \   00000050   9711               SBIW    R27:R26, 1
   \   00000052   01F9               MOVW    R31:R30, R19:R18
   \   00000054   9631               ADIW    R31:R30, 1
   \   00000056   93ED               ST      X+, R30
   \   00000058   93FC               ST      X, R31
   \   0000005A   9711               SBIW    R27:R26, 1
   \   0000005C   01F8               MOVW    R31:R30, R17:R16
   \   0000005E   0FE2               ADD     R30, R18
   \   00000060   1FF3               ADC     R31, R19
   \   00000062   E024               LDI     R18, 4
   \   00000064   8320               ST      Z, R18
    611              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000066   912D               LD      R18, X+
   \   00000068   913C               LD      R19, X
   \   0000006A   9711               SBIW    R27:R26, 1
    612              UART[ch].TxFirst += 2;                                      // two byte length
   \   0000006C   01FD               MOVW    R31:R30, R27:R26
   \   0000006E   8140               LD      R20, Z
   \   00000070   8151               LDD     R21, Z+1
   \   00000072   5F4E               SUBI    R20, 254
   \   00000074   4F5F               SBCI    R21, 255
   \   00000076   8340               ST      Z, R20
   \   00000078   8351               STD     Z+1, R21
    613          
    614              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (RestartStatus << 4);    // Add restart status
   \   0000007A   8140               LD      R20, Z
   \   0000007C   8151               LDD     R21, Z+1
   \   0000007E   01CA               MOVW    R25:R24, R21:R20
   \   00000080   9601               ADIW    R25:R24, 1
   \   00000082   8380               ST      Z, R24
   \   00000084   8391               STD     Z+1, R25
   \   00000086   9160....           LDS     R22, RestartStatus
   \   0000008A   9562               SWAP    R22
   \   0000008C   7F60               ANDI    R22, 0xF0
   \   0000008E   01F8               MOVW    R31:R30, R17:R16
   \   00000090   0FE4               ADD     R30, R20
   \   00000092   1FF5               ADC     R31, R21
   \   00000094   8360               ST      Z, R22
    615              for (i = 0; i < 12; i++) {
   \   00000096   ....               LDI     R20, LOW((TData + 14))
   \   00000098   ....               LDI     R21, HIGH((TData + 14))
   \   0000009A   ....               LDI     R22, LOW((TData + 26))
   \   0000009C   ....               LDI     R23, HIGH((TData + 26))
   \   0000009E   E08C               LDI     R24, 12
    616                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.Ana.Status[i];
   \                     ??BuildMDataANA_0:
   \   000000A0   01FD               MOVW    R31:R30, R27:R26
   \   000000A2   8020               LD      R2, Z
   \   000000A4   8031               LDD     R3, Z+1
   \   000000A6   0101               MOVW    R1:R0, R3:R2
   \   000000A8   E0E1               LDI     R30, 1
   \   000000AA   0E0E               ADD     R0, R30
   \   000000AC   E0E0               LDI     R30, 0
   \   000000AE   1E1E               ADC     R1, R30
   \   000000B0   2FEA               MOV     R30, R26
   \   000000B2   8200               ST      Z, R0
   \   000000B4   8211               STD     Z+1, R1
   \   000000B6   01FA               MOVW    R31:R30, R21:R20
   \   000000B8   9001               LD      R0, Z+
   \   000000BA   01AF               MOVW    R21:R20, R31:R30
   \   000000BC   01F8               MOVW    R31:R30, R17:R16
   \   000000BE   0DE2               ADD     R30, R2
   \   000000C0   1DF3               ADC     R31, R3
   \   000000C2   8200               ST      Z, R0
    617                  *((float *)&UART[ch].pTxBuffer[UART[ch].TxFirst]) = *((float *)&TData.Ana.Result[i]);   // ADresult
   \   000000C4   01FB               MOVW    R31:R30, R23:R22
   \   000000C6   9001               LD      R0, Z+
   \   000000C8   9011               LD      R1, Z+
   \   000000CA   9021               LD      R2, Z+
   \   000000CC   9031               LD      R3, Z+
   \   000000CE   01BF               MOVW    R23:R22, R31:R30
   \   000000D0   01FD               MOVW    R31:R30, R27:R26
   \   000000D2   8040               LD      R4, Z
   \   000000D4   8051               LDD     R5, Z+1
   \   000000D6   01F8               MOVW    R31:R30, R17:R16
   \   000000D8   0DE4               ADD     R30, R4
   \   000000DA   1DF5               ADC     R31, R5
   \   000000DC   8200               ST      Z, R0
   \   000000DE   8211               STD     Z+1, R1
   \   000000E0   8222               STD     Z+2, R2
   \   000000E2   8233               STD     Z+3, R3
    618                  UART[ch].TxFirst += sizeof(float);
   \   000000E4   01FD               MOVW    R31:R30, R27:R26
   \   000000E6   8000               LD      R0, Z
   \   000000E8   8011               LDD     R1, Z+1
   \   000000EA   E094               LDI     R25, 4
   \   000000EC   0E09               ADD     R0, R25
   \   000000EE   E090               LDI     R25, 0
   \   000000F0   1E19               ADC     R1, R25
   \   000000F2   8200               ST      Z, R0
   \   000000F4   8211               STD     Z+1, R1
    619              }
   \   000000F6   958A               DEC     R24
   \   000000F8   F699               BRNE    ??BuildMDataANA_0
    620          
    621              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000FA   0F02               ADD     R16, R18
   \   000000FC   1F13               ADC     R17, R19
   \   000000FE   01F8               MOVW    R31:R30, R17:R16
   \   00000100   910D               LD      R16, X+
   \   00000102   911C               LD      R17, X
   \   00000104   9711               SBIW    R27:R26, 1
   \   00000106   1B02               SUB     R16, R18
   \   00000108   5002               SUBI    R16, 2
   \   0000010A   8300               ST      Z, R16
    622              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000010C   918D               LD      R24, X+
   \   0000010E   919C               LD      R25, X
   \   00000110   1B82               SUB     R24, R18
   \   00000112   0B93               SBC     R25, R19
   \   00000114   9702               SBIW    R25:R24, 2
   \   00000116                      REQUIRE ?Subroutine2
   \   00000116                      ;               // Fall through to label ?Subroutine2
    623          
    624          }
    625          
    626          /*************************************************************************
    627          *
    628          * Build datablock for Stack status
    629          *
    630          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    631          void BuildStackStatus(char ch, short pointer) {
   \                     BuildStackStatus:
   \   00000000   011D               MOVW    R3:R2, R27:R26
   \   00000002   01BC               MOVW    R23:R22, R25:R24
    632          
    633              short ntna, stack;
    634              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000004   2F20               MOV     R18, R16
   \   00000006   EF0D               LDI     R16, 253
   \   00000008   E011               LDI     R17, 1
   \   0000000A   9F21               MUL     R18, R17
   \   0000000C   2D30               MOV     R19, R0
   \   0000000E   9F20               MUL     R18, R16
   \   00000010   0D31               ADD     R19, R1
   \   00000012   ....               LDI     R16, LOW(UART)
   \   00000014   ....               LDI     R17, (UART) >> 8
   \   00000016   0D00               ADD     R16, R0
   \   00000018   1F13               ADC     R17, R19
   \   0000001A   01F8               MOVW    R31:R30, R17:R16
   \   0000001C   54E2               SUBI    R30, 66
   \   0000001E   4FFE               SBCI    R31, 254
   \   00000020   E021               LDI     R18, 1
   \   00000022   8320               ST      Z, R18
    635          
    636              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STACKSTATUS & 0xff;
   \   00000024   01D8               MOVW    R27:R26, R17:R16
   \   00000026   5EAD               SUBI    R26, 237
   \   00000028   4FBE               SBCI    R27, 254
   \   0000002A   912D               LD      R18, X+
   \   0000002C   913C               LD      R19, X
   \   0000002E   9711               SBIW    R27:R26, 1
   \   00000030   01F9               MOVW    R31:R30, R19:R18
   \   00000032   9631               ADIW    R31:R30, 1
   \   00000034   93ED               ST      X+, R30
   \   00000036   93FC               ST      X, R31
   \   00000038   9711               SBIW    R27:R26, 1
   \   0000003A   01F8               MOVW    R31:R30, R17:R16
   \   0000003C   0FE2               ADD     R30, R18
   \   0000003E   1FF3               ADC     R31, R19
   \   00000040   E727               LDI     R18, 119
   \   00000042   8320               ST      Z, R18
    637              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STACKSTATUS >> 8;
   \   00000044   912D               LD      R18, X+
   \   00000046   913C               LD      R19, X
   \   00000048   9711               SBIW    R27:R26, 1
   \   0000004A   01F9               MOVW    R31:R30, R19:R18
   \   0000004C   9631               ADIW    R31:R30, 1
   \   0000004E   93ED               ST      X+, R30
   \   00000050   93FC               ST      X, R31
   \   00000052   9711               SBIW    R27:R26, 1
   \   00000054   01F8               MOVW    R31:R30, R17:R16
   \   00000056   0FE2               ADD     R30, R18
   \   00000058   1FF3               ADC     R31, R19
   \   0000005A   E027               LDI     R18, 7
   \   0000005C   8320               ST      Z, R18
    638              ntna = UART[ch].TxFirst;                                    /* remember index */
   \   0000005E   912D               LD      R18, X+
   \   00000060   913C               LD      R19, X
   \   00000062   9711               SBIW    R27:R26, 1
    639              UART[ch].TxFirst += 2;                                      // two byte length
   \   00000064   914D               LD      R20, X+
   \   00000066   915C               LD      R21, X
   \   00000068   5F4E               SUBI    R20, 254
   \   0000006A   4F5F               SBCI    R21, 255
   \   0000006C   935C               ST      X, R21
   \   0000006E   934E               ST      -X, R20
    640          #if USE_1281_RX_INT_TASK == 0
    641              stack = OS_GetStackSpace(&TCB_USART0);                            // USART 0
    642              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
    643              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
    644              stack = OS_GetStackSpace(&TCB_USART1);                            // USART 1
    645              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
    646              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
    647          #else
    648              stack = OS_GetStackSpace(&TCB_ATMega1281RX_Driver0);                // TCB_ATMega1281RX_Driver0
    649              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
   \   00000070   914D               LD      R20, X+
   \   00000072   915C               LD      R21, X
   \   00000074   9711               SBIW    R27:R26, 1
   \   00000076   01FA               MOVW    R31:R30, R21:R20
   \   00000078   9631               ADIW    R31:R30, 1
   \   0000007A   93ED               ST      X+, R30
   \   0000007C   93FC               ST      X, R31
   \   0000007E   9711               SBIW    R27:R26, 1
   \   00000080   01F8               MOVW    R31:R30, R17:R16
   \   00000082   0FE4               ADD     R30, R20
   \   00000084   1FF5               ADC     R31, R21
   \   00000086   E040               LDI     R20, 0
   \   00000088   8340               ST      Z, R20
    650              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
   \   0000008A   914D               LD      R20, X+
   \   0000008C   915C               LD      R21, X
   \   0000008E   9711               SBIW    R27:R26, 1
   \   00000090   01FA               MOVW    R31:R30, R21:R20
   \   00000092   9631               ADIW    R31:R30, 1
   \   00000094   93ED               ST      X+, R30
   \   00000096   93FC               ST      X, R31
   \   00000098   9711               SBIW    R27:R26, 1
   \   0000009A   01F8               MOVW    R31:R30, R17:R16
   \   0000009C   0FE4               ADD     R30, R20
   \   0000009E   1FF5               ADC     R31, R21
   \   000000A0   E040               LDI     R20, 0
   \   000000A2   8340               ST      Z, R20
    651              stack = OS_GetStackSpace(&TCB_ATMega1281RX_Driver1);                // TCB_ATMega1281RX_Driver1
    652              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
   \   000000A4   914D               LD      R20, X+
   \   000000A6   915C               LD      R21, X
   \   000000A8   9711               SBIW    R27:R26, 1
   \   000000AA   01FA               MOVW    R31:R30, R21:R20
   \   000000AC   9631               ADIW    R31:R30, 1
   \   000000AE   93ED               ST      X+, R30
   \   000000B0   93FC               ST      X, R31
   \   000000B2   9711               SBIW    R27:R26, 1
   \   000000B4   01F8               MOVW    R31:R30, R17:R16
   \   000000B6   0FE4               ADD     R30, R20
   \   000000B8   1FF5               ADC     R31, R21
   \   000000BA   E040               LDI     R20, 0
   \   000000BC   8340               ST      Z, R20
    653              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
   \   000000BE   914D               LD      R20, X+
   \   000000C0   915C               LD      R21, X
   \   000000C2   9711               SBIW    R27:R26, 1
   \   000000C4   01FA               MOVW    R31:R30, R21:R20
   \   000000C6   9631               ADIW    R31:R30, 1
   \   000000C8   93ED               ST      X+, R30
   \   000000CA   93FC               ST      X, R31
   \   000000CC   9711               SBIW    R27:R26, 1
   \   000000CE   01F8               MOVW    R31:R30, R17:R16
   \   000000D0   0FE4               ADD     R30, R20
   \   000000D2   1FF5               ADC     R31, R21
   \   000000D4   E040               LDI     R20, 0
   \   000000D6   8340               ST      Z, R20
    654          #endif
    655              stack = OS_GetStackSpace(&TCB_WATCHDOG);                            // watchdog
    656              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
   \   000000D8   914D               LD      R20, X+
   \   000000DA   915C               LD      R21, X
   \   000000DC   9711               SBIW    R27:R26, 1
   \   000000DE   01FA               MOVW    R31:R30, R21:R20
   \   000000E0   9631               ADIW    R31:R30, 1
   \   000000E2   93ED               ST      X+, R30
   \   000000E4   93FC               ST      X, R31
   \   000000E6   9711               SBIW    R27:R26, 1
   \   000000E8   01F8               MOVW    R31:R30, R17:R16
   \   000000EA   0FE4               ADD     R30, R20
   \   000000EC   1FF5               ADC     R31, R21
   \   000000EE   E040               LDI     R20, 0
   \   000000F0   8340               ST      Z, R20
    657              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
   \   000000F2   914D               LD      R20, X+
   \   000000F4   915C               LD      R21, X
   \   000000F6   9711               SBIW    R27:R26, 1
   \   000000F8   01FA               MOVW    R31:R30, R21:R20
   \   000000FA   9631               ADIW    R31:R30, 1
   \   000000FC   93ED               ST      X+, R30
   \   000000FE   93FC               ST      X, R31
   \   00000100   9711               SBIW    R27:R26, 1
   \   00000102   01F8               MOVW    R31:R30, R17:R16
   \   00000104   0FE4               ADD     R30, R20
   \   00000106   1FF5               ADC     R31, R21
   \   00000108   E040               LDI     R20, 0
   \   0000010A   8340               ST      Z, R20
    658              switch (UnitID) {
   \   0000010C   9140....           LDS     R20, UnitID
   \   00000110   2344               TST     R20
   \   00000112   F011               BREQ    ??BuildStackStatus_0
   \   00000114   954A               DEC     R20
   \   00000116   F5A1               BRNE    ??BuildStackStatus_1
    659              case AN_ZB485 :
    660                  stack = OS_GetStackSpace(&TCB_RS485Ctl);                            // RS485 Control
    661                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
    662                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
    663                  stack = OS_GetStackSpace(&TCB_RS485Rec);                            // RS485 receive
    664                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
    665                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
    666                  break;
    667              case AN_ZBANA :
    668                  stack = OS_GetStackSpace(&TCB_AD7715);                            // AD handling
    669                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
   \                     ??BuildStackStatus_0:
   \   00000118   914D               LD      R20, X+
   \   0000011A   915C               LD      R21, X
   \   0000011C   9711               SBIW    R27:R26, 1
   \   0000011E   01FA               MOVW    R31:R30, R21:R20
   \   00000120   9631               ADIW    R31:R30, 1
   \   00000122   93ED               ST      X+, R30
   \   00000124   93FC               ST      X, R31
   \   00000126   9711               SBIW    R27:R26, 1
   \   00000128   01F8               MOVW    R31:R30, R17:R16
   \   0000012A   0FE4               ADD     R30, R20
   \   0000012C   1FF5               ADC     R31, R21
   \   0000012E   E040               LDI     R20, 0
   \   00000130   8340               ST      Z, R20
    670                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
   \   00000132   914D               LD      R20, X+
   \   00000134   915C               LD      R21, X
   \   00000136   9711               SBIW    R27:R26, 1
   \   00000138   01FA               MOVW    R31:R30, R21:R20
   \   0000013A   9631               ADIW    R31:R30, 1
   \   0000013C   93ED               ST      X+, R30
   \   0000013E   93FC               ST      X, R31
   \   00000140   9711               SBIW    R27:R26, 1
   \   00000142   01F8               MOVW    R31:R30, R17:R16
   \   00000144   0FE4               ADD     R30, R20
   \   00000146   1FF5               ADC     R31, R21
   \   00000148   E040               LDI     R20, 0
   \   0000014A   8340               ST      Z, R20
    671                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0;
   \   0000014C   914D               LD      R20, X+
   \   0000014E   915C               LD      R21, X
   \   00000150   9711               SBIW    R27:R26, 1
   \   00000152   01FA               MOVW    R31:R30, R21:R20
   \   00000154   9631               ADIW    R31:R30, 1
   \   00000156   93ED               ST      X+, R30
   \   00000158   93FC               ST      X, R31
   \   0000015A   9711               SBIW    R27:R26, 1
   \   0000015C   01F8               MOVW    R31:R30, R17:R16
   \   0000015E   0FE4               ADD     R30, R20
   \   00000160   1FF5               ADC     R31, R21
   \   00000162   E040               LDI     R20, 0
   \   00000164   8340               ST      Z, R20
    672                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0;
   \   00000166   914D               LD      R20, X+
   \   00000168   915C               LD      R21, X
   \   0000016A   9711               SBIW    R27:R26, 1
   \   0000016C   01FA               MOVW    R31:R30, R21:R20
   \   0000016E   9631               ADIW    R31:R30, 1
   \   00000170   93ED               ST      X+, R30
   \   00000172   93FC               ST      X, R31
   \   00000174   9711               SBIW    R27:R26, 1
   \   00000176   01F8               MOVW    R31:R30, R17:R16
   \   00000178   0FE4               ADD     R30, R20
   \   0000017A   1FF5               ADC     R31, R21
   \   0000017C   E040               LDI     R20, 0
   \   0000017E   8340               ST      Z, R20
    673                  break;
    674              }
    675          
    676              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \                     ??BuildStackStatus_1:
   \   00000180   0F02               ADD     R16, R18
   \   00000182   1F13               ADC     R17, R19
   \   00000184   01F8               MOVW    R31:R30, R17:R16
   \   00000186   910D               LD      R16, X+
   \   00000188   911C               LD      R17, X
   \   0000018A   9711               SBIW    R27:R26, 1
   \   0000018C   1B02               SUB     R16, R18
   \   0000018E   5002               SUBI    R16, 2
   \   00000190   8300               ST      Z, R16
    677              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000192   918D               LD      R24, X+
   \   00000194   919C               LD      R25, X
   \   00000196   1B82               SUB     R24, R18
   \   00000198   0B93               SBC     R25, R19
   \   0000019A   9702               SBIW    R25:R24, 2
   \   0000019C   8391               STD     Z+1, R25
    678          
    679          }
   \   0000019E   01CB               MOVW    R25:R24, R23:R22
   \   000001A0   01D1               MOVW    R27:R26, R3:R2
   \   000001A2   9508               RET
    680          
    681          //////////////////////////////////////////////////////////////////////////////
    682          // Receiving data to IO module here
    683          /////////////////////////////////////////////////////////////////////////////
    684          
    685          /*************************************************************************
    686          *
    687          * Receive Command to Reset the EEPROM
    688          *
    689          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    690          void GetResetEEPROM(char ch, short pointer) {
   \                     GetResetEEPROM:
    691          
    692              EEPROMReset();
   \   00000000   ........           JMP     EEPROMReset
    693          }
    694          
    695          
    696          /*************************************************************************
    697          *
    698          * Receive Command to go to the bootloader program
    699          *
    700          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    701          void GetGotoBootloader(char ch, short pointer) {
   \                     GetGotoBootloader:
    702          
    703          //    void (*BootApp)(void) = (void(*)())0xF000;
    704          
    705              // 128 -> 1281
    706              /*
    707              while ( (EECR & 1<<EEWE) != 0 ) //chech if EEPROM is ready
    708                  ;
    709              EEARL = (0x0fff & 0xff);
    710              EEARH = (0x0fff >> 8);
    711              EEDR = 0xff;
    712              EECR |= (1<<EEMWE);
    713              EECR |= (1<<EEWE);
    714              while (EECR & (1<<EEWE))
    715                  ;
    716              */
    717              while ((EECR & 1 << EEPE) != 0) //chech if EEPROM is ready
   \                     ??GetGotoBootloader_0:
   \   00000000   99F9               SBIC    0x1F, 0x01
   \   00000002   CFFE               RJMP    ??GetGotoBootloader_0
    718              ;
    719              EEARL = (0x0fff & 0xff);
   \   00000004   EF0F               LDI     R16, 255
   \   00000006   BD01               OUT     0x21, R16
    720              EEARH = (0x0fff >> 8);
   \   00000008   E00F               LDI     R16, 15
   \   0000000A   BD02               OUT     0x22, R16
    721              EEDR = 0xff;
   \   0000000C   EF0F               LDI     R16, 255
   \   0000000E   BD00               OUT     0x20, R16
    722              EECR |= (1 << EEMPE);
   \   00000010   9AFA               SBI     0x1F, 0x02
    723              EECR |= (1 << EEPE);
   \   00000012   9AF9               SBI     0x1F, 0x01
   \   00000014   E108               LDI     R16, 24
   \   00000016   C002               RJMP    ??GetGotoBootloader_1
    724              while (EECR & (1 << EEPE))
    725          
    726                  // 128 -> 1281
    727                  // WDTCR = 0x18;               //Start watchdog to genetate restart
    728                  // WDTCR = 0x08;               //Start watchdog to genetate restart
    729                  WDTCSR = 0x18;               //Start watchdog to genetate restart
   \                     ??GetGotoBootloader_2:
   \   00000018   9300....           STS     _A_WDTCSR, R16
   \                     ??GetGotoBootloader_1:
   \   0000001C   99F9               SBIC    0x1F, 0x01
   \   0000001E   CFFC               RJMP    ??GetGotoBootloader_2
    730              WDTCSR = 0x08;               //Start watchdog to genetate restart
   \   00000020   E008               LDI     R16, 8
   \   00000022   9300....           STS     _A_WDTCSR, R16
    731          }
   \   00000026   9508               RET
   \   00000028                      REQUIRE _A_EECR
   \   00000028                      REQUIRE _A_EEAR
   \   00000028                      REQUIRE _A_EEDR
   \   00000028                      REQUIRE _A_WDTCSR
    732          
    733          /*************************************************************************
    734          *
    735          * Receive EEPROM data
    736          *
    737          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    738          void GetEEPROMData(char ch, short pointer) {
   \                     GetEEPROMData:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
    739          
    740              char channel;
    741              int t0;
    742          
    743              channel = UART[ch].pRxBuffer[pointer];
   \   0000000C   2F40               MOV     R20, R16
   \   0000000E   EF0D               LDI     R16, 253
   \   00000010   E011               LDI     R17, 1
   \   00000012   9F41               MUL     R20, R17
   \   00000014   2D50               MOV     R21, R0
   \   00000016   9F40               MUL     R20, R16
   \   00000018   0D51               ADD     R21, R1
   \   0000001A   ....               LDI     R16, LOW(UART)
   \   0000001C   ....               LDI     R17, (UART) >> 8
   \   0000001E   0D00               ADD     R16, R0
   \   00000020   1F15               ADC     R17, R21
   \   00000022   0F02               ADD     R16, R18
   \   00000024   1F13               ADC     R17, R19
   \   00000026   0128               MOVW    R5:R4, R17:R16
   \   00000028   01D8               MOVW    R27:R26, R17:R16
   \   0000002A   5EA5               SUBI    R26, 229
   \   0000002C   4FBE               SBCI    R27, 254
   \   0000002E   01FD               MOVW    R31:R30, R27:R26
   \   00000030   8120               LD      R18, Z
    744              if ((channel >= 0x80) && (UnitID == 0x01)) { // AN-ZBANA
   \   00000032   3820               CPI     R18, 128
   \   00000034   F100               BRCS    ??GetEEPROMData_0
   \   00000036   9100....           LDS     R16, UnitID
   \   0000003A   3001               CPI     R16, 1
   \   0000003C   F4E1               BRNE    ??GetEEPROMData_0
    745                  *((float *)&TData.Ana.Offset[channel & 0x0f]) = *((float *)&UART[ch].pRxBuffer[pointer + 1]);  //offset
   \   0000003E   ....               LDI     R16, LOW((TData + 98))
   \   00000040   ....               LDI     R17, HIGH((TData + 98))
   \   00000042   2F42               MOV     R20, R18
   \   00000044   E050               LDI     R21, 0
   \   00000046   704F               ANDI    R20, 0x0F
   \   00000048   0F44               LSL     R20
   \   0000004A   0F44               LSL     R20
   \   0000004C   0F04               ADD     R16, R20
   \   0000004E   1F15               ADC     R17, R21
   \   00000050   8141               LDD     R20, Z+1
   \   00000052   8152               LDD     R21, Z+2
   \   00000054   8163               LDD     R22, Z+3
   \   00000056   8174               LDD     R23, Z+4
   \   00000058   01F8               MOVW    R31:R30, R17:R16
   \   0000005A   8340               ST      Z, R20
   \   0000005C   8351               STD     Z+1, R21
   \   0000005E   8362               STD     Z+2, R22
   \   00000060   8373               STD     Z+3, R23
    746                  *((float *)&TData.Ana.Gain[channel & 0x0f]) = *((float *)&UART[ch].pRxBuffer[pointer + 5]);  //gain
   \   00000062   01FD               MOVW    R31:R30, R27:R26
   \   00000064   8145               LDD     R20, Z+5
   \   00000066   8156               LDD     R21, Z+6
   \   00000068   8167               LDD     R22, Z+7
   \   0000006A   8570               LDD     R23, Z+8
   \   0000006C   01F8               MOVW    R31:R30, R17:R16
   \   0000006E   AB40               STD     Z+48, R20
   \   00000070   AB51               STD     Z+49, R21
   \   00000072   AB62               STD     Z+50, R22
   \   00000074   AB73               STD     Z+51, R23
    747              }
    748              WriteEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&UART[ch].pRxBuffer[pointer + 1]);
   \                     ??GetEEPROMData_0:
   \   00000076   E008               LDI     R16, 8
   \   00000078   9F20               MUL     R18, R16
   \   0000007A   01D0               MOVW    R27:R26, R1:R0
   \   0000007C   01A2               MOVW    R21:R20, R5:R4
   \   0000007E   5E44               SUBI    R20, 228
   \   00000080   4F5E               SBCI    R21, 254
   \   00000082   E024               LDI     R18, 4
   \   00000084   0180               MOVW    R17:R16, R1:R0
   \   00000086   ........           CALL    WriteEEPROMBuffer
    749              t0 = OS_GetTime();
   \   0000008A   ........           CALL    OS__Gettime
   \   0000008E   01C8               MOVW    R25:R24, R17:R16
    750              do {
    751                  OS_Delay(1);
   \                     ??GetEEPROMData_1:
   \   00000090   E001               LDI     R16, 1
   \   00000092   E010               LDI     R17, 0
   \   00000094   ........           CALL    OS_Delay
    752              }while ((OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK);  //8.5 ms programming time
   \   00000098   ........           CALL    OS__Gettime
   \   0000009C   1B08               SUB     R16, R24
   \   0000009E   0B19               SBC     R17, R25
   \   000000A0   3204               CPI     R16, 36
   \   000000A2   4010               SBCI    R17, 0
   \   000000A4   F420               BRCC    ??GetEEPROMData_2
   \   000000A6   9100....           LDS     R16, EEPWriteOK
   \   000000AA   2300               TST     R16
   \   000000AC   F389               BREQ    ??GetEEPROMData_1
    753              WriteEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&UART[ch].pRxBuffer[pointer + 5]);
   \                     ??GetEEPROMData_2:
   \   000000AE   E200               LDI     R16, 32
   \   000000B0   0E40               ADD     R4, R16
   \   000000B2   E001               LDI     R16, 1
   \   000000B4   1E50               ADC     R5, R16
   \   000000B6   01A2               MOVW    R21:R20, R5:R4
   \   000000B8   E024               LDI     R18, 4
   \   000000BA   9614               ADIW    R27:R26, 4
   \   000000BC   018D               MOVW    R17:R16, R27:R26
   \   000000BE   ........           CALL    WriteEEPROMBuffer
    754              t0 = OS_GetTime();
   \   000000C2   ........           CALL    OS__Gettime
   \   000000C6   01C8               MOVW    R25:R24, R17:R16
    755              do {
    756                  OS_Delay(1);
   \                     ??GetEEPROMData_3:
   \   000000C8   E001               LDI     R16, 1
   \   000000CA   E010               LDI     R17, 0
   \   000000CC   ........           CALL    OS_Delay
    757              }while ((OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK);
   \   000000D0   ........           CALL    OS__Gettime
   \   000000D4   1B08               SUB     R16, R24
   \   000000D6   0B19               SBC     R17, R25
   \   000000D8   3204               CPI     R16, 36
   \   000000DA   4010               SBCI    R17, 0
   \   000000DC   F420               BRCC    ??GetEEPROMData_4
   \   000000DE   9100....           LDS     R16, EEPWriteOK
   \   000000E2   2300               TST     R16
   \   000000E4   F389               BREQ    ??GetEEPROMData_3
    758          }
   \                     ??GetEEPROMData_4:
   \   000000E6   ....               RJMP    ??Subroutine4_0
    759          
    760          /*************************************************************************
    761          *
    762          * Receive AN-ZB485 setup
    763          *
    764          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    765          void GetRS4Setup(char ch, short pointer) {
   \                     GetRS4Setup:
    766          
    767              TData.RS4.PortUsed = UART[ch].pRxBuffer[pointer];           // Get the setup
   \   00000000   ....               LDI     R30, LOW((UART + 283))
   \   00000002   ....               LDI     R31, HIGH((UART + 283))
   \   00000004   0FE2               ADD     R30, R18
   \   00000006   1FF3               ADC     R31, R19
   \   00000008   2F20               MOV     R18, R16
   \   0000000A   EF0D               LDI     R16, 253
   \   0000000C   E011               LDI     R17, 1
   \   0000000E   9F21               MUL     R18, R17
   \   00000010   2D30               MOV     R19, R0
   \   00000012   9F20               MUL     R18, R16
   \   00000014   0D31               ADD     R19, R1
   \   00000016   0DE0               ADD     R30, R0
   \   00000018   1FF3               ADC     R31, R19
   \   0000001A   8120               LD      R18, Z
   \   0000001C   9320....           STS     TData, R18
    768              TData.RS4.SensorType[0] = UART[ch].pRxBuffer[pointer + 1];       // Get the sensor type
   \   00000020   8101               LDD     R16, Z+1
   \   00000022   9300....           STS     (TData + 1), R16
    769              TData.RS4.SensorType[1] = UART[ch].pRxBuffer[pointer + 2];       // Get the sensor type
   \   00000026   8102               LDD     R16, Z+2
   \   00000028   9300....           STS     (TData + 2), R16
    770              WriteEEPROMByte(EEPROM_PORTSETUP, TData.RS4.PortUsed);      // store in EEPROM
   \   0000002C   E002               LDI     R16, 2
   \   0000002E   E010               LDI     R17, 0
   \   00000030   ........           CALL    WriteEEPROMByte
    771              WriteEEPROMByte(EEPROM_PORTSETUP + 1, TData.RS4.SensorType[0]);
   \   00000034   9120....           LDS     R18, (TData + 1)
   \   00000038   E003               LDI     R16, 3
   \   0000003A   E010               LDI     R17, 0
   \   0000003C   ........           CALL    WriteEEPROMByte
    772              WriteEEPROMByte(EEPROM_PORTSETUP + 2, TData.RS4.SensorType[1]);
   \   00000040   9120....           LDS     R18, (TData + 2)
   \   00000044   E004               LDI     R16, 4
   \   00000046   E010               LDI     R17, 0
   \   00000048   ........           CALL    WriteEEPROMByte
    773              SetRS4Port();                                               // Set power on ports
   \   0000004C   ........           JMP     SetRS4Port
    774          }
    775          
    776          /*************************************************************************
    777          *
    778          * Rceive data fo AD card
    779          *
    780          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    781          void GetADData(char ch, short pointer) {
   \                     GetADData:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F79               MOV     R23, R25
   \   00000006   2E28               MOV     R2, R24
   \   00000008   01C9               MOVW    R25:R24, R19:R18
    782          
    783              char i, pair;
    784          
    785              if (UART[ch].pRxBuffer[pointer] <= 3) {
   \   0000000A   2F20               MOV     R18, R16
   \   0000000C   EF0D               LDI     R16, 253
   \   0000000E   E011               LDI     R17, 1
   \   00000010   9F21               MUL     R18, R17
   \   00000012   2D30               MOV     R19, R0
   \   00000014   9F20               MUL     R18, R16
   \   00000016   0D31               ADD     R19, R1
   \   00000018   ....               LDI     R26, LOW(UART)
   \   0000001A   ....               LDI     R27, (UART) >> 8
   \   0000001C   0DA0               ADD     R26, R0
   \   0000001E   1FB3               ADC     R27, R19
   \   00000020   01FD               MOVW    R31:R30, R27:R26
   \   00000022   0FE8               ADD     R30, R24
   \   00000024   1FF9               ADC     R31, R25
   \   00000026   5EE5               SUBI    R30, 229
   \   00000028   4FFE               SBCI    R31, 254
   \   0000002A   8120               LD      R18, Z
   \   0000002C   3024               CPI     R18, 4
   \   0000002E   F410               BRCC    ??GetADData_0
    786                  pair = 0;
   \   00000030   E000               LDI     R16, 0
   \   00000032   C001               RJMP    ??GetADData_1
    787              } else {
    788                  pair = 1;
   \                     ??GetADData_0:
   \   00000034   E500               LDI     R16, 80
   \                     ??GetADData_1:
   \   00000036   E010               LDI     R17, 0
    789              }
    790              if (!TData.RS4.ToTargetBuffer[pair][0]) {                                // buffer empty?
   \   00000038   ....               LDI     R20, LOW(TData)
   \   0000003A   ....               LDI     R21, (TData) >> 8
   \   0000003C   0F40               ADD     R20, R16
   \   0000003E   1F51               ADC     R21, R17
   \   00000040   018A               MOVW    R17:R16, R21:R20
   \   00000042   500C               SUBI    R16, 12
   \   00000044   4F1B               SBCI    R17, 251
   \   00000046   01F8               MOVW    R31:R30, R17:R16
   \   00000048   8130               LD      R19, Z
   \   0000004A   2333               TST     R19
   \   0000004C   F531               BRNE    ??GetADData_2
    791                  TData.RS4.ToTargetBuffer[pair][0] = true;                            //  Availible data for AD card
   \   0000004E   E031               LDI     R19, 1
   \   00000050   8330               ST      Z, R19
    792                  TData.RS4.ToTargetBuffer[pair][1] = UART[ch].pRxBuffer[pointer++];   //  Channel to AD card
   \   00000052   8321               STD     Z+1, R18
    793                  TData.RS4.ToTargetBuffer[pair][2] = UART[ch].pRxBuffer[pointer++];   // nob in datablock
   \   00000054   9601               ADIW    R25:R24, 1
   \   00000056   01FD               MOVW    R31:R30, R27:R26
   \   00000058   0FE8               ADD     R30, R24
   \   0000005A   1FF9               ADC     R31, R25
   \   0000005C   5EE5               SUBI    R30, 229
   \   0000005E   4FFE               SBCI    R31, 254
   \   00000060   8120               LD      R18, Z
   \   00000062   01F8               MOVW    R31:R30, R17:R16
   \   00000064   8322               STD     Z+2, R18
    794                  for (i = 3; i < TData.RS4.ToTargetBuffer[pair][2] + 3; i++) {
   \   00000066   E023               LDI     R18, 3
   \   00000068   0FA8               ADD     R26, R24
   \   0000006A   1FB9               ADC     R27, R25
   \   0000006C   5EA4               SUBI    R26, 228
   \   0000006E   4FBE               SBCI    R27, 254
   \   00000070   81E2               LDD     R30, Z+2
   \   00000072   E0F0               LDI     R31, 0
   \   00000074   9633               ADIW    R31:R30, 3
   \   00000076   9734               SBIW    R31:R30, 4
   \   00000078   F084               BRLT    ??GetADData_2
    795                      TData.RS4.ToTargetBuffer[pair][i] = UART[ch].pRxBuffer[pointer++];  //Get the buffer
   \                     ??GetADData_3:
   \   0000007A   916D               LD      R22, X+
   \   0000007C   E030               LDI     R19, 0
   \   0000007E   01FA               MOVW    R31:R30, R21:R20
   \   00000080   0FE2               ADD     R30, R18
   \   00000082   1FF3               ADC     R31, R19
   \   00000084   50EC               SUBI    R30, 12
   \   00000086   4FFB               SBCI    R31, 251
   \   00000088   8360               ST      Z, R22
    796                  }
   \   0000008A   9523               INC     R18
   \   0000008C   01F8               MOVW    R31:R30, R17:R16
   \   0000008E   81E2               LDD     R30, Z+2
   \   00000090   E0F0               LDI     R31, 0
   \   00000092   9633               ADIW    R31:R30, 3
   \   00000094   172E               CP      R18, R30
   \   00000096   073F               CPC     R19, R31
   \   00000098   F384               BRLT    ??GetADData_3
    797              }
    798          }
   \                     ??GetADData_2:
   \   0000009A                      REQUIRE ?Subroutine3
   \   0000009A                      ;               // Fall through to label ?Subroutine3
    799          
    800          /*************************************************************************
    801          *
    802          * Receive AN-ZBANA setup
    803          *
    804          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    805          void GetANASetup(char ch, short pointer) {
   \                     GetANASetup:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
    806          
    807              TData.Ana.PortUsed = UART[ch].pRxBuffer[pointer] + (UART[ch].pRxBuffer[pointer + 1] << 8);  //Get the setup
   \   00000004   ....               LDI     R26, LOW((UART + 283))
   \   00000006   ....               LDI     R27, HIGH((UART + 283))
   \   00000008   0FA2               ADD     R26, R18
   \   0000000A   1FB3               ADC     R27, R19
   \   0000000C   2F20               MOV     R18, R16
   \   0000000E   EF0D               LDI     R16, 253
   \   00000010   E011               LDI     R17, 1
   \   00000012   9F21               MUL     R18, R17
   \   00000014   2D30               MOV     R19, R0
   \   00000016   9F20               MUL     R18, R16
   \   00000018   0D31               ADD     R19, R1
   \   0000001A   0DA0               ADD     R26, R0
   \   0000001C   1FB3               ADC     R27, R19
   \   0000001E   910C               LD      R16, X
   \   00000020   01FD               MOVW    R31:R30, R27:R26
   \   00000022   8111               LDD     R17, Z+1
   \   00000024   9300....           STS     TData, R16
   \   00000028   9310....           STS     (TData + 1), R17
    808              WriteEEPROMByte(EEPROM_PORTSETUP, UART[ch].pRxBuffer[pointer]);   // store in EEPROM
   \   0000002C   8120               LD      R18, Z
   \   0000002E   E002               LDI     R16, 2
   \   00000030   E010               LDI     R17, 0
   \   00000032   ........           CALL    WriteEEPROMByte
    809              WriteEEPROMByte(EEPROM_PORTSETUP + 1, UART[ch].pRxBuffer[pointer + 1]);
   \   00000036   01FD               MOVW    R31:R30, R27:R26
   \   00000038   8121               LDD     R18, Z+1
   \   0000003A   E003               LDI     R16, 3
   \   0000003C   E010               LDI     R17, 0
   \   0000003E   ........           CALL    WriteEEPROMByte
    810              SetAnaPort();                           // set the port on or off
   \   00000042   ........           CALL    SetAnaPort
    811          }
   \   00000046   91A9               LD      R26, Y+
   \   00000048   91B9               LD      R27, Y+
   \   0000004A   9508               RET
    812          
    813          /*************************************************************************
    814          *
    815          * Receive AN-ZBANA filter
    816          *
    817          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    818          void GetANAFilter(char ch, short pointer) {
   \                     GetANAFilter:
   \   00000000   01AD               MOVW    R21:R20, R27:R26
    819              char port;
    820          
    821              for (port = 0; port < 12; port++) {
   \   00000002   ....               LDI     R26, LOW((UART + 283))
   \   00000004   ....               LDI     R27, HIGH((UART + 283))
   \   00000006   0FA2               ADD     R26, R18
   \   00000008   1FB3               ADC     R27, R19
   \   0000000A   2F20               MOV     R18, R16
   \   0000000C   EF0D               LDI     R16, 253
   \   0000000E   E011               LDI     R17, 1
   \   00000010   9F21               MUL     R18, R17
   \   00000012   2D30               MOV     R19, R0
   \   00000014   9F20               MUL     R18, R16
   \   00000016   0D31               ADD     R19, R1
   \   00000018   0DA0               ADD     R26, R0
   \   0000001A   1FB3               ADC     R27, R19
   \   0000001C   ....               LDI     R30, LOW((TData + 2))
   \   0000001E   ....               LDI     R31, HIGH((TData + 2))
   \   00000020   E00C               LDI     R16, 12
    822                  TData.Ana.Filter[port] = UART[ch].pRxBuffer[pointer++];  //Get the filter
   \                     ??GetANAFilter_0:
   \   00000022   911D               LD      R17, X+
   \   00000024   9311               ST      Z+, R17
    823              }
   \   00000026   950A               DEC     R16
   \   00000028   F7E1               BRNE    ??GetANAFilter_0
    824          }
   \   0000002A   01DA               MOVW    R27:R26, R21:R20
   \   0000002C   9508               RET
    825          
    826          
    827          /*************************************************************************
    828          *
    829          *  Receive data on USARTs
    830          *
    831          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    832          void ReceivePacketUart(char ch) {
   \                     ReceivePacketUart:
   \   00000000   924A               ST      -Y, R4
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000A   2E40               MOV     R4, R16
    833          
    834              switch (UART[ch].RxState) {                  // check status
   \   0000000C   2F20               MOV     R18, R16
   \   0000000E   EF0D               LDI     R16, 253
   \   00000010   E011               LDI     R17, 1
   \   00000012   9F21               MUL     R18, R17
   \   00000014   2D30               MOV     R19, R0
   \   00000016   9F20               MUL     R18, R16
   \   00000018   0D31               ADD     R19, R1
   \   0000001A   ....               LDI     R24, LOW(UART)
   \   0000001C   ....               LDI     R25, (UART) >> 8
   \   0000001E   0D80               ADD     R24, R0
   \   00000020   1F93               ADC     R25, R19
   \   00000022   01DC               MOVW    R27:R26, R25:R24
   \   00000024   54AD               SUBI    R26, 77
   \   00000026   4FBE               SBCI    R27, 254
   \   00000028   01FD               MOVW    R31:R30, R27:R26
   \   0000002A   8104               LDD     R16, Z+4
   \   0000002C   2300               TST     R16
   \   0000002E   F409               BRNE    $+2+2
   \   00000030   C0BA               RJMP    ??ReceivePacketUart_0
   \   00000032   950A               DEC     R16
   \   00000034   F039               BREQ    ??ReceivePacketUart_1
   \   00000036   950A               DEC     R16
   \   00000038   F409               BRNE    $+2+2
   \   0000003A   C04A               RJMP    ??ReceivePacketUart_2
   \   0000003C   5008               SUBI    R16, 8
   \   0000003E   F409               BRNE    $+2+2
   \   00000040   C0B2               RJMP    ??ReceivePacketUart_0
   \   00000042   C0AE               RJMP    ??ReceivePacketUart_3
    835              case SYNC :
    836                  // all functionallity in inerrupt routine
    837                  break;
    838              case HEADER :
    839                  if (UART[ch].RxLast >= 6) {             // receive header
   \                     ??ReceivePacketUart_1:
   \   00000044   91ED               LD      R30, X+
   \   00000046   91FC               LD      R31, X
   \   00000048   9711               SBIW    R27:R26, 1
   \   0000004A   9736               SBIW    R31:R30, 6
   \   0000004C   F408               BRCC    $+2+2
   \   0000004E   C0AB               RJMP    ??ReceivePacketUart_0
    840                      UART[ch].RxPacklen = (UART[ch].pRxBuffer[4] + (UART[ch].pRxBuffer[5] * 256)); // Find length of package
   \   00000050   5E85               SUBI    R24, 229
   \   00000052   4F9E               SBCI    R25, 254
   \   00000054   01FC               MOVW    R31:R30, R25:R24
   \   00000056   8104               LDD     R16, Z+4
   \   00000058   8115               LDD     R17, Z+5
   \   0000005A   01FD               MOVW    R31:R30, R27:R26
   \   0000005C   8700               STD     Z+8, R16
   \   0000005E   8711               STD     Z+9, R17
    841                      if (CalcDSRxChecksum(ch, 6) && (UART[ch].pRxBuffer[0] == (DEVICE_IO + UnitID))) {
   \   00000060   E040               LDI     R20, 0
   \   00000062   018C               MOVW    R17:R16, R25:R24
   \   00000064   E026               LDI     R18, 6
   \   00000066   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_4:
   \   00000068   01F8               MOVW    R31:R30, R17:R16
   \   0000006A   9161               LD      R22, Z+
   \   0000006C   018F               MOVW    R17:R16, R31:R30
   \   0000006E   2746               EOR     R20, R22
   \   00000070   2FE4               MOV     R30, R20
   \   00000072   E0F0               LDI     R31, 0
   \   00000074   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000076   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000078   BF3B               OUT     0x3B, R19
   \   0000007A   9146               ELPM    R20, Z
   \   0000007C   952A               DEC     R18
   \   0000007E   F7A1               BRNE    ??ReceivePacketUart_4
   \   00000080   01FC               MOVW    R31:R30, R25:R24
   \   00000082   8106               LDD     R16, Z+6
   \   00000084   1740               CP      R20, R16
   \   00000086   F009               BREQ    $+2+2
   \   00000088   C08B               RJMP    ??ReceivePacketUart_3
   \   0000008A   8100               LD      R16, Z
   \   0000008C   E010               LDI     R17, 0
   \   0000008E   91E0....           LDS     R30, UnitID
   \   00000092   E0F0               LDI     R31, 0
   \   00000094   9670               ADIW    R31:R30, 16
   \   00000096   170E               CP      R16, R30
   \   00000098   071F               CPC     R17, R31
   \   0000009A   F009               BREQ    $+2+2
   \   0000009C   C081               RJMP    ??ReceivePacketUart_3
    842                          // header checksum OK and to me
    843                          if ((UART[ch].RxPacklen < ((short)RXSIZE_UART - UART[ch].RxLast)) && (UART[ch].RxPacklen >= MIN_PACK_LEN)) {    /* chk. header */
   \   0000009E   01FD               MOVW    R31:R30, R27:R26
   \   000000A0   8520               LDD     R18, Z+8
   \   000000A2   8531               LDD     R19, Z+9
   \   000000A4   E906               LDI     R16, 150
   \   000000A6   8140               LD      R20, Z
   \   000000A8   8151               LDD     R21, Z+1
   \   000000AA   1B04               SUB     R16, R20
   \   000000AC   0B15               SBC     R17, R21
   \   000000AE   1720               CP      R18, R16
   \   000000B0   0731               CPC     R19, R17
   \   000000B2   F008               BRCS    $+2+2
   \   000000B4   C075               RJMP    ??ReceivePacketUart_3
   \   000000B6   8580               LDD     R24, Z+8
   \   000000B8   8591               LDD     R25, Z+9
   \   000000BA   9707               SBIW    R25:R24, 7
   \   000000BC   F408               BRCC    $+2+2
   \   000000BE   C070               RJMP    ??ReceivePacketUart_3
    844                              UART[ch].RxState = RECEIVE;       // Header ok go to data receive state
   \   000000C0   E002               LDI     R16, 2
   \   000000C2   8304               STD     Z+4, R16
    845                              UART[ch].RxCount = UART[ch].RxLast + 1;                     // Set receive counter
   \   000000C4   8180               LD      R24, Z
   \   000000C6   8191               LDD     R25, Z+1
   \   000000C8   9601               ADIW    R25:R24, 1
   \   000000CA   8382               STD     Z+2, R24
   \   000000CC   8393               STD     Z+3, R25
   \   000000CE   C06B               RJMP    ??ReceivePacketUart_0
    846                          } else {
    847                              GoToSyncUART(ch);                     // go to sync modus for recive
    848                          }
    849                      } else {
    850                          GoToSyncUART(ch);                     // go to sync modus for recive
    851                      }
    852                  }
    853                  break;
    854          
    855              case RECEIVE :
    856                  ++UART[ch].RxCount;
   \                     ??ReceivePacketUart_2:
   \   000000D0   01FC               MOVW    R31:R30, R25:R24
   \   000000D2   54EB               SUBI    R30, 75
   \   000000D4   4FFE               SBCI    R31, 254
   \   000000D6   8100               LD      R16, Z
   \   000000D8   8111               LDD     R17, Z+1
   \   000000DA   5F0F               SUBI    R16, 255
   \   000000DC   4F1F               SBCI    R17, 255
   \   000000DE   8300               ST      Z, R16
   \   000000E0   8311               STD     Z+1, R17
    857                  if (UART[ch].RxCount >= UART[ch].RxPacklen) {
   \   000000E2   01FD               MOVW    R31:R30, R27:R26
   \   000000E4   8102               LDD     R16, Z+2
   \   000000E6   8113               LDD     R17, Z+3
   \   000000E8   8520               LDD     R18, Z+8
   \   000000EA   8531               LDD     R19, Z+9
   \   000000EC   1702               CP      R16, R18
   \   000000EE   0713               CPC     R17, R19
   \   000000F0   F408               BRCC    $+2+2
   \   000000F2   C059               RJMP    ??ReceivePacketUart_0
    858                      if ((UART[ch].pRxBuffer[UART[ch].RxPacklen - 1]) == ANPRO10_EOT) {
   \   000000F4   8500               LDD     R16, Z+8
   \   000000F6   8511               LDD     R17, Z+9
   \   000000F8   01FC               MOVW    R31:R30, R25:R24
   \   000000FA   0FE0               ADD     R30, R16
   \   000000FC   1FF1               ADC     R31, R17
   \   000000FE   5EE6               SUBI    R30, 230
   \   00000100   4FFE               SBCI    R31, 254
   \   00000102   8100               LD      R16, Z
   \   00000104   3004               CPI     R16, 4
   \   00000106   F009               BREQ    $+2+2
   \   00000108   C04B               RJMP    ??ReceivePacketUart_3
    859                          if (CalcDSRxChecksum(ch, UART[ch].RxPacklen - 2)) {
   \   0000010A   01FD               MOVW    R31:R30, R27:R26
   \   0000010C   8400               LDD     R0, Z+8
   \   0000010E   8411               LDD     R1, Z+9
   \   00000110   EF0E               LDI     R16, 254
   \   00000112   0E00               ADD     R0, R16
   \   00000114   EF0F               LDI     R16, 255
   \   00000116   1E10               ADC     R1, R16
   \   00000118   E060               LDI     R22, 0
   \   0000011A   2D00               MOV     R16, R0
   \   0000011C   2901               OR      R16, R1
   \   0000011E   F091               BREQ    ??ReceivePacketUart_5
   \   00000120   018C               MOVW    R17:R16, R25:R24
   \   00000122   5E05               SUBI    R16, 229
   \   00000124   4F1E               SBCI    R17, 254
   \   00000126   01A0               MOVW    R21:R20, R1:R0
   \   00000128   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_6:
   \   0000012A   01F8               MOVW    R31:R30, R17:R16
   \   0000012C   9121               LD      R18, Z+
   \   0000012E   018F               MOVW    R17:R16, R31:R30
   \   00000130   2762               EOR     R22, R18
   \   00000132   2FE6               MOV     R30, R22
   \   00000134   E0F0               LDI     R31, 0
   \   00000136   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000138   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000013A   BF3B               OUT     0x3B, R19
   \   0000013C   9166               ELPM    R22, Z
   \   0000013E   5041               SUBI    R20, 1
   \   00000140   4050               SBCI    R21, 0
   \   00000142   F799               BRNE    ??ReceivePacketUart_6
   \                     ??ReceivePacketUart_5:
   \   00000144   01FC               MOVW    R31:R30, R25:R24
   \   00000146   0DE0               ADD     R30, R0
   \   00000148   1DF1               ADC     R31, R1
   \   0000014A   5EE5               SUBI    R30, 229
   \   0000014C   4FFE               SBCI    R31, 254
   \   0000014E   8100               LD      R16, Z
   \   00000150   1760               CP      R22, R16
   \   00000152   F531               BRNE    ??ReceivePacketUart_3
    860                              if ((UART[ch].pRxBuffer[1] == MyAddress()) ||      // message to me? or
    861                                  (UART[ch].pRxBuffer[1] == 0xff)) {            // broadcast
   \   00000154   ........           CALL    MyAddress
   \   00000158   5E85               SUBI    R24, 229
   \   0000015A   4F9E               SBCI    R25, 254
   \   0000015C   01FC               MOVW    R31:R30, R25:R24
   \   0000015E   8111               LDD     R17, Z+1
   \   00000160   1710               CP      R17, R16
   \   00000162   F011               BREQ    ??ReceivePacketUart_7
   \   00000164   3F1F               CPI     R17, 255
   \   00000166   F4E1               BRNE    ??ReceivePacketUart_3
    862                                  hostAddress = UART[ch].pRxBuffer[3];                     // address to sender (host)
   \                     ??ReceivePacketUart_7:
   \   00000168   8103               LDD     R16, Z+3
   \   0000016A   9300....           STS     hostAddress, R16
    863                                  UART[ch].RxState = HANDLE;                     // Package OK
   \   0000016E   01FD               MOVW    R31:R30, R27:R26
   \   00000170   E00A               LDI     R16, 10
   \   00000172   8304               STD     Z+4, R16
    864                                  switch (ch) {
   \   00000174   2044               TST     R4
   \   00000176   F019               BREQ    ??ReceivePacketUart_8
   \   00000178   944A               DEC     R4
   \   0000017A   F039               BREQ    ??ReceivePacketUart_9
   \   0000017C   C014               RJMP    ??ReceivePacketUart_0
    865                                  case 0:
    866                                      OS_Use(&UARTSEND);
   \                     ??ReceivePacketUart_8:
   \   0000017E   ....               LDI     R16, LOW(UARTSEND)
   \   00000180   ....               LDI     R17, (UARTSEND) >> 8
   \   00000182   ........           CALL    OS_Use
    867                                      UsartCheckPackage(0);
   \   00000186   E000               LDI     R16, 0
   \   00000188   C005               RJMP    ??ReceivePacketUart_10
    868                                      OS_Unuse(&UARTSEND);
    869                                      break;
    870                                  case 1:
    871                                      OS_Use(&UARTSEND);
   \                     ??ReceivePacketUart_9:
   \   0000018A   ....               LDI     R16, LOW(UARTSEND)
   \   0000018C   ....               LDI     R17, (UARTSEND) >> 8
   \   0000018E   ........           CALL    OS_Use
    872                                      UsartCheckPackage(1);
   \   00000192   E001               LDI     R16, 1
   \                     ??ReceivePacketUart_10:
   \   00000194   ....               RCALL   UsartCheckPackage
    873                                      OS_Unuse(&UARTSEND);
   \   00000196   ....               LDI     R16, LOW(UARTSEND)
   \   00000198   ....               LDI     R17, (UARTSEND) >> 8
   \   0000019A   ........           CALL    OS_Unuse
    874                                      break;
   \   0000019E   C003               RJMP    ??ReceivePacketUart_0
    875                                  }
    876                              } else {
    877                                  GoToSyncUART(ch);                     // go to sync modus for recive
    878                              }
    879                          } else {
    880                              GoToSyncUART(ch);                     // go to sync modus for recive
    881                          }
    882                      } else {
    883                          GoToSyncUART(ch);                     // go to sync modus for recive
    884                      }
    885                  }
    886                  break;
    887              case HANDLE :
    888                  break;
    889              default:
    890                  GoToSyncUART(ch);                                            // go to sync modus for recive
   \                     ??ReceivePacketUart_3:
   \   000001A0   2D04               MOV     R16, R4
   \   000001A2   ........           CALL    GoToSyncUART
    891                  break;
    892              }                                                           // end switch
    893              if (++UART[ch].RxLast >= RXSIZE_UART) {                     // check pointer
   \                     ??ReceivePacketUart_0:
   \   000001A6   91ED               LD      R30, X+
   \   000001A8   91FC               LD      R31, X
   \   000001AA   9711               SBIW    R27:R26, 1
   \   000001AC   9631               ADIW    R31:R30, 1
   \   000001AE   93ED               ST      X+, R30
   \   000001B0   93FC               ST      X, R31
   \   000001B2   9711               SBIW    R27:R26, 1
   \   000001B4   39E6               CPI     R30, 150
   \   000001B6   E000               LDI     R16, 0
   \   000001B8   40F0               SBCI    R31, 0
   \   000001BA   F010               BRCS    ??ReceivePacketUart_11
    894                  UART[ch].RxLast = 0;                                     // reset pointer
   \   000001BC   930D               ST      X+, R16
   \   000001BE   930C               ST      X, R16
    895              }
    896          }
   \                     ??ReceivePacketUart_11:
   \   000001C0   9189               LD      R24, Y+
   \   000001C2   9199               LD      R25, Y+
   \   000001C4   91A9               LD      R26, Y+
   \   000001C6   91B9               LD      R27, Y+
   \   000001C8   9049               LD      R4, Y+
   \   000001CA   9508               RET
    897          
    898          
    899          /*************************************************************************
    900          *
    901          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    902          *
    903          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    904          char CalcDSTxChecksum(char ch, unsigned short len) {
   \                     CalcDSTxChecksum:
   \   00000000   2F7B               MOV     R23, R27
   \   00000002   2E2A               MOV     R2, R26
   \   00000004   2F19               MOV     R17, R25
   \   00000006   2F68               MOV     R22, R24
   \   00000008   2F40               MOV     R20, R16
   \   0000000A   01C9               MOVW    R25:R24, R19:R18
    905              unsigned short  cnt;
    906              unsigned char   csum;
    907          
    908              csum = 0;
   \   0000000C   E000               LDI     R16, 0
    909              for (cnt = 4; cnt < len; cnt++) {
   \   0000000E   3025               CPI     R18, 5
   \   00000010   4030               SBCI    R19, 0
   \   00000012   F0B0               BRCS    ??CalcDSTxChecksum_0
   \   00000014   ....               LDI     R26, LOW((UART + 4))
   \   00000016   ....               LDI     R27, HIGH((UART + 4))
   \   00000018   EF2D               LDI     R18, 253
   \   0000001A   E031               LDI     R19, 1
   \   0000001C   9F43               MUL     R20, R19
   \   0000001E   2D50               MOV     R21, R0
   \   00000020   9F42               MUL     R20, R18
   \   00000022   0D51               ADD     R21, R1
   \   00000024   0DA0               ADD     R26, R0
   \   00000026   1FB5               ADC     R27, R21
   \   00000028   9704               SBIW    R25:R24, 4
   \   0000002A   ....               LDI     R19, (crc) >> 16
    910                  csum = crc[csum ^ UART[ch].pTxBuffer[cnt]];
   \                     ??CalcDSTxChecksum_1:
   \   0000002C   2FE0               MOV     R30, R16
   \   0000002E   E0F0               LDI     R31, 0
   \   00000030   910D               LD      R16, X+
   \   00000032   27E0               EOR     R30, R16
   \   00000034   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000036   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000038   BF3B               OUT     0x3B, R19
   \   0000003A   9106               ELPM    R16, Z
    911              }
   \   0000003C   9701               SBIW    R25:R24, 1
   \   0000003E   F7B1               BRNE    ??CalcDSTxChecksum_1
    912              return csum;
   \                     ??CalcDSTxChecksum_0:
   \   00000040   2F86               MOV     R24, R22
   \   00000042   2F91               MOV     R25, R17
   \   00000044   2DA2               MOV     R26, R2
   \   00000046   2FB7               MOV     R27, R23
   \   00000048   9508               RET
    913          }
    914          
    915          /*************************************************************************
    916          *
    917          * Calculate rx packet checksum (header and package) using Dallas Semiconductor one-wire CRC
    918          *
    919          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    920          short CalcDSRxChecksum(char ch, unsigned short len) {
   \                     CalcDSRxChecksum:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   011C               MOVW    R3:R2, R25:R24
   \   00000006   01A9               MOVW    R21:R20, R19:R18
    921          
    922              unsigned short  cnt;
    923              unsigned char   csum;
    924          
    925              csum = 0;
   \   00000008   E020               LDI     R18, 0
    926          
    927              for (cnt = 0; cnt < len; cnt++) {
   \   0000000A   2F60               MOV     R22, R16
   \   0000000C   EF0D               LDI     R16, 253
   \   0000000E   E011               LDI     R17, 1
   \   00000010   9F61               MUL     R22, R17
   \   00000012   2D70               MOV     R23, R0
   \   00000014   9F60               MUL     R22, R16
   \   00000016   0D71               ADD     R23, R1
   \   00000018   ....               LDI     R16, LOW(UART)
   \   0000001A   ....               LDI     R17, (UART) >> 8
   \   0000001C   0D00               ADD     R16, R0
   \   0000001E   1F17               ADC     R17, R23
   \   00000020   2F34               MOV     R19, R20
   \   00000022   2B35               OR      R19, R21
   \   00000024   F079               BREQ    ??CalcDSRxChecksum_0
   \   00000026   01D8               MOVW    R27:R26, R17:R16
   \   00000028   5EA5               SUBI    R26, 229
   \   0000002A   4FBE               SBCI    R27, 254
   \   0000002C   01CA               MOVW    R25:R24, R21:R20
   \   0000002E   ....               LDI     R19, (crc) >> 16
    928                  csum = crc[csum ^ UART[ch].pRxBuffer[cnt]];
   \                     ??CalcDSRxChecksum_1:
   \   00000030   2FE2               MOV     R30, R18
   \   00000032   E0F0               LDI     R31, 0
   \   00000034   912D               LD      R18, X+
   \   00000036   27E2               EOR     R30, R18
   \   00000038   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000003A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000003C   BF3B               OUT     0x3B, R19
   \   0000003E   9126               ELPM    R18, Z
    929              }
   \   00000040   9701               SBIW    R25:R24, 1
   \   00000042   F7B1               BRNE    ??CalcDSRxChecksum_1
    930              if (csum == UART[ch].pRxBuffer[len]) {
   \                     ??CalcDSRxChecksum_0:
   \   00000044   0F04               ADD     R16, R20
   \   00000046   1F15               ADC     R17, R21
   \   00000048   5E05               SUBI    R16, 229
   \   0000004A   4F1E               SBCI    R17, 254
   \   0000004C   01F8               MOVW    R31:R30, R17:R16
   \   0000004E   8100               LD      R16, Z
   \   00000050   1720               CP      R18, R16
   \   00000052   F411               BRNE    ??CalcDSRxChecksum_2
    931                  return true;
   \   00000054   E001               LDI     R16, 1
   \   00000056   C001               RJMP    ??CalcDSRxChecksum_3
    932              } else {
    933                  return false;
   \                     ??CalcDSRxChecksum_2:
   \   00000058   E000               LDI     R16, 0
   \                     ??CalcDSRxChecksum_3:
   \   0000005A   E010               LDI     R17, 0
    934              }
   \   0000005C   ........           JMP     ??Subroutine6_0
    935          }
    936          
    937          
    938          /*************************************************************************
    939          *
    940          * Goes to sync mode
    941          *
    942          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    943          __monitor void GoToSyncUART(char ch) {
   \                     GoToSyncUART:
   \   00000000   B74F               IN      R20, 0x3F
   \   00000002   94F8               CLI
    944          
    945              if (ch < 2) {
   \   00000004   3002               CPI     R16, 2
   \   00000006   F480               BRCC    ??GoToSyncUART_0
    946                  UART[ch].SyncCnt = 0;  // ready for sync
   \   00000008   ....               LDI     R30, LOW((UART + 433))
   \   0000000A   ....               LDI     R31, HIGH((UART + 433))
   \   0000000C   2F20               MOV     R18, R16
   \   0000000E   EF0D               LDI     R16, 253
   \   00000010   E011               LDI     R17, 1
   \   00000012   9F21               MUL     R18, R17
   \   00000014   2D30               MOV     R19, R0
   \   00000016   9F20               MUL     R18, R16
   \   00000018   0D31               ADD     R19, R1
   \   0000001A   0DE0               ADD     R30, R0
   \   0000001C   1FF3               ADC     R31, R19
   \   0000001E   E000               LDI     R16, 0
   \   00000020   8307               STD     Z+7, R16
    947                  UART[ch].RxState = SYNC;
   \   00000022   8306               STD     Z+6, R16
    948                  UART[ch].RxFirst = 0;
   \   00000024   8300               ST      Z, R16
   \   00000026   8301               STD     Z+1, R16
    949              }
    950          }
   \                     ??GoToSyncUART_0:
   \   00000028   BF4F               OUT     0x3F, R20
   \   0000002A   9508               RET

   \                                 In  segment SWITCH, align 2, keep-with-next
   \                     `?<Jumptable for CheckActionUart>_0`:
   \   00000000   E803               DW      59395
   \   00000002   01                 DB      1
   \   00000003   ....               DW      (??CheckActionUart_24) /2
   \   00000005   ....               DW      (??CheckActionUart_0) /2
   \   00000007   0A                 DB      0xa
   \   00000008   ....               DW      (??CheckActionUart_3) /2
   \   0000000A   0A                 DB      0xa
   \   0000000B   ....               DW      (??CheckActionUart_4) /2
   \   0000000D   32                 DB      0x32
   \   0000000E   ....               DW      (??CheckActionUart_7) /2
   \   00000010   0A                 DB      0xa
   \   00000011   ....               DW      (??CheckActionUart_8) /2
   \   00000013   0A                 DB      0xa
   \   00000014   ....               DW      (??CheckActionUart_9) /2
   \   00000016   0A                 DB      0xa
   \   00000017   ....               DW      (??CheckActionUart_10) /2
   \   00000019   0A                 DB      0xa
   \   0000001A   ....               DW      (??CheckActionUart_11) /2
   \   0000001C   1E                 DB      0x1e
   \   0000001D   ....               DW      (??CheckActionUart_13) /2
   \   0000001F   14                 DB      0x14
   \   00000020   ....               DW      (??CheckActionUart_12) /2
   \   00000022   28                 DB      0x28
   \   00000023   ....               DW      (??CheckActionUart_18) /2
   \   00000025   0A                 DB      0xa
   \   00000026   ....               DW      (??CheckActionUart_19) /2
   \   00000028   0A                 DB      0xa
   \   00000029   ....               DW      (??CheckActionUart_20) /2
   \   0000002B   0A                 DB      0xa
   \   0000002C   ....               DW      (??CheckActionUart_22) /2
   \   0000002E   0A                 DB      0xa
   \   0000002F   ....               DW      (??CheckActionUart_23) /2
   \   00000031   02FE9E             DB      254,0x2,0x9e
   \   00000034   ....               DW      (??CheckActionUart_2) /2
   \   00000036   FB                 DB      251
   \   00000037   00                 DB      0

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      2      2   BuildADEpromdata
      2      2   BuildADInt
      2      2   BuildANAFilter
      2      2   BuildANASetup
      8      2   BuildEEPROMData
        8      2   -> ReadEEPROMBuffer
      7      2   BuildMData485
      6      2   BuildMDataANA
      6      2   BuildRData485
      1      2   BuildRS4Setup
      0      2   BuildStackStatus
      8      2   BuildStatusData
        8      2   -> MyAddress
      8      2   BuildWHdata
        8      2   -> OS_LeaveRegion
      2      2   CalcDSRxChecksum
      0      2   CalcDSTxChecksum
     10      2   CheckActionUart
       10      2   -> BuildADEpromdata
       10      2   -> BuildADInt
       10      2   -> BuildANAFilter
       10      2   -> BuildANASetup
       10      2   -> BuildEEPROMData
       10      2   -> BuildMData485
       10      2   -> BuildMDataANA
       10      2   -> BuildRData485
       10      2   -> BuildRS4Setup
       10      2   -> BuildStackStatus
       10      2   -> BuildStatusData
       10      2   -> BuildWHdata
       10      2   -> EEPROMReset
       10      2   -> GetADData
       10      2   -> GetANASetup
       10      2   -> GetEEPROMData
       10      2   -> GetRS4Setup
       10      2 ?SS_SHR_L02
       10      2 ?SV_SWITCH_L06
      1      2   GetADData
      0      2   GetANAFilter
      2      2   GetANASetup
        2      2   -> SetAnaPort
        2      2   -> WriteEEPROMByte
      6      2   GetEEPROMData
        6      2   -> OS_Delay
        6      2   -> OS__Gettime
        6      2   -> WriteEEPROMBuffer
      0      2   GetGotoBootloader
      0      2   GetRS4Setup
        0      2   -> SetRS4Port
        0      2   -> WriteEEPROMByte
      0      2   GetResetEEPROM
        0      2   -> EEPROMReset
      0      2   GoToSyncUART
      5      2   ReceivePacketUart
        5      2   -> GoToSyncUART
        5      2   -> MyAddress
        5      2   -> OS_Unuse
        5      2   -> OS_Use
        5      2   -> UsartCheckPackage
      0      2   TimoutUSART0
        0      2   -> GoToSyncUART
      0      2   TimoutUSART0On
      0      2   TimoutUSART1
        0      2   -> GoToSyncUART
      0      2   TimoutUSART1On
      2      2   Uart_BuildHeader
        2      2   -> MyAddress
      3      2   Uart_BuildTail
        3      2   -> OS_RetriggerTimer
        3      2   -> Uart_BuildHeader
      7      2   UsartCheckPackage
        7      2   -> CheckActionUart
        7      2   -> GoToSyncUART
        7      2   -> Uart_BuildTail


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      56  ?<Jumptable for CheckActionUart>_0
      14  ??Subroutine4_0
       2  ??Subroutine5_0
       8  ??Subroutine6_0
      16  ??Subroutine7_0
      28  ?Subroutine0
       2  ?Subroutine1
       2  ?Subroutine2
      10  ?Subroutine3
     178  BuildADEpromdata
     164  BuildADInt
     168  BuildANAFilter
     154  BuildANASetup
     266  BuildEEPROMData
     624  BuildMData485
     278  BuildMDataANA
     296  BuildRData485
     208  BuildRS4Setup
     420  BuildStackStatus
     476  BuildStatusData
     390  BuildWHdata
      96  CalcDSRxChecksum
      74  CalcDSTxChecksum
     492  CheckActionUart
     154  GetADData
      46  GetANAFilter
      76  GetANASetup
     232  GetEEPROMData
      40  GetGotoBootloader
      80  GetRS4Setup
       4  GetResetEEPROM
      44  GoToSyncUART
     460  ReceivePacketUart
      28  TimoutUSART0
      12  TimoutUSART0On
      28  TimoutUSART1
      12  TimoutUSART1On
     106  Uart_BuildHeader
     410  Uart_BuildTail
     154  UsartCheckPackage
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_UCSR0B
       1  _A_UCSR1B
       1  _A_WDTCSR

 
     8 bytes in segment ABSOLUTE
 6 252 bytes in segment CODE
    56 bytes in segment SWITCH
 
 6 308 bytes of CODE memory
     0 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: 4
