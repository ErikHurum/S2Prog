###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       20/Nov/2023  14:43:41
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\UsartPro.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWAA7C.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\UsartPro.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj" -D
#        OS_LIBMODE_R -D OS_UART=-1 -D USE_16552_DRIVER_TASK=1 -D
#        USE_MODBUS_PROTOCOL=0 -D ANZBANA_V8=1 -D __ATMEGA_1281__ -lCN
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List" -y
#        --initializers_in_flash --no_tbaa --enable_external_bus
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -Ohs)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List\UsartPro.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj\UsartPro.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\UsartPro.c
      1          /****************************************************************************************
      2          / Com protocol for USART0
      3          /
      4          ***************************************************************************************/
      5          
      6          #ifdef __ATMEGA_1280__
      7          #include	"iom1280.h"
      8          #endif
      9          
     10          #ifdef __ATMEGA_1281__
     11          #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0xc9
   \   union <unnamed> volatile __io _A_UCSR1B
   \                     _A_UCSR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1
     12          #endif
     13          #include "stdio.h"
     14          #include "math.h"
     15          #include "string.h"
     16          #include "externals.h"
     17          #include "version.h"
     18          
     19          /*************************************************************************
     20          *   (This is a timer calback)
     21          *  Timout timer USART 0
     22          *
     23          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     24          void TimoutUSART0(void) {
   \                     TimoutUSART0:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     25          
     26              UCSR0B &= ~(__BIT_MASK( UDRIE0)) ;            // transmission end, disable int.
   \   00000000   910000C1           LDS     R16, 193
   \   00000004   7D0F               ANDI    R16, 0xDF
   \   00000006   930000C1           STS     193, R16
     27              ClrBit(PORTE, 0x04) ;                              // TXE0 off
   \   0000000A   94F8               cli
   \   0000000C   9872               CBI     0x0E, 0x02
   \   0000000E   9100....           LDS     R16, (OS_Global + 1)
   \   00000012   2300               TST     R16
   \   00000014   F409               BRNE    ??TimoutUSART0_0
   \   00000016   9478               sei
     28              OS_StopTimer(&TimerUSART0);                    // and stop timer
   \                     ??TimoutUSART0_0:
   \   00000018   ....               LDI     R16, LOW(TimerUSART0)
   \   0000001A   ....               LDI     R17, (TimerUSART0) >> 8
   \   0000001C   ........           CALL    OS_StopTimer
     29              GoToSyncUART(0) ;                                    // go to sync modus for recive
   \   00000020   E000               LDI     R16, 0
   \   00000022   ....               RJMP    GoToSyncUART
   \   00000024                      REQUIRE _A_UCSR0B
   \   00000024                      REQUIRE _A_PORTE
     30          }
     31          
     32          /*************************************************************************
     33          *   (This is a timer calback)
     34          *  Timer USART 0 on before TX
     35          *
     36          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     37          void TimoutUSART0On(void) {
   \                     TimoutUSART0On:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     38          
     39              UCSR0B |= __BIT_MASK( UDRIE0) ;                     // start sending by enableing interrupt
   \   00000000   910000C1           LDS     R16, 193
   \   00000004   6200               ORI     R16, 0x20
   \   00000006   930000C1           STS     193, R16
     40              OS_StopTimer(&TimerUSART0On);                    // and stop timer
   \   0000000A   ....               LDI     R16, LOW(TimerUSART0On)
   \   0000000C   ....               LDI     R17, (TimerUSART0On) >> 8
   \   0000000E   ........           JMP     OS_StopTimer
   \   00000012                      REQUIRE _A_UCSR0B
     41          }
     42          
     43          /*************************************************************************
     44          *   (This is a timer calback)
     45          *  Timout timer USART 1
     46          *
     47          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     48          void TimoutUSART1(void) {
   \                     TimoutUSART1:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     49          
     50              UCSR1B &= ~(__BIT_MASK( UDRIE1)) ;            // transmission end, disable int.
   \   00000000   910000C9           LDS     R16, 201
   \   00000004   7D0F               ANDI    R16, 0xDF
   \   00000006   930000C9           STS     201, R16
     51              ClrBit(PORTE, 0x08) ;                              // TXE1 off
   \   0000000A   94F8               cli
   \   0000000C   9873               CBI     0x0E, 0x03
   \   0000000E   9100....           LDS     R16, (OS_Global + 1)
   \   00000012   2300               TST     R16
   \   00000014   F409               BRNE    ??TimoutUSART1_0
   \   00000016   9478               sei
     52              OS_StopTimer(&TimerUSART1);                    // and stop timer
   \                     ??TimoutUSART1_0:
   \   00000018   ....               LDI     R16, LOW(TimerUSART1)
   \   0000001A   ....               LDI     R17, (TimerUSART1) >> 8
   \   0000001C   ........           CALL    OS_StopTimer
     53              GoToSyncUART(1) ;                                    // go to sync modus for recive
   \   00000020   E001               LDI     R16, 1
   \   00000022   ....               RJMP    GoToSyncUART
   \   00000024                      REQUIRE _A_UCSR1B
   \   00000024                      REQUIRE _A_PORTE
     54          }
     55          
     56          
     57          /*************************************************************************
     58          *   (This is a timer calback)
     59          *  Timer USART 1 on before TX
     60          *
     61          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     62          void TimoutUSART1On(void) {
   \                     TimoutUSART1On:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     63          
     64              UCSR1B |= __BIT_MASK( UDRIE1) ;                     // start sending by enableing interrupt
   \   00000000   910000C9           LDS     R16, 201
   \   00000004   6200               ORI     R16, 0x20
   \   00000006   930000C9           STS     201, R16
     65              OS_StopTimer(&TimerUSART1On);                    // and stop timer
   \   0000000A   ....               LDI     R16, LOW(TimerUSART1On)
   \   0000000C   ....               LDI     R17, (TimerUSART1On) >> 8
   \   0000000E   ........           JMP     OS_StopTimer
   \   00000012                      REQUIRE _A_UCSR1B
     66          }
     67          
     68          
     69          /*************************************************************************
     70          *   (This is a task)
     71          *  Usart0 handler
     72          *
     73          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     74          void Usart0Handler(void) {
   \                     Usart0Handler:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000008   E0AB               LDI     R26, 11
   \   0000000A   E0B0               LDI     R27, 0
   \   0000000C   C005               RJMP    ??Usart0Handler_0
     75              char stat;
     76          
     77              while (1) {
     78                  stat = OS_WaitEventTimed(1,500);
     79                  if (stat) {
   \                     ??Usart0Handler_1:
   \   0000000E   ....               RCALL   ?Subroutine6
     80                      OS_Use(&UARTSEND);
     81                      UsartCheckPackage(0) ;
     82                      OS_Unuse(&UARTSEND);
   \                     ??CrossCallReturnLabel_0:
   \   00000010   ....               LDI     R16, LOW(UARTSEND)
   \   00000012   ....               LDI     R17, (UARTSEND) >> 8
   \   00000014   ........           CALL    OS_Unuse
   \                     ??Usart0Handler_0:
   \   00000018   EF24               LDI     R18, 244
   \   0000001A   E031               LDI     R19, 1
   \   0000001C   E001               LDI     R16, 1
   \   0000001E   ........           CALL    OS_WaitEventTimed
   \   00000022   2300               TST     R16
   \   00000024   F3C9               BREQ    ??Usart0Handler_0
   \   00000026   ....               LDI     R16, LOW(UARTSEND)
   \   00000028   ....               LDI     R17, (UARTSEND) >> 8
   \   0000002A   ........           CALL    OS_Use
   \   0000002E   93B0....           STS     (UART + 25), R27
   \   00000032   93A0....           STS     (UART + 2), R26
   \   00000036   93B0....           STS     (UART + 3), R27
   \   0000003A   E087               LDI     R24, 7
   \   0000003C   E090               LDI     R25, 0
   \                     ??Usart0Handler_2:
   \   0000003E   019C               MOVW    R19:R18, R25:R24
   \   00000040   E000               LDI     R16, 0
   \   00000042   ....               RCALL   CheckActionUart
   \   00000044   91E0....           LDS     R30, (UART + 10)
   \   00000048   91F0....           LDS     R31, (UART + 11)
   \   0000004C   0FE8               ADD     R30, R24
   \   0000004E   1FF9               ADC     R31, R25
   \   00000050   8112               LDD     R17, Z+2
   \   00000052   81F3               LDD     R31, Z+3
   \   00000054   2FE1               MOV     R30, R17
   \   00000056   9634               ADIW    R31:R30, 4
   \   00000058   0F8E               ADD     R24, R30
   \   0000005A   1F9F               ADC     R25, R31
   \   0000005C   2300               TST     R16
   \   0000005E   F041               BREQ    ??Usart0Handler_3
   \   00000060   91E0....           LDS     R30, (UART + 22)
   \   00000064   91F0....           LDS     R31, (UART + 23)
   \   00000068   9734               SBIW    R31:R30, 4
   \   0000006A   178E               CP      R24, R30
   \   0000006C   079F               CPC     R25, R31
   \   0000006E   F338               BRCS    ??Usart0Handler_2
   \                     ??Usart0Handler_3:
   \   00000070   9100....           LDS     R16, (UART + 25)
   \   00000074   2300               TST     R16
   \   00000076   E000               LDI     R16, 0
   \   00000078   F251               BREQ    ??Usart0Handler_1
   \   0000007A   ....               RCALL   ?Subroutine7
     83                  }
     84              }
   \                     ??CrossCallReturnLabel_4:
   \   0000007C   CFC9               RJMP    ??CrossCallReturnLabel_0
     85          }
     86          
     87          /*************************************************************************
     88          *   (This is a task)
     89          *  Usart1 handler
     90          *
     91          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     92          void Usart1Handler(void) {
   \                     Usart1Handler:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000008   E0AB               LDI     R26, 11
   \   0000000A   E0B0               LDI     R27, 0
   \   0000000C   C005               RJMP    ??Usart1Handler_0
     93              char stat;
     94          
     95              while (1) {
     96                  stat = OS_WaitEventTimed(1,500);
     97                  if (stat) {
   \                     ??Usart1Handler_1:
   \   0000000E   ....               RCALL   ?Subroutine6
     98                      OS_Use(&UARTSEND);
     99                      UsartCheckPackage(1) ;
    100                      OS_Unuse(&UARTSEND);
   \                     ??CrossCallReturnLabel_1:
   \   00000010   ....               LDI     R16, LOW(UARTSEND)
   \   00000012   ....               LDI     R17, (UARTSEND) >> 8
   \   00000014   ........           CALL    OS_Unuse
   \                     ??Usart1Handler_0:
   \   00000018   EF24               LDI     R18, 244
   \   0000001A   E031               LDI     R19, 1
   \   0000001C   E001               LDI     R16, 1
   \   0000001E   ........           CALL    OS_WaitEventTimed
   \   00000022   2300               TST     R16
   \   00000024   F3C9               BREQ    ??Usart1Handler_0
   \   00000026   ....               LDI     R16, LOW(UARTSEND)
   \   00000028   ....               LDI     R17, (UARTSEND) >> 8
   \   0000002A   ........           CALL    OS_Use
   \   0000002E   93B0....           STS     (UART + 51), R27
   \   00000032   93A0....           STS     (UART + 28), R26
   \   00000036   93B0....           STS     (UART + 29), R27
   \   0000003A   E087               LDI     R24, 7
   \   0000003C   E090               LDI     R25, 0
   \                     ??Usart1Handler_2:
   \   0000003E   019C               MOVW    R19:R18, R25:R24
   \   00000040   E001               LDI     R16, 1
   \   00000042   ....               RCALL   CheckActionUart
   \   00000044   91E0....           LDS     R30, (UART + 36)
   \   00000048   91F0....           LDS     R31, (UART + 37)
   \   0000004C   0FE8               ADD     R30, R24
   \   0000004E   1FF9               ADC     R31, R25
   \   00000050   8112               LDD     R17, Z+2
   \   00000052   81F3               LDD     R31, Z+3
   \   00000054   2FE1               MOV     R30, R17
   \   00000056   9634               ADIW    R31:R30, 4
   \   00000058   0F8E               ADD     R24, R30
   \   0000005A   1F9F               ADC     R25, R31
   \   0000005C   2300               TST     R16
   \   0000005E   F041               BREQ    ??Usart1Handler_3
   \   00000060   91E0....           LDS     R30, (UART + 48)
   \   00000064   91F0....           LDS     R31, (UART + 49)
   \   00000068   9734               SBIW    R31:R30, 4
   \   0000006A   178E               CP      R24, R30
   \   0000006C   079F               CPC     R25, R31
   \   0000006E   F338               BRCS    ??Usart1Handler_2
   \                     ??Usart1Handler_3:
   \   00000070   9100....           LDS     R16, (UART + 51)
   \   00000074   2300               TST     R16
   \   00000076   E001               LDI     R16, 1
   \   00000078   F251               BREQ    ??Usart1Handler_1
   \   0000007A   ....               RCALL   ?Subroutine7
    101                  }
    102              }
   \                     ??CrossCallReturnLabel_5:
   \   0000007C   CFC9               RJMP    ??CrossCallReturnLabel_1
    103          }
    104          
    105          /*************************************************************************
    106          *
    107          *  Check the incoming packages
    108          *
    109          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    110          void UsartCheckPackage(char ch) {
   \                     UsartCheckPackage:
   \   00000000   924A               ST      -Y, R4
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000A                      REQUIRE __RSTACK_in_external_ram_new_way
   \   0000000A   2E40               MOV     R4, R16
    111          
    112              unsigned short pointer;
    113              char    retval ;
    114          
    115              UART[ch].RxSendReply = false ;                              // flag for answering set to fault
   \   0000000C   E10A               LDI     R16, 26
   \   0000000E   9E40               MUL     R4, R16
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   8F01               STD     Z+25, R16
    116              UART[ch].TxFirst = 11 ;                                     // Start pos for first TX command
   \   0000001E   E00B               LDI     R16, 11
   \   00000020   8302               STD     Z+2, R16
   \   00000022   E000               LDI     R16, 0
   \   00000024   8303               STD     Z+3, R16
    117              pointer = 7 ;
   \   00000026   E087               LDI     R24, 7
   \   00000028   E090               LDI     R25, 0
    118              do {
    119                  retval = CheckActionUart(ch, pointer);
   \                     ??UsartCheckPackage_0:
   \   0000002A   019C               MOVW    R19:R18, R25:R24
   \   0000002C   2D04               MOV     R16, R4
   \   0000002E   ....               RCALL   CheckActionUart
   \   00000030   2F30               MOV     R19, R16
    120                  pointer = pointer + UART[ch].pRxBuffer[pointer+2]
    121                            + (UART[ch].pRxBuffer[pointer+3]*256) + 4;      // Point to a command cmd hb/lb
   \   00000032   01FD               MOVW    R31:R30, R27:R26
   \   00000034   8502               LDD     R16, Z+10
   \   00000036   8513               LDD     R17, Z+11
   \   00000038   0F08               ADD     R16, R24
   \   0000003A   1F19               ADC     R17, R25
   \   0000003C   01F8               MOVW    R31:R30, R17:R16
   \   0000003E   8122               LDD     R18, Z+2
   \   00000040   81F3               LDD     R31, Z+3
   \   00000042   2FE2               MOV     R30, R18
   \   00000044   9634               ADIW    R31:R30, 4
   \   00000046   0F8E               ADD     R24, R30
   \   00000048   1F9F               ADC     R25, R31
    122              } while (retval && (pointer < (UART[ch].RxPacklen - 4 )));
   \   0000004A   2333               TST     R19
   \   0000004C   F041               BREQ    ??UsartCheckPackage_1
   \   0000004E   01FD               MOVW    R31:R30, R27:R26
   \   00000050   8906               LDD     R16, Z+22
   \   00000052   8917               LDD     R17, Z+23
   \   00000054   5004               SUBI    R16, 4
   \   00000056   4010               SBCI    R17, 0
   \   00000058   1780               CP      R24, R16
   \   0000005A   0791               CPC     R25, R17
   \   0000005C   F330               BRCS    ??UsartCheckPackage_0
    123              if (UART[ch].RxSendReply) {                                   //send answer?
   \                     ??UsartCheckPackage_1:
   \   0000005E   01FD               MOVW    R31:R30, R27:R26
   \   00000060   8D01               LDD     R16, Z+25
   \   00000062   2300               TST     R16
   \   00000064   2D04               MOV     R16, R4
   \   00000066   F011               BREQ    ??UsartCheckPackage_2
    124                  Uart_BuildTail(ch);                                       // yes, build tail (and header) and start sending
   \   00000068   ....               RCALL   ?Subroutine7
    125              } else {
   \                     ??CrossCallReturnLabel_6:
   \   0000006A   C001               RJMP    ??CrossCallReturnLabel_2
    126                  GoToSyncUART(ch) ;                                        // go to sync modus here if not reply
   \                     ??UsartCheckPackage_2:
   \   0000006C   ....               RCALL   ?Subroutine6
    127              }
    128          }
   \                     ??CrossCallReturnLabel_2:
   \   0000006E   9189               LD      R24, Y+
   \   00000070   9199               LD      R25, Y+
   \   00000072   91A9               LD      R26, Y+
   \   00000074   91B9               LD      R27, Y+
   \   00000076   9049               LD      R4, Y+
   \   00000078   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   ........           JMP     Uart_BuildTail

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   ........           JMP     GoToSyncUART
    129          
    130          
    131          /*************************************************************************
    132          *
    133          *  Check action on received data
    134          *
    135          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    136          char CheckActionUart(char ch, unsigned short pointer) {
   \                     CheckActionUart:
   \   00000000   929A               ST      -Y, R9
   \   00000002   928A               ST      -Y, R8
   \   00000004   927A               ST      -Y, R7
   \   00000006   926A               ST      -Y, R6
   \   00000008   925A               ST      -Y, R5
   \   0000000A   924A               ST      -Y, R4
   \   0000000C   93BA               ST      -Y, R27
   \   0000000E   93AA               ST      -Y, R26
   \   00000010   939A               ST      -Y, R25
   \   00000012   938A               ST      -Y, R24
   \   00000014                      REQUIRE ?Register_R4_is_cg_reg
   \   00000014                      REQUIRE ?Register_R5_is_cg_reg
   \   00000014                      REQUIRE ?Register_R6_is_cg_reg
   \   00000014                      REQUIRE ?Register_R7_is_cg_reg
   \   00000014                      REQUIRE ?Register_R8_is_cg_reg
   \   00000014                      REQUIRE ?Register_R9_is_cg_reg
   \   00000014                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000014   2E40               MOV     R4, R16
   \   00000016   01C9               MOVW    R25:R24, R19:R18
    137          
    138              unsigned short   command;
    139              char    retval = true;
   \   00000018   2455               CLR     R5
   \   0000001A   9453               INC     R5
    140          
    141              command = UART[ch].pRxBuffer[pointer] | (UART[ch].pRxBuffer[pointer+1] << 8);
   \   0000001C   E10A               LDI     R16, 26
   \   0000001E   9E40               MUL     R4, R16
   \   00000020   ....               LDI     R16, LOW(UART)
   \   00000022   2E80               MOV     R8, R16
   \   00000024   ....               LDI     R16, (UART) >> 8
   \   00000026   0C80               ADD     R8, R0
   \   00000028   1D01               ADC     R16, R1
   \   0000002A   2E90               MOV     R9, R16
   \   0000002C   2DE8               MOV     R30, R8
   \   0000002E   2FF0               MOV     R31, R16
   \   00000030   85A2               LDD     R26, Z+10
   \   00000032   85B3               LDD     R27, Z+11
   \   00000034   0FA8               ADD     R26, R24
   \   00000036   1FB9               ADC     R27, R25
   \   00000038   01FD               MOVW    R31:R30, R27:R26
   \   0000003A   8060               LD      R6, Z
   \   0000003C   8071               LDD     R7, Z+1
    142              switch (command) {                                  // check action
   \   0000003E   0183               MOVW    R17:R16, R7:R6
   \   00000040   ....               LDI     R30, LOW(`?<Jumptable for CheckActionUart>_0`)
   \   00000042   ....               LDI     R31, (`?<Jumptable for CheckActionUart>_0`) >> 16
   \   00000044   BFFB               OUT     0x3B, R31
   \   00000046   ....               LDI     R31, HIGH(`?<Jumptable for CheckActionUart>_0`)
   \   00000048   ........           JMP     ?SV_SWITCH_L06
    143              case CMD_REQ_STATUS :                           // Regusest status for target
    144                  BuildStatusData(ch) ;                         // make package
   \                     ??CheckActionUart_0:
   \   0000004C   2D04               MOV     R16, R4
   \   0000004E   ....               RCALL   BuildStatusData
    145                  break;
   \   00000050   C0C3               RJMP    ??CheckActionUart_1
    146          
    147              case CMD_GET_STACKSTATUS :                        // Request stck status
    148                  BuildStackStatus(ch, pointer+4) ;                     // receive package	
   \                     ??CheckActionUart_2:
   \   00000052   9604               ADIW    R25:R24, 4
   \   00000054   019C               MOVW    R19:R18, R25:R24
   \   00000056   2D04               MOV     R16, R4
   \   00000058   ....               RCALL   BuildStackStatus
    149                  break ;
   \   0000005A   C0BE               RJMP    ??CheckActionUart_1
    150          
    151              case CMD_EEPROM_RESET :                        // Reset EEPROM??
    152                  GetResetEEPROM(ch, pointer+4) ;                     // receive package	
   \                     ??CheckActionUart_3:
   \   0000005C   ........           CALL    EEPROMReset
    153                  break ;
   \   00000060   C0BB               RJMP    ??CheckActionUart_1
   \                     ??CheckActionUart_4:
   \   00000062   99F9               SBIC    0x1F, 0x01
   \   00000064   CFFE               RJMP    ??CheckActionUart_4
   \   00000066   EF0F               LDI     R16, 255
   \   00000068   BD01               OUT     0x21, R16
   \   0000006A   E00F               LDI     R16, 15
   \   0000006C   BD02               OUT     0x22, R16
   \   0000006E   EF0F               LDI     R16, 255
   \   00000070   BD00               OUT     0x20, R16
   \   00000072   9AFA               SBI     0x1F, 0x02
   \   00000074   9AF9               SBI     0x1F, 0x01
   \   00000076   E108               LDI     R16, 24
   \   00000078   C002               RJMP    ??CheckActionUart_5
   \                     ??CheckActionUart_6:
   \   0000007A   9300....           STS     _A_WDTCSR, R16
   \                     ??CheckActionUart_5:
   \   0000007E   99F9               SBIC    0x1F, 0x01
   \   00000080   CFFC               RJMP    ??CheckActionUart_6
   \   00000082   E008               LDI     R16, 8
   \   00000084   9300....           STS     _A_WDTCSR, R16
    154          
    155              case CMD_GOTO_BOOTLOADER :                        // Goto bootlaoder??
    156                  GetGotoBootloader(ch, pointer+4) ;                     // receive package	
    157                  break ;
   \   00000088   C0A7               RJMP    ??CheckActionUart_1
    158          
    159              case CMD_SND_EEPROM_DATA :                              // Receive EEPROM data
    160                  GetEEPROMData(ch, pointer+4) ;                     // receive package	
   \                     ??CheckActionUart_7:
   \   0000008A   9604               ADIW    R25:R24, 4
   \   0000008C   019C               MOVW    R19:R18, R25:R24
   \   0000008E   2D04               MOV     R16, R4
   \   00000090   ....               RCALL   GetEEPROMData
    161                  break ;
   \   00000092   C0A2               RJMP    ??CheckActionUart_1
    162          
    163              case CMD_REQ_EEPROM_DATA :                              // Request to send EEPROM data
    164                  BuildEEPROMData(ch, pointer+4) ;                     // receive package	
   \                     ??CheckActionUart_8:
   \   00000094   9604               ADIW    R25:R24, 4
   \   00000096   019C               MOVW    R19:R18, R25:R24
   \   00000098   2D04               MOV     R16, R4
   \   0000009A   ....               RCALL   BuildEEPROMData
    165                  break ;
   \   0000009C   C09D               RJMP    ??CheckActionUart_1
    166          
    167              case CMD_REQ_INT_DATA :                              // Request external data
    168                  BuildADInt(ch, pointer+4) ;                     // receive package	
   \                     ??CheckActionUart_9:
   \   0000009E   9604               ADIW    R25:R24, 4
   \   000000A0   019C               MOVW    R19:R18, R25:R24
   \   000000A2   2D04               MOV     R16, R4
   \   000000A4   ....               RCALL   BuildADInt
    169                  break ;
   \   000000A6   C098               RJMP    ??CheckActionUart_1
    170          
    171              case CMD_SND_RS4_SETUP :                              // Receive sertup of AN-RS485
    172                  if (UnitID == AN_ZB485) {
   \                     ??CheckActionUart_10:
   \   000000A8   9100....           LDS     R16, UnitID
   \   000000AC   2300               TST     R16
   \   000000AE   F009               BREQ    $+2+2
   \   000000B0   C093               RJMP    ??CheckActionUart_1
    173                      GetRS4Setup(ch, pointer+4) ;                     // receive package	
   \   000000B2   9604               ADIW    R25:R24, 4
   \   000000B4   019C               MOVW    R19:R18, R25:R24
   \   000000B6   2D04               MOV     R16, R4
   \   000000B8   ....               RCALL   GetRS4Setup
   \   000000BA   C08E               RJMP    ??CheckActionUart_1
    174                  }
    175                  break ;
    176          
    177              case CMD_REQ_RS4_SETUP :                              // Request for sertup of AN-RS485
    178                  if (UnitID == AN_ZB485) {
   \                     ??CheckActionUart_11:
   \   000000BC   9100....           LDS     R16, UnitID
   \   000000C0   2300               TST     R16
   \   000000C2   F009               BREQ    $+2+2
   \   000000C4   C089               RJMP    ??CheckActionUart_1
    179                      BuildRS4Setup(ch, pointer+4) ;                     // receive package	
   \   000000C6   9604               ADIW    R25:R24, 4
   \   000000C8   019C               MOVW    R19:R18, R25:R24
   \   000000CA   2D04               MOV     R16, R4
   \   000000CC   ....               RCALL   BuildRS4Setup
   \   000000CE   C084               RJMP    ??CheckActionUart_1
    180                  }
    181                  break ;
    182          
    183              case CMD_SND_RS4_ADBUF :                              // Request external AD data
    184                  if (UnitID == AN_ZB485) {
   \                     ??CheckActionUart_12:
   \   000000D0   9100....           LDS     R16, UnitID
   \   000000D4   2300               TST     R16
   \   000000D6   F009               BREQ    $+2+2
   \   000000D8   C07F               RJMP    ??CheckActionUart_1
    185                      GetADData(ch, pointer+4) ;                     // receive package	
   \   000000DA   9604               ADIW    R25:R24, 4
   \   000000DC   019C               MOVW    R19:R18, R25:R24
   \   000000DE   2D04               MOV     R16, R4
   \   000000E0   ....               RCALL   GetADData
   \   000000E2   C07A               RJMP    ??CheckActionUart_1
    186                  }
    187                  break;
    188          
    189              case CMD_REQ_RS4_DATA :                              // Request external AD eeprom data
    190                  if (UnitID == AN_ZB485) {
   \                     ??CheckActionUart_13:
   \   000000E4   9100....           LDS     R16, UnitID
   \   000000E8   2300               TST     R16
   \   000000EA   F009               BREQ    $+2+2
   \   000000EC   C075               RJMP    ??CheckActionUart_1
    191                      switch (UART[ch].pRxBuffer[pointer+4]) {
   \   000000EE   01FD               MOVW    R31:R30, R27:R26
   \   000000F0   8104               LDD     R16, Z+4
   \   000000F2   2300               TST     R16
   \   000000F4   F019               BREQ    ??CheckActionUart_14
   \   000000F6   950A               DEC     R16
   \   000000F8   F179               BREQ    ??CheckActionUart_15
   \   000000FA   C06E               RJMP    ??CheckActionUart_1
    192                      case 0:                                         // Measure data
    193                          BuildMData485(ch, pointer+5) ;              // receive package	
   \                     ??CheckActionUart_14:
   \   000000FC   013C               MOVW    R7:R6, R25:R24
   \   000000FE   E005               LDI     R16, 5
   \   00000100   0E60               ADD     R6, R16
   \   00000102   E000               LDI     R16, 0
   \   00000104   1E70               ADC     R7, R16
   \   00000106   0193               MOVW    R19:R18, R7:R6
   \   00000108   2D04               MOV     R16, R4
   \   0000010A   ....               RCALL   BuildMData485
    194                          if (TData.RS4.FromTargetBuffer[0][0] == true) {     // send eepromdata ch 0?
   \   0000010C   ....               LDI     R26, LOW((TData + 1428))
   \   0000010E   ....               LDI     R27, HIGH((TData + 1428))
   \   00000110   910C               LD      R16, X
   \   00000112   3001               CPI     R16, 1
   \   00000114   F429               BRNE    ??CheckActionUart_16
    195                            BuildADEpromdata(ch, 0);
   \   00000116   E010               LDI     R17, 0
   \   00000118   2D04               MOV     R16, R4
   \   0000011A   ....               RCALL   BuildADEpromdata
    196                            TData.RS4.FromTargetBuffer[0][0] = false ;  // Marked as sent
   \   0000011C   E000               LDI     R16, 0
   \   0000011E   930C               ST      X, R16
    197                          }
    198                          if (TData.RS4.FromTargetBuffer[1][0] == true) {     // send eepromdata ch 1?
   \                     ??CheckActionUart_16:
   \   00000120   01FD               MOVW    R31:R30, R27:R26
   \   00000122   A902               LDD     R16, Z+50
   \   00000124   3001               CPI     R16, 1
   \   00000126   F429               BRNE    ??CheckActionUart_17
    199                            BuildADEpromdata(ch, 1);                  // channel 1
   \   00000128   0182               MOVW    R17:R16, R5:R4
   \   0000012A   ....               RCALL   BuildADEpromdata
    200                            TData.RS4.FromTargetBuffer[1][0] = false ;  // Marked as sent
   \   0000012C   01FD               MOVW    R31:R30, R27:R26
   \   0000012E   E000               LDI     R16, 0
   \   00000130   AB02               STD     Z+50, R16
    201                          }
    202                          if ((TData.RS4.WHDataAvailable >> UART[ch].pRxBuffer[pointer+5]) & 0x01) {
   \                     ??CheckActionUart_17:
   \   00000132   9100....           LDS     R16, (TData + 1267)
   \   00000136   E010               LDI     R17, 0
   \   00000138   01F4               MOVW    R31:R30, R9:R8
   \   0000013A   8522               LDD     R18, Z+10
   \   0000013C   8533               LDD     R19, Z+11
   \   0000013E   0F28               ADD     R18, R24
   \   00000140   1F39               ADC     R19, R25
   \   00000142   01F9               MOVW    R31:R30, R19:R18
   \   00000144   8145               LDD     R20, Z+5
   \   00000146   ........           CALL    ?SS_SHR_L02
   \   0000014A   7001               ANDI    R16, 0x01
   \   0000014C   F409               BRNE    $+2+2
   \   0000014E   C044               RJMP    ??CheckActionUart_1
    203                              BuildWHdata(ch, pointer + 5);
   \   00000150   0193               MOVW    R19:R18, R7:R6
   \   00000152   2D04               MOV     R16, R4
   \   00000154   ....               RCALL   BuildWHdata
   \   00000156   C040               RJMP    ??CheckActionUart_1
    204                              //TData.RS4.WHDataAvailable &= ~(0x01 << UART[ch].pRxBuffer[pointer+5]);
    205                          }
    206                          break;
    207                      case 1:                                         // Raw and cal data
    208                          BuildRData485(ch, pointer+5) ;                     // receive package	
   \                     ??CheckActionUart_15:
   \   00000158   9605               ADIW    R25:R24, 5
   \   0000015A   019C               MOVW    R19:R18, R25:R24
   \   0000015C   2D04               MOV     R16, R4
   \   0000015E   ....               RCALL   BuildRData485
    209                          break;
   \   00000160   C03B               RJMP    ??CheckActionUart_1
    210                      }
    211                  }
    212                  break;
    213          
    214              case CMD_SND_ANA_SETUP :                              // Receive sertup of AN-RSANA
    215                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_18:
   \   00000162   9100....           LDS     R16, UnitID
   \   00000166   3001               CPI     R16, 1
   \   00000168   F5B9               BRNE    ??CheckActionUart_1
    216                      GetANASetup(ch, pointer+4) ;                     // receive package	
   \   0000016A   9604               ADIW    R25:R24, 4
   \   0000016C   019C               MOVW    R19:R18, R25:R24
   \   0000016E   2D04               MOV     R16, R4
   \   00000170   ........           CALL    GetANASetup
   \   00000174   C031               RJMP    ??CheckActionUart_1
    217                  }
    218                  break ;
    219          
    220              case CMD_REQ_ANA_SETUP :                              // Request for sertup of AN-RSANA
    221                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_19:
   \   00000176   9100....           LDS     R16, UnitID
   \   0000017A   3001               CPI     R16, 1
   \   0000017C   F569               BRNE    ??CheckActionUart_1
    222                      BuildANASetup(ch, pointer+4) ;                     // receive package	
   \   0000017E   9604               ADIW    R25:R24, 4
   \   00000180   019C               MOVW    R19:R18, R25:R24
   \   00000182   2D04               MOV     R16, R4
   \   00000184   ........           CALL    BuildANASetup
   \   00000188   C027               RJMP    ??CheckActionUart_1
    223                  }
    224                  break ;
    225          
    226              case CMD_SND_ANA_FILTER :                              // Receive filter of AN-RSANA
    227                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_20:
   \   0000018A   9100....           LDS     R16, UnitID
   \   0000018E   3001               CPI     R16, 1
   \   00000190   F519               BRNE    ??CheckActionUart_1
    228                      GetANAFilter(ch, pointer+4) ;                     // receive package	
   \   00000192   9614               ADIW    R27:R26, 4
   \   00000194   ....               LDI     R30, LOW((TData + 2))
   \   00000196   ....               LDI     R31, HIGH((TData + 2))
   \   00000198   E00C               LDI     R16, 12
   \                     ??CheckActionUart_21:
   \   0000019A   911D               LD      R17, X+
   \   0000019C   9311               ST      Z+, R17
   \   0000019E   950A               DEC     R16
   \   000001A0   F0D9               BREQ    ??CheckActionUart_1
   \   000001A2   CFFB               RJMP    ??CheckActionUart_21
    229                  }
    230                  break ;
    231          
    232              case CMD_REQ_ANA_FILTER :                              // Request filter of AN-RSANA
    233                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_22:
   \   000001A4   9100....           LDS     R16, UnitID
   \   000001A8   3001               CPI     R16, 1
   \   000001AA   F4B1               BRNE    ??CheckActionUart_1
    234                      BuildANAFilter(ch, pointer+4) ;                     // receive package	
   \   000001AC   9604               ADIW    R25:R24, 4
   \   000001AE   019C               MOVW    R19:R18, R25:R24
   \   000001B0   2D04               MOV     R16, R4
   \   000001B2   ........           CALL    BuildANAFilter
   \   000001B6   C010               RJMP    ??CheckActionUart_1
    235                  }
    236                  break ;
    237          
    238              case CMD_REQ_ANA_DATA :                              // Request ANA data(4-20ma)
    239                  if (UnitID == AN_ZBANA) {
   \                     ??CheckActionUart_23:
   \   000001B8   9100....           LDS     R16, UnitID
   \   000001BC   3001               CPI     R16, 1
   \   000001BE   F461               BRNE    ??CheckActionUart_1
    240                      BuildMDataANA(ch, pointer+4) ;                     // receive
   \   000001C0   9604               ADIW    R25:R24, 4
   \   000001C2   019C               MOVW    R19:R18, R25:R24
   \   000001C4   2D04               MOV     R16, R4
   \   000001C6   ........           CALL    BuildMDataANA
   \   000001CA   C006               RJMP    ??CheckActionUart_1
    241                  }
    242                  break ;
    243          
    244              default:
    245                  if (command < MAX_ECMD) {                   // handle end commands
   \                     ??CheckActionUart_24:
   \   000001CC   E604               LDI     R16, 100
   \   000001CE   1660               CP      R6, R16
   \   000001D0   E000               LDI     R16, 0
   \   000001D2   0670               CPC     R7, R16
   \   000001D4   F408               BRCC    ??CheckActionUart_1
    246                      retval = false ;
   \   000001D6   2455               CLR     R5
    247                  }
    248                  break;
    249          
    250              }
    251              return retval;
   \                     ??CheckActionUart_1:
   \   000001D8   2D05               MOV     R16, R5
   \   000001DA   9189               LD      R24, Y+
   \   000001DC   9199               LD      R25, Y+
   \   000001DE   91A9               LD      R26, Y+
   \   000001E0   91B9               LD      R27, Y+
   \   000001E2   9049               LD      R4, Y+
   \   000001E4   9059               LD      R5, Y+
   \   000001E6   9069               LD      R6, Y+
   \   000001E8   9079               LD      R7, Y+
   \   000001EA   9089               LD      R8, Y+
   \   000001EC   9099               LD      R9, Y+
   \   000001EE   9508               RET
   \   000001F0                      REQUIRE _A_EECR
   \   000001F0                      REQUIRE _A_EEAR
   \   000001F0                      REQUIRE _A_EEDR
   \   000001F0                      REQUIRE _A_WDTCSR
    252          }
    253          
    254          /*************************************************************************
    255          *
    256          * Build send packet header
    257          *
    258          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    259          void Uart_BuildHeader(char ch) {
   \                     Uart_BuildHeader:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
    260          
    261              UART[ch].RxFirst = 0;                                // Reset pointers
   \   00000004   E11A               LDI     R17, 26
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R26, LOW(UART)
   \   0000000A   ....               LDI     R27, (UART) >> 8
   \   0000000C   0DA0               ADD     R26, R0
   \   0000000E   1DB1               ADC     R27, R1
   \   00000010   01FD               MOVW    R31:R30, R27:R26
   \   00000012   E000               LDI     R16, 0
   \   00000014   8704               STD     Z+12, R16
   \   00000016   8705               STD     Z+13, R16
    262              UART[ch].RxLast  = 0;
   \   00000018   8706               STD     Z+14, R16
   \   0000001A   8707               STD     Z+15, R16
    263              UART[ch].TxLast  = 0;
   \   0000001C   8304               STD     Z+4, R16
   \   0000001E   8305               STD     Z+5, R16
    264          
    265              UART[ch].pTxBuffer[0] = ANPRO10_SYN ;                        /* Sync */
   \   00000020   91ED               LD      R30, X+
   \   00000022   91FC               LD      R31, X
   \   00000024   9711               SBIW    R27:R26, 1
   \   00000026   E106               LDI     R16, 22
   \   00000028   8300               ST      Z, R16
    266              UART[ch].pTxBuffer[1] = ANPRO10_SYN ;                        /* Sync */
   \   0000002A   91ED               LD      R30, X+
   \   0000002C   91FC               LD      R31, X
   \   0000002E   9711               SBIW    R27:R26, 1
   \   00000030   8301               STD     Z+1, R16
    267              UART[ch].pTxBuffer[2] = ANPRO10_SYN ;                        /* Sync */
   \   00000032   91ED               LD      R30, X+
   \   00000034   91FC               LD      R31, X
   \   00000036   9711               SBIW    R27:R26, 1
   \   00000038   8302               STD     Z+2, R16
    268              UART[ch].pTxBuffer[3] = ANPRO10_SOH ;                        /* Start of header */
   \   0000003A   91ED               LD      R30, X+
   \   0000003C   91FC               LD      R31, X
   \   0000003E   9619               ADIW    R27:R26, 9
   \   00000040   E001               LDI     R16, 1
   \   00000042   8303               STD     Z+3, R16
    269              UART[ch].pTxBuffer[4] = UART[ch].pRxBuffer[2] ;      /* RXID */
   \   00000044   91ED               LD      R30, X+
   \   00000046   91FC               LD      R31, X
   \   00000048   971B               SBIW    R27:R26, 11
   \   0000004A   8102               LDD     R16, Z+2
   \   0000004C   91ED               LD      R30, X+
   \   0000004E   91FC               LD      R31, X
   \   00000050   9619               ADIW    R27:R26, 9
   \   00000052   8304               STD     Z+4, R16
    270              UART[ch].pTxBuffer[5] = UART[ch].pRxBuffer[3] ;      /* Rx address */
   \   00000054   91ED               LD      R30, X+
   \   00000056   91FC               LD      R31, X
   \   00000058   971B               SBIW    R27:R26, 11
   \   0000005A   8103               LDD     R16, Z+3
   \   0000005C   91ED               LD      R30, X+
   \   0000005E   91FC               LD      R31, X
   \   00000060   9711               SBIW    R27:R26, 1
   \   00000062   8305               STD     Z+5, R16
    271              UART[ch].pTxBuffer[6] = 0x10 + UnitID ;              /* Unit ID */
   \   00000064   9100....           LDS     R16, UnitID
   \   00000068   5F00               SUBI    R16, 240
   \   0000006A   91ED               LD      R30, X+
   \   0000006C   91FC               LD      R31, X
   \   0000006E   9711               SBIW    R27:R26, 1
   \   00000070   8306               STD     Z+6, R16
    272              UART[ch].pTxBuffer[7] = MyAddress();                 /* Tx address */
   \   00000072   ........           CALL    MyAddress
   \   00000076   91ED               LD      R30, X+
   \   00000078   91FC               LD      R31, X
   \   0000007A   9711               SBIW    R27:R26, 1
   \   0000007C   8307               STD     Z+7, R16
    273              UART[ch].pTxBuffer[8] = 0 ;                          /* packlen HB, don't know yet */
   \   0000007E   91ED               LD      R30, X+
   \   00000080   91FC               LD      R31, X
   \   00000082   9711               SBIW    R27:R26, 1
   \   00000084   E000               LDI     R16, 0
   \   00000086   8700               STD     Z+8, R16
    274              UART[ch].pTxBuffer[9] = 0 ;                          /* packlen LB, don't know yet */
   \   00000088   91ED               LD      R30, X+
   \   0000008A   91FC               LD      R31, X
   \   0000008C   9711               SBIW    R27:R26, 1
   \   0000008E   8701               STD     Z+9, R16
    275              UART[ch].pTxBuffer[10] = 0 ;                         /* Header checksum, don't know yet */
   \   00000090   91ED               LD      R30, X+
   \   00000092   91FC               LD      R31, X
   \   00000094   8702               STD     Z+10, R16
    276          }
   \   00000096   91A9               LD      R26, Y+
   \   00000098   91B9               LD      R27, Y+
   \   0000009A   9508               RET
    277          
    278          /*************************************************************************
    279          *
    280          * Build  packet tail
    281          *
    282          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    283          void Uart_BuildTail(char ch) {
   \                     Uart_BuildTail:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
   \   00000006                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000006   2F80               MOV     R24, R16
    284          
    285              Uart_BuildHeader(ch);                                    // fist build the header
   \   00000008   ....               RCALL   Uart_BuildHeader
    286          
    287              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ECMD_NMDWOACK & 0xff ;  // End command lb
   \   0000000A   E10A               LDI     R16, 26
   \   0000000C   9F80               MUL     R24, R16
   \   0000000E   ....               LDI     R26, LOW(UART)
   \   00000010   ....               LDI     R27, (UART) >> 8
   \   00000012   0DA0               ADD     R26, R0
   \   00000014   1DB1               ADC     R27, R1
   \   00000016   910D               LD      R16, X+
   \   00000018   911C               LD      R17, X
   \   0000001A   9711               SBIW    R27:R26, 1
   \   0000001C   01FD               MOVW    R31:R30, R27:R26
   \   0000001E   8122               LDD     R18, Z+2
   \   00000020   8133               LDD     R19, Z+3
   \   00000022   0F02               ADD     R16, R18
   \   00000024   1F13               ADC     R17, R19
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   E000               LDI     R16, 0
   \   0000002A   8300               ST      Z, R16
   \   0000002C   01FD               MOVW    R31:R30, R27:R26
   \   0000002E   8102               LDD     R16, Z+2
   \   00000030   8113               LDD     R17, Z+3
   \   00000032   5F0F               SUBI    R16, 255
   \   00000034   4F1F               SBCI    R17, 255
   \   00000036   8302               STD     Z+2, R16
   \   00000038   8313               STD     Z+3, R17
    288              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ECMD_NMDWOACK >> 8 ;    // End command hb
   \   0000003A   8100               LD      R16, Z
   \   0000003C   8111               LDD     R17, Z+1
   \   0000003E   8122               LDD     R18, Z+2
   \   00000040   8133               LDD     R19, Z+3
   \   00000042   0F02               ADD     R16, R18
   \   00000044   1F13               ADC     R17, R19
   \   00000046   01F8               MOVW    R31:R30, R17:R16
   \   00000048   E000               LDI     R16, 0
   \   0000004A   8300               ST      Z, R16
   \   0000004C   01FD               MOVW    R31:R30, R27:R26
   \   0000004E   8102               LDD     R16, Z+2
   \   00000050   8113               LDD     R17, Z+3
   \   00000052   5F0F               SUBI    R16, 255
   \   00000054   4F1F               SBCI    R17, 255
   \   00000056   8302               STD     Z+2, R16
   \   00000058   8313               STD     Z+3, R17
    289              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0x00 ;                  // End data
   \   0000005A   8100               LD      R16, Z
   \   0000005C   8111               LDD     R17, Z+1
   \   0000005E   8122               LDD     R18, Z+2
   \   00000060   8133               LDD     R19, Z+3
   \   00000062   0F02               ADD     R16, R18
   \   00000064   1F13               ADC     R17, R19
   \   00000066   01F8               MOVW    R31:R30, R17:R16
   \   00000068   E000               LDI     R16, 0
   \   0000006A   8300               ST      Z, R16
   \   0000006C   01FD               MOVW    R31:R30, R27:R26
   \   0000006E   8102               LDD     R16, Z+2
   \   00000070   8113               LDD     R17, Z+3
   \   00000072   5F0F               SUBI    R16, 255
   \   00000074   4F1F               SBCI    R17, 255
   \   00000076   8302               STD     Z+2, R16
   \   00000078   8313               STD     Z+3, R17
    290          
    291              UART[ch].pTxBuffer[UART[ch].TxFirst++] = UART[ch].TxSeqCnt++ ;   // Sequence counter
   \   0000007A   8521               LDD     R18, Z+9
   \   0000007C   2F02               MOV     R16, R18
   \   0000007E   9503               INC     R16
   \   00000080   8701               STD     Z+9, R16
   \   00000082   8100               LD      R16, Z
   \   00000084   8111               LDD     R17, Z+1
   \   00000086   8142               LDD     R20, Z+2
   \   00000088   8153               LDD     R21, Z+3
   \   0000008A   0F04               ADD     R16, R20
   \   0000008C   1F15               ADC     R17, R21
   \   0000008E   01F8               MOVW    R31:R30, R17:R16
   \   00000090   8320               ST      Z, R18
   \   00000092   01FD               MOVW    R31:R30, R27:R26
   \   00000094   8102               LDD     R16, Z+2
   \   00000096   8113               LDD     R17, Z+3
   \   00000098   5F0F               SUBI    R16, 255
   \   0000009A   4F1F               SBCI    R17, 255
   \   0000009C   8302               STD     Z+2, R16
   \   0000009E   8313               STD     Z+3, R17
    292          
    293              UART[ch].pTxBuffer[8] = UART[ch].TxFirst -2;                    // correct length because stx's
   \   000000A0   5002               SUBI    R16, 2
   \   000000A2   91ED               LD      R30, X+
   \   000000A4   91FC               LD      R31, X
   \   000000A6   9711               SBIW    R27:R26, 1
   \   000000A8   8700               STD     Z+8, R16
    294              UART[ch].pTxBuffer[9] = (UART[ch].TxFirst-2) >> 8 ;             // packet len high
   \   000000AA   01FD               MOVW    R31:R30, R27:R26
   \   000000AC   8102               LDD     R16, Z+2
   \   000000AE   8113               LDD     R17, Z+3
   \   000000B0   5002               SUBI    R16, 2
   \   000000B2   4010               SBCI    R17, 0
   \   000000B4   91ED               LD      R30, X+
   \   000000B6   91FC               LD      R31, X
   \   000000B8   9711               SBIW    R27:R26, 1
   \   000000BA   8711               STD     Z+9, R17
    295          
    296              UART[ch].pTxBuffer[10] = CalcDSTxChecksum(ch, 10) ;         // Get header checksum
   \   000000BC   E040               LDI     R20, 0
   \   000000BE   900D               LD      R0, X+
   \   000000C0   901C               LD      R1, X
   \   000000C2   9711               SBIW    R27:R26, 1
   \   000000C4   0180               MOVW    R17:R16, R1:R0
   \   000000C6   5F0C               SUBI    R16, 252
   \   000000C8   4F1F               SBCI    R17, 255
   \   000000CA   E026               LDI     R18, 6
   \   000000CC   ....               LDI     R19, (crc) >> 16
   \                     ??Uart_BuildTail_0:
   \   000000CE   01F8               MOVW    R31:R30, R17:R16
   \   000000D0   9161               LD      R22, Z+
   \   000000D2   018F               MOVW    R17:R16, R31:R30
   \   000000D4   2746               EOR     R20, R22
   \   000000D6   2FE4               MOV     R30, R20
   \   000000D8   E0F0               LDI     R31, 0
   \   000000DA   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000DC   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000DE   BF3B               OUT     0x3B, R19
   \   000000E0   9146               ELPM    R20, Z
   \   000000E2   952A               DEC     R18
   \   000000E4   F7A1               BRNE    ??Uart_BuildTail_0
   \   000000E6   01F0               MOVW    R31:R30, R1:R0
   \   000000E8   8742               STD     Z+10, R20
    297          
    298              UART[ch].pTxBuffer[UART[ch].TxFirst] = CalcDSTxChecksum(ch, UART[ch].TxFirst) ; // Get checksum
   \   000000EA   01FD               MOVW    R31:R30, R27:R26
   \   000000EC   8142               LDD     R20, Z+2
   \   000000EE   8153               LDD     R21, Z+3
   \   000000F0   2400               CLR     R0
   \   000000F2   8160               LD      R22, Z
   \   000000F4   8171               LDD     R23, Z+1
   \   000000F6   3045               CPI     R20, 5
   \   000000F8   0550               CPC     R21, R0
   \   000000FA   F088               BRCS    ??Uart_BuildTail_1
   \   000000FC   018B               MOVW    R17:R16, R23:R22
   \   000000FE   5F0C               SUBI    R16, 252
   \   00000100   4F1F               SBCI    R17, 255
   \   00000102   5044               SUBI    R20, 4
   \   00000104   4050               SBCI    R21, 0
   \                     ??Uart_BuildTail_2:
   \   00000106   01F8               MOVW    R31:R30, R17:R16
   \   00000108   9121               LD      R18, Z+
   \   0000010A   018F               MOVW    R17:R16, R31:R30
   \   0000010C   2602               EOR     R0, R18
   \   0000010E   2DE0               MOV     R30, R0
   \   00000110   E0F0               LDI     R31, 0
   \   00000112   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000114   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000116   9006               ELPM    R0, Z
   \   00000118   5041               SUBI    R20, 1
   \   0000011A   4050               SBCI    R21, 0
   \   0000011C   F7A1               BRNE    ??Uart_BuildTail_2
   \                     ??Uart_BuildTail_1:
   \   0000011E   01FD               MOVW    R31:R30, R27:R26
   \   00000120   8102               LDD     R16, Z+2
   \   00000122   8113               LDD     R17, Z+3
   \   00000124   0F60               ADD     R22, R16
   \   00000126   1F71               ADC     R23, R17
   \   00000128   01FB               MOVW    R31:R30, R23:R22
   \   0000012A   8200               ST      Z, R0
    299              UART[ch].TxFirst++ ;                                        // OBS!! must be inc here due to ANSI standard !!!!
   \   0000012C   01FD               MOVW    R31:R30, R27:R26
   \   0000012E   8102               LDD     R16, Z+2
   \   00000130   8113               LDD     R17, Z+3
   \   00000132   5F0F               SUBI    R16, 255
   \   00000134   4F1F               SBCI    R17, 255
   \   00000136   8302               STD     Z+2, R16
   \   00000138   8313               STD     Z+3, R17
    300          
    301              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANPRO10_EOT ;            // End of transmission
   \   0000013A   8100               LD      R16, Z
   \   0000013C   8111               LDD     R17, Z+1
   \   0000013E   8122               LDD     R18, Z+2
   \   00000140   8133               LDD     R19, Z+3
   \   00000142   0F02               ADD     R16, R18
   \   00000144   1F13               ADC     R17, R19
   \   00000146   01F8               MOVW    R31:R30, R17:R16
   \   00000148   E004               LDI     R16, 4
   \   0000014A   8300               ST      Z, R16
   \   0000014C   01FD               MOVW    R31:R30, R27:R26
   \   0000014E   8102               LDD     R16, Z+2
   \   00000150   8113               LDD     R17, Z+3
   \   00000152   5F0F               SUBI    R16, 255
   \   00000154   4F1F               SBCI    R17, 255
   \   00000156   8302               STD     Z+2, R16
   \   00000158   8313               STD     Z+3, R17
    302              UART[ch].TxCount = UART[ch].TxFirst;                      //bytes to send
   \   0000015A   8306               STD     Z+6, R16
   \   0000015C   8317               STD     Z+7, R17
    303              UART[ch].TxLast = 0;                                     // reset cunter
   \   0000015E   E000               LDI     R16, 0
   \   00000160   8304               STD     Z+4, R16
   \   00000162   8305               STD     Z+5, R16
    304              if (ch == 0) {                                           // Turn on TXE for channel
   \   00000164   2388               TST     R24
   \   00000166   F471               BRNE    ??Uart_BuildTail_3
    305                  OS_RetriggerTimer(&TimerUSART0);                     // and start timeout TX timer
   \   00000168   ....               LDI     R16, LOW(TimerUSART0)
   \   0000016A   ....               LDI     R17, (TimerUSART0) >> 8
   \   0000016C   ........           CALL    OS_RetriggerTimer
    306                  SetBit(PORTE, 0x04) ;                                // TXE0 on
   \   00000170   94F8               cli
   \   00000172   9A72               SBI     0x0E, 0x02
   \   00000174   9100....           LDS     R16, (OS_Global + 1)
   \   00000178   2300               TST     R16
   \   0000017A   F409               BRNE    ??Uart_BuildTail_4
   \   0000017C   9478               sei
    307                  OS_RetriggerTimer(&TimerUSART0On);                   // and start timer for on before TX
   \                     ??Uart_BuildTail_4:
   \   0000017E   ....               LDI     R16, LOW(TimerUSART0On)
   \   00000180   ....               LDI     R17, (TimerUSART0On) >> 8
   \   00000182   C00F               RJMP    ??Uart_BuildTail_5
    308              } else if (ch ==1) {
   \                     ??Uart_BuildTail_3:
   \   00000184   3081               CPI     R24, 1
   \   00000186   F479               BRNE    ??Uart_BuildTail_6
    309                  OS_RetriggerTimer(&TimerUSART1);                     // and start timeout TX timer
   \   00000188   ....               LDI     R16, LOW(TimerUSART1)
   \   0000018A   ....               LDI     R17, (TimerUSART1) >> 8
   \   0000018C   ........           CALL    OS_RetriggerTimer
    310                  SetBit(PORTE, 0x08) ;                                // TXE1 on
   \   00000190   94F8               cli
   \   00000192   9A73               SBI     0x0E, 0x03
   \   00000194   9100....           LDS     R16, (OS_Global + 1)
   \   00000198   2300               TST     R16
   \   0000019A   F409               BRNE    ??Uart_BuildTail_7
   \   0000019C   9478               sei
    311                  OS_RetriggerTimer(&TimerUSART1On);                   // and start timer for on before TX
   \                     ??Uart_BuildTail_7:
   \   0000019E   ....               LDI     R16, LOW(TimerUSART1On)
   \   000001A0   ....               LDI     R17, (TimerUSART1On) >> 8
   \                     ??Uart_BuildTail_5:
   \   000001A2   ........           CALL    OS_RetriggerTimer
    312              }
    313          }
   \                     ??Uart_BuildTail_6:
   \   000001A6   9189               LD      R24, Y+
   \   000001A8   91A9               LD      R26, Y+
   \   000001AA   91B9               LD      R27, Y+
   \   000001AC   9508               RET
   \   000001AE                      REQUIRE _A_PORTE
    314          
    315          /*************************************************************************
    316          *
    317          * Build datablock for card status
    318          *
    319          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine5_0:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9049               LD      R4, Y+
   \   0000000A   9059               LD      R5, Y+
   \   0000000C   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    320          void BuildStatusData(char ch){
   \                     BuildStatusData:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C                      REQUIRE __RSTACK_in_external_ram_new_way
    321          
    322              short ntna ;
    323              UART[ch].RxSendReply = true ;                               // flag for answering
   \   0000000C   E11A               LDI     R17, 26
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E011               LDI     R17, 1
   \   0000001C   8F11               STD     Z+25, R17
    324          
    325              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STATUS & 0xff;
   \   0000001E   91ED               LD      R30, X+
   \   00000020   91FD               LD      R31, X+
   \   00000022   912D               LD      R18, X+
   \   00000024   913C               LD      R19, X
   \   00000026   9713               SBIW    R27:R26, 3
   \   00000028   0FE2               ADD     R30, R18
   \   0000002A   1FF3               ADC     R31, R19
   \   0000002C   EE19               LDI     R17, 233
   \   0000002E   8310               ST      Z, R17
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8122               LDD     R18, Z+2
   \   00000034   8133               LDD     R19, Z+3
   \   00000036   5F2F               SUBI    R18, 255
   \   00000038   4F3F               SBCI    R19, 255
   \   0000003A   8322               STD     Z+2, R18
   \   0000003C   8333               STD     Z+3, R19
    326              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STATUS >> 8;
   \   0000003E   91ED               LD      R30, X+
   \   00000040   91FD               LD      R31, X+
   \   00000042   912D               LD      R18, X+
   \   00000044   9713               SBIW    R27:R26, 3
   \   00000046   0FE2               ADD     R30, R18
   \   00000048   1FF3               ADC     R31, R19
   \   0000004A   E013               LDI     R17, 3
   \   0000004C   8310               ST      Z, R17
   \   0000004E   01FD               MOVW    R31:R30, R27:R26
   \   00000050   8122               LDD     R18, Z+2
   \   00000052   8133               LDD     R19, Z+3
   \   00000054   5F2F               SUBI    R18, 255
   \   00000056   4F3F               SBCI    R19, 255
   \   00000058   8322               STD     Z+2, R18
   \   0000005A   8333               STD     Z+3, R19
    327              ntna = UART[ch].TxFirst ;                                    /* remember index */
   \   0000005C   0129               MOVW    R5:R4, R19:R18
    328              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000005E   5F2E               SUBI    R18, 254
   \   00000060   4F3F               SBCI    R19, 255
   \   00000062   8322               STD     Z+2, R18
   \   00000064   8333               STD     Z+3, R19
    329              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ch ;               // channel
   \   00000066   8120               LD      R18, Z
   \   00000068   8131               LDD     R19, Z+1
   \   0000006A   8142               LDD     R20, Z+2
   \   0000006C   8153               LDD     R21, Z+3
   \   0000006E   0F24               ADD     R18, R20
   \   00000070   1F35               ADC     R19, R21
   \   00000072   01F9               MOVW    R31:R30, R19:R18
   \   00000074   8300               ST      Z, R16
   \   00000076   01FD               MOVW    R31:R30, R27:R26
   \   00000078   8102               LDD     R16, Z+2
   \   0000007A   8113               LDD     R17, Z+3
   \   0000007C   5F0F               SUBI    R16, 255
   \   0000007E   4F1F               SBCI    R17, 255
   \   00000080   8302               STD     Z+2, R16
   \   00000082   8313               STD     Z+3, R17
    330              UART[ch].pTxBuffer[UART[ch].TxFirst++] = DEVICE_IO + UnitID ;   // Product ID
   \   00000084   9120....           LDS     R18, UnitID
   \   00000088   5F20               SUBI    R18, 240
   \   0000008A   8100               LD      R16, Z
   \   0000008C   8111               LDD     R17, Z+1
   \   0000008E   8142               LDD     R20, Z+2
   \   00000090   8153               LDD     R21, Z+3
   \   00000092   0F04               ADD     R16, R20
   \   00000094   1F15               ADC     R17, R21
   \   00000096   01F8               MOVW    R31:R30, R17:R16
   \   00000098   8320               ST      Z, R18
   \   0000009A   01FD               MOVW    R31:R30, R27:R26
   \   0000009C   8102               LDD     R16, Z+2
   \   0000009E   8113               LDD     R17, Z+3
   \   000000A0   5F0F               SUBI    R16, 255
   \   000000A2   4F1F               SBCI    R17, 255
   \   000000A4   8302               STD     Z+2, R16
   \   000000A6   8313               STD     Z+3, R17
    331              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MyAddress();           // unit adddress
   \   000000A8   01C8               MOVW    R25:R24, R17:R16
   \   000000AA   5F0F               SUBI    R16, 255
   \   000000AC   4F1F               SBCI    R17, 255
   \   000000AE   8302               STD     Z+2, R16
   \   000000B0   8313               STD     Z+3, R17
   \   000000B2   ........           CALL    MyAddress
   \   000000B6   91ED               LD      R30, X+
   \   000000B8   91FC               LD      R31, X
   \   000000BA   9711               SBIW    R27:R26, 1
   \   000000BC   0FE8               ADD     R30, R24
   \   000000BE   1FF9               ADC     R31, R25
   \   000000C0   8300               ST      Z, R16
    332              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROG_VERSION ;       // software version */
   \   000000C2   910D               LD      R16, X+
   \   000000C4   911C               LD      R17, X
   \   000000C6   9711               SBIW    R27:R26, 1
   \   000000C8   01FD               MOVW    R31:R30, R27:R26
   \   000000CA   8122               LDD     R18, Z+2
   \   000000CC   8133               LDD     R19, Z+3
   \   000000CE   0F02               ADD     R16, R18
   \   000000D0   1F13               ADC     R17, R19
   \   000000D2   01F8               MOVW    R31:R30, R17:R16
   \   000000D4   E20B               LDI     R16, 43
   \   000000D6   8300               ST      Z, R16
   \   000000D8   01FD               MOVW    R31:R30, R27:R26
   \   000000DA   8102               LDD     R16, Z+2
   \   000000DC   8113               LDD     R17, Z+3
   \   000000DE   5F0F               SUBI    R16, 255
   \   000000E0   4F1F               SBCI    R17, 255
   \   000000E2   8302               STD     Z+2, R16
   \   000000E4   8313               STD     Z+3, R17
    333              UART[ch].pTxBuffer[UART[ch].TxFirst++] = COMP_VERSION;        // cpmpability version
   \   000000E6   8100               LD      R16, Z
   \   000000E8   8111               LDD     R17, Z+1
   \   000000EA   8122               LDD     R18, Z+2
   \   000000EC   8133               LDD     R19, Z+3
   \   000000EE   0F02               ADD     R16, R18
   \   000000F0   1F13               ADC     R17, R19
   \   000000F2   01F8               MOVW    R31:R30, R17:R16
   \   000000F4   E001               LDI     R16, 1
   \   000000F6   8300               ST      Z, R16
   \   000000F8   01FD               MOVW    R31:R30, R27:R26
   \   000000FA   8102               LDD     R16, Z+2
   \   000000FC   8113               LDD     R17, Z+3
   \   000000FE   5F0F               SUBI    R16, 255
   \   00000100   4F1F               SBCI    R17, 255
   \   00000102   8302               STD     Z+2, R16
   \   00000104   8313               STD     Z+3, R17
    334              UART[ch].pTxBuffer[UART[ch].TxFirst++] = STORE_VERSION;        // cpmpability version
   \   00000106   8100               LD      R16, Z
   \   00000108   8111               LDD     R17, Z+1
   \   0000010A   8122               LDD     R18, Z+2
   \   0000010C   8133               LDD     R19, Z+3
   \   0000010E   0F02               ADD     R16, R18
   \   00000110   1F13               ADC     R17, R19
   \   00000112   01F8               MOVW    R31:R30, R17:R16
   \   00000114   E002               LDI     R16, 2
   \   00000116   8300               ST      Z, R16
   \   00000118   01FD               MOVW    R31:R30, R27:R26
   \   0000011A   8102               LDD     R16, Z+2
   \   0000011C   8113               LDD     R17, Z+3
   \   0000011E   5F0F               SUBI    R16, 255
   \   00000120   4F1F               SBCI    R17, 255
   \   00000122   8302               STD     Z+2, R16
   \   00000124   8313               STD     Z+3, R17
    335              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (RXSIZE_UART & 0xff);         // rx buffer size
   \   00000126   8100               LD      R16, Z
   \   00000128   8111               LDD     R17, Z+1
   \   0000012A   8122               LDD     R18, Z+2
   \   0000012C   8133               LDD     R19, Z+3
   \   0000012E   0F02               ADD     R16, R18
   \   00000130   1F13               ADC     R17, R19
   \   00000132   01F8               MOVW    R31:R30, R17:R16
   \   00000134   E906               LDI     R16, 150
   \   00000136   8300               ST      Z, R16
   \   00000138   01FD               MOVW    R31:R30, R27:R26
   \   0000013A   8102               LDD     R16, Z+2
   \   0000013C   8113               LDD     R17, Z+3
   \   0000013E   5F0F               SUBI    R16, 255
   \   00000140   4F1F               SBCI    R17, 255
   \   00000142   8302               STD     Z+2, R16
   \   00000144   8313               STD     Z+3, R17
    336              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (( RXSIZE_UART >> 8) & 0xff); // rx buffer size
   \   00000146   8100               LD      R16, Z
   \   00000148   8111               LDD     R17, Z+1
   \   0000014A   8122               LDD     R18, Z+2
   \   0000014C   8133               LDD     R19, Z+3
   \   0000014E   0F02               ADD     R16, R18
   \   00000150   1F13               ADC     R17, R19
   \   00000152   01F8               MOVW    R31:R30, R17:R16
   \   00000154   E000               LDI     R16, 0
   \   00000156   8300               ST      Z, R16
   \   00000158   01FD               MOVW    R31:R30, R27:R26
   \   0000015A   8102               LDD     R16, Z+2
   \   0000015C   8113               LDD     R17, Z+3
   \   0000015E   5F0F               SUBI    R16, 255
   \   00000160   4F1F               SBCI    R17, 255
   \   00000162   8302               STD     Z+2, R16
   \   00000164   8313               STD     Z+3, R17
    337              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TXSIZE_UART & 0xff);         // tx buffer size
   \   00000166   8100               LD      R16, Z
   \   00000168   8111               LDD     R17, Z+1
   \   0000016A   8122               LDD     R18, Z+2
   \   0000016C   8133               LDD     R19, Z+3
   \   0000016E   0F02               ADD     R16, R18
   \   00000170   1F13               ADC     R17, R19
   \   00000172   01F8               MOVW    R31:R30, R17:R16
   \   00000174   E103               LDI     R16, 19
   \   00000176   8300               ST      Z, R16
   \   00000178   01FD               MOVW    R31:R30, R27:R26
   \   0000017A   8102               LDD     R16, Z+2
   \   0000017C   8113               LDD     R17, Z+3
   \   0000017E   5F0F               SUBI    R16, 255
   \   00000180   4F1F               SBCI    R17, 255
   \   00000182   8302               STD     Z+2, R16
   \   00000184   8313               STD     Z+3, R17
    338              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);  // tx buffer size
   \   00000186   8100               LD      R16, Z
   \   00000188   8111               LDD     R17, Z+1
   \   0000018A   8122               LDD     R18, Z+2
   \   0000018C   8133               LDD     R19, Z+3
   \   0000018E   0F02               ADD     R16, R18
   \   00000190   1F13               ADC     R17, R19
   \   00000192   01F8               MOVW    R31:R30, R17:R16
   \   00000194   E001               LDI     R16, 1
   \   00000196   8300               ST      Z, R16
   \   00000198   01FD               MOVW    R31:R30, R27:R26
   \   0000019A   8102               LDD     R16, Z+2
   \   0000019C   8113               LDD     R17, Z+3
   \   0000019E   5F0F               SUBI    R16, 255
   \   000001A0   4F1F               SBCI    R17, 255
   \   000001A2   8302               STD     Z+2, R16
   \   000001A4   8313               STD     Z+3, R17
    339              UART[ch].pTxBuffer[UART[ch].TxFirst++] = RestartStatus ;                  // restart flag
   \   000001A6   9120....           LDS     R18, RestartStatus
   \   000001AA   8100               LD      R16, Z
   \   000001AC   8111               LDD     R17, Z+1
   \   000001AE   8142               LDD     R20, Z+2
   \   000001B0   8153               LDD     R21, Z+3
   \   000001B2   0F04               ADD     R16, R20
   \   000001B4   1F15               ADC     R17, R21
   \   000001B6   01F8               MOVW    R31:R30, R17:R16
   \   000001B8   8320               ST      Z, R18
   \   000001BA   01FD               MOVW    R31:R30, R27:R26
   \   000001BC   8102               LDD     R16, Z+2
   \   000001BE   8113               LDD     R17, Z+3
   \   000001C0   5F0F               SUBI    R16, 255
   \   000001C2   4F1F               SBCI    R17, 255
   \   000001C4   8302               STD     Z+2, R16
   \   000001C6   8313               STD     Z+3, R17
    340              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROGTYPE_APP ;                // Application program
   \   000001C8   8100               LD      R16, Z
   \   000001CA   8111               LDD     R17, Z+1
   \   000001CC   8122               LDD     R18, Z+2
   \   000001CE   8133               LDD     R19, Z+3
   \   000001D0   0F02               ADD     R16, R18
   \   000001D2   1F13               ADC     R17, R19
   \   000001D4   01F8               MOVW    R31:R30, R17:R16
   \   000001D6   E001               LDI     R16, 1
   \   000001D8   8300               ST      Z, R16
   \   000001DA   01FD               MOVW    R31:R30, R27:R26
   \   000001DC   8102               LDD     R16, Z+2
   \   000001DE   8113               LDD     R17, Z+3
   \   000001E0   5F0F               SUBI    R16, 255
   \   000001E2   4F1F               SBCI    R17, 255
   \   000001E4   8302               STD     Z+2, R16
   \   000001E6   8313               STD     Z+3, R17
    341          
    342              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   000001E8   1904               SUB     R16, R4
   \   000001EA   5002               SUBI    R16, 2
   \   000001EC   91ED               LD      R30, X+
   \   000001EE   91FC               LD      R31, X
   \   000001F0   9711               SBIW    R27:R26, 1
   \   000001F2   0DE4               ADD     R30, R4
   \   000001F4   1DF5               ADC     R31, R5
   \   000001F6   8300               ST      Z, R16
    343              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   000001F8   01FD               MOVW    R31:R30, R27:R26
   \   000001FA   8182               LDD     R24, Z+2
   \   000001FC   8193               LDD     R25, Z+3
   \   000001FE   1984               SUB     R24, R4
   \   00000200   0995               SBC     R25, R5
   \   00000202   9702               SBIW    R25:R24, 2
   \   00000204   91ED               LD      R30, X+
   \   00000206   91FC               LD      R31, X
   \   00000208   0DE4               ADD     R30, R4
   \   0000020A   1DF5               ADC     R31, R5
   \   0000020C   8391               STD     Z+1, R25
    344          
    345              RestartStatus = 0 ;                                                       // set reset stat to 0 = read
   \   0000020E   E000               LDI     R16, 0
   \   00000210   9300....           STS     RestartStatus, R16
    346          }
   \   00000214   ....               RJMP    ??Subroutine5_0
    347          
    348          /*************************************************************************
    349          *
    350          * Build EEPROM data package
    351          *
    352          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    353          void BuildEEPROMData(char ch, short pointer) {
   \                     BuildEEPROMData:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C                      REQUIRE __RSTACK_in_external_ram_new_way
    354          
    355              short ntna ;
    356              char channel;
    357              UART[ch].RxSendReply = true ;                               // flag for answering
   \   0000000C   E11A               LDI     R17, 26
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E001               LDI     R16, 1
   \   0000001C   8F01               STD     Z+25, R16
    358          
    359              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_EEPROM_DATA & 0xff;
   \   0000001E   91ED               LD      R30, X+
   \   00000020   91FD               LD      R31, X+
   \   00000022   910D               LD      R16, X+
   \   00000024   911C               LD      R17, X
   \   00000026   9713               SBIW    R27:R26, 3
   \   00000028   0FE0               ADD     R30, R16
   \   0000002A   1FF1               ADC     R31, R17
   \   0000002C   E309               LDI     R16, 57
   \   0000002E   8300               ST      Z, R16
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8102               LDD     R16, Z+2
   \   00000034   8113               LDD     R17, Z+3
   \   00000036   5F0F               SUBI    R16, 255
   \   00000038   4F1F               SBCI    R17, 255
   \   0000003A   8302               STD     Z+2, R16
   \   0000003C   8313               STD     Z+3, R17
    360              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_EEPROM_DATA >> 8;
   \   0000003E   91ED               LD      R30, X+
   \   00000040   91FD               LD      R31, X+
   \   00000042   910D               LD      R16, X+
   \   00000044   9713               SBIW    R27:R26, 3
   \   00000046   0FE0               ADD     R30, R16
   \   00000048   1FF1               ADC     R31, R17
   \   0000004A   E004               LDI     R16, 4
   \   0000004C   8300               ST      Z, R16
   \   0000004E   01FD               MOVW    R31:R30, R27:R26
   \   00000050   8102               LDD     R16, Z+2
   \   00000052   8113               LDD     R17, Z+3
   \   00000054   5F0F               SUBI    R16, 255
   \   00000056   4F1F               SBCI    R17, 255
   \   00000058   8302               STD     Z+2, R16
   \   0000005A   8313               STD     Z+3, R17
    361              ntna = UART[ch].TxFirst ;                                    /* remember index */
   \   0000005C   0128               MOVW    R5:R4, R17:R16
    362              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000005E   5F0E               SUBI    R16, 254
   \   00000060   4F1F               SBCI    R17, 255
   \   00000062   8302               STD     Z+2, R16
   \   00000064   8313               STD     Z+3, R17
    363          
    364              channel = UART[ch].pRxBuffer[pointer];
   \   00000066   8502               LDD     R16, Z+10
   \   00000068   8513               LDD     R17, Z+11
   \   0000006A   0F02               ADD     R16, R18
   \   0000006C   1F13               ADC     R17, R19
   \   0000006E   01F8               MOVW    R31:R30, R17:R16
   \   00000070   8120               LD      R18, Z
    365              UART[ch].pTxBuffer[UART[ch].TxFirst++] = channel; //channel
   \   00000072   910D               LD      R16, X+
   \   00000074   911C               LD      R17, X
   \   00000076   9711               SBIW    R27:R26, 1
   \   00000078   01FD               MOVW    R31:R30, R27:R26
   \   0000007A   8142               LDD     R20, Z+2
   \   0000007C   8153               LDD     R21, Z+3
   \   0000007E   0F04               ADD     R16, R20
   \   00000080   1F15               ADC     R17, R21
   \   00000082   01F8               MOVW    R31:R30, R17:R16
   \   00000084   8320               ST      Z, R18
   \   00000086   01FD               MOVW    R31:R30, R27:R26
   \   00000088   8102               LDD     R16, Z+2
   \   0000008A   8113               LDD     R17, Z+3
   \   0000008C   5F0F               SUBI    R16, 255
   \   0000008E   4F1F               SBCI    R17, 255
   \   00000090   8302               STD     Z+2, R16
   \   00000092   8313               STD     Z+3, R17
    366          
    367              ReadEEPROMBuffer( (channel * sizeof(float)* 2) , sizeof(float), (char*)&UART[ch].pTxBuffer[UART[ch].TxFirst] );
   \   00000094   E008               LDI     R16, 8
   \   00000096   9F20               MUL     R18, R16
   \   00000098   01C0               MOVW    R25:R24, R1:R0
   \   0000009A   8140               LD      R20, Z
   \   0000009C   8151               LDD     R21, Z+1
   \   0000009E   8102               LDD     R16, Z+2
   \   000000A0   0F40               ADD     R20, R16
   \   000000A2   1F51               ADC     R21, R17
   \   000000A4   E024               LDI     R18, 4
   \   000000A6   0180               MOVW    R17:R16, R1:R0
   \   000000A8   ........           CALL    ReadEEPROMBuffer
    368              UART[ch].TxFirst += sizeof(float) ;
   \   000000AC   01FD               MOVW    R31:R30, R27:R26
   \   000000AE   8102               LDD     R16, Z+2
   \   000000B0   8113               LDD     R17, Z+3
   \   000000B2   5F0C               SUBI    R16, 252
   \   000000B4   4F1F               SBCI    R17, 255
   \   000000B6   8302               STD     Z+2, R16
   \   000000B8   8313               STD     Z+3, R17
    369              ReadEEPROMBuffer( (channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char*)&UART[ch].pTxBuffer[UART[ch].TxFirst] );
   \   000000BA   8140               LD      R20, Z
   \   000000BC   8151               LDD     R21, Z+1
   \   000000BE   0F40               ADD     R20, R16
   \   000000C0   1F51               ADC     R21, R17
   \   000000C2   E024               LDI     R18, 4
   \   000000C4   9604               ADIW    R25:R24, 4
   \   000000C6   018C               MOVW    R17:R16, R25:R24
   \   000000C8   ........           CALL    ReadEEPROMBuffer
    370              UART[ch].TxFirst += sizeof(float) ;
   \   000000CC   01FD               MOVW    R31:R30, R27:R26
   \   000000CE   8102               LDD     R16, Z+2
   \   000000D0   8113               LDD     R17, Z+3
   \   000000D2   5F0C               SUBI    R16, 252
   \   000000D4   4F1F               SBCI    R17, 255
   \   000000D6   8302               STD     Z+2, R16
   \   000000D8   8313               STD     Z+3, R17
    371          
    372              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   000000DA   1904               SUB     R16, R4
   \   000000DC   5002               SUBI    R16, 2
   \   000000DE   91ED               LD      R30, X+
   \   000000E0   91FC               LD      R31, X
   \   000000E2   9711               SBIW    R27:R26, 1
   \   000000E4   0DE4               ADD     R30, R4
   \   000000E6   1DF5               ADC     R31, R5
   \   000000E8   8300               ST      Z, R16
    373              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   000000EA   01FD               MOVW    R31:R30, R27:R26
   \   000000EC   8182               LDD     R24, Z+2
   \   000000EE   8193               LDD     R25, Z+3
   \   000000F0   1984               SUB     R24, R4
   \   000000F2   0995               SBC     R25, R5
   \   000000F4   9702               SBIW    R25:R24, 2
   \   000000F6   91ED               LD      R30, X+
   \   000000F8   91FC               LD      R31, X
   \   000000FA   0DE4               ADD     R30, R4
   \   000000FC   1DF5               ADC     R31, R5
   \   000000FE                      REQUIRE ?Subroutine1
   \   000000FE                      ;               // Fall through to label ?Subroutine1
    374          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   8391               STD     Z+1, R25
   \   00000002                      REQUIRE ??Subroutine5_0
   \   00000002                      ;               // Fall through to label ??Subroutine5_0
    375          
    376          
    377          /*************************************************************************
    378          *
    379          * Build datablock for Internal AD
    380          *
    381          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   01F8               MOVW    R31:R30, R17:R16
   \   00000002   8391               STD     Z+1, R25
   \   00000004   2D82               MOV     R24, R2
   \   00000006   2F95               MOV     R25, R21
   \   00000008   2DA3               MOV     R26, R3
   \   0000000A   91B9               LD      R27, Y+
   \   0000000C   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    382          void BuildADInt(char ch, short pointer) {
   \                     BuildADInt:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F59               MOV     R21, R25
   \   00000006   2E28               MOV     R2, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    383          
    384              short ntna, i ;
    385              UART[ch].RxSendReply = true ;                               // flag for answering
   \   00000008   E11A               LDI     R17, 26
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E001               LDI     R16, 1
   \   00000016   8F01               STD     Z+25, R16
    386          
    387              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_INT_DATA & 0xff;
   \   00000018   81A0               LD      R26, Z
   \   0000001A   81B1               LDD     R27, Z+1
   \   0000001C   8102               LDD     R16, Z+2
   \   0000001E   8113               LDD     R17, Z+3
   \   00000020   0FA0               ADD     R26, R16
   \   00000022   1FB1               ADC     R27, R17
   \   00000024   E403               LDI     R16, 67
   \   00000026   930C               ST      X, R16
   \   00000028   8102               LDD     R16, Z+2
   \   0000002A   8113               LDD     R17, Z+3
   \   0000002C   5F0F               SUBI    R16, 255
   \   0000002E   4F1F               SBCI    R17, 255
   \   00000030   8302               STD     Z+2, R16
   \   00000032   8313               STD     Z+3, R17
    388              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_INT_DATA >> 8;
   \   00000034   81A0               LD      R26, Z
   \   00000036   81B1               LDD     R27, Z+1
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   E004               LDI     R16, 4
   \   0000003E   930C               ST      X, R16
   \   00000040   8102               LDD     R16, Z+2
   \   00000042   8113               LDD     R17, Z+3
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   8302               STD     Z+2, R16
   \   0000004A   8313               STD     Z+3, R17
    389              ntna = UART[ch].TxFirst ;                                    /* remember index */
   \   0000004C   0198               MOVW    R19:R18, R17:R16
    390              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000004E   5F0E               SUBI    R16, 254
   \   00000050   4F1F               SBCI    R17, 255
   \   00000052   8302               STD     Z+2, R16
   \   00000054   8313               STD     Z+3, R17
    391          
    392              for (i = 0; i<3; i++) {
   \   00000056   ....               LDI     R16, LOW(ADInt)
   \   00000058   ....               LDI     R17, (ADInt) >> 8
   \   0000005A   E043               LDI     R20, 3
    393                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ADInt.Result[i] ;
   \                     ??BuildADInt_0:
   \   0000005C   01D8               MOVW    R27:R26, R17:R16
   \   0000005E   916D               LD      R22, X+
   \   00000060   81A0               LD      R26, Z
   \   00000062   81B1               LDD     R27, Z+1
   \   00000064   8002               LDD     R0, Z+2
   \   00000066   8013               LDD     R1, Z+3
   \   00000068   0DA0               ADD     R26, R0
   \   0000006A   1DB1               ADC     R27, R1
   \   0000006C   936C               ST      X, R22
   \   0000006E   8162               LDD     R22, Z+2
   \   00000070   8173               LDD     R23, Z+3
   \   00000072   5F6F               SUBI    R22, 255
   \   00000074   4F7F               SBCI    R23, 255
   \   00000076   8362               STD     Z+2, R22
   \   00000078   8373               STD     Z+3, R23
    394                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ADInt.Result[i] >> 8 ;   // ADresult
   \   0000007A   01D8               MOVW    R27:R26, R17:R16
   \   0000007C   9611               ADIW    R27:R26, 1
   \   0000007E   917D               LD      R23, X+
   \   00000080   018D               MOVW    R17:R16, R27:R26
   \   00000082   81A0               LD      R26, Z
   \   00000084   81B1               LDD     R27, Z+1
   \   00000086   8002               LDD     R0, Z+2
   \   00000088   8013               LDD     R1, Z+3
   \   0000008A   0DA0               ADD     R26, R0
   \   0000008C   1DB1               ADC     R27, R1
   \   0000008E   937C               ST      X, R23
   \   00000090   8162               LDD     R22, Z+2
   \   00000092   8173               LDD     R23, Z+3
   \   00000094   5F6F               SUBI    R22, 255
   \   00000096   4F7F               SBCI    R23, 255
   \   00000098   8362               STD     Z+2, R22
   \   0000009A   8373               STD     Z+3, R23
    395              }
   \   0000009C   954A               DEC     R20
   \   0000009E   F6F1               BRNE    ??BuildADInt_0
    396          
    397              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   000000A0   8102               LDD     R16, Z+2
   \   000000A2   1B02               SUB     R16, R18
   \   000000A4   5002               SUBI    R16, 2
   \   000000A6   81A0               LD      R26, Z
   \   000000A8   81B1               LDD     R27, Z+1
   \   000000AA   0FA2               ADD     R26, R18
   \   000000AC   1FB3               ADC     R27, R19
   \   000000AE   930C               ST      X, R16
    398              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   000000B0   8182               LDD     R24, Z+2
   \   000000B2   8193               LDD     R25, Z+3
   \   000000B4   1B82               SUB     R24, R18
   \   000000B6   0B93               SBC     R25, R19
   \   000000B8   9702               SBIW    R25:R24, 2
   \   000000BA   8100               LD      R16, Z
   \   000000BC   8111               LDD     R17, Z+1
   \   000000BE   0F02               ADD     R16, R18
   \   000000C0   1F13               ADC     R17, R19
   \   000000C2   ....               RJMP    ?Subroutine2
    399          
    400          }
    401          
    402          
    403          /*************************************************************************
    404          *
    405          * Build datablock for eeprom on ADcard
    406          *
    407          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    408          void BuildADEpromdata(char ch, char portch) {
   \                     BuildADEpromdata:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F79               MOV     R23, R25
   \   00000006   2E28               MOV     R2, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000008   2F21               MOV     R18, R17
    409          
    410              UART[ch].RxSendReply = true ;                               // flag for answering
   \   0000000A   E11A               LDI     R17, 26
   \   0000000C   9F01               MUL     R16, R17
   \   0000000E   ....               LDI     R30, LOW(UART)
   \   00000010   ....               LDI     R31, (UART) >> 8
   \   00000012   0DE0               ADD     R30, R0
   \   00000014   1DF1               ADC     R31, R1
   \   00000016   E001               LDI     R16, 1
   \   00000018   8F01               STD     Z+25, R16
    411          
    412              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_ADBUF & 0xff;
   \   0000001A   81A0               LD      R26, Z
   \   0000001C   81B1               LDD     R27, Z+1
   \   0000001E   8102               LDD     R16, Z+2
   \   00000020   8113               LDD     R17, Z+3
   \   00000022   0FA0               ADD     R26, R16
   \   00000024   1FB1               ADC     R27, R17
   \   00000026   E809               LDI     R16, 137
   \   00000028   930C               ST      X, R16
   \   0000002A   8102               LDD     R16, Z+2
   \   0000002C   8113               LDD     R17, Z+3
   \   0000002E   5F0F               SUBI    R16, 255
   \   00000030   4F1F               SBCI    R17, 255
   \   00000032   8302               STD     Z+2, R16
   \   00000034   8313               STD     Z+3, R17
    413              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_ADBUF >> 8;
   \   00000036   81A0               LD      R26, Z
   \   00000038   81B1               LDD     R27, Z+1
   \   0000003A   0FA0               ADD     R26, R16
   \   0000003C   1FB1               ADC     R27, R17
   \   0000003E   E004               LDI     R16, 4
   \   00000040   930C               ST      X, R16
   \   00000042   8102               LDD     R16, Z+2
   \   00000044   8113               LDD     R17, Z+3
   \   00000046   5F0F               SUBI    R16, 255
   \   00000048   4F1F               SBCI    R17, 255
   \   0000004A   8302               STD     Z+2, R16
   \   0000004C   8313               STD     Z+3, R17
    414              short ntna = UART[ch].TxFirst ;                                    // remember index
   \   0000004E   01A8               MOVW    R21:R20, R17:R16
    415              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   00000050   5F0E               SUBI    R16, 254
   \   00000052   4F1F               SBCI    R17, 255
   \   00000054   8302               STD     Z+2, R16
   \   00000056   8313               STD     Z+3, R17
    416          
    417              for (short i = 0; i < 44; i++) {
   \   00000058   ....               LDI     R16, LOW((TData + 1428))
   \   0000005A   ....               LDI     R17, HIGH((TData + 1428))
   \   0000005C   E332               LDI     R19, 50
   \   0000005E   9F23               MUL     R18, R19
   \   00000060   0D00               ADD     R16, R0
   \   00000062   1D11               ADC     R17, R1
   \   00000064   E26C               LDI     R22, 44
    418                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.FromTargetBuffer[portch][i] ;
   \                     ??BuildADEpromdata_0:
   \   00000066   01D8               MOVW    R27:R26, R17:R16
   \   00000068   912D               LD      R18, X+
   \   0000006A   018D               MOVW    R17:R16, R27:R26
   \   0000006C   81A0               LD      R26, Z
   \   0000006E   81B1               LDD     R27, Z+1
   \   00000070   8002               LDD     R0, Z+2
   \   00000072   8013               LDD     R1, Z+3
   \   00000074   0DA0               ADD     R26, R0
   \   00000076   1DB1               ADC     R27, R1
   \   00000078   932C               ST      X, R18
   \   0000007A   8122               LDD     R18, Z+2
   \   0000007C   8133               LDD     R19, Z+3
   \   0000007E   5F2F               SUBI    R18, 255
   \   00000080   4F3F               SBCI    R19, 255
   \   00000082   8322               STD     Z+2, R18
   \   00000084   8333               STD     Z+3, R19
    419              }
   \   00000086   956A               DEC     R22
   \   00000088   F771               BRNE    ??BuildADEpromdata_0
    420              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   0000008A   8102               LDD     R16, Z+2
   \   0000008C   1B04               SUB     R16, R20
   \   0000008E   5002               SUBI    R16, 2
   \   00000090   81A0               LD      R26, Z
   \   00000092   81B1               LDD     R27, Z+1
   \   00000094   0FA4               ADD     R26, R20
   \   00000096   1FB5               ADC     R27, R21
   \   00000098   930C               ST      X, R16
    421              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000009A   8182               LDD     R24, Z+2
   \   0000009C   8193               LDD     R25, Z+3
   \   0000009E   1B84               SUB     R24, R20
   \   000000A0   0B95               SBC     R25, R21
   \   000000A2   9702               SBIW    R25:R24, 2
   \   000000A4   8100               LD      R16, Z
   \   000000A6   8111               LDD     R17, Z+1
   \   000000A8   0F04               ADD     R16, R20
   \   000000AA   1F15               ADC     R17, R21
   \   000000AC   01F8               MOVW    R31:R30, R17:R16
   \   000000AE   8391               STD     Z+1, R25
    422          
    423          }
   \   000000B0                      REQUIRE ?Subroutine4
   \   000000B0                      ;               // Fall through to label ?Subroutine4

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   2D82               MOV     R24, R2
   \   00000002   2F97               MOV     R25, R23
   \   00000004   2DA3               MOV     R26, R3
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9508               RET
    424          
    425          /*************************************************************************
    426          *
    427          * Build datablock for WHData on ADcard
    428          *
    429          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    430          void BuildWHdata(char ch, short pointer) {
   \                     BuildWHdata:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    431          
    432              UART[ch].RxSendReply = true;                               // flag for answering
   \   00000008   E11A               LDI     R17, 26
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E001               LDI     R16, 1
   \   00000016   8F01               STD     Z+25, R16
    433          
    434              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_SND_RS4_WHBUF & 0xff;
   \   00000018   81A0               LD      R26, Z
   \   0000001A   81B1               LDD     R27, Z+1
   \   0000001C   8102               LDD     R16, Z+2
   \   0000001E   8113               LDD     R17, Z+3
   \   00000020   0FA0               ADD     R26, R16
   \   00000022   1FB1               ADC     R27, R17
   \   00000024   E90C               LDI     R16, 156
   \   00000026   930C               ST      X, R16
   \   00000028   8102               LDD     R16, Z+2
   \   0000002A   8113               LDD     R17, Z+3
   \   0000002C   5F0F               SUBI    R16, 255
   \   0000002E   4F1F               SBCI    R17, 255
   \   00000030   8302               STD     Z+2, R16
   \   00000032   8313               STD     Z+3, R17
    435              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_SND_RS4_WHBUF >> 8;
   \   00000034   81A0               LD      R26, Z
   \   00000036   81B1               LDD     R27, Z+1
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   E004               LDI     R16, 4
   \   0000003E   930C               ST      X, R16
   \   00000040   8102               LDD     R16, Z+2
   \   00000042   8113               LDD     R17, Z+3
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   8302               STD     Z+2, R16
   \   0000004A   8313               STD     Z+3, R17
    436              short ntna = UART[ch].TxFirst;                          // remember index
    437              UART[ch].TxFirst += 2;                                  // two byte length
   \   0000004C   01A8               MOVW    R21:R20, R17:R16
   \   0000004E   5F4E               SUBI    R20, 254
   \   00000050   4F5F               SBCI    R21, 255
   \   00000052   8342               STD     Z+2, R20
   \   00000054   8353               STD     Z+3, R21
    438          
    439              OS_EnterRegion();
   \   00000056   9140....           LDS     R20, OS_Global
   \   0000005A   9543               INC     R20
   \   0000005C   9340....           STS     OS_Global, R20
    440              for (short i = 0; i < 4; i++) {
   \   00000060   E080               LDI     R24, 0
   \   00000062   E090               LDI     R25, 0
   \   00000064   E044               LDI     R20, 4
    441                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.WTrackCnt[UART[ch].pRxBuffer[pointer]][i] & 0xff; // WashTrackcnt
   \                     ??BuildWHdata_0:
   \   00000066   011C               MOVW    R3:R2, R25:R24
   \   00000068   0C22               LSL     R2
   \   0000006A   1C33               ROL     R3
   \   0000006C   ....               LDI     R22, LOW((TData + 1179))
   \   0000006E   ....               LDI     R23, HIGH((TData + 1179))
   \   00000070   0D62               ADD     R22, R2
   \   00000072   1D73               ADC     R23, R3
   \   00000074   85A2               LDD     R26, Z+10
   \   00000076   85B3               LDD     R27, Z+11
   \   00000078   0FA2               ADD     R26, R18
   \   0000007A   1FB3               ADC     R27, R19
   \   0000007C   900C               LD      R0, X
   \   0000007E   E058               LDI     R21, 8
   \   00000080   9E05               MUL     R0, R21
   \   00000082   0D60               ADD     R22, R0
   \   00000084   1D71               ADC     R23, R1
   \   00000086   01DB               MOVW    R27:R26, R23:R22
   \   00000088   916D               LD      R22, X+
   \   0000008A   81A0               LD      R26, Z
   \   0000008C   81B1               LDD     R27, Z+1
   \   0000008E   8002               LDD     R0, Z+2
   \   00000090   8013               LDD     R1, Z+3
   \   00000092   0DA0               ADD     R26, R0
   \   00000094   1DB1               ADC     R27, R1
   \   00000096   936C               ST      X, R22
   \   00000098   8162               LDD     R22, Z+2
   \   0000009A   8173               LDD     R23, Z+3
   \   0000009C   5F6F               SUBI    R22, 255
   \   0000009E   4F7F               SBCI    R23, 255
   \   000000A0   8362               STD     Z+2, R22
   \   000000A2   8373               STD     Z+3, R23
    442                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.RS4.WTrackCnt[UART[ch].pRxBuffer[pointer]][i] >> 8) & 0xff; // WashTrackcnt
   \   000000A4   ....               LDI     R22, LOW((TData + 1179))
   \   000000A6   ....               LDI     R23, HIGH((TData + 1179))
   \   000000A8   0D62               ADD     R22, R2
   \   000000AA   1D73               ADC     R23, R3
   \   000000AC   85A2               LDD     R26, Z+10
   \   000000AE   85B3               LDD     R27, Z+11
   \   000000B0   0FA2               ADD     R26, R18
   \   000000B2   1FB3               ADC     R27, R19
   \   000000B4   915C               LD      R21, X
   \   000000B6   E0A8               LDI     R26, 8
   \   000000B8   9F5A               MUL     R21, R26
   \   000000BA   0D60               ADD     R22, R0
   \   000000BC   1D71               ADC     R23, R1
   \   000000BE   01DB               MOVW    R27:R26, R23:R22
   \   000000C0   9611               ADIW    R27:R26, 1
   \   000000C2   916C               LD      R22, X
   \   000000C4   81A0               LD      R26, Z
   \   000000C6   81B1               LDD     R27, Z+1
   \   000000C8   8002               LDD     R0, Z+2
   \   000000CA   8013               LDD     R1, Z+3
   \   000000CC   0DA0               ADD     R26, R0
   \   000000CE   1DB1               ADC     R27, R1
   \   000000D0   936C               ST      X, R22
   \   000000D2   8162               LDD     R22, Z+2
   \   000000D4   8173               LDD     R23, Z+3
   \   000000D6   5F6F               SUBI    R22, 255
   \   000000D8   4F7F               SBCI    R23, 255
   \   000000DA   8362               STD     Z+2, R22
   \   000000DC   8373               STD     Z+3, R23
    443              }
   \   000000DE   9601               ADIW    R25:R24, 1
   \   000000E0   954A               DEC     R20
   \   000000E2   F609               BRNE    ??BuildWHdata_0
    444              UART[ch].pTxBuffer[UART[ch].TxFirst++] =  TData.RS4.LevelSwitch[UART[ch].pRxBuffer[pointer]];
   \   000000E4   85A2               LDD     R26, Z+10
   \   000000E6   85B3               LDD     R27, Z+11
   \   000000E8   0FA2               ADD     R26, R18
   \   000000EA   1FB3               ADC     R27, R19
   \   000000EC   91AC               LD      R26, X
   \   000000EE   E0B0               LDI     R27, 0
   \   000000F0   ....               SUBI    R26, LOW((-(TData + 1243) & 0xFFFF))
   \   000000F2   ....               SBCI    R27, HIGH((-(TData + 1243) & 0xFFFF))
   \   000000F4   914C               LD      R20, X
   \   000000F6   81A0               LD      R26, Z
   \   000000F8   81B1               LDD     R27, Z+1
   \   000000FA   8162               LDD     R22, Z+2
   \   000000FC   0FA6               ADD     R26, R22
   \   000000FE   1FB7               ADC     R27, R23
   \   00000100   934C               ST      X, R20
   \   00000102   8142               LDD     R20, Z+2
   \   00000104   8153               LDD     R21, Z+3
   \   00000106   5F4F               SUBI    R20, 255
   \   00000108   4F5F               SBCI    R21, 255
   \   0000010A   8342               STD     Z+2, R20
   \   0000010C   8353               STD     Z+3, R21
    445              UART[ch].pTxBuffer[UART[ch].TxFirst++] =  TData.RS4.WTTime[UART[ch].pRxBuffer[pointer]] & 0xff; // WashTrackcnt
   \   0000010E   85A2               LDD     R26, Z+10
   \   00000110   85B3               LDD     R27, Z+11
   \   00000112   0FA2               ADD     R26, R18
   \   00000114   1FB3               ADC     R27, R19
   \   00000116   914C               LD      R20, X
   \   00000118   E052               LDI     R21, 2
   \   0000011A   9F45               MUL     R20, R21
   \   0000011C   01D0               MOVW    R27:R26, R1:R0
   \   0000011E   ....               SUBI    R26, LOW((-(TData + 1251) & 0xFFFF))
   \   00000120   ....               SBCI    R27, HIGH((-(TData + 1251) & 0xFFFF))
   \   00000122   914D               LD      R20, X+
   \   00000124   81A0               LD      R26, Z
   \   00000126   81B1               LDD     R27, Z+1
   \   00000128   8162               LDD     R22, Z+2
   \   0000012A   8173               LDD     R23, Z+3
   \   0000012C   0FA6               ADD     R26, R22
   \   0000012E   1FB7               ADC     R27, R23
   \   00000130   934C               ST      X, R20
   \   00000132   8142               LDD     R20, Z+2
   \   00000134   8153               LDD     R21, Z+3
   \   00000136   5F4F               SUBI    R20, 255
   \   00000138   4F5F               SBCI    R21, 255
   \   0000013A   8342               STD     Z+2, R20
   \   0000013C   8353               STD     Z+3, R21
    446              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.RS4.WTTime[UART[ch].pRxBuffer[pointer]] >> 8) & 0xff; // WashTrackcnt
   \   0000013E   85A2               LDD     R26, Z+10
   \   00000140   85B3               LDD     R27, Z+11
   \   00000142   0FA2               ADD     R26, R18
   \   00000144   1FB3               ADC     R27, R19
   \   00000146   912C               LD      R18, X
   \   00000148   E032               LDI     R19, 2
   \   0000014A   9F23               MUL     R18, R19
   \   0000014C   01D0               MOVW    R27:R26, R1:R0
   \   0000014E   ....               SUBI    R26, LOW((-(TData + 1251) & 0xFFFF))
   \   00000150   ....               SBCI    R27, HIGH((-(TData + 1251) & 0xFFFF))
   \   00000152   9611               ADIW    R27:R26, 1
   \   00000154   912C               LD      R18, X
   \   00000156   81A0               LD      R26, Z
   \   00000158   81B1               LDD     R27, Z+1
   \   0000015A   8142               LDD     R20, Z+2
   \   0000015C   0FA4               ADD     R26, R20
   \   0000015E   1FB5               ADC     R27, R21
   \   00000160   932C               ST      X, R18
   \   00000162   8122               LDD     R18, Z+2
   \   00000164   8133               LDD     R19, Z+3
   \   00000166   5F2F               SUBI    R18, 255
   \   00000168   4F3F               SBCI    R19, 255
   \   0000016A   8322               STD     Z+2, R18
   \   0000016C   8333               STD     Z+3, R19
    447              UART[ch].pTxBuffer[ntna]     = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   0000016E   1B20               SUB     R18, R16
   \   00000170   5022               SUBI    R18, 2
   \   00000172   81A0               LD      R26, Z
   \   00000174   81B1               LDD     R27, Z+1
   \   00000176   0FA0               ADD     R26, R16
   \   00000178   1FB1               ADC     R27, R17
   \   0000017A   932C               ST      X, R18
    448              UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000017C   8182               LDD     R24, Z+2
   \   0000017E   8193               LDD     R25, Z+3
   \   00000180   1B80               SUB     R24, R16
   \   00000182   0B91               SBC     R25, R17
   \   00000184   9702               SBIW    R25:R24, 2
   \   00000186   8120               LD      R18, Z
   \   00000188   8131               LDD     R19, Z+1
   \   0000018A   0F20               ADD     R18, R16
   \   0000018C   1F31               ADC     R19, R17
   \   0000018E   01F9               MOVW    R31:R30, R19:R18
   \   00000190   8391               STD     Z+1, R25
    449              OS_LeaveRegion();
   \   00000192   ........           CALL    OS_LeaveRegion
    450          }
   \   00000196   ....               RJMP    ?Subroutine3

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9508               RET
    451          
    452          
    453          
    454          /*************************************************************************
    455          *
    456          * Build setup dat package for AN-ZB485
    457          *
    458          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   81A0               LD      R26, Z
   \   00000002   81B1               LDD     R27, Z+1
   \   00000004   8142               LDD     R20, Z+2
   \   00000006   0FA4               ADD     R26, R20
   \   00000008   1FB3               ADC     R27, R19
   \   0000000A   932C               ST      X, R18
   \   0000000C   8122               LDD     R18, Z+2
   \   0000000E   8133               LDD     R19, Z+3
   \   00000010   5F2F               SUBI    R18, 255
   \   00000012   4F3F               SBCI    R19, 255
   \   00000014   8322               STD     Z+2, R18
   \   00000016   8333               STD     Z+3, R19
   \   00000018   1B20               SUB     R18, R16
   \   0000001A   5022               SUBI    R18, 2
   \   0000001C   81A0               LD      R26, Z
   \   0000001E   81B1               LDD     R27, Z+1
   \   00000020   0FA0               ADD     R26, R16
   \   00000022   1FB1               ADC     R27, R17
   \   00000024   932C               ST      X, R18
   \   00000026   8182               LDD     R24, Z+2
   \   00000028   8193               LDD     R25, Z+3
   \   0000002A   1B80               SUB     R24, R16
   \   0000002C   0B91               SBC     R25, R17
   \   0000002E   9702               SBIW    R25:R24, 2
   \   00000030   8120               LD      R18, Z
   \   00000032   8131               LDD     R19, Z+1
   \   00000034   0F20               ADD     R18, R16
   \   00000036   1F31               ADC     R19, R17
   \   00000038   01F9               MOVW    R31:R30, R19:R18
   \   0000003A   8391               STD     Z+1, R25
   \   0000003C   2F86               MOV     R24, R22
   \   0000003E   2F95               MOV     R25, R21
   \   00000040   2DA2               MOV     R26, R2
   \   00000042   2FB7               MOV     R27, R23
   \   00000044   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    459          void BuildRS4Setup(char ch, short pointer) {
   \                     BuildRS4Setup:
   \   00000000   2F7B               MOV     R23, R27
   \   00000002   2E2A               MOV     R2, R26
   \   00000004   2F59               MOV     R21, R25
   \   00000006   2F68               MOV     R22, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    460          
    461              short ntna ;
    462              UART[ch].RxSendReply = true ;                               // flag for answering
   \   00000008   E11A               LDI     R17, 26
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E001               LDI     R16, 1
   \   00000016   8F01               STD     Z+25, R16
    463          
    464              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_SETUP & 0xff;
   \   00000018   81A0               LD      R26, Z
   \   0000001A   81B1               LDD     R27, Z+1
   \   0000001C   8102               LDD     R16, Z+2
   \   0000001E   8113               LDD     R17, Z+3
   \   00000020   0FA0               ADD     R26, R16
   \   00000022   1FB1               ADC     R27, R17
   \   00000024   E507               LDI     R16, 87
   \   00000026   930C               ST      X, R16
   \   00000028   8102               LDD     R16, Z+2
   \   0000002A   8113               LDD     R17, Z+3
   \   0000002C   5F0F               SUBI    R16, 255
   \   0000002E   4F1F               SBCI    R17, 255
   \   00000030   8302               STD     Z+2, R16
   \   00000032   8313               STD     Z+3, R17
    465              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_SETUP >> 8;
   \   00000034   81A0               LD      R26, Z
   \   00000036   81B1               LDD     R27, Z+1
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   E004               LDI     R16, 4
   \   0000003E   930C               ST      X, R16
   \   00000040   8102               LDD     R16, Z+2
   \   00000042   8113               LDD     R17, Z+3
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   8302               STD     Z+2, R16
   \   0000004A   8313               STD     Z+3, R17
    466              ntna = UART[ch].TxFirst ;                                    /* remember index */
    467              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000004C   0198               MOVW    R19:R18, R17:R16
   \   0000004E   5F2E               SUBI    R18, 254
   \   00000050   4F3F               SBCI    R19, 255
   \   00000052   8322               STD     Z+2, R18
   \   00000054   8333               STD     Z+3, R19
    468          
    469              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.PortUsed;  // send the setup
   \   00000056   9120....           LDS     R18, TData
   \   0000005A   81A0               LD      R26, Z
   \   0000005C   81B1               LDD     R27, Z+1
   \   0000005E   8142               LDD     R20, Z+2
   \   00000060   0FA4               ADD     R26, R20
   \   00000062   1FB3               ADC     R27, R19
   \   00000064   932C               ST      X, R18
   \   00000066   8122               LDD     R18, Z+2
   \   00000068   8133               LDD     R19, Z+3
   \   0000006A   5F2F               SUBI    R18, 255
   \   0000006C   4F3F               SBCI    R19, 255
   \   0000006E   8322               STD     Z+2, R18
   \   00000070   8333               STD     Z+3, R19
    470              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.SensorType[0];  // send the sensor type
   \   00000072   9120....           LDS     R18, (TData + 1)
   \   00000076   81A0               LD      R26, Z
   \   00000078   81B1               LDD     R27, Z+1
   \   0000007A   8142               LDD     R20, Z+2
   \   0000007C   0FA4               ADD     R26, R20
   \   0000007E   1FB3               ADC     R27, R19
   \   00000080   932C               ST      X, R18
   \   00000082   8122               LDD     R18, Z+2
   \   00000084   8133               LDD     R19, Z+3
   \   00000086   5F2F               SUBI    R18, 255
   \   00000088   4F3F               SBCI    R19, 255
   \   0000008A   8322               STD     Z+2, R18
   \   0000008C   8333               STD     Z+3, R19
    471              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.SensorType[1];  // send the sensor type
   \   0000008E   9120....           LDS     R18, (TData + 2)
   \   00000092   ....               RJMP    ?Subroutine0
    472          
    473              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
    474              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
    475          }
    476          
    477          /*************************************************************************
    478          *
    479          * Build datablock of measured data for ADcard
    480          *
    481          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    482          void BuildMData485(char ch, short pointer) {
   \                     BuildMData485:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    483          
    484              short ntna, i ;
    485              UART[ch].RxSendReply = true ;                               // flag for answering
   \   00000008   E11A               LDI     R17, 26
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E001               LDI     R16, 1
   \   00000016   8F01               STD     Z+25, R16
    486          
    487              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_MDATA & 0xff;
   \   00000018   81A0               LD      R26, Z
   \   0000001A   81B1               LDD     R27, Z+1
   \   0000001C   8102               LDD     R16, Z+2
   \   0000001E   8113               LDD     R17, Z+3
   \   00000020   0FA0               ADD     R26, R16
   \   00000022   1FB1               ADC     R27, R17
   \   00000024   E705               LDI     R16, 117
   \   00000026   930C               ST      X, R16
   \   00000028   8102               LDD     R16, Z+2
   \   0000002A   8113               LDD     R17, Z+3
   \   0000002C   5F0F               SUBI    R16, 255
   \   0000002E   4F1F               SBCI    R17, 255
   \   00000030   8302               STD     Z+2, R16
   \   00000032   8313               STD     Z+3, R17
    488              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_MDATA >> 8;
   \   00000034   81A0               LD      R26, Z
   \   00000036   81B1               LDD     R27, Z+1
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   E004               LDI     R16, 4
   \   0000003E   930C               ST      X, R16
   \   00000040   8102               LDD     R16, Z+2
   \   00000042   8113               LDD     R17, Z+3
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   8302               STD     Z+2, R16
   \   0000004A   8313               STD     Z+3, R17
    489              ntna = UART[ch].TxFirst ;                                    /* remember index */
   \   0000004C   0118               MOVW    R3:R2, R17:R16
    490              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000004E   5F0E               SUBI    R16, 254
   \   00000050   4F1F               SBCI    R17, 255
   \   00000052   8302               STD     Z+2, R16
   \   00000054   8313               STD     Z+3, R17
    491          
    492              UART[ch].pTxBuffer[UART[ch].TxFirst++] = UART[ch].pRxBuffer[pointer] ;
   \   00000056   85A2               LDD     R26, Z+10
   \   00000058   85B3               LDD     R27, Z+11
   \   0000005A   0FA2               ADD     R26, R18
   \   0000005C   1FB3               ADC     R27, R19
   \   0000005E   910C               LD      R16, X
   \   00000060   81A0               LD      R26, Z
   \   00000062   81B1               LDD     R27, Z+1
   \   00000064   8142               LDD     R20, Z+2
   \   00000066   0FA4               ADD     R26, R20
   \   00000068   1FB1               ADC     R27, R17
   \   0000006A   930C               ST      X, R16
   \   0000006C   8102               LDD     R16, Z+2
   \   0000006E   8113               LDD     R17, Z+3
   \   00000070   5F0F               SUBI    R16, 255
   \   00000072   4F1F               SBCI    R17, 255
   \   00000074   8302               STD     Z+2, R16
   \   00000076   8313               STD     Z+3, R17
    493              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.IOUnitStatus[UART[ch].pRxBuffer[pointer]] | (RestartStatus <<4); // IOUnit status +  restart status
   \   00000078   85A2               LDD     R26, Z+10
   \   0000007A   85B3               LDD     R27, Z+11
   \   0000007C   0FA2               ADD     R26, R18
   \   0000007E   1FB3               ADC     R27, R19
   \   00000080   91AC               LD      R26, X
   \   00000082   E0B0               LDI     R27, 0
   \   00000084   ....               SUBI    R26, LOW((-(TData + 3) & 0xFFFF))
   \   00000086   ....               SBCI    R27, HIGH((-(TData + 3) & 0xFFFF))
   \   00000088   910C               LD      R16, X
   \   0000008A   9110....           LDS     R17, RestartStatus
   \   0000008E   9512               SWAP    R17
   \   00000090   7F10               ANDI    R17, 0xF0
   \   00000092   2B01               OR      R16, R17
   \   00000094   81A0               LD      R26, Z
   \   00000096   81B1               LDD     R27, Z+1
   \   00000098   8142               LDD     R20, Z+2
   \   0000009A   8153               LDD     R21, Z+3
   \   0000009C   0FA4               ADD     R26, R20
   \   0000009E   1FB5               ADC     R27, R21
   \   000000A0   930C               ST      X, R16
   \   000000A2   8102               LDD     R16, Z+2
   \   000000A4   8113               LDD     R17, Z+3
   \   000000A6   5F0F               SUBI    R16, 255
   \   000000A8   4F1F               SBCI    R17, 255
   \   000000AA   8302               STD     Z+2, R16
   \   000000AC   8313               STD     Z+3, R17
    494              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.FailCnt[UART[ch].pRxBuffer[pointer]][0] & 0xff; // Failcnt error
   \   000000AE   85A2               LDD     R26, Z+10
   \   000000B0   85B3               LDD     R27, Z+11
   \   000000B2   0FA2               ADD     R26, R18
   \   000000B4   1FB3               ADC     R27, R19
   \   000000B6   910C               LD      R16, X
   \   000000B8   E014               LDI     R17, 4
   \   000000BA   9F01               MUL     R16, R17
   \   000000BC   01D0               MOVW    R27:R26, R1:R0
   \   000000BE   ....               SUBI    R26, LOW((-(TData + 11) & 0xFFFF))
   \   000000C0   ....               SBCI    R27, HIGH((-(TData + 11) & 0xFFFF))
   \   000000C2   910D               LD      R16, X+
   \   000000C4   81A0               LD      R26, Z
   \   000000C6   81B1               LDD     R27, Z+1
   \   000000C8   8142               LDD     R20, Z+2
   \   000000CA   8153               LDD     R21, Z+3
   \   000000CC   0FA4               ADD     R26, R20
   \   000000CE   1FB5               ADC     R27, R21
   \   000000D0   930C               ST      X, R16
   \   000000D2   8102               LDD     R16, Z+2
   \   000000D4   8113               LDD     R17, Z+3
   \   000000D6   5F0F               SUBI    R16, 255
   \   000000D8   4F1F               SBCI    R17, 255
   \   000000DA   8302               STD     Z+2, R16
   \   000000DC   8313               STD     Z+3, R17
    495              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.RS4.FailCnt[UART[ch].pRxBuffer[pointer]][0] >> 8) & 0xff; // Failcnt error
   \   000000DE   85A2               LDD     R26, Z+10
   \   000000E0   85B3               LDD     R27, Z+11
   \   000000E2   0FA2               ADD     R26, R18
   \   000000E4   1FB3               ADC     R27, R19
   \   000000E6   910C               LD      R16, X
   \   000000E8   E014               LDI     R17, 4
   \   000000EA   9F01               MUL     R16, R17
   \   000000EC   01D0               MOVW    R27:R26, R1:R0
   \   000000EE   ....               SUBI    R26, LOW((-(TData + 11) & 0xFFFF))
   \   000000F0   ....               SBCI    R27, HIGH((-(TData + 11) & 0xFFFF))
   \   000000F2   9611               ADIW    R27:R26, 1
   \   000000F4   910C               LD      R16, X
   \   000000F6   81A0               LD      R26, Z
   \   000000F8   81B1               LDD     R27, Z+1
   \   000000FA   8142               LDD     R20, Z+2
   \   000000FC   8153               LDD     R21, Z+3
   \   000000FE   0FA4               ADD     R26, R20
   \   00000100   1FB5               ADC     R27, R21
   \   00000102   930C               ST      X, R16
   \   00000104   8102               LDD     R16, Z+2
   \   00000106   8113               LDD     R17, Z+3
   \   00000108   5F0F               SUBI    R16, 255
   \   0000010A   4F1F               SBCI    R17, 255
   \   0000010C   8302               STD     Z+2, R16
   \   0000010E   8313               STD     Z+3, R17
    496              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.FailCnt[UART[ch].pRxBuffer[pointer]][1] & 0xff; // Failcnt total
   \   00000110   85A2               LDD     R26, Z+10
   \   00000112   85B3               LDD     R27, Z+11
   \   00000114   0FA2               ADD     R26, R18
   \   00000116   1FB3               ADC     R27, R19
   \   00000118   910C               LD      R16, X
   \   0000011A   E014               LDI     R17, 4
   \   0000011C   9F01               MUL     R16, R17
   \   0000011E   01D0               MOVW    R27:R26, R1:R0
   \   00000120   ....               SUBI    R26, LOW((-(TData + 13) & 0xFFFF))
   \   00000122   ....               SBCI    R27, HIGH((-(TData + 13) & 0xFFFF))
   \   00000124   910D               LD      R16, X+
   \   00000126   81A0               LD      R26, Z
   \   00000128   81B1               LDD     R27, Z+1
   \   0000012A   8142               LDD     R20, Z+2
   \   0000012C   8153               LDD     R21, Z+3
   \   0000012E   0FA4               ADD     R26, R20
   \   00000130   1FB5               ADC     R27, R21
   \   00000132   930C               ST      X, R16
   \   00000134   8102               LDD     R16, Z+2
   \   00000136   8113               LDD     R17, Z+3
   \   00000138   5F0F               SUBI    R16, 255
   \   0000013A   4F1F               SBCI    R17, 255
   \   0000013C   8302               STD     Z+2, R16
   \   0000013E   8313               STD     Z+3, R17
    497              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.RS4.FailCnt[UART[ch].pRxBuffer[pointer]][1] >> 8) & 0xff; // Failcnt total
   \   00000140   85A2               LDD     R26, Z+10
   \   00000142   85B3               LDD     R27, Z+11
   \   00000144   0FA2               ADD     R26, R18
   \   00000146   1FB3               ADC     R27, R19
   \   00000148   910C               LD      R16, X
   \   0000014A   E014               LDI     R17, 4
   \   0000014C   9F01               MUL     R16, R17
   \   0000014E   01D0               MOVW    R27:R26, R1:R0
   \   00000150   ....               SUBI    R26, LOW((-(TData + 13) & 0xFFFF))
   \   00000152   ....               SBCI    R27, HIGH((-(TData + 13) & 0xFFFF))
   \   00000154   9611               ADIW    R27:R26, 1
   \   00000156   910C               LD      R16, X
   \   00000158   81A0               LD      R26, Z
   \   0000015A   81B1               LDD     R27, Z+1
   \   0000015C   8142               LDD     R20, Z+2
   \   0000015E   8153               LDD     R21, Z+3
   \   00000160   0FA4               ADD     R26, R20
   \   00000162   1FB5               ADC     R27, R21
   \   00000164   930C               ST      X, R16
   \   00000166   8102               LDD     R16, Z+2
   \   00000168   8113               LDD     R17, Z+3
   \   0000016A   5F0F               SUBI    R16, 255
   \   0000016C   4F1F               SBCI    R17, 255
   \   0000016E   8302               STD     Z+2, R16
   \   00000170   8313               STD     Z+3, R17
    498              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.TargetStatusSWVer[UART[ch].pRxBuffer[pointer]] ; // Target status byte 1
   \   00000172   85A2               LDD     R26, Z+10
   \   00000174   85B3               LDD     R27, Z+11
   \   00000176   0FA2               ADD     R26, R18
   \   00000178   1FB3               ADC     R27, R19
   \   0000017A   91AC               LD      R26, X
   \   0000017C   E0B0               LDI     R27, 0
   \   0000017E   ....               SUBI    R26, LOW((-(TData + 43) & 0xFFFF))
   \   00000180   ....               SBCI    R27, HIGH((-(TData + 43) & 0xFFFF))
   \   00000182   910C               LD      R16, X
   \   00000184   81A0               LD      R26, Z
   \   00000186   81B1               LDD     R27, Z+1
   \   00000188   8142               LDD     R20, Z+2
   \   0000018A   0FA4               ADD     R26, R20
   \   0000018C   1FB1               ADC     R27, R17
   \   0000018E   930C               ST      X, R16
   \   00000190   8102               LDD     R16, Z+2
   \   00000192   8113               LDD     R17, Z+3
   \   00000194   5F0F               SUBI    R16, 255
   \   00000196   4F1F               SBCI    R17, 255
   \   00000198   8302               STD     Z+2, R16
   \   0000019A   8313               STD     Z+3, R17
    499              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.TargetStatusAddress[UART[ch].pRxBuffer[pointer]] ; // Target status byte 2
   \   0000019C   85A2               LDD     R26, Z+10
   \   0000019E   85B3               LDD     R27, Z+11
   \   000001A0   0FA2               ADD     R26, R18
   \   000001A2   1FB3               ADC     R27, R19
   \   000001A4   91AC               LD      R26, X
   \   000001A6   E0B0               LDI     R27, 0
   \   000001A8   ....               SUBI    R26, LOW((-(TData + 51) & 0xFFFF))
   \   000001AA   ....               SBCI    R27, HIGH((-(TData + 51) & 0xFFFF))
   \   000001AC   910C               LD      R16, X
   \   000001AE   81A0               LD      R26, Z
   \   000001B0   81B1               LDD     R27, Z+1
   \   000001B2   8142               LDD     R20, Z+2
   \   000001B4   0FA4               ADD     R26, R20
   \   000001B6   1FB1               ADC     R27, R17
   \   000001B8   930C               ST      X, R16
   \   000001BA   8102               LDD     R16, Z+2
   \   000001BC   8113               LDD     R17, Z+3
   \   000001BE   5F0F               SUBI    R16, 255
   \   000001C0   4F1F               SBCI    R17, 255
   \   000001C2   8302               STD     Z+2, R16
   \   000001C4   8313               STD     Z+3, R17
    500          
    501              TData.RS4.TargetStatusAddress[UART[ch].pRxBuffer[pointer]] &= ~0x80;                                  //reset restart flag for adcard
   \   000001C6   85A2               LDD     R26, Z+10
   \   000001C8   85B3               LDD     R27, Z+11
   \   000001CA   0FA2               ADD     R26, R18
   \   000001CC   1FB3               ADC     R27, R19
   \   000001CE   91AC               LD      R26, X
   \   000001D0   E0B0               LDI     R27, 0
   \   000001D2   ....               SUBI    R26, LOW((-(TData + 51) & 0xFFFF))
   \   000001D4   ....               SBCI    R27, HIGH((-(TData + 51) & 0xFFFF))
   \   000001D6   910C               LD      R16, X
   \   000001D8   770F               ANDI    R16, 0x7F
   \   000001DA   930C               ST      X, R16
    502          
    503              for (i = 0; i < 14; i++) {
   \   000001DC   E080               LDI     R24, 0
   \   000001DE   E090               LDI     R25, 0
   \   000001E0   E00E               LDI     R16, 14
    504                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.TargetSetup1[UART[ch].pRxBuffer[pointer]][i] ;
   \                     ??BuildMData485_0:
   \   000001E2   ....               LDI     R20, LOW((TData + 59))
   \   000001E4   ....               LDI     R21, HIGH((TData + 59))
   \   000001E6   0F48               ADD     R20, R24
   \   000001E8   1F59               ADC     R21, R25
   \   000001EA   85A2               LDD     R26, Z+10
   \   000001EC   85B3               LDD     R27, Z+11
   \   000001EE   0FA2               ADD     R26, R18
   \   000001F0   1FB3               ADC     R27, R19
   \   000001F2   911C               LD      R17, X
   \   000001F4   E06E               LDI     R22, 14
   \   000001F6   9F16               MUL     R17, R22
   \   000001F8   0D40               ADD     R20, R0
   \   000001FA   1D51               ADC     R21, R1
   \   000001FC   01DA               MOVW    R27:R26, R21:R20
   \   000001FE   911C               LD      R17, X
   \   00000200   81A0               LD      R26, Z
   \   00000202   81B1               LDD     R27, Z+1
   \   00000204   8142               LDD     R20, Z+2
   \   00000206   8153               LDD     R21, Z+3
   \   00000208   0FA4               ADD     R26, R20
   \   0000020A   1FB5               ADC     R27, R21
   \   0000020C   931C               ST      X, R17
   \   0000020E   8142               LDD     R20, Z+2
   \   00000210   8153               LDD     R21, Z+3
   \   00000212   5F4F               SUBI    R20, 255
   \   00000214   4F5F               SBCI    R21, 255
   \   00000216   8342               STD     Z+2, R20
   \   00000218   8353               STD     Z+3, R21
    505                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.RS4.TargetSetup2[UART[ch].pRxBuffer[pointer]][i] ;
   \   0000021A   ....               LDI     R20, LOW((TData + 171))
   \   0000021C   ....               LDI     R21, HIGH((TData + 171))
   \   0000021E   0F48               ADD     R20, R24
   \   00000220   1F59               ADC     R21, R25
   \   00000222   85A2               LDD     R26, Z+10
   \   00000224   85B3               LDD     R27, Z+11
   \   00000226   0FA2               ADD     R26, R18
   \   00000228   1FB3               ADC     R27, R19
   \   0000022A   911C               LD      R17, X
   \   0000022C   9F16               MUL     R17, R22
   \   0000022E   0D40               ADD     R20, R0
   \   00000230   1D51               ADC     R21, R1
   \   00000232   01DA               MOVW    R27:R26, R21:R20
   \   00000234   911C               LD      R17, X
   \   00000236   81A0               LD      R26, Z
   \   00000238   81B1               LDD     R27, Z+1
   \   0000023A   8142               LDD     R20, Z+2
   \   0000023C   8153               LDD     R21, Z+3
   \   0000023E   0FA4               ADD     R26, R20
   \   00000240   1FB5               ADC     R27, R21
   \   00000242   931C               ST      X, R17
   \   00000244   8142               LDD     R20, Z+2
   \   00000246   8153               LDD     R21, Z+3
   \   00000248   5F4F               SUBI    R20, 255
   \   0000024A   4F5F               SBCI    R21, 255
   \   0000024C   8342               STD     Z+2, R20
   \   0000024E   8353               STD     Z+3, R21
    506                  *((float*)&UART[ch].pTxBuffer[UART[ch].TxFirst]) = *((float*)&TData.RS4.Result[UART[ch].pRxBuffer[pointer]][i]) ;   // ADresult
   \   00000250   ....               LDI     R20, LOW((TData + 731))
   \   00000252   ....               LDI     R21, HIGH((TData + 731))
   \   00000254   01BC               MOVW    R23:R22, R25:R24
   \   00000256   0F66               LSL     R22
   \   00000258   1F77               ROL     R23
   \   0000025A   0F66               LSL     R22
   \   0000025C   1F77               ROL     R23
   \   0000025E   0F46               ADD     R20, R22
   \   00000260   1F57               ADC     R21, R23
   \   00000262   85A2               LDD     R26, Z+10
   \   00000264   85B3               LDD     R27, Z+11
   \   00000266   0FA2               ADD     R26, R18
   \   00000268   1FB3               ADC     R27, R19
   \   0000026A   911C               LD      R17, X
   \   0000026C   E368               LDI     R22, 56
   \   0000026E   9F16               MUL     R17, R22
   \   00000270   0D40               ADD     R20, R0
   \   00000272   1D51               ADC     R21, R1
   \   00000274   01DA               MOVW    R27:R26, R21:R20
   \   00000276   914D               LD      R20, X+
   \   00000278   915D               LD      R21, X+
   \   0000027A   916D               LD      R22, X+
   \   0000027C   917C               LD      R23, X
   \   0000027E   81A0               LD      R26, Z
   \   00000280   81B1               LDD     R27, Z+1
   \   00000282   8002               LDD     R0, Z+2
   \   00000284   8013               LDD     R1, Z+3
   \   00000286   0DA0               ADD     R26, R0
   \   00000288   1DB1               ADC     R27, R1
   \   0000028A   934D               ST      X+, R20
   \   0000028C   935D               ST      X+, R21
   \   0000028E   936D               ST      X+, R22
   \   00000290   937C               ST      X, R23
    507                  UART[ch].TxFirst += sizeof(float) ;
   \   00000292   8142               LDD     R20, Z+2
   \   00000294   8153               LDD     R21, Z+3
   \   00000296   5F4C               SUBI    R20, 252
   \   00000298   4F5F               SBCI    R21, 255
   \   0000029A   8342               STD     Z+2, R20
   \   0000029C   8353               STD     Z+3, R21
    508              }
   \   0000029E   9601               ADIW    R25:R24, 1
   \   000002A0   950A               DEC     R16
   \   000002A2   F009               BREQ    $+2+2
   \   000002A4   CF9E               RJMP    ??BuildMData485_0
    509          
    510              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   000002A6   8102               LDD     R16, Z+2
   \   000002A8   1902               SUB     R16, R2
   \   000002AA   5002               SUBI    R16, 2
   \   000002AC   81A0               LD      R26, Z
   \   000002AE   81B1               LDD     R27, Z+1
   \   000002B0   0DA2               ADD     R26, R2
   \   000002B2   1DB3               ADC     R27, R3
   \   000002B4   930C               ST      X, R16
    511              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   000002B6   8182               LDD     R24, Z+2
   \   000002B8   8193               LDD     R25, Z+3
   \   000002BA   1982               SUB     R24, R2
   \   000002BC   0993               SBC     R25, R3
   \   000002BE   9702               SBIW    R25:R24, 2
   \   000002C0   8100               LD      R16, Z
   \   000002C2   8111               LDD     R17, Z+1
   \   000002C4   0D02               ADD     R16, R2
   \   000002C6   1D13               ADC     R17, R3
   \   000002C8   01F8               MOVW    R31:R30, R17:R16
   \   000002CA   8391               STD     Z+1, R25
    512          
    513          }
   \   000002CC                      REQUIRE ?Subroutine3
   \   000002CC                      ;               // Fall through to label ?Subroutine3
    514          
    515          /*************************************************************************
    516          *
    517          * Build datablock of raw and cal data for ADcard
    518          *
    519          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    520          void BuildRData485(char ch, short pointer) {
   \                     BuildRData485:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C                      REQUIRE __RSTACK_in_external_ram_new_way
    521          
    522              short ntna, i ;
    523              UART[ch].RxSendReply = true ;                               // flag for answering
   \   0000000C   E11A               LDI     R17, 26
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E001               LDI     R16, 1
   \   0000001C   8F01               STD     Z+25, R16
    524          
    525              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_RDATA & 0xff;
   \   0000001E   8100               LD      R16, Z
   \   00000020   8111               LDD     R17, Z+1
   \   00000022   8142               LDD     R20, Z+2
   \   00000024   8153               LDD     R21, Z+3
   \   00000026   0F04               ADD     R16, R20
   \   00000028   1F15               ADC     R17, R21
   \   0000002A   01F8               MOVW    R31:R30, R17:R16
   \   0000002C   E706               LDI     R16, 118
   \   0000002E   8300               ST      Z, R16
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8102               LDD     R16, Z+2
   \   00000034   8113               LDD     R17, Z+3
   \   00000036   5F0F               SUBI    R16, 255
   \   00000038   4F1F               SBCI    R17, 255
   \   0000003A   8302               STD     Z+2, R16
   \   0000003C   8313               STD     Z+3, R17
    526              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_RS4_RDATA >> 8;
   \   0000003E   8100               LD      R16, Z
   \   00000040   8111               LDD     R17, Z+1
   \   00000042   8142               LDD     R20, Z+2
   \   00000044   8153               LDD     R21, Z+3
   \   00000046   0F04               ADD     R16, R20
   \   00000048   1F15               ADC     R17, R21
   \   0000004A   01F8               MOVW    R31:R30, R17:R16
   \   0000004C   E004               LDI     R16, 4
   \   0000004E   8300               ST      Z, R16
   \   00000050   01FD               MOVW    R31:R30, R27:R26
   \   00000052   8102               LDD     R16, Z+2
   \   00000054   8113               LDD     R17, Z+3
   \   00000056   5F0F               SUBI    R16, 255
   \   00000058   4F1F               SBCI    R17, 255
   \   0000005A   8302               STD     Z+2, R16
   \   0000005C   8313               STD     Z+3, R17
    527              ntna = UART[ch].TxFirst ;                                    /* remember index */
    528              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000005E   01A8               MOVW    R21:R20, R17:R16
   \   00000060   5F4E               SUBI    R20, 254
   \   00000062   4F5F               SBCI    R21, 255
   \   00000064   8342               STD     Z+2, R20
   \   00000066   8353               STD     Z+3, R21
    529          
    530              UART[ch].pTxBuffer[UART[ch].TxFirst++] = UART[ch].pRxBuffer[pointer] ;
   \   00000068   8542               LDD     R20, Z+10
   \   0000006A   8553               LDD     R21, Z+11
   \   0000006C   0F42               ADD     R20, R18
   \   0000006E   1F53               ADC     R21, R19
   \   00000070   01FA               MOVW    R31:R30, R21:R20
   \   00000072   8160               LD      R22, Z
   \   00000074   914D               LD      R20, X+
   \   00000076   915C               LD      R21, X
   \   00000078   9711               SBIW    R27:R26, 1
   \   0000007A   01FD               MOVW    R31:R30, R27:R26
   \   0000007C   8002               LDD     R0, Z+2
   \   0000007E   8013               LDD     R1, Z+3
   \   00000080   0D40               ADD     R20, R0
   \   00000082   1D51               ADC     R21, R1
   \   00000084   01FA               MOVW    R31:R30, R21:R20
   \   00000086   8360               ST      Z, R22
   \   00000088   01FD               MOVW    R31:R30, R27:R26
   \   0000008A   8142               LDD     R20, Z+2
   \   0000008C   8153               LDD     R21, Z+3
   \   0000008E   5F4F               SUBI    R20, 255
   \   00000090   4F5F               SBCI    R21, 255
   \   00000092   8342               STD     Z+2, R20
   \   00000094   8353               STD     Z+3, R21
    531              for (i = 0; i < 14; i++) {
   \   00000096   E080               LDI     R24, 0
   \   00000098   E090               LDI     R25, 0
   \   0000009A   E04E               LDI     R20, 14
    532                  *((short*)&UART[ch].pTxBuffer[UART[ch].TxFirst]) = *((short*)&TData.RS4.Raw[UART[ch].pRxBuffer[pointer]][i]) ;   // Raw data
   \                     ??BuildRData485_0:
   \   0000009C   011C               MOVW    R3:R2, R25:R24
   \   0000009E   0C22               LSL     R2
   \   000000A0   1C33               ROL     R3
   \   000000A2   ....               LDI     R22, LOW((TData + 283))
   \   000000A4   ....               LDI     R23, HIGH((TData + 283))
   \   000000A6   0D62               ADD     R22, R2
   \   000000A8   1D73               ADC     R23, R3
   \   000000AA   8402               LDD     R0, Z+10
   \   000000AC   8413               LDD     R1, Z+11
   \   000000AE   0E02               ADD     R0, R18
   \   000000B0   1E13               ADC     R1, R19
   \   000000B2   01F0               MOVW    R31:R30, R1:R0
   \   000000B4   8000               LD      R0, Z
   \   000000B6   E15C               LDI     R21, 28
   \   000000B8   9E05               MUL     R0, R21
   \   000000BA   0D60               ADD     R22, R0
   \   000000BC   1D71               ADC     R23, R1
   \   000000BE   01FB               MOVW    R31:R30, R23:R22
   \   000000C0   8000               LD      R0, Z
   \   000000C2   8011               LDD     R1, Z+1
   \   000000C4   01FD               MOVW    R31:R30, R27:R26
   \   000000C6   8160               LD      R22, Z
   \   000000C8   8171               LDD     R23, Z+1
   \   000000CA   8042               LDD     R4, Z+2
   \   000000CC   8053               LDD     R5, Z+3
   \   000000CE   0D64               ADD     R22, R4
   \   000000D0   1D75               ADC     R23, R5
   \   000000D2   01FB               MOVW    R31:R30, R23:R22
   \   000000D4   8200               ST      Z, R0
   \   000000D6   8211               STD     Z+1, R1
    533                  UART[ch].TxFirst += sizeof(short) ;
   \   000000D8   01FD               MOVW    R31:R30, R27:R26
   \   000000DA   8162               LDD     R22, Z+2
   \   000000DC   8173               LDD     R23, Z+3
   \   000000DE   5F6E               SUBI    R22, 254
   \   000000E0   4F7F               SBCI    R23, 255
   \   000000E2   8362               STD     Z+2, R22
   \   000000E4   8373               STD     Z+3, R23
    534                  *((short*)&UART[ch].pTxBuffer[UART[ch].TxFirst]) = *((short*)&TData.RS4.Cal[UART[ch].pRxBuffer[pointer]][i]) ;   // Cal data
   \   000000E6   ....               LDI     R22, LOW((TData + 507))
   \   000000E8   ....               LDI     R23, HIGH((TData + 507))
   \   000000EA   0D62               ADD     R22, R2
   \   000000EC   1D73               ADC     R23, R3
   \   000000EE   8402               LDD     R0, Z+10
   \   000000F0   8413               LDD     R1, Z+11
   \   000000F2   0E02               ADD     R0, R18
   \   000000F4   1E13               ADC     R1, R19
   \   000000F6   01F0               MOVW    R31:R30, R1:R0
   \   000000F8   8150               LD      R21, Z
   \   000000FA   E1EC               LDI     R30, 28
   \   000000FC   9F5E               MUL     R21, R30
   \   000000FE   0D60               ADD     R22, R0
   \   00000100   1D71               ADC     R23, R1
   \   00000102   01FB               MOVW    R31:R30, R23:R22
   \   00000104   8000               LD      R0, Z
   \   00000106   8011               LDD     R1, Z+1
   \   00000108   01FD               MOVW    R31:R30, R27:R26
   \   0000010A   8160               LD      R22, Z
   \   0000010C   8171               LDD     R23, Z+1
   \   0000010E   8022               LDD     R2, Z+2
   \   00000110   8033               LDD     R3, Z+3
   \   00000112   0D62               ADD     R22, R2
   \   00000114   1D73               ADC     R23, R3
   \   00000116   01FB               MOVW    R31:R30, R23:R22
   \   00000118   8200               ST      Z, R0
   \   0000011A   8211               STD     Z+1, R1
    535                  UART[ch].TxFirst += sizeof(short) ;
   \   0000011C   01FD               MOVW    R31:R30, R27:R26
   \   0000011E   8162               LDD     R22, Z+2
   \   00000120   8173               LDD     R23, Z+3
   \   00000122   5F6E               SUBI    R22, 254
   \   00000124   4F7F               SBCI    R23, 255
   \   00000126   8362               STD     Z+2, R22
   \   00000128   8373               STD     Z+3, R23
    536              }
   \   0000012A   9601               ADIW    R25:R24, 1
   \   0000012C   954A               DEC     R20
   \   0000012E   F009               BREQ    $+2+2
   \   00000130   CFB5               RJMP    ??BuildRData485_0
    537          
    538              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   00000132   8122               LDD     R18, Z+2
   \   00000134   1B20               SUB     R18, R16
   \   00000136   5022               SUBI    R18, 2
   \   00000138   91ED               LD      R30, X+
   \   0000013A   91FC               LD      R31, X
   \   0000013C   9711               SBIW    R27:R26, 1
   \   0000013E   0FE0               ADD     R30, R16
   \   00000140   1FF1               ADC     R31, R17
   \   00000142   8320               ST      Z, R18
    539              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   00000144   01FD               MOVW    R31:R30, R27:R26
   \   00000146   8182               LDD     R24, Z+2
   \   00000148   8193               LDD     R25, Z+3
   \   0000014A   1B80               SUB     R24, R16
   \   0000014C   0B91               SBC     R25, R17
   \   0000014E   9702               SBIW    R25:R24, 2
   \   00000150   91ED               LD      R30, X+
   \   00000152   91FC               LD      R31, X
   \   00000154   0FE0               ADD     R30, R16
   \   00000156   1FF1               ADC     R31, R17
   \   00000158   ....               RJMP    ?Subroutine1
    540          
    541          }
    542          
    543          /*************************************************************************
    544          *
    545          * Build setup data package for AN-ZBANA
    546          *
    547          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    548          void BuildANASetup(char ch, short pointer) {
   \                     BuildANASetup:
   \   00000000   2F7B               MOV     R23, R27
   \   00000002   2E2A               MOV     R2, R26
   \   00000004   2F59               MOV     R21, R25
   \   00000006   2F68               MOV     R22, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    549          
    550              short ntna ;
    551              UART[ch].RxSendReply = true ;                               // flag for answering
   \   00000008   E11A               LDI     R17, 26
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E001               LDI     R16, 1
   \   00000016   8F01               STD     Z+25, R16
    552          
    553              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_SETUP & 0xff;
   \   00000018   81A0               LD      R26, Z
   \   0000001A   81B1               LDD     R27, Z+1
   \   0000001C   8102               LDD     R16, Z+2
   \   0000001E   8113               LDD     R17, Z+3
   \   00000020   0FA0               ADD     R26, R16
   \   00000022   1FB1               ADC     R27, R17
   \   00000024   EB0B               LDI     R16, 187
   \   00000026   930C               ST      X, R16
   \   00000028   8102               LDD     R16, Z+2
   \   0000002A   8113               LDD     R17, Z+3
   \   0000002C   5F0F               SUBI    R16, 255
   \   0000002E   4F1F               SBCI    R17, 255
   \   00000030   8302               STD     Z+2, R16
   \   00000032   8313               STD     Z+3, R17
    554              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_SETUP >> 8;
   \   00000034   81A0               LD      R26, Z
   \   00000036   81B1               LDD     R27, Z+1
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   E004               LDI     R16, 4
   \   0000003E   930C               ST      X, R16
   \   00000040   8102               LDD     R16, Z+2
   \   00000042   8113               LDD     R17, Z+3
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   8302               STD     Z+2, R16
   \   0000004A   8313               STD     Z+3, R17
    555              ntna = UART[ch].TxFirst ;                                    /* remember index */
    556              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000004C   0198               MOVW    R19:R18, R17:R16
   \   0000004E   5F2E               SUBI    R18, 254
   \   00000050   4F3F               SBCI    R19, 255
   \   00000052   8322               STD     Z+2, R18
   \   00000054   8333               STD     Z+3, R19
    557          
    558              UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.Ana.PortUsed & 0xff;
   \   00000056   9120....           LDS     R18, TData
   \   0000005A   81A0               LD      R26, Z
   \   0000005C   81B1               LDD     R27, Z+1
   \   0000005E   8142               LDD     R20, Z+2
   \   00000060   0FA4               ADD     R26, R20
   \   00000062   1FB3               ADC     R27, R19
   \   00000064   932C               ST      X, R18
   \   00000066   8122               LDD     R18, Z+2
   \   00000068   8133               LDD     R19, Z+3
   \   0000006A   5F2F               SUBI    R18, 255
   \   0000006C   4F3F               SBCI    R19, 255
   \   0000006E   8322               STD     Z+2, R18
   \   00000070   8333               STD     Z+3, R19
    559              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.Ana.PortUsed >> 8) & 0xff;
   \   00000072   9120....           LDS     R18, (TData + 1)
   \   00000076                      REQUIRE ?Subroutine0
   \   00000076                      ;               // Fall through to label ?Subroutine0
    560          
    561              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
    562              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
    563          }
    564          
    565          /*************************************************************************
    566          *
    567          * Build filter data package for AN-ZBANA
    568          *
    569          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    570          void BuildANAFilter(char ch, short pointer) {
   \                     BuildANAFilter:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F59               MOV     R21, R25
   \   00000006   2E28               MOV     R2, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    571          
    572              char port;
    573              short ntna ;
    574              UART[ch].RxSendReply = true ;                               // flag for answering
   \   00000008   E11A               LDI     R17, 26
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E001               LDI     R16, 1
   \   00000016   8F01               STD     Z+25, R16
    575          
    576              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_FILTER & 0xff;
   \   00000018   81A0               LD      R26, Z
   \   0000001A   81B1               LDD     R27, Z+1
   \   0000001C   8102               LDD     R16, Z+2
   \   0000001E   8113               LDD     R17, Z+3
   \   00000020   0FA0               ADD     R26, R16
   \   00000022   1FB1               ADC     R27, R17
   \   00000024   EC0F               LDI     R16, 207
   \   00000026   930C               ST      X, R16
   \   00000028   8102               LDD     R16, Z+2
   \   0000002A   8113               LDD     R17, Z+3
   \   0000002C   5F0F               SUBI    R16, 255
   \   0000002E   4F1F               SBCI    R17, 255
   \   00000030   8302               STD     Z+2, R16
   \   00000032   8313               STD     Z+3, R17
    577              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_FILTER >> 8;
   \   00000034   81A0               LD      R26, Z
   \   00000036   81B1               LDD     R27, Z+1
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   E004               LDI     R16, 4
   \   0000003E   930C               ST      X, R16
   \   00000040   8102               LDD     R16, Z+2
   \   00000042   8113               LDD     R17, Z+3
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   8302               STD     Z+2, R16
   \   0000004A   8313               STD     Z+3, R17
    578              ntna = UART[ch].TxFirst ;                                    /* remember index */
   \   0000004C   01B8               MOVW    R23:R22, R17:R16
    579              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000004E   5F0E               SUBI    R16, 254
   \   00000050   4F1F               SBCI    R17, 255
   \   00000052   8302               STD     Z+2, R16
   \   00000054   8313               STD     Z+3, R17
    580          
    581              for (port = 0; port < 12; port++) {
   \   00000056   ....               LDI     R16, LOW((TData + 2))
   \   00000058   ....               LDI     R17, HIGH((TData + 2))
   \   0000005A   E04C               LDI     R20, 12
    582                  #if USE_MODBUS_PROTOCOL == 1
    583                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (char)TData.Ana.Filter[port];
    584                  #else
    585                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.Ana.Filter[port];
   \                     ??BuildANAFilter_0:
   \   0000005C   01D8               MOVW    R27:R26, R17:R16
   \   0000005E   912D               LD      R18, X+
   \   00000060   018D               MOVW    R17:R16, R27:R26
   \   00000062   81A0               LD      R26, Z
   \   00000064   81B1               LDD     R27, Z+1
   \   00000066   8002               LDD     R0, Z+2
   \   00000068   8013               LDD     R1, Z+3
   \   0000006A   0DA0               ADD     R26, R0
   \   0000006C   1DB1               ADC     R27, R1
   \   0000006E   932C               ST      X, R18
   \   00000070   8122               LDD     R18, Z+2
   \   00000072   8133               LDD     R19, Z+3
   \   00000074   5F2F               SUBI    R18, 255
   \   00000076   4F3F               SBCI    R19, 255
   \   00000078   8322               STD     Z+2, R18
   \   0000007A   8333               STD     Z+3, R19
    586                  #endif
    587              }
   \   0000007C   954A               DEC     R20
   \   0000007E   F771               BRNE    ??BuildANAFilter_0
    588          
    589              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   00000080   8102               LDD     R16, Z+2
   \   00000082   1B06               SUB     R16, R22
   \   00000084   5002               SUBI    R16, 2
   \   00000086   81A0               LD      R26, Z
   \   00000088   81B1               LDD     R27, Z+1
   \   0000008A   0FA6               ADD     R26, R22
   \   0000008C   1FB7               ADC     R27, R23
   \   0000008E   930C               ST      X, R16
    590              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   00000090   8182               LDD     R24, Z+2
   \   00000092   8193               LDD     R25, Z+3
   \   00000094   1B86               SUB     R24, R22
   \   00000096   0B97               SBC     R25, R23
   \   00000098   9702               SBIW    R25:R24, 2
   \   0000009A   8100               LD      R16, Z
   \   0000009C   8111               LDD     R17, Z+1
   \   0000009E   0F06               ADD     R16, R22
   \   000000A0   1F17               ADC     R17, R23
   \   000000A2                      REQUIRE ?Subroutine2
   \   000000A2                      ;               // Fall through to label ?Subroutine2
    591          }
    592          
    593          /*************************************************************************
    594          *
    595          * Build datablock for External AD (ANA)
    596          *
    597          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    598          void BuildMDataANA(char ch, short pointer) {
   \                     BuildMDataANA:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C                      REQUIRE __RSTACK_in_external_ram_new_way
    599          
    600              short ntna, i ;
    601              UART[ch].RxSendReply = true ;                               // flag for answering
   \   0000000C   E11A               LDI     R17, 26
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   2D00               MOV     R16, R0
   \   00000012   ....               LDI     R18, LOW(UART)
   \   00000014   2E02               MOV     R0, R18
   \   00000016   ....               LDI     R18, (UART) >> 8
   \   00000018   0E00               ADD     R0, R16
   \   0000001A   1E12               ADC     R1, R18
   \   0000001C   01F0               MOVW    R31:R30, R1:R0
   \   0000001E   E001               LDI     R16, 1
   \   00000020   8F01               STD     Z+25, R16
    602          
    603              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_MDATA & 0xff;
   \   00000022   8100               LD      R16, Z
   \   00000024   8111               LDD     R17, Z+1
   \   00000026   8122               LDD     R18, Z+2
   \   00000028   8133               LDD     R19, Z+3
   \   0000002A   0F02               ADD     R16, R18
   \   0000002C   1F13               ADC     R17, R19
   \   0000002E   01F8               MOVW    R31:R30, R17:R16
   \   00000030   ED09               LDI     R16, 217
   \   00000032   8300               ST      Z, R16
   \   00000034   01F0               MOVW    R31:R30, R1:R0
   \   00000036   8102               LDD     R16, Z+2
   \   00000038   8113               LDD     R17, Z+3
   \   0000003A   5F0F               SUBI    R16, 255
   \   0000003C   4F1F               SBCI    R17, 255
   \   0000003E   8302               STD     Z+2, R16
   \   00000040   8313               STD     Z+3, R17
    604              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_ANA_MDATA >> 8;
   \   00000042   8100               LD      R16, Z
   \   00000044   8111               LDD     R17, Z+1
   \   00000046   8122               LDD     R18, Z+2
   \   00000048   8133               LDD     R19, Z+3
   \   0000004A   0F02               ADD     R16, R18
   \   0000004C   1F13               ADC     R17, R19
   \   0000004E   01F8               MOVW    R31:R30, R17:R16
   \   00000050   E004               LDI     R16, 4
   \   00000052   8300               ST      Z, R16
   \   00000054   01F0               MOVW    R31:R30, R1:R0
   \   00000056   8102               LDD     R16, Z+2
   \   00000058   8113               LDD     R17, Z+3
   \   0000005A   5F0F               SUBI    R16, 255
   \   0000005C   4F1F               SBCI    R17, 255
   \   0000005E   8302               STD     Z+2, R16
   \   00000060   8313               STD     Z+3, R17
    605              ntna = UART[ch].TxFirst ;                                    /* remember index */
   \   00000062   0198               MOVW    R19:R18, R17:R16
    606              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   00000064   5F0E               SUBI    R16, 254
   \   00000066   4F1F               SBCI    R17, 255
   \   00000068   8302               STD     Z+2, R16
   \   0000006A   8313               STD     Z+3, R17
    607          
    608              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (RestartStatus << 4) ;    // Add restart status
   \   0000006C   9140....           LDS     R20, RestartStatus
   \   00000070   9542               SWAP    R20
   \   00000072   7F40               ANDI    R20, 0xF0
   \   00000074   8100               LD      R16, Z
   \   00000076   8111               LDD     R17, Z+1
   \   00000078   8162               LDD     R22, Z+2
   \   0000007A   8173               LDD     R23, Z+3
   \   0000007C   0F06               ADD     R16, R22
   \   0000007E   1F17               ADC     R17, R23
   \   00000080   01F8               MOVW    R31:R30, R17:R16
   \   00000082   8340               ST      Z, R20
   \   00000084   01F0               MOVW    R31:R30, R1:R0
   \   00000086   8102               LDD     R16, Z+2
   \   00000088   8113               LDD     R17, Z+3
   \   0000008A   5F0F               SUBI    R16, 255
   \   0000008C   4F1F               SBCI    R17, 255
   \   0000008E   8302               STD     Z+2, R16
   \   00000090   8313               STD     Z+3, R17
    609              for (i = 0; i<12; i++) {
   \   00000092   ....               LDI     R30, LOW((TData + 14))
   \   00000094   ....               LDI     R31, HIGH((TData + 14))
   \   00000096   ....               LDI     R24, LOW((TData + 26))
   \   00000098   ....               LDI     R25, HIGH((TData + 26))
   \   0000009A   E00C               LDI     R16, 12
    610                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.Ana.Status[i] ;
   \                     ??BuildMDataANA_0:
   \   0000009C   9111               LD      R17, Z+
   \   0000009E   01D0               MOVW    R27:R26, R1:R0
   \   000000A0   914D               LD      R20, X+
   \   000000A2   915C               LD      R21, X
   \   000000A4   01D0               MOVW    R27:R26, R1:R0
   \   000000A6   9612               ADIW    R27:R26, 2
   \   000000A8   916D               LD      R22, X+
   \   000000AA   917C               LD      R23, X
   \   000000AC   0F46               ADD     R20, R22
   \   000000AE   1F57               ADC     R21, R23
   \   000000B0   01DA               MOVW    R27:R26, R21:R20
   \   000000B2   931C               ST      X, R17
   \   000000B4   01D0               MOVW    R27:R26, R1:R0
   \   000000B6   9612               ADIW    R27:R26, 2
   \   000000B8   914D               LD      R20, X+
   \   000000BA   915C               LD      R21, X
   \   000000BC   5F4F               SUBI    R20, 255
   \   000000BE   4F5F               SBCI    R21, 255
   \   000000C0   935C               ST      X, R21
   \   000000C2   934E               ST      -X, R20
    611                  *((float*)&UART[ch].pTxBuffer[UART[ch].TxFirst]) = *((float*)&TData.Ana.Result[i]) ;   // ADresult
   \   000000C4   01DC               MOVW    R27:R26, R25:R24
   \   000000C6   914D               LD      R20, X+
   \   000000C8   915D               LD      R21, X+
   \   000000CA   916D               LD      R22, X+
   \   000000CC   917D               LD      R23, X+
   \   000000CE   01CD               MOVW    R25:R24, R27:R26
   \   000000D0   01D0               MOVW    R27:R26, R1:R0
   \   000000D2   902D               LD      R2, X+
   \   000000D4   903C               LD      R3, X
   \   000000D6   01D0               MOVW    R27:R26, R1:R0
   \   000000D8   9612               ADIW    R27:R26, 2
   \   000000DA   904D               LD      R4, X+
   \   000000DC   905C               LD      R5, X
   \   000000DE   0C24               ADD     R2, R4
   \   000000E0   1C35               ADC     R3, R5
   \   000000E2   01D1               MOVW    R27:R26, R3:R2
   \   000000E4   934D               ST      X+, R20
   \   000000E6   935D               ST      X+, R21
   \   000000E8   936D               ST      X+, R22
   \   000000EA   937C               ST      X, R23
    612                  UART[ch].TxFirst += sizeof(float) ;
   \   000000EC   01D0               MOVW    R27:R26, R1:R0
   \   000000EE   9612               ADIW    R27:R26, 2
   \   000000F0   914D               LD      R20, X+
   \   000000F2   915C               LD      R21, X
   \   000000F4   5F4C               SUBI    R20, 252
   \   000000F6   4F5F               SBCI    R21, 255
   \   000000F8   935C               ST      X, R21
   \   000000FA   934E               ST      -X, R20
    613              }
   \   000000FC   950A               DEC     R16
   \   000000FE   F671               BRNE    ??BuildMDataANA_0
    614          
    615              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   00000100   01F0               MOVW    R31:R30, R1:R0
   \   00000102   1B42               SUB     R20, R18
   \   00000104   5042               SUBI    R20, 2
   \   00000106   8100               LD      R16, Z
   \   00000108   8111               LDD     R17, Z+1
   \   0000010A   0F02               ADD     R16, R18
   \   0000010C   1F13               ADC     R17, R19
   \   0000010E   01F8               MOVW    R31:R30, R17:R16
   \   00000110   8340               ST      Z, R20
    616              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   00000112   01F0               MOVW    R31:R30, R1:R0
   \   00000114   8182               LDD     R24, Z+2
   \   00000116   8193               LDD     R25, Z+3
   \   00000118   1B82               SUB     R24, R18
   \   0000011A   0B93               SBC     R25, R19
   \   0000011C   9702               SBIW    R25:R24, 2
   \   0000011E   8100               LD      R16, Z
   \   00000120   8111               LDD     R17, Z+1
   \   00000122   0F02               ADD     R16, R18
   \   00000124   1F13               ADC     R17, R19
   \   00000126   01F8               MOVW    R31:R30, R17:R16
   \   00000128   ....               RJMP    ?Subroutine1
    617          
    618          }
    619          
    620          /*************************************************************************
    621          *
    622          * Build datablock for Stack status
    623          *
    624          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    625          void BuildStackStatus(char ch, short pointer) {
   \                     BuildStackStatus:
   \   00000000   01BD               MOVW    R23:R22, R27:R26
   \   00000002   01AC               MOVW    R21:R20, R25:R24
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
    626          
    627              short ntna, stack ;
    628              UART[ch].RxSendReply = true ;                               // flag for answering
   \   00000004   E11A               LDI     R17, 26
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   E001               LDI     R16, 1
   \   00000012   8F01               STD     Z+25, R16
    629          
    630              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STACKSTATUS & 0xff;
   \   00000014   81A0               LD      R26, Z
   \   00000016   81B1               LDD     R27, Z+1
   \   00000018   8102               LDD     R16, Z+2
   \   0000001A   8113               LDD     R17, Z+3
   \   0000001C   0FA0               ADD     R26, R16
   \   0000001E   1FB1               ADC     R27, R17
   \   00000020   E707               LDI     R16, 119
   \   00000022   930C               ST      X, R16
   \   00000024   8102               LDD     R16, Z+2
   \   00000026   8113               LDD     R17, Z+3
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   8302               STD     Z+2, R16
   \   0000002E   8313               STD     Z+3, R17
    631              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STACKSTATUS >> 8;
   \   00000030   81A0               LD      R26, Z
   \   00000032   81B1               LDD     R27, Z+1
   \   00000034   0FA0               ADD     R26, R16
   \   00000036   1FB1               ADC     R27, R17
   \   00000038   E007               LDI     R16, 7
   \   0000003A   930C               ST      X, R16
   \   0000003C   8102               LDD     R16, Z+2
   \   0000003E   8113               LDD     R17, Z+3
   \   00000040   5F0F               SUBI    R16, 255
   \   00000042   4F1F               SBCI    R17, 255
   \   00000044   8302               STD     Z+2, R16
   \   00000046   8313               STD     Z+3, R17
    632              ntna = UART[ch].TxFirst ;                                    /* remember index */
    633              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   00000048   0198               MOVW    R19:R18, R17:R16
   \   0000004A   5F2E               SUBI    R18, 254
   \   0000004C   4F3F               SBCI    R19, 255
   \   0000004E   8322               STD     Z+2, R18
   \   00000050   8333               STD     Z+3, R19
    634          
    635              stack = OS_GetStackSpace(&TCB_USART0);                            // USART 0
    636              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
   \   00000052   81A0               LD      R26, Z
   \   00000054   81B1               LDD     R27, Z+1
   \   00000056   0FA2               ADD     R26, R18
   \   00000058   1FB3               ADC     R27, R19
   \   0000005A   E020               LDI     R18, 0
   \   0000005C   932C               ST      X, R18
   \   0000005E   8122               LDD     R18, Z+2
   \   00000060   8133               LDD     R19, Z+3
   \   00000062   5F2F               SUBI    R18, 255
   \   00000064   4F3F               SBCI    R19, 255
   \   00000066   8322               STD     Z+2, R18
   \   00000068   8333               STD     Z+3, R19
    637              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
   \   0000006A   81A0               LD      R26, Z
   \   0000006C   81B1               LDD     R27, Z+1
   \   0000006E   0FA2               ADD     R26, R18
   \   00000070   1FB3               ADC     R27, R19
   \   00000072   E020               LDI     R18, 0
   \   00000074   932C               ST      X, R18
   \   00000076   8122               LDD     R18, Z+2
   \   00000078   8133               LDD     R19, Z+3
   \   0000007A   5F2F               SUBI    R18, 255
   \   0000007C   4F3F               SBCI    R19, 255
   \   0000007E   8322               STD     Z+2, R18
   \   00000080   8333               STD     Z+3, R19
    638              stack = OS_GetStackSpace(&TCB_USART1);                            // USART 1
    639              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
   \   00000082   81A0               LD      R26, Z
   \   00000084   81B1               LDD     R27, Z+1
   \   00000086   0FA2               ADD     R26, R18
   \   00000088   1FB3               ADC     R27, R19
   \   0000008A   E020               LDI     R18, 0
   \   0000008C   932C               ST      X, R18
   \   0000008E   8122               LDD     R18, Z+2
   \   00000090   8133               LDD     R19, Z+3
   \   00000092   5F2F               SUBI    R18, 255
   \   00000094   4F3F               SBCI    R19, 255
   \   00000096   8322               STD     Z+2, R18
   \   00000098   8333               STD     Z+3, R19
    640              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
   \   0000009A   81A0               LD      R26, Z
   \   0000009C   81B1               LDD     R27, Z+1
   \   0000009E   0FA2               ADD     R26, R18
   \   000000A0   1FB3               ADC     R27, R19
   \   000000A2   E020               LDI     R18, 0
   \   000000A4   932C               ST      X, R18
   \   000000A6   8122               LDD     R18, Z+2
   \   000000A8   8133               LDD     R19, Z+3
   \   000000AA   5F2F               SUBI    R18, 255
   \   000000AC   4F3F               SBCI    R19, 255
   \   000000AE   8322               STD     Z+2, R18
   \   000000B0   8333               STD     Z+3, R19
    641              stack = OS_GetStackSpace(&TCB_WATCHDOG);                            // watchdog
    642              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
   \   000000B2   81A0               LD      R26, Z
   \   000000B4   81B1               LDD     R27, Z+1
   \   000000B6   0FA2               ADD     R26, R18
   \   000000B8   1FB3               ADC     R27, R19
   \   000000BA   E020               LDI     R18, 0
   \   000000BC   932C               ST      X, R18
   \   000000BE   8122               LDD     R18, Z+2
   \   000000C0   8133               LDD     R19, Z+3
   \   000000C2   5F2F               SUBI    R18, 255
   \   000000C4   4F3F               SBCI    R19, 255
   \   000000C6   8322               STD     Z+2, R18
   \   000000C8   8333               STD     Z+3, R19
    643              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
   \   000000CA   81A0               LD      R26, Z
   \   000000CC   81B1               LDD     R27, Z+1
   \   000000CE   0FA2               ADD     R26, R18
   \   000000D0   1FB3               ADC     R27, R19
   \   000000D2   E020               LDI     R18, 0
   \   000000D4   932C               ST      X, R18
   \   000000D6   8122               LDD     R18, Z+2
   \   000000D8   8133               LDD     R19, Z+3
   \   000000DA   5F2F               SUBI    R18, 255
   \   000000DC   4F3F               SBCI    R19, 255
   \   000000DE   8322               STD     Z+2, R18
   \   000000E0   8333               STD     Z+3, R19
    644              switch (UnitID) {
   \   000000E2   9120....           LDS     R18, UnitID
   \   000000E6   2322               TST     R18
   \   000000E8   F011               BREQ    ??BuildStackStatus_0
   \   000000EA   952A               DEC     R18
   \   000000EC   F589               BRNE    ??BuildStackStatus_1
    645              case AN_ZB485 :
    646                  stack = OS_GetStackSpace(&TCB_RS485Ctl);                            // RS485 Control
    647                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
    648                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
    649                  stack = OS_GetStackSpace(&TCB_RS485Rec);                            // RS485 receive
    650                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
    651                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
    652                  break;
    653              case AN_ZBANA :
    654                  stack = OS_GetStackSpace(&TCB_AD7715);                            // AD handling
    655                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
   \                     ??BuildStackStatus_0:
   \   000000EE   81A0               LD      R26, Z
   \   000000F0   81B1               LDD     R27, Z+1
   \   000000F2   8122               LDD     R18, Z+2
   \   000000F4   0FA2               ADD     R26, R18
   \   000000F6   1FB3               ADC     R27, R19
   \   000000F8   E020               LDI     R18, 0
   \   000000FA   932C               ST      X, R18
   \   000000FC   8122               LDD     R18, Z+2
   \   000000FE   8133               LDD     R19, Z+3
   \   00000100   5F2F               SUBI    R18, 255
   \   00000102   4F3F               SBCI    R19, 255
   \   00000104   8322               STD     Z+2, R18
   \   00000106   8333               STD     Z+3, R19
    656                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
   \   00000108   81A0               LD      R26, Z
   \   0000010A   81B1               LDD     R27, Z+1
   \   0000010C   0FA2               ADD     R26, R18
   \   0000010E   1FB3               ADC     R27, R19
   \   00000110   E020               LDI     R18, 0
   \   00000112   932C               ST      X, R18
   \   00000114   8122               LDD     R18, Z+2
   \   00000116   8133               LDD     R19, Z+3
   \   00000118   5F2F               SUBI    R18, 255
   \   0000011A   4F3F               SBCI    R19, 255
   \   0000011C   8322               STD     Z+2, R18
   \   0000011E   8333               STD     Z+3, R19
    657                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0 ;
   \   00000120   81A0               LD      R26, Z
   \   00000122   81B1               LDD     R27, Z+1
   \   00000124   0FA2               ADD     R26, R18
   \   00000126   1FB3               ADC     R27, R19
   \   00000128   E020               LDI     R18, 0
   \   0000012A   932C               ST      X, R18
   \   0000012C   8122               LDD     R18, Z+2
   \   0000012E   8133               LDD     R19, Z+3
   \   00000130   5F2F               SUBI    R18, 255
   \   00000132   4F3F               SBCI    R19, 255
   \   00000134   8322               STD     Z+2, R18
   \   00000136   8333               STD     Z+3, R19
    658                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0 ;
   \   00000138   81A0               LD      R26, Z
   \   0000013A   81B1               LDD     R27, Z+1
   \   0000013C   0FA2               ADD     R26, R18
   \   0000013E   1FB3               ADC     R27, R19
   \   00000140   E020               LDI     R18, 0
   \   00000142   932C               ST      X, R18
   \   00000144   8122               LDD     R18, Z+2
   \   00000146   8133               LDD     R19, Z+3
   \   00000148   5F2F               SUBI    R18, 255
   \   0000014A   4F3F               SBCI    R19, 255
   \   0000014C   8322               STD     Z+2, R18
   \   0000014E   8333               STD     Z+3, R19
    659                  break;
    660              }
    661          
    662              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \                     ??BuildStackStatus_1:
   \   00000150   8122               LDD     R18, Z+2
   \   00000152   1B20               SUB     R18, R16
   \   00000154   5022               SUBI    R18, 2
   \   00000156   81A0               LD      R26, Z
   \   00000158   81B1               LDD     R27, Z+1
   \   0000015A   0FA0               ADD     R26, R16
   \   0000015C   1FB1               ADC     R27, R17
   \   0000015E   932C               ST      X, R18
    663              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   00000160   8182               LDD     R24, Z+2
   \   00000162   8193               LDD     R25, Z+3
   \   00000164   1B80               SUB     R24, R16
   \   00000166   0B91               SBC     R25, R17
   \   00000168   9702               SBIW    R25:R24, 2
   \   0000016A   8120               LD      R18, Z
   \   0000016C   8131               LDD     R19, Z+1
   \   0000016E   0F20               ADD     R18, R16
   \   00000170   1F31               ADC     R19, R17
   \   00000172   01F9               MOVW    R31:R30, R19:R18
   \   00000174   8391               STD     Z+1, R25
    664          
    665          }
   \   00000176   01CA               MOVW    R25:R24, R21:R20
   \   00000178   01DB               MOVW    R27:R26, R23:R22
   \   0000017A   9508               RET
    666          
    667          //////////////////////////////////////////////////////////////////////////////
    668          // Receiving data to IO module here
    669          /////////////////////////////////////////////////////////////////////////////
    670          
    671          /*************************************************************************
    672          *
    673          * Receive Command to Reset the EEPROM
    674          *
    675          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    676          void GetResetEEPROM(char ch, short pointer) {
   \                     GetResetEEPROM:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    677          
    678              EEPROMReset();
   \   00000000   ........           JMP     EEPROMReset
    679          }
    680          
    681          
    682          /*************************************************************************
    683          *
    684          * Receive Command to go to the bootloader program
    685          *
    686          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    687          void GetGotoBootloader(char ch, short pointer) {
   \                     GetGotoBootloader:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    688          
    689          //    void (*BootApp)(void) = (void(*)())0xF000;
    690          
    691              // 128 -> 1281
    692              /*
    693              while ( (EECR & 1<<EEWE) != 0 ) //chech if EEPROM is ready
    694                  ;
    695              EEARL = (0x0fff & 0xff);
    696              EEARH = (0x0fff >> 8);
    697              EEDR = 0xff;
    698              EECR |= (1<<EEMWE);
    699              EECR |= (1<<EEWE);
    700              while (EECR & (1<<EEWE))
    701                  ;
    702              */
    703              while ( (EECR & 1<<EEPE) != 0 ) //chech if EEPROM is ready
   \                     ??GetGotoBootloader_0:
   \   00000000   99F9               SBIC    0x1F, 0x01
   \   00000002   CFFE               RJMP    ??GetGotoBootloader_0
    704                  ;
    705              EEARL = (0x0fff & 0xff);
   \   00000004   EF0F               LDI     R16, 255
   \   00000006   BD01               OUT     0x21, R16
    706              EEARH = (0x0fff >> 8);
   \   00000008   E00F               LDI     R16, 15
   \   0000000A   BD02               OUT     0x22, R16
    707              EEDR = 0xff;
   \   0000000C   EF0F               LDI     R16, 255
   \   0000000E   BD00               OUT     0x20, R16
    708              EECR |= (1<<EEMPE);
   \   00000010   9AFA               SBI     0x1F, 0x02
    709              EECR |= (1<<EEPE);
   \   00000012   9AF9               SBI     0x1F, 0x01
   \   00000014   E108               LDI     R16, 24
   \   00000016   C002               RJMP    ??GetGotoBootloader_1
    710              while (EECR & (1<<EEPE))
    711          
    712              // 128 -> 1281
    713              // WDTCR = 0x18;               //Start watchdog to genetate restart
    714              // WDTCR = 0x08;               //Start watchdog to genetate restart
    715              WDTCSR = 0x18;               //Start watchdog to genetate restart
   \                     ??GetGotoBootloader_2:
   \   00000018   9300....           STS     _A_WDTCSR, R16
   \                     ??GetGotoBootloader_1:
   \   0000001C   99F9               SBIC    0x1F, 0x01
   \   0000001E   CFFC               RJMP    ??GetGotoBootloader_2
    716              WDTCSR = 0x08;               //Start watchdog to genetate restart
   \   00000020   E008               LDI     R16, 8
   \   00000022   9300....           STS     _A_WDTCSR, R16
    717          }
   \   00000026   9508               RET
   \   00000028                      REQUIRE _A_EECR
   \   00000028                      REQUIRE _A_EEAR
   \   00000028                      REQUIRE _A_EEDR
   \   00000028                      REQUIRE _A_WDTCSR
    718          
    719          /*************************************************************************
    720          *
    721          * Receive EEPROM data
    722          *
    723          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    724          void GetEEPROMData(char ch, short pointer) {
   \                     GetEEPROMData:
   \   00000000   929A               ST      -Y, R9
   \   00000002   928A               ST      -Y, R8
   \   00000004   925A               ST      -Y, R5
   \   00000006   924A               ST      -Y, R4
   \   00000008   93BA               ST      -Y, R27
   \   0000000A   93AA               ST      -Y, R26
   \   0000000C   939A               ST      -Y, R25
   \   0000000E   938A               ST      -Y, R24
   \   00000010                      REQUIRE ?Register_R4_is_cg_reg
   \   00000010                      REQUIRE ?Register_R5_is_cg_reg
   \   00000010                      REQUIRE ?Register_R8_is_cg_reg
   \   00000010                      REQUIRE ?Register_R9_is_cg_reg
   \   00000010                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000010   0149               MOVW    R9:R8, R19:R18
    725          
    726            char channel;
    727            int t0;
    728          
    729              channel = UART[ch].pRxBuffer[pointer] ;
   \   00000012   E11A               LDI     R17, 26
   \   00000014   9F01               MUL     R16, R17
   \   00000016   ....               LDI     R16, LOW(UART)
   \   00000018   2E40               MOV     R4, R16
   \   0000001A   ....               LDI     R16, (UART) >> 8
   \   0000001C   0C40               ADD     R4, R0
   \   0000001E   1D01               ADC     R16, R1
   \   00000020   2E50               MOV     R5, R16
   \   00000022   2DE4               MOV     R30, R4
   \   00000024   2FF0               MOV     R31, R16
   \   00000026   8542               LDD     R20, Z+10
   \   00000028   8553               LDD     R21, Z+11
   \   0000002A   0D48               ADD     R20, R8
   \   0000002C   1D59               ADC     R21, R9
   \   0000002E   01FA               MOVW    R31:R30, R21:R20
   \   00000030   8120               LD      R18, Z
    730              if ((channel >= 0x80) && (UnitID == 0x01)) { // AN-ZBANA
   \   00000032   3820               CPI     R18, 128
   \   00000034   F100               BRCS    ??GetEEPROMData_0
   \   00000036   9100....           LDS     R16, UnitID
   \   0000003A   3001               CPI     R16, 1
   \   0000003C   F4E1               BRNE    ??GetEEPROMData_0
    731                *((float*)&TData.Ana.Offset[channel & 0x0f]) = *((float*)&UART[ch].pRxBuffer[pointer+1]) ;  //offset
   \   0000003E   ....               LDI     R16, LOW((TData + 98))
   \   00000040   ....               LDI     R17, HIGH((TData + 98))
   \   00000042   2F62               MOV     R22, R18
   \   00000044   E070               LDI     R23, 0
   \   00000046   706F               ANDI    R22, 0x0F
   \   00000048   0F66               LSL     R22
   \   0000004A   0F66               LSL     R22
   \   0000004C   0F06               ADD     R16, R22
   \   0000004E   1F17               ADC     R17, R23
   \   00000050   8001               LDD     R0, Z+1
   \   00000052   8012               LDD     R1, Z+2
   \   00000054   8023               LDD     R2, Z+3
   \   00000056   8034               LDD     R3, Z+4
   \   00000058   01F8               MOVW    R31:R30, R17:R16
   \   0000005A   8200               ST      Z, R0
   \   0000005C   8211               STD     Z+1, R1
   \   0000005E   8222               STD     Z+2, R2
   \   00000060   8233               STD     Z+3, R3
    732                *((float*)&TData.Ana.Gain[channel & 0x0f]) = *((float*)&UART[ch].pRxBuffer[pointer+5]) ;  //gain
   \   00000062   01FA               MOVW    R31:R30, R21:R20
   \   00000064   8005               LDD     R0, Z+5
   \   00000066   8016               LDD     R1, Z+6
   \   00000068   8027               LDD     R2, Z+7
   \   0000006A   8430               LDD     R3, Z+8
   \   0000006C   01F8               MOVW    R31:R30, R17:R16
   \   0000006E   AA00               STD     Z+48, R0
   \   00000070   AA11               STD     Z+49, R1
   \   00000072   AA22               STD     Z+50, R2
   \   00000074   AA33               STD     Z+51, R3
    733              }
    734              WriteEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char*)&UART[ch].pRxBuffer[pointer+1]);
   \                     ??GetEEPROMData_0:
   \   00000076   E008               LDI     R16, 8
   \   00000078   9F20               MUL     R18, R16
   \   0000007A   01D0               MOVW    R27:R26, R1:R0
   \   0000007C   5F4F               SUBI    R20, 255
   \   0000007E   4F5F               SBCI    R21, 255
   \   00000080   E024               LDI     R18, 4
   \   00000082   0180               MOVW    R17:R16, R1:R0
   \   00000084   ........           CALL    WriteEEPROMBuffer
    735              t0 = OS_GetTime();
   \   00000088   ........           CALL    OS__Gettime
   \   0000008C   01C8               MOVW    R25:R24, R17:R16
    736              do {
    737                OS_Delay(1);
   \                     ??GetEEPROMData_1:
   \   0000008E   E001               LDI     R16, 1
   \   00000090   E010               LDI     R17, 0
   \   00000092   ........           CALL    OS_Delay
    738              }while ((OS_GetTime()-t0)< (sizeof(float)*9) && !EEPWriteOK);  //8.5 ms programming time
   \   00000096   ........           CALL    OS__Gettime
   \   0000009A   1B08               SUB     R16, R24
   \   0000009C   0B19               SBC     R17, R25
   \   0000009E   3204               CPI     R16, 36
   \   000000A0   4010               SBCI    R17, 0
   \   000000A2   F420               BRCC    ??GetEEPROMData_2
   \   000000A4   9100....           LDS     R16, EEPWriteOK
   \   000000A8   2300               TST     R16
   \   000000AA   F389               BREQ    ??GetEEPROMData_1
    739              WriteEEPROMBuffer( (channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char*)&UART[ch].pRxBuffer[pointer+5]);
   \                     ??GetEEPROMData_2:
   \   000000AC   01F2               MOVW    R31:R30, R5:R4
   \   000000AE   8542               LDD     R20, Z+10
   \   000000B0   8553               LDD     R21, Z+11
   \   000000B2   0D48               ADD     R20, R8
   \   000000B4   1D59               ADC     R21, R9
   \   000000B6   5F4B               SUBI    R20, 251
   \   000000B8   4F5F               SBCI    R21, 255
   \   000000BA   E024               LDI     R18, 4
   \   000000BC   9614               ADIW    R27:R26, 4
   \   000000BE   018D               MOVW    R17:R16, R27:R26
   \   000000C0   ........           CALL    WriteEEPROMBuffer
    740              t0 = OS_GetTime();
   \   000000C4   ........           CALL    OS__Gettime
   \   000000C8   01C8               MOVW    R25:R24, R17:R16
    741              do {
    742                OS_Delay(1);
   \                     ??GetEEPROMData_3:
   \   000000CA   E001               LDI     R16, 1
   \   000000CC   E010               LDI     R17, 0
   \   000000CE   ........           CALL    OS_Delay
    743              }while ((OS_GetTime()-t0)< (sizeof(float)*9) && !EEPWriteOK);
   \   000000D2   ........           CALL    OS__Gettime
   \   000000D6   1B08               SUB     R16, R24
   \   000000D8   0B19               SBC     R17, R25
   \   000000DA   3204               CPI     R16, 36
   \   000000DC   4010               SBCI    R17, 0
   \   000000DE   F420               BRCC    ??GetEEPROMData_4
   \   000000E0   9100....           LDS     R16, EEPWriteOK
   \   000000E4   2300               TST     R16
   \   000000E6   F389               BREQ    ??GetEEPROMData_3
    744          }
   \                     ??GetEEPROMData_4:
   \   000000E8   9189               LD      R24, Y+
   \   000000EA   9199               LD      R25, Y+
   \   000000EC   91A9               LD      R26, Y+
   \   000000EE   91B9               LD      R27, Y+
   \   000000F0   9049               LD      R4, Y+
   \   000000F2   9059               LD      R5, Y+
   \   000000F4   9089               LD      R8, Y+
   \   000000F6   9099               LD      R9, Y+
   \   000000F8   9508               RET
    745          
    746          /*************************************************************************
    747          *
    748          * Receive AN-ZB485 setup
    749          *
    750          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    751          void GetRS4Setup(char ch, short pointer) {
   \                     GetRS4Setup:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000004   E11A               LDI     R17, 26
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R26, LOW(UART)
   \   0000000A   ....               LDI     R27, (UART) >> 8
   \   0000000C   0DA0               ADD     R26, R0
   \   0000000E   1DB1               ADC     R27, R1
   \   00000010   961A               ADIW    R27:R26, 10
   \   00000012   91ED               LD      R30, X+
   \   00000014   91FC               LD      R31, X
   \   00000016   0FE2               ADD     R30, R18
   \   00000018   1FF3               ADC     R31, R19
   \   0000001A   8120               LD      R18, Z
   \   0000001C   9320....           STS     TData, R18
    752          
    753              TData.RS4.PortUsed = UART[ch].pRxBuffer[pointer];           // Get the setup
    754              TData.RS4.SensorType[0] = UART[ch].pRxBuffer[pointer+1];       // Get the sensor type
   \   00000020   8101               LDD     R16, Z+1
   \   00000022   9300....           STS     (TData + 1), R16
    755              TData.RS4.SensorType[1] = UART[ch].pRxBuffer[pointer+2];       // Get the sensor type
   \   00000026   8102               LDD     R16, Z+2
   \   00000028   9300....           STS     (TData + 2), R16
    756              WriteEEPROMByte(EEPROM_PORTSETUP, TData.RS4.PortUsed);      // store in EEPROM
   \   0000002C   E002               LDI     R16, 2
   \   0000002E   E010               LDI     R17, 0
   \   00000030   ........           CALL    WriteEEPROMByte
    757              WriteEEPROMByte(EEPROM_PORTSETUP+1, TData.RS4.SensorType[0]);
   \   00000034   9120....           LDS     R18, (TData + 1)
   \   00000038   E003               LDI     R16, 3
   \   0000003A   E010               LDI     R17, 0
   \   0000003C   ........           CALL    WriteEEPROMByte
    758              WriteEEPROMByte(EEPROM_PORTSETUP+2, TData.RS4.SensorType[1]);
   \   00000040   9120....           LDS     R18, (TData + 2)
   \   00000044   E004               LDI     R16, 4
   \   00000046   E010               LDI     R17, 0
   \   00000048   ........           CALL    WriteEEPROMByte
    759              SetRS4Port();                                               // Set power on ports
   \   0000004C   ........           CALL    SetRS4Port
    760          }
   \   00000050   91A9               LD      R26, Y+
   \   00000052   91B9               LD      R27, Y+
   \   00000054   9508               RET
    761          
    762          /*************************************************************************
    763          *
    764          * Rceive data fo AD card
    765          *
    766          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    767          void GetADData(char ch, short pointer) {
   \                     GetADData:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F79               MOV     R23, R25
   \   00000006   2E28               MOV     R2, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000008   01C9               MOVW    R25:R24, R19:R18
   \   0000000A   E11A               LDI     R17, 26
   \   0000000C   9F01               MUL     R16, R17
   \   0000000E   ....               LDI     R30, LOW(UART)
   \   00000010   ....               LDI     R31, (UART) >> 8
   \   00000012   0DE0               ADD     R30, R0
   \   00000014   1DF1               ADC     R31, R1
   \   00000016   8502               LDD     R16, Z+10
   \   00000018   8513               LDD     R17, Z+11
   \   0000001A   01F8               MOVW    R31:R30, R17:R16
   \   0000001C   0FE8               ADD     R30, R24
   \   0000001E   1FF9               ADC     R31, R25
   \   00000020   8120               LD      R18, Z
   \   00000022   3024               CPI     R18, 4
   \   00000024   F410               BRCC    ??GetADData_0
    768          
    769             char i, pair;
    770          
    771             if (UART[ch].pRxBuffer[pointer] <=3) {
    772               pair = 0;
   \   00000026   E020               LDI     R18, 0
   \   00000028   C001               RJMP    ??GetADData_1
    773             } else {
    774               pair = 1;
   \                     ??GetADData_0:
   \   0000002A   E520               LDI     R18, 80
   \                     ??GetADData_1:
   \   0000002C   E030               LDI     R19, 0
    775             }
    776             if (!TData.RS4.ToTargetBuffer[pair][0]) {                                // buffer empty?
   \   0000002E   ....               LDI     R20, LOW(TData)
   \   00000030   ....               LDI     R21, (TData) >> 8
   \   00000032   0F42               ADD     R20, R18
   \   00000034   1F53               ADC     R21, R19
   \   00000036   01DA               MOVW    R27:R26, R21:R20
   \   00000038   50AC               SUBI    R26, 12
   \   0000003A   4FBB               SBCI    R27, 251
   \   0000003C   912C               LD      R18, X
   \   0000003E   2322               TST     R18
   \   00000040   F539               BRNE    ??GetADData_2
    777                TData.RS4.ToTargetBuffer[pair][0] = true;                            //  Availible data for AD card
   \   00000042   E021               LDI     R18, 1
   \   00000044   932C               ST      X, R18
    778                TData.RS4.ToTargetBuffer[pair][1] = UART[ch].pRxBuffer[pointer++];   //  Channel to AD card
   \   00000046   8120               LD      R18, Z
   \   00000048   01FD               MOVW    R31:R30, R27:R26
   \   0000004A   8321               STD     Z+1, R18
    779                TData.RS4.ToTargetBuffer[pair][2] = UART[ch].pRxBuffer[pointer++];   // nob in datablock
   \   0000004C   9601               ADIW    R25:R24, 1
   \   0000004E   01F8               MOVW    R31:R30, R17:R16
   \   00000050   0FE8               ADD     R30, R24
   \   00000052   1FF9               ADC     R31, R25
   \   00000054   8120               LD      R18, Z
   \   00000056   01FD               MOVW    R31:R30, R27:R26
   \   00000058   8322               STD     Z+2, R18
    780                for (i = 3; i < TData.RS4.ToTargetBuffer[pair][2] + 3; i++) {
   \   0000005A   E023               LDI     R18, 3
   \   0000005C   0F08               ADD     R16, R24
   \   0000005E   1F19               ADC     R17, R25
   \   00000060   5F0F               SUBI    R16, 255
   \   00000062   4F1F               SBCI    R17, 255
   \   00000064   81E2               LDD     R30, Z+2
   \   00000066   E0F0               LDI     R31, 0
   \   00000068   9633               ADIW    R31:R30, 3
   \   0000006A   9734               SBIW    R31:R30, 4
   \   0000006C   F08C               BRLT    ??GetADData_2
    781                    TData.RS4.ToTargetBuffer[pair][i] = UART[ch].pRxBuffer[pointer++];  //Get the buffer
   \                     ??GetADData_3:
   \   0000006E   01F8               MOVW    R31:R30, R17:R16
   \   00000070   9161               LD      R22, Z+
   \   00000072   018F               MOVW    R17:R16, R31:R30
   \   00000074   01FA               MOVW    R31:R30, R21:R20
   \   00000076   0FE2               ADD     R30, R18
   \   00000078   1FF3               ADC     R31, R19
   \   0000007A   50EC               SUBI    R30, 12
   \   0000007C   4FFB               SBCI    R31, 251
   \   0000007E   8360               ST      Z, R22
    782                }
   \   00000080   9523               INC     R18
   \   00000082   01FD               MOVW    R31:R30, R27:R26
   \   00000084   81E2               LDD     R30, Z+2
   \   00000086   E0F0               LDI     R31, 0
   \   00000088   9633               ADIW    R31:R30, 3
   \   0000008A   172E               CP      R18, R30
   \   0000008C   073F               CPC     R19, R31
   \   0000008E   F37C               BRLT    ??GetADData_3
    783             }
    784          }
   \                     ??GetADData_2:
   \   00000090   ....               RJMP    ?Subroutine4
    785          
    786          /*************************************************************************
    787          *
    788          * Receive AN-ZBANA setup
    789          *
    790          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    791          void GetANASetup(char ch, short pointer) {
   \                     GetANASetup:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000008   01C9               MOVW    R25:R24, R19:R18
    792          
    793              TData.Ana.PortUsed = UART[ch].pRxBuffer[pointer] + (UART[ch].pRxBuffer[pointer+1] << 8);  //Get the setup
   \   0000000A   E11A               LDI     R17, 26
   \   0000000C   9F01               MUL     R16, R17
   \   0000000E   ....               LDI     R26, LOW(UART)
   \   00000010   ....               LDI     R27, (UART) >> 8
   \   00000012   0DA0               ADD     R26, R0
   \   00000014   1DB1               ADC     R27, R1
   \   00000016   01FD               MOVW    R31:R30, R27:R26
   \   00000018   8502               LDD     R16, Z+10
   \   0000001A   8513               LDD     R17, Z+11
   \   0000001C   0F08               ADD     R16, R24
   \   0000001E   1F19               ADC     R17, R25
   \   00000020   01F8               MOVW    R31:R30, R17:R16
   \   00000022   8120               LD      R18, Z
   \   00000024   8131               LDD     R19, Z+1
   \   00000026   9320....           STS     TData, R18
   \   0000002A   9330....           STS     (TData + 1), R19
    794              WriteEEPROMByte(EEPROM_PORTSETUP,UART[ch].pRxBuffer[pointer]);   // store in EEPROM
   \   0000002E   8120               LD      R18, Z
   \   00000030   E002               LDI     R16, 2
   \   00000032   E010               LDI     R17, 0
   \   00000034   ........           CALL    WriteEEPROMByte
    795              WriteEEPROMByte(EEPROM_PORTSETUP+1,UART[ch].pRxBuffer[pointer+1]);
   \   00000038   01FD               MOVW    R31:R30, R27:R26
   \   0000003A   8502               LDD     R16, Z+10
   \   0000003C   8513               LDD     R17, Z+11
   \   0000003E   0F08               ADD     R16, R24
   \   00000040   1F19               ADC     R17, R25
   \   00000042   01F8               MOVW    R31:R30, R17:R16
   \   00000044   8121               LDD     R18, Z+1
   \   00000046   E003               LDI     R16, 3
   \   00000048   E010               LDI     R17, 0
   \   0000004A   ........           CALL    WriteEEPROMByte
    796              SetAnaPort();                           // set the port on or off
   \   0000004E   ........           CALL    SetAnaPort
    797          }
   \   00000052   ....               RJMP    ?Subroutine3
    798          
    799          /*************************************************************************
    800          *
    801          * Receive AN-ZBANA filter
    802          *
    803          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    804          void GetANAFilter(char ch, short pointer) {
   \                     GetANAFilter:
   \   00000000   01AD               MOVW    R21:R20, R27:R26
   \   00000002                      REQUIRE __RSTACK_in_external_ram_new_way
    805              char port;
    806          
    807              for (port = 0; port <12; port++) {
   \   00000002   E11A               LDI     R17, 26
   \   00000004   9F01               MUL     R16, R17
   \   00000006   01F0               MOVW    R31:R30, R1:R0
   \   00000008   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000000A   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000000C   85A2               LDD     R26, Z+10
   \   0000000E   85B3               LDD     R27, Z+11
   \   00000010   0FA2               ADD     R26, R18
   \   00000012   1FB3               ADC     R27, R19
   \   00000014   ....               LDI     R30, LOW((TData + 2))
   \   00000016   ....               LDI     R31, HIGH((TData + 2))
   \   00000018   E00C               LDI     R16, 12
    808                  TData.Ana.Filter[port] = UART[ch].pRxBuffer[pointer++];  //Get the filter
   \                     ??GetANAFilter_0:
   \   0000001A   911D               LD      R17, X+
   \   0000001C   9311               ST      Z+, R17
    809              }
   \   0000001E   950A               DEC     R16
   \   00000020   F7E1               BRNE    ??GetANAFilter_0
    810          }
   \   00000022   01DA               MOVW    R27:R26, R21:R20
   \   00000024   9508               RET
    811          
    812          /*************************************************************************
    813          *
    814          *  Receive data on USARTs
    815          *
    816          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    817          void ReceivePacketUart(char ch) {
   \                     ReceivePacketUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000008   2F80               MOV     R24, R16
    818          
    819              switch (UART[ch].RxState) {                  // check status
   \   0000000A   E10A               LDI     R16, 26
   \   0000000C   9F80               MUL     R24, R16
   \   0000000E   ....               LDI     R26, LOW(UART)
   \   00000010   ....               LDI     R27, (UART) >> 8
   \   00000012   0DA0               ADD     R26, R0
   \   00000014   1DB1               ADC     R27, R1
   \   00000016   01FD               MOVW    R31:R30, R27:R26
   \   00000018   8902               LDD     R16, Z+18
   \   0000001A   2300               TST     R16
   \   0000001C   F409               BRNE    $+2+2
   \   0000001E   C0AA               RJMP    ??CrossCallReturnLabel_3
   \   00000020   950A               DEC     R16
   \   00000022   F039               BREQ    ??ReceivePacketUart_0
   \   00000024   950A               DEC     R16
   \   00000026   F409               BRNE    $+2+2
   \   00000028   C04B               RJMP    ??ReceivePacketUart_1
   \   0000002A   5008               SUBI    R16, 8
   \   0000002C   F409               BRNE    $+2+2
   \   0000002E   C0A2               RJMP    ??CrossCallReturnLabel_3
   \   00000030   C09F               RJMP    ??ReceivePacketUart_2
    820              case SYNC :
    821                  // all functionallity in inerrupt routine
    822                  break ;
    823              case HEADER :
    824                  if (UART[ch].RxLast >= 6) {             // receive header
   \                     ??ReceivePacketUart_0:
   \   00000032   8506               LDD     R16, Z+14
   \   00000034   8517               LDD     R17, Z+15
   \   00000036   3006               CPI     R16, 6
   \   00000038   4010               SBCI    R17, 0
   \   0000003A   F408               BRCC    $+2+2
   \   0000003C   C09B               RJMP    ??CrossCallReturnLabel_3
    825                      UART[ch].RxPacklen = (UART[ch].pRxBuffer[4] + (UART[ch].pRxBuffer[5] * 256)) ; // Find length of package
   \   0000003E   8502               LDD     R16, Z+10
   \   00000040   85F3               LDD     R31, Z+11
   \   00000042   2FE0               MOV     R30, R16
   \   00000044   8104               LDD     R16, Z+4
   \   00000046   8115               LDD     R17, Z+5
   \   00000048   01FD               MOVW    R31:R30, R27:R26
   \   0000004A   8B06               STD     Z+22, R16
   \   0000004C   8B17               STD     Z+23, R17
    826                      if (CalcDSRxChecksum(ch, 6) && (UART[ch].pRxBuffer[0] == (DEVICE_IO + UnitID))) {
   \   0000004E   E060               LDI     R22, 0
   \   00000050   8542               LDD     R20, Z+10
   \   00000052   8553               LDD     R21, Z+11
   \   00000054   018A               MOVW    R17:R16, R21:R20
   \   00000056   E026               LDI     R18, 6
   \   00000058   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_3:
   \   0000005A   01F8               MOVW    R31:R30, R17:R16
   \   0000005C   9001               LD      R0, Z+
   \   0000005E   018F               MOVW    R17:R16, R31:R30
   \   00000060   2560               EOR     R22, R0
   \   00000062   2FE6               MOV     R30, R22
   \   00000064   E0F0               LDI     R31, 0
   \   00000066   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000068   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000006A   BF3B               OUT     0x3B, R19
   \   0000006C   9166               ELPM    R22, Z
   \   0000006E   952A               DEC     R18
   \   00000070   F7A1               BRNE    ??ReceivePacketUart_3
   \   00000072   01FA               MOVW    R31:R30, R21:R20
   \   00000074   8106               LDD     R16, Z+6
   \   00000076   1760               CP      R22, R16
   \   00000078   F009               BREQ    $+2+2
   \   0000007A   C07A               RJMP    ??ReceivePacketUart_2
   \   0000007C   8100               LD      R16, Z
   \   0000007E   E010               LDI     R17, 0
   \   00000080   91E0....           LDS     R30, UnitID
   \   00000084   E0F0               LDI     R31, 0
   \   00000086   9670               ADIW    R31:R30, 16
   \   00000088   170E               CP      R16, R30
   \   0000008A   071F               CPC     R17, R31
   \   0000008C   F009               BREQ    $+2+2
   \   0000008E   C070               RJMP    ??ReceivePacketUart_2
    827                          // header checksum OK and to me
    828                          if ((UART[ch].RxPacklen < ((short) RXSIZE_UART-UART[ch].RxLast)) &&    /* chk. header */
    829                              (UART[ch].RxPacklen >= MIN_PACK_LEN)) {
   \   00000090   01FD               MOVW    R31:R30, R27:R26
   \   00000092   8926               LDD     R18, Z+22
   \   00000094   8937               LDD     R19, Z+23
   \   00000096   E906               LDI     R16, 150
   \   00000098   8546               LDD     R20, Z+14
   \   0000009A   8557               LDD     R21, Z+15
   \   0000009C   1B04               SUB     R16, R20
   \   0000009E   0B15               SBC     R17, R21
   \   000000A0   1720               CP      R18, R16
   \   000000A2   0731               CPC     R19, R17
   \   000000A4   F008               BRCS    $+2+2
   \   000000A6   C064               RJMP    ??ReceivePacketUart_2
   \   000000A8   3027               CPI     R18, 7
   \   000000AA   4030               SBCI    R19, 0
   \   000000AC   F408               BRCC    $+2+2
   \   000000AE   C060               RJMP    ??ReceivePacketUart_2
    830                              UART[ch].RxState = RECEIVE ;       // Header ok go to data receive state
   \   000000B0   E002               LDI     R16, 2
   \   000000B2   8B02               STD     Z+18, R16
    831                              UART[ch].RxCount = UART[ch].RxLast + 1 ;    // Set receive counter
   \   000000B4   8586               LDD     R24, Z+14
   \   000000B6   8597               LDD     R25, Z+15
   \   000000B8   9601               ADIW    R25:R24, 1
   \   000000BA   8B80               STD     Z+16, R24
   \   000000BC   8B91               STD     Z+17, R25
   \   000000BE   C05A               RJMP    ??CrossCallReturnLabel_3
    832                          } else {
    833                              GoToSyncUART(ch) ;                        // go to sync modus for recive
    834                          }
    835                      } else {
    836                          GoToSyncUART(ch) ;                            // go to sync modus for recive
    837                      }
    838                  }
    839                  break ;
    840              case RECEIVE :
    841                  if (++UART[ch].RxCount >= UART[ch].RxPacklen) {
   \                     ??ReceivePacketUart_1:
   \   000000C0   8900               LDD     R16, Z+16
   \   000000C2   8911               LDD     R17, Z+17
   \   000000C4   5F0F               SUBI    R16, 255
   \   000000C6   4F1F               SBCI    R17, 255
   \   000000C8   8B00               STD     Z+16, R16
   \   000000CA   8B11               STD     Z+17, R17
   \   000000CC   8926               LDD     R18, Z+22
   \   000000CE   8937               LDD     R19, Z+23
   \   000000D0   1702               CP      R16, R18
   \   000000D2   0713               CPC     R17, R19
   \   000000D4   F408               BRCC    $+2+2
   \   000000D6   C04E               RJMP    ??CrossCallReturnLabel_3
    842                      if ((UART[ch].pRxBuffer[UART[ch].RxPacklen -1]) == ANPRO10_EOT) {
   \   000000D8   0119               MOVW    R3:R2, R19:R18
   \   000000DA   8502               LDD     R16, Z+10
   \   000000DC   8513               LDD     R17, Z+11
   \   000000DE   0F02               ADD     R16, R18
   \   000000E0   1F13               ADC     R17, R19
   \   000000E2   5001               SUBI    R16, 1
   \   000000E4   4010               SBCI    R17, 0
   \   000000E6   01F8               MOVW    R31:R30, R17:R16
   \   000000E8   8100               LD      R16, Z
   \   000000EA   3004               CPI     R16, 4
   \   000000EC   F009               BREQ    $+2+2
   \   000000EE   C040               RJMP    ??ReceivePacketUart_2
    843                          if (CalcDSRxChecksum(ch, UART[ch].RxPacklen-2)) {
   \   000000F0   EF0E               LDI     R16, 254
   \   000000F2   0E20               ADD     R2, R16
   \   000000F4   EF0F               LDI     R16, 255
   \   000000F6   1E30               ADC     R3, R16
   \   000000F8   2400               CLR     R0
   \   000000FA   01FD               MOVW    R31:R30, R27:R26
   \   000000FC   8562               LDD     R22, Z+10
   \   000000FE   8573               LDD     R23, Z+11
   \   00000100   2D02               MOV     R16, R2
   \   00000102   2903               OR      R16, R3
   \   00000104   F081               BREQ    ??ReceivePacketUart_4
   \   00000106   018B               MOVW    R17:R16, R23:R22
   \   00000108   01A1               MOVW    R21:R20, R3:R2
   \   0000010A   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_5:
   \   0000010C   01F8               MOVW    R31:R30, R17:R16
   \   0000010E   9121               LD      R18, Z+
   \   00000110   018F               MOVW    R17:R16, R31:R30
   \   00000112   2602               EOR     R0, R18
   \   00000114   2DE0               MOV     R30, R0
   \   00000116   E0F0               LDI     R31, 0
   \   00000118   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000011A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000011C   BF3B               OUT     0x3B, R19
   \   0000011E   9006               ELPM    R0, Z
   \   00000120   5041               SUBI    R20, 1
   \   00000122   4050               SBCI    R21, 0
   \   00000124   F799               BRNE    ??ReceivePacketUart_5
   \                     ??ReceivePacketUart_4:
   \   00000126   0D62               ADD     R22, R2
   \   00000128   1D73               ADC     R23, R3
   \   0000012A   01FB               MOVW    R31:R30, R23:R22
   \   0000012C   8100               LD      R16, Z
   \   0000012E   1600               CP      R0, R16
   \   00000130   F4F9               BRNE    ??ReceivePacketUart_2
    844                              if ((UART[ch].pRxBuffer[1] == MyAddress())||      // message to me? or
    845                                  (UART[ch].pRxBuffer[1] == 0xff)) {            // broadcast
   \   00000132   ........           CALL    MyAddress
   \   00000136   2F20               MOV     R18, R16
   \   00000138   01FD               MOVW    R31:R30, R27:R26
   \   0000013A   8502               LDD     R16, Z+10
   \   0000013C   85F3               LDD     R31, Z+11
   \   0000013E   2FE0               MOV     R30, R16
   \   00000140   8131               LDD     R19, Z+1
   \   00000142   1732               CP      R19, R18
   \   00000144   F011               BREQ    ??ReceivePacketUart_6
   \   00000146   3F3F               CPI     R19, 255
   \   00000148   F499               BRNE    ??ReceivePacketUart_2
    846                                  hostAddress = UART[ch].pRxBuffer[3];            // address to sender (host)
   \                     ??ReceivePacketUart_6:
   \   0000014A   8103               LDD     R16, Z+3
   \   0000014C   9300....           STS     hostAddress, R16
    847                                  UART[ch].RxState = HANDLE ;                     // Package OK
   \   00000150   01FD               MOVW    R31:R30, R27:R26
   \   00000152   E00A               LDI     R16, 10
   \   00000154   8B02               STD     Z+18, R16
    848                                  if (ch == 0) {
   \   00000156   2388               TST     R24
   \   00000158   F419               BRNE    ??ReceivePacketUart_7
    849                                      OS_SignalEvent(1, &TCB_USART0);
   \   0000015A   ....               LDI     R18, LOW(TCB_USART0)
   \   0000015C   ....               LDI     R19, (TCB_USART0) >> 8
   \   0000015E   C004               RJMP    ??ReceivePacketUart_8
    850                                  } else if (ch == 1) {
   \                     ??ReceivePacketUart_7:
   \   00000160   3081               CPI     R24, 1
   \   00000162   F441               BRNE    ??CrossCallReturnLabel_3
    851                                      OS_SignalEvent(1, &TCB_USART1);
   \   00000164   ....               LDI     R18, LOW(TCB_USART1)
   \   00000166   ....               LDI     R19, (TCB_USART1) >> 8
   \                     ??ReceivePacketUart_8:
   \   00000168   E001               LDI     R16, 1
   \   0000016A   ........           CALL    OS_SignalEvent
   \   0000016E   C002               RJMP    ??CrossCallReturnLabel_3
    852                                  }
    853                              } else {
    854                                  GoToSyncUART(ch) ;                             // go to sync modus for recive
    855                              }
    856                          } else {
    857                              GoToSyncUART(ch) ;                                // go to sync modus for recive
    858                          }
    859                      } else {
    860                          GoToSyncUART(ch) ;                                    // go to sync modus for recive
    861                      }
    862                  }
    863                  break ;
    864              case HANDLE :
    865                  break;
    866              default :
    867                  GoToSyncUART(ch) ;                                            // go to sync modus for recive
   \                     ??ReceivePacketUart_2:
   \   00000170   2F08               MOV     R16, R24
   \   00000172   ....               RCALL   ?Subroutine6
    868                  break ;
    869              }                                                           // end switch
    870              if (++UART[ch].RxLast >= RXSIZE_UART) {                     // check pointer
   \                     ??CrossCallReturnLabel_3:
   \   00000174   01FD               MOVW    R31:R30, R27:R26
   \   00000176   8506               LDD     R16, Z+14
   \   00000178   8517               LDD     R17, Z+15
   \   0000017A   5F0F               SUBI    R16, 255
   \   0000017C   4F1F               SBCI    R17, 255
   \   0000017E   8706               STD     Z+14, R16
   \   00000180   8717               STD     Z+15, R17
   \   00000182   3906               CPI     R16, 150
   \   00000184   E020               LDI     R18, 0
   \   00000186   4010               SBCI    R17, 0
   \   00000188   F010               BRCS    ??ReceivePacketUart_9
    871                  UART[ch].RxLast = 0;                                     // reset pointer
   \   0000018A   8726               STD     Z+14, R18
   \   0000018C   8727               STD     Z+15, R18
    872              }
    873          }
   \                     ??ReceivePacketUart_9:
   \   0000018E   ....               RJMP    ?Subroutine3
    874          
    875          
    876          /*************************************************************************
    877          *
    878          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    879          *
    880          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    881          char CalcDSTxChecksum(char ch, unsigned short len) {
   \                     CalcDSTxChecksum:
   \   00000000   01BD               MOVW    R23:R22, R27:R26
   \   00000002   01AC               MOVW    R21:R20, R25:R24
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000004   2F10               MOV     R17, R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
    882          
    883              unsigned short  cnt ;
    884              unsigned char   csum ;
    885          
    886              csum = 0 ;
   \   00000008   E000               LDI     R16, 0
    887              for (cnt = 4 ; cnt < len ; cnt++) {
   \   0000000A   3025               CPI     R18, 5
   \   0000000C   4030               SBCI    R19, 0
   \   0000000E   F0A0               BRCS    ??CalcDSTxChecksum_0
   \   00000010   E12A               LDI     R18, 26
   \   00000012   9F12               MUL     R17, R18
   \   00000014   01F0               MOVW    R31:R30, R1:R0
   \   00000016   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000018   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000001A   81A0               LD      R26, Z
   \   0000001C   81B1               LDD     R27, Z+1
   \   0000001E   9614               ADIW    R27:R26, 4
   \   00000020   9704               SBIW    R25:R24, 4
   \   00000022   ....               LDI     R19, (crc) >> 16
    888                  csum = crc[csum ^ UART[ch].pTxBuffer[cnt]] ;
   \                     ??CalcDSTxChecksum_1:
   \   00000024   2FE0               MOV     R30, R16
   \   00000026   E0F0               LDI     R31, 0
   \   00000028   910D               LD      R16, X+
   \   0000002A   27E0               EOR     R30, R16
   \   0000002C   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000002E   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000030   BF3B               OUT     0x3B, R19
   \   00000032   9106               ELPM    R16, Z
    889              }
   \   00000034   9701               SBIW    R25:R24, 1
   \   00000036   F7B1               BRNE    ??CalcDSTxChecksum_1
    890              return csum ;
   \                     ??CalcDSTxChecksum_0:
   \   00000038   01CA               MOVW    R25:R24, R21:R20
   \   0000003A   01DB               MOVW    R27:R26, R23:R22
   \   0000003C   9508               RET
    891          }
    892          
    893          /*************************************************************************
    894          *
    895          * Calculate rx packet checksum (header and package) using Dallas Semiconductor one-wire CRC
    896          *
    897          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    898          short CalcDSRxChecksum(char ch, unsigned short len) {
   \                     CalcDSRxChecksum:
   \   00000000   939A               ST      -Y, R25
   \   00000002   2F58               MOV     R21, R24
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000004   0119               MOVW    R3:R2, R19:R18
    899          
    900              unsigned short  cnt ;
    901              unsigned char   csum ;
    902          
    903              csum = 0 ;
   \   00000006   E040               LDI     R20, 0
   \   00000008   E11A               LDI     R17, 26
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   8562               LDD     R22, Z+10
   \   00000016   8573               LDD     R23, Z+11
   \   00000018   2923               OR      R18, R3
   \   0000001A   F081               BREQ    ??CalcDSRxChecksum_0
   \   0000001C   018B               MOVW    R17:R16, R23:R22
   \   0000001E   2D82               MOV     R24, R2
   \   00000020   2F93               MOV     R25, R19
   \   00000022   ....               LDI     R19, (crc) >> 16
    904              for (cnt=0 ; cnt < len ; cnt++) {
    905                  csum = crc[csum ^ UART[ch].pRxBuffer[cnt]] ;
   \                     ??CalcDSRxChecksum_1:
   \   00000024   01F8               MOVW    R31:R30, R17:R16
   \   00000026   9121               LD      R18, Z+
   \   00000028   018F               MOVW    R17:R16, R31:R30
   \   0000002A   2742               EOR     R20, R18
   \   0000002C   2FE4               MOV     R30, R20
   \   0000002E   E0F0               LDI     R31, 0
   \   00000030   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000032   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000034   BF3B               OUT     0x3B, R19
   \   00000036   9146               ELPM    R20, Z
    906              }
   \   00000038   9701               SBIW    R25:R24, 1
   \   0000003A   F7A1               BRNE    ??CalcDSRxChecksum_1
    907              if (csum == UART[ch].pRxBuffer[len]) {
   \                     ??CalcDSRxChecksum_0:
   \   0000003C   0D62               ADD     R22, R2
   \   0000003E   1D73               ADC     R23, R3
   \   00000040   01FB               MOVW    R31:R30, R23:R22
   \   00000042   8100               LD      R16, Z
   \   00000044   1740               CP      R20, R16
   \   00000046   F411               BRNE    ??CalcDSRxChecksum_2
    908                  return true ;
   \   00000048   E001               LDI     R16, 1
   \   0000004A   C001               RJMP    ??CalcDSRxChecksum_3
    909              } else {
    910                  return false ;
   \                     ??CalcDSRxChecksum_2:
   \   0000004C   E000               LDI     R16, 0
   \                     ??CalcDSRxChecksum_3:
   \   0000004E   E010               LDI     R17, 0
   \   00000050   2F85               MOV     R24, R21
   \   00000052   9199               LD      R25, Y+
   \   00000054   9508               RET
    911              }
    912          }
    913          
    914          /*************************************************************************
    915          *
    916          * Goes to sync mode
    917          *
    918          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    919          __monitor void GoToSyncUART(char ch) {
   \                     GoToSyncUART:
   \   00000000   B72F               IN      R18, 0x3F
   \   00000002                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000002   94F8               CLI
    920          
    921              if (ch < 2) {
   \   00000004   3002               CPI     R16, 2
   \   00000006   F458               BRCC    ??GoToSyncUART_0
    922                  UART[ch].SyncCnt = 0 ;                        // ready for sync
   \   00000008   E11A               LDI     R17, 26
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E000               LDI     R16, 0
   \   00000016   8B03               STD     Z+19, R16
    923                  UART[ch].RxState = SYNC ;
   \   00000018   8B02               STD     Z+18, R16
    924                  UART[ch].RxFirst = 0 ;
   \   0000001A   8704               STD     Z+12, R16
   \   0000001C   8705               STD     Z+13, R16
    925              }
    926          }
   \                     ??GoToSyncUART_0:
   \   0000001E   BF2F               OUT     0x3F, R18
   \   00000020   9508               RET

   \                                 In  segment SWITCH, align 2, keep-with-next
   \                     `?<Jumptable for CheckActionUart>_0`:
   \   00000000   E803               DW      59395
   \   00000002   01                 DB      1
   \   00000003   ....               DW      (??CheckActionUart_24) /2
   \   00000005   ....               DW      (??CheckActionUart_0) /2
   \   00000007   0A                 DB      0xa
   \   00000008   ....               DW      (??CheckActionUart_3) /2
   \   0000000A   0A                 DB      0xa
   \   0000000B   ....               DW      (??CheckActionUart_4) /2
   \   0000000D   32                 DB      0x32
   \   0000000E   ....               DW      (??CheckActionUart_7) /2
   \   00000010   0A                 DB      0xa
   \   00000011   ....               DW      (??CheckActionUart_8) /2
   \   00000013   0A                 DB      0xa
   \   00000014   ....               DW      (??CheckActionUart_9) /2
   \   00000016   0A                 DB      0xa
   \   00000017   ....               DW      (??CheckActionUart_10) /2
   \   00000019   0A                 DB      0xa
   \   0000001A   ....               DW      (??CheckActionUart_11) /2
   \   0000001C   1E                 DB      0x1e
   \   0000001D   ....               DW      (??CheckActionUart_13) /2
   \   0000001F   14                 DB      0x14
   \   00000020   ....               DW      (??CheckActionUart_12) /2
   \   00000022   28                 DB      0x28
   \   00000023   ....               DW      (??CheckActionUart_18) /2
   \   00000025   0A                 DB      0xa
   \   00000026   ....               DW      (??CheckActionUart_19) /2
   \   00000028   0A                 DB      0xa
   \   00000029   ....               DW      (??CheckActionUart_20) /2
   \   0000002B   0A                 DB      0xa
   \   0000002C   ....               DW      (??CheckActionUart_22) /2
   \   0000002E   0A                 DB      0xa
   \   0000002F   ....               DW      (??CheckActionUart_23) /2
   \   00000031   02FE9E             DB      254,0x2,0x9e
   \   00000034   ....               DW      (??CheckActionUart_2) /2
   \   00000036   FB                 DB      251
   \   00000037   00                 DB      0

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      1      2   BuildADEpromdata
      1      2   BuildADInt
      1      2   BuildANAFilter
      0      2   BuildANASetup
      6      2   BuildEEPROMData
        6      2   -> ReadEEPROMBuffer
      4      2   BuildMData485
      6      2   BuildMDataANA
      6      2   BuildRData485
      0      2   BuildRS4Setup
      0      2   BuildStackStatus
      6      2   BuildStatusData
        6      2   -> MyAddress
      4      2   BuildWHdata
        4      2   -> OS_LeaveRegion
      1      2   CalcDSRxChecksum
      0      2   CalcDSTxChecksum
     10      2   CheckActionUart
       10      2   -> BuildADEpromdata
       10      2   -> BuildADInt
       10      2   -> BuildANAFilter
       10      2   -> BuildANASetup
       10      2   -> BuildEEPROMData
       10      2   -> BuildMData485
       10      2   -> BuildMDataANA
       10      2   -> BuildRData485
       10      2   -> BuildRS4Setup
       10      2   -> BuildStackStatus
       10      2   -> BuildStatusData
       10      2   -> BuildWHdata
       10      2   -> EEPROMReset
       10      2   -> GetADData
       10      2   -> GetANASetup
       10      2   -> GetEEPROMData
       10      2   -> GetRS4Setup
       10      2 ?SS_SHR_L02
       10      2 ?SV_SWITCH_L06
      1      2   GetADData
      0      2   GetANAFilter
      4      2   GetANASetup
        4      2   -> SetAnaPort
        4      2   -> WriteEEPROMByte
      8      2   GetEEPROMData
        8      2   -> OS_Delay
        8      2   -> OS__Gettime
        8      2   -> WriteEEPROMBuffer
      0      2   GetGotoBootloader
      2      2   GetRS4Setup
        2      2   -> SetRS4Port
        2      2   -> WriteEEPROMByte
      0      2   GetResetEEPROM
        0      2   -> EEPROMReset
      0      2   GoToSyncUART
      4      2   ReceivePacketUart
        4      2   -> GoToSyncUART
        4      2   -> MyAddress
        4      2   -> OS_SignalEvent
      0      2   TimoutUSART0
        0      2   -> GoToSyncUART
        0      2   -> OS_StopTimer
      0      2   TimoutUSART0On
        0      2   -> OS_StopTimer
      0      2   TimoutUSART1
        0      2   -> GoToSyncUART
        0      2   -> OS_StopTimer
      0      2   TimoutUSART1On
        0      2   -> OS_StopTimer
      2      2   Uart_BuildHeader
        2      2   -> MyAddress
      3      2   Uart_BuildTail
        3      2   -> OS_RetriggerTimer
        3      2   -> Uart_BuildHeader
      4      2   Usart0Handler
        4      2   -> CheckActionUart
        4      2   -> GoToSyncUART
        4      2   -> OS_Unuse
        4      2   -> OS_Use
        4      2   -> OS_WaitEventTimed
        4      2   -> Uart_BuildTail
      4      2   Usart1Handler
        4      2   -> CheckActionUart
        4      2   -> GoToSyncUART
        4      2   -> OS_Unuse
        4      2   -> OS_Use
        4      2   -> OS_WaitEventTimed
        4      2   -> Uart_BuildTail
      5      2   UsartCheckPackage
        5      2   -> CheckActionUart
        5      2   -> GoToSyncUART
        5      2   -> Uart_BuildTail


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      56  ?<Jumptable for CheckActionUart>_0
      14  ??Subroutine5_0
      70  ?Subroutine0
       2  ?Subroutine1
      14  ?Subroutine2
      10  ?Subroutine3
      10  ?Subroutine4
       4  ?Subroutine6
       4  ?Subroutine7
     176  BuildADEpromdata
     196  BuildADInt
     162  BuildANAFilter
     118  BuildANASetup
     254  BuildEEPROMData
     716  BuildMData485
     298  BuildMDataANA
     346  BuildRData485
     148  BuildRS4Setup
     380  BuildStackStatus
     534  BuildStatusData
     408  BuildWHdata
      86  CalcDSRxChecksum
      62  CalcDSTxChecksum
     496  CheckActionUart
     146  GetADData
      38  GetANAFilter
      84  GetANASetup
     250  GetEEPROMData
      40  GetGotoBootloader
      86  GetRS4Setup
       4  GetResetEEPROM
      34  GoToSyncUART
     400  ReceivePacketUart
      36  TimoutUSART0
      18  TimoutUSART0On
      36  TimoutUSART1
      18  TimoutUSART1On
     156  Uart_BuildHeader
     430  Uart_BuildTail
     126  Usart0Handler
     126  Usart1Handler
     122  UsartCheckPackage
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_UCSR0B
       1  _A_UCSR1B
       1  _A_WDTCSR

 
     8 bytes in segment ABSOLUTE
 6 658 bytes in segment CODE
    56 bytes in segment SWITCH
 
 6 714 bytes of CODE memory
     0 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: none
