###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       02/Jan/2024  12:42:50
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\ExtInt.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWC75C.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\ExtInt.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj" -D
#        OS_LIBMODE_R -D OS_UART=-1 -D USE_16552_DRIVER_TASK=1 -D
#        USE_1281_RX_INT_TASK=1 -D USE_MODBUS_PROTOCOL=0 -D ANZBANA_V8=0 -D
#        __ATMEGA_1281__ -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List" -y
#        --initializers_in_flash -DENABLE_BIT_DEFINITIONS -e -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -Ohs)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List\ExtInt.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj\ExtInt.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\ExtInt.c
      1          /****************************************************************************************
      2          / AD converter handling , AD7715
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom1281.h"
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "externals.h"
     10          #pragma diag_suppress=Pa082
     11          
     12          #if USE_16552_DRIVER_TASK == 1

   \                                 In  segment CODE, align 2, keep-with-next
     13          void _16552_Rx_handler(void *pData) {
   \                     _16552_Rx_handler:
   \   00000000   92FA               ST      -Y, R15
   \   00000002   92EA               ST      -Y, R14
   \   00000004   928A               ST      -Y, R8
   \   00000006   927A               ST      -Y, R7
   \   00000008   926A               ST      -Y, R6
   \   0000000A   925A               ST      -Y, R5
   \   0000000C   924A               ST      -Y, R4
   \   0000000E   93BA               ST      -Y, R27
   \   00000010   93AA               ST      -Y, R26
   \   00000012   939A               ST      -Y, R25
   \   00000014   938A               ST      -Y, R24
   \   00000016                      REQUIRE ?Register_R4_is_cg_reg
   \   00000016                      REQUIRE ?Register_R5_is_cg_reg
   \   00000016                      REQUIRE ?Register_R6_is_cg_reg
   \   00000016                      REQUIRE ?Register_R7_is_cg_reg
   \   00000016                      REQUIRE ?Register_R8_is_cg_reg
   \   00000016                      REQUIRE ?Register_R14_is_cg_reg
   \   00000016                      REQUIRE ?Register_R15_is_cg_reg
   \   00000016   9721               SBIW    R29:R28, 1
     14              const char Ch = (char)pData;
   \   00000018   2E80               MOV     R8, R16
     15              char *RxBuff = UART16552[Ch].pRxBuffer;
   \   0000001A   2F20               MOV     R18, R16
   \   0000001C   E008               LDI     R16, 8
   \   0000001E   E011               LDI     R17, 1
   \   00000020   9F21               MUL     R18, R17
   \   00000022   2D30               MOV     R19, R0
   \   00000024   9F20               MUL     R18, R16
   \   00000026   0D31               ADD     R19, R1
   \   00000028   ....               LDI     R24, LOW(UART16552)
   \   0000002A   ....               LDI     R25, (UART16552) >> 8
   \   0000002C   0D80               ADD     R24, R0
   \   0000002E   1F93               ADC     R25, R19
   \   00000030   013C               MOVW    R7:R6, R25:R24
   \   00000032   E404               LDI     R16, 68
   \   00000034   0E60               ADD     R6, R16
   \   00000036   E000               LDI     R16, 0
   \   00000038   1E70               ADC     R7, R16
     16              OS_WaitEvent(0x01);
   \   0000003A   E001               LDI     R16, 1
   \   0000003C   ........           CALL    OS_WaitEvent
   \   00000040   012C               MOVW    R5:R4, R25:R24
   \   00000042   EC03               LDI     R16, 195
   \   00000044   0E40               ADD     R4, R16
   \   00000046   E000               LDI     R16, 0
   \   00000048   1E50               ADC     R5, R16
   \   0000004A   01DC               MOVW    R27:R26, R25:R24
   \   0000004C   54A4               SUBI    R26, 68
   \   0000004E   4FBF               SBCI    R27, 255
   \   00000050   5083               SUBI    R24, 3
   \   00000052   4F9F               SBCI    R25, 255
   \   00000054   EF0A               LDI     R16, 250
   \   00000056   2EE0               MOV     R14, R16
   \   00000058   24FF               CLR     R15
   \   0000005A   C007               RJMP    ??_16552_Rx_handler_0
     17              while (true) {
     18                  char RxByte;
     19                  OS_GetMail1(&UART16552[Ch].RxMailBox, &RxByte);
     20                  RxBuff[UART16552[Ch].RxFirst] = RxByte;
     21                  if (UART16552[Ch].RxState != HANDLE) {                 // ok to receive?
     22                      switch (UART16552[Ch].RxState) {                   // Yes, check state
     23                      case SYNC :
     24                          if (RxByte == ANPRO1_SYN) {
     25                              UART16552[Ch].SyncCnt++;                 // count sync
   \                     ??_16552_Rx_handler_1:
   \   0000005C   01F2               MOVW    R31:R30, R5:R4
   \   0000005E   8100               LD      R16, Z
   \   00000060   9503               INC     R16
   \   00000062   8300               ST      Z, R16
     26                              UART16552[Ch].RxFirst = 0;                 // start at start of buff
   \   00000064   92FD               ST      X+, R15
   \   00000066   92FC               ST      X, R15
   \   00000068   9711               SBIW    R27:R26, 1
     27                          } else if (UART16552[Ch].SyncCnt >= 2) {       // minimum two sync bytes
   \                     ??_16552_Rx_handler_0:
   \   0000006A   019E               MOVW    R19:R18, R29:R28
   \   0000006C   018C               MOVW    R17:R16, R25:R24
   \   0000006E   ........           CALL    OS_GetMail1
   \   00000072   8108               LD      R16, Y
   \   00000074   912D               LD      R18, X+
   \   00000076   913C               LD      R19, X
   \   00000078   9711               SBIW    R27:R26, 1
   \   0000007A   01F3               MOVW    R31:R30, R7:R6
   \   0000007C   0FE2               ADD     R30, R18
   \   0000007E   1FF3               ADC     R31, R19
   \   00000080   8300               ST      Z, R16
   \   00000082   01FD               MOVW    R31:R30, R27:R26
   \   00000084   8106               LDD     R16, Z+6
   \   00000086   300A               CPI     R16, 10
   \   00000088   F381               BREQ    ??_16552_Rx_handler_0
   \   0000008A   8106               LDD     R16, Z+6
   \   0000008C   2300               TST     R16
   \   0000008E   F4C1               BRNE    ??_16552_Rx_handler_2
   \   00000090   8108               LD      R16, Y
   \   00000092   3002               CPI     R16, 2
   \   00000094   F319               BREQ    ??_16552_Rx_handler_1
   \   00000096   8107               LDD     R16, Z+7
   \   00000098   3002               CPI     R16, 2
   \   0000009A   82F7               STD     Z+7, R15
   \   0000009C   F330               BRCS    ??_16552_Rx_handler_0
     28                              UART16552[Ch].SyncCnt = 0;                // reset counter
     29                              UART16552[Ch].RxState = HEADER;
   \   0000009E   E001               LDI     R16, 1
   \   000000A0   8306               STD     Z+6, R16
     30                              UART16552[Ch].RxLast = 0;
   \   000000A2   82F2               STD     Z+2, R15
   \   000000A4   82F3               STD     Z+3, R15
     31                              UART16552[Ch].RxTimeout = RX_TO_TIME;   // reset timeout
   \   000000A6   86E0               STD     Z+8, R14
   \   000000A8   86F1               STD     Z+9, R15
     32                              UART16552[Ch].RxFirst++;                 //  1. char OK, start on next
   \   000000AA   8100               LD      R16, Z
   \   000000AC   9611               ADIW    R27:R26, 1
   \   000000AE   8111               LDD     R17, Z+1
   \   000000B0   5F0F               SUBI    R16, 255
   \   000000B2   4F1F               SBCI    R17, 255
   \   000000B4   931C               ST      X, R17
   \   000000B6   930E               ST      -X, R16
     33                              ReceivePacketUart16552(Ch);              // Check package
   \   000000B8   2D08               MOV     R16, R8
   \                     ??_16552_Rx_handler_3:
   \   000000BA   ........           CALL    ReceivePacketUart16552
   \   000000BE   CFD5               RJMP    ??_16552_Rx_handler_0
     34                          } else {
     35                              UART16552[Ch].SyncCnt = 0;                // start over once more
     36                          }
     37                          break;
     38                      default :
     39                          if ((++UART16552[Ch].RxFirst) > RXSIZE_UART_16552) { // Point to next location
   \                     ??_16552_Rx_handler_2:
   \   000000C0   91ED               LD      R30, X+
   \   000000C2   91FC               LD      R31, X
   \   000000C4   9711               SBIW    R27:R26, 1
   \   000000C6   9631               ADIW    R31:R30, 1
   \   000000C8   93ED               ST      X+, R30
   \   000000CA   93FC               ST      X, R31
   \   000000CC   9711               SBIW    R27:R26, 1
   \   000000CE   37E9               CPI     R30, 121
   \   000000D0   40F0               SBCI    R31, 0
   \   000000D2   2D08               MOV     R16, R8
   \   000000D4   F390               BRCS    ??_16552_Rx_handler_3
     40                              GoToSyncUART16552(Ch);                       // go to sync mode
   \   000000D6   ........           CALL    GoToSyncUART16552
   \   000000DA   CFC7               RJMP    ??_16552_Rx_handler_0
     41                          } else {
     42                              ReceivePacketUart16552(Ch);              // Check package
     43                          }
     44                          break;
     45                      }
     46                  }
     47              }
     48          }
     49          
     50          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     51          OS_TASK TCB_16552_RxHandler1;
   \                     TCB_16552_RxHandler1:
   \   00000000                      DS8 20
     52          OS_TASK TCB_16552_RxHandler2;
   \                     TCB_16552_RxHandler2:
   \   00000014                      DS8 20

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     53          static OS_STACKPTR int stack1[300]; /* Task stacks */
   \                     stack1:
   \   00000000                      DS8 600

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     54          static OS_STACKPTR int stack2[300]; /* Task stacks */
   \                     stack2:
   \   00000000                      DS8 600
     55          

   \                                 In  segment CODE, align 2, keep-with-next
     56          void _16552_driver_task_init(void) {
   \                     _16552_driver_task_init:
     57          
     58              OS_CREATETASK_EX(&TCB_16552_RxHandler1, "16552_RX_Handler 0", _16552_Rx_handler, 96, stack1, (void *)0);
   \   00000000   E000               LDI     R16, 0
   \   00000002   E010               LDI     R17, 0
   \   00000004   930A               ST      -Y, R16
   \   00000006   930A               ST      -Y, R16
   \   00000008   E002               LDI     R16, 2
   \   0000000A   931A               ST      -Y, R17
   \   0000000C   930A               ST      -Y, R16
   \   0000000E   E508               LDI     R16, 88
   \   00000010   E012               LDI     R17, 2
   \   00000012   931A               ST      -Y, R17
   \   00000014   930A               ST      -Y, R16
   \   00000016   ....               LDI     R16, LOW(stack1)
   \   00000018   ....               LDI     R17, (stack1) >> 8
   \   0000001A   931A               ST      -Y, R17
   \   0000001C   930A               ST      -Y, R16
   \   0000001E   ....               LDI     R22, LOW(_16552_Rx_handler/2)
   \   00000020   ....               LDI     R23, (_16552_Rx_handler/2) >> 8
   \   00000022   E640               LDI     R20, 96
   \   00000024   ....               LDI     R18, LOW(`?<Constant "16552_RX_Handler 0">`)
   \   00000026   ....               LDI     R19, (`?<Constant "16552_RX_Handler 0">`) >> 8
   \   00000028   ....               LDI     R16, LOW(TCB_16552_RxHandler1)
   \   0000002A   ....               LDI     R17, (TCB_16552_RxHandler1) >> 8
   \   0000002C   ........           CALL    OS_CreateTaskEx_R
     59              OS_CREATETASK_EX(&TCB_16552_RxHandler2, "16552_RX_Handler 1", _16552_Rx_handler, 95, stack2, (void *)1);
   \   00000030   E001               LDI     R16, LOW(1)
   \   00000032   E010               LDI     R17, (1) >> 8
   \   00000034   931A               ST      -Y, R17
   \   00000036   930A               ST      -Y, R16
   \   00000038   E002               LDI     R16, 2
   \   0000003A   931A               ST      -Y, R17
   \   0000003C   930A               ST      -Y, R16
   \   0000003E   E508               LDI     R16, 88
   \   00000040   E012               LDI     R17, 2
   \   00000042   931A               ST      -Y, R17
   \   00000044   930A               ST      -Y, R16
   \   00000046   ....               LDI     R16, LOW(stack2)
   \   00000048   ....               LDI     R17, (stack2) >> 8
   \   0000004A   931A               ST      -Y, R17
   \   0000004C   930A               ST      -Y, R16
   \   0000004E   ....               LDI     R22, LOW(_16552_Rx_handler/2)
   \   00000050   ....               LDI     R23, (_16552_Rx_handler/2) >> 8
   \   00000052   E54F               LDI     R20, 95
   \   00000054   ....               LDI     R18, LOW((`?<Constant "16552_RX_Handler 0">` + 19))
   \   00000056   ....               LDI     R19, HIGH((`?<Constant "16552_RX_Handler 0">` + 19))
   \   00000058   ....               LDI     R16, LOW((TCB_16552_RxHandler1 + 20))
   \   0000005A   ....               LDI     R17, HIGH((TCB_16552_RxHandler1 + 20))
   \   0000005C   ........           JMP     OS_CreateTaskEx_R
     60          }
     61          #endif
     62          
     63          /*************************************************************************
     64          *
     65          *  External int 0 (UART PC16554 on AN-ZB485 or ADready on AN-ZBANA)
     66          *
     67          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     68          void Int_Handler_INT0(void) {               //Int handler for ext int 0
   \                     Int_Handler_INT0:
   \   00000000   924A               ST      -Y, R4
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R4_is_cg_reg
     69          
     70              // OBS!!!
     71              // Uses UART16552[].TxStatus as intreason and
     72              // UART16552[].TxSeqCnt as counter because these needs to be globale
     73              // by using OS_EnterIntStack()
     74          
     75          
     76              switch (UnitID) {
   \   0000000A   9100....           LDS     R16, UnitID
   \   0000000E   2300               TST     R16
   \   00000010   F021               BREQ    ??Int_Handler_INT0_0
   \   00000012   950A               DEC     R16
   \   00000014   F409               BRNE    $+2+2
   \   00000016   C07D               RJMP    ??Int_Handler_INT0_1
   \   00000018   C081               RJMP    ??Int_Handler_INT0_2
     77              case 0x00:                  // AN-ZB485
     78          #if USE_16552_DRIVER_TASK == 0
     79                  UART16552[0].TxStatus = (U0_IIR & 0x0f);          // reason for interrupt
     80                  do {
     81                      switch (UART16552[0].TxStatus) {
     82                      case 0x02 :             // transmit holding reg emty
     83                          if (UART16552[0].TxCount == 0) {
     84                              U0_MCR  &= ~RTS;        // set RTS off
     85                              UART16552[0].RxState = SYNC;
     86                              //OS_StopTimer(&TimerUART0);                    // and stop timer
     87                          } else {
     88                              for (UART16552[0].TxSeqCnt = 0; (UART16552[0].TxSeqCnt < FIFO_TX_BUFSIZE) && (UART16552[0].TxCount > 0); UART16552[0].TxSeqCnt++, --UART16552[0].TxCount) {
     89                                  U0_THR = UART16552[0].pTxBuffer[UART16552[0].TxLast++];
     90                              }
     91                          }
     92                          break;
     93                      case 0x04 :             // Receive data available
     94                      case 0x0C :             // or caracter timeout (FIFO)
     95                          if (UART16552[0].RxState == SEND) {
     96                              while (U0_LSR & DATA_READY) {
     97                                  U0_RBR;
     98                              }
     99                          } else while (U0_LSR & DATA_READY) {
    100                              UART16552[0].pRxBuffer[UART16552[0].RxFirst] = U0_RBR;             // Read the character
    101          
    102                              if (UART16552[0].RxState != HANDLE) {                 // ok to receive?
    103                                  switch (UART16552[0].RxState) {                   // Yes, check state
    104                                  case SYNC :
    105                                      if (UART16552[0].pRxBuffer[UART16552[0].RxFirst] == ANPRO1_SYN) {
    106                                          UART16552[0].SyncCnt++;                 // count sync
    107                                          UART16552[0].RxFirst = 0;                 // start at start of buff
    108                                      } else if (UART16552[0].SyncCnt >= 2) {       // minimum two sync bytes
    109                                          UART16552[0].SyncCnt = 0;                // reset counter
    110                                          UART16552[0].RxState = HEADER;
    111                                          UART16552[0].RxLast = 0;
    112                                          UART16552[0].RxTimeout = RX_TO_TIME;   // reset timeout
    113                                          UART16552[0].RxFirst++;                 //  1. char OK, start on next
    114                                          ReceivePacketUart16552(0);              // Check package
    115                                      } else {
    116                                          UART16552[0].SyncCnt = 0;                // start over once more
    117                                      }
    118                                      break;
    119                                  default :
    120                                      if ((++UART16552[0].RxFirst) > RXSIZE_UART_16552) { // Point to next location
    121                                          GoToSyncUART16552(0);                       // go to sync mode
    122                                      } else {
    123                                          ReceivePacketUart16552(0);              // Check package
    124                                      }
    125                                      break;
    126                                  }
    127                              }
    128                          }
    129                          break;
    130                      case 0x06 :                 // Receiver line status, OR, PE, FR, Break int.
    131                          U0_LSR;      // Dummy read to empty register
    132                          break;
    133                      case 0x00 :                 // Modem status.
    134                          U0_MSR;      // Dummy read to empty register
    135                          break;
    136                      }
    137                      UART16552[0].TxStatus = (U0_IIR & 0x0f);      // reason for interrupt,
    138                      // check again before exit to avoid lost int. and hang
    139                  } while ((UART16552[0].TxStatus & 0x01) != 0x01);
    140          #else
    141                  UART16552[0].TxStatus = (U0_IIR & IIR_MASK);          // reason for interrupt
   \                     ??Int_Handler_INT0_0:
   \   0000001A   9100220A           LDS     R16, 8714
   \   0000001E   700F               ANDI    R16, 0x0F
   \   00000020   9300....           STS     (UART16552 + 66), R16
   \   00000024   ....               LDI     R24, LOW((UART16552 + 194))
   \   00000026   ....               LDI     R25, HIGH((UART16552 + 194))
   \   00000028   E0AD               LDI     R26, LOW(8717)
   \   0000002A   E2B2               LDI     R27, (8717) >> 8
   \   0000002C   2444               CLR     R4
    142                  do {
    143                      switch (UART16552[0].TxStatus) {
   \                     ??Int_Handler_INT0_3:
   \   0000002E   9100....           LDS     R16, (UART16552 + 66)
   \   00000032   2300               TST     R16
   \   00000034   F409               BRNE    $+2+2
   \   00000036   C061               RJMP    ??Int_Handler_INT0_4
   \   00000038   5002               SUBI    R16, 2
   \   0000003A   F049               BREQ    ??Int_Handler_INT0_5
   \   0000003C   5002               SUBI    R16, 2
   \   0000003E   F409               BRNE    $+2+2
   \   00000040   C041               RJMP    ??Int_Handler_INT0_6
   \   00000042   5002               SUBI    R16, 2
   \   00000044   F409               BRNE    $+2+2
   \   00000046   C056               RJMP    ??Int_Handler_INT0_7
   \   00000048   5006               SUBI    R16, 6
   \   0000004A   F1E1               BREQ    ??Int_Handler_INT0_6
   \   0000004C   C058               RJMP    ??Int_Handler_INT0_8
    144                      case IIR_THRE :             // transmit holding reg emty
    145                          if (UART16552[0].TxCount == 0) {
   \                     ??Int_Handler_INT0_5:
   \   0000004E   9100....           LDS     R16, (UART16552 + 64)
   \   00000052   9110....           LDS     R17, (UART16552 + 65)
   \   00000056   2B01               OR      R16, R17
   \   00000058   F441               BRNE    ??Int_Handler_INT0_9
    146                              U0_MCR &= ~RTS;        // set RTS off
   \   0000005A   9100220C           LDS     R16, 8716
   \   0000005E   7F0D               ANDI    R16, 0xFD
   \   00000060   9300220C           STS     8716, R16
    147                              UART16552[0].RxState = SYNC;
   \   00000064   01FC               MOVW    R31:R30, R25:R24
   \   00000066   8240               ST      Z, R4
   \   00000068   C04A               RJMP    ??Int_Handler_INT0_8
    148                              //OS_StopTimer(&TimerUART0);                    // and stop timer
    149                          } else {
    150                              for (UART16552[0].TxSeqCnt = 0; (UART16552[0].TxSeqCnt < FIFO_TX_BUFSIZE) && (UART16552[0].TxCount > 0); UART16552[0].TxSeqCnt++, --UART16552[0].TxCount) {
   \                     ??Int_Handler_INT0_9:
   \   0000006A   9240....           STS     (UART16552 + 67), R4
   \                     ??Int_Handler_INT0_10:
   \   0000006E   9100....           LDS     R16, (UART16552 + 67)
   \   00000072   3100               CPI     R16, 16
   \   00000074   F008               BRCS    $+2+2
   \   00000076   C043               RJMP    ??Int_Handler_INT0_8
   \   00000078   9100....           LDS     R16, (UART16552 + 64)
   \   0000007C   9110....           LDS     R17, (UART16552 + 65)
   \   00000080   2B01               OR      R16, R17
   \   00000082   F1E9               BREQ    ??Int_Handler_INT0_8
    151                                  U0_THR = UART16552[0].pTxBuffer[UART16552[0].TxLast++];
   \   00000084   9100....           LDS     R16, (UART16552 + 62)
   \   00000088   9110....           LDS     R17, (UART16552 + 63)
   \   0000008C   01F8               MOVW    R31:R30, R17:R16
   \   0000008E   9631               ADIW    R31:R30, 1
   \   00000090   93E0....           STS     (UART16552 + 62), R30
   \   00000094   93F0....           STS     (UART16552 + 63), R31
   \   00000098   01F8               MOVW    R31:R30, R17:R16
   \   0000009A   ....               SUBI    R30, LOW((-(UART16552) & 0xFFFF))
   \   0000009C   ....               SBCI    R31, (-(UART16552) & 0xFFFF) >> 8
   \   0000009E   8100               LD      R16, Z
   \   000000A0   93002208           STS     8712, R16
    152                              }
   \   000000A4   9100....           LDS     R16, (UART16552 + 67)
   \   000000A8   9503               INC     R16
   \   000000AA   9300....           STS     (UART16552 + 67), R16
   \   000000AE   9100....           LDS     R16, (UART16552 + 64)
   \   000000B2   9110....           LDS     R17, (UART16552 + 65)
   \   000000B6   5001               SUBI    R16, 1
   \   000000B8   4010               SBCI    R17, 0
   \   000000BA   9300....           STS     (UART16552 + 64), R16
   \   000000BE   9310....           STS     (UART16552 + 65), R17
   \   000000C2   CFD5               RJMP    ??Int_Handler_INT0_10
    153                          }
    154                          break;
    155                      case IIR_TOUT:          // Receive data available
    156                      case IIR_RBRF:          // or caracter timeout (FIFO)
    157                          if (UART16552[0].RxState == SEND) {
   \                     ??Int_Handler_INT0_6:
   \   000000C4   01FC               MOVW    R31:R30, R25:R24
   \   000000C6   8100               LD      R16, Z
   \   000000C8   3003               CPI     R16, 3
   \   000000CA   F431               BRNE    ??Int_Handler_INT0_11
    158                              while (U0_LSR & DATA_READY) {
   \                     ??Int_Handler_INT0_12:
   \   000000CC   910C               LD      R16, X
   \   000000CE   FF00               SBRS    R16, 0
   \   000000D0   C016               RJMP    ??Int_Handler_INT0_8
    159                                  U0_RBR;
   \   000000D2   91002208           LDS     R16, 8712
   \   000000D6   CFFA               RJMP    ??Int_Handler_INT0_12
    160                              }
    161                          } else {
    162                              while (U0_LSR & DATA_READY) {
   \                     ??Int_Handler_INT0_11:
   \   000000D8   910C               LD      R16, X
   \   000000DA   FF00               SBRS    R16, 0
   \   000000DC   C010               RJMP    ??Int_Handler_INT0_8
    163                                  UART16552[0].RxByte = U0_RBR;    // Read the character
   \   000000DE   91002208           LDS     R16, 8712
   \   000000E2   01FC               MOVW    R31:R30, R25:R24
   \   000000E4   8700               STD     Z+8, R16
    164                                  OS_PutMailCond1(&UART16552[0].RxMailBox, &UART16552[0].RxByte);
   \   000000E6   ....               LDI     R18, LOW((UART16552 + 202))
   \   000000E8   ....               LDI     R19, HIGH((UART16552 + 202))
   \   000000EA   ....               LDI     R16, LOW((UART16552 + 253))
   \   000000EC   ....               LDI     R17, HIGH((UART16552 + 253))
   \   000000EE   ........           CALL    OS_PutMailCond1
   \   000000F2   CFF2               RJMP    ??Int_Handler_INT0_11
    165                              }
    166                          }
    167                          break;
    168                      case IIR_SEOB:   // Receiver line status, OR, PE, FR, Break int.
    169                          U0_LSR;      // Dummy read to empty register
   \                     ??Int_Handler_INT0_7:
   \   000000F4   9100220D           LDS     R16, 8717
    170                          break;
   \   000000F8   C002               RJMP    ??Int_Handler_INT0_8
    171                      case IIR_MSTAT :                 // Modem status.
    172                          U0_MSR;      // Dummy read to empty register
   \                     ??Int_Handler_INT0_4:
   \   000000FA   9100220E           LDS     R16, 8718
    173                          break;
    174                      }
    175                      UART16552[0].TxStatus = (U0_IIR & IIR_MASK);      // reason for interrupt,
   \                     ??Int_Handler_INT0_8:
   \   000000FE   9100220A           LDS     R16, 8714
   \   00000102   700F               ANDI    R16, 0x0F
   \   00000104   9300....           STS     (UART16552 + 66), R16
    176                      // check again before exit to avoid lost int. and hang
    177                  } while ((UART16552[0].TxStatus & 0x01) == 0x00);
   \   00000108   9100....           LDS     R16, (UART16552 + 66)
   \   0000010C   FD00               SBRC    R16, 0
   \   0000010E   C006               RJMP    ??Int_Handler_INT0_2
   \   00000110   CF8E               RJMP    ??Int_Handler_INT0_3
    178          
    179          #endif
    180                  break;
    181              case 0x01:                  // AN-ZBANA ADready
    182                  OS_SignalEvent(1, &TCB_AD7715);
   \                     ??Int_Handler_INT0_1:
   \   00000112   ....               LDI     R18, LOW(TCB_AD7715)
   \   00000114   ....               LDI     R19, (TCB_AD7715) >> 8
   \   00000116   E001               LDI     R16, 1
   \   00000118   ........           CALL    OS_SignalEvent
    183                  break;
    184              }
    185          }
   \                     ??Int_Handler_INT0_2:
   \   0000011C   9189               LD      R24, Y+
   \   0000011E   9199               LD      R25, Y+
   \   00000120   91A9               LD      R26, Y+
   \   00000122   91B9               LD      R27, Y+
   \   00000124   9049               LD      R4, Y+
   \   00000126   9508               RET
    186          
    187          
    188          #pragma vector=INT0_vect

   \                                 In  segment CODE, align 2, keep-with-next
    189          __interrupt void IntHandler_INT0(void) {               //Int handler for ext int 0
   \                     IntHandler_INT0:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    190              OS_CallISR(Int_Handler_INT0);
   \   00000024   ....               LDI     R16, LOW(Int_Handler_INT0/2)
   \   00000026   ....               LDI     R17, (Int_Handler_INT0/2) >> 8
   \   00000028                      REQUIRE ?Subroutine0
   \   00000028                      ;               // Fall through to label ?Subroutine0
    191          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   ........           CALL    OS_CallISR
   \   00000004   BF9B               OUT     0x3B, R25
   \   00000006   BF8F               OUT     0x3F, R24
   \   00000008   9109               LD      R16, Y+
   \   0000000A   9119               LD      R17, Y+
   \   0000000C   9129               LD      R18, Y+
   \   0000000E   9139               LD      R19, Y+
   \   00000010   9149               LD      R20, Y+
   \   00000012   9159               LD      R21, Y+
   \   00000014   9169               LD      R22, Y+
   \   00000016   9179               LD      R23, Y+
   \   00000018   9009               LD      R0, Y+
   \   0000001A   9019               LD      R1, Y+
   \   0000001C   9029               LD      R2, Y+
   \   0000001E   9039               LD      R3, Y+
   \   00000020   91E9               LD      R30, Y+
   \   00000022   91F9               LD      R31, Y+
   \   00000024   9189               LD      R24, Y+
   \   00000026   9199               LD      R25, Y+
   \   00000028   9518               RETI
    192          
    193          /*************************************************************************
    194          *
    195          *  External int 1 (UART PC16554 on AN-ZB485)
    196          *
    197          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    198          void Int_Handler_INT1(void) {               //Int handler for Ext int 1
   \                     Int_Handler_INT1:
   \   00000000   926A               ST      -Y, R6
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R6_is_cg_reg
    199          
    200              // OBS!!!
    201              // Uses UART16552[].TxStatus as int reason and
    202              // UART16552[].TxSeqCnt as counter because these needs to be globale
    203              // by using OS_EnterIntStack()
    204          
    205              switch (UnitID) {
   \   0000000A   9100....           LDS     R16, UnitID
   \   0000000E   2300               TST     R16
   \   00000010   F009               BREQ    $+2+2
   \   00000012   C075               RJMP    ??Int_Handler_INT1_0
    206              case 0x00:                  // AN-ZB485
    207          #if USE_16552_DRIVER_TASK == 0
    208                  UART16552[1].TxStatus = (U1_IIR & 0x0f);          // reason for interrupt
    209                  do {
    210                      switch (UART16552[1].TxStatus) {
    211                      case 0x02 :             // transmit holding reg emty
    212                          if (UART16552[1].TxCount == 0) {
    213                              U1_MCR &= ~RTS;        // set RTS off
    214                              UART16552[1].RxState = SYNC;
    215                              //OS_StopTimer(&TimerUART1);                    // and stop timer
    216                          } else {
    217                              for (UART16552[1].TxSeqCnt = 0; (UART16552[1].TxSeqCnt < FIFO_TX_BUFSIZE) && (UART16552[1].TxCount > 0); UART16552[1].TxSeqCnt++, UART16552[1].TxCount--) {
    218                                  U1_THR = UART16552[1].pTxBuffer[UART16552[1].TxLast++];
    219                              }
    220                          }
    221                          break;
    222                      case 0x04 :             // Receive data available
    223                      case 0x0C :             // or caracter timeout (FIFO)
    224                          if (UART16552[1].RxState == SEND) {
    225                              while (U1_LSR & DATA_READY) {
    226                                  U1_RBR;
    227                              }
    228                          } else while (U1_LSR & DATA_READY) {
    229                              UART16552[1].pRxBuffer[UART16552[1].RxFirst] = U1_RBR;             // Read the character
    230          
    231                              if (UART16552[1].RxState != HANDLE) {        // ok to receive?
    232                                  switch (UART16552[1].RxState) {                   // Yes, check state
    233                                  case SYNC :
    234                                      if (UART16552[1].pRxBuffer[UART16552[1].RxFirst] == ANPRO1_SYN) {
    235                                          UART16552[1].SyncCnt++;                 // count sync
    236                                          UART16552[1].RxFirst = 0;                 // start at start of buff
    237                                      } else if (UART16552[1].SyncCnt >= 2) {       // minimum two sync bytes
    238                                          UART16552[1].SyncCnt = 0;                // reset counter
    239                                          UART16552[1].RxState = HEADER;
    240                                          UART16552[1].RxLast = 0;
    241                                          UART16552[1].RxTimeout = RX_TO_TIME;     // reset timeout
    242                                          UART16552[1].RxFirst++;                  //  1. char OK, start on next
    243                                          ReceivePacketUart16552(1);               // Check package
    244                                      } else {
    245                                          UART16552[1].SyncCnt = 0;                // start over once more
    246                                      }
    247                                      break;
    248                                  default :
    249                                      if ((++UART16552[1].RxFirst) > RXSIZE_UART_16552) { // Point to next location
    250                                          GoToSyncUART16552(1);                       // go to sync mode
    251                                      } else {
    252                                          ReceivePacketUart16552(1);              // Check package
    253                                      }
    254                                      break;
    255                                  }
    256                              }
    257                          }
    258                          break;
    259                      case 0x06 :                 // Receiver line status, OR, PE, FR, Break int.
    260                          U1_LSR;      // Dummy read to empty register
    261                          break;
    262                      case 0x00 :                 // Modem status.
    263                          U1_MSR;      // Dummy read to empty register
    264                          break;
    265                      }
    266                      UART16552[1].TxStatus = (U1_IIR & 0x0f);      // reason for interrupt,
    267                      // check again before exit to avoid lost int. and hang
    268                  } while ((UART16552[1].TxStatus & 0x01) != 0x01);
    269          #else
    270                  UART16552[1].TxStatus = (U1_IIR & IIR_MASK);          // reason for interrupt
   \   00000014   ....               LDI     R26, LOW((UART16552 + 326))
   \   00000016   ....               LDI     R27, HIGH((UART16552 + 326))
   \   00000018   91002202           LDS     R16, 8706
   \   0000001C   700F               ANDI    R16, 0x0F
   \   0000001E   01FD               MOVW    R31:R30, R27:R26
   \   00000020   8304               STD     Z+4, R16
   \   00000022   ....               LDI     R24, LOW((UART16552 + 458))
   \   00000024   ....               LDI     R25, HIGH((UART16552 + 458))
   \   00000026   2466               CLR     R6
    271                  do {
    272                      switch (UART16552[1].TxStatus) {
   \                     ??Int_Handler_INT1_1:
   \   00000028   8104               LDD     R16, Z+4
   \   0000002A   2300               TST     R16
   \   0000002C   F409               BRNE    $+2+2
   \   0000002E   C05C               RJMP    ??Int_Handler_INT1_2
   \   00000030   5002               SUBI    R16, 2
   \   00000032   F041               BREQ    ??Int_Handler_INT1_3
   \   00000034   5002               SUBI    R16, 2
   \   00000036   F1C9               BREQ    ??Int_Handler_INT1_4
   \   00000038   5002               SUBI    R16, 2
   \   0000003A   F409               BRNE    $+2+2
   \   0000003C   C052               RJMP    ??Int_Handler_INT1_5
   \   0000003E   5006               SUBI    R16, 6
   \   00000040   F1A1               BREQ    ??Int_Handler_INT1_4
   \   00000042   C054               RJMP    ??Int_Handler_INT1_6
    273                      case IIR_THRE :             // transmit holding reg emty
    274                          if (UART16552[1].TxCount == 0) {
   \                     ??Int_Handler_INT1_3:
   \   00000044   8102               LDD     R16, Z+2
   \   00000046   8113               LDD     R17, Z+3
   \   00000048   2B01               OR      R16, R17
   \   0000004A   F441               BRNE    ??Int_Handler_INT1_7
    275                              U1_MCR &= ~RTS;        // set RTS off
   \   0000004C   91002204           LDS     R16, 8708
   \   00000050   7F0D               ANDI    R16, 0xFD
   \   00000052   93002204           STS     8708, R16
    276                              UART16552[1].RxState = SYNC;
   \   00000056   01FC               MOVW    R31:R30, R25:R24
   \   00000058   8260               ST      Z, R6
   \   0000005A   C048               RJMP    ??Int_Handler_INT1_6
    277                              //OS_StopTimer(&TimerUART0);                    // and stop timer
    278                          } else {
    279                              for (UART16552[1].TxSeqCnt = 0; (UART16552[1].TxSeqCnt < FIFO_TX_BUFSIZE) && (UART16552[1].TxCount > 0); UART16552[1].TxSeqCnt++, --UART16552[1].TxCount) {
   \                     ??Int_Handler_INT1_7:
   \   0000005C   8265               STD     Z+5, R6
   \                     ??Int_Handler_INT1_8:
   \   0000005E   01FD               MOVW    R31:R30, R27:R26
   \   00000060   8105               LDD     R16, Z+5
   \   00000062   3100               CPI     R16, 16
   \   00000064   F008               BRCS    $+2+2
   \   00000066   C042               RJMP    ??Int_Handler_INT1_6
   \   00000068   8102               LDD     R16, Z+2
   \   0000006A   8113               LDD     R17, Z+3
   \   0000006C   2B01               OR      R16, R17
   \   0000006E   F1F1               BREQ    ??Int_Handler_INT1_6
    280                                  U1_THR = UART16552[1].pTxBuffer[UART16552[1].TxLast++];
   \   00000070   8100               LD      R16, Z
   \   00000072   8111               LDD     R17, Z+1
   \   00000074   01F8               MOVW    R31:R30, R17:R16
   \   00000076   9631               ADIW    R31:R30, 1
   \   00000078   93ED               ST      X+, R30
   \   0000007A   93FC               ST      X, R31
   \   0000007C   9711               SBIW    R27:R26, 1
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   ....               SUBI    R30, LOW((-(UART16552 + 264) & 0xFFFF))
   \   00000082   ....               SBCI    R31, HIGH((-(UART16552 + 264) & 0xFFFF))
   \   00000084   8100               LD      R16, Z
   \   00000086   93002200           STS     8704, R16
    281                              }
   \   0000008A   9100....           LDS     R16, (UART16552 + 331)
   \   0000008E   9503               INC     R16
   \   00000090   9300....           STS     (UART16552 + 331), R16
   \   00000094   9100....           LDS     R16, (UART16552 + 328)
   \   00000098   9110....           LDS     R17, (UART16552 + 329)
   \   0000009C   5001               SUBI    R16, 1
   \   0000009E   4010               SBCI    R17, 0
   \   000000A0   9300....           STS     (UART16552 + 328), R16
   \   000000A4   9310....           STS     (UART16552 + 329), R17
   \   000000A8   CFDA               RJMP    ??Int_Handler_INT1_8
    282                          }
    283                          break;
    284                      case IIR_TOUT:          // Receive data available
    285                      case IIR_RBRF:          // or caracter timeout (FIFO)
    286                          if (UART16552[1].RxState == SEND) {
   \                     ??Int_Handler_INT1_4:
   \   000000AA   01FC               MOVW    R31:R30, R25:R24
   \   000000AC   8100               LD      R16, Z
   \   000000AE   3003               CPI     R16, 3
   \   000000B0   F441               BRNE    ??Int_Handler_INT1_9
    287                              while (U1_LSR & DATA_READY) {
   \                     ??Int_Handler_INT1_10:
   \   000000B2   E0E5               LDI     R30, LOW(8709)
   \   000000B4   E2F2               LDI     R31, (8709) >> 8
   \   000000B6   8100               LD      R16, Z
   \   000000B8   FF00               SBRS    R16, 0
   \   000000BA   C018               RJMP    ??Int_Handler_INT1_6
    288                                  U1_RBR;
   \   000000BC   91002200           LDS     R16, 8704
   \   000000C0   CFF8               RJMP    ??Int_Handler_INT1_10
    289                              }
    290                          } else {
    291                              while (U1_LSR & DATA_READY) {
   \                     ??Int_Handler_INT1_9:
   \   000000C2   E0E5               LDI     R30, LOW(8709)
   \   000000C4   E2F2               LDI     R31, (8709) >> 8
   \   000000C6   8100               LD      R16, Z
   \   000000C8   FF00               SBRS    R16, 0
   \   000000CA   C010               RJMP    ??Int_Handler_INT1_6
    292                                  UART16552[1].RxByte = U1_RBR;    // Read the character
   \   000000CC   91002200           LDS     R16, 8704
   \   000000D0   01FC               MOVW    R31:R30, R25:R24
   \   000000D2   8700               STD     Z+8, R16
    293                                  OS_PutMailCond1(&UART16552[1].RxMailBox, &UART16552[1].RxByte);
   \   000000D4   ....               LDI     R18, LOW((UART16552 + 466))
   \   000000D6   ....               LDI     R19, HIGH((UART16552 + 466))
   \   000000D8   ....               LDI     R16, LOW((UART16552 + 517))
   \   000000DA   ....               LDI     R17, HIGH((UART16552 + 517))
   \   000000DC   ........           CALL    OS_PutMailCond1
   \   000000E0   CFF0               RJMP    ??Int_Handler_INT1_9
    294                              }
    295                          }
    296                          break;
    297                      case IIR_SEOB:   // Receiver line status, OR, PE, FR, Break int.
    298                          U1_LSR;      // Dummy read to empty register
   \                     ??Int_Handler_INT1_5:
   \   000000E2   91002205           LDS     R16, 8709
    299                          break;
   \   000000E6   C002               RJMP    ??Int_Handler_INT1_6
    300                      case IIR_MSTAT :                 // Modem status.
    301                          U1_MSR;      // Dummy read to empty register
   \                     ??Int_Handler_INT1_2:
   \   000000E8   91002206           LDS     R16, 8710
    302                          break;
    303                      }
    304                      UART16552[1].TxStatus = (U1_IIR & IIR_MASK);      // reason for interrupt,
   \                     ??Int_Handler_INT1_6:
   \   000000EC   91002202           LDS     R16, 8706
   \   000000F0   700F               ANDI    R16, 0x0F
   \   000000F2   01FD               MOVW    R31:R30, R27:R26
   \   000000F4   8304               STD     Z+4, R16
    305                      // check again before exit to avoid lost int. and hang
    306                  } while ((UART16552[1].TxStatus & 0x01) == 0x00);
   \   000000F6   9100....           LDS     R16, (UART16552 + 330)
   \   000000FA   FF00               SBRS    R16, 0
   \   000000FC   CF95               RJMP    ??Int_Handler_INT1_1
    307          #endif
    308                  break;
    309              case 0x01:                  // AN-ZBANA Not connected!
    310                  break;
    311              }
    312          }
   \                     ??Int_Handler_INT1_0:
   \   000000FE   9189               LD      R24, Y+
   \   00000100   9199               LD      R25, Y+
   \   00000102   91A9               LD      R26, Y+
   \   00000104   91B9               LD      R27, Y+
   \   00000106   9069               LD      R6, Y+
   \   00000108   9508               RET
    313          
    314          
    315          #pragma vector=INT1_vect

   \                                 In  segment CODE, align 2, keep-with-next
    316          __interrupt void IntHandler_INT1(void) {               //Int handler for Ext int 1
   \                     IntHandler_INT1:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    317          
    318              OS_CallISR(Int_Handler_INT1);
   \   00000024   ....               LDI     R16, LOW(Int_Handler_INT1/2)
   \   00000026   ....               LDI     R17, (Int_Handler_INT1/2) >> 8
   \   00000028   ....               RJMP    ?Subroutine0
    319          }

   \                                 In  segment INTVEC, offset 0x4, root
   \                     `??IntHandler_INT0::??INTVEC 4`:
   \   00000004   ........           JMP     IntHandler_INT0

   \                                 In  segment INTVEC, offset 0x8, root
   \                     `??IntHandler_INT1::??INTVEC 8`:
   \   00000008   ........           JMP     IntHandler_INT1

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "16552_RX_Handler `:
   \   00000000   363135355F32       DC8 "16552_RX_Handler 0"
   \              5852485F6E61
   \              6C6472653020
   \              00          
   \                     `?<Initializer for <Constant "16552_RX_Handler _1`:
   \   00000013   363135355F32       DC8 "16552_RX_Handler 1"
   \              5852485F6E61
   \              6C6472653120
   \              00          

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant "16552_RX_Handler 0">`:
   \   00000000                      DS8 19
   \   00000013                      REQUIRE `?<Initializer for <Constant "16552_RX_Handler `
   \   00000013                      DS8 19
   \   00000026                      REQUIRE `?<Initializer for <Constant "16552_RX_Handler _1`

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
     16      2   IntHandler_INT0
       16      2   -> OS_CallISR
     16      2   IntHandler_INT1
       16      2   -> OS_CallISR
      5      2   Int_Handler_INT0
        5      2   -> OS_PutMailCond1
        5      2   -> OS_SignalEvent
      5      2   Int_Handler_INT1
        5      2   -> OS_PutMailCond1
     12      2   _16552_Rx_handler
       12      2   -> GoToSyncUART16552
       12      2   -> OS_GetMail1
       12      2   -> OS_WaitEvent
       12      2   -> ReceivePacketUart16552
      8      2   _16552_driver_task_init
        0      2   -> OS_CreateTaskEx_R


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      38  ?<Constant "16552_RX_Handler 0">
      38  ?<Initializer for <Constant "16552_RX_Handler
      42  ?Subroutine0
      40  IntHandler_INT0
       4  IntHandler_INT0::??INTVEC 4
      42  IntHandler_INT1
       4  IntHandler_INT1::??INTVEC 8
     296  Int_Handler_INT0
     266  Int_Handler_INT1
      40  TCB_16552_RxHandler1
          TCB_16552_RxHandler2
     220  _16552_Rx_handler
      96  _16552_driver_task_init
     600  stack1
     600  stack2
      14  -- Other

 
 1 002 bytes in segment CODE
    14 bytes in segment INITTAB
     8 bytes in segment INTVEC
    38 bytes in segment NEAR_I
    38 bytes in segment NEAR_ID
 1 240 bytes in segment NEAR_Z
 
 1 040 bytes of CODE memory (+ 22 bytes shared)
 1 278 bytes of DATA memory

Errors: none
Warnings: 1
