###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       08/Feb/2024  10:48:55
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\init.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWA60E.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\init.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj" -D
#        OS_LIBMODE_R -D OS_UART=-1 -D USE_16552_DRIVER_TASK=1 -D
#        USE_1281_RX_INT_TASK=1 -D USE_MODBUS_PROTOCOL=0 -D ANZBANA_V8=0 -D
#        __ATMEGA_1281__ -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List" -y
#        --initializers_in_flash -DENABLE_BIT_DEFINITIONS -e -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -Ohs)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List\init.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj\init.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\init.c
      1          /****************************************************************************************
      2          / Init the project
      3          /
      4          ***************************************************************************************/
      5          #ifdef __ATMEGA_1280__
      6          #include	"iom1280.h"
      7          #endif
      8          
      9          #ifdef __ATMEGA_1281__
     10          #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0xcc
   \   union <unnamed> volatile __io _A_UBRR1
   \                     _A_UBRR1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xca
   \   union <unnamed> volatile __io _A_UCSR1C
   \                     _A_UCSR1C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc9
   \   union <unnamed> volatile __io _A_UCSR1B
   \                     _A_UCSR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc8
   \   union <unnamed> volatile __io _A_UCSR1A
   \                     _A_UCSR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc4
   \   union <unnamed> volatile __io _A_UBRR0
   \                     _A_UBRR0:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xc2
   \   union <unnamed> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   union <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb3
   \   union <unnamed> volatile __io _A_OCR2A
   \                     _A_OCR2A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb1
   \   union <unnamed> volatile __io _A_TCCR2B
   \                     _A_TCCR2B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb0
   \   union <unnamed> volatile __io _A_TCCR2A
   \                     _A_TCCR2A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7c
   \   union <unnamed> volatile __io _A_ADMUX
   \                     _A_ADMUX:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7a
   \   union <unnamed> volatile __io _A_ADCSRA
   \                     _A_ADCSRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x75
   \   union <unnamed> volatile __io _A_XMCRB
   \                     _A_XMCRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x74
   \   union <unnamed> volatile __io _A_XMCRA
   \                     _A_XMCRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6a
   \   union <unnamed> volatile __io _A_EICRB
   \                     _A_EICRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x69
   \   union <unnamed> volatile __io _A_EICRA
   \                     _A_EICRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x55
   \   union <unnamed> volatile __io _A_MCUCR
   \                     _A_MCUCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x54
   \   union <unnamed> volatile __io _A_MCUSR
   \                     _A_MCUSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4d
   \   union <unnamed> volatile __io _A_SPSR
   \                     _A_SPSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4c
   \   union <unnamed> volatile __io _A_SPCR
   \                     _A_SPCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   union <unnamed> volatile __io _A_EIMSK
   \                     _A_EIMSK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   union <unnamed> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33
   \   union <unnamed> volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   union <unnamed> volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   union <unnamed> volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d
   \   union <unnamed> volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   union <unnamed> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x28
   \   union <unnamed> volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   union <unnamed> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   union <unnamed> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   union <unnamed> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x23
   \   union <unnamed> volatile __io _A_PINB
   \                     _A_PINB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x22
   \   union <unnamed> volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21
   \   union <unnamed> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1
     11          #endif
     12          #include "stdio.h"
     13          #include "math.h"
     14          #include "externals.h"
     15          #include "version.h"
     16          #include "inavr.h"
     17          #include "string.h"
     18          
     19          /*
     20          **===========================================================================
     21          ** Init the system according to board type
     22          **===========================================================================
     23          */ 

   \                                 In  segment CODE, align 2, keep-with-next
     24          void InitSystem(void) {
   \                     InitSystem:
     25          #if ANZBANA_V8 == 1
     26              DDRA    =  0x00 ;      // Port B data direction, bit 0, 4-7 out
     27              PORTA   =  0x3;
     28              UnitID  = PINA & 0x03;       //get the unit ID
     29          #else
     30              DDRB    =  0x00 ;      // Port B data direction, bit 0, 4-7 out
   \   00000000   E000               LDI     R16, 0
   \   00000002   B904               OUT     0x04, R16
     31          //    PORTB   =  0xc;
     32              UnitID  = (PINB >> 2)& 0x03;       //get the unit ID
   \   00000004   B103               IN      R16, 0x03
   \   00000006   9506               LSR     R16
   \   00000008   9506               LSR     R16
   \   0000000A   7003               ANDI    R16, 0x03
   \   0000000C   9300....           STS     UnitID, R16
     33          #endif
     34          #if (OS_UART == 0)
     35              UnitID = 0x00; //AStmark  for test
     36          #endif
     37          
     38              Init_CPU();                         // init all processes
   \   00000010   94F8               CLI
   \   00000012   9110....           LDS     R17, UnitID
   \   00000016   F071               BREQ    ??InitSystem_0
   \   00000018   950A               DEC     R16
   \   0000001A   F4D9               BRNE    ??InitSystem_1
   \   0000001C   E000               LDI     R16, 0
   \   0000001E   BF05               OUT     0x35, R16
   \   00000020   BB0D               OUT     0x1D, R16
   \   00000022   EA0A               LDI     R16, 170
   \   00000024   9300....           STS     _A_EICRA, R16
   \   00000028   9300....           STS     _A_EICRB, R16
   \   0000002C   E001               LDI     R16, 1
   \   0000002E   BB0D               OUT     0x1D, R16
   \   00000030   E000               LDI     R16, 0
   \   00000032   C00D               RJMP    ??InitSystem_2
   \                     ??InitSystem_0:
   \   00000034   EC00               LDI     R16, 192
   \   00000036   BF05               OUT     0x35, R16
   \   00000038   E000               LDI     R16, 0
   \   0000003A   BB0D               OUT     0x1D, R16
   \   0000003C   EA0F               LDI     R16, 175
   \   0000003E   9300....           STS     _A_EICRA, R16
   \   00000042   EA0A               LDI     R16, 170
   \   00000044   9300....           STS     _A_EICRB, R16
   \   00000048   E003               LDI     R16, 3
   \   0000004A   BB0D               OUT     0x1D, R16
   \   0000004C   E800               LDI     R16, 128
   \                     ??InitSystem_2:
   \   0000004E   9300....           STS     _A_XMCRA, R16
   \                     ??InitSystem_1:
   \   00000052   E007               LDI     R16, 7
   \   00000054   9300....           STS     _A_XMCRB, R16
   \   00000058   B704               IN      R16, 0x34
   \   0000005A   9300....           STS     RestartStatus, R16
   \   0000005E   E000               LDI     R16, 0
   \   00000060   BF04               OUT     0x34, R16
   \   00000062   9300....           STS     WriteCount, R16
     39              Init_IO();
   \   00000066   2F01               MOV     R16, R17
   \   00000068   2311               TST     R17
   \   0000006A   F0E9               BREQ    ??InitSystem_3
   \   0000006C   950A               DEC     R16
   \   0000006E   F009               BREQ    $+2+2
   \   00000070   C053               RJMP    ??InitSystem_4
   \   00000072   E000               LDI     R16, 0
   \   00000074   B901               OUT     0x01, R16
   \   00000076   B902               OUT     0x02, R16
   \   00000078   EF01               LDI     R16, 241
   \   0000007A   B904               OUT     0x04, R16
   \   0000007C   E000               LDI     R16, 0
   \   0000007E   B905               OUT     0x05, R16
   \   00000080   EF0F               LDI     R16, 255
   \   00000082   B907               OUT     0x07, R16
   \   00000084   E000               LDI     R16, 0
   \   00000086   B908               OUT     0x08, R16
   \   00000088   E002               LDI     R16, 2
   \   0000008A   B90A               OUT     0x0A, R16
   \   0000008C   EF01               LDI     R16, 241
   \   0000008E   B90B               OUT     0x0B, R16
   \   00000090   EF0E               LDI     R16, 254
   \   00000092   B90D               OUT     0x0D, R16
   \   00000094   E000               LDI     R16, 0
   \   00000096   B90E               OUT     0x0E, R16
   \   00000098   BB00               OUT     0x10, R16
   \   0000009A   BB01               OUT     0x11, R16
   \   0000009C   E100               LDI     R16, 16
   \   0000009E   BB03               OUT     0x13, R16
   \   000000A0   E000               LDI     R16, 0
   \   000000A2   BB04               OUT     0x14, R16
   \   000000A4   C03D               RJMP    ??InitSystem_5
   \                     ??InitSystem_3:
   \   000000A6   EF0F               LDI     R16, 255
   \   000000A8   B901               OUT     0x01, R16
   \   000000AA   E000               LDI     R16, 0
   \   000000AC   B902               OUT     0x02, R16
   \   000000AE   E100               LDI     R16, 16
   \   000000B0   B904               OUT     0x04, R16
   \   000000B2   E000               LDI     R16, 0
   \   000000B4   B905               OUT     0x05, R16
   \   000000B6   EF0F               LDI     R16, 255
   \   000000B8   B907               OUT     0x07, R16
   \   000000BA   E000               LDI     R16, 0
   \   000000BC   B908               OUT     0x08, R16
   \   000000BE   B90A               OUT     0x0A, R16
   \   000000C0   EF0F               LDI     R16, 255
   \   000000C2   B90B               OUT     0x0B, R16
   \   000000C4   EF0E               LDI     R16, 254
   \   000000C6   B90D               OUT     0x0D, R16
   \   000000C8   EF00               LDI     R16, 240
   \   000000CA   B90E               OUT     0x0E, R16
   \   000000CC   E000               LDI     R16, 0
   \   000000CE   BB00               OUT     0x10, R16
   \   000000D0   BB01               OUT     0x11, R16
   \   000000D2   E007               LDI     R16, 7
   \   000000D4   BB03               OUT     0x13, R16
   \   000000D6   E003               LDI     R16, 3
   \   000000D8   BB04               OUT     0x14, R16
   \                     ??InitSystem_6:
   \   000000DA   E402               LDI     R16, 66
   \   000000DC   9300....           STS     _A_TCCR2A, R16
   \   000000E0   E801               LDI     R16, 129
   \   000000E2   9300....           STS     _A_TCCR2B, R16
   \   000000E6   E003               LDI     R16, 3
   \                     ??InitSystem_7:
   \   000000E8   9300....           STS     _A_OCR2A, R16
     40              Init_TMR() ;
     41              Init_AD();
   \                     ??InitSystem_8:
   \   000000EC   ....               LDI     R30, LOW(ADInt)
   \   000000EE   ....               LDI     R31, (ADInt) >> 8
   \   000000F0   E008               LDI     R16, 8
   \   000000F2   E020               LDI     R18, 0
   \                     ??InitSystem_9:
   \   000000F4   9321               ST      Z+, R18
   \   000000F6   9321               ST      Z+, R18
   \   000000F8   950A               DEC     R16
   \   000000FA   F7E1               BRNE    ??InitSystem_9
   \   000000FC   9320....           STS     ADChannel, R18
   \   00000100   EC00               LDI     R16, 192
   \   00000102   9300....           STS     _A_ADMUX, R16
   \   00000106   E80F               LDI     R16, 143
   \   00000108   9300....           STS     _A_ADCSRA, R16
     42              Init_Values();                      // init the values in the system
     43          
     44              // 128 -> 1281
     45              // ADCSR |= 0x40 ;                     //start the AD convertion
     46              ADCSRA |= 0x40 ;
   \   0000010C   9100007A           LDS     R16, 122
   \   00000110   6400               ORI     R16, 0x40
   \   00000112   9300007A           STS     122, R16
     47          }
   \   00000116   9508               RET
   \                     ??InitSystem_4:
   \   00000118   2311               TST     R17
   \   0000011A   F2F9               BREQ    ??InitSystem_6
   \   0000011C   951A               DEC     R17
   \   0000011E   F731               BRNE    ??InitSystem_8
   \                     ??InitSystem_5:
   \   00000120   E402               LDI     R16, 66
   \   00000122   9300....           STS     _A_TCCR2A, R16
   \   00000126   E801               LDI     R16, 129
   \   00000128   9300....           STS     _A_TCCR2B, R16
   \   0000012C   E007               LDI     R16, 7
   \   0000012E   CFDC               RJMP    ??InitSystem_7
   \   00000130                      REQUIRE _A_DDRB
   \   00000130                      REQUIRE _A_PINB
   \   00000130                      REQUIRE _A_ADCSRA
   \   00000130                      REQUIRE _A_TCCR2A
   \   00000130                      REQUIRE _A_TCCR2B
   \   00000130                      REQUIRE _A_OCR2A
   \   00000130                      REQUIRE _A_ADMUX
   \   00000130                      REQUIRE _A_MCUCR
   \   00000130                      REQUIRE _A_EIMSK
   \   00000130                      REQUIRE _A_EICRA
   \   00000130                      REQUIRE _A_EICRB
   \   00000130                      REQUIRE _A_XMCRA
   \   00000130                      REQUIRE _A_XMCRB
   \   00000130                      REQUIRE _A_MCUSR
   \   00000130                      REQUIRE _A_DDRA
   \   00000130                      REQUIRE _A_PORTA
   \   00000130                      REQUIRE _A_PORTB
   \   00000130                      REQUIRE _A_DDRC
   \   00000130                      REQUIRE _A_PORTC
   \   00000130                      REQUIRE _A_DDRD
   \   00000130                      REQUIRE _A_PORTD
   \   00000130                      REQUIRE _A_DDRE
   \   00000130                      REQUIRE _A_PORTE
   \   00000130                      REQUIRE _A_DDRF
   \   00000130                      REQUIRE _A_PORTF
   \   00000130                      REQUIRE _A_DDRG
   \   00000130                      REQUIRE _A_PORTG
     48          
     49          /*
     50          **===========================================================================
     51          ** Init the CPU related registers
     52          **===========================================================================
     53          */ 

   \                                 In  segment CODE, align 2, keep-with-next
     54          void Init_CPU( void ) {
   \                     Init_CPU:
     55          
     56              __disable_interrupt();
   \   00000000   94F8               CLI
     57          
     58              /*--- Configure CPU and interrupts ---*/
     59              switch (UnitID) {
   \   00000002   9100....           LDS     R16, UnitID
   \   00000006   2300               TST     R16
   \   00000008   F019               BREQ    ??Init_CPU_0
   \   0000000A   950A               DEC     R16
   \   0000000C   F079               BREQ    ??Init_CPU_1
   \   0000000E   C01B               RJMP    ??Init_CPU_2
     60              case AN_ZB485:                  // AN-ZB485 
     61                  MCUCR = 0xc0 ;        // MCU control register  External Ram + wait state
   \                     ??Init_CPU_0:
   \   00000010   EC00               LDI     R16, 192
   \   00000012   BF05               OUT     0x35, R16
     62                  EIMSK = 0x00 ;        // External interrupt mask register, all off
   \   00000014   E000               LDI     R16, 0
   \   00000016   BB0D               OUT     0x1D, R16
     63                  EICRA = 0xAf ;        // External interrupt control register, 0,1 raising, rest faling
   \   00000018   EA0F               LDI     R16, 175
   \   0000001A   9300....           STS     _A_EICRA, R16
     64                  EICRB = 0xAA ;        // External interrupt control register 
   \   0000001E   EA0A               LDI     R16, 170
   \   00000020   9300....           STS     _A_EICRB, R16
     65                  EIMSK = 0x03 ;        // External interrupt mask register, int 0 and 1 on 
   \   00000024   E003               LDI     R16, 3
   \   00000026   BB0D               OUT     0x1D, R16
     66                  XMCRA = 0x80;         // maximum wait states
   \   00000028   E800               LDI     R16, 128
   \   0000002A   C00B               RJMP    ??Init_CPU_3
     67                  break;
     68              case AN_ZBANA:                  // AN-ZBANA
     69                  MCUCR = 0x00 ;        // MCU control register wait state
   \                     ??Init_CPU_1:
   \   0000002C   E000               LDI     R16, 0
   \   0000002E   BF05               OUT     0x35, R16
     70                  EIMSK = 0x00 ;        // External interrupt mask register , all off
   \   00000030   BB0D               OUT     0x1D, R16
     71                  EICRA = 0xAA ;        // External interrupt control register, o on faling edge
   \   00000032   EA0A               LDI     R16, 170
   \   00000034   9300....           STS     _A_EICRA, R16
     72                  EICRB = 0xAA ;        // External interrupt control register 
   \   00000038   9300....           STS     _A_EICRB, R16
     73                  EIMSK = 0x01 ;        // External interrupt mask register, int 0 on
   \   0000003C   E001               LDI     R16, 1
   \   0000003E   BB0D               OUT     0x1D, R16
     74                  XMCRA = 0x00 ;        // maximum wait states
   \   00000040   E000               LDI     R16, 0
   \                     ??Init_CPU_3:
   \   00000042   9300....           STS     _A_XMCRA, R16
     75                  break;
     76              }
     77              // XMCRA = 0x00; // maximum wait states
     78              XMCRB = 0x07 ;       // Full portC + bus keeper
   \                     ??Init_CPU_2:
   \   00000046   E007               LDI     R16, 7
   \   00000048   9300....           STS     _A_XMCRB, R16
     79              //
     80              // hkim
     81              // are you fucking out of mind?
     82              // why do you enable global interrupt here?
     83              //
     84              // SREG = 0x80;  // global interrupt
     85          
     86              //
     87              // 128 -> 1281
     88              // No XDIV in 1281. CLKPR instead.
     89              // Anyway No need to do this.
     90              //XDIV  = 0x00 ;     // Init valuse used 0x00
     91          
     92              // 128 -> 1281
     93              // register name change
     94              // RestartStatus = MCUCSR;       // Remember reset source
     95              RestartStatus = MCUSR;
   \   0000004C   B704               IN      R16, 0x34
   \   0000004E   9300....           STS     RestartStatus, R16
     96              MCUSR = 0x00; // and reset
   \   00000052   E000               LDI     R16, 0
   \   00000054   BF04               OUT     0x34, R16
     97              /*--- Initialize buffer ---*/
     98              WriteCount = 0;
   \   00000056   9300....           STS     WriteCount, R16
     99          
    100          }
   \   0000005A   9508               RET
   \   0000005C                      REQUIRE _A_MCUCR
   \   0000005C                      REQUIRE _A_EIMSK
   \   0000005C                      REQUIRE _A_EICRA
   \   0000005C                      REQUIRE _A_EICRB
   \   0000005C                      REQUIRE _A_XMCRA
   \   0000005C                      REQUIRE _A_XMCRB
   \   0000005C                      REQUIRE _A_MCUSR
    101          
    102          /*
    103          **===========================================================================
    104          ** Init the watchdog registers
    105          **===========================================================================
    106          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    107          __monitor void Init_Watchdog( void ) {
   \                     Init_Watchdog:
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002   94F8               CLI
    108          
    109              asm("WDR");                             // kick the dog!!
   \   00000004   95A8               WDR
    110              // 128 -> 1281
    111              // WDTCR = 0x0f;
    112              WDTCSR = 0x0f;
   \   00000006   E00F               LDI     R16, 15
   \   00000008   9300....           STS     _A_WDTCSR, R16
    113              asm("WDR");                             // kick the dog!!
   \   0000000C   95A8               WDR
    114          
    115          }
   \   0000000E   BF1F               OUT     0x3F, R17
   \   00000010   9508               RET
   \   00000012                      REQUIRE _A_WDTCSR
    116          
    117          /*
    118          **===========================================================================
    119          ** Init the IO related registers
    120          **===========================================================================
    121          */ 
    122          
    123          

   \                                 In  segment CODE, align 2, keep-with-next
    124          void SPI_Init()					/* SPI Initialize function */
   \                     SPI_Init:
    125          {
    126          
    127              // SPI initialization
    128              // SPI Type: Master
    129              // SPI Clock Rate: 125,000 kHz
    130              // SPI Clock Phase: Cycle Half
    131              // SPI Clock Polarity: High
    132              // SPI Data Order: MSB First
    133              //SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);	/* Enable SPI in master mode with Fosc/16 */
    134              SPCR=(0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (1<<SPR1) | (1<<SPR0);
   \   00000000   E50F               LDI     R16, 95
   \   00000002   BD0C               OUT     0x2C, R16
    135              //SPSR=(0<<SPI2X);
    136              SPSR &= ~(1<<SPI2X);			/* Disable speed doubler */
   \   00000004   B50D               IN      R16, 0x2D
   \   00000006   7F0E               ANDI    R16, 0xFE
   \   00000008   BD0D               OUT     0x2D, R16
    137          }
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_SPCR
   \   0000000C                      REQUIRE _A_SPSR
    138          

   \                                 In  segment CODE, align 2, keep-with-next
    139          void Init_IO( void ) {
   \                     Init_IO:
    140          
    141              /*--- Initialize the data registers, output value and input pullup ---*/
    142              switch (UnitID) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   2300               TST     R16
   \   00000006   F019               BREQ    ??Init_IO_0
   \   00000008   950A               DEC     R16
   \   0000000A   F0D9               BREQ    ??Init_IO_1
   \   0000000C   9508               RET
    143              case AN_ZB485:                  // AN-ZB485  
    144                  DDRA   =  0xff ;      // Port A data direction (out), external bus
   \                     ??Init_IO_0:
   \   0000000E   EF0F               LDI     R16, 255
   \   00000010   B901               OUT     0x01, R16
    145                  PORTA  =  0x00 ;      // Port A data
   \   00000012   E000               LDI     R16, 0
   \   00000014   B902               OUT     0x02, R16
    146                  DDRB   =  0x10 ;      // Port B data direction, bit 0, 4-7 out
   \   00000016   E100               LDI     R16, 16
   \   00000018   B904               OUT     0x04, R16
    147                  PORTB  =  0x00 ;      // Port B data   
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   B905               OUT     0x05, R16
    148                  DDRC   =  0xff ;      // Port C data direction, all out
   \   0000001E   EF0F               LDI     R16, 255
   \   00000020   B907               OUT     0x07, R16
    149                  PORTC  =  0x00 ;      // Port C data
   \   00000022   E000               LDI     R16, 0
   \   00000024   B908               OUT     0x08, R16
    150                  DDRD   =  0x00 ;      // Port D data direction, all in except output to osc and txd
   \   00000026   B90A               OUT     0x0A, R16
    151                  PORTD  =  0xff ;      // Port D data pullup on int fro AD
   \   00000028   EF0F               LDI     R16, 255
   \   0000002A   B90B               OUT     0x0B, R16
    152                  DDRE   =  0xFE ;      // Port E data direction, all out except rxd
   \   0000002C   EF0E               LDI     R16, 254
   \   0000002E   B90D               OUT     0x0D, R16
    153                  PORTE  =  0xf0 ;      // Port E data 
   \   00000030   EF00               LDI     R16, 240
   \   00000032   B90E               OUT     0x0E, R16
    154                  DDRF   =  0x00 ;      // Port F data direction, used for ADC
   \   00000034   E000               LDI     R16, 0
   \   00000036   BB00               OUT     0x10, R16
    155                  PORTF  =  0x00 ;      // Port F data 
   \   00000038   BB01               OUT     0x11, R16
    156                  DDRG   =  0x07 ;      // Port G data direction, port 1,2,3 out
   \   0000003A   E007               LDI     R16, 7
   \   0000003C   BB03               OUT     0x13, R16
    157                  PORTG  =  0x03 ;      // Port G data 
   \   0000003E   E003               LDI     R16, 3
   \   00000040   C018               RJMP    ??Init_IO_2
    158                  break;
    159              case AN_ZBANA:                  // AN-ZBANA
    160          #if ANZBANA_V8 == 1
    161                  DDRA   =  0x00 ;      // Port A data direction in ID0, ID1
    162                  PORTA  =  0x03 ;      // Port A data
    163                  DDRB   =  0xF7 ;      // Port B data direction, bit 2 in, bit 0-1 and 3-7 out
    164                  PORTB  =  0x08 ;      // Port B data  Pin 3 pull-up 
    165                  DDRC   =  0xFF ;      // Port C data direction, all out
    166                  PORTC  =  0x00 ;      // Port C data
    167                  DDRD   =  0x02 ;      // Port D data direction, all in except output to ADC CLC
    168                  PORTD  =  0xf1 ;      // Port D data pullup on int fro AD and ADC CLC
    169                  DDRE   =  0xFE ;      // Port E data direction, all out except rxd
    170                  PORTE  =  0x00 ;      // Port E data 
    171                  DDRF   =  0x00 ;      // Port F data direction, used for ADC
    172                  PORTF  =  0x00 ;      // Port F data 
    173                  DDRG   =  0x08 ;      // Port G data direction, bit 3 out
    174                  PORTG  =  0x30 ;      // Port G data pullup PG4, PG5 
    175                  SPI_Init();
    176          #else
    177                  DDRA   =  0x00 ;      // Port A data direction in (not used)
   \                     ??Init_IO_1:
   \   00000042   E000               LDI     R16, 0
   \   00000044   B901               OUT     0x01, R16
    178                  PORTA  =  0x00 ;      // Port A data
   \   00000046   B902               OUT     0x02, R16
    179                  DDRB   =  0xF1 ;      // Port B data direction, bit 0, 4-7 out
   \   00000048   EF01               LDI     R16, 241
   \   0000004A   B904               OUT     0x04, R16
    180                  PORTB  =  0x00 ;      // Port B data   
   \   0000004C   E000               LDI     R16, 0
   \   0000004E   B905               OUT     0x05, R16
    181                  DDRC   =  0xFF ;      // Port C data direction, all out
   \   00000050   EF0F               LDI     R16, 255
   \   00000052   B907               OUT     0x07, R16
    182                  PORTC  =  0x00 ;      // Port C data
   \   00000054   E000               LDI     R16, 0
   \   00000056   B908               OUT     0x08, R16
    183                  DDRD   =  0x02 ;      // Port D data direction, all in except output to osc and txd
   \   00000058   E002               LDI     R16, 2
   \   0000005A   B90A               OUT     0x0A, R16
    184                  PORTD  =  0xf1 ;      // Port D data pullup on int fro AD
   \   0000005C   EF01               LDI     R16, 241
   \   0000005E   B90B               OUT     0x0B, R16
    185                  DDRE   =  0xFE ;      // Port E data direction, all out except rxd
   \   00000060   EF0E               LDI     R16, 254
   \   00000062   B90D               OUT     0x0D, R16
    186                  PORTE  =  0x00 ;      // Port E data 
   \   00000064   E000               LDI     R16, 0
   \   00000066   B90E               OUT     0x0E, R16
    187                  DDRF   =  0x00 ;      // Port F data direction, used for ADC
   \   00000068   BB00               OUT     0x10, R16
    188                  PORTF  =  0x00 ;      // Port F data 
   \   0000006A   BB01               OUT     0x11, R16
    189                  DDRG   =  0x10 ;      // Port G data direction, bit 5 out
   \   0000006C   E100               LDI     R16, 16
   \   0000006E   BB03               OUT     0x13, R16
    190                  PORTG  =  0x00 ;      // Port G data 
   \   00000070   E000               LDI     R16, 0
   \                     ??Init_IO_2:
   \   00000072   BB04               OUT     0x14, R16
    191          #endif
    192                  break;
    193              default:
    194                  break;
    195              }    
    196          }
   \   00000074   9508               RET
   \   00000076                      REQUIRE _A_DDRA
   \   00000076                      REQUIRE _A_PORTA
   \   00000076                      REQUIRE _A_DDRB
   \   00000076                      REQUIRE _A_PORTB
   \   00000076                      REQUIRE _A_DDRC
   \   00000076                      REQUIRE _A_PORTC
   \   00000076                      REQUIRE _A_DDRD
   \   00000076                      REQUIRE _A_PORTD
   \   00000076                      REQUIRE _A_DDRE
   \   00000076                      REQUIRE _A_PORTE
   \   00000076                      REQUIRE _A_DDRF
   \   00000076                      REQUIRE _A_PORTF
   \   00000076                      REQUIRE _A_DDRG
   \   00000076                      REQUIRE _A_PORTG
    197          
    198          /*
    199          **===========================================================================
    200          ** Init the timer related registers
    201          **===========================================================================
    202          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    203          void Init_TMR( void ) {
   \                     Init_TMR:
    204              /*--- Timer control (disable clock inputs) ---*/
    205          
    206              switch (UnitID) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   2300               TST     R16
   \   00000006   F019               BREQ    ??Init_TMR_0
   \   00000008   950A               DEC     R16
   \   0000000A   F049               BREQ    ??Init_TMR_1
   \   0000000C   9508               RET
    207              case AN_ZB485:                  // AN-ZB485
    208                  // 128 -> 1281
    209                  // TIM0 and TIM2 are swapped in 1281.
    210                  // Registers are completely changed.
    211                  // TCCR0   =  0x99 ;      // Timer control register 0
    212                  // OCR0    =  3;         // Timer output compare register 0, 2MHZ //16MHz xtal
    213                  //
    214                  // TCCR2A : 0 1 0 0 - - 1 0
    215                  // TCCR2B : 1 0 - - 0 0 0 1
    216                  //
    217                  // COM2A1 COM2A0 : 0 1
    218                  // COM2B1 COM2B0 : 0 0
    219                  // WGM21 WGM20   : 1 0
    220                  // FOC2A : 1, FOR2B : 0, WGM22 : 0, CS2/1/0 : 0 0 1
    221                  //
    222                  // COM2A : Toggle
    223                  // WGM : CTC
    224                  // Clock Scale: 1
    225          
    226                  TCCR2A = 0x42;
   \                     ??Init_TMR_0:
   \   0000000E   E402               LDI     R16, 66
   \   00000010   9300....           STS     _A_TCCR2A, R16
    227                  TCCR2B = 0x81;
   \   00000014   E801               LDI     R16, 129
   \   00000016   9300....           STS     _A_TCCR2B, R16
    228                  OCR2A = 3;
   \   0000001A   E003               LDI     R16, 3
   \   0000001C   C007               RJMP    ??Init_TMR_2
    229                  break;
    230              case AN_ZBANA:                  // AN-ZBANA
    231                  // 128 -> 1281
    232                  // TCCR0   =  0x99 ;      // Timer control register 0
    233                  // OCR0    =  7 ;         // Timer output compare register 0, 1MHZ //16MHz xtal
    234                  TCCR2A = 0x42;
   \                     ??Init_TMR_1:
   \   0000001E   E402               LDI     R16, 66
   \   00000020   9300....           STS     _A_TCCR2A, R16
    235                  TCCR2B = 0x81;
   \   00000024   E801               LDI     R16, 129
   \   00000026   9300....           STS     _A_TCCR2B, R16
    236                  OCR2A = 7;
   \   0000002A   E007               LDI     R16, 7
   \                     ??Init_TMR_2:
   \   0000002C   9300....           STS     _A_OCR2A, R16
    237                  break;
    238              default:
    239                  break;
    240              }
    241          
    242          } 
   \   00000030   9508               RET
   \   00000032                      REQUIRE _A_TCCR2A
   \   00000032                      REQUIRE _A_TCCR2B
   \   00000032                      REQUIRE _A_OCR2A
    243          
    244          /*
    245          **===========================================================================
    246          ** Init the USARTs registers
    247          **===========================================================================
    248          */ 
    249          
    250          

   \                                 In  segment CODE, align 2, keep-with-next
    251          void Init_USART( char channel, unsigned long baud ) {
   \                     Init_USART:
   \   00000000   927A               ST      -Y, R7
   \   00000002   926A               ST      -Y, R6
   \   00000004   925A               ST      -Y, R5
   \   00000006   924A               ST      -Y, R4
   \   00000008   93BA               ST      -Y, R27
   \   0000000A   93AA               ST      -Y, R26
   \   0000000C   938A               ST      -Y, R24
   \   0000000E                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000E                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000E                      REQUIRE ?Register_R6_is_cg_reg
   \   0000000E                      REQUIRE ?Register_R7_is_cg_reg
   \   0000000E   2F80               MOV     R24, R16
   \   00000010   012A               MOVW    R5:R4, R21:R20
   \   00000012   013B               MOVW    R7:R6, R23:R22
    252          
    253              OS_CREATEMB(&UART[channel].RxMailBox,1, sizeof(UART[channel].RxMailBoxBuf),&UART[channel].RxMailBoxBuf);
   \   00000014   2F20               MOV     R18, R16
   \   00000016   EF0D               LDI     R16, 253
   \   00000018   E011               LDI     R17, 1
   \   0000001A   9F21               MUL     R18, R17
   \   0000001C   2D30               MOV     R19, R0
   \   0000001E   9F20               MUL     R18, R16
   \   00000020   0D31               ADD     R19, R1
   \   00000022   ....               LDI     R26, LOW(UART)
   \   00000024   ....               LDI     R27, (UART) >> 8
   \   00000026   0DA0               ADD     R26, R0
   \   00000028   1FB3               ADC     R27, R19
   \   0000002A   01BD               MOVW    R23:R22, R27:R26
   \   0000002C   5460               SUBI    R22, 64
   \   0000002E   4F7E               SBCI    R23, 254
   \   00000030   E342               LDI     R20, 50
   \   00000032   E050               LDI     R21, 0
   \   00000034   E021               LDI     R18, 1
   \   00000036   018D               MOVW    R17:R16, R27:R26
   \   00000038   500E               SUBI    R16, 14
   \   0000003A   4F1E               SBCI    R17, 254
   \   0000003C   ........           CALL    OS_CreateMB
    254              
    255              /*--- Configure UART data block ---*/
    256              UART[channel].TxFirst   = 0x00;
   \   00000040   018D               MOVW    R17:R16, R27:R26
   \   00000042   5E0D               SUBI    R16, 237
   \   00000044   4F1E               SBCI    R17, 254
   \   00000046   01F8               MOVW    R31:R30, R17:R16
   \   00000048   E020               LDI     R18, 0
   \   0000004A   8320               ST      Z, R18
   \   0000004C   8321               STD     Z+1, R18
    257              UART[channel].TxLast    = 0x00;
   \   0000004E   8322               STD     Z+2, R18
   \   00000050   8323               STD     Z+3, R18
    258              UART[channel].TxCount   = 0x00;
   \   00000052   8324               STD     Z+4, R18
   \   00000054   8325               STD     Z+5, R18
    259              UART[channel].RxFirst   = 0x00;
   \   00000056   54AF               SUBI    R26, 79
   \   00000058   4FBE               SBCI    R27, 254
   \   0000005A   01FD               MOVW    R31:R30, R27:R26
   \   0000005C   8320               ST      Z, R18
   \   0000005E   8321               STD     Z+1, R18
    260              UART[channel].RxLast    = 0x00;
   \   00000060   8322               STD     Z+2, R18
   \   00000062   8323               STD     Z+3, R18
    261              UART[channel].RxCount   = 0x00;
   \   00000064   8324               STD     Z+4, R18
   \   00000066   8325               STD     Z+5, R18
    262              UART[channel].RxState   = SYNC;
   \   00000068   8326               STD     Z+6, R18
    263              UART[channel].SyncCnt   = 0 ;
   \   0000006A   8327               STD     Z+7, R18
    264              UART[channel].TxStatus  = 0x00;
   \   0000006C   01F8               MOVW    R31:R30, R17:R16
   \   0000006E   8326               STD     Z+6, R18
    265          
    266              switch (channel) {
   \   00000070   2388               TST     R24
   \   00000072   F019               BREQ    ??Init_USART_0
   \   00000074   958A               DEC     R24
   \   00000076   F129               BREQ    ??Init_USART_1
   \   00000078   C047               RJMP    ??Init_USART_2
    267              case 0x00 :          
    268                  UART[channel].RxTimeout = RX_TO_TIME ;   // reset timeout
   \                     ??Init_USART_0:
   \   0000007A   EF0A               LDI     R16, 250
   \   0000007C   9300....           STS     (UART + 441), R16
   \   00000080   E000               LDI     R16, 0
   \   00000082   9300....           STS     (UART + 442), R16
    269                  UCSR0A  = 0x00; 
   \   00000086   9300....           STS     _A_UCSR0A, R16
    270                  //UBRR0L  = ((XTAL_CPU / 16 / baud )-1) & 0xff;
    271                  //UBRR0H  = (((XTAL_CPU / 16 / baud )-1)>> 8) & 0xff;
    272                  UBRR0   = (unsigned)(((float)XTAL_CPU / 16.0 / ((float)baud) )-0.5); 
   \   0000008A   01A2               MOVW    R21:R20, R5:R4
   \   0000008C   01B3               MOVW    R23:R22, R7:R6
   \   0000008E   ........           CALL    ?UL2F_QS_L04
   \   00000092   E214               LDI     R17, 36
   \   00000094   E724               LDI     R18, 116
   \   00000096   E439               LDI     R19, 73
   \   00000098   ........           CALL    ?F_DIV_S_L04
   \   0000009C   E040               LDI     R20, 0
   \   0000009E   E050               LDI     R21, 0
   \   000000A0   E060               LDI     R22, 0
   \   000000A2   EB7F               LDI     R23, 191
   \   000000A4   ........           CALL    ?F_ADD_S_L04
   \   000000A8   ........           CALL    ?F2SL_S_L04
   \   000000AC   9310....           STS     (_A_UBRR0 + 1), R17
   \   000000B0   9300....           STS     _A_UBRR0, R16
    273                  // why the fuck do you enalbe UDRE here you stupid fucktard!!! -hkim
    274                  // UCSR0B = 0xb8; /* tx/ rx enable, int udre/rxon */
    275                  UCSR0B  = 0x98;       /* tx/ rx enable, int udre/rxon */
   \   000000B4   E908               LDI     R16, 152
   \   000000B6   9300....           STS     _A_UCSR0B, R16
    276                  UCSR0C  = 0x06;       /* n,8,1 */
   \   000000BA   E006               LDI     R16, 6
   \   000000BC   9300....           STS     _A_UCSR0C, R16
    277                  break;
   \   000000C0   C023               RJMP    ??Init_USART_2
    278              case 0x01 :
    279                  UART[channel].RxTimeout = RX_TO_TIME ;   // reset timeout
   \                     ??Init_USART_1:
   \   000000C2   EF0A               LDI     R16, 250
   \   000000C4   9300....           STS     (UART + 950), R16
   \   000000C8   E000               LDI     R16, 0
   \   000000CA   9300....           STS     (UART + 951), R16
    280                  UCSR1A  = 0x00; 
   \   000000CE   9300....           STS     _A_UCSR1A, R16
    281                  //UBRR1L  = ((XTAL_CPU / 16 / baud )-1) & 0xff;
    282                  //UBRR1H  = (((XTAL_CPU / 16 / baud )-1)>> 8) & 0xff;
    283                  UBRR1   = (unsigned)(((float)XTAL_CPU / 16.0 / ((float)baud) )-0.5); 
   \   000000D2   01A2               MOVW    R21:R20, R5:R4
   \   000000D4   01B3               MOVW    R23:R22, R7:R6
   \   000000D6   ........           CALL    ?UL2F_QS_L04
   \   000000DA   E214               LDI     R17, 36
   \   000000DC   E724               LDI     R18, 116
   \   000000DE   E439               LDI     R19, 73
   \   000000E0   ........           CALL    ?F_DIV_S_L04
   \   000000E4   E040               LDI     R20, 0
   \   000000E6   E050               LDI     R21, 0
   \   000000E8   E060               LDI     R22, 0
   \   000000EA   EB7F               LDI     R23, 191
   \   000000EC   ........           CALL    ?F_ADD_S_L04
   \   000000F0   ........           CALL    ?F2SL_S_L04
   \   000000F4   9310....           STS     (_A_UBRR1 + 1), R17
   \   000000F8   9300....           STS     _A_UBRR1, R16
    284                  // why the fuck do you enalbe UDRE here you stupid fucktard!!! -hkim
    285                  // UCSR1B = 0xb8; /* tx/ rx enable, int udre/rxon */
    286                  UCSR1B = 0x98;       /* tx/ rx enable, int udre/rxon */
   \   000000FC   E908               LDI     R16, 152
   \   000000FE   9300....           STS     _A_UCSR1B, R16
    287                  UCSR1C  = 0x06;       /* n,8,1 */
   \   00000102   E006               LDI     R16, 6
   \   00000104   9300....           STS     _A_UCSR1C, R16
    288                  break;
    289              default:
    290                  break ;
    291              }    
    292          }
   \                     ??Init_USART_2:
   \   00000108   9189               LD      R24, Y+
   \   0000010A   91A9               LD      R26, Y+
   \   0000010C   91B9               LD      R27, Y+
   \   0000010E   9049               LD      R4, Y+
   \   00000110   9059               LD      R5, Y+
   \   00000112   9069               LD      R6, Y+
   \   00000114   9079               LD      R7, Y+
   \   00000116   9508               RET
   \   00000118                      REQUIRE _A_UCSR0A
   \   00000118                      REQUIRE _A_UBRR0
   \   00000118                      REQUIRE _A_UCSR0B
   \   00000118                      REQUIRE _A_UCSR0C
   \   00000118                      REQUIRE _A_UCSR1A
   \   00000118                      REQUIRE _A_UBRR1
   \   00000118                      REQUIRE _A_UCSR1B
   \   00000118                      REQUIRE _A_UCSR1C
    293          
    294          
    295          /*
    296          **===========================================================================
    297          ** Init the AD converter registers
    298          **===========================================================================
    299          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    300          void Init_AD( void ) {
   \                     Init_AD:
    301          
    302              char i;     
    303              for (i = 0; i<8; i++) {                 // Init variables
   \   00000000   ....               LDI     R30, LOW(ADInt)
   \   00000002   ....               LDI     R31, (ADInt) >> 8
   \   00000004   E008               LDI     R16, 8
   \   00000006   E020               LDI     R18, 0
    304                  ADInt.Result[i] = 0;                   // convertion resluts
   \                     ??Init_AD_0:
   \   00000008   9321               ST      Z+, R18
   \   0000000A   9321               ST      Z+, R18
    305              }
   \   0000000C   950A               DEC     R16
   \   0000000E   F7E1               BRNE    ??Init_AD_0
    306              ADChannel = 0x00 ;                      // AD channel to be converted
   \   00000010   9320....           STS     ADChannel, R18
    307              ADMUX   = 0xc0 ;                        // Ref = 2,56V, right adjust
   \   00000014   EC00               LDI     R16, 192
   \   00000016   9300....           STS     _A_ADMUX, R16
    308              // 128 -> 1281
    309              // ADCSR   = 0x8f ;                        // AD enabled, int enabled, xtal / 128
    310              ADCSRA = 0x8f;
   \   0000001A   E80F               LDI     R16, 143
   \   0000001C   9300....           STS     _A_ADCSRA, R16
    311          }
   \   00000020   9508               RET
   \   00000022                      REQUIRE _A_ADMUX
   \   00000022                      REQUIRE _A_ADCSRA
    312          
    313          /*
    314          **===========================================================================
    315          ** Init values  in the system
    316          **===========================================================================
    317          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    318          void Init_Values(void) {
   \                     Init_Values:
    319          
    320          
    321          }
   \   00000000   9508               RET

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   InitSystem
      0      2   Init_AD
      0      2   Init_CPU
      0      2   Init_IO
      0      2   Init_TMR
      7      2   Init_USART
        7      2   -> OS_CreateMB
        7      2 ?F2SL_S_L04
        7      2 ?F_ADD_S_L04
        7      2 ?F_DIV_S_L04
        7      2 ?UL2F_QS_L04
      0      2   Init_Values
      0      2   Init_Watchdog
      0      2   SPI_Init


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     304  InitSystem
      34  Init_AD
      92  Init_CPU
     118  Init_IO
      50  Init_TMR
     280  Init_USART
       2  Init_Values
      18  Init_Watchdog
      12  SPI_Init
       1  _A_ADCSRA
       1  _A_ADMUX
       1  _A_DDRA
       1  _A_DDRB
       1  _A_DDRC
       1  _A_DDRD
       1  _A_DDRE
       1  _A_DDRF
       1  _A_DDRG
       1  _A_EICRA
       1  _A_EICRB
       1  _A_EIMSK
       1  _A_MCUCR
       1  _A_MCUSR
       1  _A_OCR2A
       1  _A_PINB
       1  _A_PORTA
       1  _A_PORTB
       1  _A_PORTC
       1  _A_PORTD
       1  _A_PORTE
       1  _A_PORTF
       1  _A_PORTG
       1  _A_SPCR
       1  _A_SPSR
       1  _A_TCCR2A
       1  _A_TCCR2B
       2  _A_UBRR0
       2  _A_UBRR1
       1  _A_UCSR0A
       1  _A_UCSR0B
       1  _A_UCSR0C
       1  _A_UCSR1A
       1  _A_UCSR1B
       1  _A_UCSR1C
       1  _A_WDTCSR
       1  _A_XMCRA
       1  _A_XMCRB

 
  40 bytes in segment ABSOLUTE
 910 bytes in segment CODE
 
 910 bytes of CODE memory
   0 bytes of DATA memory (+ 40 bytes shared)

Errors: none
Warnings: none
