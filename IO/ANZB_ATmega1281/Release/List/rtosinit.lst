###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       08/Feb/2024  10:48:55
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWA609.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj" -D
#        OS_LIBMODE_R -D OS_UART=-1 -D USE_16552_DRIVER_TASK=1 -D
#        USE_1281_RX_INT_TASK=1 -D USE_MODBUS_PROTOCOL=0 -D ANZBANA_V8=0 -D
#        __ATMEGA_1281__ -lCN "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List" -y
#        --initializers_in_flash -DENABLE_BIT_DEFINITIONS -e -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -Ohs)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\List\rtosinit.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Release\Obj\rtosinit.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c
      1          /*********************************************************************
      2          *               SEGGER MICROCONTROLLER GmbH & Co KG                  *
      3          *       Solutions for real time microcontroller applications         *
      4          **********************************************************************
      5          *                                                                    *
      6          *       (c) 1995 - 2012  SEGGER Microcontroller GmbH & Co KG         *
      7          *                                                                    *
      8          *       www.segger.com     Support: support@segger.com               *
      9          *                                                                    *
     10          **********************************************************************
     11          *                                                                    *
     12          *       embOS * Real time operating system for microcontrollers      *
     13          *                                                                    *
     14          *                                                                    *
     15          *       Please note:                                                 *
     16          *                                                                    *
     17          *       Knowledge of this file may under no circumstances            *
     18          *       be used to write a similar product or a real-time            *
     19          *       operating system for in-house use.                           *
     20          *
     21          *                                                                    *       Thank you for your fairness !                                *
     22          *                                                                    *
     23          **********************************************************************
     24          *                                                                    *
     25          *       OS version: 3.86g                                            *
     26          *                                                                    *
     27          **********************************************************************
     28          
     29          ----------------------------------------------------------------------
     30          Licensing information
     31          Licensor:                 SEGGER Microcontroller GmbH
     32          Licensed to:              Scanjet Ariston AS, Moen  12, 3948  Porsgrunn, Norway
     33          Licensed SEGGER software: embOS
     34          License number:           OS-01417
     35          License model:            SOL [Single Developer Single Platform Object Code License]
     36          Licensed product:         -
     37          Licensed platform:        AtMega 128, IAR
     38          Licensed number of seats: 1
     39          ----------------------------------------------------------------------
     40          Support and Update Agreement (SUA)
     41          SUA period:               2022-12-21 - 2023-06-22
     42          Contact to extend SUA:    sales@segger.com
     43          ----------------------------------------------------------------------
     44          File    : RTOSInit_ATmega128.c for ATmega128 CPU and IAR compiler
     45          
     46          Purpose : Initializes and handles the hardware for embOS as far
     47                    as required by embOS
     48                    Feel free to modify this file acc. to your target system.
     49          --------  END-OF-HEADER  ---------------------------------------------
     50          */
     51          
     52          #include "RTOS.h"
     53          #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0x88
   \   union <unnamed> volatile __io _A_OCR1A
   \                     _A_OCR1A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x84
   \   union <unnamed> volatile __io _A_TCNT1
   \                     _A_TCNT1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x81
   \   union <unnamed> volatile __io _A_TCCR1B
   \                     _A_TCCR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x80
   \   union <unnamed> volatile __io _A_TCCR1A
   \                     _A_TCCR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6f
   \   union <unnamed> volatile __io _A_TIMSK1
   \                     _A_TIMSK1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x36
   \   union <unnamed> volatile __io _A_TIFR1
   \                     _A_TIFR1:
   \   00000000                      DS8 1
     54          #include "constants.h"
     55          /*
     56          #if (((__TID__ >> 4) & 0x0F) == 1)
     57            #include "IO8535.H"
     58          #elif (((__TID__ >> 4) & 0x0F) == 3)
     59            #include "IOM603.H"
     60          #else
     61            #error "This CPU version (selected by -v) is not supported !"
     62          #endif
     63          */
     64          
     65          /*********************************************************************
     66          *
     67          *       Configuration
     68          *
     69          **********************************************************************
     70          */
     71          
     72          /*********************************************************************
     73          *
     74          *       Clock frequency settings
     75          */
     76          #ifndef   OS_FSYS                   /* CPU Main clock frequency     */
     77          #define OS_FSYS 16000000LuL        /* Assume 16 MHz            */
     78          #endif
     79          
     80          #ifndef   OS_PCLK_TIMER             /* Peripheral clock for timer   */
     81              #define OS_PCLK_TIMER (OS_FSYS)   /* May vary from CPU clock      */
     82          #endif                              /* depending on CPU             */
     83          
     84          #ifndef   OS_PCLK_UART              /* Peripheral clock for UART    */
     85              #define OS_PCLK_UART (OS_FSYS)    /* May vary from CPU clock      */
     86          #endif                              /* depending on CPU             */
     87          
     88          #ifndef   OS_TICK_FREQ
     89              #define OS_TICK_FREQ (1000)
     90          #endif
     91          
     92          /*********************************************************************
     93          *
     94          *       Configuration of communication to OSView
     95          */
     96          #ifndef   OS_VIEW_ENABLE            // Global enable of communication
     97              #define OS_VIEW_ENABLE    (1)     // Default: on
     98          #endif
     99          
    100          #ifndef   OS_VIEW_USE_UART          // If set, UART will be used for communication
    101              #define OS_VIEW_USE_UART  (1)     // Default: 1 => Uart is used
    102          #endif                              // if OS_VIEW_ENABLE is on
    103          
    104          /*********************************************************************
    105          *
    106          *       UART settings for OSView
    107          *       If you do not want (or can not due to hardware limitations)
    108          *       to dedicate a UART to OSView, please define it to be -1
    109          *       Currently UART1 is supported and the standard
    110          *       setup enables UART1 per default
    111          */
    112          #ifndef   OS_UART
    113              #define OS_UART (0)
    114          #endif
    115          
    116          #ifndef   OS_BAUDRATE
    117              #define OS_BAUDRATE (19200)
    118          #endif
    119          
    120          /****** End of configurable options *********************************/
    121          
    122          #define OS_UART_USED  ((OS_VIEW_ENABLE && (OS_VIEW_USE_UART != 0)) && ((OS_UART == 0)))
    123          
    124          #if OS_UART_USED
    125              #define OS_COM_INIT() OS_COM_Init()
    126          #else
    127              #define OS_COM_INIT()
    128          #endif
    129          
    130          #define OS_TIMER_RELOAD (OS_PCLK_TIMER / OS_TICK_FREQ)
    131          
    132          /*********************************************************************
    133          *
    134          *       Check configuration
    135          *
    136          **********************************************************************
    137          */
    138          
    139          #ifndef   DEBUG     /* Should normally be defined as project option */
    140              #define DEBUG  (0)
    141          #endif
    142          
    143          /*********************************************************************
    144          *
    145          *       Local defines (sfrs used in RTOSInit.c)
    146          *
    147          **********************************************************************
    148          */
    149          
    150          /*********************************************************************
    151          *
    152          *       Static data
    153          *
    154          **********************************************************************
    155          */
    156          
    157          /*********************************************************************
    158          *
    159          *       Local functions
    160          *
    161          **********************************************************************
    162          */
    163          
    164          /*********************************************************************
    165          *
    166          *       _ReadHWTimer()
    167          *
    168          */

   \                                 In  segment CODE, align 2, keep-with-next
    169          static int _ReadHWTimer(void) {
   \                     _ReadHWTimer:
    170              OS_U16 r = TCNT1L;
   \   00000000   9100....           LDS     R16, _A_TCNT1
    171              asm("nop");
   \   00000004   0000               nop
    172              return r | (TCNT1H << 8);
   \   00000006   91100085           LDS     R17, 133
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_TCNT1
    173          }
    174          
    175          /*********************************************************************
    176          *
    177          *       OS_ISR_Tick()
    178          *       The embOS timer tick interrupt Handler
    179          */
    180          static void OS_ISR_Tick_Handler(void);

   \                                 In  segment CODE, align 2, keep-with-next
    181          static void OS_ISR_Tick_Handler(void) {
   \                     OS_ISR_Tick_Handler:
    182              OS_TICK_Handle();
   \   00000000   ........           JMP     OS_TICK_Handle
    183          }
    184          
    185          /*********************************************************************
    186          *
    187          *       OS_ISR_Tick()
    188          *       The embOS timer tick interrupt Handler
    189          */
    190          #pragma vector = TIMER1_COMPA_vect
    191          __interrupt void OS_ISR_Tick(void);
    192          #pragma vector = TIMER1_COMPA_vect

   \                                 In  segment CODE, align 2, keep-with-next
    193          __interrupt void OS_ISR_Tick(void) {
   \                     OS_ISR_Tick:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    194              OS_CallISR(OS_ISR_Tick_Handler);
   \   00000024   ....               LDI     R16, LOW(OS_ISR_Tick_Handler/2)
   \   00000026   ....               LDI     R17, (OS_ISR_Tick_Handler/2) >> 8
   \   00000028   ........           CALL    OS_CallISR
    195          }
   \   0000002C   BF9B               OUT     0x3B, R25
   \   0000002E   BF8F               OUT     0x3F, R24
   \   00000030   9109               LD      R16, Y+
   \   00000032   9119               LD      R17, Y+
   \   00000034   9129               LD      R18, Y+
   \   00000036   9139               LD      R19, Y+
   \   00000038   9149               LD      R20, Y+
   \   0000003A   9159               LD      R21, Y+
   \   0000003C   9169               LD      R22, Y+
   \   0000003E   9179               LD      R23, Y+
   \   00000040   9009               LD      R0, Y+
   \   00000042   9019               LD      R1, Y+
   \   00000044   9029               LD      R2, Y+
   \   00000046   9039               LD      R3, Y+
   \   00000048   91E9               LD      R30, Y+
   \   0000004A   91F9               LD      R31, Y+
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9518               RETI
    196          
    197          /*********************************************************************
    198          *
    199          *       Global functions
    200          *
    201          **********************************************************************
    202          */
    203          
    204          /*********************************************************************
    205          *
    206          *       OS_InitHW()
    207          *
    208          *       Initialize the hardware (timer) required for embOS to run.
    209          *       May be modified, if an other timer should be used
    210          */
    211          
    212          

   \                                 In  segment CODE, align 2, keep-with-next
    213          void OS_InitHW(void) {
   \                     OS_InitHW:
    214              TCCR1A=  (0<<6)       // 0: No output
    215                       |(0<<4)             // 0: No output
    216                       |(0<<0);            // No PWM
   \   00000000   E000               LDI     R16, 0
   \   00000002   9300....           STS     _A_TCCR1A, R16
    217              TCCR1B=  (1<<7)       // 0: Disable noise canceler
    218                       |(0<<6)             // X: Capture edge
    219                       |(1<<3)             // 1: Reset on compare match
    220                       |(1<<0);            // 1: clock source CK/1
   \   00000006   E809               LDI     R16, 137
   \   00000008   9300....           STS     _A_TCCR1B, R16
    221              OCR1A = (XTAL_CPU/1000)-1;         // generate 1ms interrupts
   \   0000000C   E70F               LDI     R16, 127
   \   0000000E   E31E               LDI     R17, 62
   \   00000010   9310....           STS     (_A_OCR1A + 1), R17
   \   00000014   9300....           STS     _A_OCR1A, R16
    222            TIMSK1 |= (1<<1);      // Output CompareA Match Interrupt Enable
   \   00000018   9100006F           LDS     R16, 111
   \   0000001C   6002               ORI     R16, 0x02
   \   0000001E   9300006F           STS     111, R16
    223              //  SREG  = 0x80 ;        // global interrupt
    224              OS_COM_INIT();        // Initialize communication to embOSView
    225          }
   \   00000022   9508               RET
   \   00000024                      REQUIRE _A_TCCR1A
   \   00000024                      REQUIRE _A_TCCR1B
   \   00000024                      REQUIRE _A_OCR1A
   \   00000024                      REQUIRE _A_TIMSK1
    226          
    227          /*********************************************************************
    228          *
    229          *       OS_Idle()
    230          *
    231          *       Please note:
    232          *       This is basically the "core" of the idle loop.
    233          *       This core loop can be changed, but:
    234          *       The idle loop does not have a stack of its own, therefore no
    235          *       functionality should be implemented that relies on the stack
    236          *       to be preserved. However, a simple program loop can be programmed
    237          *       (like toggeling an output or incrementing a counter)
    238          */
    239          

   \                                 In  segment CODE, align 2, keep-with-next
    240          void OS_Idle(void) {          // Idle loop: No task is ready to execute
   \                     OS_Idle:
    241              while (1) {           // Nothing to do ... wait for interrupt
   \                     ??OS_Idle_0:
   \   00000000   CFFF               RJMP    ??OS_Idle_0
    242          #if (DEBUG == 0)
    243                  // Switch CPU into sleep mode
    244          #endif
    245              }
    246          }
    247          
    248          /*********************************************************************
    249          *
    250          *       OS_GetTime_Cycles()
    251          *
    252          *       This routine is required for task-info via OSView or high
    253          *       resolution time measurement functions.
    254          *       It returns the system time in timer clock cycles.
    255          */

   \                                 In  segment CODE, align 2, keep-with-next
    256          OS_U32 OS_GetTime_Cycles(void) {
   \                     OS_GetTime_Cycles:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2FFA               MOV     R31, R26
   \   00000004   2E39               MOV     R3, R25
   \   00000006   2FE8               MOV     R30, R24
    257              OS_U32 Time;
    258              OS_U32 Cnt;
    259          
    260              Time = OS_Time;
   \   00000008   9140....           LDS     R20, (OS_Global + 18)
   \   0000000C   9150....           LDS     R21, (OS_Global + 19)
   \   00000010   9160....           LDS     R22, (OS_Global + 20)
   \   00000014   9170....           LDS     R23, (OS_Global + 21)
    261              Cnt  = _ReadHWTimer();
   \   00000018   ....               RCALL   _ReadHWTimer
   \   0000001A   01C8               MOVW    R25:R24, R17:R16
   \   0000001C   0F11               LSL     R17
   \   0000001E   0B11               SBC     R17, R17
   \   00000020   2FA1               MOV     R26, R17
   \   00000022   2FB1               MOV     R27, R17
    262              //
    263              // Check if timer interrupt pending ...
    264              //
    265              if (TIFR1 & (1 << 4)) {  // Check if timer interrupt pending ...
   \   00000024   9BB4               SBIS    0x16, 0x04
   \   00000026   C00A               RJMP    ??OS_GetTime_Cycles_0
    266                  Cnt = _ReadHWTimer();
   \   00000028   ....               RCALL   _ReadHWTimer
   \   0000002A   01C8               MOVW    R25:R24, R17:R16
   \   0000002C   0F11               LSL     R17
   \   0000002E   0B11               SBC     R17, R17
   \   00000030   2FA1               MOV     R26, R17
   \   00000032   2FB1               MOV     R27, R17
    267                  Time++;
   \   00000034   5F4F               SUBI    R20, 255
   \   00000036   4F5F               SBCI    R21, 255
   \   00000038   4F6F               SBCI    R22, 255
   \   0000003A   4F7F               SBCI    R23, 255
    268              }
    269              return (OS_TIMER_RELOAD * Time) + Cnt;
   \                     ??OS_GetTime_Cycles_0:
   \   0000003C   E800               LDI     R16, 128
   \   0000003E   E31E               LDI     R17, 62
   \   00000040   2422               CLR     R2
   \   00000042   9F70               MUL     R23, R16
   \   00000044   2D70               MOV     R23, R0
   \   00000046   9F61               MUL     R22, R17
   \   00000048   0D70               ADD     R23, R0
   \   0000004A   9F60               MUL     R22, R16
   \   0000004C   2D60               MOV     R22, R0
   \   0000004E   0D71               ADD     R23, R1
   \   00000050   9F51               MUL     R21, R17
   \   00000052   0D60               ADD     R22, R0
   \   00000054   1D71               ADC     R23, R1
   \   00000056   9F50               MUL     R21, R16
   \   00000058   2D50               MOV     R21, R0
   \   0000005A   0D61               ADD     R22, R1
   \   0000005C   1D72               ADC     R23, R2
   \   0000005E   9F41               MUL     R20, R17
   \   00000060   0D50               ADD     R21, R0
   \   00000062   1D61               ADC     R22, R1
   \   00000064   1D72               ADC     R23, R2
   \   00000066   9F40               MUL     R20, R16
   \   00000068   0D51               ADD     R21, R1
   \   0000006A   1D62               ADC     R22, R2
   \   0000006C   1D72               ADC     R23, R2
   \   0000006E   0E08               ADD     R0, R24
   \   00000070   1F59               ADC     R21, R25
   \   00000072   1F6A               ADC     R22, R26
   \   00000074   1F7B               ADC     R23, R27
   \   00000076   2D00               MOV     R16, R0
   \   00000078   2F15               MOV     R17, R21
   \   0000007A   019B               MOVW    R19:R18, R23:R22
   \   0000007C   2F8E               MOV     R24, R30
   \   0000007E   2D93               MOV     R25, R3
   \   00000080   2FAF               MOV     R26, R31
   \   00000082   91B9               LD      R27, Y+
   \   00000084   9508               RET
   \   00000086                      REQUIRE _A_TIFR1
    270          }
    271          
    272          /*********************************************************************
    273          *
    274          *       OS_ConvertCycles2us()
    275          *
    276          *       Convert Cycles into micro seconds.
    277          *
    278          *       If your clock frequency is not a multiple of 1 MHz,
    279          *       you may have to modify this routine in order to get proper
    280          *       diagnostics.
    281          *
    282          *       This routine is required for profiling or high resolution time
    283          *       measurement only.
    284             It does not affect operation of the OS.
    285          */
    286          

   \                                 In  segment CODE, align 2, keep-with-next
    287          OS_U32 OS_ConvertCycles2us(OS_U32 Cycles) {
   \                     OS_ConvertCycles2us:
    288              return Cycles / (OS_PCLK_TIMER / 1000000);
   \   00000000   9536               LSR     R19
   \   00000002   9527               ROR     R18
   \   00000004   9517               ROR     R17
   \   00000006   9507               ROR     R16
   \   00000008   9536               LSR     R19
   \   0000000A   9527               ROR     R18
   \   0000000C   9517               ROR     R17
   \   0000000E   9507               ROR     R16
   \   00000010   9536               LSR     R19
   \   00000012   9527               ROR     R18
   \   00000014   9517               ROR     R17
   \   00000016   9507               ROR     R16
   \   00000018   9536               LSR     R19
   \   0000001A   9527               ROR     R18
   \   0000001C   9517               ROR     R17
   \   0000001E   9507               ROR     R16
   \   00000020   9508               RET
    289          }
    290          
    291          /*********************************************************************
    292          *
    293          *       Optional communication with embOSView
    294          *
    295          **********************************************************************
    296          */
    297          #if OS_UART_USED
    298              #define OS_BAUDDIVIDE ((OS_FSYS+OS_BAUDRATE*8L)/(OS_BAUDRATE*16L)-1)
    299          
    300          /*********************************************************************
    301          *
    302          *       OS_COM_Init()
    303          */
    304          void OS_COM_Init(void) {
    305              UBRR0H  = OS_BAUDDIVIDE >> 8;
    306              UBRR0L = OS_BAUDDIVIDE;
    307              UCSR0B =  (0 << 0)      // X
    308                  | (0 << 1)      // X
    309                  | (0 << 2)      // CHR9: 9-bit Characters
    310                  | (1 << 3)      // TXEN: Transmitter Enable
    311                  | (1 << 4)      // RXEN: Receiver Enable
    312                  | (0 << 5)      // UDRIE: UART Data Register Empty Interrupt Enable
    313                  | (0 << 6)      // TXCIE Tx complete interrupt enable
    314                  | (0 << 7);     // RXCIE Rx complete interrupt enable
    315              UCSR0B =  (0 << 0)      // X
    316                  | (0 << 1)      // X
    317                  | (0 << 2)      // CHR9: 9-bit Characters
    318                  | (1 << 3)      // TXEN: Transmitter Enable
    319                  | (1 << 4)      // RXEN: Receiver Enable
    320                  | (1 << 5)      // UDRIE: UART Data Register Empty Interrupt Enable
    321                  | (0 << 6)      // TXCIE Tx complete interrupt enable
    322                  | (1 << 7);     // RXCIE Rx complete interrupt enable
    323          }
    324          
    325          /*********************************************************************
    326          *
    327          *       OS_COM_Send1()
    328          *       Send one character via UART.
    329          *       Never call this function from your application
    330          */
    331          void OS_COM_Send1(unsigned char c) {
    332              UDR0 = c;
    333              UCSR0B |=  (1 << 5);      // Generate interrupt on transmit buffer emtpy
    334          }
    335          
    336          /*********************************************************************
    337          *
    338          *       OS_ISR_rx_Handler()
    339          *       embOS UART rx interrupt handler
    340          */
    341          void OS_ISR_rx_Handler(void);
    342          void OS_ISR_rx_Handler(void) {
    343              UCSR0B &=  ~(1 << 7);     // Avoid nesting itself !!!
    344              OS_OnRx(UDR0);
    345              OS_DI();             // Disable before allowing Rx interrupt
    346              UCSR0B |=  (1 << 7);
    347          }
    348          
    349          /*********************************************************************
    350          *
    351          *       OS_ISR_rx()
    352          *       embOS UART rx interrupt handler
    353          */
    354              #pragma vector = USART0_RXC_vect
    355          __interrupt void OS_ISR_rx(void);
    356              #pragma vector = USART0_RXC_vect
    357          __interrupt void OS_ISR_rx(void) {
    358              OS_CallISR(OS_ISR_rx_Handler);
    359          }
    360          
    361          /*********************************************************************
    362          *
    363          *       OS_ISR_tx_Handler()
    364          *       embOS UART tx interrupt handler
    365          */
    366          void OS_ISR_tx_Handler(void);
    367          void OS_ISR_tx_Handler(void) {
    368              UCSR0B &=  ~(1 << 5);   // Do not generate any more interrupts
    369              if (OS_OnTx() == 0) {
    370                  OS_DI();             // Disable before allowing Tx interrupt
    371                  UCSR0B |=  (1 << 5);   // Re-enable Tx interrupts
    372              }
    373          }
    374          
    375          /*********************************************************************
    376          *
    377          *       OS_ISR_tx()
    378          *       embOS UART tx interrupt handler
    379          */
    380              #pragma vector = USART0_UDRE_vect
    381          __interrupt void OS_ISR_tx(void);
    382              #pragma vector = USART0_UDRE_vect
    383          __interrupt void OS_ISR_tx(void) {
    384              OS_CallISR(OS_ISR_tx_Handler);
    385          }
    386          
    387          #else  /* UART for communication not used, define dummy functions */
    388          

   \                                 In  segment CODE, align 2, keep-with-next
    389          void OS_COM_Send1(OS_U8 c) {
   \                     OS_COM_Send1:
    390              OS_USEPARA(c);           /* Avoid compiler warning */
    391              OS_COM_ClearTxActive();    /* Let the OS know that Tx is not busy */
   \   00000000   ........           JMP     OS_COM_ClearTxActive
    392          }

   \                                 In  segment INTVEC, offset 0x44, root
   \                     `??OS_ISR_Tick::??INTVEC 68`:
   \   00000044   ........           JMP     OS_ISR_Tick
    393          #endif
    394          
    395          /****** End Of File *************************************************/

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   OS_COM_Send1
        0      2   -> OS_COM_ClearTxActive
      0      2   OS_ConvertCycles2us
      1      2   OS_GetTime_Cycles
        1      2   -> _ReadHWTimer
     16      2   OS_ISR_Tick
       16      2   -> OS_CallISR
      0      2   OS_ISR_Tick_Handler
        0      2   -> OS_TICK_Handle
      0      2   OS_Idle
      0      2   OS_InitHW
      0      2   _ReadHWTimer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  OS_COM_Send1
      34  OS_ConvertCycles2us
     134  OS_GetTime_Cycles
      82  OS_ISR_Tick
       4  OS_ISR_Tick::??INTVEC 68
       4  OS_ISR_Tick_Handler
       2  OS_Idle
      36  OS_InitHW
       2  _A_OCR1A
       1  _A_TCCR1A
       1  _A_TCCR1B
       2  _A_TCNT1
       1  _A_TIFR1
       1  _A_TIMSK1
      12  _ReadHWTimer

 
   8 bytes in segment ABSOLUTE
 308 bytes in segment CODE
   4 bytes in segment INTVEC
 
 308 bytes of CODE memory (+ 4 bytes shared)
   0 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: none
