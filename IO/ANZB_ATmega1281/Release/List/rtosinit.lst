###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       10/May/2023  12:10:42
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  D:\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWA811.tmp
#        (D:\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c --cpu=m1281 -ms -o
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj -D OS_LIBMODE_R -D OS_UART=-1
#        -D USE_16552_DRIVER_TASK=1 -D USE_MODBUS_PROTOCOL=0 -D ANZBANA_V8=0
#        -lCN D:\S2Prog\IO\ANZB_ATmega1281\Release\List -y
#        --initializers_in_flash --no_tbaa --enable_external_bus
#        -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\ANZB_ATmega1281\INC\\ -I
#        D:\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\\ --eeprom_size 4096
#        --clib -Oh)
#    Locale       =  English_USA.1252
#    List file    =  D:\S2Prog\IO\ANZB_ATmega1281\Release\List\rtosinit.lst
#    Object file  =  D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj\rtosinit.r90
#
###############################################################################

D:\S2Prog\IO\ANZB_ATmega1281\Src\rtosinit.c
      1          /*********************************************************************
      2          *               SEGGER MICROCONTROLLER GmbH & Co KG                  *
      3          *       Solutions for real time microcontroller applications         *
      4          **********************************************************************
      5          *                                                                    *
      6          *       (c) 1995 - 2012  SEGGER Microcontroller GmbH & Co KG         *
      7          *                                                                    *
      8          *       www.segger.com     Support: support@segger.com               *
      9          *                                                                    *
     10          **********************************************************************
     11          *                                                                    *
     12          *       embOS * Real time operating system for microcontrollers      *
     13          *                                                                    *
     14          *                                                                    *
     15          *       Please note:                                                 *
     16          *                                                                    *
     17          *       Knowledge of this file may under no circumstances            *
     18          *       be used to write a similar product or a real-time            *
     19          *       operating system for in-house use.                           *
     20          *
     21          *                                                                    *       Thank you for your fairness !                                *
     22          *                                                                    *
     23          **********************************************************************
     24          *                                                                    *
     25          *       OS version: 3.86g                                            *
     26          *                                                                    *
     27          **********************************************************************
     28          
     29          ----------------------------------------------------------------------
     30          Licensing information
     31          Licensor:                 SEGGER Microcontroller GmbH
     32          Licensed to:              Scanjet Ariston AS, Moen  12, 3948  Porsgrunn, Norway
     33          Licensed SEGGER software: embOS
     34          License number:           OS-01417
     35          License model:            SOL [Single Developer Single Platform Object Code License]
     36          Licensed product:         -
     37          Licensed platform:        AtMega 128, IAR
     38          Licensed number of seats: 1
     39          ----------------------------------------------------------------------
     40          Support and Update Agreement (SUA)
     41          SUA period:               2022-12-21 - 2023-06-22
     42          Contact to extend SUA:    sales@segger.com
     43          ----------------------------------------------------------------------
     44          File    : RTOSInit_ATmega128.c for ATmega128 CPU and IAR compiler
     45          
     46          Purpose : Initializes and handles the hardware for embOS as far
     47                    as required by embOS
     48                    Feel free to modify this file acc. to your target system.
     49          --------  END-OF-HEADER  ---------------------------------------------
     50          */
     51          
     52          #include "RTOS.h"
     53          #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0x88
   \   union <unnamed> volatile __io _A_OCR1A
   \                     _A_OCR1A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x84
   \   union <unnamed> volatile __io _A_TCNT1
   \                     _A_TCNT1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x81
   \   union <unnamed> volatile __io _A_TCCR1B
   \                     _A_TCCR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x80
   \   union <unnamed> volatile __io _A_TCCR1A
   \                     _A_TCCR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6f
   \   union <unnamed> volatile __io _A_TIMSK1
   \                     _A_TIMSK1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x36
   \   union <unnamed> volatile __io _A_TIFR1
   \                     _A_TIFR1:
   \   00000000                      DS8 1
     54          #include "constants.h"
     55          /*
     56          #if (((__TID__ >> 4) & 0x0F) == 1)
     57            #include "IO8535.H"
     58          #elif (((__TID__ >> 4) & 0x0F) == 3)
     59            #include "IOM603.H"
     60          #else
     61            #error "This CPU version (selected by -v) is not supported !"
     62          #endif
     63          */
     64          
     65          /*********************************************************************
     66          *
     67          *       Configuration
     68          *
     69          **********************************************************************
     70          */
     71          
     72          /*********************************************************************
     73          *
     74          *       Clock frequency settings
     75          */
     76          #ifndef   OS_FSYS                   /* CPU Main clock frequency     */
     77          #define OS_FSYS 7372800LuL        /* Assume 7.3728 MHz            */
     78          #endif
     79          
     80          #ifndef   OS_PCLK_TIMER             /* Peripheral clock for timer   */
     81              #define OS_PCLK_TIMER (OS_FSYS)   /* May vary from CPU clock      */
     82          #endif                              /* depending on CPU             */
     83          
     84          #ifndef   OS_PCLK_UART              /* Peripheral clock for UART    */
     85              #define OS_PCLK_UART (OS_FSYS)    /* May vary from CPU clock      */
     86          #endif                              /* depending on CPU             */
     87          
     88          #ifndef   OS_TICK_FREQ
     89              #define OS_TICK_FREQ (1000)
     90          #endif
     91          
     92          /*********************************************************************
     93          *
     94          *       Configuration of communication to OSView
     95          */
     96          #ifndef   OS_VIEW_ENABLE            // Global enable of communication
     97              #define OS_VIEW_ENABLE    (1)     // Default: on
     98          #endif
     99          
    100          #ifndef   OS_VIEW_USE_UART          // If set, UART will be used for communication
    101              #define OS_VIEW_USE_UART  (1)     // Default: 1 => Uart is used
    102          #endif                              // if OS_VIEW_ENABLE is on
    103          
    104          /*********************************************************************
    105          *
    106          *       UART settings for OSView
    107          *       If you do not want (or can not due to hardware limitations)
    108          *       to dedicate a UART to OSView, please define it to be -1
    109          *       Currently UART1 is supported and the standard
    110          *       setup enables UART1 per default
    111          */
    112          #ifndef   OS_UART
    113              #define OS_UART (0)
    114          #endif
    115          
    116          #ifndef   OS_BAUDRATE
    117              #define OS_BAUDRATE (19200)
    118          #endif
    119          
    120          /****** End of configurable options *********************************/
    121          
    122          #define OS_UART_USED  ((OS_VIEW_ENABLE && (OS_VIEW_USE_UART != 0)) && ((OS_UART == 0)))
    123          
    124          #if OS_UART_USED
    125              #define OS_COM_INIT() OS_COM_Init()
    126          #else
    127              #define OS_COM_INIT()
    128          #endif
    129          
    130          #define OS_TIMER_RELOAD (OS_PCLK_TIMER / OS_TICK_FREQ)
    131          
    132          /*********************************************************************
    133          *
    134          *       Check configuration
    135          *
    136          **********************************************************************
    137          */
    138          
    139          #ifndef   DEBUG     /* Should normally be defined as project option */
    140              #define DEBUG  (0)
    141          #endif
    142          
    143          /*********************************************************************
    144          *
    145          *       Local defines (sfrs used in RTOSInit.c)
    146          *
    147          **********************************************************************
    148          */
    149          
    150          /*********************************************************************
    151          *
    152          *       Static data
    153          *
    154          **********************************************************************
    155          */
    156          
    157          /*********************************************************************
    158          *
    159          *       Local functions
    160          *
    161          **********************************************************************
    162          */
    163          
    164          /*********************************************************************
    165          *
    166          *       _ReadHWTimer()
    167          *
    168          */

   \                                 In  segment CODE, align 2, keep-with-next
    169          static int _ReadHWTimer(void) {
   \                     _ReadHWTimer:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    170              OS_U16 r = TCNT1L;
   \   00000000   9100....           LDS     R16, _A_TCNT1
    171              asm("nop");
   \   00000004   0000               nop
    172              return r | (TCNT1H << 8);
   \   00000006   91100085           LDS     R17, 133
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_TCNT1
    173          }
    174          
    175          /*********************************************************************
    176          *
    177          *       OS_ISR_Tick()
    178          *       The embOS timer tick interrupt Handler
    179          */
    180          static void OS_ISR_Tick_Handler(void);

   \                                 In  segment CODE, align 2, keep-with-next
    181          static void OS_ISR_Tick_Handler(void) {
   \                     OS_ISR_Tick_Handler:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    182              OS_TICK_Handle();
   \   00000000   ........           JMP     OS_TICK_Handle
    183          }
    184          
    185          /*********************************************************************
    186          *
    187          *       OS_ISR_Tick()
    188          *       The embOS timer tick interrupt Handler
    189          */
    190          #pragma vector = TIMER1_COMPA_vect
    191          __interrupt void OS_ISR_Tick(void);
    192          #pragma vector = TIMER1_COMPA_vect

   \                                 In  segment CODE, align 2, keep-with-next
    193          __interrupt void OS_ISR_Tick(void) {
   \                     OS_ISR_Tick:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
   \   00000024                      REQUIRE __RSTACK_in_external_ram_new_way
    194              OS_CallISR(OS_ISR_Tick_Handler);
   \   00000024   ....               LDI     R16, LOW(OS_ISR_Tick_Handler/2)
   \   00000026   ....               LDI     R17, (OS_ISR_Tick_Handler/2) >> 8
   \   00000028   ........           CALL    OS_CallISR
    195          }
   \   0000002C   BF9B               OUT     0x3B, R25
   \   0000002E   BF8F               OUT     0x3F, R24
   \   00000030   9109               LD      R16, Y+
   \   00000032   9119               LD      R17, Y+
   \   00000034   9129               LD      R18, Y+
   \   00000036   9139               LD      R19, Y+
   \   00000038   9149               LD      R20, Y+
   \   0000003A   9159               LD      R21, Y+
   \   0000003C   9169               LD      R22, Y+
   \   0000003E   9179               LD      R23, Y+
   \   00000040   9009               LD      R0, Y+
   \   00000042   9019               LD      R1, Y+
   \   00000044   9029               LD      R2, Y+
   \   00000046   9039               LD      R3, Y+
   \   00000048   91E9               LD      R30, Y+
   \   0000004A   91F9               LD      R31, Y+
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9518               RETI
    196          
    197          /*********************************************************************
    198          *
    199          *       Global functions
    200          *
    201          **********************************************************************
    202          */
    203          
    204          /*********************************************************************
    205          *
    206          *       OS_InitHW()
    207          *
    208          *       Initialize the hardware (timer) required for embOS to run.
    209          *       May be modified, if an other timer should be used
    210          */
    211          
    212          

   \                                 In  segment CODE, align 2, keep-with-next
    213          void OS_InitHW(void) {
   \                     OS_InitHW:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    214              TCCR1A=  (0<<6)       // 0: No output
    215                       |(0<<4)             // 0: No output
    216                       |(0<<0);            // No PWM
   \   00000000   E000               LDI     R16, 0
   \   00000002   9300....           STS     _A_TCCR1A, R16
    217              TCCR1B=  (1<<7)       // 0: Disable noise canceler
    218                       |(0<<6)             // X: Capture edge
    219                       |(1<<3)             // 1: Reset on compare match
    220                       |(1<<0);            // 1: clock source CK/1
   \   00000006   E809               LDI     R16, 137
   \   00000008   9300....           STS     _A_TCCR1B, R16
    221              OCR1A = (XTAL_CPU/1000)-1;         // generate 1ms interrupts
   \   0000000C   E70F               LDI     R16, 127
   \   0000000E   E31E               LDI     R17, 62
   \   00000010   9310....           STS     (_A_OCR1A + 1), R17
   \   00000014   9300....           STS     _A_OCR1A, R16
    222              // 128 -> 1281
    223              // TIMSK |= (1<<4);      // Output CompareA Match Interrupt Enable
    224              TIMSK1 |= 0x02;      // Output CompareA Match Interrupt Enable
   \   00000018   9100006F           LDS     R16, 111
   \   0000001C   6002               ORI     R16, 0x02
   \   0000001E   9300006F           STS     111, R16
    225              //  SREG  = 0x80 ;        // global interrupt
    226              OS_COM_INIT();        // Initialize communication to embOSView
    227          }
   \   00000022   9508               RET
   \   00000024                      REQUIRE _A_TCCR1A
   \   00000024                      REQUIRE _A_TCCR1B
   \   00000024                      REQUIRE _A_OCR1A
   \   00000024                      REQUIRE _A_TIMSK1
    228          
    229          /*********************************************************************
    230          *
    231          *       OS_Idle()
    232          *
    233          *       Please note:
    234          *       This is basically the "core" of the idle loop.
    235          *       This core loop can be changed, but:
    236          *       The idle loop does not have a stack of its own, therefore no
    237          *       functionality should be implemented that relies on the stack
    238          *       to be preserved. However, a simple program loop can be programmed
    239          *       (like toggeling an output or incrementing a counter)
    240          */
    241          

   \                                 In  segment CODE, align 2, keep-with-next
    242          void OS_Idle(void) {          // Idle loop: No task is ready to execute
   \                     OS_Idle:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    243              while (1) {           // Nothing to do ... wait for interrupt
   \                     ??OS_Idle_0:
   \   00000000   CFFF               RJMP    ??OS_Idle_0
    244          #if (DEBUG == 0)
    245                  // Switch CPU into sleep mode
    246          #endif
    247              }
    248          }
    249          
    250          /*********************************************************************
    251          *
    252          *       OS_GetTime_Cycles()
    253          *
    254          *       This routine is required for task-info via OSView or high
    255          *       resolution time measurement functions.
    256          *       It returns the system time in timer clock cycles.
    257          */

   \                                 In  segment CODE, align 2, keep-with-next
    258          OS_U32 OS_GetTime_Cycles(void) {
   \                     OS_GetTime_Cycles:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2FFA               MOV     R31, R26
   \   00000004   2E39               MOV     R3, R25
   \   00000006   2FE8               MOV     R30, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    259              OS_U32 Time;
    260              OS_U32 Cnt;
    261          
    262              Time = OS_Time;
   \   00000008   9140....           LDS     R20, (OS_Global + 18)
   \   0000000C   9150....           LDS     R21, (OS_Global + 19)
   \   00000010   9160....           LDS     R22, (OS_Global + 20)
   \   00000014   9170....           LDS     R23, (OS_Global + 21)
    263              Cnt  = _ReadHWTimer();
   \   00000018   ....               RCALL   _ReadHWTimer
   \   0000001A   01C8               MOVW    R25:R24, R17:R16
   \   0000001C   0F11               LSL     R17
   \   0000001E   0B11               SBC     R17, R17
   \   00000020   2FA1               MOV     R26, R17
   \   00000022   2FB1               MOV     R27, R17
    264              //
    265              // Check if timer interrupt pending ...
    266              //
    267              if (TIFR1 & (1 << 4)) {  // Check if timer interrupt pending ...
   \   00000024   9BB4               SBIS    0x16, 0x04
   \   00000026   C00A               RJMP    ??OS_GetTime_Cycles_0
    268                  Cnt = _ReadHWTimer();
   \   00000028   ....               RCALL   _ReadHWTimer
   \   0000002A   01C8               MOVW    R25:R24, R17:R16
   \   0000002C   0F11               LSL     R17
   \   0000002E   0B11               SBC     R17, R17
   \   00000030   2FA1               MOV     R26, R17
   \   00000032   2FB1               MOV     R27, R17
    269                  Time++;
   \   00000034   5F4F               SUBI    R20, 255
   \   00000036   4F5F               SBCI    R21, 255
   \   00000038   4F6F               SBCI    R22, 255
   \   0000003A   4F7F               SBCI    R23, 255
    270              }
    271              return (OS_TIMER_RELOAD * Time) + Cnt;
   \                     ??OS_GetTime_Cycles_0:
   \   0000003C   EC0C               LDI     R16, 204
   \   0000003E   E11C               LDI     R17, 28
   \   00000040   2422               CLR     R2
   \   00000042   9F70               MUL     R23, R16
   \   00000044   2D70               MOV     R23, R0
   \   00000046   9F61               MUL     R22, R17
   \   00000048   0D70               ADD     R23, R0
   \   0000004A   9F60               MUL     R22, R16
   \   0000004C   2D60               MOV     R22, R0
   \   0000004E   0D71               ADD     R23, R1
   \   00000050   9F51               MUL     R21, R17
   \   00000052   0D60               ADD     R22, R0
   \   00000054   1D71               ADC     R23, R1
   \   00000056   9F50               MUL     R21, R16
   \   00000058   2D50               MOV     R21, R0
   \   0000005A   0D61               ADD     R22, R1
   \   0000005C   1D72               ADC     R23, R2
   \   0000005E   9F41               MUL     R20, R17
   \   00000060   0D50               ADD     R21, R0
   \   00000062   1D61               ADC     R22, R1
   \   00000064   1D72               ADC     R23, R2
   \   00000066   9F40               MUL     R20, R16
   \   00000068   0D51               ADD     R21, R1
   \   0000006A   1D62               ADC     R22, R2
   \   0000006C   1D72               ADC     R23, R2
   \   0000006E   0E08               ADD     R0, R24
   \   00000070   1F59               ADC     R21, R25
   \   00000072   1F6A               ADC     R22, R26
   \   00000074   1F7B               ADC     R23, R27
   \   00000076   2D00               MOV     R16, R0
   \   00000078   2F15               MOV     R17, R21
   \   0000007A   019B               MOVW    R19:R18, R23:R22
   \   0000007C   2F8E               MOV     R24, R30
   \   0000007E   2D93               MOV     R25, R3
   \   00000080   2FAF               MOV     R26, R31
   \   00000082   91B9               LD      R27, Y+
   \   00000084   9508               RET
   \   00000086                      REQUIRE _A_TIFR1
    272          }
    273          
    274          /*********************************************************************
    275          *
    276          *       OS_ConvertCycles2us()
    277          *
    278          *       Convert Cycles into micro seconds.
    279          *
    280          *       If your clock frequency is not a multiple of 1 MHz,
    281          *       you may have to modify this routine in order to get proper
    282          *       diagnostics.
    283          *
    284          *       This routine is required for profiling or high resolution time
    285          *       measurement only.
    286             It does not affect operation of the OS.
    287          */
    288          

   \                                 In  segment CODE, align 2, keep-with-next
    289          OS_U32 OS_ConvertCycles2us(OS_U32 Cycles) {
   \                     OS_ConvertCycles2us:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    290              return Cycles / (OS_PCLK_TIMER / 1000000);
   \   00000000   E047               LDI     R20, 7
   \   00000002   E050               LDI     R21, 0
   \   00000004   E060               LDI     R22, 0
   \   00000006   E070               LDI     R23, 0
   \   00000008   ........           JMP     ?UL_DIVMOD_S_L03
    291          }
    292          
    293          /*********************************************************************
    294          *
    295          *       Optional communication with embOSView
    296          *
    297          **********************************************************************
    298          */
    299          #if OS_UART_USED
    300              #define OS_BAUDDIVIDE ((OS_FSYS+OS_BAUDRATE*8L)/(OS_BAUDRATE*16L)-1)
    301          
    302          /*********************************************************************
    303          *
    304          *       OS_COM_Init()
    305          */
    306          void OS_COM_Init(void) {
    307              UBRR0H  = OS_BAUDDIVIDE >> 8;
    308              UBRR0L = OS_BAUDDIVIDE;
    309              UCSR0B =  (0 << 0)      // X
    310                  | (0 << 1)      // X
    311                  | (0 << 2)      // CHR9: 9-bit Characters
    312                  | (1 << 3)      // TXEN: Transmitter Enable
    313                  | (1 << 4)      // RXEN: Receiver Enable
    314                  | (0 << 5)      // UDRIE: UART Data Register Empty Interrupt Enable
    315                  | (0 << 6)      // TXCIE Tx complete interrupt enable
    316                  | (0 << 7);     // RXCIE Rx complete interrupt enable
    317              UCSR0B =  (0 << 0)      // X
    318                  | (0 << 1)      // X
    319                  | (0 << 2)      // CHR9: 9-bit Characters
    320                  | (1 << 3)      // TXEN: Transmitter Enable
    321                  | (1 << 4)      // RXEN: Receiver Enable
    322                  | (1 << 5)      // UDRIE: UART Data Register Empty Interrupt Enable
    323                  | (0 << 6)      // TXCIE Tx complete interrupt enable
    324                  | (1 << 7);     // RXCIE Rx complete interrupt enable
    325          }
    326          
    327          /*********************************************************************
    328          *
    329          *       OS_COM_Send1()
    330          *       Send one character via UART.
    331          *       Never call this function from your application
    332          */
    333          void OS_COM_Send1(unsigned char c) {
    334              UDR0 = c;
    335              UCSR0B |=  (1 << 5);      // Generate interrupt on transmit buffer emtpy
    336          }
    337          
    338          /*********************************************************************
    339          *
    340          *       OS_ISR_rx_Handler()
    341          *       embOS UART rx interrupt handler
    342          */
    343          void OS_ISR_rx_Handler(void);
    344          void OS_ISR_rx_Handler(void) {
    345              UCSR0B &=  ~(1 << 7);     // Avoid nesting itself !!!
    346              OS_OnRx(UDR0);
    347              OS_DI();             // Disable before allowing Rx interrupt
    348              UCSR0B |=  (1 << 7);
    349          }
    350          
    351          /*********************************************************************
    352          *
    353          *       OS_ISR_rx()
    354          *       embOS UART rx interrupt handler
    355          */
    356              #pragma vector = USART0_RXC_vect
    357          __interrupt void OS_ISR_rx(void);
    358              #pragma vector = USART0_RXC_vect
    359          __interrupt void OS_ISR_rx(void) {
    360              OS_CallISR(OS_ISR_rx_Handler);
    361          }
    362          
    363          /*********************************************************************
    364          *
    365          *       OS_ISR_tx_Handler()
    366          *       embOS UART tx interrupt handler
    367          */
    368          void OS_ISR_tx_Handler(void);
    369          void OS_ISR_tx_Handler(void) {
    370              UCSR0B &=  ~(1 << 5);   // Do not generate any more interrupts
    371              if (OS_OnTx() == 0) {
    372                  OS_DI();             // Disable before allowing Tx interrupt
    373                  UCSR0B |=  (1 << 5);   // Re-enable Tx interrupts
    374              }
    375          }
    376          
    377          /*********************************************************************
    378          *
    379          *       OS_ISR_tx()
    380          *       embOS UART tx interrupt handler
    381          */
    382              #pragma vector = USART0_UDRE_vect
    383          __interrupt void OS_ISR_tx(void);
    384              #pragma vector = USART0_UDRE_vect
    385          __interrupt void OS_ISR_tx(void) {
    386              OS_CallISR(OS_ISR_tx_Handler);
    387          }
    388          
    389          #else  /* UART for communication not used, define dummy functions */
    390          

   \                                 In  segment CODE, align 2, keep-with-next
    391          void OS_COM_Send1(OS_U8 c) {
   \                     OS_COM_Send1:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    392              OS_USEPARA(c);           /* Avoid compiler warning */
    393              OS_COM_ClearTxActive();    /* Let the OS know that Tx is not busy */
   \   00000000   ........           JMP     OS_COM_ClearTxActive
    394          }

   \                                 In  segment INTVEC, offset 0x44, root
   \                     `??OS_ISR_Tick::??INTVEC 68`:
   \   00000044   ........           JMP     OS_ISR_Tick
    395          #endif
    396          
    397          /****** End Of File *************************************************/

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   OS_COM_Send1
        0      2   -> OS_COM_ClearTxActive
      0      2   OS_ConvertCycles2us
        0      2 ?UL_DIVMOD_S_L03
      1      2   OS_GetTime_Cycles
        1      2   -> _ReadHWTimer
     16      2   OS_ISR_Tick
       16      2   -> OS_CallISR
      0      2   OS_ISR_Tick_Handler
        0      2   -> OS_TICK_Handle
      0      2   OS_Idle
      0      2   OS_InitHW
      0      2   _ReadHWTimer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  OS_COM_Send1
      12  OS_ConvertCycles2us
     134  OS_GetTime_Cycles
      82  OS_ISR_Tick
       4  OS_ISR_Tick::??INTVEC 68
       4  OS_ISR_Tick_Handler
       2  OS_Idle
      36  OS_InitHW
       2  _A_OCR1A
       1  _A_TCCR1A
       1  _A_TCCR1B
       2  _A_TCNT1
       1  _A_TIFR1
       1  _A_TIMSK1
      12  _ReadHWTimer

 
   8 bytes in segment ABSOLUTE
 286 bytes in segment CODE
   4 bytes in segment INTVEC
 
 286 bytes of CODE memory (+ 4 bytes shared)
   0 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: none
