###############################################################################
#
# IAR C/C++ Compiler V8.10.1.1784/W64 for Microchip AVR   02/May/2023  12:40:43
# Copyright 1996-2023 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file           =  D:\S2Prog\IO\ANZB_ATmega1281\Src\init.c
#    Command line          =
#        -f D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj\Main\init.r90.rsp
#        (D:\S2Prog\IO\ANZB_ATmega1281\Src\init.c --cpu=m1281 -ms -o
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj\Main -D OS_LIBMODE_S -D
#        OS_UART=-1 -D USE_16552_DRIVER_TASK=1 -lCN
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\List\Main -y
#        --initializers_in_flash --no_tbaa --enable_external_bus
#        -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\ANZB_ATmega1281\INC\ -I
#        D:\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\ --eeprom_size 4096
#        --clib -Oh) --dependencies=n
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj\Main\init.r90.iar_deps
#    Locale                =  C
#    List file             =
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\List\Main\init.lst
#    Object file           =
#        D:\S2Prog\IO\ANZB_ATmega1281\Release\Obj\Main\init.r90
#    Runtime model:           
#      __64bit_doubles     =  disabled
#      __SystemLibrary     =  CLib
#      __architecture      =  *
#      __cpu               =  3
#      __cpu_name          =  ATmega1281
#      __dlib_version      =  clib
#      __enhanced_core     =  enabled
#      __enhanced_core_mul =  enabled
#      __has_elpm          =  true
#      __memory_model      =  2
#      __mex               =  disabled
#      __no_rampd          =  enabled
#      __rt_version        =  3
#      __vtable_memory     =  __nearflash
#
###############################################################################

D:\S2Prog\IO\ANZB_ATmega1281\Src\init.c
      1          /****************************************************************************************
      2          / Init the project
      3          /
      4          ***************************************************************************************/
      5          #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0xcc
   \   __no_init union <unnamed>#43 volatile __io _A_UBRR1
   \                     _A_UBRR1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xca
   \   __no_init union <unnamed>#49 volatile __io _A_UCSR1C
   \                     _A_UCSR1C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc8
   \   __no_init union <unnamed>#56 volatile __io _A_UCSR1A
   \                     _A_UCSR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc4
   \   __no_init union <unnamed>#62 volatile __io _A_UBRR0
   \                     _A_UBRR0:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xc2
   \   __no_init union <unnamed>#68 volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   __no_init union <unnamed>#72 volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   __no_init union <unnamed>#75 volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb3
   \   __no_init union <unnamed>#102 volatile __io _A_OCR2A
   \                     _A_OCR2A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb1
   \   __no_init union <unnamed>#108 volatile __io _A_TCCR2B
   \                     _A_TCCR2B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xb0
   \   __no_init union <unnamed>#111 volatile __io _A_TCCR2A
   \                     _A_TCCR2A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7c
   \   __no_init union <unnamed>#240 volatile __io _A_ADMUX
   \                     _A_ADMUX:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7a
   \   __no_init union <unnamed>#246 volatile __io _A_ADCSRA
   \                     _A_ADCSRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x75
   \   __no_init union <unnamed>#255 volatile __io _A_XMCRB
   \                     _A_XMCRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x74
   \   __no_init union <unnamed>#258 volatile __io _A_XMCRA
   \                     _A_XMCRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6a
   \   __no_init union <unnamed>#288 volatile __io _A_EICRB
   \                     _A_EICRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x69
   \   __no_init union <unnamed>#291 volatile __io _A_EICRA
   \                     _A_EICRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   __no_init union <unnamed>#309 volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x55
   \   __no_init union <unnamed>#327 volatile __io _A_MCUCR
   \                     _A_MCUCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x54
   \   __no_init union <unnamed>#330 volatile __io _A_MCUSR
   \                     _A_MCUSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   __no_init union <unnamed>#391 volatile __io _A_EIMSK
   \                     _A_EIMSK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   __no_init union <unnamed>#418 volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33
   \   __no_init union <unnamed>#421 volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   __no_init union <unnamed>#427 volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   __no_init union <unnamed>#430 volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   __no_init union <unnamed>#436 volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d
   \   __no_init union <unnamed>#439 volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2b
   \   __no_init union <unnamed>#445 volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   __no_init union <unnamed>#448 volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x28
   \   __no_init union <unnamed>#454 volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   __no_init union <unnamed>#457 volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   __no_init union <unnamed>#463 volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   __no_init union <unnamed>#466 volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x23
   \   __no_init union <unnamed>#469 volatile __io _A_PINB
   \                     _A_PINB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x22
   \   __no_init union <unnamed>#472 volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21
   \   __no_init union <unnamed>#475 volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          #include "string.h"
     12          
     13          /*
     14          **===========================================================================
     15          ** Init the system according to board type
     16          **===========================================================================
     17          */ 

   \                                 In  segment CODE, align 2, keep-with-next
     18          void InitSystem(void) {
   \                     InitSystem:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     19          
     20              DDRB    =  0x00 ;      // Port B data direction, bit 0, 4-7 out
   \   00000000   E000               LDI     R16, 0
   \   00000002   B904               OUT     0x04, R16
     21          //    PORTB   =  0xc;
     22              UnitID  = (PINB >> 2)& 0x03;       //get the unit ID
   \   00000004   B103               IN      R16, 0x03
   \   00000006   9506               LSR     R16
   \   00000008   9506               LSR     R16
   \   0000000A   7003               ANDI    R16, 0x03
   \   0000000C   9300....           STS     UnitID, R16
     23          #if (OS_UART == 0)
     24              UnitID = 0x00; //AStmark  for test
     25          #endif
     26          
     27              Init_CPU();                         // init all processes
   \   00000010   ....               RCALL   Init_CPU
     28              Init_IO();
   \   00000012   ....               RCALL   Init_IO
     29              Init_TMR() ;
   \   00000014   ....               RCALL   Init_TMR
     30          #if (OS_UART != 0)
     31              Init_USART(0, 38400) ;              // 
   \   00000016   ....               LDI     R30, LOW(UART)
   \   00000018   ....               LDI     R31, (UART) >> 8
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   8302               STD     Z+2, R16
   \   0000001E   8303               STD     Z+3, R16
   \   00000020   8304               STD     Z+4, R16
   \   00000022   8305               STD     Z+5, R16
   \   00000024   8306               STD     Z+6, R16
   \   00000026   8307               STD     Z+7, R16
   \   00000028   8704               STD     Z+12, R16
   \   0000002A   8705               STD     Z+13, R16
   \   0000002C   8706               STD     Z+14, R16
   \   0000002E   8707               STD     Z+15, R16
   \   00000030   8B00               STD     Z+16, R16
   \   00000032   8B01               STD     Z+17, R16
   \   00000034   8B02               STD     Z+18, R16
   \   00000036   8B03               STD     Z+19, R16
   \   00000038   8700               STD     Z+8, R16
   \   0000003A   EF0A               LDI     R16, 250
   \   0000003C   E010               LDI     R17, 0
   \   0000003E   8B04               STD     Z+20, R16
   \   00000040   8B15               STD     Z+21, R17
   \   00000042   ....               LDI     R16, LOW(TxBufferCh0)
   \   00000044   ....               LDI     R17, (TxBufferCh0) >> 8
   \   00000046   8300               ST      Z, R16
   \   00000048   8311               STD     Z+1, R17
   \   0000004A   ....               LDI     R16, LOW(RxBufferCh0)
   \   0000004C   ....               LDI     R17, (RxBufferCh0) >> 8
   \   0000004E   8702               STD     Z+10, R16
   \   00000050   8713               STD     Z+11, R17
   \   00000052   E000               LDI     R16, 0
   \   00000054   930000C0           STS     192, R16
   \   00000058   E109               LDI     R16, 25
   \   0000005A   930000C4           STS     196, R16
   \   0000005E   E000               LDI     R16, 0
   \   00000060   930000C5           STS     197, R16
   \   00000064   E908               LDI     R16, 152
   \   00000066   930000C1           STS     193, R16
   \   0000006A   E006               LDI     R16, 6
   \   0000006C   930000C2           STS     194, R16
     32          #endif
     33              Init_USART(1, 38400) ;              //    
   \   00000070   E000               LDI     R16, 0
   \   00000072   8F04               STD     Z+28, R16
   \   00000074   8F05               STD     Z+29, R16
   \   00000076   8F06               STD     Z+30, R16
   \   00000078   8F07               STD     Z+31, R16
   \   0000007A   A300               STD     Z+32, R16
   \   0000007C   A301               STD     Z+33, R16
   \   0000007E   A306               STD     Z+38, R16
   \   00000080   A307               STD     Z+39, R16
   \   00000082   A700               STD     Z+40, R16
   \   00000084   A701               STD     Z+41, R16
   \   00000086   A702               STD     Z+42, R16
   \   00000088   A703               STD     Z+43, R16
   \   0000008A   A704               STD     Z+44, R16
   \   0000008C   A705               STD     Z+45, R16
   \   0000008E   A302               STD     Z+34, R16
   \   00000090   EF0A               LDI     R16, 250
   \   00000092   E010               LDI     R17, 0
   \   00000094   A706               STD     Z+46, R16
   \   00000096   A717               STD     Z+47, R17
   \   00000098   ....               LDI     R16, LOW(TxBufferCh1)
   \   0000009A   ....               LDI     R17, (TxBufferCh1) >> 8
   \   0000009C   8F02               STD     Z+26, R16
   \   0000009E   8F13               STD     Z+27, R17
   \   000000A0   ....               LDI     R16, LOW(RxBufferCh1)
   \   000000A2   ....               LDI     R17, (RxBufferCh1) >> 8
   \   000000A4   A304               STD     Z+36, R16
   \   000000A6   A315               STD     Z+37, R17
   \   000000A8   E000               LDI     R16, 0
   \   000000AA   930000C8           STS     200, R16
   \   000000AE   E109               LDI     R16, 25
   \   000000B0   930000CC           STS     204, R16
   \   000000B4   E000               LDI     R16, 0
   \   000000B6   930000CD           STS     205, R16
   \   000000BA   E908               LDI     R16, 152
   \   000000BC   930000C1           STS     193, R16
   \   000000C0   E006               LDI     R16, 6
   \   000000C2   930000CA           STS     202, R16
     34              Init_AD();
   \   000000C6   ....               RCALL   Init_AD
     35              Init_Values();                      // init the values in the system
     36          
     37              // 128 -> 1281
     38              // ADCSR |= 0x40 ;                     //start the AD convertion
     39              ADCSRA |= 0x40 ;
   \   000000C8   9100007A           LDS     R16, 122
   \   000000CC   6400               ORI     R16, 0x40
   \   000000CE   9300007A           STS     122, R16
     40          }
   \   000000D2   9508               RET
   \   000000D4                      REQUIRE _A_DDRB
   \   000000D4                      REQUIRE _A_PINB
   \   000000D4                      REQUIRE _A_ADCSRA
   \   000000D4                      REQUIRE _A_UCSR0A
   \   000000D4                      REQUIRE _A_UBRR0
   \   000000D4                      REQUIRE _A_UCSR0B
   \   000000D4                      REQUIRE _A_UCSR0C
   \   000000D4                      REQUIRE _A_UCSR1A
   \   000000D4                      REQUIRE _A_UBRR1
   \   000000D4                      REQUIRE _A_UCSR1C
     41          
     42          /*
     43          **===========================================================================
     44          ** Init the CPU related registers
     45          **===========================================================================
     46          */ 

   \                                 In  segment CODE, align 2, keep-with-next
     47          void Init_CPU( void ) {
   \                     Init_CPU:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     48          
     49              __disable_interrupt();
   \   00000000   94F8               CLI
     50          
     51              /*--- Configure CPU and interrupts ---*/
     52              switch (UnitID) {
   \   00000002   9100....           LDS     R16, UnitID
   \   00000006   2300               TST     R16
   \   00000008   F019               BREQ    ??Init_CPU_0
   \   0000000A   950A               DEC     R16
   \   0000000C   F079               BREQ    ??Init_CPU_1
   \   0000000E   C01B               RJMP    ??Init_CPU_2
     53              case AN_ZB485:                  // AN-ZB485 
     54                  MCUCR = 0xc0 ;        // MCU control register  External Ram + wait state
   \                     ??Init_CPU_0:
   \   00000010   EC00               LDI     R16, 192
   \   00000012   BF05               OUT     0x35, R16
     55                  EIMSK = 0x00 ;        // External interrupt mask register, all off
   \   00000014   E000               LDI     R16, 0
   \   00000016   BB0D               OUT     0x1D, R16
     56                  EICRA = 0xAf ;        // External interrupt control register, 0,1 raising, rest faling
   \   00000018   EA0F               LDI     R16, 175
   \   0000001A   93000069           STS     105, R16
     57                  EICRB = 0xAA ;        // External interrupt control register 
   \   0000001E   EA0A               LDI     R16, 170
   \   00000020   9300006A           STS     106, R16
     58                  EIMSK = 0x03 ;        // External interrupt mask register, int 0 and 1 on
   \   00000024   E003               LDI     R16, 3
   \   00000026   BB0D               OUT     0x1D, R16
     59                  XMCRA = 0x80; // maximum wait states
   \   00000028   E800               LDI     R16, 128
   \   0000002A   C00B               RJMP    ??Init_CPU_3
     60                  break;
     61              case AN_ZBANA:                  // AN-ZBANA
     62                  MCUCR = 0x00 ;        // MCU control register wait state
   \                     ??Init_CPU_1:
   \   0000002C   E000               LDI     R16, 0
   \   0000002E   BF05               OUT     0x35, R16
     63                  EIMSK = 0x00 ;        // External interrupt mask register , all off
   \   00000030   BB0D               OUT     0x1D, R16
     64                  EICRA = 0xAA ;        // External interrupt control register, o on faling edge
   \   00000032   EA0A               LDI     R16, 170
   \   00000034   93000069           STS     105, R16
     65                  EICRB = 0xAA ;        // External interrupt control register 
   \   00000038   9300006A           STS     106, R16
     66                  EIMSK = 0x01 ;        // External interrupt mask register, int 0 on
   \   0000003C   E001               LDI     R16, 1
   \   0000003E   BB0D               OUT     0x1D, R16
     67                  XMCRA = 0x00 ; // maximum wait states
   \   00000040   E000               LDI     R16, 0
   \                     ??Init_CPU_3:
   \   00000042   93000074           STS     116, R16
     68                  break;
     69              }
     70              // XMCRA = 0x00; // maximum wait states
     71              XMCRB = 0x07 ;       // Full portC + bus keeper
   \                     ??Init_CPU_2:
   \   00000046   E007               LDI     R16, 7
   \   00000048   93000075           STS     117, R16
     72              //
     73              // hkim
     74              // are you fucking out of mind?
     75              // why do you enable global interrupt here?
     76              //
     77              // SREG = 0x80;  // global interrupt
     78          
     79              //
     80              // 128 -> 1281
     81              // No XDIV in 1281. CLKPR instead.
     82              // Anyway No need to do this.
     83              //XDIV  = 0x00 ;     // Init valuse used 0x00
     84          
     85              // 128 -> 1281
     86              // register name change
     87              // RestartStatus = MCUCSR;       // Remember reset source
     88              RestartStatus = MCUSR;
   \   0000004C   B704               IN      R16, 0x34
   \   0000004E   9300....           STS     RestartStatus, R16
     89              MCUSR = 0x00; // and reset
   \   00000052   E000               LDI     R16, 0
   \   00000054   BF04               OUT     0x34, R16
     90              /*--- Initialize buffer ---*/
     91              WriteCount = 0;
   \   00000056   9300....           STS     WriteCount, R16
     92          
     93          }
   \   0000005A   9508               RET
   \   0000005C                      REQUIRE _A_MCUCR
   \   0000005C                      REQUIRE _A_EIMSK
   \   0000005C                      REQUIRE _A_EICRA
   \   0000005C                      REQUIRE _A_EICRB
   \   0000005C                      REQUIRE _A_XMCRA
   \   0000005C                      REQUIRE _A_XMCRB
   \   0000005C                      REQUIRE _A_MCUSR
     94          
     95          /*
     96          **===========================================================================
     97          ** Init the watchdog registers
     98          **===========================================================================
     99          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    100          __monitor void Init_Watchdog( void ) {
   \                     Init_Watchdog:
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000002   94F8               CLI
    101          
    102              asm("WDR");                             // kick the dog!!
   \   00000004   95A8               WDR
    103              // 128 -> 1281
    104              // WDTCR = 0x0f;
    105              WDTCSR = 0x0f;
   \   00000006   E00F               LDI     R16, 15
   \   00000008   93000060           STS     96, R16
    106              asm("WDR");                             // kick the dog!!
   \   0000000C   95A8               WDR
    107          
    108          }
   \   0000000E   BF1F               OUT     0x3F, R17
   \   00000010   9508               RET
   \   00000012                      REQUIRE _A_WDTCSR
    109          
    110          /*
    111          **===========================================================================
    112          ** Init the IO related registers
    113          **===========================================================================
    114          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    115          void Init_IO( void ) {
   \                     Init_IO:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    116          
    117              /*--- Initialize the data registers, output value and input pullup ---*/
    118              switch (UnitID) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   2300               TST     R16
   \   00000006   F019               BREQ    ??Init_IO_0
   \   00000008   950A               DEC     R16
   \   0000000A   F0D9               BREQ    ??Init_IO_1
   \   0000000C   9508               RET
    119              case AN_ZB485:                  // AN-ZB485  
    120                  DDRA   =  0xff ;      // Port A data direction (out), external bus
   \                     ??Init_IO_0:
   \   0000000E   EF0F               LDI     R16, 255
   \   00000010   B901               OUT     0x01, R16
    121                  PORTA  =  0x00 ;      // Port A data
   \   00000012   E000               LDI     R16, 0
   \   00000014   B902               OUT     0x02, R16
    122                  DDRB   =  0x10 ;      // Port B data direction, bit 0, 4-7 out
   \   00000016   E100               LDI     R16, 16
   \   00000018   B904               OUT     0x04, R16
    123                  PORTB  =  0x00 ;      // Port B data   
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   B905               OUT     0x05, R16
    124                  DDRC   =  0xff ;      // Port C data direction, all out
   \   0000001E   EF0F               LDI     R16, 255
   \   00000020   B907               OUT     0x07, R16
    125                  PORTC  =  0x00 ;      // Port C data
   \   00000022   E000               LDI     R16, 0
   \   00000024   B908               OUT     0x08, R16
    126                  DDRD   =  0x00 ;      // Port D data direction, all in except output to osc and txd
   \   00000026   B90A               OUT     0x0A, R16
    127                  PORTD  =  0xff ;      // Port D data pullup on int fro AD
   \   00000028   EF0F               LDI     R16, 255
   \   0000002A   B90B               OUT     0x0B, R16
    128                  DDRE   =  0xFE ;      // Port E data direction, all out except rxd
   \   0000002C   EF0E               LDI     R16, 254
   \   0000002E   B90D               OUT     0x0D, R16
    129                  PORTE  =  0xf0 ;      // Port E data 
   \   00000030   EF00               LDI     R16, 240
   \   00000032   B90E               OUT     0x0E, R16
    130                  DDRF   =  0x00 ;      // Port F data direction, used for ADC
   \   00000034   E000               LDI     R16, 0
   \   00000036   BB00               OUT     0x10, R16
    131                  PORTF  =  0x00 ;      // Port F data 
   \   00000038   BB01               OUT     0x11, R16
    132                  DDRG   =  0x07 ;      // Port G data direction, port 1,2,3 out
   \   0000003A   E007               LDI     R16, 7
   \   0000003C   BB03               OUT     0x13, R16
    133                  PORTG  =  0x03 ;      // Port G data 
   \   0000003E   E003               LDI     R16, 3
   \   00000040   C018               RJMP    ??Init_IO_2
    134                  break;
    135              case AN_ZBANA:                  // AN-ZBANA
    136                  DDRA   =  0x00 ;      // Port A data direction in (not used)
   \                     ??Init_IO_1:
   \   00000042   E000               LDI     R16, 0
   \   00000044   B901               OUT     0x01, R16
    137                  PORTA  =  0x00 ;      // Port A data
   \   00000046   B902               OUT     0x02, R16
    138                  DDRB   =  0xF1 ;      // Port B data direction, bit 0, 4-7 out
   \   00000048   EF01               LDI     R16, 241
   \   0000004A   B904               OUT     0x04, R16
    139                  PORTB  =  0x00 ;      // Port B data   
   \   0000004C   E000               LDI     R16, 0
   \   0000004E   B905               OUT     0x05, R16
    140                  DDRC   =  0xFF ;      // Port C data direction, all out
   \   00000050   EF0F               LDI     R16, 255
   \   00000052   B907               OUT     0x07, R16
    141                  PORTC  =  0x00 ;      // Port C data
   \   00000054   E000               LDI     R16, 0
   \   00000056   B908               OUT     0x08, R16
    142                  DDRD   =  0x02 ;      // Port D data direction, all in except output to osc and txd
   \   00000058   E002               LDI     R16, 2
   \   0000005A   B90A               OUT     0x0A, R16
    143                  PORTD  =  0xf1 ;      // Port D data pullup on int fro AD
   \   0000005C   EF01               LDI     R16, 241
   \   0000005E   B90B               OUT     0x0B, R16
    144                  DDRE   =  0xFE ;      // Port E data direction, all out except rxd
   \   00000060   EF0E               LDI     R16, 254
   \   00000062   B90D               OUT     0x0D, R16
    145                  PORTE  =  0x00 ;      // Port E data 
   \   00000064   E000               LDI     R16, 0
   \   00000066   B90E               OUT     0x0E, R16
    146                  DDRF   =  0x00 ;      // Port F data direction, used for ADC
   \   00000068   BB00               OUT     0x10, R16
    147                  PORTF  =  0x00 ;      // Port F data 
   \   0000006A   BB01               OUT     0x11, R16
    148                  DDRG   =  0x10 ;      // Port G data direction, bit 5 out
   \   0000006C   E100               LDI     R16, 16
   \   0000006E   BB03               OUT     0x13, R16
    149                  PORTG  =  0x00 ;      // Port G data 
   \   00000070   E000               LDI     R16, 0
   \                     ??Init_IO_2:
   \   00000072   BB04               OUT     0x14, R16
    150                  break;
    151              default:
    152                  break;
    153              }    
    154          }
   \   00000074   9508               RET
   \   00000076                      REQUIRE _A_DDRA
   \   00000076                      REQUIRE _A_PORTA
   \   00000076                      REQUIRE _A_DDRB
   \   00000076                      REQUIRE _A_PORTB
   \   00000076                      REQUIRE _A_DDRC
   \   00000076                      REQUIRE _A_PORTC
   \   00000076                      REQUIRE _A_DDRD
   \   00000076                      REQUIRE _A_PORTD
   \   00000076                      REQUIRE _A_DDRE
   \   00000076                      REQUIRE _A_PORTE
   \   00000076                      REQUIRE _A_DDRF
   \   00000076                      REQUIRE _A_PORTF
   \   00000076                      REQUIRE _A_DDRG
   \   00000076                      REQUIRE _A_PORTG
    155          
    156          /*
    157          **===========================================================================
    158          ** Init the timer related registers
    159          **===========================================================================
    160          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    161          void Init_TMR( void ) {
   \                     Init_TMR:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    162              /*--- Timer control (disable clock inputs) ---*/
    163          
    164              switch (UnitID) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   2300               TST     R16
   \   00000006   F019               BREQ    ??Init_TMR_0
   \   00000008   950A               DEC     R16
   \   0000000A   F049               BREQ    ??Init_TMR_1
   \   0000000C   9508               RET
    165              case AN_ZB485:                  // AN-ZB485
    166                  // 128 -> 1281
    167                  // TIM0 and TIM2 are swapped in 1281.
    168                  // Registers are completely changed.
    169                  // TCCR0   =  0x99 ;      // Timer control register 0
    170                  // OCR0    =  3;         // Timer output compare register 0, 2MHZ //16MHz xtal
    171                  //
    172                  // TCCR2A : 0 1 0 0 - - 1 0
    173                  // TCCR2B : 1 0 - - 0 0 0 1
    174                  //
    175                  // COM2A1 COM2A0 : 0 1
    176                  // COM2B1 COM2B0 : 0 0
    177                  // WGM21 WGM20   : 1 0
    178                  // FOC2A : 1, FOR2B : 0, WGM22 : 0, CS2/1/0 : 0 0 1
    179                  //
    180                  // COM2A : Toggle
    181                  // WGM : CTC
    182                  // Clock Scale: 1
    183          
    184                  TCCR2A = 0x42;
   \                     ??Init_TMR_0:
   \   0000000E   E402               LDI     R16, 66
   \   00000010   930000B0           STS     176, R16
    185                  TCCR2B = 0x81;
   \   00000014   E801               LDI     R16, 129
   \   00000016   930000B1           STS     177, R16
    186                  OCR2A = 3;
   \   0000001A   E003               LDI     R16, 3
   \   0000001C   C007               RJMP    ??Init_TMR_2
    187                  break;
    188              case AN_ZBANA:                  // AN-ZBANA
    189                  // 128 -> 1281
    190                  // TCCR0   =  0x99 ;      // Timer control register 0
    191                  // OCR0    =  7 ;         // Timer output compare register 0, 1MHZ //16MHz xtal
    192                  TCCR2A = 0x42;
   \                     ??Init_TMR_1:
   \   0000001E   E402               LDI     R16, 66
   \   00000020   930000B0           STS     176, R16
    193                  TCCR2B = 0x81;
   \   00000024   E801               LDI     R16, 129
   \   00000026   930000B1           STS     177, R16
    194                  OCR2A = 7;
   \   0000002A   E007               LDI     R16, 7
   \                     ??Init_TMR_2:
   \   0000002C   930000B3           STS     179, R16
    195                  break;
    196              default:
    197                  break;
    198              }
    199          
    200          } 
   \   00000030   9508               RET
   \   00000032                      REQUIRE _A_TCCR2A
   \   00000032                      REQUIRE _A_TCCR2B
   \   00000032                      REQUIRE _A_OCR2A
    201          
    202          /*
    203          **===========================================================================
    204          ** Init the USARTs registers
    205          **===========================================================================
    206          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    207          void Init_USART( char channel, unsigned long baud ) {
   \                     Init_USART:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    208          
    209          
    210              /*--- Configure UART data block ---*/
    211              UART[channel].TxFirst   = 0x00;
   \   00000000   E11A               LDI     R17, 26
   \   00000002   9F01               MUL     R16, R17
   \   00000004   ....               LDI     R17, LOW(UART)
   \   00000006   0E01               ADD     R0, R17
   \   00000008   ....               LDI     R17, (UART) >> 8
   \   0000000A   1E11               ADC     R1, R17
   \   0000000C   01F0               MOVW    R31:R30, R1:R0
   \   0000000E   E010               LDI     R17, 0
   \   00000010   8312               STD     Z+2, R17
   \   00000012   8313               STD     Z+3, R17
    212              UART[channel].TxLast    = 0x00;
   \   00000014   8314               STD     Z+4, R17
   \   00000016   8315               STD     Z+5, R17
    213              UART[channel].TxCount   = 0x00;
   \   00000018   8316               STD     Z+6, R17
   \   0000001A   8317               STD     Z+7, R17
    214              UART[channel].RxFirst   = 0x00;
   \   0000001C   8714               STD     Z+12, R17
   \   0000001E   8715               STD     Z+13, R17
    215              UART[channel].RxLast    = 0x00;
   \   00000020   8716               STD     Z+14, R17
   \   00000022   8717               STD     Z+15, R17
    216              UART[channel].RxCount   = 0x00;
   \   00000024   8B10               STD     Z+16, R17
   \   00000026   8B11               STD     Z+17, R17
    217              UART[channel].RxState   = SYNC;
   \   00000028   8B12               STD     Z+18, R17
    218              UART[channel].SyncCnt   = 0 ;
   \   0000002A   8B13               STD     Z+19, R17
    219              UART[channel].TxStatus  = 0x00;
   \   0000002C   8710               STD     Z+8, R17
    220          
    221              switch (channel) {
   \   0000002E   2300               TST     R16
   \   00000030   F019               BREQ    ??Init_USART_0
   \   00000032   950A               DEC     R16
   \   00000034   F131               BREQ    ??Init_USART_1
   \   00000036   9508               RET
    222              case 0x00 :          
    223                  UART[channel].RxTimeout = RX_TO_TIME ;   // reset timeout
   \                     ??Init_USART_0:
   \   00000038   ....               LDI     R30, LOW(UART)
   \   0000003A   ....               LDI     R31, (UART) >> 8
   \   0000003C   EF0A               LDI     R16, 250
   \   0000003E   8B04               STD     Z+20, R16
   \   00000040   8B15               STD     Z+21, R17
    224                  UART[channel].pTxBuffer = TxBufferCh0;        
   \   00000042   ....               LDI     R16, LOW(TxBufferCh0)
   \   00000044   ....               LDI     R17, (TxBufferCh0) >> 8
   \   00000046   8300               ST      Z, R16
   \   00000048   8311               STD     Z+1, R17
    225                  UART[channel].pRxBuffer = RxBufferCh0;        
   \   0000004A   ....               LDI     R16, LOW(RxBufferCh0)
   \   0000004C   ....               LDI     R17, (RxBufferCh0) >> 8
   \   0000004E   8702               STD     Z+10, R16
   \   00000050   8713               STD     Z+11, R17
    226                  UCSR0A  = 0x00; 
   \   00000052   E000               LDI     R16, 0
   \   00000054   930000C0           STS     192, R16
    227                  UBRR0L  = ((XTAL_CPU / 16 / baud )-1) & 0xff;
   \   00000058   E400               LDI     R16, 64
   \   0000005A   E412               LDI     R17, 66
   \   0000005C   E02F               LDI     R18, 15
   \   0000005E   E030               LDI     R19, 0
   \   00000060   ........           CALL    ?UL_DIVMOD_S_L03
   \   00000064   2F40               MOV     R20, R16
   \   00000066   954A               DEC     R20
   \   00000068   934000C4           STS     196, R20
    228                  UBRR0H  = (((XTAL_CPU / 16 / baud )-1)>> 8) & 0xff;
   \   0000006C   5001               SUBI    R16, 1
   \   0000006E   4010               SBCI    R17, 0
   \   00000070   931000C5           STS     197, R17
    229                  // why the fuck do you enalbe UDRE here you stupid fucktard!!! -hkim
    230                  // UCSR0B = 0xb8; /* tx/ rx enable, int udre/rxon */
    231                  UCSR0B  = 0x98;       /* tx/ rx enable, int udre/rxon */
   \   00000074   E908               LDI     R16, 152
   \   00000076   930000C1           STS     193, R16
    232                  UCSR0C  = 0x06;       /* n,8,1 */
   \   0000007A   E006               LDI     R16, 6
   \   0000007C   930000C2           STS     194, R16
    233                  break;
   \   00000080   9508               RET
    234              case 0x01 :
    235                  UART[channel].RxTimeout = RX_TO_TIME ;   // reset timeout
   \                     ??Init_USART_1:
   \   00000082   ....               LDI     R30, LOW(UART)
   \   00000084   ....               LDI     R31, (UART) >> 8
   \   00000086   EF0A               LDI     R16, 250
   \   00000088   A706               STD     Z+46, R16
   \   0000008A   A717               STD     Z+47, R17
    236                  UART[channel].pTxBuffer = TxBufferCh1;
   \   0000008C   ....               LDI     R16, LOW(TxBufferCh1)
   \   0000008E   ....               LDI     R17, (TxBufferCh1) >> 8
   \   00000090   8F02               STD     Z+26, R16
   \   00000092   8F13               STD     Z+27, R17
    237                  UART[channel].pRxBuffer = RxBufferCh1;
   \   00000094   ....               LDI     R16, LOW(RxBufferCh1)
   \   00000096   ....               LDI     R17, (RxBufferCh1) >> 8
   \   00000098   A304               STD     Z+36, R16
   \   0000009A   A315               STD     Z+37, R17
    238                  UCSR1A  = 0x00; 
   \   0000009C   E000               LDI     R16, 0
   \   0000009E   930000C8           STS     200, R16
    239                  UBRR1L  = ((XTAL_CPU / 16 / baud )-1) & 0xff;
   \   000000A2   E400               LDI     R16, 64
   \   000000A4   E412               LDI     R17, 66
   \   000000A6   E02F               LDI     R18, 15
   \   000000A8   E030               LDI     R19, 0
   \   000000AA   ........           CALL    ?UL_DIVMOD_S_L03
   \   000000AE   2F40               MOV     R20, R16
   \   000000B0   954A               DEC     R20
   \   000000B2   934000CC           STS     204, R20
    240                  UBRR1H  = (((XTAL_CPU / 16 / baud )-1)>> 8) & 0xff;
   \   000000B6   5001               SUBI    R16, 1
   \   000000B8   4010               SBCI    R17, 0
   \   000000BA   931000CD           STS     205, R17
    241                  // why the fuck do you enalbe UDRE here you stupid fucktard!!! -hkim
    242                  // UCSR1B = 0xb8; /* tx/ rx enable, int udre/rxon */
    243                  UCSR0B = 0x98;       /* tx/ rx enable, int udre/rxon */
   \   000000BE   E908               LDI     R16, 152
   \   000000C0   930000C1           STS     193, R16
    244                  UCSR1C  = 0x06;       /* n,8,1 */
   \   000000C4   E006               LDI     R16, 6
   \   000000C6   930000CA           STS     202, R16
    245                  break;
    246              default:
    247                  break ;
    248              }    
    249          }
   \   000000CA   9508               RET
   \   000000CC                      REQUIRE _A_UCSR0A
   \   000000CC                      REQUIRE _A_UBRR0
   \   000000CC                      REQUIRE _A_UCSR0B
   \   000000CC                      REQUIRE _A_UCSR0C
   \   000000CC                      REQUIRE _A_UCSR1A
   \   000000CC                      REQUIRE _A_UBRR1
   \   000000CC                      REQUIRE _A_UCSR1C
    250          
    251          
    252          /*
    253          **===========================================================================
    254          ** Init the AD converter registers
    255          **===========================================================================
    256          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    257          void Init_AD( void ) {
   \                     Init_AD:
   \   00000000   019D               MOVW    R19:R18, R27:R26
   \   00000002                      REQUIRE __RSTACK_in_external_ram_new_way
    258          
    259              char i;     
    260              for (i = 0; i<8; i++) {                 // Init variables
   \   00000002   ....               LDI     R26, LOW(ADInt)
   \   00000004   ....               LDI     R27, (ADInt) >> 8
   \   00000006   E008               LDI     R16, 8
   \   00000008   E010               LDI     R17, 0
    261                  ADInt.Result[i] = 0;                   // convertion resluts
   \                     ??Init_AD_0:
   \   0000000A   931D               ST      X+, R17
   \   0000000C   931D               ST      X+, R17
    262              }
   \   0000000E   950A               DEC     R16
   \   00000010   F7E1               BRNE    ??Init_AD_0
    263              ADChannel = 0x00 ;                      // AD channel to be converted
   \   00000012   9310....           STS     ADChannel, R17
    264              ADMUX   = 0xc0 ;                        // Ref = 2,56V, right adjust
   \   00000016   EC00               LDI     R16, 192
   \   00000018   9300007C           STS     124, R16
    265              // 128 -> 1281
    266              // ADCSR   = 0x8f ;                        // AD enabled, int enabled, xtal / 128
    267              ADCSRA = 0x8f;
   \   0000001C   E80F               LDI     R16, 143
   \   0000001E   9300007A           STS     122, R16
    268          }
   \   00000022   01D9               MOVW    R27:R26, R19:R18
   \   00000024   9508               RET
   \   00000026                      REQUIRE _A_ADMUX
   \   00000026                      REQUIRE _A_ADCSRA
    269          
    270          /*
    271          **===========================================================================
    272          ** Init values  in the system
    273          **===========================================================================
    274          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    275          void Init_Values(void) {
   \                     Init_Values:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    276          
    277          
    278          }
   \   00000000   9508               RET

   Maximum stack usage in bytes:

   RSTACK Function
   ------ --------
      2   InitSystem
        2   -> Init_AD
        2   -> Init_CPU
        2   -> Init_IO
        2   -> Init_TMR
      2   Init_AD
      2   Init_CPU
      2   Init_IO
      2   Init_TMR
      2   Init_USART
        2 ?UL_DIVMOD_S_L03
      2   Init_Values
      2   Init_Watchdog


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     212  InitSystem
      38  Init_AD
      92  Init_CPU
     118  Init_IO
      50  Init_TMR
     204  Init_USART
       2  Init_Values
      18  Init_Watchdog
       1  _A_ADCSRA
       1  _A_ADMUX
       1  _A_DDRA
       1  _A_DDRB
       1  _A_DDRC
       1  _A_DDRD
       1  _A_DDRE
       1  _A_DDRF
       1  _A_DDRG
       1  _A_EICRA
       1  _A_EICRB
       1  _A_EIMSK
       1  _A_MCUCR
       1  _A_MCUSR
       1  _A_OCR2A
       1  _A_PINB
       1  _A_PORTA
       1  _A_PORTB
       1  _A_PORTC
       1  _A_PORTD
       1  _A_PORTE
       1  _A_PORTF
       1  _A_PORTG
       1  _A_TCCR2A
       1  _A_TCCR2B
       2  _A_UBRR0
       2  _A_UBRR1
       1  _A_UCSR0A
       1  _A_UCSR0B
       1  _A_UCSR0C
       1  _A_UCSR1A
       1  _A_UCSR1C
       1  _A_WDTCSR
       1  _A_XMCRA
       1  _A_XMCRB

 
  37 bytes in segment ABSOLUTE
 734 bytes in segment CODE
 
 734 bytes of CODE memory
   0 bytes of DATA memory (+ 37 bytes shared)

Errors: none
Warnings: none
