###############################################################################
#
# IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR       10/Aug/2021  11:27:14
# Copyright 1996-2021 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\New ANSGCNV\Src\init.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW8021.tmp ("D:\S2Prog\IO\New
#        ANSGCNV\Src\init.c" --cpu=m128a -ms -o "D:\S2Prog\IO\New
#        ANSGCNV\Debug\Obj" -D OS_LIBMODE_R -D OS_UART=-1 -lCN
#        "D:\S2Prog\IO\New ANSGCNV\Debug\List" -y --initializers_in_flash
#        --no_cse --no_inline --no_code_motion --no_cross_call --no_clustering
#        --no_tbaa --debug -DENABLE_BIT_DEFINITIONS -e -I "D:\S2Prog\IO\New
#        ANSGCNV\INC\\" -I "D:\S2Prog\IO\New ANSGCNV\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -On)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\New ANSGCNV\Debug\List\init.lst
#    Object file  =  D:\S2Prog\IO\New ANSGCNV\Debug\Obj\init.r90
#
###############################################################################

D:\S2Prog\IO\New ANSGCNV\Src\init.c
      1          /****************************************************************************************
      2          / Init the project
      3          /
      4          ***************************************************************************************/
      5          #include "iom128.h"

   \                                 In  segment ABSOLUTE, at 0x22
   \   union <unnamed> volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x23
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x26
   \   union <unnamed> volatile __io _A_ADCSR
   \                     _A_ADCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   union <unnamed> volatile __io _A_ADMUX
   \                     _A_ADMUX:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x29
   \   union <unnamed> volatile __io _A_UBRR0L
   \                     _A_UBRR0L:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   union <unnamed> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x32
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   union <unnamed> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x35
   \   union <unnamed> volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x37
   \   union <unnamed> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x38
   \   union <unnamed> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3a
   \   union <unnamed> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3b
   \   union <unnamed> volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_WDTCR
   \                     _A_WDTCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x51
   \   union <unnamed> volatile __io _A_OCR0
   \                     _A_OCR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x53
   \   union <unnamed> volatile __io _A_TCCR0
   \                     _A_TCCR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x54
   \   union <unnamed> volatile __io _A_MCUCSR
   \                     _A_MCUCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x55
   \   union <unnamed> volatile __io _A_MCUCR
   \                     _A_MCUCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x59
   \   union <unnamed> volatile __io _A_EIMSK
   \                     _A_EIMSK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5a
   \   union <unnamed> volatile __io _A_EICRB
   \                     _A_EICRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5f
   \   union <unnamed> volatile __io _A_SREG
   \                     _A_SREG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x61
   \   union <unnamed> volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x62
   \   union <unnamed> volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x64
   \   union <unnamed> volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x65
   \   union <unnamed> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6a
   \   union <unnamed> volatile __io _A_EICRA
   \                     _A_EICRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x90
   \   union <unnamed> volatile __io _A_UBRR0H
   \                     _A_UBRR0H:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x95
   \   union <unnamed> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x98
   \   union <unnamed> volatile __io _A_UBRR1H
   \                     _A_UBRR1H:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x99
   \   union <unnamed> volatile __io _A_UBRR1L
   \                     _A_UBRR1L:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9a
   \   union <unnamed> volatile __io _A_UCSR1B
   \                     _A_UCSR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9b
   \   union <unnamed> volatile __io _A_UCSR1A
   \                     _A_UCSR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9d
   \   union <unnamed> volatile __io _A_UCSR1C
   \                     _A_UCSR1C:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          #include "string.h"
     12          
     13          /*
     14          **===========================================================================
     15          ** Init the system according to board type
     16          **===========================================================================
     17          */ 

   \                                 In  segment CODE, align 2, keep-with-next
     18          void InitSystem(void) {
   \                     InitSystem:
     19          
     20             // DDRB    =  0x00 ;      // Port B data direction, bit 0, 4-7 out
     21              UnitID = AN_SGCNV;  // EHSMark, just for testing
   \   00000000   E004               LDI     R16, 4
   \   00000002   9300....           STS     UnitID, R16
     22              Init_IO();
   \   00000006   ....               RCALL   Init_IO
     23          //    PORTB   =  0xc;
     24             // UnitID  = (PINB >> 2)& 0x03;       //get the unit ID
     25          #if (OS_UART == 0)
     26              UnitID = AN_SGCNV; //EHSMark for test
     27          #endif
     28          
     29              Init_CPU();                         // init all processes
   \   00000008   ....               RCALL   Init_CPU
     30              //Init_IO();
     31              Init_TMR() ;
   \   0000000A   ....               RCALL   Init_TMR
     32          #if (OS_UART != 0)
     33              //Init_USART(0, 38400) ;              // 
     34          #endif
     35             // Init_USART(1, 38400) ;              //    
     36              //Init_AD();
     37              Init_Values();                      // init the values in the system
   \   0000000C   ....               RCALL   Init_Values
     38          
     39              //ADCSR |= 0x40 ;                     //start the AD convertion
     40          }
   \   0000000E   9508               RET
     41          
     42          /*
     43          **===========================================================================
     44          ** Init the CPU related registers
     45          **===========================================================================
     46          */ 

   \                                 In  segment CODE, align 2, keep-with-next
     47          void Init_CPU( void ) {
   \                     Init_CPU:
     48          
     49              __disable_interrupt();
   \   00000000   94F8               CLI
     50          
     51              /*--- Configure CPU and interrupts ---*/
     52              switch (UnitID) {
   \   00000002   9100....           LDS     R16, UnitID
   \   00000006   3004               CPI     R16, 4
   \   00000008   F459               BRNE    ??Init_CPU_0
     53              case AN_SGCNV:                  // AN-ZBANA
     54                  MCUCR = 0x00 ;        // MCU control register wait state
   \   0000000A   E000               LDI     R16, 0
   \   0000000C   BF05               OUT     0x35, R16
     55                  EIMSK = 0x00 ;        // External interrupt mask register , all off
   \   0000000E   E000               LDI     R16, 0
   \   00000010   BF09               OUT     0x39, R16
     56                  EICRA = 0xAA ;        // External interrupt control register, o on faling edge
   \   00000012   EA0A               LDI     R16, 170
   \   00000014   9300....           STS     _A_EICRA, R16
     57                  EICRB = 0xAA ;        // External interrupt control register 
   \   00000018   EA0A               LDI     R16, 170
   \   0000001A   BF0A               OUT     0x3A, R16
     58                  //EIMSK = 0x01 ;        // External interrupt mask register, int 0 on EHSMark set later to 3 Tank cleaning
     59                  EIMSK = 0x02 ;        // External interrupt mask register , all off
   \   0000001C   E002               LDI     R16, 2
   \   0000001E   BF09               OUT     0x39, R16
     60                  break;
     61              }
     62              //XMCRA = 0x00 ;       // maximum wait states
     63              //XMCRB = 0x07 ;       // Full portC + bus keeper
     64              SREG  = 0x80 ;        // global interrupt
   \                     ??Init_CPU_0:
   \   00000020   E800               LDI     R16, 128
   \   00000022   BF0F               OUT     0x3F, R16
     65              // From page 372, ATMega128.pdf
     66              //asm("CLI");
     67              //XDIV  = 0x00 ;     // Init valuse used 0x00
     68              //asm("NOP");
     69              //asm("NOP");
     70              //asm("NOP");
     71              //asm("NOP");
     72              //asm("NOP");
     73              //asm("NOP");
     74              //asm("NOP");
     75              //asm("NOP");
     76              //asm("NOP");
     77              //asm("SEI");
     78              __no_operation();
   \   00000024   0000               NOP
     79              RestartStatus = MCUCSR;       // Remember reset source
   \   00000026   B704               IN      R16, 0x34
   \   00000028   9300....           STS     RestartStatus, R16
     80              MCUCSR = 0x00;              // and reset
   \   0000002C   E000               LDI     R16, 0
   \   0000002E   BF04               OUT     0x34, R16
     81              /*--- Initialize buffer ---*/
     82              WriteCount = 0;
   \   00000030   E000               LDI     R16, 0
   \   00000032   9300....           STS     WriteCount, R16
     83          
     84          }
   \   00000036   9508               RET
   \   00000038                      REQUIRE _A_MCUCR
   \   00000038                      REQUIRE _A_EIMSK
   \   00000038                      REQUIRE _A_EICRA
   \   00000038                      REQUIRE _A_EICRB
   \   00000038                      REQUIRE _A_SREG
   \   00000038                      REQUIRE _A_MCUCSR
     85          
     86          /*
     87          **===========================================================================
     88          ** Init the watchdog registers
     89          **===========================================================================
     90          */ 

   \                                 In  segment CODE, align 2, keep-with-next
     91          __monitor void Init_Watchdog( void ) {
   \                     Init_Watchdog:
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002   94F8               CLI
     92          
     93              asm("WDR");                             // kick the dog!!
   \   00000004   95A8               WDR
     94              WDTCR = 0x0f;
   \   00000006   E00F               LDI     R16, 15
   \   00000008   BD01               OUT     0x21, R16
     95              asm("WDR");                             // kick the dog!!
   \   0000000A   95A8               WDR
     96          
     97          }
   \   0000000C   BF1F               OUT     0x3F, R17
   \   0000000E   9508               RET
   \   00000010                      REQUIRE _A_WDTCR
     98          
     99          /*
    100          **===========================================================================
    101          ** Init the IO related registers
    102          **===========================================================================
    103          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    104          void Init_IO( void ) {
   \                     Init_IO:
    105          
    106              /*--- Initialize the data registers, output value and input pullup ---*/
    107              switch (UnitID) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   3004               CPI     R16, 4
   \   00000006   F501               BRNE    ??Init_IO_0
    108              case AN_SGCNV:                  // AN-ZB485  
    109                  DDRA   =  0x00 ;      // Port A data direction (in)
   \   00000008   E000               LDI     R16, 0
   \   0000000A   BB0A               OUT     0x1A, R16
    110                  PORTA  =  0xff ;      // Port A data, Pull up on all inputs
   \   0000000C   EF0F               LDI     R16, 255
   \   0000000E   BB0B               OUT     0x1B, R16
    111                  DDRB   =  0xff ;      // Port B data direction, all bits output
   \   00000010   EF0F               LDI     R16, 255
   \   00000012   BB07               OUT     0x17, R16
    112                  PORTB  =  0x10 ;      // Port B data set all outputs low except OC0, Bit 4 
   \   00000014   E100               LDI     R16, 16
   \   00000016   BB08               OUT     0x18, R16
    113                  DDRC   =  0x00 ;      // Port C data direction, all out
   \   00000018   E000               LDI     R16, 0
   \   0000001A   BB04               OUT     0x14, R16
    114                  PORTC  =  0x00 ;      // Port C data, Pull up on all inputs
   \   0000001C   E000               LDI     R16, 0
   \   0000001E   BB05               OUT     0x15, R16
    115                  DDRD   =  0xf8 ;      // Port D data direction, bit 0-2 is inputs, bit 1 : INT1
   \   00000020   EF08               LDI     R16, 248
   \   00000022   BB01               OUT     0x11, R16
    116                  PORTD  =  0x07 ;      // Port D data pullup on bit 0 - 2
   \   00000024   E007               LDI     R16, 7
   \   00000026   BB02               OUT     0x12, R16
    117                  DDRE   =  0xDE ;      // Port E data direction, all out except rxd (0) and bit 5 (TCL)
   \   00000028   ED0E               LDI     R16, 222
   \   0000002A   B902               OUT     0x02, R16
    118                  PORTE  =  0x21 ;      // Port E data pullup on bit 0 and 5
   \   0000002C   E201               LDI     R16, 33
   \   0000002E   B903               OUT     0x03, R16
    119                  DDRF   =  0x05 ;      // Port F data direction, bit  1 for LED, bit 4 - 7 for JTAG
   \   00000030   E005               LDI     R16, 5
   \   00000032   9300....           STS     _A_DDRF, R16
    120                  PORTF  =  0x00 ;      // Port F data 
   \   00000036   E000               LDI     R16, 0
   \   00000038   9300....           STS     _A_PORTF, R16
    121                  DDRG   =  0x1f ;      // Port G data direction, port 0,1,2,3, 4 out
   \   0000003C   E10F               LDI     R16, 31
   \   0000003E   9300....           STS     _A_DDRG, R16
    122                  PORTG  =  0x00 ;      // Port G data 
   \   00000042   E000               LDI     R16, 0
   \   00000044   9300....           STS     _A_PORTG, R16
    123                  break;
    124              default:
    125                  break;
    126              }    
    127          }
   \                     ??Init_IO_0:
   \   00000048   9508               RET
   \   0000004A                      REQUIRE _A_DDRA
   \   0000004A                      REQUIRE _A_PORTA
   \   0000004A                      REQUIRE _A_DDRB
   \   0000004A                      REQUIRE _A_PORTB
   \   0000004A                      REQUIRE _A_DDRC
   \   0000004A                      REQUIRE _A_PORTC
   \   0000004A                      REQUIRE _A_DDRD
   \   0000004A                      REQUIRE _A_PORTD
   \   0000004A                      REQUIRE _A_DDRE
   \   0000004A                      REQUIRE _A_PORTE
   \   0000004A                      REQUIRE _A_DDRF
   \   0000004A                      REQUIRE _A_PORTF
   \   0000004A                      REQUIRE _A_DDRG
   \   0000004A                      REQUIRE _A_PORTG
    128          
    129          /*
    130          **===========================================================================
    131          ** Init the timer related registers
    132          **===========================================================================
    133          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    134          void Init_TMR( void ) {
   \                     Init_TMR:
    135              /*--- Timer control (disable clock inputs) ---*/
    136          
    137              switch (UnitID) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   3004               CPI     R16, 4
   \   00000006   F421               BRNE    ??Init_TMR_0
    138              case AN_SGCNV:                  // AN-ZB485
    139                  TCCR0   =  0x99 ;      // Timer control register 0 
   \   00000008   E909               LDI     R16, 153
   \   0000000A   BF03               OUT     0x33, R16
    140                  OCR0    =  1;         // Timer output compare register 0, 2MHZ //16MHz xtal
   \   0000000C   E001               LDI     R16, 1
   \   0000000E   BF01               OUT     0x31, R16
    141                  break;
    142              default:
    143                  break;
    144              }
    145          
    146          } 
   \                     ??Init_TMR_0:
   \   00000010   9508               RET
   \   00000012                      REQUIRE _A_TCCR0
   \   00000012                      REQUIRE _A_OCR0
    147          
    148          /*
    149          **===========================================================================
    150          ** Init the USARTs registers
    151          **===========================================================================
    152          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    153          void Init_USART( char channel, unsigned long baud ) {
   \                     Init_USART:
   \   00000000   ........           CALL    ?PROLOGUE5_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004   2E40               MOV     R4, R16
   \   00000006   01CA               MOVW    R25:R24, R21:R20
   \   00000008   01DB               MOVW    R27:R26, R23:R22
    154          
    155          
    156              /*--- Configure UART data block ---*/
    157              UART[channel].TxFirst   = 0x00;
   \   0000000A   2D04               MOV     R16, R4
   \   0000000C   E010               LDI     R17, 0
   \   0000000E   E14A               LDI     R20, 26
   \   00000010   E050               LDI     R21, 0
   \   00000012   ........           CALL    ?S_EC_MUL_L02
   \   00000016   01F8               MOVW    R31:R30, R17:R16
   \   00000018   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000001A   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000001C   E000               LDI     R16, 0
   \   0000001E   8302               STD     Z+2, R16
   \   00000020   E000               LDI     R16, 0
   \   00000022   8303               STD     Z+3, R16
    158              UART[channel].TxLast    = 0x00;
   \   00000024   2D04               MOV     R16, R4
   \   00000026   E010               LDI     R17, 0
   \   00000028   E14A               LDI     R20, 26
   \   0000002A   E050               LDI     R21, 0
   \   0000002C   ........           CALL    ?S_EC_MUL_L02
   \   00000030   01F8               MOVW    R31:R30, R17:R16
   \   00000032   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000034   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000036   E000               LDI     R16, 0
   \   00000038   8304               STD     Z+4, R16
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   8305               STD     Z+5, R16
    159              UART[channel].TxCount   = 0x00;
   \   0000003E   2D04               MOV     R16, R4
   \   00000040   E010               LDI     R17, 0
   \   00000042   E14A               LDI     R20, 26
   \   00000044   E050               LDI     R21, 0
   \   00000046   ........           CALL    ?S_EC_MUL_L02
   \   0000004A   01F8               MOVW    R31:R30, R17:R16
   \   0000004C   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000004E   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000050   E000               LDI     R16, 0
   \   00000052   8306               STD     Z+6, R16
   \   00000054   E000               LDI     R16, 0
   \   00000056   8307               STD     Z+7, R16
    160              UART[channel].RxFirst   = 0x00;
   \   00000058   2D04               MOV     R16, R4
   \   0000005A   E010               LDI     R17, 0
   \   0000005C   E14A               LDI     R20, 26
   \   0000005E   E050               LDI     R21, 0
   \   00000060   ........           CALL    ?S_EC_MUL_L02
   \   00000064   01F8               MOVW    R31:R30, R17:R16
   \   00000066   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000068   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000006A   E000               LDI     R16, 0
   \   0000006C   8704               STD     Z+12, R16
   \   0000006E   E000               LDI     R16, 0
   \   00000070   8705               STD     Z+13, R16
    161              UART[channel].RxLast    = 0x00;
   \   00000072   2D04               MOV     R16, R4
   \   00000074   E010               LDI     R17, 0
   \   00000076   E14A               LDI     R20, 26
   \   00000078   E050               LDI     R21, 0
   \   0000007A   ........           CALL    ?S_EC_MUL_L02
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000082   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000084   E000               LDI     R16, 0
   \   00000086   8706               STD     Z+14, R16
   \   00000088   E000               LDI     R16, 0
   \   0000008A   8707               STD     Z+15, R16
    162              UART[channel].RxCount   = 0x00;
   \   0000008C   2D04               MOV     R16, R4
   \   0000008E   E010               LDI     R17, 0
   \   00000090   E14A               LDI     R20, 26
   \   00000092   E050               LDI     R21, 0
   \   00000094   ........           CALL    ?S_EC_MUL_L02
   \   00000098   01F8               MOVW    R31:R30, R17:R16
   \   0000009A   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000009C   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000009E   E000               LDI     R16, 0
   \   000000A0   8B00               STD     Z+16, R16
   \   000000A2   E000               LDI     R16, 0
   \   000000A4   8B01               STD     Z+17, R16
    163              UART[channel].RxState   = SYNC;
   \   000000A6   2D04               MOV     R16, R4
   \   000000A8   E010               LDI     R17, 0
   \   000000AA   E14A               LDI     R20, 26
   \   000000AC   E050               LDI     R21, 0
   \   000000AE   ........           CALL    ?S_EC_MUL_L02
   \   000000B2   01F8               MOVW    R31:R30, R17:R16
   \   000000B4   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   000000B6   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   000000B8   E000               LDI     R16, 0
   \   000000BA   8B02               STD     Z+18, R16
    164              UART[channel].SyncCnt   = 0 ;
   \   000000BC   2D04               MOV     R16, R4
   \   000000BE   E010               LDI     R17, 0
   \   000000C0   E14A               LDI     R20, 26
   \   000000C2   E050               LDI     R21, 0
   \   000000C4   ........           CALL    ?S_EC_MUL_L02
   \   000000C8   01F8               MOVW    R31:R30, R17:R16
   \   000000CA   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   000000CC   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   000000CE   E000               LDI     R16, 0
   \   000000D0   8B03               STD     Z+19, R16
    165              UART[channel].TxStatus  = 0x00;
   \   000000D2   2D04               MOV     R16, R4
   \   000000D4   E010               LDI     R17, 0
   \   000000D6   E14A               LDI     R20, 26
   \   000000D8   E050               LDI     R21, 0
   \   000000DA   ........           CALL    ?S_EC_MUL_L02
   \   000000DE   01F8               MOVW    R31:R30, R17:R16
   \   000000E0   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   000000E2   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   000000E4   E000               LDI     R16, 0
   \   000000E6   8700               STD     Z+8, R16
    166          
    167              switch (channel) {
   \   000000E8   2D04               MOV     R16, R4
   \   000000EA   5000               SUBI    R16, 0
   \   000000EC   F021               BREQ    ??Init_USART_0
   \   000000EE   950A               DEC     R16
   \   000000F0   F409               BRNE    $+2+2
   \   000000F2   C048               RJMP    ??Init_USART_1
   \   000000F4   C090               RJMP    ??Init_USART_2
    168              case 0x00 :          
    169                  UART[channel].RxTimeout = RX_TO_TIME ;   // reset timeout
   \                     ??Init_USART_0:
   \   000000F6   2D04               MOV     R16, R4
   \   000000F8   E010               LDI     R17, 0
   \   000000FA   E14A               LDI     R20, 26
   \   000000FC   E050               LDI     R21, 0
   \   000000FE   ........           CALL    ?S_EC_MUL_L02
   \   00000102   01F8               MOVW    R31:R30, R17:R16
   \   00000104   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000106   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000108   EF0A               LDI     R16, 250
   \   0000010A   E010               LDI     R17, 0
   \   0000010C   8B04               STD     Z+20, R16
   \   0000010E   8B15               STD     Z+21, R17
    170                  UART[channel].pTxBuffer = TxBufferCh0;        
   \   00000110   ....               LDI     R18, LOW(TxBufferCh0)
   \   00000112   ....               LDI     R19, (TxBufferCh0) >> 8
   \   00000114   2D04               MOV     R16, R4
   \   00000116   E010               LDI     R17, 0
   \   00000118   E14A               LDI     R20, 26
   \   0000011A   E050               LDI     R21, 0
   \   0000011C   ........           CALL    ?S_EC_MUL_L02
   \   00000120   01F8               MOVW    R31:R30, R17:R16
   \   00000122   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000124   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000126   8320               ST      Z, R18
   \   00000128   8331               STD     Z+1, R19
    171                  UART[channel].pRxBuffer = RxBufferCh0;        
   \   0000012A   ....               LDI     R18, LOW(RxBufferCh0)
   \   0000012C   ....               LDI     R19, (RxBufferCh0) >> 8
   \   0000012E   2D04               MOV     R16, R4
   \   00000130   E010               LDI     R17, 0
   \   00000132   E14A               LDI     R20, 26
   \   00000134   E050               LDI     R21, 0
   \   00000136   ........           CALL    ?S_EC_MUL_L02
   \   0000013A   01F8               MOVW    R31:R30, R17:R16
   \   0000013C   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000013E   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000140   8722               STD     Z+10, R18
   \   00000142   8733               STD     Z+11, R19
    172                  UCSR0A  = 0x00; 
   \   00000144   E000               LDI     R16, 0
   \   00000146   B90B               OUT     0x0B, R16
    173                  UBRR0L  = ((XTAL_CPU / 16 / baud )-1) & 0xff;
   \   00000148   E000               LDI     R16, 0
   \   0000014A   EE18               LDI     R17, 232
   \   0000014C   E023               LDI     R18, 3
   \   0000014E   E030               LDI     R19, 0
   \   00000150   01AC               MOVW    R21:R20, R25:R24
   \   00000152   01BD               MOVW    R23:R22, R27:R26
   \   00000154   ........           CALL    ?UL_DIVMOD_L03
   \   00000158   950A               DEC     R16
   \   0000015A   B909               OUT     0x09, R16
    174                  UBRR0H  = (((XTAL_CPU / 16 / baud )-1)>> 8) & 0xff;
   \   0000015C   E000               LDI     R16, 0
   \   0000015E   EE18               LDI     R17, 232
   \   00000160   E023               LDI     R18, 3
   \   00000162   E030               LDI     R19, 0
   \   00000164   01AC               MOVW    R21:R20, R25:R24
   \   00000166   01BD               MOVW    R23:R22, R27:R26
   \   00000168   ........           CALL    ?UL_DIVMOD_L03
   \   0000016C   5001               SUBI    R16, 1
   \   0000016E   4010               SBCI    R17, 0
   \   00000170   2F01               MOV     R16, R17
   \   00000172   E010               LDI     R17, 0
   \   00000174   9300....           STS     _A_UBRR0H, R16
    175                  UCSR0B  = 0xb8;       /* tx/ rx enable, int udre/rxon */
   \   00000178   EB08               LDI     R16, 184
   \   0000017A   B90A               OUT     0x0A, R16
    176                  UCSR0C  = 0x06;       /* n,8,1 */
   \   0000017C   E006               LDI     R16, 6
   \   0000017E   9300....           STS     _A_UCSR0C, R16
    177                  break;
   \   00000182   C049               RJMP    ??Init_USART_2
    178              case 0x01 :
    179                  UART[channel].RxTimeout = RX_TO_TIME ;   // reset timeout
   \                     ??Init_USART_1:
   \   00000184   2D04               MOV     R16, R4
   \   00000186   E010               LDI     R17, 0
   \   00000188   E14A               LDI     R20, 26
   \   0000018A   E050               LDI     R21, 0
   \   0000018C   ........           CALL    ?S_EC_MUL_L02
   \   00000190   01F8               MOVW    R31:R30, R17:R16
   \   00000192   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000194   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000196   EF0A               LDI     R16, 250
   \   00000198   E010               LDI     R17, 0
   \   0000019A   8B04               STD     Z+20, R16
   \   0000019C   8B15               STD     Z+21, R17
    180                  UART[channel].pTxBuffer = TxBufferCh1;
   \   0000019E   ....               LDI     R18, LOW(TxBufferCh1)
   \   000001A0   ....               LDI     R19, (TxBufferCh1) >> 8
   \   000001A2   2D04               MOV     R16, R4
   \   000001A4   E010               LDI     R17, 0
   \   000001A6   E14A               LDI     R20, 26
   \   000001A8   E050               LDI     R21, 0
   \   000001AA   ........           CALL    ?S_EC_MUL_L02
   \   000001AE   01F8               MOVW    R31:R30, R17:R16
   \   000001B0   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   000001B2   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   000001B4   8320               ST      Z, R18
   \   000001B6   8331               STD     Z+1, R19
    181                  UART[channel].pRxBuffer = RxBufferCh1;
   \   000001B8   ....               LDI     R18, LOW(RxBufferCh1)
   \   000001BA   ....               LDI     R19, (RxBufferCh1) >> 8
   \   000001BC   2D04               MOV     R16, R4
   \   000001BE   E010               LDI     R17, 0
   \   000001C0   E14A               LDI     R20, 26
   \   000001C2   E050               LDI     R21, 0
   \   000001C4   ........           CALL    ?S_EC_MUL_L02
   \   000001C8   01F8               MOVW    R31:R30, R17:R16
   \   000001CA   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   000001CC   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   000001CE   8722               STD     Z+10, R18
   \   000001D0   8733               STD     Z+11, R19
    182                  UCSR1A  = 0x00; 
   \   000001D2   E000               LDI     R16, 0
   \   000001D4   9300....           STS     _A_UCSR1A, R16
    183                  UBRR1L  = ((XTAL_CPU / 16 / baud )-1) & 0xff;
   \   000001D8   E000               LDI     R16, 0
   \   000001DA   EE18               LDI     R17, 232
   \   000001DC   E023               LDI     R18, 3
   \   000001DE   E030               LDI     R19, 0
   \   000001E0   01AC               MOVW    R21:R20, R25:R24
   \   000001E2   01BD               MOVW    R23:R22, R27:R26
   \   000001E4   ........           CALL    ?UL_DIVMOD_L03
   \   000001E8   950A               DEC     R16
   \   000001EA   9300....           STS     _A_UBRR1L, R16
    184                  UBRR1H  = (((XTAL_CPU / 16 / baud )-1)>> 8) & 0xff;
   \   000001EE   E000               LDI     R16, 0
   \   000001F0   EE18               LDI     R17, 232
   \   000001F2   E023               LDI     R18, 3
   \   000001F4   E030               LDI     R19, 0
   \   000001F6   01AC               MOVW    R21:R20, R25:R24
   \   000001F8   01BD               MOVW    R23:R22, R27:R26
   \   000001FA   ........           CALL    ?UL_DIVMOD_L03
   \   000001FE   5001               SUBI    R16, 1
   \   00000200   4010               SBCI    R17, 0
   \   00000202   2F01               MOV     R16, R17
   \   00000204   E010               LDI     R17, 0
   \   00000206   9300....           STS     _A_UBRR1H, R16
    185                  UCSR1B  = 0xb8;       /* tx/ rx enable, int udre/rxon */
   \   0000020A   EB08               LDI     R16, 184
   \   0000020C   9300....           STS     _A_UCSR1B, R16
    186                  UCSR1C  = 0x06;       /* n,8,1 */
   \   00000210   E006               LDI     R16, 6
   \   00000212   9300....           STS     _A_UCSR1C, R16
    187                  break;
    188              default:
    189                  break ;
    190              }    
    191          }
   \                     ??Init_USART_2:
   \   00000216   E0E5               LDI     R30, 5
   \   00000218   ........           JMP     ?EPILOGUE_B5_L09
   \   0000021C                      REQUIRE _A_UCSR0A
   \   0000021C                      REQUIRE _A_UBRR0L
   \   0000021C                      REQUIRE _A_UBRR0H
   \   0000021C                      REQUIRE _A_UCSR0B
   \   0000021C                      REQUIRE _A_UCSR0C
   \   0000021C                      REQUIRE _A_UCSR1A
   \   0000021C                      REQUIRE _A_UBRR1L
   \   0000021C                      REQUIRE _A_UBRR1H
   \   0000021C                      REQUIRE _A_UCSR1B
   \   0000021C                      REQUIRE _A_UCSR1C
    192          
    193          
    194          /*
    195          **===========================================================================
    196          ** Init the AD converter registers
    197          **===========================================================================
    198          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    199          void Init_AD( void ) {
   \                     Init_AD:
    200          
    201              char i;     
    202              for (i = 0; i<8; i++) {                 // Init variables
   \   00000000   E000               LDI     R16, 0
   \                     ??Init_AD_0:
   \   00000002   3008               CPI     R16, 8
   \   00000004   F468               BRCC    ??Init_AD_1
    203                  ADInt.Result[i] = 0;                   // convertion resluts
   \   00000006   2F20               MOV     R18, R16
   \   00000008   E030               LDI     R19, 0
   \   0000000A   0F22               LSL     R18
   \   0000000C   1F33               ROL     R19
   \   0000000E   01F9               MOVW    R31:R30, R19:R18
   \   00000010   ....               SUBI    R30, LOW((-(ADInt) & 0xFFFF))
   \   00000012   ....               SBCI    R31, (-(ADInt) & 0xFFFF) >> 8
   \   00000014   E010               LDI     R17, 0
   \   00000016   8310               ST      Z, R17
   \   00000018   E010               LDI     R17, 0
   \   0000001A   8311               STD     Z+1, R17
    204              }
   \   0000001C   9503               INC     R16
   \   0000001E   CFF1               RJMP    ??Init_AD_0
    205              ADChannel = 0x00 ;                      // AD channel to be converted
   \                     ??Init_AD_1:
   \   00000020   E010               LDI     R17, 0
   \   00000022   9310....           STS     ADChannel, R17
    206              ADMUX   = 0xc0 ;                        // Ref = 2,56V, right adjust
   \   00000026   EC10               LDI     R17, 192
   \   00000028   B917               OUT     0x07, R17
    207              ADCSR   = 0x8f ;                        // AD enabled, int enabled, xtal / 128
   \   0000002A   E81F               LDI     R17, 143
   \   0000002C   B916               OUT     0x06, R17
    208          }
   \   0000002E   9508               RET
   \   00000030                      REQUIRE _A_ADMUX
   \   00000030                      REQUIRE _A_ADCSR
    209          
    210          /*
    211          **===========================================================================
    212          ** Init values  in the system
    213          **===========================================================================
    214          */ 

   \                                 In  segment CODE, align 2, keep-with-next
    215          void Init_Values(void) {
   \                     Init_Values:
    216          
    217          
    218          }
   \   00000000   9508               RET

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   InitSystem
        0      2   -> Init_CPU
        0      2   -> Init_IO
        0      2   -> Init_TMR
        0      2   -> Init_Values
      0      2   Init_AD
      0      2   Init_CPU
      0      2   Init_IO
      0      2   Init_TMR
      5      2   Init_USART
        5      2 ?S_EC_MUL_L02
        5      2 ?UL_DIVMOD_L03
      0      2   Init_Values
      0      2   Init_Watchdog


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      16  InitSystem
      48  Init_AD
      56  Init_CPU
      74  Init_IO
      18  Init_TMR
     540  Init_USART
       2  Init_Values
      16  Init_Watchdog
       1  _A_ADCSR
       1  _A_ADMUX
       1  _A_DDRA
       1  _A_DDRB
       1  _A_DDRC
       1  _A_DDRD
       1  _A_DDRE
       1  _A_DDRF
       1  _A_DDRG
       1  _A_EICRA
       1  _A_EICRB
       1  _A_EIMSK
       1  _A_MCUCR
       1  _A_MCUCSR
       1  _A_OCR0
       1  _A_PORTA
       1  _A_PORTB
       1  _A_PORTC
       1  _A_PORTD
       1  _A_PORTE
       1  _A_PORTF
       1  _A_PORTG
       1  _A_SREG
       1  _A_TCCR0
       1  _A_UBRR0H
       1  _A_UBRR0L
       1  _A_UBRR1H
       1  _A_UBRR1L
       1  _A_UCSR0A
       1  _A_UCSR0B
       1  _A_UCSR0C
       1  _A_UCSR1A
       1  _A_UCSR1B
       1  _A_UCSR1C
       1  _A_WDTCR

 
  35 bytes in segment ABSOLUTE
 770 bytes in segment CODE
 
 770 bytes of CODE memory
   0 bytes of DATA memory (+ 35 bytes shared)

Errors: none
Warnings: none
