###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       13/Feb/2024  15:22:08
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Src\Usart.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW9DBB.tmp ("C:\Users\ESY\OneDrive
#        - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Src\Usart.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\Obj" -D
#        SPEED=38400 -D __AVR_ATmega1281__ -D ANZBANA_V8=1 -lCN
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\List" -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\List\Usart.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\Obj\Usart.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Src\Usart.c
      1          /****************************************************************************************
      2          / Com protocol for USART0 
      3          /
      4          ***************************************************************************************/
      5          
      6          #ifdef __ATMEGA_1280__
      7          #include	"iom1280.h"
      8          #endif
      9          
     10          #ifdef __AVR_ATmega1281__
     11          #include	"iom1281.h"

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5b
   \   union <unnamed> volatile __io _A_RAMPZ
   \                     _A_RAMPZ:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1
     12          #endif
     13          #include "stdio.h"
     14          #include "string.h"
     15          #include "math.h"
     16          #include "externals.h"
     17          #include "assembly.h"
     18          #include <intrinsics.h>

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     19          __near char TxBufferCh0[TXSIZE_UART];            // set up buffer size
   \                     TxBufferCh0:
   \   00000000                      DS8 350

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     20          __near char RxBufferCh0[RXSIZE_UART];
   \                     RxBufferCh0:
   \   00000000                      DS8 350
     21          
     22          
     23          /*************************************************************************
     24          *
     25          *  Check the incoming packages
     26          *
     27          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     28          void UsartCheckPackage(void) {
   \                     UsartCheckPackage:
   \   00000000   ........           CALL    ?PROLOGUE5_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
     29          
     30              unsigned short pointer;
     31              char retval;
     32          
     33              myUART.RxSendReply = false;                           // flag for answering set to fault
   \   00000004   E000               LDI     R16, 0
   \   00000006   9300....           STS     (myUART + 24), R16
     34              myUART.TxFirst = 11;                        // Startpos for fist TX command
   \   0000000A   ....               LDI     R30, LOW(myUART)
   \   0000000C   ....               LDI     R31, (myUART) >> 8
   \   0000000E   E00B               LDI     R16, 11
   \   00000010   E010               LDI     R17, 0
   \   00000012   8300               ST      Z, R16
   \   00000014   8311               STD     Z+1, R17
     35              pointer = 7;
   \   00000016   E087               LDI     R24, 7
   \   00000018   E090               LDI     R25, 0
     36              do {
     37                  retval = CheckActionUart(pointer);
   \                     ??UsartCheckPackage_0:
   \   0000001A   018C               MOVW    R17:R16, R25:R24
   \   0000001C   ....               RCALL   CheckActionUart
   \   0000001E   2E40               MOV     R4, R16
     38                  pointer = pointer + RxBufferCh0[pointer + 2]
     39                      + (RxBufferCh0[pointer + 3] * 256) + 4;            // Point to a command cmd hb/lb
   \   00000020   01FC               MOVW    R31:R30, R25:R24
   \   00000022   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000024   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000026   81A2               LDD     R26, Z+2
   \   00000028   E0B0               LDI     R27, 0
   \   0000002A   01FC               MOVW    R31:R30, R25:R24
   \   0000002C   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   0000002E   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000030   8103               LDD     R16, Z+3
   \   00000032   E010               LDI     R17, 0
   \   00000034   2F10               MOV     R17, R16
   \   00000036   E000               LDI     R16, 0
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   9614               ADIW    R27:R26, 4
   \   0000003E   0F8A               ADD     R24, R26
   \   00000040   1F9B               ADC     R25, R27
     40              } while ( retval && (pointer < (myUART.RxPacklen - 4)) );
   \   00000042   2044               TST     R4
   \   00000044   F041               BREQ    ??UsartCheckPackage_1
   \   00000046   ....               LDI     R30, LOW(myUART)
   \   00000048   ....               LDI     R31, (myUART) >> 8
   \   0000004A   89A4               LDD     R26, Z+20
   \   0000004C   89B5               LDD     R27, Z+21
   \   0000004E   9714               SBIW    R27:R26, 4
   \   00000050   178A               CP      R24, R26
   \   00000052   079B               CPC     R25, R27
   \   00000054   F310               BRCS    ??UsartCheckPackage_0
     41              if ( myUART.RxSendReply ) {                              //send answer
   \                     ??UsartCheckPackage_1:
   \   00000056   9100....           LDS     R16, (myUART + 24)
   \   0000005A   2300               TST     R16
   \   0000005C   F009               BREQ    ??UsartCheckPackage_2
     42                  Uart_BuildTail();
   \   0000005E   ....               RCALL   Uart_BuildTail
     43              }
     44              GoToSyncUART();                                    // go to sync modus for recive
   \                     ??UsartCheckPackage_2:
   \   00000060   ....               RCALL   GoToSyncUART
     45          }
   \   00000062   E0E5               LDI     R30, 5
   \   00000064   ........           JMP     ?EPILOGUE_B5_L09
     46          
     47          /*************************************************************************
     48          *
     49          *  Check action on received data
     50          *
     51          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     52          char CheckActionUart(unsigned short pointer) {
   \                     CheckActionUart:
   \   00000000   ........           CALL    ?PROLOGUE6_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004   01C8               MOVW    R25:R24, R17:R16
     53          
     54              const char ch = 0;
   \   00000006   2455               CLR     R5
     55              unsigned short   command;
     56              char    retval = true;
   \   00000008   2444               CLR     R4
   \   0000000A   9443               INC     R4
     57          
     58              command = RxBufferCh0[pointer] | (RxBufferCh0[pointer + 1] << 8);
   \   0000000C   01FC               MOVW    R31:R30, R25:R24
   \   0000000E   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000010   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000012   8100               LD      R16, Z
   \   00000014   01FC               MOVW    R31:R30, R25:R24
   \   00000016   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000018   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   0000001A   8111               LDD     R17, Z+1
   \   0000001C   01D8               MOVW    R27:R26, R17:R16
     59              switch ( command ) {                                      // check action
   \   0000001E   018D               MOVW    R17:R16, R27:R26
   \   00000020   ....               LDI     R30, LOW(`?<Jumptable for CheckActionUart>_0`)
   \   00000022   ....               LDI     R31, (`?<Jumptable for CheckActionUart>_0`) >> 16
   \   00000024   BFFB               OUT     0x3B, R31
   \   00000026   ....               LDI     R31, HIGH(`?<Jumptable for CheckActionUart>_0`)
   \   00000028   ........           JMP     ?SV_SWITCH_L06
     60              case CMD_REQ_STATUS :                                    // Regusest status for target
     61                  BuildStatusData(ch);
   \                     ??CheckActionUart_0:
   \   0000002C   2D05               MOV     R16, R5
   \   0000002E   ....               RCALL   BuildStatusData
     62                  break;
   \   00000030   C017               RJMP    ??CheckActionUart_1
     63          
     64              case CMD_FLASH_ID :                                     // Send flash ID
     65                  BuildFlashID(ch);
   \                     ??CheckActionUart_2:
   \   00000032   2D05               MOV     R16, R5
   \   00000034   ....               RCALL   BuildFlashID
     66                  break;
   \   00000036   C014               RJMP    ??CheckActionUart_1
     67          
     68              case CMD_FLASH_ERASE :                                 // Erase flash
     69                  EraseFlash();
   \                     ??CheckActionUart_3:
   \   00000038   ....               RCALL   EraseFlash
     70                  break;
   \   0000003A   C012               RJMP    ??CheckActionUart_1
     71          
     72              case CMD_FLASH_PROG :                                   // Prog flash
     73                  ProgramFlash(pointer + 4);
   \                     ??CheckActionUart_4:
   \   0000003C   018C               MOVW    R17:R16, R25:R24
   \   0000003E   5F0C               SUBI    R16, 252
   \   00000040   4F1F               SBCI    R17, 255
   \   00000042   ....               RCALL   ProgramFlash
     74                  break;
   \   00000044   C00D               RJMP    ??CheckActionUart_1
     75          
     76              case CMD_FLASH_READ :                                   // Read flash
     77                  ReadFlash(pointer + 4);
   \                     ??CheckActionUart_5:
   \   00000046   018C               MOVW    R17:R16, R25:R24
   \   00000048   5F0C               SUBI    R16, 252
   \   0000004A   4F1F               SBCI    R17, 255
   \   0000004C   ....               RCALL   ReadFlash
     78                  break;
   \   0000004E   C008               RJMP    ??CheckActionUart_1
     79          
     80              case CMD_EXIT_BOOTLOADER :                                // Leave bootlaoder
     81                  ExitBootloader(ch);
   \                     ??CheckActionUart_6:
   \   00000050   2D05               MOV     R16, R5
   \   00000052   ....               RCALL   ExitBootloader
     82                  break;
   \   00000054   C005               RJMP    ??CheckActionUart_1
     83          
     84              default:
     85                  if ( command < MAX_ECMD ) {                           // handle end commands
   \                     ??CheckActionUart_7:
   \   00000056   36A4               CPI     R26, 100
   \   00000058   E000               LDI     R16, 0
   \   0000005A   07B0               CPC     R27, R16
   \   0000005C   F408               BRCC    ??CheckActionUart_1
     86                      retval = false;
   \   0000005E   2444               CLR     R4
     87                  }
     88                  break;
     89          
     90              }
     91              return retval;
   \                     ??CheckActionUart_1:
   \   00000060   2D04               MOV     R16, R4
   \   00000062   E0E6               LDI     R30, 6
   \   00000064   ........           JMP     ?EPILOGUE_B6_L09
     92          }
     93          
     94          //#include <intrinsics.h>
     95          
     96          /*************************************************************************
     97          *
     98          * Build send packet header
     99          *
    100          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    101          void Uart_BuildHeader(void) {
   \                     Uart_BuildHeader:
    102              //__disable_interrupt();
    103              myUART.RxFirst = 0;                                // Reset pointers
   \   00000000   ....               LDI     R30, LOW(myUART)
   \   00000002   ....               LDI     R31, (myUART) >> 8
   \   00000004   E000               LDI     R16, 0
   \   00000006   8702               STD     Z+10, R16
   \   00000008   E000               LDI     R16, 0
   \   0000000A   8703               STD     Z+11, R16
    104              myUART.RxLast  = 0;
   \   0000000C   ....               LDI     R30, LOW(myUART)
   \   0000000E   ....               LDI     R31, (myUART) >> 8
   \   00000010   E000               LDI     R16, 0
   \   00000012   8704               STD     Z+12, R16
   \   00000014   E000               LDI     R16, 0
   \   00000016   8705               STD     Z+13, R16
    105              myUART.TxLast  = 0;
   \   00000018   ....               LDI     R30, LOW(myUART)
   \   0000001A   ....               LDI     R31, (myUART) >> 8
   \   0000001C   E000               LDI     R16, 0
   \   0000001E   8302               STD     Z+2, R16
   \   00000020   E000               LDI     R16, 0
   \   00000022   8303               STD     Z+3, R16
    106          
    107          
    108              TxBufferCh0[0] = ANPRO10_SYN;                        /* Sync */
   \   00000024   E106               LDI     R16, 22
   \   00000026   9300....           STS     TxBufferCh0, R16
    109              TxBufferCh0[1] = ANPRO10_SYN;                        /* Sync */
   \   0000002A   E106               LDI     R16, 22
   \   0000002C   9300....           STS     (TxBufferCh0 + 1), R16
    110              TxBufferCh0[2] = ANPRO10_SYN;                        /* Sync */
   \   00000030   E106               LDI     R16, 22
   \   00000032   9300....           STS     (TxBufferCh0 + 2), R16
    111              TxBufferCh0[3] = ANPRO10_SOH;                        /* Start of header */
   \   00000036   E001               LDI     R16, 1
   \   00000038   9300....           STS     (TxBufferCh0 + 3), R16
    112              TxBufferCh0[4] = RxBufferCh0[2];      /* RXID */
   \   0000003C   9100....           LDS     R16, (RxBufferCh0 + 2)
   \   00000040   9300....           STS     (TxBufferCh0 + 4), R16
    113              TxBufferCh0[5] = RxBufferCh0[3];      /* Rx address */
   \   00000044   9100....           LDS     R16, (RxBufferCh0 + 3)
   \   00000048   9300....           STS     (TxBufferCh0 + 5), R16
    114              TxBufferCh0[6] = 0x10 + UnitID;              /* Unit ID */
   \   0000004C   9100....           LDS     R16, UnitID
   \   00000050   5F00               SUBI    R16, 240
   \   00000052   9300....           STS     (TxBufferCh0 + 6), R16
    115              TxBufferCh0[7] = MyAddress();                /* Tx address */
   \   00000056   ........           CALL    MyAddress
   \   0000005A   9300....           STS     (TxBufferCh0 + 7), R16
    116              TxBufferCh0[8] = 0;                         /* packlen HB, don't know yet */
   \   0000005E   E000               LDI     R16, 0
   \   00000060   9300....           STS     (TxBufferCh0 + 8), R16
    117              TxBufferCh0[9] = 0;                         /* packlen LB, don't know yet */
   \   00000064   E000               LDI     R16, 0
   \   00000066   9300....           STS     (TxBufferCh0 + 9), R16
    118              TxBufferCh0[10] = 0;                        /* header checksum, don't know yet */
   \   0000006A   E000               LDI     R16, 0
   \   0000006C   9300....           STS     (TxBufferCh0 + 10), R16
    119          
    120              //__enable_interrupt();
    121          }
   \   00000070   9508               RET
    122          
    123          /*************************************************************************
    124          *
    125          * Build  packet tail
    126          *
    127          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    128          void Uart_BuildTail(void) {
   \                     Uart_BuildTail:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
    129              Uart_BuildHeader();                                    // fist build the header
   \   00000004   ....               RCALL   Uart_BuildHeader
    130          
    131              TxBufferCh0[myUART.TxFirst++] = ECMD_NMDWOACK & 0xff;  // End command lb
   \   00000006   ....               LDI     R30, LOW(myUART)
   \   00000008   ....               LDI     R31, (myUART) >> 8
   \   0000000A   8100               LD      R16, Z
   \   0000000C   8111               LDD     R17, Z+1
   \   0000000E   01F8               MOVW    R31:R30, R17:R16
   \   00000010   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000012   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000014   E000               LDI     R16, 0
   \   00000016   8300               ST      Z, R16
   \   00000018   ....               LDI     R30, LOW(myUART)
   \   0000001A   ....               LDI     R31, (myUART) >> 8
   \   0000001C   8100               LD      R16, Z
   \   0000001E   8111               LDD     R17, Z+1
   \   00000020   5F0F               SUBI    R16, 255
   \   00000022   4F1F               SBCI    R17, 255
   \   00000024   8300               ST      Z, R16
   \   00000026   8311               STD     Z+1, R17
    132              TxBufferCh0[myUART.TxFirst++] = ECMD_NMDWOACK >> 8;    // End command hb
   \   00000028   ....               LDI     R30, LOW(myUART)
   \   0000002A   ....               LDI     R31, (myUART) >> 8
   \   0000002C   8100               LD      R16, Z
   \   0000002E   8111               LDD     R17, Z+1
   \   00000030   01F8               MOVW    R31:R30, R17:R16
   \   00000032   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000034   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000036   E000               LDI     R16, 0
   \   00000038   8300               ST      Z, R16
   \   0000003A   ....               LDI     R30, LOW(myUART)
   \   0000003C   ....               LDI     R31, (myUART) >> 8
   \   0000003E   8100               LD      R16, Z
   \   00000040   8111               LDD     R17, Z+1
   \   00000042   5F0F               SUBI    R16, 255
   \   00000044   4F1F               SBCI    R17, 255
   \   00000046   8300               ST      Z, R16
   \   00000048   8311               STD     Z+1, R17
    133              TxBufferCh0[myUART.TxFirst++] = 0x00;                  // End data
   \   0000004A   ....               LDI     R30, LOW(myUART)
   \   0000004C   ....               LDI     R31, (myUART) >> 8
   \   0000004E   8100               LD      R16, Z
   \   00000050   8111               LDD     R17, Z+1
   \   00000052   01F8               MOVW    R31:R30, R17:R16
   \   00000054   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000056   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000058   E000               LDI     R16, 0
   \   0000005A   8300               ST      Z, R16
   \   0000005C   ....               LDI     R30, LOW(myUART)
   \   0000005E   ....               LDI     R31, (myUART) >> 8
   \   00000060   8100               LD      R16, Z
   \   00000062   8111               LDD     R17, Z+1
   \   00000064   5F0F               SUBI    R16, 255
   \   00000066   4F1F               SBCI    R17, 255
   \   00000068   8300               ST      Z, R16
   \   0000006A   8311               STD     Z+1, R17
    134          
    135              TxBufferCh0[myUART.TxFirst++] = myUART.TxSeqCnt++;   // Sequence counter
   \   0000006C   9100....           LDS     R16, (myUART + 9)
   \   00000070   2F10               MOV     R17, R16
   \   00000072   9513               INC     R17
   \   00000074   9310....           STS     (myUART + 9), R17
   \   00000078   ....               LDI     R30, LOW(myUART)
   \   0000007A   ....               LDI     R31, (myUART) >> 8
   \   0000007C   8120               LD      R18, Z
   \   0000007E   8131               LDD     R19, Z+1
   \   00000080   01F9               MOVW    R31:R30, R19:R18
   \   00000082   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000084   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000086   8300               ST      Z, R16
   \   00000088   ....               LDI     R30, LOW(myUART)
   \   0000008A   ....               LDI     R31, (myUART) >> 8
   \   0000008C   8100               LD      R16, Z
   \   0000008E   8111               LDD     R17, Z+1
   \   00000090   5F0F               SUBI    R16, 255
   \   00000092   4F1F               SBCI    R17, 255
   \   00000094   8300               ST      Z, R16
   \   00000096   8311               STD     Z+1, R17
    136          
    137              TxBufferCh0[8] = myUART.TxFirst - 2;                // correct length because stx's
   \   00000098   ....               LDI     R30, LOW(myUART)
   \   0000009A   ....               LDI     R31, (myUART) >> 8
   \   0000009C   8100               LD      R16, Z
   \   0000009E   8111               LDD     R17, Z+1
   \   000000A0   5002               SUBI    R16, 2
   \   000000A2   9300....           STS     (TxBufferCh0 + 8), R16
    138              TxBufferCh0[9] = (myUART.TxFirst - 2) >> 8;           // packet len high
   \   000000A6   ....               LDI     R30, LOW(myUART)
   \   000000A8   ....               LDI     R31, (myUART) >> 8
   \   000000AA   8180               LD      R24, Z
   \   000000AC   8191               LDD     R25, Z+1
   \   000000AE   9702               SBIW    R25:R24, 2
   \   000000B0   2F89               MOV     R24, R25
   \   000000B2   E090               LDI     R25, 0
   \   000000B4   9380....           STS     (TxBufferCh0 + 9), R24
    139          
    140              TxBufferCh0[10] = CalcDSTxChecksum(10);         // Get header checksum
   \   000000B8   E00A               LDI     R16, 10
   \   000000BA   E010               LDI     R17, 0
   \   000000BC   ....               RCALL   CalcDSTxChecksum
   \   000000BE   9300....           STS     (TxBufferCh0 + 10), R16
    141          
    142              TxBufferCh0[myUART.TxFirst] = CalcDSTxChecksum(myUART.TxFirst); // Get checksum
   \   000000C2   ....               LDI     R30, LOW(myUART)
   \   000000C4   ....               LDI     R31, (myUART) >> 8
   \   000000C6   8100               LD      R16, Z
   \   000000C8   8111               LDD     R17, Z+1
   \   000000CA   ....               RCALL   CalcDSTxChecksum
   \   000000CC   ....               LDI     R30, LOW(myUART)
   \   000000CE   ....               LDI     R31, (myUART) >> 8
   \   000000D0   8120               LD      R18, Z
   \   000000D2   8131               LDD     R19, Z+1
   \   000000D4   01F9               MOVW    R31:R30, R19:R18
   \   000000D6   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000D8   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000DA   8300               ST      Z, R16
    143              myUART.TxFirst++;                                       // OBS!! must be inc here
   \   000000DC   ....               LDI     R30, LOW(myUART)
   \   000000DE   ....               LDI     R31, (myUART) >> 8
   \   000000E0   8100               LD      R16, Z
   \   000000E2   8111               LDD     R17, Z+1
   \   000000E4   5F0F               SUBI    R16, 255
   \   000000E6   4F1F               SBCI    R17, 255
   \   000000E8   8300               ST      Z, R16
   \   000000EA   8311               STD     Z+1, R17
    144          
    145              TxBufferCh0[myUART.TxFirst++] = ANPRO10_EOT;            // End of transmission
   \   000000EC   ....               LDI     R30, LOW(myUART)
   \   000000EE   ....               LDI     R31, (myUART) >> 8
   \   000000F0   8100               LD      R16, Z
   \   000000F2   8111               LDD     R17, Z+1
   \   000000F4   01F8               MOVW    R31:R30, R17:R16
   \   000000F6   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000F8   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000FA   E004               LDI     R16, 4
   \   000000FC   8300               ST      Z, R16
   \   000000FE   ....               LDI     R30, LOW(myUART)
   \   00000100   ....               LDI     R31, (myUART) >> 8
   \   00000102   8100               LD      R16, Z
   \   00000104   8111               LDD     R17, Z+1
   \   00000106   5F0F               SUBI    R16, 255
   \   00000108   4F1F               SBCI    R17, 255
   \   0000010A   8300               ST      Z, R16
   \   0000010C   8311               STD     Z+1, R17
    146              TxBufferCh0[myUART.TxFirst++] = 0x00;            //switch off transmitter delay
   \   0000010E   ....               LDI     R30, LOW(myUART)
   \   00000110   ....               LDI     R31, (myUART) >> 8
   \   00000112   8100               LD      R16, Z
   \   00000114   8111               LDD     R17, Z+1
   \   00000116   01F8               MOVW    R31:R30, R17:R16
   \   00000118   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000011A   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000011C   E000               LDI     R16, 0
   \   0000011E   8300               ST      Z, R16
   \   00000120   ....               LDI     R30, LOW(myUART)
   \   00000122   ....               LDI     R31, (myUART) >> 8
   \   00000124   8100               LD      R16, Z
   \   00000126   8111               LDD     R17, Z+1
   \   00000128   5F0F               SUBI    R16, 255
   \   0000012A   4F1F               SBCI    R17, 255
   \   0000012C   8300               ST      Z, R16
   \   0000012E   8311               STD     Z+1, R17
    147          
    148              myUART.TxCount = myUART.TxFirst;                      //bytes to send
   \   00000130   ....               LDI     R30, LOW(myUART)
   \   00000132   ....               LDI     R31, (myUART) >> 8
   \   00000134   8100               LD      R16, Z
   \   00000136   8111               LDD     R17, Z+1
   \   00000138   ....               LDI     R30, LOW(myUART)
   \   0000013A   ....               LDI     R31, (myUART) >> 8
   \   0000013C   8304               STD     Z+4, R16
   \   0000013E   8315               STD     Z+5, R17
    149              myUART.TxLast = 0;                                     // reset cunter
   \   00000140   ....               LDI     R30, LOW(myUART)
   \   00000142   ....               LDI     R31, (myUART) >> 8
   \   00000144   E000               LDI     R16, 0
   \   00000146   8302               STD     Z+2, R16
   \   00000148   E000               LDI     R16, 0
   \   0000014A   8303               STD     Z+3, R16
    150              myUART.TxPkCnt++;                                     // Count sent packages
   \   0000014C   ....               LDI     R30, LOW(myUART)
   \   0000014E   ....               LDI     R31, (myUART) >> 8
   \   00000150   8106               LDD     R16, Z+6
   \   00000152   8117               LDD     R17, Z+7
   \   00000154   5F0F               SUBI    R16, 255
   \   00000156   4F1F               SBCI    R17, 255
   \   00000158   8306               STD     Z+6, R16
   \   0000015A   8317               STD     Z+7, R17
    151              PORTE |= 0x04;                                     // TXE0 on
   \   0000015C   9A72               SBI     0x0E, 0x02
    152              SendPacketUart();                                     // send answer
   \   0000015E   ....               RCALL   SendPacketUart
    153          }
   \   00000160   9189               LD      R24, Y+
   \   00000162   9199               LD      R25, Y+
   \   00000164   9508               RET
   \   00000166                      REQUIRE _A_PORTE
    154          
    155          
    156          /*************************************************************************
    157          *
    158          * Build datablock for card status
    159          *
    160          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    161          void BuildStatusData(char ch) {
   \                     BuildStatusData:
   \   00000000   ........           CALL    ?PROLOGUE5_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004   2E40               MOV     R4, R16
    162          
    163              short ntna;
    164              myUART.RxSendReply = true;                               // flag for answering
   \   00000006   E001               LDI     R16, 1
   \   00000008   9300....           STS     (myUART + 24), R16
    165          
    166              TxBufferCh0[myUART.TxFirst++] = CMD_REP_STATUS & 0xff;
   \   0000000C   ....               LDI     R30, LOW(myUART)
   \   0000000E   ....               LDI     R31, (myUART) >> 8
   \   00000010   8100               LD      R16, Z
   \   00000012   8111               LDD     R17, Z+1
   \   00000014   01F8               MOVW    R31:R30, R17:R16
   \   00000016   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000018   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000001A   EE09               LDI     R16, 233
   \   0000001C   8300               ST      Z, R16
   \   0000001E   ....               LDI     R30, LOW(myUART)
   \   00000020   ....               LDI     R31, (myUART) >> 8
   \   00000022   8100               LD      R16, Z
   \   00000024   8111               LDD     R17, Z+1
   \   00000026   5F0F               SUBI    R16, 255
   \   00000028   4F1F               SBCI    R17, 255
   \   0000002A   8300               ST      Z, R16
   \   0000002C   8311               STD     Z+1, R17
    167              TxBufferCh0[myUART.TxFirst++] = CMD_REP_STATUS >> 8;
   \   0000002E   ....               LDI     R30, LOW(myUART)
   \   00000030   ....               LDI     R31, (myUART) >> 8
   \   00000032   8100               LD      R16, Z
   \   00000034   8111               LDD     R17, Z+1
   \   00000036   01F8               MOVW    R31:R30, R17:R16
   \   00000038   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000003A   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000003C   E003               LDI     R16, 3
   \   0000003E   8300               ST      Z, R16
   \   00000040   ....               LDI     R30, LOW(myUART)
   \   00000042   ....               LDI     R31, (myUART) >> 8
   \   00000044   8100               LD      R16, Z
   \   00000046   8111               LDD     R17, Z+1
   \   00000048   5F0F               SUBI    R16, 255
   \   0000004A   4F1F               SBCI    R17, 255
   \   0000004C   8300               ST      Z, R16
   \   0000004E   8311               STD     Z+1, R17
    168              ntna = myUART.TxFirst;                                    /* remember index */
   \   00000050   ....               LDI     R30, LOW(myUART)
   \   00000052   ....               LDI     R31, (myUART) >> 8
   \   00000054   8100               LD      R16, Z
   \   00000056   8111               LDD     R17, Z+1
   \   00000058   01D8               MOVW    R27:R26, R17:R16
    169              myUART.TxFirst += 2;                                      // two byte length
   \   0000005A   ....               LDI     R30, LOW(myUART)
   \   0000005C   ....               LDI     R31, (myUART) >> 8
   \   0000005E   8100               LD      R16, Z
   \   00000060   8111               LDD     R17, Z+1
   \   00000062   5F0E               SUBI    R16, 254
   \   00000064   4F1F               SBCI    R17, 255
   \   00000066   8300               ST      Z, R16
   \   00000068   8311               STD     Z+1, R17
    170              TxBufferCh0[myUART.TxFirst++] = ch;                // channel
   \   0000006A   ....               LDI     R30, LOW(myUART)
   \   0000006C   ....               LDI     R31, (myUART) >> 8
   \   0000006E   8100               LD      R16, Z
   \   00000070   8111               LDD     R17, Z+1
   \   00000072   01F8               MOVW    R31:R30, R17:R16
   \   00000074   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000076   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000078   8240               ST      Z, R4
   \   0000007A   ....               LDI     R30, LOW(myUART)
   \   0000007C   ....               LDI     R31, (myUART) >> 8
   \   0000007E   8100               LD      R16, Z
   \   00000080   8111               LDD     R17, Z+1
   \   00000082   5F0F               SUBI    R16, 255
   \   00000084   4F1F               SBCI    R17, 255
   \   00000086   8300               ST      Z, R16
   \   00000088   8311               STD     Z+1, R17
    171              TxBufferCh0[myUART.TxFirst++] = 0x10 + UnitID;               // Product ID
   \   0000008A   9100....           LDS     R16, UnitID
   \   0000008E   5F00               SUBI    R16, 240
   \   00000090   ....               LDI     R30, LOW(myUART)
   \   00000092   ....               LDI     R31, (myUART) >> 8
   \   00000094   8120               LD      R18, Z
   \   00000096   8131               LDD     R19, Z+1
   \   00000098   01F9               MOVW    R31:R30, R19:R18
   \   0000009A   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000009C   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000009E   8300               ST      Z, R16
   \   000000A0   ....               LDI     R30, LOW(myUART)
   \   000000A2   ....               LDI     R31, (myUART) >> 8
   \   000000A4   8100               LD      R16, Z
   \   000000A6   8111               LDD     R17, Z+1
   \   000000A8   5F0F               SUBI    R16, 255
   \   000000AA   4F1F               SBCI    R17, 255
   \   000000AC   8300               ST      Z, R16
   \   000000AE   8311               STD     Z+1, R17
    172              TxBufferCh0[myUART.TxFirst++] = MyAddress();           // unit address				/* get the address */
   \   000000B0   ....               LDI     R30, LOW(myUART)
   \   000000B2   ....               LDI     R31, (myUART) >> 8
   \   000000B4   8180               LD      R24, Z
   \   000000B6   8191               LDD     R25, Z+1
   \   000000B8   018C               MOVW    R17:R16, R25:R24
   \   000000BA   5F0F               SUBI    R16, 255
   \   000000BC   4F1F               SBCI    R17, 255
   \   000000BE   ....               LDI     R30, LOW(myUART)
   \   000000C0   ....               LDI     R31, (myUART) >> 8
   \   000000C2   8300               ST      Z, R16
   \   000000C4   8311               STD     Z+1, R17
   \   000000C6   ........           CALL    MyAddress
   \   000000CA   01FC               MOVW    R31:R30, R25:R24
   \   000000CC   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000CE   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000D0   8300               ST      Z, R16
    173              TxBufferCh0[myUART.TxFirst++] = PROG_VERSION;       // software version */
   \   000000D2   ....               LDI     R30, LOW(myUART)
   \   000000D4   ....               LDI     R31, (myUART) >> 8
   \   000000D6   8100               LD      R16, Z
   \   000000D8   8111               LDD     R17, Z+1
   \   000000DA   01F8               MOVW    R31:R30, R17:R16
   \   000000DC   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000DE   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000E0   E208               LDI     R16, 40
   \   000000E2   8300               ST      Z, R16
   \   000000E4   ....               LDI     R30, LOW(myUART)
   \   000000E6   ....               LDI     R31, (myUART) >> 8
   \   000000E8   8100               LD      R16, Z
   \   000000EA   8111               LDD     R17, Z+1
   \   000000EC   5F0F               SUBI    R16, 255
   \   000000EE   4F1F               SBCI    R17, 255
   \   000000F0   8300               ST      Z, R16
   \   000000F2   8311               STD     Z+1, R17
    174              TxBufferCh0[myUART.TxFirst++] = COMP_VERSION;        // cpmpability version
   \   000000F4   ....               LDI     R30, LOW(myUART)
   \   000000F6   ....               LDI     R31, (myUART) >> 8
   \   000000F8   8100               LD      R16, Z
   \   000000FA   8111               LDD     R17, Z+1
   \   000000FC   01F8               MOVW    R31:R30, R17:R16
   \   000000FE   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000100   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000102   E001               LDI     R16, 1
   \   00000104   8300               ST      Z, R16
   \   00000106   ....               LDI     R30, LOW(myUART)
   \   00000108   ....               LDI     R31, (myUART) >> 8
   \   0000010A   8100               LD      R16, Z
   \   0000010C   8111               LDD     R17, Z+1
   \   0000010E   5F0F               SUBI    R16, 255
   \   00000110   4F1F               SBCI    R17, 255
   \   00000112   8300               ST      Z, R16
   \   00000114   8311               STD     Z+1, R17
    175              TxBufferCh0[myUART.TxFirst++] = STORE_VERSION;        // cpmpability version
   \   00000116   ....               LDI     R30, LOW(myUART)
   \   00000118   ....               LDI     R31, (myUART) >> 8
   \   0000011A   8100               LD      R16, Z
   \   0000011C   8111               LDD     R17, Z+1
   \   0000011E   01F8               MOVW    R31:R30, R17:R16
   \   00000120   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000122   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000124   E002               LDI     R16, 2
   \   00000126   8300               ST      Z, R16
   \   00000128   ....               LDI     R30, LOW(myUART)
   \   0000012A   ....               LDI     R31, (myUART) >> 8
   \   0000012C   8100               LD      R16, Z
   \   0000012E   8111               LDD     R17, Z+1
   \   00000130   5F0F               SUBI    R16, 255
   \   00000132   4F1F               SBCI    R17, 255
   \   00000134   8300               ST      Z, R16
   \   00000136   8311               STD     Z+1, R17
    176              TxBufferCh0[myUART.TxFirst++] = (RXSIZE_UART & 0xff);         // rx buffer size
   \   00000138   ....               LDI     R30, LOW(myUART)
   \   0000013A   ....               LDI     R31, (myUART) >> 8
   \   0000013C   8100               LD      R16, Z
   \   0000013E   8111               LDD     R17, Z+1
   \   00000140   01F8               MOVW    R31:R30, R17:R16
   \   00000142   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000144   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000146   E50E               LDI     R16, 94
   \   00000148   8300               ST      Z, R16
   \   0000014A   ....               LDI     R30, LOW(myUART)
   \   0000014C   ....               LDI     R31, (myUART) >> 8
   \   0000014E   8100               LD      R16, Z
   \   00000150   8111               LDD     R17, Z+1
   \   00000152   5F0F               SUBI    R16, 255
   \   00000154   4F1F               SBCI    R17, 255
   \   00000156   8300               ST      Z, R16
   \   00000158   8311               STD     Z+1, R17
    177              TxBufferCh0[myUART.TxFirst++] = ((RXSIZE_UART >> 8) & 0xff); // rx buffer size
   \   0000015A   ....               LDI     R30, LOW(myUART)
   \   0000015C   ....               LDI     R31, (myUART) >> 8
   \   0000015E   8100               LD      R16, Z
   \   00000160   8111               LDD     R17, Z+1
   \   00000162   01F8               MOVW    R31:R30, R17:R16
   \   00000164   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000166   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000168   E001               LDI     R16, 1
   \   0000016A   8300               ST      Z, R16
   \   0000016C   ....               LDI     R30, LOW(myUART)
   \   0000016E   ....               LDI     R31, (myUART) >> 8
   \   00000170   8100               LD      R16, Z
   \   00000172   8111               LDD     R17, Z+1
   \   00000174   5F0F               SUBI    R16, 255
   \   00000176   4F1F               SBCI    R17, 255
   \   00000178   8300               ST      Z, R16
   \   0000017A   8311               STD     Z+1, R17
    178              TxBufferCh0[myUART.TxFirst++] = (TXSIZE_UART & 0xff);         // tx buffer size
   \   0000017C   ....               LDI     R30, LOW(myUART)
   \   0000017E   ....               LDI     R31, (myUART) >> 8
   \   00000180   8100               LD      R16, Z
   \   00000182   8111               LDD     R17, Z+1
   \   00000184   01F8               MOVW    R31:R30, R17:R16
   \   00000186   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000188   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000018A   E50E               LDI     R16, 94
   \   0000018C   8300               ST      Z, R16
   \   0000018E   ....               LDI     R30, LOW(myUART)
   \   00000190   ....               LDI     R31, (myUART) >> 8
   \   00000192   8100               LD      R16, Z
   \   00000194   8111               LDD     R17, Z+1
   \   00000196   5F0F               SUBI    R16, 255
   \   00000198   4F1F               SBCI    R17, 255
   \   0000019A   8300               ST      Z, R16
   \   0000019C   8311               STD     Z+1, R17
    179              TxBufferCh0[myUART.TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);  // tx buffer size
   \   0000019E   ....               LDI     R30, LOW(myUART)
   \   000001A0   ....               LDI     R31, (myUART) >> 8
   \   000001A2   8100               LD      R16, Z
   \   000001A4   8111               LDD     R17, Z+1
   \   000001A6   01F8               MOVW    R31:R30, R17:R16
   \   000001A8   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000001AA   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000001AC   E001               LDI     R16, 1
   \   000001AE   8300               ST      Z, R16
   \   000001B0   ....               LDI     R30, LOW(myUART)
   \   000001B2   ....               LDI     R31, (myUART) >> 8
   \   000001B4   8100               LD      R16, Z
   \   000001B6   8111               LDD     R17, Z+1
   \   000001B8   5F0F               SUBI    R16, 255
   \   000001BA   4F1F               SBCI    R17, 255
   \   000001BC   8300               ST      Z, R16
   \   000001BE   8311               STD     Z+1, R17
    180              TxBufferCh0[myUART.TxFirst++] = ResetStatus;                  // restart flag
   \   000001C0   9100....           LDS     R16, ResetStatus
   \   000001C4   ....               LDI     R30, LOW(myUART)
   \   000001C6   ....               LDI     R31, (myUART) >> 8
   \   000001C8   8120               LD      R18, Z
   \   000001CA   8131               LDD     R19, Z+1
   \   000001CC   01F9               MOVW    R31:R30, R19:R18
   \   000001CE   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000001D0   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000001D2   8300               ST      Z, R16
   \   000001D4   ....               LDI     R30, LOW(myUART)
   \   000001D6   ....               LDI     R31, (myUART) >> 8
   \   000001D8   8100               LD      R16, Z
   \   000001DA   8111               LDD     R17, Z+1
   \   000001DC   5F0F               SUBI    R16, 255
   \   000001DE   4F1F               SBCI    R17, 255
   \   000001E0   8300               ST      Z, R16
   \   000001E2   8311               STD     Z+1, R17
    181              TxBufferCh0[myUART.TxFirst++] = PROGTYPE_BOOT;                // Boot program
   \   000001E4   ....               LDI     R30, LOW(myUART)
   \   000001E6   ....               LDI     R31, (myUART) >> 8
   \   000001E8   8100               LD      R16, Z
   \   000001EA   8111               LDD     R17, Z+1
   \   000001EC   01F8               MOVW    R31:R30, R17:R16
   \   000001EE   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000001F0   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000001F2   E000               LDI     R16, 0
   \   000001F4   8300               ST      Z, R16
   \   000001F6   ....               LDI     R30, LOW(myUART)
   \   000001F8   ....               LDI     R31, (myUART) >> 8
   \   000001FA   8100               LD      R16, Z
   \   000001FC   8111               LDD     R17, Z+1
   \   000001FE   5F0F               SUBI    R16, 255
   \   00000200   4F1F               SBCI    R17, 255
   \   00000202   8300               ST      Z, R16
   \   00000204   8311               STD     Z+1, R17
    182          
    183              TxBufferCh0[ntna] = (myUART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   00000206   ....               LDI     R30, LOW(myUART)
   \   00000208   ....               LDI     R31, (myUART) >> 8
   \   0000020A   8100               LD      R16, Z
   \   0000020C   8111               LDD     R17, Z+1
   \   0000020E   2F1A               MOV     R17, R26
   \   00000210   1B01               SUB     R16, R17
   \   00000212   5002               SUBI    R16, 2
   \   00000214   01FD               MOVW    R31:R30, R27:R26
   \   00000216   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000218   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000021A   8300               ST      Z, R16
    184              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000021C   ....               LDI     R30, LOW(myUART)
   \   0000021E   ....               LDI     R31, (myUART) >> 8
   \   00000220   8180               LD      R24, Z
   \   00000222   8191               LDD     R25, Z+1
   \   00000224   1B8A               SUB     R24, R26
   \   00000226   0B9B               SBC     R25, R27
   \   00000228   9702               SBIW    R25:R24, 2
   \   0000022A   2F89               MOV     R24, R25
   \   0000022C   E090               LDI     R25, 0
   \   0000022E   01FD               MOVW    R31:R30, R27:R26
   \   00000230   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000232   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000234   8381               STD     Z+1, R24
    185          
    186              ResetStatus = 0;                                                       // set reset stat to 0 = read
   \   00000236   E000               LDI     R16, 0
   \   00000238   9300....           STS     ResetStatus, R16
    187          }
   \   0000023C   E0E5               LDI     R30, 5
   \   0000023E   ........           JMP     ?EPILOGUE_B5_L09
    188          
    189          /*************************************************************************
    190          *
    191          * Build datablock for Flash ID
    192          *
    193          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    194          void BuildFlashID(char ch) {
   \                     BuildFlashID:
   \   00000000   01BC               MOVW    R23:R22, R25:R24
   \   00000002   2F20               MOV     R18, R16
    195          
    196              short ntna;
    197              myUART.RxSendReply = true;                               // flag for answering
   \   00000004   E031               LDI     R19, 1
   \   00000006   9330....           STS     (myUART + 24), R19
    198          
    199              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_ID & 0xff;
   \   0000000A   ....               LDI     R30, LOW(myUART)
   \   0000000C   ....               LDI     R31, (myUART) >> 8
   \   0000000E   8140               LD      R20, Z
   \   00000010   8151               LDD     R21, Z+1
   \   00000012   01FA               MOVW    R31:R30, R21:R20
   \   00000014   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000016   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000018   E935               LDI     R19, 149
   \   0000001A   8330               ST      Z, R19
   \   0000001C   ....               LDI     R30, LOW(myUART)
   \   0000001E   ....               LDI     R31, (myUART) >> 8
   \   00000020   8140               LD      R20, Z
   \   00000022   8151               LDD     R21, Z+1
   \   00000024   5F4F               SUBI    R20, 255
   \   00000026   4F5F               SBCI    R21, 255
   \   00000028   8340               ST      Z, R20
   \   0000002A   8351               STD     Z+1, R21
    200              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_ID >> 8;
   \   0000002C   ....               LDI     R30, LOW(myUART)
   \   0000002E   ....               LDI     R31, (myUART) >> 8
   \   00000030   8140               LD      R20, Z
   \   00000032   8151               LDD     R21, Z+1
   \   00000034   01FA               MOVW    R31:R30, R21:R20
   \   00000036   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000038   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000003A   E037               LDI     R19, 7
   \   0000003C   8330               ST      Z, R19
   \   0000003E   ....               LDI     R30, LOW(myUART)
   \   00000040   ....               LDI     R31, (myUART) >> 8
   \   00000042   8140               LD      R20, Z
   \   00000044   8151               LDD     R21, Z+1
   \   00000046   5F4F               SUBI    R20, 255
   \   00000048   4F5F               SBCI    R21, 255
   \   0000004A   8340               ST      Z, R20
   \   0000004C   8351               STD     Z+1, R21
    201              ntna = myUART.TxFirst;                                    // remember index
   \   0000004E   ....               LDI     R30, LOW(myUART)
   \   00000050   ....               LDI     R31, (myUART) >> 8
   \   00000052   8140               LD      R20, Z
   \   00000054   8151               LDD     R21, Z+1
   \   00000056   018A               MOVW    R17:R16, R21:R20
    202              myUART.TxFirst += 2;                                      // two byte length
   \   00000058   ....               LDI     R30, LOW(myUART)
   \   0000005A   ....               LDI     R31, (myUART) >> 8
   \   0000005C   8140               LD      R20, Z
   \   0000005E   8151               LDD     R21, Z+1
   \   00000060   5F4E               SUBI    R20, 254
   \   00000062   4F5F               SBCI    R21, 255
   \   00000064   8340               ST      Z, R20
   \   00000066   8351               STD     Z+1, R21
    203          
    204              TxBufferCh0[myUART.TxFirst++] = PARTCODE;
   \   00000068   ....               LDI     R30, LOW(myUART)
   \   0000006A   ....               LDI     R31, (myUART) >> 8
   \   0000006C   8140               LD      R20, Z
   \   0000006E   8151               LDD     R21, Z+1
   \   00000070   01FA               MOVW    R31:R30, R21:R20
   \   00000072   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000074   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000076   E434               LDI     R19, 68
   \   00000078   8330               ST      Z, R19
   \   0000007A   ....               LDI     R30, LOW(myUART)
   \   0000007C   ....               LDI     R31, (myUART) >> 8
   \   0000007E   8140               LD      R20, Z
   \   00000080   8151               LDD     R21, Z+1
   \   00000082   5F4F               SUBI    R20, 255
   \   00000084   4F5F               SBCI    R21, 255
   \   00000086   8340               ST      Z, R20
   \   00000088   8351               STD     Z+1, R21
    205              TxBufferCh0[myUART.TxFirst++] = SIGNATURE_BYTE_1;
   \   0000008A   ....               LDI     R30, LOW(myUART)
   \   0000008C   ....               LDI     R31, (myUART) >> 8
   \   0000008E   8140               LD      R20, Z
   \   00000090   8151               LDD     R21, Z+1
   \   00000092   01FA               MOVW    R31:R30, R21:R20
   \   00000094   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000096   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000098   E13E               LDI     R19, 30
   \   0000009A   8330               ST      Z, R19
   \   0000009C   ....               LDI     R30, LOW(myUART)
   \   0000009E   ....               LDI     R31, (myUART) >> 8
   \   000000A0   8140               LD      R20, Z
   \   000000A2   8151               LDD     R21, Z+1
   \   000000A4   5F4F               SUBI    R20, 255
   \   000000A6   4F5F               SBCI    R21, 255
   \   000000A8   8340               ST      Z, R20
   \   000000AA   8351               STD     Z+1, R21
    206              TxBufferCh0[myUART.TxFirst++] = SIGNATURE_BYTE_2;
   \   000000AC   ....               LDI     R30, LOW(myUART)
   \   000000AE   ....               LDI     R31, (myUART) >> 8
   \   000000B0   8140               LD      R20, Z
   \   000000B2   8151               LDD     R21, Z+1
   \   000000B4   01FA               MOVW    R31:R30, R21:R20
   \   000000B6   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000B8   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000BA   E937               LDI     R19, 151
   \   000000BC   8330               ST      Z, R19
   \   000000BE   ....               LDI     R30, LOW(myUART)
   \   000000C0   ....               LDI     R31, (myUART) >> 8
   \   000000C2   8140               LD      R20, Z
   \   000000C4   8151               LDD     R21, Z+1
   \   000000C6   5F4F               SUBI    R20, 255
   \   000000C8   4F5F               SBCI    R21, 255
   \   000000CA   8340               ST      Z, R20
   \   000000CC   8351               STD     Z+1, R21
    207              TxBufferCh0[myUART.TxFirst++] = SIGNATURE_BYTE_3;
   \   000000CE   ....               LDI     R30, LOW(myUART)
   \   000000D0   ....               LDI     R31, (myUART) >> 8
   \   000000D2   8140               LD      R20, Z
   \   000000D4   8151               LDD     R21, Z+1
   \   000000D6   01FA               MOVW    R31:R30, R21:R20
   \   000000D8   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000DA   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000DC   E032               LDI     R19, 2
   \   000000DE   8330               ST      Z, R19
   \   000000E0   ....               LDI     R30, LOW(myUART)
   \   000000E2   ....               LDI     R31, (myUART) >> 8
   \   000000E4   8140               LD      R20, Z
   \   000000E6   8151               LDD     R21, Z+1
   \   000000E8   5F4F               SUBI    R20, 255
   \   000000EA   4F5F               SBCI    R21, 255
   \   000000EC   8340               ST      Z, R20
   \   000000EE   8351               STD     Z+1, R21
    208          
    209          
    210              TxBufferCh0[ntna] = (myUART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000F0   ....               LDI     R30, LOW(myUART)
   \   000000F2   ....               LDI     R31, (myUART) >> 8
   \   000000F4   8140               LD      R20, Z
   \   000000F6   8151               LDD     R21, Z+1
   \   000000F8   2F30               MOV     R19, R16
   \   000000FA   1B43               SUB     R20, R19
   \   000000FC   5042               SUBI    R20, 2
   \   000000FE   01F8               MOVW    R31:R30, R17:R16
   \   00000100   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000102   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000104   8340               ST      Z, R20
    211              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000106   ....               LDI     R30, LOW(myUART)
   \   00000108   ....               LDI     R31, (myUART) >> 8
   \   0000010A   8180               LD      R24, Z
   \   0000010C   8191               LDD     R25, Z+1
   \   0000010E   1B80               SUB     R24, R16
   \   00000110   0B91               SBC     R25, R17
   \   00000112   9702               SBIW    R25:R24, 2
   \   00000114   2F89               MOV     R24, R25
   \   00000116   E090               LDI     R25, 0
   \   00000118   01F8               MOVW    R31:R30, R17:R16
   \   0000011A   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000011C   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000011E   8381               STD     Z+1, R24
    212          
    213          }
   \   00000120   01CB               MOVW    R25:R24, R23:R22
   \   00000122   9508               RET
    214          
    215          /*************************************************************************
    216          *
    217          * Erase Flash 
    218          *
    219          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    220          void EraseFlash(void) {
   \                     EraseFlash:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    221          
    222              unsigned short ntna, address;
    223              myUART.RxSendReply = true;                               // flag for answering
   \   00000004   E001               LDI     R16, 1
   \   00000006   9300....           STS     (myUART + 24), R16
    224          
    225              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_ERASE & 0xff;
   \   0000000A   ....               LDI     R30, LOW(myUART)
   \   0000000C   ....               LDI     R31, (myUART) >> 8
   \   0000000E   8100               LD      R16, Z
   \   00000010   8111               LDD     R17, Z+1
   \   00000012   01F8               MOVW    R31:R30, R17:R16
   \   00000014   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000016   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000018   E90F               LDI     R16, 159
   \   0000001A   8300               ST      Z, R16
   \   0000001C   ....               LDI     R30, LOW(myUART)
   \   0000001E   ....               LDI     R31, (myUART) >> 8
   \   00000020   8100               LD      R16, Z
   \   00000022   8111               LDD     R17, Z+1
   \   00000024   5F0F               SUBI    R16, 255
   \   00000026   4F1F               SBCI    R17, 255
   \   00000028   8300               ST      Z, R16
   \   0000002A   8311               STD     Z+1, R17
    226              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_ERASE >> 8;
   \   0000002C   ....               LDI     R30, LOW(myUART)
   \   0000002E   ....               LDI     R31, (myUART) >> 8
   \   00000030   8100               LD      R16, Z
   \   00000032   8111               LDD     R17, Z+1
   \   00000034   01F8               MOVW    R31:R30, R17:R16
   \   00000036   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000038   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000003A   E007               LDI     R16, 7
   \   0000003C   8300               ST      Z, R16
   \   0000003E   ....               LDI     R30, LOW(myUART)
   \   00000040   ....               LDI     R31, (myUART) >> 8
   \   00000042   8100               LD      R16, Z
   \   00000044   8111               LDD     R17, Z+1
   \   00000046   5F0F               SUBI    R16, 255
   \   00000048   4F1F               SBCI    R17, 255
   \   0000004A   8300               ST      Z, R16
   \   0000004C   8311               STD     Z+1, R17
    227              ntna = myUART.TxFirst;                                    // remember index
   \   0000004E   ....               LDI     R30, LOW(myUART)
   \   00000050   ....               LDI     R31, (myUART) >> 8
   \   00000052   8100               LD      R16, Z
   \   00000054   8111               LDD     R17, Z+1
   \   00000056   01D8               MOVW    R27:R26, R17:R16
    228              myUART.TxFirst += 2;                                      // two byte length
   \   00000058   ....               LDI     R30, LOW(myUART)
   \   0000005A   ....               LDI     R31, (myUART) >> 8
   \   0000005C   8100               LD      R16, Z
   \   0000005E   8111               LDD     R17, Z+1
   \   00000060   5F0E               SUBI    R16, 254
   \   00000062   4F1F               SBCI    R17, 255
   \   00000064   8300               ST      Z, R16
   \   00000066   8311               STD     Z+1, R17
    229          
    230          #ifdef LARGE_MEMORY               //SPM uses Z pointer but the pointer is only 16bit and
    231              RAMPZ = 0x00;                     //can only address up to 64Kbytes FLASH to adresse higher
   \   00000068   E000               LDI     R16, 0
   \   0000006A   BF0B               OUT     0x3B, R16
    232              //location it require the use of RAMPZ
    233          
    234              for ( address = 0; ((address < (unsigned int)(APP_END & 0xFFFF)) | (RAMPZ == 0x00)); address += PAGESIZE ) {
   \   0000006C   E080               LDI     R24, 0
   \   0000006E   E090               LDI     R25, 0
   \                     ??EraseFlash_0:
   \   00000070   3080               CPI     R24, 0
   \   00000072   EE00               LDI     R16, 224
   \   00000074   0790               CPC     R25, R16
   \   00000076   F410               BRCC    ??EraseFlash_1
   \   00000078   E011               LDI     R17, 1
   \   0000007A   C001               RJMP    ??EraseFlash_2
   \                     ??EraseFlash_1:
   \   0000007C   E010               LDI     R17, 0
   \                     ??EraseFlash_2:
   \   0000007E   B70B               IN      R16, 0x3B
   \   00000080   2300               TST     R16
   \   00000082   F411               BRNE    ??EraseFlash_3
   \   00000084   E001               LDI     R16, 1
   \   00000086   C001               RJMP    ??EraseFlash_4
   \                     ??EraseFlash_3:
   \   00000088   E000               LDI     R16, 0
   \                     ??EraseFlash_4:
   \   0000008A   2B10               OR      R17, R16
   \   0000008C   2311               TST     R17
   \   0000008E   F089               BREQ    ??EraseFlash_5
    235                  write_page(address, (1 << PGERS) + (1 << SPMEN));              //Perform page erase
   \   00000090   E023               LDI     R18, 3
   \   00000092   018C               MOVW    R17:R16, R25:R24
   \   00000094   ........           CALL    write_page
    236                  write_page(address, (1 << REENABLE_RWW_BIT) + (1 << SPMEN));  //Re-enable the RWW section
   \   00000098   E121               LDI     R18, 17
   \   0000009A   018C               MOVW    R17:R16, R25:R24
   \   0000009C   ........           CALL    write_page
    237          
    238                  if ( address >= (0xFFFF - PAGESIZE) ) //Last section on lower 64k segment is erased
   \   000000A0   3F8F               CPI     R24, 255
   \   000000A2   EF0E               LDI     R16, 254
   \   000000A4   0790               CPC     R25, R16
   \   000000A6   F010               BRCS    ??EraseFlash_6
    239                      RAMPZ = (1 << RAMPZ0);         //RAMPZ has to incremented into upper 64k segment
   \   000000A8   E001               LDI     R16, 1
   \   000000AA   BF0B               OUT     0x3B, R16
    240              }
   \                     ??EraseFlash_6:
   \   000000AC   5080               SUBI    R24, 0
   \   000000AE   4F9F               SBCI    R25, 255
   \   000000B0   CFDF               RJMP    ??EraseFlash_0
    241              RAMPZ = 0x00;                     //Clear RAMPZ pointer
   \                     ??EraseFlash_5:
   \   000000B2   E000               LDI     R16, 0
   \   000000B4   BF0B               OUT     0x3B, R16
    242          
    243          #else
    244          
    245              for ( address = 0; address < APP_END; address += PAGESIZE ) {  //Application section = 60 pages
    246                  write_page(address, (1 << PGERS) + (1 << SPMEN));       //Perform page erase
    247                  write_page(address, (1 << REENABLE_RWW_BIT) + (1 << SPMEN));  //Re-enable the RWW section
    248              }
    249          
    250          #endif
    251              TxBufferCh0[myUART.TxFirst++] = FLASH_ERASE_OK;                 // Answer that the erase is OK
   \   000000B6   ....               LDI     R30, LOW(myUART)
   \   000000B8   ....               LDI     R31, (myUART) >> 8
   \   000000BA   8100               LD      R16, Z
   \   000000BC   8111               LDD     R17, Z+1
   \   000000BE   01F8               MOVW    R31:R30, R17:R16
   \   000000C0   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000C2   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000C4   E000               LDI     R16, 0
   \   000000C6   8300               ST      Z, R16
   \   000000C8   ....               LDI     R30, LOW(myUART)
   \   000000CA   ....               LDI     R31, (myUART) >> 8
   \   000000CC   8100               LD      R16, Z
   \   000000CE   8111               LDD     R17, Z+1
   \   000000D0   5F0F               SUBI    R16, 255
   \   000000D2   4F1F               SBCI    R17, 255
   \   000000D4   8300               ST      Z, R16
   \   000000D6   8311               STD     Z+1, R17
    252          
    253              TxBufferCh0[ntna] = (myUART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000D8   ....               LDI     R30, LOW(myUART)
   \   000000DA   ....               LDI     R31, (myUART) >> 8
   \   000000DC   8100               LD      R16, Z
   \   000000DE   8111               LDD     R17, Z+1
   \   000000E0   2F1A               MOV     R17, R26
   \   000000E2   1B01               SUB     R16, R17
   \   000000E4   5002               SUBI    R16, 2
   \   000000E6   01FD               MOVW    R31:R30, R27:R26
   \   000000E8   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000EA   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000EC   8300               ST      Z, R16
    254              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000EE   ....               LDI     R30, LOW(myUART)
   \   000000F0   ....               LDI     R31, (myUART) >> 8
   \   000000F2   8100               LD      R16, Z
   \   000000F4   8111               LDD     R17, Z+1
   \   000000F6   1B0A               SUB     R16, R26
   \   000000F8   0B1B               SBC     R17, R27
   \   000000FA   5002               SUBI    R16, 2
   \   000000FC   4010               SBCI    R17, 0
   \   000000FE   2F01               MOV     R16, R17
   \   00000100   E010               LDI     R17, 0
   \   00000102   01FD               MOVW    R31:R30, R27:R26
   \   00000104   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000106   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000108   8301               STD     Z+1, R16
    255          
    256          }
   \   0000010A   E0E4               LDI     R30, 4
   \   0000010C   ........           JMP     ?EPILOGUE_B4_L09
   \   00000110                      REQUIRE _A_RAMPZ
    257          
    258          /*************************************************************************
    259          *
    260          * Program Flash 
    261          *
    262          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    263          void ProgramFlash(unsigned Pointer) {
   \                     ProgramFlash:
   \   00000000   ........           CALL    ?PROLOGUE14_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004                      REQUIRE ?Register_R12_is_cg_reg
   \   00000004                      REQUIRE ?Register_R13_is_cg_reg
   \   00000004   0128               MOVW    R5:R4, R17:R16
    264              __watchdog_reset();
   \   00000006   95A8               WDR
    265          
    266              unsigned ntna;
    267              myUART.RxSendReply = true;                               // flag for answering
   \   00000008   E001               LDI     R16, 1
   \   0000000A   9300....           STS     (myUART + 24), R16
    268          
    269              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_PROG & 0xff;
   \   0000000E   ....               LDI     R30, LOW(myUART)
   \   00000010   ....               LDI     R31, (myUART) >> 8
   \   00000012   8100               LD      R16, Z
   \   00000014   8111               LDD     R17, Z+1
   \   00000016   01F8               MOVW    R31:R30, R17:R16
   \   00000018   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000001A   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000001C   EA09               LDI     R16, 169
   \   0000001E   8300               ST      Z, R16
   \   00000020   ....               LDI     R30, LOW(myUART)
   \   00000022   ....               LDI     R31, (myUART) >> 8
   \   00000024   8100               LD      R16, Z
   \   00000026   8111               LDD     R17, Z+1
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   8300               ST      Z, R16
   \   0000002E   8311               STD     Z+1, R17
    270              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_PROG >> 8;
   \   00000030   ....               LDI     R30, LOW(myUART)
   \   00000032   ....               LDI     R31, (myUART) >> 8
   \   00000034   8100               LD      R16, Z
   \   00000036   8111               LDD     R17, Z+1
   \   00000038   01F8               MOVW    R31:R30, R17:R16
   \   0000003A   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000003C   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000003E   E007               LDI     R16, 7
   \   00000040   8300               ST      Z, R16
   \   00000042   ....               LDI     R30, LOW(myUART)
   \   00000044   ....               LDI     R31, (myUART) >> 8
   \   00000046   8100               LD      R16, Z
   \   00000048   8111               LDD     R17, Z+1
   \   0000004A   5F0F               SUBI    R16, 255
   \   0000004C   4F1F               SBCI    R17, 255
   \   0000004E   8300               ST      Z, R16
   \   00000050   8311               STD     Z+1, R17
    271              ntna = myUART.TxFirst;                                    // remember index
   \   00000052   ....               LDI     R30, LOW(myUART)
   \   00000054   ....               LDI     R31, (myUART) >> 8
   \   00000056   8100               LD      R16, Z
   \   00000058   8111               LDD     R17, Z+1
   \   0000005A   0168               MOVW    R13:R12, R17:R16
    272              myUART.TxFirst += 2;                                      // two byte length
   \   0000005C   ....               LDI     R30, LOW(myUART)
   \   0000005E   ....               LDI     R31, (myUART) >> 8
   \   00000060   8100               LD      R16, Z
   \   00000062   8111               LDD     R17, Z+1
   \   00000064   5F0E               SUBI    R16, 254
   \   00000066   4F1F               SBCI    R17, 255
   \   00000068   8300               ST      Z, R16
   \   0000006A   8311               STD     Z+1, R17
    273          
    274              unsigned Address = RxBufferCh0[Pointer + 0] + (RxBufferCh0[Pointer + 1] << 8); // save address
   \   0000006C   01F2               MOVW    R31:R30, R5:R4
   \   0000006E   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000070   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000072   81A0               LD      R26, Z
   \   00000074   01F2               MOVW    R31:R30, R5:R4
   \   00000076   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000078   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   0000007A   81B1               LDD     R27, Z+1
    275              unsigned Nobytes = RxBufferCh0[Pointer + 2] + (RxBufferCh0[Pointer + 3] << 8); // save address
   \   0000007C   01F2               MOVW    R31:R30, R5:R4
   \   0000007E   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000080   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000082   80A2               LDD     R10, Z+2
   \   00000084   01F2               MOVW    R31:R30, R5:R4
   \   00000086   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000088   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   0000008A   80B3               LDD     R11, Z+3
    276              Pointer += 4;
   \   0000008C   E004               LDI     R16, 4
   \   0000008E   0E40               ADD     R4, R16
   \   00000090   E000               LDI     R16, 0
   \   00000092   1E50               ADC     R5, R16
    277              unsigned Ptr = Pointer;
   \   00000094   01C2               MOVW    R25:R24, R5:R4
    278              if ( Nobytes > PAGESIZE ) {
   \   00000096   E001               LDI     R16, 1
   \   00000098   16A0               CP      R10, R16
   \   0000009A   E001               LDI     R16, 1
   \   0000009C   06B0               CPC     R11, R16
   \   0000009E   F090               BRCS    ??ProgramFlash_0
    279                  TxBufferCh0[myUART.TxFirst++] = FLASH_PROG_PAGEF;               // Answer with Page fault
   \   000000A0   ....               LDI     R30, LOW(myUART)
   \   000000A2   ....               LDI     R31, (myUART) >> 8
   \   000000A4   8100               LD      R16, Z
   \   000000A6   8111               LDD     R17, Z+1
   \   000000A8   01F8               MOVW    R31:R30, R17:R16
   \   000000AA   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000AC   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000AE   E001               LDI     R16, 1
   \   000000B0   8300               ST      Z, R16
   \   000000B2   ....               LDI     R30, LOW(myUART)
   \   000000B4   ....               LDI     R31, (myUART) >> 8
   \   000000B6   8100               LD      R16, Z
   \   000000B8   8111               LDD     R17, Z+1
   \   000000BA   5F0F               SUBI    R16, 255
   \   000000BC   4F1F               SBCI    R17, 255
   \   000000BE   8300               ST      Z, R16
   \   000000C0   8311               STD     Z+1, R17
   \   000000C2   C080               RJMP    ??ProgramFlash_1
    280              } else {
    281          #ifdef LARGE_MEMORY
    282                  if ( Address >= 0x7FFF ) {
   \                     ??ProgramFlash_0:
   \   000000C4   3FAF               CPI     R26, 255
   \   000000C6   E70F               LDI     R16, 127
   \   000000C8   07B0               CPC     R27, R16
   \   000000CA   F018               BRCS    ??ProgramFlash_2
    283                      RAMPZ = (1 << RAMPZ0);
   \   000000CC   E001               LDI     R16, 1
   \   000000CE   BF0B               OUT     0x3B, R16
   \   000000D0   C002               RJMP    ??ProgramFlash_3
    284                  } else {
    285                      RAMPZ = 0;
   \                     ??ProgramFlash_2:
   \   000000D2   E000               LDI     R16, 0
   \   000000D4   BF0B               OUT     0x3B, R16
    286                  }
    287          #endif
    288                  Address = Address << 1;                                     // convert from byte address to word address
   \                     ??ProgramFlash_3:
   \   000000D6   0FAA               LSL     R26
   \   000000D8   1FBB               ROL     R27
    289                  unsigned Addr = Address;                                             // mirror the address
   \   000000DA   014D               MOVW    R9:R8, R27:R26
    290                  for ( unsigned i = 0; i < Nobytes; i += 2, Address += 2, Pointer += 2 ) {              // write data to flash
   \   000000DC   2466               CLR     R6
   \   000000DE   2477               CLR     R7
   \                     ??ProgramFlash_4:
   \   000000E0   146A               CP      R6, R10
   \   000000E2   047B               CPC     R7, R11
   \   000000E4   F4A8               BRCC    ??ProgramFlash_5
    291                      fill_temp_buffer(RxBufferCh0[Pointer] + (RxBufferCh0[Pointer + 1] << 8), (Address)); //call asm routine.
   \   000000E6   019D               MOVW    R19:R18, R27:R26
   \   000000E8   01F2               MOVW    R31:R30, R5:R4
   \   000000EA   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   000000EC   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   000000EE   8100               LD      R16, Z
   \   000000F0   01F2               MOVW    R31:R30, R5:R4
   \   000000F2   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   000000F4   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   000000F6   8111               LDD     R17, Z+1
   \   000000F8   ........           CALL    fill_temp_buffer
    292                  }
   \   000000FC   E002               LDI     R16, 2
   \   000000FE   0E60               ADD     R6, R16
   \   00000100   E000               LDI     R16, 0
   \   00000102   1E70               ADC     R7, R16
   \   00000104   9612               ADIW    R27:R26, 2
   \   00000106   E002               LDI     R16, 2
   \   00000108   0E40               ADD     R4, R16
   \   0000010A   E000               LDI     R16, 0
   \   0000010C   1E50               ADC     R5, R16
   \   0000010E   CFE8               RJMP    ??ProgramFlash_4
    293                  write_page(Addr, (1 << PGWRT) + (1 << SPMEN));                  //Perform page write
   \                     ??ProgramFlash_5:
   \   00000110   E025               LDI     R18, 5
   \   00000112   0184               MOVW    R17:R16, R9:R8
   \   00000114   ........           CALL    write_page
    294                  write_page(Addr, (1 << REENABLE_RWW_BIT) + (1 << SPMEN));       //Re-enable the RWW section
   \   00000118   E121               LDI     R18, 17
   \   0000011A   0184               MOVW    R17:R16, R9:R8
   \   0000011C   ........           CALL    write_page
    295                  TxBufferCh0[myUART.TxFirst++] = FLASH_PROG_OK;       // OK
   \   00000120   ....               LDI     R30, LOW(myUART)
   \   00000122   ....               LDI     R31, (myUART) >> 8
   \   00000124   8100               LD      R16, Z
   \   00000126   8111               LDD     R17, Z+1
   \   00000128   01F8               MOVW    R31:R30, R17:R16
   \   0000012A   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000012C   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000012E   E000               LDI     R16, 0
   \   00000130   8300               ST      Z, R16
   \   00000132   ....               LDI     R30, LOW(myUART)
   \   00000134   ....               LDI     R31, (myUART) >> 8
   \   00000136   8100               LD      R16, Z
   \   00000138   8111               LDD     R17, Z+1
   \   0000013A   5F0F               SUBI    R16, 255
   \   0000013C   4F1F               SBCI    R17, 255
   \   0000013E   8300               ST      Z, R16
   \   00000140   8311               STD     Z+1, R17
    296          
    297                  for ( unsigned i = 0; i < Nobytes; i += 2, Addr += 2 ) {         // check the whole buffer
   \   00000142   2466               CLR     R6
   \   00000144   2477               CLR     R7
   \                     ??ProgramFlash_6:
   \   00000146   146A               CP      R6, R10
   \   00000148   047B               CPC     R7, R11
   \   0000014A   F5E0               BRCC    ??ProgramFlash_1
    298                      unsigned intval = read_program_memory(Addr, 0x00);
   \   0000014C   E020               LDI     R18, 0
   \   0000014E   0184               MOVW    R17:R16, R9:R8
   \   00000150   ........           CALL    read_program_memory
   \   00000154   0198               MOVW    R19:R18, R17:R16
    299                      if ( RxBufferCh0[Ptr++] != (intval & 0xff) ) {
   \   00000156   01AC               MOVW    R21:R20, R25:R24
   \   00000158   01CA               MOVW    R25:R24, R21:R20
   \   0000015A   9601               ADIW    R25:R24, 1
   \   0000015C   01FA               MOVW    R31:R30, R21:R20
   \   0000015E   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000160   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000162   8140               LD      R20, Z
   \   00000164   E050               LDI     R21, 0
   \   00000166   0189               MOVW    R17:R16, R19:R18
   \   00000168   7F0F               ANDI    R16, 0xFF
   \   0000016A   7010               ANDI    R17, 0x00
   \   0000016C   1740               CP      R20, R16
   \   0000016E   0751               CPC     R21, R17
   \   00000170   F049               BREQ    ??ProgramFlash_7
    300                          TxBufferCh0[myUART.TxFirst - 1] = FLASH_PROG_ERROR;       // compare error
   \   00000172   ....               LDI     R30, LOW(myUART)
   \   00000174   ....               LDI     R31, (myUART) >> 8
   \   00000176   8100               LD      R16, Z
   \   00000178   8111               LDD     R17, Z+1
   \   0000017A   01F8               MOVW    R31:R30, R17:R16
   \   0000017C   ....               SUBI    R30, LOW((-(TxBufferCh0 - 1) & 0xFFFF))
   \   0000017E   ....               SBCI    R31, HIGH((-(TxBufferCh0 - 1) & 0xFFFF))
   \   00000180   E002               LDI     R16, 2
   \   00000182   8300               ST      Z, R16
    301                      }
    302                      if ( RxBufferCh0[Ptr++] != ((intval >> 8) & 0xff) ) {
   \                     ??ProgramFlash_7:
   \   00000184   01AC               MOVW    R21:R20, R25:R24
   \   00000186   01CA               MOVW    R25:R24, R21:R20
   \   00000188   9601               ADIW    R25:R24, 1
   \   0000018A   01FA               MOVW    R31:R30, R21:R20
   \   0000018C   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   0000018E   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000190   8100               LD      R16, Z
   \   00000192   E010               LDI     R17, 0
   \   00000194   01A9               MOVW    R21:R20, R19:R18
   \   00000196   2F45               MOV     R20, R21
   \   00000198   E050               LDI     R21, 0
   \   0000019A   1704               CP      R16, R20
   \   0000019C   0715               CPC     R17, R21
   \   0000019E   F049               BREQ    ??ProgramFlash_8
    303                          TxBufferCh0[myUART.TxFirst - 1] = FLASH_PROG_ERROR;       // compare error
   \   000001A0   ....               LDI     R30, LOW(myUART)
   \   000001A2   ....               LDI     R31, (myUART) >> 8
   \   000001A4   8100               LD      R16, Z
   \   000001A6   8111               LDD     R17, Z+1
   \   000001A8   01F8               MOVW    R31:R30, R17:R16
   \   000001AA   ....               SUBI    R30, LOW((-(TxBufferCh0 - 1) & 0xFFFF))
   \   000001AC   ....               SBCI    R31, HIGH((-(TxBufferCh0 - 1) & 0xFFFF))
   \   000001AE   E002               LDI     R16, 2
   \   000001B0   8300               ST      Z, R16
    304                      }
    305                  }
   \                     ??ProgramFlash_8:
   \   000001B2   E002               LDI     R16, 2
   \   000001B4   0E60               ADD     R6, R16
   \   000001B6   E000               LDI     R16, 0
   \   000001B8   1E70               ADC     R7, R16
   \   000001BA   E002               LDI     R16, 2
   \   000001BC   0E80               ADD     R8, R16
   \   000001BE   E000               LDI     R16, 0
   \   000001C0   1E90               ADC     R9, R16
   \   000001C2   CFC1               RJMP    ??ProgramFlash_6
    306              }
    307          
    308              TxBufferCh0[ntna] = (myUART.TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \                     ??ProgramFlash_1:
   \   000001C4   ....               LDI     R30, LOW(myUART)
   \   000001C6   ....               LDI     R31, (myUART) >> 8
   \   000001C8   8100               LD      R16, Z
   \   000001CA   8111               LDD     R17, Z+1
   \   000001CC   2D1C               MOV     R17, R12
   \   000001CE   1B01               SUB     R16, R17
   \   000001D0   5002               SUBI    R16, 2
   \   000001D2   01F6               MOVW    R31:R30, R13:R12
   \   000001D4   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000001D6   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000001D8   8300               ST      Z, R16
    309              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000001DA   ....               LDI     R30, LOW(myUART)
   \   000001DC   ....               LDI     R31, (myUART) >> 8
   \   000001DE   8100               LD      R16, Z
   \   000001E0   8111               LDD     R17, Z+1
   \   000001E2   190C               SUB     R16, R12
   \   000001E4   091D               SBC     R17, R13
   \   000001E6   5002               SUBI    R16, 2
   \   000001E8   4010               SBCI    R17, 0
   \   000001EA   2F01               MOV     R16, R17
   \   000001EC   E010               LDI     R17, 0
   \   000001EE   01F6               MOVW    R31:R30, R13:R12
   \   000001F0   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000001F2   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000001F4   8301               STD     Z+1, R16
    310          
    311          }
   \   000001F6   E0EE               LDI     R30, 14
   \   000001F8   ........           JMP     ?EPILOGUE_B14_L09
   \   000001FC                      REQUIRE _A_RAMPZ
    312          
    313          /*************************************************************************
    314          *
    315          * Read Flash 
    316          *
    317          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    318          void ReadFlash(unsigned Pointer) {
   \                     ReadFlash:
   \   00000000   ........           CALL    ?PROLOGUE10_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004   0128               MOVW    R5:R4, R17:R16
    319              __watchdog_reset();
   \   00000006   95A8               WDR
    320          
    321              unsigned short ntna;
    322              myUART.RxSendReply = true;                               // flag for answering
   \   00000008   E001               LDI     R16, 1
   \   0000000A   9300....           STS     (myUART + 24), R16
    323          
    324              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_READ & 0xff;
   \   0000000E   ....               LDI     R30, LOW(myUART)
   \   00000010   ....               LDI     R31, (myUART) >> 8
   \   00000012   8100               LD      R16, Z
   \   00000014   8111               LDD     R17, Z+1
   \   00000016   01F8               MOVW    R31:R30, R17:R16
   \   00000018   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000001A   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000001C   EB03               LDI     R16, 179
   \   0000001E   8300               ST      Z, R16
   \   00000020   ....               LDI     R30, LOW(myUART)
   \   00000022   ....               LDI     R31, (myUART) >> 8
   \   00000024   8100               LD      R16, Z
   \   00000026   8111               LDD     R17, Z+1
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   8300               ST      Z, R16
   \   0000002E   8311               STD     Z+1, R17
    325              TxBufferCh0[myUART.TxFirst++] = CMD_REP_FLASH_READ >> 8;
   \   00000030   ....               LDI     R30, LOW(myUART)
   \   00000032   ....               LDI     R31, (myUART) >> 8
   \   00000034   8100               LD      R16, Z
   \   00000036   8111               LDD     R17, Z+1
   \   00000038   01F8               MOVW    R31:R30, R17:R16
   \   0000003A   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000003C   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000003E   E007               LDI     R16, 7
   \   00000040   8300               ST      Z, R16
   \   00000042   ....               LDI     R30, LOW(myUART)
   \   00000044   ....               LDI     R31, (myUART) >> 8
   \   00000046   8100               LD      R16, Z
   \   00000048   8111               LDD     R17, Z+1
   \   0000004A   5F0F               SUBI    R16, 255
   \   0000004C   4F1F               SBCI    R17, 255
   \   0000004E   8300               ST      Z, R16
   \   00000050   8311               STD     Z+1, R17
    326              ntna = myUART.TxFirst;                                    // remember index
   \   00000052   ....               LDI     R30, LOW(myUART)
   \   00000054   ....               LDI     R31, (myUART) >> 8
   \   00000056   8100               LD      R16, Z
   \   00000058   8111               LDD     R17, Z+1
   \   0000005A   0148               MOVW    R9:R8, R17:R16
    327              myUART.TxFirst += 2;                                      // two byte length
   \   0000005C   ....               LDI     R30, LOW(myUART)
   \   0000005E   ....               LDI     R31, (myUART) >> 8
   \   00000060   8100               LD      R16, Z
   \   00000062   8111               LDD     R17, Z+1
   \   00000064   5F0E               SUBI    R16, 254
   \   00000066   4F1F               SBCI    R17, 255
   \   00000068   8300               ST      Z, R16
   \   0000006A   8311               STD     Z+1, R17
    328          
    329              for ( unsigned i = 0; i < 4; i++ ) {
   \   0000006C   E080               LDI     R24, 0
   \   0000006E   E090               LDI     R25, 0
   \                     ??ReadFlash_0:
   \   00000070   3084               CPI     R24, 4
   \   00000072   E000               LDI     R16, 0
   \   00000074   0790               CPC     R25, R16
   \   00000076   F4C8               BRCC    ??ReadFlash_1
    330                  TxBufferCh0[myUART.TxFirst++] = RxBufferCh0[Pointer + i]; // ansver with address and nob
   \   00000078   0182               MOVW    R17:R16, R5:R4
   \   0000007A   0F08               ADD     R16, R24
   \   0000007C   1F19               ADC     R17, R25
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000082   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000084   8100               LD      R16, Z
   \   00000086   ....               LDI     R30, LOW(myUART)
   \   00000088   ....               LDI     R31, (myUART) >> 8
   \   0000008A   8120               LD      R18, Z
   \   0000008C   8131               LDD     R19, Z+1
   \   0000008E   01F9               MOVW    R31:R30, R19:R18
   \   00000090   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000092   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000094   8300               ST      Z, R16
   \   00000096   ....               LDI     R30, LOW(myUART)
   \   00000098   ....               LDI     R31, (myUART) >> 8
   \   0000009A   8100               LD      R16, Z
   \   0000009C   8111               LDD     R17, Z+1
   \   0000009E   5F0F               SUBI    R16, 255
   \   000000A0   4F1F               SBCI    R17, 255
   \   000000A2   8300               ST      Z, R16
   \   000000A4   8311               STD     Z+1, R17
    331              }
   \   000000A6   9601               ADIW    R25:R24, 1
   \   000000A8   CFE3               RJMP    ??ReadFlash_0
    332          
    333              unsigned Address = RxBufferCh0[Pointer + 0] + (RxBufferCh0[Pointer + 1] << 8); // save address
   \                     ??ReadFlash_1:
   \   000000AA   01F2               MOVW    R31:R30, R5:R4
   \   000000AC   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   000000AE   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   000000B0   8180               LD      R24, Z
   \   000000B2   01F2               MOVW    R31:R30, R5:R4
   \   000000B4   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   000000B6   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   000000B8   8191               LDD     R25, Z+1
    334              unsigned Nobytes = RxBufferCh0[Pointer + 2] + (RxBufferCh0[Pointer + 3] << 8); // save address
   \   000000BA   01F2               MOVW    R31:R30, R5:R4
   \   000000BC   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   000000BE   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   000000C0   8062               LDD     R6, Z+2
   \   000000C2   01F2               MOVW    R31:R30, R5:R4
   \   000000C4   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   000000C6   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   000000C8   8073               LDD     R7, Z+3
    335              if ( Nobytes > PAGESIZE ) {
   \   000000CA   E001               LDI     R16, 1
   \   000000CC   1660               CP      R6, R16
   \   000000CE   E001               LDI     R16, 1
   \   000000D0   0670               CPC     R7, R16
   \   000000D2   F090               BRCS    ??ReadFlash_2
    336                  TxBufferCh0[myUART.TxFirst++] = FLASH_PROG_PAGEF;               // Answer with Page fault
   \   000000D4   ....               LDI     R30, LOW(myUART)
   \   000000D6   ....               LDI     R31, (myUART) >> 8
   \   000000D8   8100               LD      R16, Z
   \   000000DA   8111               LDD     R17, Z+1
   \   000000DC   01F8               MOVW    R31:R30, R17:R16
   \   000000DE   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   000000E0   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   000000E2   E001               LDI     R16, 1
   \   000000E4   8300               ST      Z, R16
   \   000000E6   ....               LDI     R30, LOW(myUART)
   \   000000E8   ....               LDI     R31, (myUART) >> 8
   \   000000EA   8100               LD      R16, Z
   \   000000EC   8111               LDD     R17, Z+1
   \   000000EE   5F0F               SUBI    R16, 255
   \   000000F0   4F1F               SBCI    R17, 255
   \   000000F2   8300               ST      Z, R16
   \   000000F4   8311               STD     Z+1, R17
   \   000000F6   C03B               RJMP    ??ReadFlash_3
    337              } else {
    338          #ifdef LARGE_MEMORY
    339                  if ( Address >= 0x7FFF ) {
   \                     ??ReadFlash_2:
   \   000000F8   3F8F               CPI     R24, 255
   \   000000FA   E70F               LDI     R16, 127
   \   000000FC   0790               CPC     R25, R16
   \   000000FE   F018               BRCS    ??ReadFlash_4
    340                      RAMPZ = (1 << RAMPZ0);
   \   00000100   E001               LDI     R16, 1
   \   00000102   BF0B               OUT     0x3B, R16
   \   00000104   C002               RJMP    ??ReadFlash_5
    341                  } else {
    342                      RAMPZ = 0;
   \                     ??ReadFlash_4:
   \   00000106   E000               LDI     R16, 0
   \   00000108   BF0B               OUT     0x3B, R16
    343                  }
    344          #endif
    345                  Address = Address << 1;             // convert from byte address to word address
   \                     ??ReadFlash_5:
   \   0000010A   0F88               LSL     R24
   \   0000010C   1F99               ROL     R25
    346                  for ( unsigned i = 0; i < Nobytes; i += 2, Address += 2 ) {   // receive the whole buffer
   \   0000010E   E0A0               LDI     R26, 0
   \   00000110   E0B0               LDI     R27, 0
   \                     ??ReadFlash_6:
   \   00000112   15A6               CP      R26, R6
   \   00000114   05B7               CPC     R27, R7
   \   00000116   F558               BRCC    ??ReadFlash_3
    347                      unsigned intval = read_program_memory(Address, 0x00);
   \   00000118   E020               LDI     R18, 0
   \   0000011A   018C               MOVW    R17:R16, R25:R24
   \   0000011C   ........           CALL    read_program_memory
   \   00000120   0198               MOVW    R19:R18, R17:R16
    348                      TxBufferCh0[myUART.TxFirst++] = intval & 0xff;
   \   00000122   2F02               MOV     R16, R18
   \   00000124   ....               LDI     R30, LOW(myUART)
   \   00000126   ....               LDI     R31, (myUART) >> 8
   \   00000128   8140               LD      R20, Z
   \   0000012A   8151               LDD     R21, Z+1
   \   0000012C   01FA               MOVW    R31:R30, R21:R20
   \   0000012E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000130   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000132   8300               ST      Z, R16
   \   00000134   ....               LDI     R30, LOW(myUART)
   \   00000136   ....               LDI     R31, (myUART) >> 8
   \   00000138   8100               LD      R16, Z
   \   0000013A   8111               LDD     R17, Z+1
   \   0000013C   5F0F               SUBI    R16, 255
   \   0000013E   4F1F               SBCI    R17, 255
   \   00000140   8300               ST      Z, R16
   \   00000142   8311               STD     Z+1, R17
    349                      TxBufferCh0[myUART.TxFirst++] = (intval >> 8) & 0xff;
   \   00000144   2F23               MOV     R18, R19
   \   00000146   E030               LDI     R19, 0
   \   00000148   ....               LDI     R30, LOW(myUART)
   \   0000014A   ....               LDI     R31, (myUART) >> 8
   \   0000014C   8100               LD      R16, Z
   \   0000014E   8111               LDD     R17, Z+1
   \   00000150   01F8               MOVW    R31:R30, R17:R16
   \   00000152   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000154   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000156   8320               ST      Z, R18
   \   00000158   ....               LDI     R30, LOW(myUART)
   \   0000015A   ....               LDI     R31, (myUART) >> 8
   \   0000015C   8100               LD      R16, Z
   \   0000015E   8111               LDD     R17, Z+1
   \   00000160   5F0F               SUBI    R16, 255
   \   00000162   4F1F               SBCI    R17, 255
   \   00000164   8300               ST      Z, R16
   \   00000166   8311               STD     Z+1, R17
    350                  }
   \   00000168   9612               ADIW    R27:R26, 2
   \   0000016A   9602               ADIW    R25:R24, 2
   \   0000016C   CFD2               RJMP    ??ReadFlash_6
    351              }
    352          
    353              TxBufferCh0[ntna] = (myUART.TxFirst  - ntna - 2) & 0xff;      // length of data block lb
   \                     ??ReadFlash_3:
   \   0000016E   ....               LDI     R30, LOW(myUART)
   \   00000170   ....               LDI     R31, (myUART) >> 8
   \   00000172   8100               LD      R16, Z
   \   00000174   8111               LDD     R17, Z+1
   \   00000176   2D18               MOV     R17, R8
   \   00000178   1B01               SUB     R16, R17
   \   0000017A   5002               SUBI    R16, 2
   \   0000017C   01F4               MOVW    R31:R30, R9:R8
   \   0000017E   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000180   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000182   8300               ST      Z, R16
    354              TxBufferCh0[ntna + 1] = ((myUART.TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   00000184   ....               LDI     R30, LOW(myUART)
   \   00000186   ....               LDI     R31, (myUART) >> 8
   \   00000188   81A0               LD      R26, Z
   \   0000018A   81B1               LDD     R27, Z+1
   \   0000018C   19A8               SUB     R26, R8
   \   0000018E   09B9               SBC     R27, R9
   \   00000190   9712               SBIW    R27:R26, 2
   \   00000192   2FAB               MOV     R26, R27
   \   00000194   E0B0               LDI     R27, 0
   \   00000196   01F4               MOVW    R31:R30, R9:R8
   \   00000198   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   0000019A   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   0000019C   83A1               STD     Z+1, R26
    355          
    356          }
   \   0000019E   E0EA               LDI     R30, 10
   \   000001A0   ........           JMP     ?EPILOGUE_B10_L09
   \   000001A4                      REQUIRE _A_RAMPZ
    357          
    358          /*************************************************************************
    359          *
    360          *  Exit bootloader program
    361          *
    362          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    363          void ExitBootloader(char ch) {
   \                     ExitBootloader:
    364          
    365          
    366              while ( (EECR & 1 << EEPE) != 0 ) //chech if EEPROM is ready
   \                     ??ExitBootloader_0:
   \   00000000   99F9               SBIC    0x1F, 0x01
   \   00000002   CFFE               RJMP    ??ExitBootloader_0
    367              ;
    368              EEARL = (0x0fff & 0xff);
   \   00000004   EF1F               LDI     R17, 255
   \   00000006   BD11               OUT     0x21, R17
    369              EEARH = (0x0fff >> 8);
   \   00000008   E01F               LDI     R17, 15
   \   0000000A   BD12               OUT     0x22, R17
    370              EEDR = 0xaa;
   \   0000000C   EA1A               LDI     R17, 170
   \   0000000E   BD10               OUT     0x20, R17
    371              EECR |= (1 << EEMPE);
   \   00000010   9AFA               SBI     0x1F, 0x02
    372              EECR |= (1 << EEPE);
   \   00000012   9AF9               SBI     0x1F, 0x01
    373              while ( EECR & (1 << EEPE) );
   \                     ??ExitBootloader_1:
   \   00000014   99F9               SBIC    0x1F, 0x01
   \   00000016   CFFE               RJMP    ??ExitBootloader_1
    374              WDTCSR = 0x08;               //Start watchdog to genetate restart
   \   00000018   E018               LDI     R17, 8
   \   0000001A   9310....           STS     _A_WDTCSR, R17
    375              while (1) {
   \                     ??ExitBootloader_2:
   \   0000001E   CFFF               RJMP    ??ExitBootloader_2
   \   00000020                      REQUIRE _A_EECR
   \   00000020                      REQUIRE _A_EEAR
   \   00000020                      REQUIRE _A_EEDR
   \   00000020                      REQUIRE _A_WDTCSR
    376                  // Dummy loop!
    377              }
    378              //AppStart();        					// Jump to Reset vector 0x0000 in Application Section
    379          
    380          }
    381          
    382          
    383          /*************************************************************************
    384          *
    385          *  Transmitting data on USARTs
    386          *
    387          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    388          void SendPacketUart(void) {
   \                     SendPacketUart:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
    389              unsigned cnt = 0;
   \   00000004   E080               LDI     R24, 0
   \   00000006   E090               LDI     R25, 0
    390          
    391              for ( unsigned delay = 0; delay < 0xffff; delay++ ) {
   \   00000008   E0E0               LDI     R30, 0
   \   0000000A   E0F0               LDI     R31, 0
   \                     ??SendPacketUart_0:
   \   0000000C   3FEF               CPI     R30, 255
   \   0000000E   EF0F               LDI     R16, 255
   \   00000010   07F0               CPC     R31, R16
   \   00000012   F021               BREQ    ??SendPacketUart_1
    392                  asm("nop");
   \   00000014   0000               nop
    393                  cnt++;
   \   00000016   9601               ADIW    R25:R24, 1
    394              }
   \   00000018   9631               ADIW    R31:R30, 1
   \   0000001A   CFF8               RJMP    ??SendPacketUart_0
    395              __watchdog_reset();
   \                     ??SendPacketUart_1:
   \   0000001C   95A8               WDR
    396              while ( myUART.TxCount > 0 ) {               // Any characters to send?
   \                     ??SendPacketUart_2:
   \   0000001E   ....               LDI     R30, LOW(myUART)
   \   00000020   ....               LDI     R31, (myUART) >> 8
   \   00000022   8104               LDD     R16, Z+4
   \   00000024   8115               LDD     R17, Z+5
   \   00000026   2B01               OR      R16, R17
   \   00000028   F149               BREQ    ??SendPacketUart_3
    397                  sendchar(TxBufferCh0[myUART.TxLast]);  // Send a character
   \   0000002A   ....               LDI     R30, LOW(myUART)
   \   0000002C   ....               LDI     R31, (myUART) >> 8
   \   0000002E   8102               LDD     R16, Z+2
   \   00000030   8113               LDD     R17, Z+3
   \   00000032   01F8               MOVW    R31:R30, R17:R16
   \   00000034   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000036   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000038   8100               LD      R16, Z
   \   0000003A   ........           CALL    sendchar
    398          
    399                  if ( (++myUART.TxLast) > TXSIZE_UART ) {     // End of buffer?
   \   0000003E   ....               LDI     R30, LOW(myUART)
   \   00000040   ....               LDI     R31, (myUART) >> 8
   \   00000042   8102               LDD     R16, Z+2
   \   00000044   8113               LDD     R17, Z+3
   \   00000046   5F0F               SUBI    R16, 255
   \   00000048   4F1F               SBCI    R17, 255
   \   0000004A   8302               STD     Z+2, R16
   \   0000004C   8313               STD     Z+3, R17
   \   0000004E   ....               LDI     R30, LOW(myUART)
   \   00000050   ....               LDI     R31, (myUART) >> 8
   \   00000052   8102               LDD     R16, Z+2
   \   00000054   8113               LDD     R17, Z+3
   \   00000056   350F               CPI     R16, 95
   \   00000058   E021               LDI     R18, 1
   \   0000005A   0712               CPC     R17, R18
   \   0000005C   F030               BRCS    ??SendPacketUart_4
    400                      myUART.TxLast = 0;                     // yes, reset pointer
   \   0000005E   ....               LDI     R30, LOW(myUART)
   \   00000060   ....               LDI     R31, (myUART) >> 8
   \   00000062   E000               LDI     R16, 0
   \   00000064   8302               STD     Z+2, R16
   \   00000066   E000               LDI     R16, 0
   \   00000068   8303               STD     Z+3, R16
    401                  }
    402                  myUART.TxCount--;
   \                     ??SendPacketUart_4:
   \   0000006A   ....               LDI     R30, LOW(myUART)
   \   0000006C   ....               LDI     R31, (myUART) >> 8
   \   0000006E   8104               LDD     R16, Z+4
   \   00000070   8115               LDD     R17, Z+5
   \   00000072   5001               SUBI    R16, 1
   \   00000074   4010               SBCI    R17, 0
   \   00000076   8304               STD     Z+4, R16
   \   00000078   8315               STD     Z+5, R17
   \   0000007A   CFD1               RJMP    ??SendPacketUart_2
    403              }
    404              PORTE &= ~0x04;                                     // TXE0 off
   \                     ??SendPacketUart_3:
   \   0000007C   9872               CBI     0x0E, 0x02
    405              cnt = 0;
   \   0000007E   E080               LDI     R24, 0
   \   00000080   E090               LDI     R25, 0
    406          }
   \   00000082   9189               LD      R24, Y+
   \   00000084   9199               LD      R25, Y+
   \   00000086   9508               RET
   \   00000088                      REQUIRE _A_PORTE
    407          
    408          /*************************************************************************
    409          *
    410          *  Receive data on USARTs
    411          *
    412          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    413          void ReceivePacketUart(char ch) {
   \                     ReceivePacketUart:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   2F80               MOV     R24, R16
    414              __watchdog_reset();
   \   00000006   95A8               WDR
    415          
    416              switch ( myUART.RxState ) {                  // check status
   \   00000008   9100....           LDS     R16, (myUART + 16)
   \   0000000C   5000               SUBI    R16, 0
   \   0000000E   F049               BREQ    ??ReceivePacketUart_0
   \   00000010   950A               DEC     R16
   \   00000012   F041               BREQ    ??ReceivePacketUart_1
   \   00000014   950A               DEC     R16
   \   00000016   F409               BRNE    $+2+2
   \   00000018   C050               RJMP    ??ReceivePacketUart_2
   \   0000001A   5008               SUBI    R16, 8
   \   0000001C   F409               BRNE    $+2+2
   \   0000001E   C08D               RJMP    ??ReceivePacketUart_3
   \   00000020   C08B               RJMP    ??ReceivePacketUart_4
    417              case SYNC :
    418                  // all functionallity in inerrupt routine
    419                  break;
   \                     ??ReceivePacketUart_0:
   \   00000022   C08B               RJMP    ??ReceivePacketUart_3
    420              case HEADER :
    421                  if ( myUART.RxLast >= 6 ) {             // receive header
   \                     ??ReceivePacketUart_1:
   \   00000024   ....               LDI     R30, LOW(myUART)
   \   00000026   ....               LDI     R31, (myUART) >> 8
   \   00000028   85A4               LDD     R26, Z+12
   \   0000002A   85B5               LDD     R27, Z+13
   \   0000002C   9716               SBIW    R27:R26, 6
   \   0000002E   F408               BRCC    $+2+2
   \   00000030   C084               RJMP    ??ReceivePacketUart_3
    422                      myUART.RxPacklen = (RxBufferCh0[4] +
    423                                          (RxBufferCh0[5] * 256));    // Find length of package
   \   00000032   9120....           LDS     R18, (RxBufferCh0 + 4)
   \   00000036   E030               LDI     R19, 0
   \   00000038   9100....           LDS     R16, (RxBufferCh0 + 5)
   \   0000003C   E010               LDI     R17, 0
   \   0000003E   2F10               MOV     R17, R16
   \   00000040   E000               LDI     R16, 0
   \   00000042   0F20               ADD     R18, R16
   \   00000044   1F31               ADC     R19, R17
   \   00000046   ....               LDI     R30, LOW(myUART)
   \   00000048   ....               LDI     R31, (myUART) >> 8
   \   0000004A   8B24               STD     Z+20, R18
   \   0000004C   8B35               STD     Z+21, R19
    424                      if ( CalcDSRxChecksum(ch, 6) && (RxBufferCh0[0] == (0x10 + UnitID)) ) {
   \   0000004E   E026               LDI     R18, 6
   \   00000050   E030               LDI     R19, 0
   \   00000052   2F08               MOV     R16, R24
   \   00000054   ....               RCALL   CalcDSRxChecksum
   \   00000056   2B01               OR      R16, R17
   \   00000058   F171               BREQ    ??ReceivePacketUart_5
   \   0000005A   9100....           LDS     R16, RxBufferCh0
   \   0000005E   E010               LDI     R17, 0
   \   00000060   91E0....           LDS     R30, UnitID
   \   00000064   E0F0               LDI     R31, 0
   \   00000066   9670               ADIW    R31:R30, 16
   \   00000068   170E               CP      R16, R30
   \   0000006A   071F               CPC     R17, R31
   \   0000006C   F521               BRNE    ??ReceivePacketUart_5
    425                          // header checksum OK and to me
    426                          if ( (myUART.RxPacklen < ((short)RXSIZE_UART - myUART.RxLast)) &&    /* chk. header */
    427                               (myUART.RxPacklen >= MIN_PACK_LEN) ) {
   \   0000006E   ....               LDI     R30, LOW(myUART)
   \   00000070   ....               LDI     R31, (myUART) >> 8
   \   00000072   8924               LDD     R18, Z+20
   \   00000074   8935               LDD     R19, Z+21
   \   00000076   E50E               LDI     R16, 94
   \   00000078   E011               LDI     R17, 1
   \   0000007A   ....               LDI     R30, LOW(myUART)
   \   0000007C   ....               LDI     R31, (myUART) >> 8
   \   0000007E   8544               LDD     R20, Z+12
   \   00000080   8555               LDD     R21, Z+13
   \   00000082   1B04               SUB     R16, R20
   \   00000084   0B15               SBC     R17, R21
   \   00000086   1720               CP      R18, R16
   \   00000088   0731               CPC     R19, R17
   \   0000008A   F498               BRCC    ??ReceivePacketUart_6
   \   0000008C   ....               LDI     R30, LOW(myUART)
   \   0000008E   ....               LDI     R31, (myUART) >> 8
   \   00000090   89A4               LDD     R26, Z+20
   \   00000092   89B5               LDD     R27, Z+21
   \   00000094   9717               SBIW    R27:R26, 7
   \   00000096   F068               BRCS    ??ReceivePacketUart_6
    428                              myUART.RxState = RECEIVE;       // Header ok og to data receive state
   \   00000098   E002               LDI     R16, 2
   \   0000009A   9300....           STS     (myUART + 16), R16
    429                              myUART.RxCount = myUART.RxLast + 1;    // Set receive counter
   \   0000009E   ....               LDI     R30, LOW(myUART)
   \   000000A0   ....               LDI     R31, (myUART) >> 8
   \   000000A2   85A4               LDD     R26, Z+12
   \   000000A4   85B5               LDD     R27, Z+13
   \   000000A6   9611               ADIW    R27:R26, 1
   \   000000A8   ....               LDI     R30, LOW(myUART)
   \   000000AA   ....               LDI     R31, (myUART) >> 8
   \   000000AC   87A6               STD     Z+14, R26
   \   000000AE   87B7               STD     Z+15, R27
   \   000000B0   C044               RJMP    ??ReceivePacketUart_3
    430                          } else {
    431                              GoToSyncUART();                        // go to sync modus for recive
   \                     ??ReceivePacketUart_6:
   \   000000B2   ....               RCALL   GoToSyncUART
   \   000000B4   C042               RJMP    ??ReceivePacketUart_3
    432                          }
    433                      } else {
    434                          GoToSyncUART();                            // go to sync modus for recive
   \                     ??ReceivePacketUart_5:
   \   000000B6   ....               RCALL   GoToSyncUART
    435                      }
    436                  }
    437                  break;
   \   000000B8   C040               RJMP    ??ReceivePacketUart_3
    438              case RECEIVE :
    439                  if ( ++myUART.RxCount >= myUART.RxPacklen ) {
   \                     ??ReceivePacketUart_2:
   \   000000BA   ....               LDI     R30, LOW(myUART)
   \   000000BC   ....               LDI     R31, (myUART) >> 8
   \   000000BE   8506               LDD     R16, Z+14
   \   000000C0   8517               LDD     R17, Z+15
   \   000000C2   5F0F               SUBI    R16, 255
   \   000000C4   4F1F               SBCI    R17, 255
   \   000000C6   8706               STD     Z+14, R16
   \   000000C8   8717               STD     Z+15, R17
   \   000000CA   ....               LDI     R30, LOW(myUART)
   \   000000CC   ....               LDI     R31, (myUART) >> 8
   \   000000CE   8506               LDD     R16, Z+14
   \   000000D0   8517               LDD     R17, Z+15
   \   000000D2   ....               LDI     R30, LOW(myUART)
   \   000000D4   ....               LDI     R31, (myUART) >> 8
   \   000000D6   8924               LDD     R18, Z+20
   \   000000D8   8935               LDD     R19, Z+21
   \   000000DA   1702               CP      R16, R18
   \   000000DC   0713               CPC     R17, R19
   \   000000DE   F168               BRCS    ??ReceivePacketUart_3
    440                      if ( (RxBufferCh0[myUART.RxPacklen - 1]) == ANPRO10_EOT ) {
   \   000000E0   ....               LDI     R30, LOW(myUART)
   \   000000E2   ....               LDI     R31, (myUART) >> 8
   \   000000E4   8904               LDD     R16, Z+20
   \   000000E6   8915               LDD     R17, Z+21
   \   000000E8   01F8               MOVW    R31:R30, R17:R16
   \   000000EA   ....               SUBI    R30, LOW((-(RxBufferCh0 - 1) & 0xFFFF))
   \   000000EC   ....               SBCI    R31, HIGH((-(RxBufferCh0 - 1) & 0xFFFF))
   \   000000EE   8100               LD      R16, Z
   \   000000F0   3004               CPI     R16, 4
   \   000000F2   F501               BRNE    ??ReceivePacketUart_7
    441                          if ( CalcDSRxChecksum(ch, myUART.RxPacklen - 2) ) {
   \   000000F4   ....               LDI     R30, LOW(myUART)
   \   000000F6   ....               LDI     R31, (myUART) >> 8
   \   000000F8   8924               LDD     R18, Z+20
   \   000000FA   8935               LDD     R19, Z+21
   \   000000FC   5022               SUBI    R18, 2
   \   000000FE   4030               SBCI    R19, 0
   \   00000100   2F08               MOV     R16, R24
   \   00000102   ....               RCALL   CalcDSRxChecksum
   \   00000104   2B01               OR      R16, R17
   \   00000106   F0A1               BREQ    ??ReceivePacketUart_8
    442                              if ( (RxBufferCh0[1] == MyAddress()) ||       // message to me? or
    443                                   (RxBufferCh0[1] == 0xff) ) {            // broadcast
   \   00000108   ........           CALL    MyAddress
   \   0000010C   9110....           LDS     R17, (RxBufferCh0 + 1)
   \   00000110   1710               CP      R17, R16
   \   00000112   F021               BREQ    ??ReceivePacketUart_9
   \   00000114   9100....           LDS     R16, (RxBufferCh0 + 1)
   \   00000118   3F0F               CPI     R16, 255
   \   0000011A   F441               BRNE    ??ReceivePacketUart_10
    444                                  hostAddress = RxBufferCh0[3];            // address to sender (host)
   \                     ??ReceivePacketUart_9:
   \   0000011C   9100....           LDS     R16, (RxBufferCh0 + 3)
   \   00000120   9300....           STS     hostAddress, R16
    445                                  myUART.RxState = HANDLE;                     // Package OK
   \   00000124   E00A               LDI     R16, 10
   \   00000126   9300....           STS     (myUART + 16), R16
   \   0000012A   C007               RJMP    ??ReceivePacketUart_3
    446                              } else {
    447                                  GoToSyncUART();                             // go to sync modus for recive
   \                     ??ReceivePacketUart_10:
   \   0000012C   ....               RCALL   GoToSyncUART
   \   0000012E   C005               RJMP    ??ReceivePacketUart_3
    448                              }
    449                          } else {
    450                              GoToSyncUART();                                // go to sync modus for recive
   \                     ??ReceivePacketUart_8:
   \   00000130   ....               RCALL   GoToSyncUART
   \   00000132   C003               RJMP    ??ReceivePacketUart_3
    451                          }
    452                      } else {
    453                          GoToSyncUART();                                    // go to sync modus for recive
   \                     ??ReceivePacketUart_7:
   \   00000134   ....               RCALL   GoToSyncUART
    454                      }
    455                  }
    456                  break;
   \   00000136   C001               RJMP    ??ReceivePacketUart_3
    457              case HANDLE :
    458                  break;
    459              default :
    460                  GoToSyncUART();                                            // go to sync modus for recive
   \                     ??ReceivePacketUart_4:
   \   00000138   ....               RCALL   GoToSyncUART
    461                  break;
    462              }                                                           // end switch
    463              if ( ++myUART.RxLast >= RXSIZE_UART ) {                     // check pointer
   \                     ??ReceivePacketUart_3:
   \   0000013A   ....               LDI     R30, LOW(myUART)
   \   0000013C   ....               LDI     R31, (myUART) >> 8
   \   0000013E   8504               LDD     R16, Z+12
   \   00000140   8515               LDD     R17, Z+13
   \   00000142   5F0F               SUBI    R16, 255
   \   00000144   4F1F               SBCI    R17, 255
   \   00000146   8704               STD     Z+12, R16
   \   00000148   8715               STD     Z+13, R17
   \   0000014A   ....               LDI     R30, LOW(myUART)
   \   0000014C   ....               LDI     R31, (myUART) >> 8
   \   0000014E   8504               LDD     R16, Z+12
   \   00000150   8515               LDD     R17, Z+13
   \   00000152   350E               CPI     R16, 94
   \   00000154   E021               LDI     R18, 1
   \   00000156   0712               CPC     R17, R18
   \   00000158   F030               BRCS    ??ReceivePacketUart_11
    464                  myUART.RxLast = 0;                                     // reset pointer
   \   0000015A   ....               LDI     R30, LOW(myUART)
   \   0000015C   ....               LDI     R31, (myUART) >> 8
   \   0000015E   E000               LDI     R16, 0
   \   00000160   8704               STD     Z+12, R16
   \   00000162   E000               LDI     R16, 0
   \   00000164   8705               STD     Z+13, R16
    465              }
    466          }
   \                     ??ReceivePacketUart_11:
   \   00000166   E0E4               LDI     R30, 4
   \   00000168   ........           JMP     ?EPILOGUE_B4_L09
    467          /*************************************************************************
    468          *
    469          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    470          *
    471          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    472          char CalcDSTxChecksum(unsigned short len) {
   \                     CalcDSTxChecksum:
   \   00000000   01BC               MOVW    R23:R22, R25:R24
   \   00000002   01A8               MOVW    R21:R20, R17:R16
    473          
    474              unsigned short  cnt;
    475              unsigned char   csum;
    476          
    477              csum = 0;
   \   00000004   E000               LDI     R16, 0
    478              for ( cnt = 4; cnt < len; cnt++ ) {
   \   00000006   E084               LDI     R24, 4
   \   00000008   E090               LDI     R25, 0
   \                     ??CalcDSTxChecksum_0:
   \   0000000A   1784               CP      R24, R20
   \   0000000C   0795               CPC     R25, R21
   \   0000000E   F480               BRCC    ??CalcDSTxChecksum_1
    479                  csum = crc[csum ^ TxBufferCh0[cnt]];
   \   00000010   E010               LDI     R17, 0
   \   00000012   01FC               MOVW    R31:R30, R25:R24
   \   00000014   ....               SUBI    R30, LOW((-(TxBufferCh0) & 0xFFFF))
   \   00000016   ....               SBCI    R31, (-(TxBufferCh0) & 0xFFFF) >> 8
   \   00000018   8120               LD      R18, Z
   \   0000001A   E030               LDI     R19, 0
   \   0000001C   2702               EOR     R16, R18
   \   0000001E   2713               EOR     R17, R19
   \   00000020   01F8               MOVW    R31:R30, R17:R16
   \   00000022   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000024   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000026   ....               LDI     R19, (crc) >> 16
   \   00000028   BF3B               OUT     0x3B, R19
   \   0000002A   9106               ELPM    R16, Z
    480              }
   \   0000002C   9601               ADIW    R25:R24, 1
   \   0000002E   CFED               RJMP    ??CalcDSTxChecksum_0
    481              return csum;
   \                     ??CalcDSTxChecksum_1:
   \   00000030   01CB               MOVW    R25:R24, R23:R22
   \   00000032   9508               RET
    482          }
    483          
    484          /*************************************************************************
    485          *
    486          * Calculate rx packet checksum (header and package) using Dallas Semiconductor one-wire CRC
    487          *
    488          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    489          short CalcDSRxChecksum(char ch, unsigned short len) {
   \                     CalcDSRxChecksum:
   \   00000000   2F79               MOV     R23, R25
   \   00000002   2E08               MOV     R0, R24
   \   00000004   2F60               MOV     R22, R16
   \   00000006   01A9               MOVW    R21:R20, R19:R18
    490          
    491              unsigned short  cnt;
    492              unsigned char   csum;
    493          
    494              csum = 0;
   \   00000008   E020               LDI     R18, 0
    495              for ( cnt = 0; cnt < len; cnt++ ) {
   \   0000000A   E080               LDI     R24, 0
   \   0000000C   E090               LDI     R25, 0
   \                     ??CalcDSRxChecksum_0:
   \   0000000E   1784               CP      R24, R20
   \   00000010   0795               CPC     R25, R21
   \   00000012   F488               BRCC    ??CalcDSRxChecksum_1
    496                  csum = crc[csum ^ RxBufferCh0[cnt]];
   \   00000014   2F02               MOV     R16, R18
   \   00000016   E010               LDI     R17, 0
   \   00000018   01FC               MOVW    R31:R30, R25:R24
   \   0000001A   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   0000001C   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   0000001E   8120               LD      R18, Z
   \   00000020   E030               LDI     R19, 0
   \   00000022   2702               EOR     R16, R18
   \   00000024   2713               EOR     R17, R19
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000002A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000002C   ....               LDI     R19, (crc) >> 16
   \   0000002E   BF3B               OUT     0x3B, R19
   \   00000030   9126               ELPM    R18, Z
    497              }
   \   00000032   9601               ADIW    R25:R24, 1
   \   00000034   CFEC               RJMP    ??CalcDSRxChecksum_0
    498              if ( csum == RxBufferCh0[len] ) {
   \                     ??CalcDSRxChecksum_1:
   \   00000036   01FA               MOVW    R31:R30, R21:R20
   \   00000038   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   0000003A   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   0000003C   8100               LD      R16, Z
   \   0000003E   1720               CP      R18, R16
   \   00000040   F419               BRNE    ??CalcDSRxChecksum_2
    499                  return true;
   \   00000042   E001               LDI     R16, 1
   \   00000044   E010               LDI     R17, 0
   \   00000046   C002               RJMP    ??CalcDSRxChecksum_3
    500              } else {
    501                  return false;
   \                     ??CalcDSRxChecksum_2:
   \   00000048   E000               LDI     R16, 0
   \   0000004A   E010               LDI     R17, 0
   \                     ??CalcDSRxChecksum_3:
   \   0000004C   2D80               MOV     R24, R0
   \   0000004E   2F97               MOV     R25, R23
   \   00000050   9508               RET
    502              }
    503          }
    504          
    505          /*************************************************************************
    506          *
    507          * Goes to sync mode
    508          *
    509          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    510          __monitor void GoToSyncUART() {
   \                     GoToSyncUART:
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002   94F8               CLI
    511              __watchdog_reset();
   \   00000004   95A8               WDR
    512          
    513              myUART.SyncCnt = 0;                        // ready for sync
   \   00000006   E000               LDI     R16, 0
   \   00000008   9300....           STS     (myUART + 17), R16
    514              myUART.RxState = SYNC;
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   9300....           STS     (myUART + 16), R16
    515              myUART.RxFirst = 0;
   \   00000012   ....               LDI     R30, LOW(myUART)
   \   00000014   ....               LDI     R31, (myUART) >> 8
   \   00000016   E000               LDI     R16, 0
   \   00000018   8702               STD     Z+10, R16
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   8703               STD     Z+11, R16
    516          }
   \   0000001E   BF1F               OUT     0x3F, R17
   \   00000020   9508               RET

   \                                 In  segment SWITCH, align 2, keep-with-next
   \                     `?<Jumptable for CheckActionUart>_0`:
   \   00000000   E803               DW      59395
   \   00000002   01                 DB      1
   \   00000003   ....               DW      (??CheckActionUart_7) /2
   \   00000005   ....               DW      (??CheckActionUart_0) /2
   \   00000007   03FEAC             DB      254,0x3,0xac
   \   0000000A   ....               DW      (??CheckActionUart_2) /2
   \   0000000C   0A                 DB      0xa
   \   0000000D   ....               DW      (??CheckActionUart_3) /2
   \   0000000F   0A                 DB      0xa
   \   00000010   ....               DW      (??CheckActionUart_4) /2
   \   00000012   0A                 DB      0xa
   \   00000013   ....               DW      (??CheckActionUart_5) /2
   \   00000015   14                 DB      0x14
   \   00000016   ....               DW      (??CheckActionUart_6) /2
   \   00000018   FB                 DB      251
   \   00000019   00                 DB      0

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   BuildFlashID
      5      2   BuildStatusData
        5      2   -> MyAddress
      0      2   CalcDSRxChecksum
      0      2   CalcDSTxChecksum
      6      2   CheckActionUart
        6      2   -> BuildFlashID
        6      2   -> BuildStatusData
        6      2   -> EraseFlash
        6      2   -> ExitBootloader
        6      2   -> ProgramFlash
        6      2   -> ReadFlash
        6      2 ?SV_SWITCH_L06
      4      2   EraseFlash
        4      2   -> write_page
      0      2   ExitBootloader
      0      2   GoToSyncUART
     14      2   ProgramFlash
       14      2   -> fill_temp_buffer
       14      2   -> read_program_memory
       14      2   -> write_page
     10      2   ReadFlash
       10      2   -> read_program_memory
      4      2   ReceivePacketUart
        4      2   -> CalcDSRxChecksum
        4      2   -> GoToSyncUART
        4      2   -> MyAddress
      2      2   SendPacketUart
        2      2   -> sendchar
      0      2   Uart_BuildHeader
        0      2   -> MyAddress
      2      2   Uart_BuildTail
        2      2   -> CalcDSTxChecksum
        2      2   -> SendPacketUart
        2      2   -> Uart_BuildHeader
      5      2   UsartCheckPackage
        5      2   -> CheckActionUart
        5      2   -> GoToSyncUART
        5      2   -> Uart_BuildTail


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      26  ?<Jumptable for CheckActionUart>_0
     292  BuildFlashID
     578  BuildStatusData
      82  CalcDSRxChecksum
      52  CalcDSTxChecksum
     104  CheckActionUart
     272  EraseFlash
      32  ExitBootloader
      34  GoToSyncUART
     508  ProgramFlash
     420  ReadFlash
     364  ReceivePacketUart
     350  RxBufferCh0
     136  SendPacketUart
     350  TxBufferCh0
     114  Uart_BuildHeader
     358  Uart_BuildTail
     104  UsartCheckPackage
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_RAMPZ
       1  _A_WDTCSR
       7  -- Other

 
     7 bytes in segment ABSOLUTE
 3 450 bytes in segment CODE
     7 bytes in segment INITTAB
   700 bytes in segment NEAR_Z
    26 bytes in segment SWITCH
 
 3 476 bytes of CODE memory (+ 7 bytes shared)
   700 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
