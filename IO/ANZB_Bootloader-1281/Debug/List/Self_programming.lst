###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       13/Feb/2024  15:21:37
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Src\Self_programming.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW1CE8.tmp ("C:\Users\ESY\OneDrive
#        -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Src\Self_programming.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\Obj" -D
#        SPEED=38400 -D __AVR_ATmega1281__ -D ANZBANA_V8=1 -lCN
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\List" -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\List\Self_programming.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\Obj\Self_programming.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Src\Self_programming.c
      1          /* Copyright (C) 2006-2015 Atmel Corporation. All rights reserved.
      2           *
      3           * \asf_license_start
      4           *
      5           * \page License
      6           *
      7           * Redistribution and use in source and binary forms, with or without
      8           * modification, are permitted provided that the following conditions are met:
      9           *
     10           * 1. Redistributions of source code must retain the above copyright notice,
     11           *    this list of conditions and the following disclaimer.
     12           *
     13           * 2. Redistributions in binary form must reproduce the above copyright notice,
     14           *    this list of conditions and the following disclaimer in the documentation
     15           *    and/or other materials provided with the distribution.
     16           *
     17           * 3. The name of Atmel may not be used to endorse or promote products derived
     18           *    from this software without specific prior written permission.
     19           *
     20           * 4. This software may only be redistributed and used in connection with an
     21           *    Atmel microcontroller product.
     22           *
     23           * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
     24           * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     25           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     26           * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
     27           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     28           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     29           * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     30           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     31           * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
     32           * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     33           * POSSIBILITY OF SUCH DAMAGE.
     34           *
     35           * \asf_license_stop
     36           *
     37           */
     38          /*! \file ********************************************************************
     39          *
     40          * Atmel Corporation
     41          *
     42          * - File              : Self_programming.c
     43          * - Compiler          : avr-gcc
     44          *
     45          * - Supported devices : All devices with bootloaders support.
     46          *
     47          * - AppNote           : AVR106 - C functions for reading and writing
     48          *                       to flash memory.
     49          *
     50          * - Description       : The file contains functions for easy reading and writing
     51          *                       of Flash memory on parts having the "Self-programming"
     52          *                       feature. The user functions are as follows:
     53          *
     54          *                       ReadFlashByte()	
     55          *                       ReadFlashPage()	
     56          *                       WriteFlashByte()
     57          *                       WriteFlashPage()	
     58          *                       RecoverFlash()	
     59          *
     60          *                       The remaining functions contained in this file are used
     61          *                       by the functions listed above.
     62          *
     63          ****************************************************************************/
     64          
     65          //#include <avr/io.h>
     66          /*#include <avr/eeprom.h>
     67          #include <avr/interrupt.h>
     68          */
     69          #ifdef __ATMEGA_1280__
     70              #include	"iom1280.h"
     71          #endif
     72          
     73          #ifdef __AVR_ATmega1281__
     74              #include	"iom1281.h"

   \                                 In  segment ABSOLUTE, at 0x5b
   \   union <unnamed> volatile __io _A_RAMPZ
   \                     _A_RAMPZ:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x57
   \   union <unnamed> volatile __io _A_SPMCSR
   \                     _A_SPMCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1
     75          #endif
     76          
     77          #include "Self_programming.h"
     78          #include "flash.h"
     79          void FillBuffer(unsigned char *dataPage);
     80          
     81          /* Defining the attribute to place the selected function insu=ide the boot section*/
     82          #define BOOTLOADER_SECTION __attribute__ ((section (".bootloader")))
     83          
     84          /*
     85          * Declare global struct variable in EEPROM if Flash recovery enabled.
     86          * FlashBackup pageNumber holds Flash page address (/PAGESIZE) the data in Flash
     87          * recovery buffer should be written to if data need to be recovered.
     88          * FlashBackup.status tells if data need to be recovered.
     89          */
     90          #ifdef __FLASH_RECOVER
     91          struct EEMEM{
     92              unsigned int  pageNumber;
     93              unsigned char status;

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     94          } FlashBackup = {0};
   \                     FlashBackup:
   \   00000000                      DS8 3
     95          #endif
     96          
     97          /*
     98          * The function Returns one byte located on Flash address given by ucFlashStartAdr.
     99          */

   \                                 In  segment CODE, align 2, keep-with-next
    100          unsigned char ReadFlashByte(MyAddressType flashStartAdr) {
   \                     ReadFlashByte:
   \   00000000   9724               SBIW    R29:R28, 4
   \   00000002   8308               ST      Y, R16
   \   00000004   8319               STD     Y+1, R17
   \   00000006   832A               STD     Y+2, R18
   \   00000008   833B               STD     Y+3, R19
    101              return (unsigned char)*((MyFlashCharPointer)flashStartAdr);
   \   0000000A   8108               LD      R16, Y
   \   0000000C   8119               LDD     R17, Y+1
   \   0000000E   812A               LDD     R18, Y+2
   \   00000010   813B               LDD     R19, Y+3
   \   00000012   01F8               MOVW    R31:R30, R17:R16
   \   00000014   2F32               MOV     R19, R18
   \   00000016   BF3B               OUT     0x3B, R19
   \   00000018   9106               ELPM    R16, Z
   \   0000001A   9624               ADIW    R29:R28, 4
   \   0000001C   9508               RET
    102          }  // Returns data from Flash
    103          
    104          /*!
    105          * The function reads one Flash page from address flashStartAdr and stores data
    106          * in array dataPage[]. The number of bytes stored is depending upon the
    107          * Flash page size. The function returns FALSE if input address is not a Flash
    108          * page address, else TRUE.
    109          **/

   \                                 In  segment CODE, align 2, keep-with-next
    110          unsigned char ReadFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage) {
   \                     ReadFlashPage:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   9724               SBIW    R29:R28, 4
   \   00000006   8308               ST      Y, R16
   \   00000008   8319               STD     Y+1, R17
   \   0000000A   832A               STD     Y+2, R18
   \   0000000C   833B               STD     Y+3, R19
    111              unsigned int index;
    112              if (!(flashStartAdr & (PAGESIZE - 1))) {                                       // If input address is a page address
   \   0000000E   8108               LD      R16, Y
   \   00000010   8119               LDD     R17, Y+1
   \   00000012   812A               LDD     R18, Y+2
   \   00000014   813B               LDD     R19, Y+3
   \   00000016   7F0F               ANDI    R16, 0xFF
   \   00000018   2300               TST     R16
   \   0000001A   F4C9               BRNE    ??ReadFlashPage_0
    113                  for (index = 0; index < PAGESIZE; index++) {
   \   0000001C   E080               LDI     R24, 0
   \   0000001E   E090               LDI     R25, 0
   \                     ??ReadFlashPage_1:
   \   00000020   3080               CPI     R24, 0
   \   00000022   E001               LDI     R16, 1
   \   00000024   0790               CPC     R25, R16
   \   00000026   F488               BRCC    ??ReadFlashPage_2
    114                      dataPage[index] = ReadFlashByte(flashStartAdr + index);
   \   00000028   8108               LD      R16, Y
   \   0000002A   8119               LDD     R17, Y+1
   \   0000002C   812A               LDD     R18, Y+2
   \   0000002E   813B               LDD     R19, Y+3
   \   00000030   E0A0               LDI     R26, 0
   \   00000032   E0B0               LDI     R27, 0
   \   00000034   0F08               ADD     R16, R24
   \   00000036   1F19               ADC     R17, R25
   \   00000038   1F2A               ADC     R18, R26
   \   0000003A   1F3B               ADC     R19, R27
   \   0000003C   ....               RCALL   ReadFlashByte
   \   0000003E   01FA               MOVW    R31:R30, R21:R20
   \   00000040   0FE8               ADD     R30, R24
   \   00000042   1FF9               ADC     R31, R25
   \   00000044   8300               ST      Z, R16
    115                  }
   \   00000046   9601               ADIW    R25:R24, 1
   \   00000048   CFEB               RJMP    ??ReadFlashPage_1
    116                  return TRUE;                            // Return TRUE if valid page address
   \                     ??ReadFlashPage_2:
   \   0000004A   E001               LDI     R16, 1
   \   0000004C   C001               RJMP    ??ReadFlashPage_3
    117              } else {
    118                  return FALSE;                           // Return FALSE if not valid page address
   \                     ??ReadFlashPage_0:
   \   0000004E   E000               LDI     R16, 0
   \                     ??ReadFlashPage_3:
   \   00000050   9624               ADIW    R29:R28, 4
   \   00000052   E0E4               LDI     R30, 4
   \   00000054   ........           JMP     ?EPILOGUE_B4_L09
    119              }
    120          }
    121          
    122          /*!
    123          * The function writes byte data to Flash address flashAddr. Returns FALSE if
    124          * input address is not valid Flash byte address for writing, else TRUE.
    125          **/
    126          

   \                                 In  segment CODE, align 2, keep-with-next
    127          unsigned char WriteFlashByte(MyAddressType flashAddr, unsigned char data) {
   \                     WriteFlashByte:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   9728               SBIW    R29:R28, 8
   \   00000006   8308               ST      Y, R16
   \   00000008   8319               STD     Y+1, R17
   \   0000000A   832A               STD     Y+2, R18
   \   0000000C   833B               STD     Y+3, R19
   \   0000000E   2F84               MOV     R24, R20
    128              MyAddressType  pageAdr;
    129              unsigned char eepromInterruptSettings;
    130              if (AddressCheck(flashAddr & ~(PAGESIZE - 1))) {
   \   00000010   8108               LD      R16, Y
   \   00000012   8119               LDD     R17, Y+1
   \   00000014   812A               LDD     R18, Y+2
   \   00000016   813B               LDD     R19, Y+3
   \   00000018   7000               ANDI    R16, 0x00
   \   0000001A   7F1F               ANDI    R17, 0xFF
   \   0000001C   7F2F               ANDI    R18, 0xFF
   \   0000001E   7F3F               ANDI    R19, 0xFF
   \   00000020   ....               RCALL   AddressCheck
   \   00000022   2300               TST     R16
   \   00000024   F409               BRNE    $+2+2
   \   00000026   C04C               RJMP    ??WriteFlashByte_0
    131                  eepromInterruptSettings = EECR & (1 << EERIE); // Stores EEPROM interrupt mask
   \   00000028   B30F               IN      R16, 0x1F
   \   0000002A   7008               ANDI    R16, 0x08
   \   0000002C   2F90               MOV     R25, R16
    132                  EECR &= ~(1 << EERIE);                        // Disable EEPROM interrupt
   \   0000002E   98FB               CBI     0x1F, 0x03
    133                  while (EECR & (1 << EEPROM_program_enable));   // Wait if ongoing EEPROM write
   \                     ??WriteFlashByte_1:
   \   00000030   99F9               SBIC    0x1F, 0x01
   \   00000032   CFFE               RJMP    ??WriteFlashByte_1
    134          
    135                  pageAdr = flashAddr & ~(PAGESIZE - 1);          // Gets Flash page address from byte address
   \   00000034   8108               LD      R16, Y
   \   00000036   8119               LDD     R17, Y+1
   \   00000038   812A               LDD     R18, Y+2
   \   0000003A   813B               LDD     R19, Y+3
   \   0000003C   7000               ANDI    R16, 0x00
   \   0000003E   7F1F               ANDI    R17, 0xFF
   \   00000040   7F2F               ANDI    R18, 0xFF
   \   00000042   7F3F               ANDI    R19, 0xFF
   \   00000044   830C               STD     Y+4, R16
   \   00000046   831D               STD     Y+5, R17
   \   00000048   832E               STD     Y+6, R18
   \   0000004A   833F               STD     Y+7, R19
    136          
    137          #ifdef __FLASH_RECOVER
    138                  FlashBackup.status = 0;    // Indicate that Flash buffer does not contain data for writing
   \   0000004C   E000               LDI     R16, 0
   \   0000004E   9300....           STS     (FlashBackup + 2), R16
    139                  while (EECR & (1 << EEPROM_program_enable));
   \                     ??WriteFlashByte_2:
   \   00000052   99F9               SBIC    0x1F, 0x01
   \   00000054   CFFE               RJMP    ??WriteFlashByte_2
    140                  LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
   \   00000056   2F48               MOV     R20, R24
   \   00000058   8108               LD      R16, Y
   \   0000005A   8119               LDD     R17, Y+1
   \   0000005C   812A               LDD     R18, Y+2
   \   0000005E   813B               LDD     R19, Y+3
   \   00000060   ........           CALL    LpmReplaceSpm
    141                  WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
   \   00000064   E000               LDI     R16, 0
   \   00000066   EE1F               LDI     R17, 239
   \   00000068   E020               LDI     R18, 0
   \   0000006A   E030               LDI     R19, 0
   \   0000006C   ........           CALL    WriteBufToFlash
    142                  FlashBackup.pageNumber = (unsigned int)(pageAdr / PAGESIZE); //Stores page address of data
   \   00000070   810C               LDD     R16, Y+4
   \   00000072   811D               LDD     R17, Y+5
   \   00000074   812E               LDD     R18, Y+6
   \   00000076   813F               LDD     R19, Y+7
   \   00000078   2F01               MOV     R16, R17
   \   0000007A   2F12               MOV     R17, R18
   \   0000007C   2F23               MOV     R18, R19
   \   0000007E   E030               LDI     R19, 0
   \   00000080   ....               LDI     R30, LOW(FlashBackup)
   \   00000082   ....               LDI     R31, (FlashBackup) >> 8
   \   00000084   8300               ST      Z, R16
   \   00000086   8311               STD     Z+1, R17
    143                  FlashBackup.status = FLASH_BUFFER_FULL_ID; // Indicates that Flash recovery buffer
   \   00000088   EA0A               LDI     R16, 170
   \   0000008A   9300....           STS     (FlashBackup + 2), R16
    144                  // contains unwritten data
    145                  while (EECR & (1 << EEPROM_program_enable));
   \                     ??WriteFlashByte_3:
   \   0000008E   99F9               SBIC    0x1F, 0x01
   \   00000090   CFFE               RJMP    ??WriteFlashByte_3
    146          #endif
    147                  LpmReplaceSpm(flashAddr, data);         // Fills Flash write buffer
   \   00000092   2F48               MOV     R20, R24
   \   00000094   8108               LD      R16, Y
   \   00000096   8119               LDD     R17, Y+1
   \   00000098   812A               LDD     R18, Y+2
   \   0000009A   813B               LDD     R19, Y+3
   \   0000009C   ........           CALL    LpmReplaceSpm
    148                  WriteBufToFlash(pageAdr);               // Writes to Flash
   \   000000A0   810C               LDD     R16, Y+4
   \   000000A2   811D               LDD     R17, Y+5
   \   000000A4   812E               LDD     R18, Y+6
   \   000000A6   813F               LDD     R19, Y+7
   \   000000A8   ........           CALL    WriteBufToFlash
    149          
    150          #ifdef __FLASH_RECOVER
    151                  FlashBackup.status = 0; //Indicates that Flash recovery buffer does not contain unwritten data
   \   000000AC   E000               LDI     R16, 0
   \   000000AE   9300....           STS     (FlashBackup + 2), R16
    152          
    153                  while (EECR & (1 << EEPROM_program_enable));
   \                     ??WriteFlashByte_4:
   \   000000B2   99F9               SBIC    0x1F, 0x01
   \   000000B4   CFFE               RJMP    ??WriteFlashByte_4
    154          #endif
    155          
    156                  EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
   \   000000B6   B30F               IN      R16, 0x1F
   \   000000B8   2B09               OR      R16, R25
   \   000000BA   BB0F               OUT     0x1F, R16
    157                  return TRUE;                            // Return TRUE if address valid for writing
   \   000000BC   E001               LDI     R16, 1
   \   000000BE   C001               RJMP    ??WriteFlashByte_5
    158              } else return FALSE;                           // Return FALSE if address not valid for writing
   \                     ??WriteFlashByte_0:
   \   000000C0   E000               LDI     R16, 0
   \                     ??WriteFlashByte_5:
   \   000000C2   9628               ADIW    R29:R28, 8
   \   000000C4   9189               LD      R24, Y+
   \   000000C6   9199               LD      R25, Y+
   \   000000C8   9508               RET
   \   000000CA                      REQUIRE _A_EECR
    159          }
    160          
    161          /*
    162          * The function writes data from array dataPage[] to Flash page address
    163          * flashStartAdr. The Number of bytes written is depending upon the Flash page
    164          * size. Returns FALSE if input argument ucFlashStartAdr is not a valid Flash
    165          * page address for writing, else TRUE.
    166          */
    167          
    168          

   \                                 In  segment CODE, align 2, keep-with-next
    169          unsigned char WriteFlashPage(MyAddressType flashStartAdr, unsigned char *dataPage) {
   \                     WriteFlashPage:
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   9724               SBIW    R29:R28, 4
   \   00000006   8308               ST      Y, R16
   \   00000008   8319               STD     Y+1, R17
   \   0000000A   832A               STD     Y+2, R18
   \   0000000C   833B               STD     Y+3, R19
   \   0000000E   01CA               MOVW    R25:R24, R21:R20
    170              unsigned char eepromInterruptSettings;
    171              if (AddressCheck(flashStartAdr)) {
   \   00000010   8108               LD      R16, Y
   \   00000012   8119               LDD     R17, Y+1
   \   00000014   812A               LDD     R18, Y+2
   \   00000016   813B               LDD     R19, Y+3
   \   00000018   ....               RCALL   AddressCheck
   \   0000001A   2300               TST     R16
   \   0000001C   F1C1               BREQ    ??WriteFlashPage_0
    172                  eepromInterruptSettings = EECR & (1 << EERIE);   // Stores EEPROM interrupt mask
   \   0000001E   B30F               IN      R16, 0x1F
   \   00000020   7008               ANDI    R16, 0x08
   \   00000022   2FA0               MOV     R26, R16
    173                  EECR &= ~(1 << EERIE);                           // Disable EEPROM interrupt
   \   00000024   98FB               CBI     0x1F, 0x03
    174                  while (EECR & (1 << EEPROM_program_enable));      // Wait if ongoing EEPROM write
   \                     ??WriteFlashPage_1:
   \   00000026   99F9               SBIC    0x1F, 0x01
   \   00000028   CFFE               RJMP    ??WriteFlashPage_1
    175          
    176          #ifdef __FLASH_RECOVER
    177                  FlashBackup.status = 0;       // Indicate that Flash buffer does not contain data for writing
   \   0000002A   E000               LDI     R16, 0
   \   0000002C   9300....           STS     (FlashBackup + 2), R16
    178                  while (EECR & (1 << EEPROM_program_enable));
   \                     ??WriteFlashPage_2:
   \   00000030   99F9               SBIC    0x1F, 0x01
   \   00000032   CFFE               RJMP    ??WriteFlashPage_2
    179                  FillBuffer(dataPage);
   \   00000034   018C               MOVW    R17:R16, R25:R24
   \   00000036   ........           CALL    FillBuffer
    180                  WriteBufToFlash(ADR_FLASH_BUFFER);      // Writes to Flash recovery buffer
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   EE1F               LDI     R17, 239
   \   0000003E   E020               LDI     R18, 0
   \   00000040   E030               LDI     R19, 0
   \   00000042   ........           CALL    WriteBufToFlash
    181                  FlashBackup.pageNumber = (unsigned int)(flashStartAdr / PAGESIZE);
   \   00000046   8108               LD      R16, Y
   \   00000048   8119               LDD     R17, Y+1
   \   0000004A   812A               LDD     R18, Y+2
   \   0000004C   813B               LDD     R19, Y+3
   \   0000004E   2F01               MOV     R16, R17
   \   00000050   2F12               MOV     R17, R18
   \   00000052   2F23               MOV     R18, R19
   \   00000054   E030               LDI     R19, 0
   \   00000056   ....               LDI     R30, LOW(FlashBackup)
   \   00000058   ....               LDI     R31, (FlashBackup) >> 8
   \   0000005A   8300               ST      Z, R16
   \   0000005C   8311               STD     Z+1, R17
    182                  /* Indicates that Flash recovery buffer contains unwritten data */
    183                  FlashBackup.status = FLASH_BUFFER_FULL_ID;
   \   0000005E   EA0A               LDI     R16, 170
   \   00000060   9300....           STS     (FlashBackup + 2), R16
    184                  while (EECR & (1 << EEPROM_program_enable));
   \                     ??WriteFlashPage_3:
   \   00000064   99F9               SBIC    0x1F, 0x01
   \   00000066   CFFE               RJMP    ??WriteFlashPage_3
    185          #endif
    186                  FillBuffer(dataPage);
   \   00000068   018C               MOVW    R17:R16, R25:R24
   \   0000006A   ........           CALL    FillBuffer
    187                  WriteBufToFlash(flashStartAdr);         // Writes to Flash
   \   0000006E   8108               LD      R16, Y
   \   00000070   8119               LDD     R17, Y+1
   \   00000072   812A               LDD     R18, Y+2
   \   00000074   813B               LDD     R19, Y+3
   \   00000076   ........           CALL    WriteBufToFlash
    188          #ifdef __FLASH_RECOVER
    189                  FlashBackup.status = 0;    // Indicate that Flash buffer does not contain data for writing
   \   0000007A   E000               LDI     R16, 0
   \   0000007C   9300....           STS     (FlashBackup + 2), R16
    190                  while (EECR & (1 << EEPROM_program_enable));
   \                     ??WriteFlashPage_4:
   \   00000080   99F9               SBIC    0x1F, 0x01
   \   00000082   CFFE               RJMP    ??WriteFlashPage_4
    191          #endif
    192          
    193                  EECR |= eepromInterruptSettings;        // Restore EEPROM interrupt mask
   \   00000084   B30F               IN      R16, 0x1F
   \   00000086   2B0A               OR      R16, R26
   \   00000088   BB0F               OUT     0x1F, R16
    194                  return TRUE;                            // Return TRUE if address
   \   0000008A   E001               LDI     R16, 1
   \   0000008C   C001               RJMP    ??WriteFlashPage_5
    195                  // valid for writing
    196              } else return FALSE;                           // Return FALSE if not address not
   \                     ??WriteFlashPage_0:
   \   0000008E   E000               LDI     R16, 0
   \                     ??WriteFlashPage_5:
   \   00000090   9624               ADIW    R29:R28, 4
   \   00000092   E0E3               LDI     R30, 3
   \   00000094   ........           JMP     ?EPILOGUE_B3_L09
   \   00000098                      REQUIRE _A_EECR
    197                                                             // valid for writing
    198          }
    199          
    200          /*
    201          * The function checks if global variable FlashBackup.status indicates that Flash recovery
    202          * buffer contains data that needs to be written to Flash. Writes data from
    203          * Flash recovery buffer to Flash page address given by FLASH_recovery.pageAdr.
    204          * This function should be called at program startup if FLASH recovery option
    205          * is enabled.
    206          */
    207          
    208          unsigned char RecoverFlash() BOOTLOADER_SECTION;

   \                                 In  segment .bootloader, align 2, keep-with-next
    209          unsigned char RecoverFlash() {
   \                     RecoverFlash:
   \   00000000   2F59               MOV     R21, R25
   \   00000002   2F68               MOV     R22, R24
    210          #ifdef __FLASH_RECOVER
    211              unsigned int index;
    212              if (FlashBackup.status == FLASH_BUFFER_FULL_ID) { // Checks if Flash recovery buffer contains data
   \   00000004   9100....           LDS     R16, (FlashBackup + 2)
   \   00000008   3A0A               CPI     R16, 170
   \   0000000A   F531               BRNE    ??RecoverFlash_0
    213                  for (index = 0; index < PAGESIZE; index += 2) {     // Writes to Flash write buffer
   \   0000000C   E080               LDI     R24, 0
   \   0000000E   E090               LDI     R25, 0
   \                     ??RecoverFlash_1:
   \   00000010   3080               CPI     R24, 0
   \   00000012   E001               LDI     R16, 1
   \   00000014   0790               CPC     R25, R16
   \   00000016   F470               BRCC    ??RecoverFlash_2
    214                      _FILL_TEMP_WORD(index, *((MyFlashIntPointer)(ADR_FLASH_BUFFER + index)));
   \   00000018   E001               LDI     R16, 1
   \   0000001A   01FC               MOVW    R31:R30, R25:R24
   \   0000001C   50E0               SUBI    R30, 0
   \   0000001E   41F1               SBCI    R31, 17
   \   00000020   E030               LDI     R19, 0
   \   00000022   BF3B               OUT     0x3B, R19
   \   00000024   9007               ELPM    R0, Z+
   \   00000026   9016               ELPM    R1, Z
   \   00000028   9731               SBIW    R31:R30, 1
   \   0000002A   01FC               MOVW    R31:R30, R25:R24
   \   0000002C   BF07               OUT     0x37, R16
   \   0000002E   95E8               SPM
    215                  }
   \   00000030   9602               ADIW    R25:R24, 2
   \   00000032   CFEE               RJMP    ??RecoverFlash_1
    216                  WriteBufToFlash((MyAddressType)FlashBackup.pageNumber * PAGESIZE);
   \                     ??RecoverFlash_2:
   \   00000034   ....               LDI     R30, LOW(FlashBackup)
   \   00000036   ....               LDI     R31, (FlashBackup) >> 8
   \   00000038   8100               LD      R16, Z
   \   0000003A   8111               LDD     R17, Z+1
   \   0000003C   E020               LDI     R18, 0
   \   0000003E   E030               LDI     R19, 0
   \   00000040   2F32               MOV     R19, R18
   \   00000042   2F21               MOV     R18, R17
   \   00000044   2F10               MOV     R17, R16
   \   00000046   E000               LDI     R16, 0
   \   00000048   ....               RCALL   WriteBufToFlash
    217                  FlashBackup.status = 0;     // Indicate that Flash buffer does not contain data for writing
   \   0000004A   E000               LDI     R16, 0
   \   0000004C   9300....           STS     (FlashBackup + 2), R16
    218                  while (EECR & (1 << EEPROM_program_enable));
   \                     ??RecoverFlash_3:
   \   00000050   99F9               SBIC    0x1F, 0x01
   \   00000052   CFFE               RJMP    ??RecoverFlash_3
    219                  return TRUE;               // Returns TRUE if recovery has taken place
   \   00000054   E001               LDI     R16, 1
   \   00000056   C001               RJMP    ??RecoverFlash_4
    220              }
    221          #endif
    222              return FALSE;
   \                     ??RecoverFlash_0:
   \   00000058   E000               LDI     R16, 0
   \                     ??RecoverFlash_4:
   \   0000005A   2F86               MOV     R24, R22
   \   0000005C   2F95               MOV     R25, R21
   \   0000005E   9508               RET
   \   00000060                      REQUIRE _A_EECR
    223          }
    224          
    225          
    226          /*
    227          * The function checks if input argument is a valid Flash page address for
    228          * writing. Returns TRUE only if:
    229          * - Address points to the beginning of a Flash page
    230          * - Address is within the limits defined in Self_programming.h
    231          * - Address is not equal to page address used for buffering by the Flash recovery
    232          *   functions (if enabled).
    233          * Returns FALSE else.
    234          */

   \                                 In  segment CODE, align 2, keep-with-next
    235          unsigned char AddressCheck(MyAddressType flashAdr) {
   \                     AddressCheck:
   \   00000000   9724               SBIW    R29:R28, 4
   \   00000002   8308               ST      Y, R16
   \   00000004   8319               STD     Y+1, R17
   \   00000006   832A               STD     Y+2, R18
   \   00000008   833B               STD     Y+3, R19
    236          #ifdef __FLASH_RECOVER
    237              //The next line gives a warning 'pointless comparison with zero' if ADR_LIMIT_LOW is 0. Ignore it.
    238              if ((flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) &&
    239                  (flashAdr != ADR_FLASH_BUFFER) && !(flashAdr & (PAGESIZE - 1))) return TRUE;                            // Address is a valid page address
   \   0000000A   8148               LD      R20, Y
   \   0000000C   8159               LDD     R21, Y+1
   \   0000000E   816A               LDD     R22, Y+2
   \   00000010   817B               LDD     R23, Y+3
   \   00000012   8108               LD      R16, Y
   \   00000014   8119               LDD     R17, Y+1
   \   00000016   812A               LDD     R18, Y+2
   \   00000018   813B               LDD     R19, Y+3
   \   0000001A   3000               CPI     R16, 0
   \   0000001C   EEE0               LDI     R30, 224
   \   0000001E   071E               CPC     R17, R30
   \   00000020   E0E1               LDI     R30, 1
   \   00000022   072E               CPC     R18, R30
   \   00000024   E0E0               LDI     R30, 0
   \   00000026   073E               CPC     R19, R30
   \   00000028   F4A8               BRCC    ??AddressCheck_0
   \   0000002A   8108               LD      R16, Y
   \   0000002C   8119               LDD     R17, Y+1
   \   0000002E   812A               LDD     R18, Y+2
   \   00000030   813B               LDD     R19, Y+3
   \   00000032   3000               CPI     R16, 0
   \   00000034   EE4F               LDI     R20, 239
   \   00000036   0714               CPC     R17, R20
   \   00000038   E040               LDI     R20, 0
   \   0000003A   0724               CPC     R18, R20
   \   0000003C   E040               LDI     R20, 0
   \   0000003E   0734               CPC     R19, R20
   \   00000040   F049               BREQ    ??AddressCheck_0
   \   00000042   8108               LD      R16, Y
   \   00000044   8119               LDD     R17, Y+1
   \   00000046   812A               LDD     R18, Y+2
   \   00000048   813B               LDD     R19, Y+3
   \   0000004A   7F0F               ANDI    R16, 0xFF
   \   0000004C   2300               TST     R16
   \   0000004E   F411               BRNE    ??AddressCheck_0
   \   00000050   E001               LDI     R16, 1
   \   00000052   C001               RJMP    ??AddressCheck_1
    240              else return FALSE;                           // Address is not a valid page address
   \                     ??AddressCheck_0:
   \   00000054   E000               LDI     R16, 0
   \                     ??AddressCheck_1:
   \   00000056   9624               ADIW    R29:R28, 4
   \   00000058   9508               RET
    241          #else
    242              if ((flashAdr >= ADR_LIMIT_LOW) && (flashAdr <= ADR_LIMIT_HIGH) && !(flashAdr & (PAGESIZE - 1))) return TRUE;                            // Address is a valid page address
    243              else return FALSE;                           // Address is not a valid page address
    244          #endif
    245          }
    246          
    247          
    248          /*
    249          * The function writes Flash temporary buffer to Flash page address given by
    250          * input argument.
    251          */
    252          
    253          void WriteBufToFlash(MyAddressType flashStartAdr) BOOTLOADER_SECTION;

   \                                 In  segment .bootloader, align 2, keep-with-next
    254          void WriteBufToFlash(MyAddressType flashStartAdr) {
   \                     WriteBufToFlash:
   \   00000000   9724               SBIW    R29:R28, 4
   \   00000002   8308               ST      Y, R16
   \   00000004   8319               STD     Y+1, R17
   \   00000006   832A               STD     Y+2, R18
   \   00000008   833B               STD     Y+3, R19
    255          #ifdef __HAS_RAMPZ__
    256              RAMPZ = (unsigned char)(flashStartAdr >> 16);
   \   0000000A   8108               LD      R16, Y
   \   0000000C   8119               LDD     R17, Y+1
   \   0000000E   812A               LDD     R18, Y+2
   \   00000010   813B               LDD     R19, Y+3
   \   00000012   2F02               MOV     R16, R18
   \   00000014   2F13               MOV     R17, R19
   \   00000016   E020               LDI     R18, 0
   \   00000018   E030               LDI     R19, 0
   \   0000001A   BF0B               OUT     0x3B, R16
    257          #endif
    258              _PAGE_ERASE(flashStartAdr);
   \   0000001C   E043               LDI     R20, 3
   \   0000001E   8108               LD      R16, Y
   \   00000020   8119               LDD     R17, Y+1
   \   00000022   812A               LDD     R18, Y+2
   \   00000024   813B               LDD     R19, Y+3
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   BF47               OUT     0x37, R20
   \   0000002A   95E8               SPM
    259              while (SPMControllRegister & (1 << SPMEN)); // Wait until Flash write completed
   \                     ??WriteBufToFlash_0:
   \   0000002C   B707               IN      R16, 0x37
   \   0000002E   2F10               MOV     R17, R16
   \   00000030   FD10               SBRC    R17, 0
   \   00000032   CFFC               RJMP    ??WriteBufToFlash_0
    260              _PAGE_WRITE(flashStartAdr);
   \   00000034   E045               LDI     R20, 5
   \   00000036   8108               LD      R16, Y
   \   00000038   8119               LDD     R17, Y+1
   \   0000003A   812A               LDD     R18, Y+2
   \   0000003C   813B               LDD     R19, Y+3
   \   0000003E   01F8               MOVW    R31:R30, R17:R16
   \   00000040   BF47               OUT     0x37, R20
   \   00000042   95E8               SPM
    261              while (SPMControllRegister & (1 << SPMEN)); // Wait until Flash write completed
   \                     ??WriteBufToFlash_1:
   \   00000044   B707               IN      R16, 0x37
   \   00000046   2F10               MOV     R17, R16
   \   00000048   FD10               SBRC    R17, 0
   \   0000004A   CFFC               RJMP    ??WriteBufToFlash_1
    262          #ifdef RWWSRE
    263              _ENABLE_RWW_SECTION(); // Enable RWW
   \   0000004C   E111               LDI     R17, 17
   \   0000004E   E000               LDI     R16, 0
   \   00000050   2E00               MOV     R0, R16
   \   00000052   BF17               OUT     0x37, R17
   \   00000054   95E8               SPM
    264          #endif
    265          }
   \   00000056   9624               ADIW    R29:R28, 4
   \   00000058   9508               RET
   \   0000005A                      REQUIRE _A_RAMPZ
   \   0000005A                      REQUIRE _A_SPMCSR
    266          
    267          /*
    268          * The function reads Flash page given by flashAddr, replaces one byte given by
    269          * flashAddr with data, and stores entire page in Flash temporary buffer.
    270          */
    271          
    272          void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data) BOOTLOADER_SECTION;

   \                                 In  segment .bootloader, align 2, keep-with-next
    273          void LpmReplaceSpm(MyAddressType flashAddr, unsigned char data) {
   \                     LpmReplaceSpm:
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004   9728               SBIW    R29:R28, 8
   \   00000006   8308               ST      Y, R16
   \   00000008   8319               STD     Y+1, R17
   \   0000000A   832A               STD     Y+2, R18
   \   0000000C   833B               STD     Y+3, R19
    274              unsigned int index, oddByte, pcWord;
    275              MyAddressType  pageAdr;
    276              oddByte = (unsigned char)flashAddr & 1;
   \   0000000E   8108               LD      R16, Y
   \   00000010   8119               LDD     R17, Y+1
   \   00000012   812A               LDD     R18, Y+2
   \   00000014   813B               LDD     R19, Y+3
   \   00000016   7001               ANDI    R16, 0x01
   \   00000018   7010               ANDI    R17, 0x00
   \   0000001A   01B8               MOVW    R23:R22, R17:R16
    277              pcWord = (unsigned int)flashAddr & (PAGESIZE - 2); // Used when writing FLASH temp buffer
   \   0000001C   8108               LD      R16, Y
   \   0000001E   8119               LDD     R17, Y+1
   \   00000020   812A               LDD     R18, Y+2
   \   00000022   813B               LDD     R19, Y+3
   \   00000024   7F0E               ANDI    R16, 0xFE
   \   00000026   7010               ANDI    R17, 0x00
   \   00000028   0118               MOVW    R3:R2, R17:R16
    278              pageAdr = flashAddr & ~(PAGESIZE - 1);        // Get FLASH page address from byte address
   \   0000002A   8108               LD      R16, Y
   \   0000002C   8119               LDD     R17, Y+1
   \   0000002E   812A               LDD     R18, Y+2
   \   00000030   813B               LDD     R19, Y+3
   \   00000032   7000               ANDI    R16, 0x00
   \   00000034   7F1F               ANDI    R17, 0xFF
   \   00000036   7F2F               ANDI    R18, 0xFF
   \   00000038   7F3F               ANDI    R19, 0xFF
   \   0000003A   830C               STD     Y+4, R16
   \   0000003C   831D               STD     Y+5, R17
   \   0000003E   832E               STD     Y+6, R18
   \   00000040   833F               STD     Y+7, R19
    279              for (index = 0; index < PAGESIZE; index += 2) {
   \   00000042   E080               LDI     R24, 0
   \   00000044   E090               LDI     R25, 0
   \                     ??LpmReplaceSpm_0:
   \   00000046   3080               CPI     R24, 0
   \   00000048   E001               LDI     R16, 1
   \   0000004A   0790               CPC     R25, R16
   \   0000004C   F008               BRCS    $+2+2
   \   0000004E   C041               RJMP    ??LpmReplaceSpm_1
    280                  if (index == pcWord) {
   \   00000050   1582               CP      R24, R2
   \   00000052   0593               CPC     R25, R3
   \   00000054   F541               BRNE    ??LpmReplaceSpm_2
    281                      if (oddByte) {
   \   00000056   2F06               MOV     R16, R22
   \   00000058   2B07               OR      R16, R23
   \   0000005A   F091               BREQ    ??LpmReplaceSpm_3
    282                          _FILL_TEMP_WORD(index, (*(MyFlashCharPointer)(flashAddr & ~1) |
    283                                                  ((unsigned int)data << 8)));
   \   0000005C   8108               LD      R16, Y
   \   0000005E   8119               LDD     R17, Y+1
   \   00000060   812A               LDD     R18, Y+2
   \   00000062   813B               LDD     R19, Y+3
   \   00000064   E051               LDI     R21, 1
   \   00000066   7F0E               ANDI    R16, 0xFE
   \   00000068   7F1F               ANDI    R17, 0xFF
   \   0000006A   7F2F               ANDI    R18, 0xFF
   \   0000006C   7F3F               ANDI    R19, 0xFF
   \   0000006E   01F8               MOVW    R31:R30, R17:R16
   \   00000070   2F32               MOV     R19, R18
   \   00000072   BF3B               OUT     0x3B, R19
   \   00000074   9006               ELPM    R0, Z
   \   00000076   2E14               MOV     R1, R20
   \   00000078   01FC               MOVW    R31:R30, R25:R24
   \   0000007A   BF57               OUT     0x37, R21
   \   0000007C   95E8               SPM
   \   0000007E   C027               RJMP    ??LpmReplaceSpm_4
    284                      }                                     // Write odd byte in temporary buffer
    285                      else {
    286                          _FILL_TEMP_WORD(index, ((*((MyFlashCharPointer)flashAddr + 1) << 8) | data));
   \                     ??LpmReplaceSpm_3:
   \   00000080   8048               LD      R4, Y
   \   00000082   8059               LDD     R5, Y+1
   \   00000084   806A               LDD     R6, Y+2
   \   00000086   807B               LDD     R7, Y+3
   \   00000088   E001               LDI     R16, 1
   \   0000008A   01F2               MOVW    R31:R30, R5:R4
   \   0000008C   2D36               MOV     R19, R6
   \   0000008E   9631               ADIW    R31:R30, 1
   \   00000090   BF3B               OUT     0x3B, R19
   \   00000092   9016               ELPM    R1, Z
   \   00000094   9731               SBIW    R31:R30, 1
   \   00000096   2400               CLR     R0
   \   00000098   E050               LDI     R21, 0
   \   0000009A   2A04               OR      R0, R20
   \   0000009C   2A15               OR      R1, R21
   \   0000009E   01FC               MOVW    R31:R30, R25:R24
   \   000000A0   BF07               OUT     0x37, R16
   \   000000A2   95E8               SPM
   \   000000A4   C014               RJMP    ??LpmReplaceSpm_4
    287                      }                                     // Write even byte in temporary buffer
    288                  } else {
    289                      _FILL_TEMP_WORD(index, *((MyFlashIntPointer)(pageAdr + index)));
   \                     ??LpmReplaceSpm_2:
   \   000000A6   810C               LDD     R16, Y+4
   \   000000A8   811D               LDD     R17, Y+5
   \   000000AA   812E               LDD     R18, Y+6
   \   000000AC   813F               LDD     R19, Y+7
   \   000000AE   E051               LDI     R21, 1
   \   000000B0   E0A0               LDI     R26, 0
   \   000000B2   E0B0               LDI     R27, 0
   \   000000B4   0F08               ADD     R16, R24
   \   000000B6   1F19               ADC     R17, R25
   \   000000B8   1F2A               ADC     R18, R26
   \   000000BA   1F3B               ADC     R19, R27
   \   000000BC   01F8               MOVW    R31:R30, R17:R16
   \   000000BE   2F32               MOV     R19, R18
   \   000000C0   BF3B               OUT     0x3B, R19
   \   000000C2   9007               ELPM    R0, Z+
   \   000000C4   9016               ELPM    R1, Z
   \   000000C6   9731               SBIW    R31:R30, 1
   \   000000C8   01FC               MOVW    R31:R30, R25:R24
   \   000000CA   BF57               OUT     0x37, R21
   \   000000CC   95E8               SPM
    290                  }                                       // Write Flash word directly to temporary buffer
    291              }
   \                     ??LpmReplaceSpm_4:
   \   000000CE   9602               ADIW    R25:R24, 2
   \   000000D0   CFBA               RJMP    ??LpmReplaceSpm_0
    292          }
   \                     ??LpmReplaceSpm_1:
   \   000000D2   9628               ADIW    R29:R28, 8
   \   000000D4   E0E8               LDI     R30, 8
   \   000000D6   ........           JMP     ?EPILOGUE_B8_L09
    293          
    294          /*
    295          *This function fills the temporary bufer with the data
    296          */
    297          void FillBuffer(unsigned char *dataPage) BOOTLOADER_SECTION;

   \                                 In  segment .bootloader, align 2, keep-with-next
    298          void FillBuffer(unsigned char *dataPage) {
   \                     FillBuffer:
   \   00000000   2F39               MOV     R19, R25
   \   00000002   2F48               MOV     R20, R24
    299              unsigned int index;
    300              for (index = 0; index < PAGESIZE; index += 2) { // Fills Flash write buffer
   \   00000004   E080               LDI     R24, 0
   \   00000006   E090               LDI     R25, 0
   \                     ??FillBuffer_0:
   \   00000008   3080               CPI     R24, 0
   \   0000000A   E021               LDI     R18, 1
   \   0000000C   0792               CPC     R25, R18
   \   0000000E   F470               BRCC    ??FillBuffer_1
    301                  _FILL_TEMP_WORD(index, (unsigned int)dataPage[index] + ((unsigned int)dataPage[index + 1] << 8));
   \   00000010   E021               LDI     R18, 1
   \   00000012   01F8               MOVW    R31:R30, R17:R16
   \   00000014   0FE8               ADD     R30, R24
   \   00000016   1FF9               ADC     R31, R25
   \   00000018   8000               LD      R0, Z
   \   0000001A   01F8               MOVW    R31:R30, R17:R16
   \   0000001C   0FE8               ADD     R30, R24
   \   0000001E   1FF9               ADC     R31, R25
   \   00000020   8011               LDD     R1, Z+1
   \   00000022   01FC               MOVW    R31:R30, R25:R24
   \   00000024   BF27               OUT     0x37, R18
   \   00000026   95E8               SPM
    302              }
   \   00000028   9602               ADIW    R25:R24, 2
   \   0000002A   CFEE               RJMP    ??FillBuffer_0
    303          }
   \                     ??FillBuffer_1:
   \   0000002C   2F84               MOV     R24, R20
   \   0000002E   2F93               MOV     R25, R19
   \   00000030   9508               RET

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      4      2   AddressCheck
      0      2   FillBuffer
     16      2   LpmReplaceSpm
      4      2   ReadFlashByte
      8      2   ReadFlashPage
        8      2   -> ReadFlashByte
      0      2   RecoverFlash
        0      2   -> WriteBufToFlash
      4      2   WriteBufToFlash
     10      2   WriteFlashByte
       10      2   -> AddressCheck
       10      2   -> LpmReplaceSpm
       10      2   -> WriteBufToFlash
      7      2   WriteFlashPage
        7      2   -> AddressCheck
        7      2   -> FillBuffer
        7      2   -> WriteBufToFlash


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      90  AddressCheck
      50  FillBuffer
       3  FlashBackup
     218  LpmReplaceSpm
      30  ReadFlashByte
      88  ReadFlashPage
      96  RecoverFlash
      90  WriteBufToFlash
     202  WriteFlashByte
     152  WriteFlashPage
       1  _A_EECR
       1  _A_RAMPZ
       1  _A_SPMCSR
       7  -- Other

 
 454 bytes in segment .bootloader
   3 bytes in segment ABSOLUTE
 562 bytes in segment CODE
   7 bytes in segment INITTAB
   3 bytes in segment NEAR_Z
 
 1 016 bytes of CODE memory (+ 7 bytes shared)
     3 bytes of DATA memory (+ 3 bytes shared)

Errors: none
Warnings: 3
