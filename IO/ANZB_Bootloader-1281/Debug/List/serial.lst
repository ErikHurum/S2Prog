###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       13/Feb/2024  15:22:08
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 8.10
#
#    Source file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Src\serial.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW9DBA.tmp ("C:\Users\ESY\OneDrive
#        -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Src\serial.c"
#        --cpu=m1281 -ms -o "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\Obj" -D
#        SPEED=38400 -D __AVR_ATmega1281__ -D ANZBANA_V8=1 -lCN
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\List" -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\INC\\" -I
#        "C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\..\..\SHARED\INC\\"
#        --eeprom_size 4096 --clib -On)
#    Locale       =  English_USA.1252
#    List file    =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\List\serial.lst
#    Object file  =  
#        C:\Users\ESY\OneDrive -
#        Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Debug\Obj\serial.r90
#
###############################################################################

C:\Users\ESY\OneDrive - Scanjet\Documents\GitHub\S2Prog\IO\ANZB_Bootloader-1281\Src\serial.c
      1          #ifdef __ATMEGA_1280__
      2          #include	"iom1280.h"
      3          #endif
      4          
      5          #ifdef __AVR_ATmega1281__
      6          #include	"iom1281.h"

   \                                 In  segment ABSOLUTE, at 0xc6
   \   union <unnamed> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   union <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1
      7          #endif
      8          #include "stdio.h"
      9          #include "math.h"
     10          #include "externals.h"
     11          #include <intrinsics.h>

   \                                 In  segment CODE, align 2, keep-with-next
     12          void sendchar(char c){
   \                     sendchar:
     13              UART_DATA_REG0 = c;                                   // prepare transmission
   \   00000000   9300....           STS     _A_UDR0, R16
     14              while (!(UART_STATUS_REG0 & (1 << TRANSMIT_COMPLETE_BIT0)));// wait until byte sendt
   \                     ??sendchar_0:
   \   00000004   9110....           LDS     R17, _A_UCSR0A
   \   00000008   2F21               MOV     R18, R17
   \   0000000A   FF26               SBRS    R18, 6
   \   0000000C   CFFB               RJMP    ??sendchar_0
     15              UART_STATUS_REG0 |= (1 << TRANSMIT_COMPLETE_BIT0);          // delete TXCflag
   \   0000000E   911000C0           LDS     R17, 192
   \   00000012   6410               ORI     R17, 0x40
   \   00000014   931000C0           STS     192, R17
     16          }
   \   00000018   9508               RET
   \   0000001A                      REQUIRE _A_UDR0
   \   0000001A                      REQUIRE _A_UCSR0A
     17          
     18          

   \                                 In  segment CODE, align 2, keep-with-next
     19          void recchar(void){
   \                     recchar:
     20            if((UART_STATUS_REG0 & (1 << RECEIVE_COMPLETE_BIT0)) ||(UART_STATUS_REG0 & 0x10)){
   \   00000000   9100....           LDS     R16, _A_UCSR0A
   \   00000004   2F10               MOV     R17, R16
   \   00000006   FD17               SBRC    R17, 7
   \   00000008   C005               RJMP    ??recchar_0
   \   0000000A   9100....           LDS     R16, _A_UCSR0A
   \   0000000E   2F10               MOV     R17, R16
   \   00000010   FF14               SBRS    R17, 4
   \   00000012   C065               RJMP    ??recchar_1
     21              RxBufferCh0[ myUART.RxFirst ] = UART_DATA_REG0;                     // Read the character 
   \                     ??recchar_0:
   \   00000014   9100....           LDS     R16, _A_UDR0
   \   00000018   ....               LDI     R30, LOW(myUART)
   \   0000001A   ....               LDI     R31, (myUART) >> 8
   \   0000001C   8522               LDD     R18, Z+10
   \   0000001E   8533               LDD     R19, Z+11
   \   00000020   01F9               MOVW    R31:R30, R19:R18
   \   00000022   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000024   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   00000026   8300               ST      Z, R16
     22              __watchdog_reset();
   \   00000028   95A8               WDR
     23              if (myUART.RxState != HANDLE) {        // ok to receive? 
   \   0000002A   9100....           LDS     R16, (myUART + 16)
   \   0000002E   300A               CPI     R16, 10
   \   00000030   F409               BRNE    $+2+2
   \   00000032   C055               RJMP    ??recchar_1
     24                  switch (myUART.RxState) {                   // Yes, check state
   \   00000034   9100....           LDS     R16, (myUART + 16)
   \   00000038   2300               TST     R16
   \   0000003A   F5D9               BRNE    ??recchar_2
     25                  case SYNC :
     26                      if ( RxBufferCh0[ myUART.RxFirst ] == ANPRO10_SYN) {
   \   0000003C   ....               LDI     R30, LOW(myUART)
   \   0000003E   ....               LDI     R31, (myUART) >> 8
   \   00000040   8502               LDD     R16, Z+10
   \   00000042   8513               LDD     R17, Z+11
   \   00000044   01F8               MOVW    R31:R30, R17:R16
   \   00000046   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   00000048   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   0000004A   8100               LD      R16, Z
   \   0000004C   3106               CPI     R16, 22
   \   0000004E   F461               BRNE    ??recchar_3
     27                          myUART.SyncCnt ++ ;                 // count sync
   \   00000050   9100....           LDS     R16, (myUART + 17)
   \   00000054   9503               INC     R16
   \   00000056   9300....           STS     (myUART + 17), R16
     28                          myUART.RxFirst = 0;                 // start at start of buff
   \   0000005A   ....               LDI     R30, LOW(myUART)
   \   0000005C   ....               LDI     R31, (myUART) >> 8
   \   0000005E   E000               LDI     R16, 0
   \   00000060   8702               STD     Z+10, R16
   \   00000062   E000               LDI     R16, 0
   \   00000064   8703               STD     Z+11, R16
   \   00000066   9508               RET
     29                      } else if ((myUART.SyncCnt >= 2) && 
     30                                 (RxBufferCh0[ myUART.RxFirst ] == ANPRO10_SOH)) {       // minimum two sync bytes
   \                     ??recchar_3:
   \   00000068   9100....           LDS     R16, (myUART + 17)
   \   0000006C   3002               CPI     R16, 2
   \   0000006E   F0E8               BRCS    ??recchar_4
   \   00000070   ....               LDI     R30, LOW(myUART)
   \   00000072   ....               LDI     R31, (myUART) >> 8
   \   00000074   8502               LDD     R16, Z+10
   \   00000076   8513               LDD     R17, Z+11
   \   00000078   01F8               MOVW    R31:R30, R17:R16
   \   0000007A   ....               SUBI    R30, LOW((-(RxBufferCh0) & 0xFFFF))
   \   0000007C   ....               SBCI    R31, (-(RxBufferCh0) & 0xFFFF) >> 8
   \   0000007E   8100               LD      R16, Z
   \   00000080   3001               CPI     R16, 1
   \   00000082   F499               BRNE    ??recchar_4
     31                          myUART.SyncCnt = 0 ;                // reset counter
   \   00000084   E000               LDI     R16, 0
   \   00000086   9300....           STS     (myUART + 17), R16
     32                          myUART.RxState = HEADER ;
   \   0000008A   E001               LDI     R16, 1
   \   0000008C   9300....           STS     (myUART + 16), R16
     33                          myUART.RxLast = 0 ;
   \   00000090   ....               LDI     R30, LOW(myUART)
   \   00000092   ....               LDI     R31, (myUART) >> 8
   \   00000094   E000               LDI     R16, 0
   \   00000096   8704               STD     Z+12, R16
   \   00000098   E000               LDI     R16, 0
   \   0000009A   8705               STD     Z+13, R16
     34                          myUART.RxTimeout = RX_TO_TIME ;   // reset timeout
   \   0000009C   ....               LDI     R30, LOW(myUART)
   \   0000009E   ....               LDI     R31, (myUART) >> 8
   \   000000A0   EF0A               LDI     R16, 250
   \   000000A2   E010               LDI     R17, 0
   \   000000A4   8B02               STD     Z+18, R16
   \   000000A6   8B13               STD     Z+19, R17
   \   000000A8   9508               RET
     35                      } else {
     36                          myUART.SyncCnt = 0 ;                // start over once more
   \                     ??recchar_4:
   \   000000AA   E000               LDI     R16, 0
   \   000000AC   9300....           STS     (myUART + 17), R16
     37                      }
     38                      break;
   \   000000B0   9508               RET
     39                  default :
     40                      if ((++myUART.RxFirst) > RXSIZE_UART) { // Point to next location
   \                     ??recchar_2:
   \   000000B2   ....               LDI     R30, LOW(myUART)
   \   000000B4   ....               LDI     R31, (myUART) >> 8
   \   000000B6   8502               LDD     R16, Z+10
   \   000000B8   8513               LDD     R17, Z+11
   \   000000BA   5F0F               SUBI    R16, 255
   \   000000BC   4F1F               SBCI    R17, 255
   \   000000BE   8702               STD     Z+10, R16
   \   000000C0   8713               STD     Z+11, R17
   \   000000C2   ....               LDI     R30, LOW(myUART)
   \   000000C4   ....               LDI     R31, (myUART) >> 8
   \   000000C6   8502               LDD     R16, Z+10
   \   000000C8   8513               LDD     R17, Z+11
   \   000000CA   350F               CPI     R16, 95
   \   000000CC   E021               LDI     R18, 1
   \   000000CE   0712               CPC     R17, R18
   \   000000D0   F018               BRCS    ??recchar_5
     41                          GoToSyncUART() ;                       // go to sync mode
   \   000000D2   ........           CALL    GoToSyncUART
   \   000000D6   9508               RET
     42                      } else {
     43                          ReceivePacketUart(0) ;              // Check package
   \                     ??recchar_5:
   \   000000D8   E000               LDI     R16, 0
   \   000000DA   ........           CALL    ReceivePacketUart
     44                      }
     45                      break ;   
     46                  }
     47              }
     48            }
     49          }
   \                     ??recchar_1:
   \   000000DE   9508               RET
   \   000000E0                      REQUIRE _A_UCSR0A
   \   000000E0                      REQUIRE _A_UDR0

   Maximum stack usage in bytes:

   RSTACK Function
   ------ --------
      2   recchar
        2   -> GoToSyncUART
        2   -> ReceivePacketUart
      2   sendchar


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  _A_UCSR0A
       1  _A_UDR0
     224  recchar
      26  sendchar

 
   2 bytes in segment ABSOLUTE
 250 bytes in segment CODE
 
 250 bytes of CODE memory
   0 bytes of DATA memory (+ 2 bytes shared)

Errors: none
Warnings: none
