###############################################################################
#
# IAR C/C++ Compiler V7.30.1.1615 for Microchip AVR       02/Mar/2021  16:10:36
# Copyright 1996-2020 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\ANZB_ATmega1281\Src\eeprom.c
#    Command line =  
#        -f C:\Users\esy\AppData\Local\Temp\EWF1F2.tmp
#        (D:\S2Prog\IO\ANZB_ATmega1281\Src\eeprom.c --cpu=m1281 -ms -o
#        D:\S2Prog\IO\ANZB_ATmega1281\Debug\Obj -D OS_LIBMODE_D -D OS_UART=-1
#        -D USE_16552_DRIVER_TASK=1 -D USE_MODBUS_PROTOCOL=0 -lCN
#        D:\S2Prog\IO\ANZB_ATmega1281\Debug\List -y --initializers_in_flash
#        --debug -DENABLE_BIT_DEFINITIONS -e -I
#        D:\S2Prog\IO\ANZB_ATmega1281\INC\\ -I
#        D:\S2Prog\IO\ANZB_ATmega1281\..\..\SHARED\INC\\ --eeprom_size 4096
#        --clib -Ohs)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\ANZB_ATmega1281\Debug\List\eeprom.lst
#    Object file  =  D:\S2Prog\IO\ANZB_ATmega1281\Debug\Obj\eeprom.r90
#
###############################################################################

D:\S2Prog\IO\ANZB_ATmega1281\Src\eeprom.c
      1          /****************************************************************************************
      2          / Read and write the eeprom
      3          /
      4          ***************************************************************************************/
      5          #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          
     12          
     13          /*---------------------------------------------------------------------------
     14          **
     15          **  See how many date i remining
     16          **
     17          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     18          char TestEEPROM( void ) {
   \                     TestEEPROM:
     19          
     20              return WriteCount;
   \   00000000   9100....           LDS     R16, WriteCount
   \   00000004   9508               RET
     21          }
     22          
     23          /*---------------------------------------------------------------------------
     24          **
     25          **  Reads an address in the eeprom
     26          **
     27          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     28          char ReadEEPROMByte( unsigned int Address ) {
   \                     ReadEEPROMByte:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   01C8               MOVW    R25:R24, R17:R16
     29          
     30              unsigned char Data;
     31          
     32              while (EECR & (1<<EEPE))     // Wait until ready
   \                     ??ReadEEPROMByte_0:
   \   00000006   99F9               SBIC    0x1F, 0x01
   \   00000008   CFFE               RJMP    ??ReadEEPROMByte_0
     33                  ;
     34              OS_IncDI();
   \   0000000A   9100....           LDS     R16, (OS_Counters + 1)
   \   0000000E   7F00               ANDI    R16, 0xF0
   \   00000010   F021               BREQ    ??ReadEEPROMByte_1
   \   00000012   E909               LDI     R16, 153
   \   00000014   E010               LDI     R17, 0
   \   00000016   ........           CALL    OS_Error
   \                     ??ReadEEPROMByte_1:
   \   0000001A   94F8               CLI
   \   0000001C   9100....           LDS     R16, (OS_Counters + 1)
   \   00000020   9503               INC     R16
   \   00000022   9300....           STS     (OS_Counters + 1), R16
     35              EEAR = Address;
   \   00000026   BD92               OUT     0x22, R25
   \   00000028   BD81               OUT     0x21, R24
     36              EECR |= (1 << EERE) ;       // Don't use SetBit macrod due to timing
   \   0000002A   9AF8               SBI     0x1F, 0x00
     37              OS_DecRI();
   \   0000002C   9100....           LDS     R16, (OS_Counters + 1)
   \   00000030   7F00               ANDI    R16, 0xF0
   \   00000032   F021               BREQ    ??ReadEEPROMByte_2
   \   00000034   E909               LDI     R16, 153
   \   00000036   E010               LDI     R17, 0
   \   00000038   ........           CALL    OS_Error
   \                     ??ReadEEPROMByte_2:
   \   0000003C   9100....           LDS     R16, (OS_Counters + 1)
   \   00000040   950A               DEC     R16
   \   00000042   9300....           STS     (OS_Counters + 1), R16
   \   00000046   F409               BRNE    ??ReadEEPROMByte_3
   \   00000048   9478               SEI
     38          
     39              Data = EEDR;
     40              return Data;
   \                     ??ReadEEPROMByte_3:
   \   0000004A   B500               IN      R16, 0x20
   \   0000004C   9189               LD      R24, Y+
   \   0000004E   9199               LD      R25, Y+
   \   00000050   9508               RET
   \   00000052                      REQUIRE _A_EECR
   \   00000052                      REQUIRE _A_EEAR
   \   00000052                      REQUIRE _A_EEDR
     41          
     42          }
     43          
     44          /*---------------------------------------------------------------------------
     45          **
     46          **  Write a caracther to the eeprom
     47          **
     48          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     49          void WriteEEPROMByte( unsigned int Address, char Data ) {   
   \                     WriteEEPROMByte:
   \   00000000   93AA               ST      -Y, R26
   \   00000002   939A               ST      -Y, R25
   \   00000004   938A               ST      -Y, R24
   \   00000006   01C8               MOVW    R25:R24, R17:R16
   \   00000008   2FA2               MOV     R26, R18
     50          
     51              while (EECR & (1<<EEPE))     // Wait until ready
   \                     ??WriteEEPROMByte_0:
   \   0000000A   99F9               SBIC    0x1F, 0x01
   \   0000000C   CFFE               RJMP    ??WriteEEPROMByte_0
     52                  ;
     53              OS_IncDI();
   \   0000000E   9100....           LDS     R16, (OS_Counters + 1)
   \   00000012   7F00               ANDI    R16, 0xF0
   \   00000014   F021               BREQ    ??WriteEEPROMByte_1
   \   00000016   E909               LDI     R16, 153
   \   00000018   E010               LDI     R17, 0
   \   0000001A   ........           CALL    OS_Error
   \                     ??WriteEEPROMByte_1:
   \   0000001E   94F8               CLI
   \   00000020   9100....           LDS     R16, (OS_Counters + 1)
   \   00000024   9503               INC     R16
   \   00000026   9300....           STS     (OS_Counters + 1), R16
     54              EEAR = Address;
   \   0000002A   BD92               OUT     0x22, R25
   \   0000002C   BD81               OUT     0x21, R24
     55              EEDR = Data;
   \   0000002E   BDA0               OUT     0x20, R26
     56              EECR |= (1 << EEMPE) ;       // Don't use SetBit macrod due to timing
   \   00000030   9AFA               SBI     0x1F, 0x02
     57              EECR |= (1 << EEPE) ;        // Don't use SetBit macrod due to timing
   \   00000032   9AF9               SBI     0x1F, 0x01
     58              OS_DecRI();
   \   00000034   9100....           LDS     R16, (OS_Counters + 1)
   \   00000038   7F00               ANDI    R16, 0xF0
   \   0000003A   F021               BREQ    ??WriteEEPROMByte_2
   \   0000003C   E909               LDI     R16, 153
   \   0000003E   E010               LDI     R17, 0
   \   00000040   ........           CALL    OS_Error
   \                     ??WriteEEPROMByte_2:
   \   00000044   9100....           LDS     R16, (OS_Counters + 1)
   \   00000048   950A               DEC     R16
   \   0000004A   9300....           STS     (OS_Counters + 1), R16
   \   0000004E   F409               BRNE    ??WriteEEPROMByte_3
   \   00000050   9478               SEI
     59          }
   \                     ??WriteEEPROMByte_3:
   \   00000052   9189               LD      R24, Y+
   \   00000054   9199               LD      R25, Y+
   \   00000056   91A9               LD      R26, Y+
   \   00000058   9508               RET
   \   0000005A                      REQUIRE _A_EECR
   \   0000005A                      REQUIRE _A_EEAR
   \   0000005A                      REQUIRE _A_EEDR
     60          
     61          /*---------------------------------------------------------------------------
     62          **
     63          **  Read a tring from the eeprom
     64          **
     65          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     66          void ReadEEPROMBuffer( unsigned int Address, char Size, char *pData ) {   
   \                     ReadEEPROMBuffer:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C   01DA               MOVW    R27:R26, R21:R20
     67              unsigned int Index;
     68          
     69              for ( Index = 0; Index < Size; Index++ ) {
   \   0000000E   2322               TST     R18
   \   00000010   F169               BREQ    ??ReadEEPROMBuffer_0
   \   00000012   0128               MOVW    R5:R4, R17:R16
   \   00000014   2F82               MOV     R24, R18
   \   00000016   E090               LDI     R25, 0
   \                     ??ReadEEPROMBuffer_1:
   \   00000018   99F9               SBIC    0x1F, 0x01
   \   0000001A   CFFE               RJMP    ??ReadEEPROMBuffer_1
   \   0000001C   9100....           LDS     R16, (OS_Counters + 1)
   \   00000020   7F00               ANDI    R16, 0xF0
   \   00000022   F021               BREQ    ??ReadEEPROMBuffer_2
   \   00000024   E909               LDI     R16, 153
   \   00000026   E010               LDI     R17, 0
   \   00000028   ........           CALL    OS_Error
   \                     ??ReadEEPROMBuffer_2:
   \   0000002C   94F8               CLI
   \   0000002E   9100....           LDS     R16, (OS_Counters + 1)
   \   00000032   9503               INC     R16
   \   00000034   9300....           STS     (OS_Counters + 1), R16
   \   00000038   BC52               OUT     0x22, R5
   \   0000003A   BC41               OUT     0x21, R4
   \   0000003C   9AF8               SBI     0x1F, 0x00
   \   0000003E   9100....           LDS     R16, (OS_Counters + 1)
   \   00000042   7F00               ANDI    R16, 0xF0
   \   00000044   F021               BREQ    ??ReadEEPROMBuffer_3
   \   00000046   E909               LDI     R16, 153
   \   00000048   E010               LDI     R17, 0
   \   0000004A   ........           CALL    OS_Error
   \                     ??ReadEEPROMBuffer_3:
   \   0000004E   9100....           LDS     R16, (OS_Counters + 1)
   \   00000052   950A               DEC     R16
   \   00000054   9300....           STS     (OS_Counters + 1), R16
   \   00000058   F409               BRNE    ??ReadEEPROMBuffer_4
   \   0000005A   9478               SEI
   \                     ??ReadEEPROMBuffer_4:
   \   0000005C   B500               IN      R16, 0x20
   \   0000005E   930D               ST      X+, R16
   \   00000060   E001               LDI     R16, 1
   \   00000062   0E40               ADD     R4, R16
   \   00000064   E000               LDI     R16, 0
   \   00000066   1E50               ADC     R5, R16
   \   00000068   9701               SBIW    R25:R24, 1
   \   0000006A   F6B1               BRNE    ??ReadEEPROMBuffer_1
     70                  *pData++ = ReadEEPROMByte( Address + Index );
     71              }
     72          }
   \                     ??ReadEEPROMBuffer_0:
   \   0000006C   9189               LD      R24, Y+
   \   0000006E   9199               LD      R25, Y+
   \   00000070   91A9               LD      R26, Y+
   \   00000072   91B9               LD      R27, Y+
   \   00000074   9049               LD      R4, Y+
   \   00000076   9059               LD      R5, Y+
   \   00000078   9508               RET
   \   0000007A                      REQUIRE _A_EECR
   \   0000007A                      REQUIRE _A_EEAR
   \   0000007A                      REQUIRE _A_EEDR
     73          
     74          /*---------------------------------------------------------------------------
     75          **
     76          **  Writ buffer to eeprom
     77          **
     78          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     79          void WriteEEPROMBuffer( unsigned int Address, char Size, char *pData ) {   
   \                     WriteEEPROMBuffer:
   \   00000000   924A               ST      -Y, R4
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000A   01C8               MOVW    R25:R24, R17:R16
   \   0000000C   2E42               MOV     R4, R18
   \   0000000E   01DA               MOVW    R27:R26, R21:R20
     80          
     81              while (EECR & (1<<EEPE))     // Wait until ready
   \                     ??WriteEEPROMBuffer_0:
   \   00000010   99F9               SBIC    0x1F, 0x01
   \   00000012   CFFE               RJMP    ??WriteEEPROMBuffer_0
     82                  ;
     83              OS_IncDI();
   \   00000014   9100....           LDS     R16, (OS_Counters + 1)
   \   00000018   7F00               ANDI    R16, 0xF0
   \   0000001A   F021               BREQ    ??WriteEEPROMBuffer_1
   \   0000001C   E909               LDI     R16, 153
   \   0000001E   E010               LDI     R17, 0
   \   00000020   ........           CALL    OS_Error
   \                     ??WriteEEPROMBuffer_1:
   \   00000024   94F8               CLI
   \   00000026   9100....           LDS     R16, (OS_Counters + 1)
   \   0000002A   9503               INC     R16
   \   0000002C   9300....           STS     (OS_Counters + 1), R16
     84              pWriteBuffer = pData;
   \   00000030   93A0....           STS     pWriteBuffer, R26
   \   00000034   93B0....           STS     (pWriteBuffer + 1), R27
     85              WriteCount = Size;
   \   00000038   9240....           STS     WriteCount, R4
     86              EEAR = Address ;
   \   0000003C   BD92               OUT     0x22, R25
   \   0000003E   BD81               OUT     0x21, R24
     87              EEDR = *pData ;
   \   00000040   910C               LD      R16, X
   \   00000042   BD00               OUT     0x20, R16
     88              pWriteBuffer++;
   \   00000044   9100....           LDS     R16, pWriteBuffer
   \   00000048   9110....           LDS     R17, (pWriteBuffer + 1)
   \   0000004C   5F0F               SUBI    R16, 255
   \   0000004E   4F1F               SBCI    R17, 255
   \   00000050   9300....           STS     pWriteBuffer, R16
   \   00000054   9310....           STS     (pWriteBuffer + 1), R17
     89              EEPWriteOK = false;
   \   00000058   E000               LDI     R16, 0
   \   0000005A   9300....           STS     EEPWriteOK, R16
     90              EECR |= (1 << EEMPE) ;       // Don't use SetBit macrod due to timing
   \   0000005E   9AFA               SBI     0x1F, 0x02
     91              EECR |= (1 << EEPE) ;        // Don't use SetBit macrod due to timing
   \   00000060   9AF9               SBI     0x1F, 0x01
     92              EECR |= (1 << EERIE) ;       // Don't use SetBit macrod due to timing
   \   00000062   9AFB               SBI     0x1F, 0x03
     93              OS_DecRI();
   \   00000064   9100....           LDS     R16, (OS_Counters + 1)
   \   00000068   7F00               ANDI    R16, 0xF0
   \   0000006A   F021               BREQ    ??WriteEEPROMBuffer_2
   \   0000006C   E909               LDI     R16, 153
   \   0000006E   E010               LDI     R17, 0
   \   00000070   ........           CALL    OS_Error
   \                     ??WriteEEPROMBuffer_2:
   \   00000074   9100....           LDS     R16, (OS_Counters + 1)
   \   00000078   950A               DEC     R16
   \   0000007A   9300....           STS     (OS_Counters + 1), R16
   \   0000007E   F409               BRNE    ??WriteEEPROMBuffer_3
   \   00000080   9478               SEI
     94          }
   \                     ??WriteEEPROMBuffer_3:
   \   00000082                      REQUIRE ?Subroutine0
   \   00000082                      REQUIRE _A_EECR
   \   00000082                      REQUIRE _A_EEAR
   \   00000082                      REQUIRE _A_EEDR
   \   00000082                      ;               // Fall through to label ?Subroutine0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9049               LD      R4, Y+
   \   0000000A   9508               RET
     95          

   \                                 In  segment CODE, align 2, keep-with-next
     96          void
     97          WriteEEPROMBufferSync( unsigned int Address, char Size, char *pData )
   \                     WriteEEPROMBufferSync:
     98          {   
   \   00000000   924A               ST      -Y, R4
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000A   01C8               MOVW    R25:R24, R17:R16
   \   0000000C   2E42               MOV     R4, R18
   \   0000000E   01DA               MOVW    R27:R26, R21:R20
     99            while (EECR & (1<<EEPE))     // Wait until ready
   \                     ??WriteEEPROMBufferSync_0:
   \   00000010   99F9               SBIC    0x1F, 0x01
   \   00000012   CFFE               RJMP    ??WriteEEPROMBufferSync_0
    100              ;
    101          
    102            OS_IncDI();
   \   00000014   9100....           LDS     R16, (OS_Counters + 1)
   \   00000018   7F00               ANDI    R16, 0xF0
   \   0000001A   F021               BREQ    ??WriteEEPROMBufferSync_1
   \   0000001C   E909               LDI     R16, 153
   \   0000001E   E010               LDI     R17, 0
   \   00000020   ........           CALL    OS_Error
   \                     ??WriteEEPROMBufferSync_1:
   \   00000024   94F8               CLI
   \   00000026   9100....           LDS     R16, (OS_Counters + 1)
   \   0000002A   9503               INC     R16
   \   0000002C   9300....           STS     (OS_Counters + 1), R16
    103            pWriteBuffer = pData;
   \   00000030   93A0....           STS     pWriteBuffer, R26
   \   00000034   93B0....           STS     (pWriteBuffer + 1), R27
    104            WriteCount = Size;
   \   00000038   9240....           STS     WriteCount, R4
    105            EEAR = Address ;
   \   0000003C   BD92               OUT     0x22, R25
   \   0000003E   BD81               OUT     0x21, R24
    106            EEDR = *pData ;
   \   00000040   910C               LD      R16, X
   \   00000042   BD00               OUT     0x20, R16
    107            pWriteBuffer++;
   \   00000044   9100....           LDS     R16, pWriteBuffer
   \   00000048   9110....           LDS     R17, (pWriteBuffer + 1)
   \   0000004C   5F0F               SUBI    R16, 255
   \   0000004E   4F1F               SBCI    R17, 255
   \   00000050   9300....           STS     pWriteBuffer, R16
   \   00000054   9310....           STS     (pWriteBuffer + 1), R17
    108            EEPWriteOK = false;
   \   00000058   E000               LDI     R16, 0
   \   0000005A   9300....           STS     EEPWriteOK, R16
    109            EECR |= (1 << EEMPE) ;       // Don't use SetBit macrod due to timing
   \   0000005E   9AFA               SBI     0x1F, 0x02
    110            EECR |= (1 << EEPE) ;        // Don't use SetBit macrod due to timing
   \   00000060   9AF9               SBI     0x1F, 0x01
    111          
    112            EECR |= (1 << EERIE) ;       // Don't use SetBit macrod due to timing
   \   00000062   9AFB               SBI     0x1F, 0x03
    113            OS_DecRI();
   \   00000064   9100....           LDS     R16, (OS_Counters + 1)
   \   00000068   7F00               ANDI    R16, 0xF0
   \   0000006A   F021               BREQ    ??WriteEEPROMBufferSync_2
   \   0000006C   E909               LDI     R16, 153
   \   0000006E   E010               LDI     R17, 0
   \   00000070   ........           CALL    OS_Error
   \                     ??WriteEEPROMBufferSync_2:
   \   00000074   9100....           LDS     R16, (OS_Counters + 1)
   \   00000078   950A               DEC     R16
   \   0000007A   9300....           STS     (OS_Counters + 1), R16
   \   0000007E   F409               BRNE    ??WriteEEPROMBufferSync_3
   \   00000080   9478               SEI
    114          
    115            do
    116            {
    117              OS_Delay(1);
   \                     ??WriteEEPROMBufferSync_3:
   \   00000082   E001               LDI     R16, 1
   \   00000084   E010               LDI     R17, 0
   \   00000086   ........           CALL    OS_Delay
    118            }while (!EEPWriteOK);
   \   0000008A   9100....           LDS     R16, EEPWriteOK
   \   0000008E   2300               TST     R16
   \   00000090   F3C1               BREQ    ??WriteEEPROMBufferSync_3
    119          }
   \   00000092   ....               RJMP    ?Subroutine0
   \   00000094                      REQUIRE _A_EECR
   \   00000094                      REQUIRE _A_EEAR
   \   00000094                      REQUIRE _A_EEDR
    120          
    121          /*---------------------------------------------------------------------------
    122          **
    123          **  Interrupt on EEPROM write
    124          **
    125          **--------------------------------------------------------------------------*/
    126          #pragma vector=EE_READY_vect

   \                                 In  segment CODE, align 2, keep-with-next
    127          __interrupt void IntHandler_EEPROM( void ){
   \                     IntHandler_EEPROM:
   \   00000000   93FA               ST      -Y, R31
   \   00000002   93EA               ST      -Y, R30
   \   00000004   932A               ST      -Y, R18
   \   00000006   931A               ST      -Y, R17
   \   00000008   930A               ST      -Y, R16
   \   0000000A   B72F               IN      R18, 0x3F
    128          
    129              if ( --WriteCount ) {                        // More to write? 
   \   0000000C   9100....           LDS     R16, WriteCount
   \   00000010   950A               DEC     R16
   \   00000012   9300....           STS     WriteCount, R16
   \   00000016   2300               TST     R16
   \   00000018   F0C9               BREQ    ??IntHandler_EEPROM_0
    130                  EEAR++;                                  // Define address and data 
   \   0000001A   B501               IN      R16, 0x21
   \   0000001C   B512               IN      R17, 0x22
   \   0000001E   5F0F               SUBI    R16, 255
   \   00000020   4F1F               SBCI    R17, 255
   \   00000022   BD12               OUT     0x22, R17
   \   00000024   BD01               OUT     0x21, R16
    131                  EEDR = *pWriteBuffer++;
   \   00000026   91E0....           LDS     R30, pWriteBuffer
   \   0000002A   91F0....           LDS     R31, (pWriteBuffer + 1)
   \   0000002E   8100               LD      R16, Z
   \   00000030   BD00               OUT     0x20, R16
   \   00000032   9100....           LDS     R16, pWriteBuffer
   \   00000036   9110....           LDS     R17, (pWriteBuffer + 1)
   \   0000003A   5F0F               SUBI    R16, 255
   \   0000003C   4F1F               SBCI    R17, 255
   \   0000003E   9300....           STS     pWriteBuffer, R16
   \   00000042   9310....           STS     (pWriteBuffer + 1), R17
    132                  EECR |= (1 << EEMPE) ;       // Don't use SetBit macrod due to timing
   \   00000046   9AFA               SBI     0x1F, 0x02
    133                  EECR |= (1 << EEPE) ;        // Don't use SetBit macrod due to timing
   \   00000048   9AF9               SBI     0x1F, 0x01
   \   0000004A   C004               RJMP    ??IntHandler_EEPROM_1
    134              } else {
    135                  EECR &= ~(1 << EERIE) ;       // Don't use ClrBit macrod due to timing
   \                     ??IntHandler_EEPROM_0:
   \   0000004C   98FB               CBI     0x1F, 0x03
    136                  EEPWriteOK = true;
   \   0000004E   E001               LDI     R16, 1
   \   00000050   9300....           STS     EEPWriteOK, R16
    137              }
    138          }
   \                     ??IntHandler_EEPROM_1:
   \   00000054   BF2F               OUT     0x3F, R18
   \   00000056   9109               LD      R16, Y+
   \   00000058   9119               LD      R17, Y+
   \   0000005A   9129               LD      R18, Y+
   \   0000005C   91E9               LD      R30, Y+
   \   0000005E   91F9               LD      R31, Y+
   \   00000060   9518               RETI
   \   00000062                      REQUIRE _A_EEAR
   \   00000062                      REQUIRE _A_EEDR
   \   00000062                      REQUIRE _A_EECR
    139          
    140          
    141          /**===========================================================================
    142          ** Get the stored version in EEPROM
    143          **==========================================================================*/ 

   \                                 In  segment CODE, align 2, keep-with-next
    144          char EEPROMVersion(void) {
   \                     EEPROMVersion:
   \   00000000   938A               ST      -Y, R24
    145              char val ;
    146              char retval = false;
   \   00000002   E080               LDI     R24, 0
    147          
    148              ReadEEPROMBuffer(EEPROM_ID_START, 1, (char*)&val) ;
   \   00000004   E000               LDI     R16, 0
   \   00000006   E010               LDI     R17, 0
   \   00000008   ....               RCALL   ReadEEPROMByte
    149              if (val == EEPROM_ID) {                                     //correct EEPROM ID
   \   0000000A   3B0D               CPI     R16, 189
   \   0000000C   F459               BRNE    ??EEPROMVersion_0
    150                  ReadEEPROMBuffer(EEPROM_ID_START+1, 1, (char*)&val) ;
   \   0000000E   E001               LDI     R16, 1
   \   00000010   E010               LDI     R17, 0
   \   00000012   ....               RCALL   ReadEEPROMByte
    151                  if (val == STORE_VERSION) {                             // and version
   \   00000014   3002               CPI     R16, 2
   \   00000016   F431               BRNE    ??EEPROMVersion_0
    152                      ReadEEPROMBuffer(0xffe, 1, (char*)&val) ;
   \   00000018   EF0E               LDI     R16, 254
   \   0000001A   E01F               LDI     R17, 15
   \   0000001C   ....               RCALL   ReadEEPROMByte
    153                      if (val == EEPROM_OK) {                             // and no reset from user
   \   0000001E   3F0F               CPI     R16, 255
   \   00000020   F409               BRNE    ??EEPROMVersion_0
    154                          retval = true ;                                 // then everything is OK
   \   00000022   E081               LDI     R24, 1
    155                      }
    156                  }
    157              }
    158              return retval;
   \                     ??EEPROMVersion_0:
   \   00000024   2F08               MOV     R16, R24
   \   00000026   9189               LD      R24, Y+
   \   00000028   9508               RET
    159          }
    160          
    161          /**===========================================================================
    162          ** Reset the EEPROM
    163          **==========================================================================*/ 

   \                                 In  segment CODE, align 2, keep-with-next
    164          void EEPROMReset(void) {
   \                     EEPROMReset:
    165              EEARL = (0x0ffe & 0xff);
   \   00000000   EF0E               LDI     R16, 254
   \   00000002   BD01               OUT     0x21, R16
    166              EEARH = (0x0ffe >> 8);
   \   00000004   E00F               LDI     R16, 15
   \   00000006   BD02               OUT     0x22, R16
    167              EEDR = EEPROM_RESET;
   \   00000008   ED0B               LDI     R16, 219
   \   0000000A   BD00               OUT     0x20, R16
    168              EECR |= (1<<EEMPE);
   \   0000000C   9AFA               SBI     0x1F, 0x02
    169              EECR |= (1<<EEPE);
   \   0000000E   9AF9               SBI     0x1F, 0x01
    170              while (EECR & (1<<EEPE))
   \                     ??EEPROMReset_0:
   \   00000010   99F9               SBIC    0x1F, 0x01
   \   00000012   CFFE               RJMP    ??EEPROMReset_0
    171                  ;
    172              WDTCSR = 0x18;               //Start watchdog to genetate restart
   \   00000014   E108               LDI     R16, 24
   \   00000016   9300....           STS     _A_WDTCSR, R16
    173              WDTCSR = 0x18;
   \   0000001A   9300....           STS     _A_WDTCSR, R16
    174          }
   \   0000001E   9508               RET
   \   00000020                      REQUIRE _A_EEAR
   \   00000020                      REQUIRE _A_EEDR
   \   00000020                      REQUIRE _A_EECR
   \   00000020                      REQUIRE _A_WDTCSR

   \                                 In  segment INTVEC, offset 0x78, root
   \                     `??IntHandler_EEPROM::??INTVEC 120`:
   \   00000078   ........           JMP     IntHandler_EEPROM

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   EEPROMReset
      1      2   EEPROMVersion
        1      2   -> ReadEEPROMByte
      5      2   IntHandler_EEPROM
      6      2   ReadEEPROMBuffer
        6      2   -> OS_Error
      2      2   ReadEEPROMByte
        2      2   -> OS_Error
      0      2   TestEEPROM
      5      2   WriteEEPROMBuffer
        5      2   -> OS_Error
      5      2   WriteEEPROMBufferSync
        5      2   -> OS_Delay
        5      2   -> OS_Error
      3      2   WriteEEPROMByte
        3      2   -> OS_Error


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?Subroutine0
      32  EEPROMReset
      42  EEPROMVersion
      98  IntHandler_EEPROM
       4  IntHandler_EEPROM::??INTVEC 120
     122  ReadEEPROMBuffer
      82  ReadEEPROMByte
       6  TestEEPROM
     130  WriteEEPROMBuffer
     148  WriteEEPROMBufferSync
      90  WriteEEPROMByte
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_WDTCSR

 
   5 bytes in segment ABSOLUTE
 762 bytes in segment CODE
   4 bytes in segment INTVEC
 
 762 bytes of CODE memory (+ 4 bytes shared)
   0 bytes of DATA memory (+ 5 bytes shared)

Errors: none
Warnings: none
