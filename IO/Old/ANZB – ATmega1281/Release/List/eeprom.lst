###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       19/Dec/2022  14:35:47
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\ANZB – ATmega1281\Src\eeprom.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW48EB.tmp ("D:\S2Prog\IO\ANZB –
#        ATmega1281\Src\eeprom.c" --cpu=m1281 -ms -o "D:\S2Prog\IO\ANZB –
#        ATmega1281\Release\Obj" -D OS_LIBMODE_S -D OS_UART=-1 -lCN
#        "D:\S2Prog\IO\ANZB – ATmega1281\Release\List" -y
#        --initializers_in_flash --no_tbaa --enable_external_bus
#        -DENABLE_BIT_DEFINITIONS -e -I "D:\S2Prog\IO\ANZB – ATmega1281\INC\\"
#        -I "D:\S2Prog\IO\ANZB – ATmega1281\..\..\SHARED\INC\\" --eeprom_size
#        4096 --clib -Oh)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\ANZB – ATmega1281\Release\List\eeprom.lst
#    Object file  =  D:\S2Prog\IO\ANZB – ATmega1281\Release\Obj\eeprom.r90
#
###############################################################################

D:\S2Prog\IO\ANZB – ATmega1281\Src\eeprom.c
      1          /****************************************************************************************
      2          / Read and write the eeprom
      3          /
      4          ***************************************************************************************/
      5          #include "iom1281.h"

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          
     12          
     13          /*---------------------------------------------------------------------------
     14          **
     15          **  See how many date i remining
     16          **
     17          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     18          char TestEEPROM( void ) {
   \                     TestEEPROM:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     19          
     20              return WriteCount;
   \   00000000   9100....           LDS     R16, WriteCount
   \   00000004   9508               RET
     21          }
     22          
     23          /*---------------------------------------------------------------------------
     24          **
     25          **  Reads an address in the eeprom
     26          **
     27          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     28          char ReadEEPROMByte( unsigned int Address ) {
   \                     ReadEEPROMByte:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     29          #if 0
     30              unsigned char Data;
     31          
     32              while (EECR & (1<<EEPE))     // Wait until ready
     33                  ;
     34              EEAR = Address;
     35              OS_IncDI();
     36              EECR |= (1 << EERE) ;       // Don't use MB_SetBit macrod due to timing
     37              OS_DecRI();
     38          
     39              Data = EEDR;
     40              return Data;
     41          #else
     42              return 0;
   \   00000000   E000               LDI     R16, 0
   \   00000002   9508               RET
     43          #endif
     44          }
     45          
     46          /*---------------------------------------------------------------------------
     47          **
     48          **  Write a caracther to the eeprom
     49          **
     50          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     51          void WriteEEPROMByte( unsigned int Address, char Data ) {   
   \                     WriteEEPROMByte:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     52          #if 0
     53              while (EECR & (1<<EEPE))     // Wait until ready
     54                  ;
     55              OS_IncDI();
     56              EEAR = Address;
     57              EEDR = Data;
     58              EECR |= (1 << EEMPE) ;       // Don't use MB_SetBit macrod due to timing
     59              EECR |= (1 << EEPE) ;        // Don't use MB_SetBit macrod due to timing
     60              OS_DecRI();
     61          #else
     62          #endif
     63          }
   \   00000000   9508               RET
     64          
     65          /*---------------------------------------------------------------------------
     66          **
     67          **  Read a tring from the eeprom
     68          **
     69          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     70          void ReadEEPROMBuffer( unsigned int Address, char Size, char *pData ) {   
   \                     ReadEEPROMBuffer:
   \   00000000   2F39               MOV     R19, R25
   \   00000002   2F68               MOV     R22, R24
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
     71              unsigned int Index;
     72          
     73              for ( Index = 0; Index < Size; Index++ ) {
   \   00000004   2322               TST     R18
   \   00000006   F041               BREQ    ??ReadEEPROMBuffer_0
   \   00000008   2F82               MOV     R24, R18
   \   0000000A   E090               LDI     R25, 0
   \   0000000C   E000               LDI     R16, 0
     74                  *pData++ = ReadEEPROMByte( Address + Index );
   \                     ??ReadEEPROMBuffer_1:
   \   0000000E   01FA               MOVW    R31:R30, R21:R20
   \   00000010   9301               ST      Z+, R16
   \   00000012   01AF               MOVW    R21:R20, R31:R30
   \   00000014   9701               SBIW    R25:R24, 1
   \   00000016   F7D9               BRNE    ??ReadEEPROMBuffer_1
     75              }
     76          }
   \                     ??ReadEEPROMBuffer_0:
   \   00000018   2F86               MOV     R24, R22
   \   0000001A   2F93               MOV     R25, R19
   \   0000001C   9508               RET
     77          
     78          /*---------------------------------------------------------------------------
     79          **
     80          **  Writ buffer to eeprom
     81          **
     82          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     83          void WriteEEPROMBuffer( unsigned int Address, char Size, char *pData ) {   
   \                     WriteEEPROMBuffer:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     84          #if 0
     85              while (EECR & (1<<EEPE))     // Wait until ready
     86                  ;
     87              OS_IncDI();
     88              pWriteBuffer = pData;
     89              WriteCount = Size;
     90              EEAR = Address ;
     91              EEDR = *pData ;
     92              pWriteBuffer++;
     93              EEPWriteOK = false;
     94              EECR |= (1 << EEMPE) ;       // Don't use MB_SetBit macrod due to timing
     95              EECR |= (1 << EEPE) ;        // Don't use MB_SetBit macrod due to timing
     96              EECR |= (1 << EERIE) ;       // Don't use MB_SetBit macrod due to timing
     97              OS_DecRI();
     98          #endif
     99          }
   \   00000000   9508               RET
    100          
    101          /*---------------------------------------------------------------------------
    102          **
    103          **  Interrupt on EEPROM write
    104          **
    105          **--------------------------------------------------------------------------*/
    106          #pragma vector=EE_READY_vect

   \                                 In  segment CODE, align 2, keep-with-next
    107          __interrupt void IntHandler_EEPROM( void ){
   \                     IntHandler_EEPROM:
   \   00000000   93FA               ST      -Y, R31
   \   00000002   93EA               ST      -Y, R30
   \   00000004   932A               ST      -Y, R18
   \   00000006   931A               ST      -Y, R17
   \   00000008   930A               ST      -Y, R16
   \   0000000A   B72F               IN      R18, 0x3F
   \   0000000C                      REQUIRE __RSTACK_in_external_ram_new_way
    108          
    109              if ( --WriteCount ) {                        // More to write? 
   \   0000000C   9100....           LDS     R16, WriteCount
   \   00000010   950A               DEC     R16
   \   00000012   9300....           STS     WriteCount, R16
   \   00000016   2300               TST     R16
   \   00000018   F0C9               BREQ    ??IntHandler_EEPROM_0
    110                  EEAR++;                                  // Define address and data 
   \   0000001A   B501               IN      R16, 0x21
   \   0000001C   B512               IN      R17, 0x22
   \   0000001E   5F0F               SUBI    R16, 255
   \   00000020   4F1F               SBCI    R17, 255
   \   00000022   BD12               OUT     0x22, R17
   \   00000024   BD01               OUT     0x21, R16
    111                  EEDR = *pWriteBuffer++;
   \   00000026   91E0....           LDS     R30, pWriteBuffer
   \   0000002A   91F0....           LDS     R31, (pWriteBuffer + 1)
   \   0000002E   8100               LD      R16, Z
   \   00000030   BD00               OUT     0x20, R16
   \   00000032   9100....           LDS     R16, pWriteBuffer
   \   00000036   9110....           LDS     R17, (pWriteBuffer + 1)
   \   0000003A   5F0F               SUBI    R16, 255
   \   0000003C   4F1F               SBCI    R17, 255
   \   0000003E   9300....           STS     pWriteBuffer, R16
   \   00000042   9310....           STS     (pWriteBuffer + 1), R17
    112                  EECR |= (1 << EEMPE) ;       // Don't use MB_SetBit macrod due to timing
   \   00000046   9AFA               SBI     0x1F, 0x02
    113                  EECR |= (1 << EEPE) ;        // Don't use MB_SetBit macrod due to timing
   \   00000048   9AF9               SBI     0x1F, 0x01
   \   0000004A   C004               RJMP    ??IntHandler_EEPROM_1
    114              } else {
    115                  EECR &= ~(1 << EERIE) ;       // Don't use ClrBit macrod due to timing
   \                     ??IntHandler_EEPROM_0:
   \   0000004C   98FB               CBI     0x1F, 0x03
    116                  EEPWriteOK = true;
   \   0000004E   E001               LDI     R16, 1
   \   00000050   9300....           STS     EEPWriteOK, R16
    117              }
    118          }
   \                     ??IntHandler_EEPROM_1:
   \   00000054   BF2F               OUT     0x3F, R18
   \   00000056   9109               LD      R16, Y+
   \   00000058   9119               LD      R17, Y+
   \   0000005A   9129               LD      R18, Y+
   \   0000005C   91E9               LD      R30, Y+
   \   0000005E   91F9               LD      R31, Y+
   \   00000060   9518               RETI
   \   00000062                      REQUIRE _A_EEAR
   \   00000062                      REQUIRE _A_EEDR
   \   00000062                      REQUIRE _A_EECR
    119          
    120          
    121          /**===========================================================================
    122          ** Get the stored version in EEPROM
    123          **==========================================================================*/ 

   \                                 In  segment CODE, align 2, keep-with-next
    124          char EEPROMVersion(void) {
   \                     EEPROMVersion:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    125          #if 0
    126              char val ;
    127              char retval = false;
    128          
    129              ReadEEPROMBuffer(EEPROM_ID_START, 1, (char*)&val) ;
    130              if (val == EEPROM_ID) {                                     //correct EEPROM ID
    131                  ReadEEPROMBuffer(EEPROM_ID_START+1, 1, (char*)&val) ;
    132                  if (val == STORE_VERSION) {                             // and version
    133                      ReadEEPROMBuffer(0xffe, 1, (char*)&val) ;
    134                      if (val == EEPROM_OK) {                             // and no reset from user
    135                          retval = true ;                                 // then everything is OK
    136                      }
    137                  }
    138              }
    139              return retval;
    140          #else
    141              return 0;
   \   00000000   E000               LDI     R16, 0
   \   00000002   9508               RET
    142          #endif
    143          }
    144          
    145          /**===========================================================================
    146          ** Reset the EEPROM
    147          **==========================================================================*/ 

   \                                 In  segment CODE, align 2, keep-with-next
    148          void EEPROMReset(void) {
   \                     EEPROMReset:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    149          #if 0
    150              EEARL = (0x0ffe & 0xff);
    151              EEARH = (0x0ffe >> 8);
    152              EEDR = EEPROM_RESET;
    153              EECR |= (1<<EEMPE);
    154              EECR |= (1<<EEPE);
    155              while (EECR & (1<<EEPE))
    156                  ;
    157              WDTCSR = 0x18;               //Start watchdog to genetate restart
    158              WDTCSR = 0x18;
    159          #endif
    160          }
   \   00000000   9508               RET

   \                                 In  segment INTVEC, offset 0x78, root
   \                     `??IntHandler_EEPROM::??INTVEC 120`:
   \   00000078   ........           JMP     IntHandler_EEPROM

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   EEPROMReset
      0      2   EEPROMVersion
      5      2   IntHandler_EEPROM
      0      2   ReadEEPROMBuffer
      0      2   ReadEEPROMByte
      0      2   TestEEPROM
      0      2   WriteEEPROMBuffer
      0      2   WriteEEPROMByte


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  EEPROMReset
       4  EEPROMVersion
      98  IntHandler_EEPROM
       4  IntHandler_EEPROM::??INTVEC 120
      30  ReadEEPROMBuffer
       4  ReadEEPROMByte
       6  TestEEPROM
       2  WriteEEPROMBuffer
       2  WriteEEPROMByte
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR

 
   4 bytes in segment ABSOLUTE
 148 bytes in segment CODE
   4 bytes in segment INTVEC
 
 148 bytes of CODE memory (+ 4 bytes shared)
   0 bytes of DATA memory (+ 4 bytes shared)

Errors: none
Warnings: none
