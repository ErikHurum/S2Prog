###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       23/Jan/2023  12:55:32
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\ANZB_Bootloader – 1280\Src\serial.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWE56A.tmp
#        ("D:\S2Prog\IO\ANZB_Bootloader – 1280\Src\serial.c" --cpu=m1280 -ms -o
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\Debug\Obj" -D SPEED=38400 -lCN
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\Debug\List" -y
#        --initializers_in_flash --no_cse --no_inline --no_code_motion
#        --no_cross_call --no_clustering --no_tbaa --debug
#        -DENABLE_BIT_DEFINITIONS -e -I "D:\S2Prog\IO\ANZB_Bootloader –
#        1280\INC\\" -I "D:\S2Prog\IO\ANZB_Bootloader –
#        1280\..\..\SHARED\INC\\" --eeprom_size 4096 --clib -On)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\ANZB_Bootloader – 1280\Debug\List\serial.lst
#    Object file  =  D:\S2Prog\IO\ANZB_Bootloader – 1280\Debug\Obj\serial.r90
#
###############################################################################

D:\S2Prog\IO\ANZB_Bootloader – 1280\Src\serial.c
      1          //#include "iom1280.h"
      2          #include "stdio.h"
      3          //#include "math.h"
      4          #include "externals.h"

   \                                 In  segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2c
   \   union <unnamed> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1
      5          

   \                                 In  segment CODE, align 2, keep-with-next
      6          void sendchar(char c){
   \                     sendchar:
      7              UART_DATA_REG0 = c;                                   // prepare transmission
   \   00000000   B90C               OUT     0x0C, R16
      8              while (!(UART_STATUS_REG0 & (1 << TRANSMIT_COMPLETE_BIT0)));// wait until byte sendt
   \                     ??sendchar_0:
   \   00000002   9B5E               SBIS    0x0B, 0x06
   \   00000004   CFFE               RJMP    ??sendchar_0
      9              UART_STATUS_REG0 |= (1 << TRANSMIT_COMPLETE_BIT0);          // delete TXCflag
   \   00000006   9A5E               SBI     0x0B, 0x06
     10          }
   \   00000008   9508               RET
   \   0000000A                      REQUIRE _A_UDR0
   \   0000000A                      REQUIRE _A_UCSR0A
     11          
     12          

   \                                 In  segment CODE, align 2, keep-with-next
     13          void recchar(void){
   \                     recchar:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
     14            if((UART_STATUS_REG0 & (1 << RECEIVE_COMPLETE_BIT0)) ||(UART_STATUS_REG0 & 0x10)){
   \   00000004   995F               SBIC    0x0B, 0x07
   \   00000006   C002               RJMP    ??recchar_0
   \   00000008   9B5C               SBIS    0x0B, 0x04
   \   0000000A   C072               RJMP    ??recchar_1
     15              My485UART.pRxBuffer[ My485UART.RxFirst ] = UART_DATA_REG0;                     // Read the character 
   \                     ??recchar_0:
   \   0000000C   B10C               IN      R16, 0x0C
   \   0000000E   ....               LDI     R26, LOW((My485UART + 12))
   \   00000010   ....               LDI     R27, HIGH((My485UART + 12))
   \   00000012   91ED               LD      R30, X+
   \   00000014   91FC               LD      R31, X
   \   00000016   9711               SBIW    R27:R26, 1
   \   00000018   ....               LDI     R26, LOW((My485UART + 14))
   \   0000001A   ....               LDI     R27, HIGH((My485UART + 14))
   \   0000001C   912D               LD      R18, X+
   \   0000001E   913C               LD      R19, X
   \   00000020   9711               SBIW    R27:R26, 1
   \   00000022   0FE2               ADD     R30, R18
   \   00000024   1FF3               ADC     R31, R19
   \   00000026   8300               ST      Z, R16
     16              if (My485UART.RxState != HANDLE) {        // ok to receive? 
   \   00000028   9100....           LDS     R16, (My485UART + 20)
   \   0000002C   300A               CPI     R16, 10
   \   0000002E   F409               BRNE    $+2+2
   \   00000030   C05F               RJMP    ??recchar_1
     17                  switch (My485UART.RxState) {                   // Yes, check state
   \   00000032   9100....           LDS     R16, (My485UART + 20)
   \   00000036   2300               TST     R16
   \   00000038   F009               BREQ    $+2+2
   \   0000003A   C045               RJMP    ??recchar_2
     18                  case SYNC :
     19                      if ( My485UART.pRxBuffer[ My485UART.RxFirst ] == ANPRO10_SYN) {
   \   0000003C   ....               LDI     R26, LOW((My485UART + 12))
   \   0000003E   ....               LDI     R27, HIGH((My485UART + 12))
   \   00000040   91ED               LD      R30, X+
   \   00000042   91FC               LD      R31, X
   \   00000044   9711               SBIW    R27:R26, 1
   \   00000046   ....               LDI     R26, LOW((My485UART + 14))
   \   00000048   ....               LDI     R27, HIGH((My485UART + 14))
   \   0000004A   910D               LD      R16, X+
   \   0000004C   911C               LD      R17, X
   \   0000004E   9711               SBIW    R27:R26, 1
   \   00000050   0FE0               ADD     R30, R16
   \   00000052   1FF1               ADC     R31, R17
   \   00000054   8100               LD      R16, Z
   \   00000056   3106               CPI     R16, 22
   \   00000058   F461               BRNE    ??recchar_3
     20                          My485UART.SyncCnt ++ ;                 // count sync
   \   0000005A   9100....           LDS     R16, (My485UART + 21)
   \   0000005E   9503               INC     R16
   \   00000060   9300....           STS     (My485UART + 21), R16
     21                          My485UART.RxFirst = 0;                 // start at start of buff
   \   00000064   ....               LDI     R30, LOW(My485UART)
   \   00000066   ....               LDI     R31, (My485UART) >> 8
   \   00000068   E000               LDI     R16, 0
   \   0000006A   8706               STD     Z+14, R16
   \   0000006C   E000               LDI     R16, 0
   \   0000006E   8707               STD     Z+15, R16
   \   00000070   C03F               RJMP    ??recchar_1
     22                      } else if ((My485UART.SyncCnt >= 2) && 
     23                                 (My485UART.pRxBuffer[ My485UART.RxFirst ] == ANPRO10_SOH)) {       // minimum two sync bytes
   \                     ??recchar_3:
   \   00000072   9100....           LDS     R16, (My485UART + 21)
   \   00000076   3002               CPI     R16, 2
   \   00000078   F110               BRCS    ??recchar_4
   \   0000007A   ....               LDI     R26, LOW((My485UART + 12))
   \   0000007C   ....               LDI     R27, HIGH((My485UART + 12))
   \   0000007E   91ED               LD      R30, X+
   \   00000080   91FC               LD      R31, X
   \   00000082   9711               SBIW    R27:R26, 1
   \   00000084   ....               LDI     R26, LOW((My485UART + 14))
   \   00000086   ....               LDI     R27, HIGH((My485UART + 14))
   \   00000088   910D               LD      R16, X+
   \   0000008A   911C               LD      R17, X
   \   0000008C   9711               SBIW    R27:R26, 1
   \   0000008E   0FE0               ADD     R30, R16
   \   00000090   1FF1               ADC     R31, R17
   \   00000092   8100               LD      R16, Z
   \   00000094   3001               CPI     R16, 1
   \   00000096   F499               BRNE    ??recchar_4
     24                          My485UART.SyncCnt = 0 ;                // reset counter
   \   00000098   E000               LDI     R16, 0
   \   0000009A   9300....           STS     (My485UART + 21), R16
     25                          My485UART.RxState = HEADER ;
   \   0000009E   E001               LDI     R16, 1
   \   000000A0   9300....           STS     (My485UART + 20), R16
     26                          My485UART.RxLast = 0 ;
   \   000000A4   ....               LDI     R30, LOW(My485UART)
   \   000000A6   ....               LDI     R31, (My485UART) >> 8
   \   000000A8   E000               LDI     R16, 0
   \   000000AA   8B00               STD     Z+16, R16
   \   000000AC   E000               LDI     R16, 0
   \   000000AE   8B01               STD     Z+17, R16
     27                          My485UART.RxTimeout = RX_TO_TIME ;   // reset timeout
   \   000000B0   ....               LDI     R30, LOW(My485UART)
   \   000000B2   ....               LDI     R31, (My485UART) >> 8
   \   000000B4   EF0A               LDI     R16, 250
   \   000000B6   E010               LDI     R17, 0
   \   000000B8   8B06               STD     Z+22, R16
   \   000000BA   8B17               STD     Z+23, R17
   \   000000BC   C019               RJMP    ??recchar_1
     28                      } else {
     29                          My485UART.SyncCnt = 0 ;                // start over once more
   \                     ??recchar_4:
   \   000000BE   E000               LDI     R16, 0
   \   000000C0   9300....           STS     (My485UART + 21), R16
     30                      }
     31                      break;
   \   000000C4   C015               RJMP    ??recchar_1
     32                  default :
     33                      if ((++My485UART.RxFirst) > RXSIZE_UART) { // Point to next location
   \                     ??recchar_2:
   \   000000C6   ....               LDI     R30, LOW(My485UART)
   \   000000C8   ....               LDI     R31, (My485UART) >> 8
   \   000000CA   8506               LDD     R16, Z+14
   \   000000CC   8517               LDD     R17, Z+15
   \   000000CE   5F0F               SUBI    R16, 255
   \   000000D0   4F1F               SBCI    R17, 255
   \   000000D2   8706               STD     Z+14, R16
   \   000000D4   8717               STD     Z+15, R17
   \   000000D6   ....               LDI     R30, LOW(My485UART)
   \   000000D8   ....               LDI     R31, (My485UART) >> 8
   \   000000DA   8506               LDD     R16, Z+14
   \   000000DC   8517               LDD     R17, Z+15
   \   000000DE   350F               CPI     R16, 95
   \   000000E0   E021               LDI     R18, 1
   \   000000E2   0712               CPC     R17, R18
   \   000000E4   F018               BRCS    ??recchar_5
     34                          GoToSyncUART() ;                       // go to sync mode
   \   000000E6   ........           CALL    GoToSyncUART
   \   000000EA   C002               RJMP    ??recchar_1
     35                      } else {
     36                          ReceivePacketUart() ;              // Check package
   \                     ??recchar_5:
   \   000000EC   ........           CALL    ReceivePacketUart
     37                      }
     38                      break ;   
     39                  }
     40              }
     41            }
     42          }
   \                     ??recchar_1:
   \   000000F0   91A9               LD      R26, Y+
   \   000000F2   91B9               LD      R27, Y+
   \   000000F4   9508               RET
   \   000000F6                      REQUIRE _A_UCSR0A
   \   000000F6                      REQUIRE _A_UDR0

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      2      2   recchar
        2      2   -> GoToSyncUART
        2      2   -> ReceivePacketUart
      0      2   sendchar


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  _A_UCSR0A
       1  _A_UDR0
     246  recchar
      10  sendchar

 
   2 bytes in segment ABSOLUTE
 256 bytes in segment CODE
 
 256 bytes of CODE memory
   0 bytes of DATA memory (+ 2 bytes shared)

Errors: none
Warnings: none
