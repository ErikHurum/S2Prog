###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       12/Dec/2022  12:54:01
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\ANZB_Bootloader – 1280\Src\serial.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWDD41.tmp
#        ("D:\S2Prog\IO\ANZB_Bootloader – 1280\Src\serial.c" --cpu=m1280 -ms -o
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\Release\Obj" -D SPEED=38400 -lC
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\Release\List" -y
#        --initializers_in_flash --no_tbaa -DENABLE_BIT_DEFINITIONS -e -I
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\INC\\" -I
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\..\..\SHARED\INC\\" --eeprom_size
#        4096 --clib -Oh)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  
#        D:\S2Prog\IO\ANZB_Bootloader – 1280\Release\List\serial.lst
#    Object file  =  D:\S2Prog\IO\ANZB_Bootloader – 1280\Release\Obj\serial.r90
#
###############################################################################

D:\S2Prog\IO\ANZB_Bootloader – 1280\Src\serial.c
      1          #include "iom128.h"

   \                                 In  segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2c
   \   union <unnamed> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9b
   \   union <unnamed> volatile __io _A_UCSR1A
   \                     _A_UCSR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9c
   \   union <unnamed> volatile __io _A_UDR1
   \                     _A_UDR1:
   \   00000000                      DS8 1
      2          #include "stdio.h"
      3          #include "math.h"
      4          #include "externals.h"
      5          

   \                                 In  segment CODE, align 2, keep-with-next
      6          void sendchar(char ch, char c){
   \                     sendchar:
      7            if (ch == 0) {
   \   00000000   2300               TST     R16
   \   00000002   F429               BRNE    ??sendchar_0
      8              UART_DATA_REG0 = c;                                   // prepare transmission
   \   00000004   B91C               OUT     0x0C, R17
      9              while (!(UART_STATUS_REG0 & (1 << TRANSMIT_COMPLETE_BIT0)));// wait until byte sendt
   \                     ??sendchar_1:
   \   00000006   9B5E               SBIS    0x0B, 0x06
   \   00000008   CFFE               RJMP    ??sendchar_1
     10              UART_STATUS_REG0 |= (1 << TRANSMIT_COMPLETE_BIT0);          // delete TXCflag
   \   0000000A   9A5E               SBI     0x0B, 0x06
   \   0000000C   9508               RET
     11            }else if (ch == 1) {
   \                     ??sendchar_0:
   \   0000000E   3001               CPI     R16, 1
   \   00000010   F459               BRNE    ??sendchar_2
     12              UART_DATA_REG1 = c;                                   // prepare transmission
   \   00000012   9310....           STS     _A_UDR1, R17
     13              while (!(UART_STATUS_REG1 & (1 << TRANSMIT_COMPLETE_BIT1)));// wait until byte sendt
   \                     ??sendchar_3:
   \   00000016   9100....           LDS     R16, _A_UCSR1A
   \   0000001A   FF06               SBRS    R16, 6
   \   0000001C   CFFC               RJMP    ??sendchar_3
     14              UART_STATUS_REG1 |= (1 << TRANSMIT_COMPLETE_BIT1);          // delete TXCflag
   \   0000001E   9100009B           LDS     R16, 155
   \   00000022   6400               ORI     R16, 0x40
   \   00000024   9300009B           STS     155, R16
     15            }  
     16          }
   \                     ??sendchar_2:
   \   00000028   9508               RET
   \   0000002A                      REQUIRE _A_UDR0
   \   0000002A                      REQUIRE _A_UCSR0A
   \   0000002A                      REQUIRE _A_UDR1
   \   0000002A                      REQUIRE _A_UCSR1A
     17          
     18          

   \                                 In  segment CODE, align 2, keep-with-next
     19          void recchar(void){
   \                     recchar:
     20            if((UART_STATUS_REG0 & (1 << RECEIVE_COMPLETE_BIT0)) ||(UART_STATUS_REG0 & 0x10)){
   \   00000000   995F               SBIC    0x0B, 0x07
   \   00000002   C002               RJMP    ??recchar_0
   \   00000004   9B5C               SBIS    0x0B, 0x04
   \   00000006   C05A               RJMP    ??recchar_1
     21              UART[0].pRxBuffer[ UART[0].RxFirst ] = UART_DATA_REG0;                     // Read the character 
   \                     ??recchar_0:
   \   00000008   B10C               IN      R16, 0x0C
   \   0000000A   91E0....           LDS     R30, (UART + 12)
   \   0000000E   91F0....           LDS     R31, (UART + 13)
   \   00000012   9120....           LDS     R18, (UART + 14)
   \   00000016   9130....           LDS     R19, (UART + 15)
   \   0000001A   0FE2               ADD     R30, R18
   \   0000001C   1FF3               ADC     R31, R19
   \   0000001E   8300               ST      Z, R16
     22              if (UART[0].RxState != HANDLE) {        // ok to receive? 
   \   00000020   9100....           LDS     R16, (UART + 20)
   \   00000024   300A               CPI     R16, 10
   \   00000026   F409               BRNE    $+2+2
   \   00000028   C049               RJMP    ??recchar_1
     23                  switch (UART[0].RxState) {                   // Yes, check state
   \   0000002A   2300               TST     R16
   \   0000002C   F5A1               BRNE    ??recchar_2
   \   0000002E   91E0....           LDS     R30, (UART + 12)
   \   00000032   91F0....           LDS     R31, (UART + 13)
   \   00000036   9100....           LDS     R16, (UART + 14)
   \   0000003A   9110....           LDS     R17, (UART + 15)
   \   0000003E   0FE0               ADD     R30, R16
   \   00000040   1FF1               ADC     R31, R17
   \   00000042   8100               LD      R16, Z
   \   00000044   3106               CPI     R16, 22
   \   00000046   F459               BRNE    ??recchar_3
     24                  case SYNC :
     25                      if ( UART[0].pRxBuffer[ UART[0].RxFirst ] == ANPRO10_SYN) {
     26                          UART[0].SyncCnt ++ ;                 // count sync
   \   00000048   9100....           LDS     R16, (UART + 21)
   \   0000004C   9503               INC     R16
   \   0000004E   9300....           STS     (UART + 21), R16
     27                          UART[0].RxFirst = 0;                 // start at start of buff
   \   00000052   E000               LDI     R16, 0
   \   00000054   9300....           STS     (UART + 14), R16
   \   00000058   9300....           STS     (UART + 15), R16
   \   0000005C   C02F               RJMP    ??recchar_1
     28                      } else if ((UART[0].SyncCnt >= 2) && 
     29                                 (UART[0].pRxBuffer[ UART[0].RxFirst ] == ANPRO10_SOH)) {       // minimum two sync bytes
   \                     ??recchar_3:
   \   0000005E   9110....           LDS     R17, (UART + 21)
   \   00000062   3012               CPI     R17, 2
   \   00000064   F0A0               BRCS    ??recchar_4
   \   00000066   3001               CPI     R16, 1
   \   00000068   F491               BRNE    ??recchar_4
     30                          UART[0].SyncCnt = 0 ;                // reset counter
   \   0000006A   E000               LDI     R16, 0
   \   0000006C   9300....           STS     (UART + 21), R16
     31                          UART[0].RxState = HEADER ;
   \   00000070   E001               LDI     R16, 1
   \   00000072   9300....           STS     (UART + 20), R16
     32                          UART[0].RxLast = 0 ;
   \   00000076   E000               LDI     R16, 0
   \   00000078   9300....           STS     (UART + 16), R16
   \   0000007C   9300....           STS     (UART + 17), R16
     33                          UART[0].RxTimeout = RX_TO_TIME ;   // reset timeout
   \   00000080   EF0A               LDI     R16, 250
   \   00000082   9300....           STS     (UART + 22), R16
   \   00000086   E000               LDI     R16, 0
   \   00000088   9300....           STS     (UART + 23), R16
   \   0000008C   C017               RJMP    ??recchar_1
     34                      } else {
     35                          UART[0].SyncCnt = 0 ;                // start over once more
   \                     ??recchar_4:
   \   0000008E   E000               LDI     R16, 0
   \   00000090   9300....           STS     (UART + 21), R16
   \   00000094   C013               RJMP    ??recchar_1
     36                      }
     37                      break;
     38                  default :
     39                      if ((++UART[0].RxFirst) > RXSIZE_UART) { // Point to next location
   \                     ??recchar_2:
   \   00000096   9100....           LDS     R16, (UART + 14)
   \   0000009A   9110....           LDS     R17, (UART + 15)
   \   0000009E   5F0F               SUBI    R16, 255
   \   000000A0   4F1F               SBCI    R17, 255
   \   000000A2   9300....           STS     (UART + 14), R16
   \   000000A6   9310....           STS     (UART + 15), R17
   \   000000AA   350F               CPI     R16, 95
   \   000000AC   4011               SBCI    R17, 1
   \   000000AE   E000               LDI     R16, 0
   \   000000B0   F018               BRCS    ??recchar_5
     40                          GoToSyncUART(0) ;                       // go to sync mode
   \   000000B2   ........           CALL    GoToSyncUART
   \   000000B6   C002               RJMP    ??recchar_1
     41                      } else {
     42                          ReceivePacketUart(0) ;              // Check package
   \                     ??recchar_5:
   \   000000B8   ........           CALL    ReceivePacketUart
     43                      }
     44                      break ;   
     45                  }
     46              }
     47            }
     48            if((UART_STATUS_REG1 & (1 << RECEIVE_COMPLETE_BIT1)) ||(UART_STATUS_REG1 & 0x10)){
   \                     ??recchar_1:
   \   000000BC   9100....           LDS     R16, _A_UCSR1A
   \   000000C0   FD07               SBRC    R16, 7
   \   000000C2   C004               RJMP    ??recchar_6
   \   000000C4   9100....           LDS     R16, _A_UCSR1A
   \   000000C8   FF04               SBRS    R16, 4
   \   000000CA   C05A               RJMP    ??recchar_7
     49              UART[1].pRxBuffer[ UART[1].RxFirst ] = UART_DATA_REG1;                     // Read the character 
   \                     ??recchar_6:
   \   000000CC   9100....           LDS     R16, _A_UDR1
   \   000000D0   91E0....           LDS     R30, (UART + 41)
   \   000000D4   91F0....           LDS     R31, (UART + 42)
   \   000000D8   9120....           LDS     R18, (UART + 43)
   \   000000DC   9130....           LDS     R19, (UART + 44)
   \   000000E0   0FE2               ADD     R30, R18
   \   000000E2   1FF3               ADC     R31, R19
   \   000000E4   8300               ST      Z, R16
     50              if (UART[1].RxState != HANDLE) {        // ok to receive? 
   \   000000E6   9100....           LDS     R16, (UART + 49)
   \   000000EA   300A               CPI     R16, 10
   \   000000EC   F409               BRNE    $+2+2
   \   000000EE   C048               RJMP    ??recchar_7
     51                  switch (UART[1].RxState) {                   // Yes, check state
   \   000000F0   2300               TST     R16
   \   000000F2   F5A1               BRNE    ??recchar_8
   \   000000F4   91E0....           LDS     R30, (UART + 41)
   \   000000F8   91F0....           LDS     R31, (UART + 42)
   \   000000FC   9100....           LDS     R16, (UART + 43)
   \   00000100   9110....           LDS     R17, (UART + 44)
   \   00000104   0FE0               ADD     R30, R16
   \   00000106   1FF1               ADC     R31, R17
   \   00000108   8100               LD      R16, Z
   \   0000010A   3106               CPI     R16, 22
   \   0000010C   F459               BRNE    ??recchar_9
     52                  case SYNC :
     53                      if ( UART[1].pRxBuffer[ UART[1].RxFirst ] == ANPRO10_SYN) {
     54                          UART[1].SyncCnt ++ ;                 // count sync
   \   0000010E   9100....           LDS     R16, (UART + 50)
   \   00000112   9503               INC     R16
   \   00000114   9300....           STS     (UART + 50), R16
     55                          UART[1].RxFirst = 0;                 // start at start of buff
   \   00000118   E000               LDI     R16, 0
   \   0000011A   9300....           STS     (UART + 43), R16
   \   0000011E   9300....           STS     (UART + 44), R16
   \   00000122   9508               RET
     56                      } else if ((UART[1].SyncCnt >= 2) && 
     57                                 (UART[1].pRxBuffer[ UART[1].RxFirst ] == ANPRO10_SOH)) {       // minimum two sync bytes
   \                     ??recchar_9:
   \   00000124   9110....           LDS     R17, (UART + 50)
   \   00000128   3012               CPI     R17, 2
   \   0000012A   F0A0               BRCS    ??recchar_10
   \   0000012C   3001               CPI     R16, 1
   \   0000012E   F491               BRNE    ??recchar_10
     58                          UART[1].SyncCnt = 0 ;                // reset counter
   \   00000130   E000               LDI     R16, 0
   \   00000132   9300....           STS     (UART + 50), R16
     59                          UART[1].RxState = HEADER ;
   \   00000136   E001               LDI     R16, 1
   \   00000138   9300....           STS     (UART + 49), R16
     60                          UART[1].RxLast = 0 ;
   \   0000013C   E000               LDI     R16, 0
   \   0000013E   9300....           STS     (UART + 45), R16
   \   00000142   9300....           STS     (UART + 46), R16
     61                          UART[1].RxTimeout = RX_TO_TIME ;   // reset timeout
   \   00000146   EF0A               LDI     R16, 250
   \   00000148   9300....           STS     (UART + 51), R16
   \   0000014C   E000               LDI     R16, 0
   \   0000014E   9300....           STS     (UART + 52), R16
   \   00000152   9508               RET
     62                      } else {
     63                          UART[1].SyncCnt = 0 ;                // start over once more
   \                     ??recchar_10:
   \   00000154   E000               LDI     R16, 0
   \   00000156   9300....           STS     (UART + 50), R16
   \   0000015A   9508               RET
     64                      }
     65                      break;
     66                  default :
     67                      if ((++UART[1].RxFirst) > RXSIZE_UART) { // Point to next location
   \                     ??recchar_8:
   \   0000015C   9100....           LDS     R16, (UART + 43)
   \   00000160   9110....           LDS     R17, (UART + 44)
   \   00000164   5F0F               SUBI    R16, 255
   \   00000166   4F1F               SBCI    R17, 255
   \   00000168   9300....           STS     (UART + 43), R16
   \   0000016C   9310....           STS     (UART + 44), R17
   \   00000170   350F               CPI     R16, 95
   \   00000172   4011               SBCI    R17, 1
   \   00000174   E001               LDI     R16, 1
   \   00000176   F010               BRCS    ??recchar_11
     68                          GoToSyncUART(1) ;                       // go to sync mode
   \   00000178   ........           JMP     GoToSyncUART
     69                      } else {
     70                          ReceivePacketUart(1) ;              // Check package
   \                     ??recchar_11:
   \   0000017C   ........           CALL    ReceivePacketUart
     71                      }
     72                      break ;   
     73                  }
     74              }
     75            }
     76          }
   \                     ??recchar_7:
   \   00000180   9508               RET
   \   00000182                      REQUIRE _A_UCSR0A
   \   00000182                      REQUIRE _A_UDR0
   \   00000182                      REQUIRE _A_UCSR1A
   \   00000182                      REQUIRE _A_UDR1

   Maximum stack usage in bytes:

   RSTACK Function
   ------ --------
      2   recchar
        2   -> GoToSyncUART
        2   -> ReceivePacketUart
      2   sendchar


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  _A_UCSR0A
       1  _A_UCSR1A
       1  _A_UDR0
       1  _A_UDR1
     386  recchar
      42  sendchar

 
   4 bytes in segment ABSOLUTE
 428 bytes in segment CODE
 
 428 bytes of CODE memory
   0 bytes of DATA memory (+ 4 bytes shared)

Errors: none
Warnings: none
