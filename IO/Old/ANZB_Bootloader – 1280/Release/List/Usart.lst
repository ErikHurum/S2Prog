###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       12/Dec/2022  12:54:02
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\ANZB_Bootloader – 1280\Src\Usart.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EWDDFF.tmp
#        ("D:\S2Prog\IO\ANZB_Bootloader – 1280\Src\Usart.c" --cpu=m1280 -ms -o
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\Release\Obj" -D SPEED=38400 -lC
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\Release\List" -y
#        --initializers_in_flash --no_tbaa -DENABLE_BIT_DEFINITIONS -e -I
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\INC\\" -I
#        "D:\S2Prog\IO\ANZB_Bootloader – 1280\..\..\SHARED\INC\\" --eeprom_size
#        4096 --clib -Oh)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\ANZB_Bootloader – 1280\Release\List\Usart.lst
#    Object file  =  D:\S2Prog\IO\ANZB_Bootloader – 1280\Release\Obj\Usart.r90
#
###############################################################################

D:\S2Prog\IO\ANZB_Bootloader – 1280\Src\Usart.c
      1          /****************************************************************************************
      2          / Com protocol for USART0 
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom128.h"

   \                                 In  segment ABSOLUTE, at 0x23
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3c
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3e
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_WDTCR
   \                     _A_WDTCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5b
   \   union <unnamed> volatile __io _A_RAMPZ
   \                     _A_RAMPZ:
   \   00000000                      DS8 1
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "externals.h"
     10          #include "assembly.h"
     11          
     12           
     13           /*************************************************************************
     14          *
     15          *  Check the incoming packages
     16          *
     17          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     18          void UsartCheckPackage(char ch) {
   \                     UsartCheckPackage:
   \   00000000   924A               ST      -Y, R4
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000A   2E40               MOV     R4, R16
     19          
     20              unsigned short pointer;
     21              char retval ;
     22              
     23              UART[ch].RxSendReply = false ;                           // flag for answering set to fault
   \   0000000C   E10D               LDI     R16, 29
   \   0000000E   9E40               MUL     R4, R16
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   8F04               STD     Z+28, R16
     24              UART[ch].TxFirst = 11 ;                        // Startpos for fist TX command
   \   0000001E   E00B               LDI     R16, 11
   \   00000020   8302               STD     Z+2, R16
   \   00000022   E000               LDI     R16, 0
   \   00000024   8303               STD     Z+3, R16
     25              pointer = 7 ;
   \   00000026   E087               LDI     R24, 7
   \   00000028   E090               LDI     R25, 0
     26              do {
     27                  retval = CheckActionUart(ch, pointer);
   \                     ??UsartCheckPackage_0:
   \   0000002A   019C               MOVW    R19:R18, R25:R24
   \   0000002C   2D04               MOV     R16, R4
   \   0000002E   ....               RCALL   CheckActionUart
   \   00000030   2F30               MOV     R19, R16
     28                  pointer = pointer + UART[ch].pRxBuffer[pointer+2] 
     29                                    + (UART[ch].pRxBuffer[pointer+3]*256) + 4;            // Point to a command cmd hb/lb
   \   00000032   01FD               MOVW    R31:R30, R27:R26
   \   00000034   8504               LDD     R16, Z+12
   \   00000036   8515               LDD     R17, Z+13
   \   00000038   0F08               ADD     R16, R24
   \   0000003A   1F19               ADC     R17, R25
   \   0000003C   01F8               MOVW    R31:R30, R17:R16
   \   0000003E   8122               LDD     R18, Z+2
   \   00000040   81F3               LDD     R31, Z+3
   \   00000042   2FE2               MOV     R30, R18
   \   00000044   9634               ADIW    R31:R30, 4
   \   00000046   0F8E               ADD     R24, R30
   \   00000048   1F9F               ADC     R25, R31
     30              } while (retval && (pointer < (UART[ch].RxPacklen - 4 )));
   \   0000004A   2333               TST     R19
   \   0000004C   F041               BREQ    ??UsartCheckPackage_1
   \   0000004E   01FD               MOVW    R31:R30, R27:R26
   \   00000050   8D00               LDD     R16, Z+24
   \   00000052   8D11               LDD     R17, Z+25
   \   00000054   5004               SUBI    R16, 4
   \   00000056   4010               SBCI    R17, 0
   \   00000058   1780               CP      R24, R16
   \   0000005A   0791               CPC     R25, R17
   \   0000005C   F330               BRCS    ??UsartCheckPackage_0
     31              if(UART[ch].RxSendReply){                              //send answer
   \                     ??UsartCheckPackage_1:
   \   0000005E   01FD               MOVW    R31:R30, R27:R26
   \   00000060   8D04               LDD     R16, Z+28
   \   00000062   2300               TST     R16
   \   00000064   F011               BREQ    ??UsartCheckPackage_2
     32                  Uart_BuildTail(ch);
   \   00000066   2D04               MOV     R16, R4
   \   00000068   ....               RCALL   Uart_BuildTail
     33              }
     34              GoToSyncUART(ch) ;                                    // go to sync modus for recive
   \                     ??UsartCheckPackage_2:
   \   0000006A   2D04               MOV     R16, R4
   \   0000006C   ....               RCALL   GoToSyncUART
     35          }
   \   0000006E   9189               LD      R24, Y+
   \   00000070   9199               LD      R25, Y+
   \   00000072   91A9               LD      R26, Y+
   \   00000074   91B9               LD      R27, Y+
   \   00000076   9049               LD      R4, Y+
   \   00000078   9508               RET
     36          
     37          /*************************************************************************
     38          *
     39          *  Check action on received data
     40          *
     41          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     42          char CheckActionUart(char ch, unsigned short pointer) {
   \                     CheckActionUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
     43          
     44              unsigned short   command;
     45              char    retval = true;
   \   00000006   E081               LDI     R24, 1
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R26, LOW(UART)
   \   0000000E   ....               LDI     R27, (UART) >> 8
   \   00000010   0DA0               ADD     R26, R0
   \   00000012   1DB1               ADC     R27, R1
   \   00000014   961C               ADIW    R27:R26, 12
   \   00000016   91ED               LD      R30, X+
   \   00000018   91FC               LD      R31, X
   \   0000001A   0FE2               ADD     R30, R18
   \   0000001C   1FF3               ADC     R31, R19
   \   0000001E   8140               LD      R20, Z
   \   00000020   8151               LDD     R21, Z+1
     46          
     47              command = UART[ch].pRxBuffer[pointer] | (UART[ch].pRxBuffer[pointer+1] <<8);
     48              switch (command) {                                      // check action 
   \   00000022   01FA               MOVW    R31:R30, R21:R20
   \   00000024   5EE8               SUBI    R30, 232
   \   00000026   40F3               SBCI    R31, 3
   \   00000028   F061               BREQ    ??CheckActionUart_0
   \   0000002A   5AEC               SUBI    R30, 172
   \   0000002C   40F3               SBCI    R31, 3
   \   0000002E   F059               BREQ    ??CheckActionUart_1
   \   00000030   973A               SBIW    R31:R30, 10
   \   00000032   F059               BREQ    ??CheckActionUart_2
   \   00000034   973A               SBIW    R31:R30, 10
   \   00000036   F059               BREQ    ??CheckActionUart_3
   \   00000038   973A               SBIW    R31:R30, 10
   \   0000003A   F069               BREQ    ??CheckActionUart_4
   \   0000003C   9774               SBIW    R31:R30, 20
   \   0000003E   F079               BREQ    ??CheckActionUart_5
   \   00000040   C010               RJMP    ??CheckActionUart_6
     49             case CMD_REQ_STATUS :                                    // Regusest status for target
     50                  BuildStatusData(ch) ;                       
   \                     ??CheckActionUart_0:
   \   00000042   ....               RCALL   BuildStatusData
     51                  break;
   \   00000044   C012               RJMP    ??CheckActionUart_7
     52                  
     53              case CMD_FLASH_ID :                                     // Send flash ID
     54                  BuildFlashID(ch) ;
   \                     ??CheckActionUart_1:
   \   00000046   ....               RCALL   BuildFlashID
     55                  break ;
   \   00000048   C010               RJMP    ??CheckActionUart_7
     56                  
     57              case CMD_FLASH_ERASE :                                 // Erase flash
     58                  EraseFlash(ch) ;
   \                     ??CheckActionUart_2:
   \   0000004A   ....               RCALL   EraseFlash
     59                  break ;
   \   0000004C   C00E               RJMP    ??CheckActionUart_7
     60                  
     61              case CMD_FLASH_PROG :                                   // Prog flash
     62                  ProgramFlash(ch, pointer+4) ;
   \                     ??CheckActionUart_3:
   \   0000004E   5F2C               SUBI    R18, 252
   \   00000050   4F3F               SBCI    R19, 255
   \   00000052   ....               RCALL   ProgramFlash
     63                  break ;
   \   00000054   C00A               RJMP    ??CheckActionUart_7
     64                  
     65              case CMD_FLASH_READ :                                   // Read flash
     66                  ReadFlash(ch, pointer+4) ;
   \                     ??CheckActionUart_4:
   \   00000056   5F2C               SUBI    R18, 252
   \   00000058   4F3F               SBCI    R19, 255
   \   0000005A   ....               RCALL   ReadFlash
     67                  break ;
   \   0000005C   C006               RJMP    ??CheckActionUart_7
     68                  
     69              case CMD_EXIT_BOOTLOADER :                                // Leave bootlaoder
     70                  ExitBootloader(ch) ; 
   \                     ??CheckActionUart_5:
   \   0000005E   ....               RCALL   ExitBootloader
     71                  break ;
   \   00000060   C004               RJMP    ??CheckActionUart_7
     72                  
     73              default:
     74                  if (command < MAX_ECMD) {                           // handle end commands
   \                     ??CheckActionUart_6:
   \   00000062   3644               CPI     R20, 100
   \   00000064   4050               SBCI    R21, 0
   \   00000066   F408               BRCC    ??CheckActionUart_7
     75                      retval = false ;
   \   00000068   E080               LDI     R24, 0
     76                  }
     77                  break;
     78                  
     79              }
     80              return retval;
   \                     ??CheckActionUart_7:
   \   0000006A   2F08               MOV     R16, R24
   \   0000006C   9189               LD      R24, Y+
   \   0000006E   91A9               LD      R26, Y+
   \   00000070   91B9               LD      R27, Y+
   \   00000072   9508               RET
     81          }
     82          
     83          /*************************************************************************
     84          *
     85          * Build send packet header
     86          *
     87          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     88          void Uart_BuildHeader(char ch) {
   \                     Uart_BuildHeader:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
     89          
     90              UART[ch].RxFirst = 0;                                // Reset pointers
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R26, LOW(UART)
   \   0000000A   ....               LDI     R27, (UART) >> 8
   \   0000000C   0DA0               ADD     R26, R0
   \   0000000E   1DB1               ADC     R27, R1
   \   00000010   01FD               MOVW    R31:R30, R27:R26
   \   00000012   E000               LDI     R16, 0
   \   00000014   8706               STD     Z+14, R16
   \   00000016   8707               STD     Z+15, R16
     91              UART[ch].RxLast  = 0;
   \   00000018   8B00               STD     Z+16, R16
   \   0000001A   8B01               STD     Z+17, R16
     92              UART[ch].TxLast  = 0;
   \   0000001C   8304               STD     Z+4, R16
   \   0000001E   8305               STD     Z+5, R16
     93          
     94              UART[ch].pTxBuffer[0] = ANPRO10_SYN ;                        /* Sync */
   \   00000020   91ED               LD      R30, X+
   \   00000022   91FC               LD      R31, X
   \   00000024   9711               SBIW    R27:R26, 1
   \   00000026   E106               LDI     R16, 22
   \   00000028   8300               ST      Z, R16
     95              UART[ch].pTxBuffer[1] = ANPRO10_SYN ;                        /* Sync */
   \   0000002A   91ED               LD      R30, X+
   \   0000002C   91FC               LD      R31, X
   \   0000002E   9711               SBIW    R27:R26, 1
   \   00000030   8301               STD     Z+1, R16
     96              UART[ch].pTxBuffer[2] = ANPRO10_SYN ;                        /* Sync */
   \   00000032   91ED               LD      R30, X+
   \   00000034   91FC               LD      R31, X
   \   00000036   9711               SBIW    R27:R26, 1
   \   00000038   8302               STD     Z+2, R16
     97              UART[ch].pTxBuffer[3] = ANPRO10_SOH ;                        /* Start of header */
   \   0000003A   91ED               LD      R30, X+
   \   0000003C   91FC               LD      R31, X
   \   0000003E   961B               ADIW    R27:R26, 11
   \   00000040   E001               LDI     R16, 1
   \   00000042   8303               STD     Z+3, R16
     98              UART[ch].pTxBuffer[4] = UART[ch].pRxBuffer[2] ;      /* RXID */
   \   00000044   91ED               LD      R30, X+
   \   00000046   91FC               LD      R31, X
   \   00000048   971D               SBIW    R27:R26, 13
   \   0000004A   8102               LDD     R16, Z+2
   \   0000004C   91ED               LD      R30, X+
   \   0000004E   91FC               LD      R31, X
   \   00000050   961B               ADIW    R27:R26, 11
   \   00000052   8304               STD     Z+4, R16
     99              UART[ch].pTxBuffer[5] = UART[ch].pRxBuffer[3] ;      /* Rx address */
   \   00000054   91ED               LD      R30, X+
   \   00000056   91FC               LD      R31, X
   \   00000058   971D               SBIW    R27:R26, 13
   \   0000005A   8103               LDD     R16, Z+3
   \   0000005C   91ED               LD      R30, X+
   \   0000005E   91FC               LD      R31, X
   \   00000060   9711               SBIW    R27:R26, 1
   \   00000062   8305               STD     Z+5, R16
    100              UART[ch].pTxBuffer[6] = 0x10 + UnitID ;              /* Unit ID */
   \   00000064   9100....           LDS     R16, UnitID
   \   00000068   5F00               SUBI    R16, 240
   \   0000006A   91ED               LD      R30, X+
   \   0000006C   91FC               LD      R31, X
   \   0000006E   9711               SBIW    R27:R26, 1
   \   00000070   8306               STD     Z+6, R16
    101              UART[ch].pTxBuffer[7] = MyAddress();                /* Tx address */
   \   00000072   ........           CALL    MyAddress
   \   00000076   91ED               LD      R30, X+
   \   00000078   91FC               LD      R31, X
   \   0000007A   9711               SBIW    R27:R26, 1
   \   0000007C   8307               STD     Z+7, R16
    102              UART[ch].pTxBuffer[8] = 0 ;                         /* packlen HB, don't know yet */
   \   0000007E   91ED               LD      R30, X+
   \   00000080   91FC               LD      R31, X
   \   00000082   9711               SBIW    R27:R26, 1
   \   00000084   E000               LDI     R16, 0
   \   00000086   8700               STD     Z+8, R16
    103              UART[ch].pTxBuffer[9] = 0 ;                         /* packlen LB, don't know yet */
   \   00000088   91ED               LD      R30, X+
   \   0000008A   91FC               LD      R31, X
   \   0000008C   9711               SBIW    R27:R26, 1
   \   0000008E   8701               STD     Z+9, R16
    104              UART[ch].pTxBuffer[10] = 0 ;                        /* header checksum, don't know yet */
   \   00000090   91ED               LD      R30, X+
   \   00000092   91FC               LD      R31, X
   \   00000094   8702               STD     Z+10, R16
    105          }
   \   00000096   91A9               LD      R26, Y+
   \   00000098   91B9               LD      R27, Y+
   \   0000009A   9508               RET
    106          
    107          /*************************************************************************
    108          *
    109          * Build  packet tail
    110          *
    111          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    112          void Uart_BuildTail(char ch) {
   \                     Uart_BuildTail:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
   \   00000006   2F80               MOV     R24, R16
    113          
    114              Uart_BuildHeader(ch);                                    // fist build the header
   \   00000008   ....               RCALL   Uart_BuildHeader
    115          
    116              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ECMD_NMDWOACK & 0xff ;  // End command lb
   \   0000000A   E10D               LDI     R16, 29
   \   0000000C   9F80               MUL     R24, R16
   \   0000000E   ....               LDI     R26, LOW(UART)
   \   00000010   ....               LDI     R27, (UART) >> 8
   \   00000012   0DA0               ADD     R26, R0
   \   00000014   1DB1               ADC     R27, R1
   \   00000016   910D               LD      R16, X+
   \   00000018   911C               LD      R17, X
   \   0000001A   9711               SBIW    R27:R26, 1
   \   0000001C   01FD               MOVW    R31:R30, R27:R26
   \   0000001E   8122               LDD     R18, Z+2
   \   00000020   8133               LDD     R19, Z+3
   \   00000022   0F02               ADD     R16, R18
   \   00000024   1F13               ADC     R17, R19
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   E000               LDI     R16, 0
   \   0000002A   8300               ST      Z, R16
   \   0000002C   01FD               MOVW    R31:R30, R27:R26
   \   0000002E   8102               LDD     R16, Z+2
   \   00000030   8113               LDD     R17, Z+3
   \   00000032   5F0F               SUBI    R16, 255
   \   00000034   4F1F               SBCI    R17, 255
   \   00000036   8302               STD     Z+2, R16
   \   00000038   8313               STD     Z+3, R17
    117              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ECMD_NMDWOACK >> 8 ;    // End command hb 
   \   0000003A   8100               LD      R16, Z
   \   0000003C   8111               LDD     R17, Z+1
   \   0000003E   8122               LDD     R18, Z+2
   \   00000040   8133               LDD     R19, Z+3
   \   00000042   0F02               ADD     R16, R18
   \   00000044   1F13               ADC     R17, R19
   \   00000046   01F8               MOVW    R31:R30, R17:R16
   \   00000048   E000               LDI     R16, 0
   \   0000004A   8300               ST      Z, R16
   \   0000004C   01FD               MOVW    R31:R30, R27:R26
   \   0000004E   8102               LDD     R16, Z+2
   \   00000050   8113               LDD     R17, Z+3
   \   00000052   5F0F               SUBI    R16, 255
   \   00000054   4F1F               SBCI    R17, 255
   \   00000056   8302               STD     Z+2, R16
   \   00000058   8313               STD     Z+3, R17
    118              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0x00 ;                  // End data 
   \   0000005A   8100               LD      R16, Z
   \   0000005C   8111               LDD     R17, Z+1
   \   0000005E   8122               LDD     R18, Z+2
   \   00000060   8133               LDD     R19, Z+3
   \   00000062   0F02               ADD     R16, R18
   \   00000064   1F13               ADC     R17, R19
   \   00000066   01F8               MOVW    R31:R30, R17:R16
   \   00000068   E000               LDI     R16, 0
   \   0000006A   8300               ST      Z, R16
   \   0000006C   01FD               MOVW    R31:R30, R27:R26
   \   0000006E   8102               LDD     R16, Z+2
   \   00000070   8113               LDD     R17, Z+3
   \   00000072   5F0F               SUBI    R16, 255
   \   00000074   4F1F               SBCI    R17, 255
   \   00000076   8302               STD     Z+2, R16
   \   00000078   8313               STD     Z+3, R17
    119              
    120              UART[ch].pTxBuffer[UART[ch].TxFirst++] = UART[ch].TxSeqCnt++ ;   // Sequence counter 
   \   0000007A   8523               LDD     R18, Z+11
   \   0000007C   2F02               MOV     R16, R18
   \   0000007E   9503               INC     R16
   \   00000080   8703               STD     Z+11, R16
   \   00000082   8100               LD      R16, Z
   \   00000084   8111               LDD     R17, Z+1
   \   00000086   8142               LDD     R20, Z+2
   \   00000088   8153               LDD     R21, Z+3
   \   0000008A   0F04               ADD     R16, R20
   \   0000008C   1F15               ADC     R17, R21
   \   0000008E   01F8               MOVW    R31:R30, R17:R16
   \   00000090   8320               ST      Z, R18
   \   00000092   01FD               MOVW    R31:R30, R27:R26
   \   00000094   8102               LDD     R16, Z+2
   \   00000096   8113               LDD     R17, Z+3
   \   00000098   5F0F               SUBI    R16, 255
   \   0000009A   4F1F               SBCI    R17, 255
   \   0000009C   8302               STD     Z+2, R16
   \   0000009E   8313               STD     Z+3, R17
    121          
    122              UART[ch].pTxBuffer[8] = UART[ch].TxFirst -2;                // correct length because stx's
   \   000000A0   5002               SUBI    R16, 2
   \   000000A2   91ED               LD      R30, X+
   \   000000A4   91FC               LD      R31, X
   \   000000A6   9711               SBIW    R27:R26, 1
   \   000000A8   8700               STD     Z+8, R16
    123              UART[ch].pTxBuffer[9] = (UART[ch].TxFirst-2) >> 8 ;           // packet len high 
   \   000000AA   01FD               MOVW    R31:R30, R27:R26
   \   000000AC   8102               LDD     R16, Z+2
   \   000000AE   8113               LDD     R17, Z+3
   \   000000B0   5002               SUBI    R16, 2
   \   000000B2   4010               SBCI    R17, 0
   \   000000B4   91ED               LD      R30, X+
   \   000000B6   91FC               LD      R31, X
   \   000000B8   9711               SBIW    R27:R26, 1
   \   000000BA   8711               STD     Z+9, R17
    124          
    125              UART[ch].pTxBuffer[10] = CalcDSTxChecksum(ch, 10) ;         // Get header checksum 
   \   000000BC   E02A               LDI     R18, 10
   \   000000BE   E030               LDI     R19, 0
   \   000000C0   2F08               MOV     R16, R24
   \   000000C2   ....               RCALL   CalcDSTxChecksum
   \   000000C4   91ED               LD      R30, X+
   \   000000C6   91FC               LD      R31, X
   \   000000C8   9711               SBIW    R27:R26, 1
   \   000000CA   8702               STD     Z+10, R16
    126          
    127              UART[ch].pTxBuffer[UART[ch].TxFirst] = CalcDSTxChecksum(ch, UART[ch].TxFirst) ; // Get checksum 
   \   000000CC   01FD               MOVW    R31:R30, R27:R26
   \   000000CE   8122               LDD     R18, Z+2
   \   000000D0   8133               LDD     R19, Z+3
   \   000000D2   2F08               MOV     R16, R24
   \   000000D4   ....               RCALL   CalcDSTxChecksum
   \   000000D6   2F20               MOV     R18, R16
   \   000000D8   910D               LD      R16, X+
   \   000000DA   911C               LD      R17, X
   \   000000DC   9711               SBIW    R27:R26, 1
   \   000000DE   01FD               MOVW    R31:R30, R27:R26
   \   000000E0   8142               LDD     R20, Z+2
   \   000000E2   8153               LDD     R21, Z+3
   \   000000E4   0F04               ADD     R16, R20
   \   000000E6   1F15               ADC     R17, R21
   \   000000E8   01F8               MOVW    R31:R30, R17:R16
   \   000000EA   8320               ST      Z, R18
    128              UART[ch].TxFirst++ ;                                       // OBS!! must be inc here
   \   000000EC   01FD               MOVW    R31:R30, R27:R26
   \   000000EE   8102               LDD     R16, Z+2
   \   000000F0   8113               LDD     R17, Z+3
   \   000000F2   5F0F               SUBI    R16, 255
   \   000000F4   4F1F               SBCI    R17, 255
   \   000000F6   8302               STD     Z+2, R16
   \   000000F8   8313               STD     Z+3, R17
    129          
    130              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANPRO10_EOT ;            // End of transmission 
   \   000000FA   8100               LD      R16, Z
   \   000000FC   8111               LDD     R17, Z+1
   \   000000FE   8122               LDD     R18, Z+2
   \   00000100   8133               LDD     R19, Z+3
   \   00000102   0F02               ADD     R16, R18
   \   00000104   1F13               ADC     R17, R19
   \   00000106   01F8               MOVW    R31:R30, R17:R16
   \   00000108   E004               LDI     R16, 4
   \   0000010A   8300               ST      Z, R16
   \   0000010C   01FD               MOVW    R31:R30, R27:R26
   \   0000010E   8102               LDD     R16, Z+2
   \   00000110   8113               LDD     R17, Z+3
   \   00000112   5F0F               SUBI    R16, 255
   \   00000114   4F1F               SBCI    R17, 255
   \   00000116   8302               STD     Z+2, R16
   \   00000118   8313               STD     Z+3, R17
    131              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0x00 ;            //switch off transmitter delay 
   \   0000011A   8100               LD      R16, Z
   \   0000011C   8111               LDD     R17, Z+1
   \   0000011E   8122               LDD     R18, Z+2
   \   00000120   8133               LDD     R19, Z+3
   \   00000122   0F02               ADD     R16, R18
   \   00000124   1F13               ADC     R17, R19
   \   00000126   01F8               MOVW    R31:R30, R17:R16
   \   00000128   E000               LDI     R16, 0
   \   0000012A   8300               ST      Z, R16
   \   0000012C   01FD               MOVW    R31:R30, R27:R26
   \   0000012E   8102               LDD     R16, Z+2
   \   00000130   8113               LDD     R17, Z+3
   \   00000132   5F0F               SUBI    R16, 255
   \   00000134   4F1F               SBCI    R17, 255
   \   00000136   8302               STD     Z+2, R16
   \   00000138   8313               STD     Z+3, R17
    132          
    133              UART[ch].TxCount = UART[ch].TxFirst;                      //bytes to send 
   \   0000013A   8306               STD     Z+6, R16
   \   0000013C   8317               STD     Z+7, R17
    134              UART[ch].TxLast = 0;                                     // reset cunter
   \   0000013E   E000               LDI     R16, 0
   \   00000140   8304               STD     Z+4, R16
   \   00000142   8305               STD     Z+5, R16
    135              UART[ch].TxPkCnt++ ;                                     // Count sent packages
   \   00000144   8500               LDD     R16, Z+8
   \   00000146   8511               LDD     R17, Z+9
   \   00000148   5F0F               SUBI    R16, 255
   \   0000014A   4F1F               SBCI    R17, 255
   \   0000014C   8700               STD     Z+8, R16
   \   0000014E   8711               STD     Z+9, R17
    136              if (ch == 0){                                           // Turn on TXE for channel
   \   00000150   2388               TST     R24
   \   00000152   F419               BRNE    ??Uart_BuildTail_0
    137                  PORTE |= 0x04 ;                                     // TXE0 on
   \   00000154   9A1A               SBI     0x03, 0x02
    138                  SendPacketUart(0) ;                                     // send answer
   \   00000156   E000               LDI     R16, 0
   \   00000158   C004               RJMP    ??Uart_BuildTail_1
    139              } else if (ch ==1){
   \                     ??Uart_BuildTail_0:
   \   0000015A   3081               CPI     R24, 1
   \   0000015C   F419               BRNE    ??Uart_BuildTail_2
    140                  PORTE |= 0x08 ;                                     // TXE1 on
   \   0000015E   9A1B               SBI     0x03, 0x03
    141                  SendPacketUart(1) ;                                     // send answer
   \   00000160   E001               LDI     R16, 1
   \                     ??Uart_BuildTail_1:
   \   00000162   ....               RCALL   SendPacketUart
    142          
    143              }
    144          }
   \                     ??Uart_BuildTail_2:
   \   00000164   9189               LD      R24, Y+
   \   00000166   91A9               LD      R26, Y+
   \   00000168   91B9               LD      R27, Y+
   \   0000016A   9508               RET
   \   0000016C                      REQUIRE _A_PORTE
    145          
    146          
    147          /*************************************************************************
    148          *
    149          * Build datablock for card status
    150          *
    151          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9049               LD      R4, Y+
   \   0000000A   9059               LD      R5, Y+
   \   0000000C   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    152          void BuildStatusData(char ch){
   \                     BuildStatusData:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
    153          
    154              short ntna ;
    155              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   0000000C   E11D               LDI     R17, 29
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E011               LDI     R17, 1
   \   0000001C   8F14               STD     Z+28, R17
    156              
    157              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STATUS & 0xff;     
   \   0000001E   91ED               LD      R30, X+
   \   00000020   91FD               LD      R31, X+
   \   00000022   912D               LD      R18, X+
   \   00000024   913C               LD      R19, X
   \   00000026   9713               SBIW    R27:R26, 3
   \   00000028   0FE2               ADD     R30, R18
   \   0000002A   1FF3               ADC     R31, R19
   \   0000002C   EE19               LDI     R17, 233
   \   0000002E   8310               ST      Z, R17
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8122               LDD     R18, Z+2
   \   00000034   8133               LDD     R19, Z+3
   \   00000036   5F2F               SUBI    R18, 255
   \   00000038   4F3F               SBCI    R19, 255
   \   0000003A   8322               STD     Z+2, R18
   \   0000003C   8333               STD     Z+3, R19
    158              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STATUS >> 8;     
   \   0000003E   91ED               LD      R30, X+
   \   00000040   91FD               LD      R31, X+
   \   00000042   912D               LD      R18, X+
   \   00000044   9713               SBIW    R27:R26, 3
   \   00000046   0FE2               ADD     R30, R18
   \   00000048   1FF3               ADC     R31, R19
   \   0000004A   E013               LDI     R17, 3
   \   0000004C   8310               ST      Z, R17
   \   0000004E   01FD               MOVW    R31:R30, R27:R26
   \   00000050   8122               LDD     R18, Z+2
   \   00000052   8133               LDD     R19, Z+3
   \   00000054   5F2F               SUBI    R18, 255
   \   00000056   4F3F               SBCI    R19, 255
   \   00000058   8322               STD     Z+2, R18
   \   0000005A   8333               STD     Z+3, R19
    159              ntna = UART[ch].TxFirst ;                                    /* remember index */
   \   0000005C   0129               MOVW    R5:R4, R19:R18
    160              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000005E   5F2E               SUBI    R18, 254
   \   00000060   4F3F               SBCI    R19, 255
   \   00000062   8322               STD     Z+2, R18
   \   00000064   8333               STD     Z+3, R19
    161              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ch ;                // channel
   \   00000066   8120               LD      R18, Z
   \   00000068   8131               LDD     R19, Z+1
   \   0000006A   8142               LDD     R20, Z+2
   \   0000006C   8153               LDD     R21, Z+3
   \   0000006E   0F24               ADD     R18, R20
   \   00000070   1F35               ADC     R19, R21
   \   00000072   01F9               MOVW    R31:R30, R19:R18
   \   00000074   8300               ST      Z, R16
   \   00000076   01FD               MOVW    R31:R30, R27:R26
   \   00000078   8102               LDD     R16, Z+2
   \   0000007A   8113               LDD     R17, Z+3
   \   0000007C   5F0F               SUBI    R16, 255
   \   0000007E   4F1F               SBCI    R17, 255
   \   00000080   8302               STD     Z+2, R16
   \   00000082   8313               STD     Z+3, R17
    162              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0x10 +UnitID ;               // Product ID
   \   00000084   9120....           LDS     R18, UnitID
   \   00000088   5F20               SUBI    R18, 240
   \   0000008A   8100               LD      R16, Z
   \   0000008C   8111               LDD     R17, Z+1
   \   0000008E   8142               LDD     R20, Z+2
   \   00000090   8153               LDD     R21, Z+3
   \   00000092   0F04               ADD     R16, R20
   \   00000094   1F15               ADC     R17, R21
   \   00000096   01F8               MOVW    R31:R30, R17:R16
   \   00000098   8320               ST      Z, R18
   \   0000009A   01FD               MOVW    R31:R30, R27:R26
   \   0000009C   8102               LDD     R16, Z+2
   \   0000009E   8113               LDD     R17, Z+3
   \   000000A0   5F0F               SUBI    R16, 255
   \   000000A2   4F1F               SBCI    R17, 255
   \   000000A4   8302               STD     Z+2, R16
   \   000000A6   8313               STD     Z+3, R17
    163              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MyAddress();           // unit address				/* get the address */
   \   000000A8   01C8               MOVW    R25:R24, R17:R16
   \   000000AA   5F0F               SUBI    R16, 255
   \   000000AC   4F1F               SBCI    R17, 255
   \   000000AE   8302               STD     Z+2, R16
   \   000000B0   8313               STD     Z+3, R17
   \   000000B2   ........           CALL    MyAddress
   \   000000B6   91ED               LD      R30, X+
   \   000000B8   91FC               LD      R31, X
   \   000000BA   9711               SBIW    R27:R26, 1
   \   000000BC   0FE8               ADD     R30, R24
   \   000000BE   1FF9               ADC     R31, R25
   \   000000C0   8300               ST      Z, R16
    164              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROG_VERSION ;       // software version */
   \   000000C2   910D               LD      R16, X+
   \   000000C4   911C               LD      R17, X
   \   000000C6   9711               SBIW    R27:R26, 1
   \   000000C8   01FD               MOVW    R31:R30, R27:R26
   \   000000CA   8122               LDD     R18, Z+2
   \   000000CC   8133               LDD     R19, Z+3
   \   000000CE   0F02               ADD     R16, R18
   \   000000D0   1F13               ADC     R17, R19
   \   000000D2   01F8               MOVW    R31:R30, R17:R16
   \   000000D4   E007               LDI     R16, 7
   \   000000D6   8300               ST      Z, R16
   \   000000D8   01FD               MOVW    R31:R30, R27:R26
   \   000000DA   8102               LDD     R16, Z+2
   \   000000DC   8113               LDD     R17, Z+3
   \   000000DE   5F0F               SUBI    R16, 255
   \   000000E0   4F1F               SBCI    R17, 255
   \   000000E2   8302               STD     Z+2, R16
   \   000000E4   8313               STD     Z+3, R17
    165              UART[ch].pTxBuffer[UART[ch].TxFirst++] = COMP_VERSION;        // cpmpability version
   \   000000E6   8100               LD      R16, Z
   \   000000E8   8111               LDD     R17, Z+1
   \   000000EA   8122               LDD     R18, Z+2
   \   000000EC   8133               LDD     R19, Z+3
   \   000000EE   0F02               ADD     R16, R18
   \   000000F0   1F13               ADC     R17, R19
   \   000000F2   01F8               MOVW    R31:R30, R17:R16
   \   000000F4   E001               LDI     R16, 1
   \   000000F6   8300               ST      Z, R16
   \   000000F8   01FD               MOVW    R31:R30, R27:R26
   \   000000FA   8102               LDD     R16, Z+2
   \   000000FC   8113               LDD     R17, Z+3
   \   000000FE   5F0F               SUBI    R16, 255
   \   00000100   4F1F               SBCI    R17, 255
   \   00000102   8302               STD     Z+2, R16
   \   00000104   8313               STD     Z+3, R17
    166              UART[ch].pTxBuffer[UART[ch].TxFirst++] = STORE_VERSION;        // cpmpability version
   \   00000106   8100               LD      R16, Z
   \   00000108   8111               LDD     R17, Z+1
   \   0000010A   8122               LDD     R18, Z+2
   \   0000010C   8133               LDD     R19, Z+3
   \   0000010E   0F02               ADD     R16, R18
   \   00000110   1F13               ADC     R17, R19
   \   00000112   01F8               MOVW    R31:R30, R17:R16
   \   00000114   E002               LDI     R16, 2
   \   00000116   8300               ST      Z, R16
   \   00000118   01FD               MOVW    R31:R30, R27:R26
   \   0000011A   8102               LDD     R16, Z+2
   \   0000011C   8113               LDD     R17, Z+3
   \   0000011E   5F0F               SUBI    R16, 255
   \   00000120   4F1F               SBCI    R17, 255
   \   00000122   8302               STD     Z+2, R16
   \   00000124   8313               STD     Z+3, R17
    167              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (RXSIZE_UART & 0xff);         // rx buffer size
   \   00000126   8100               LD      R16, Z
   \   00000128   8111               LDD     R17, Z+1
   \   0000012A   8122               LDD     R18, Z+2
   \   0000012C   8133               LDD     R19, Z+3
   \   0000012E   0F02               ADD     R16, R18
   \   00000130   1F13               ADC     R17, R19
   \   00000132   01F8               MOVW    R31:R30, R17:R16
   \   00000134   E50E               LDI     R16, 94
   \   00000136   8300               ST      Z, R16
   \   00000138   01FD               MOVW    R31:R30, R27:R26
   \   0000013A   8102               LDD     R16, Z+2
   \   0000013C   8113               LDD     R17, Z+3
   \   0000013E   5F0F               SUBI    R16, 255
   \   00000140   4F1F               SBCI    R17, 255
   \   00000142   8302               STD     Z+2, R16
   \   00000144   8313               STD     Z+3, R17
    168              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (( RXSIZE_UART >> 8) & 0xff); // rx buffer size
   \   00000146   8100               LD      R16, Z
   \   00000148   8111               LDD     R17, Z+1
   \   0000014A   8122               LDD     R18, Z+2
   \   0000014C   8133               LDD     R19, Z+3
   \   0000014E   0F02               ADD     R16, R18
   \   00000150   1F13               ADC     R17, R19
   \   00000152   01F8               MOVW    R31:R30, R17:R16
   \   00000154   E001               LDI     R16, 1
   \   00000156   8300               ST      Z, R16
   \   00000158   01FD               MOVW    R31:R30, R27:R26
   \   0000015A   8102               LDD     R16, Z+2
   \   0000015C   8113               LDD     R17, Z+3
   \   0000015E   5F0F               SUBI    R16, 255
   \   00000160   4F1F               SBCI    R17, 255
   \   00000162   8302               STD     Z+2, R16
   \   00000164   8313               STD     Z+3, R17
    169              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TXSIZE_UART & 0xff);         // tx buffer size
   \   00000166   8100               LD      R16, Z
   \   00000168   8111               LDD     R17, Z+1
   \   0000016A   8122               LDD     R18, Z+2
   \   0000016C   8133               LDD     R19, Z+3
   \   0000016E   0F02               ADD     R16, R18
   \   00000170   1F13               ADC     R17, R19
   \   00000172   01F8               MOVW    R31:R30, R17:R16
   \   00000174   E50E               LDI     R16, 94
   \   00000176   8300               ST      Z, R16
   \   00000178   01FD               MOVW    R31:R30, R27:R26
   \   0000017A   8102               LDD     R16, Z+2
   \   0000017C   8113               LDD     R17, Z+3
   \   0000017E   5F0F               SUBI    R16, 255
   \   00000180   4F1F               SBCI    R17, 255
   \   00000182   8302               STD     Z+2, R16
   \   00000184   8313               STD     Z+3, R17
    170              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);  // tx buffer size
   \   00000186   8100               LD      R16, Z
   \   00000188   8111               LDD     R17, Z+1
   \   0000018A   8122               LDD     R18, Z+2
   \   0000018C   8133               LDD     R19, Z+3
   \   0000018E   0F02               ADD     R16, R18
   \   00000190   1F13               ADC     R17, R19
   \   00000192   01F8               MOVW    R31:R30, R17:R16
   \   00000194   E001               LDI     R16, 1
   \   00000196   8300               ST      Z, R16
   \   00000198   01FD               MOVW    R31:R30, R27:R26
   \   0000019A   8102               LDD     R16, Z+2
   \   0000019C   8113               LDD     R17, Z+3
   \   0000019E   5F0F               SUBI    R16, 255
   \   000001A0   4F1F               SBCI    R17, 255
   \   000001A2   8302               STD     Z+2, R16
   \   000001A4   8313               STD     Z+3, R17
    171              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ResetStatus ;                  // restart flag
   \   000001A6   9120....           LDS     R18, ResetStatus
   \   000001AA   8100               LD      R16, Z
   \   000001AC   8111               LDD     R17, Z+1
   \   000001AE   8142               LDD     R20, Z+2
   \   000001B0   8153               LDD     R21, Z+3
   \   000001B2   0F04               ADD     R16, R20
   \   000001B4   1F15               ADC     R17, R21
   \   000001B6   01F8               MOVW    R31:R30, R17:R16
   \   000001B8   8320               ST      Z, R18
   \   000001BA   01FD               MOVW    R31:R30, R27:R26
   \   000001BC   8102               LDD     R16, Z+2
   \   000001BE   8113               LDD     R17, Z+3
   \   000001C0   5F0F               SUBI    R16, 255
   \   000001C2   4F1F               SBCI    R17, 255
   \   000001C4   8302               STD     Z+2, R16
   \   000001C6   8313               STD     Z+3, R17
    172              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROGTYPE_BOOT ;                // Boot program
   \   000001C8   8100               LD      R16, Z
   \   000001CA   8111               LDD     R17, Z+1
   \   000001CC   8122               LDD     R18, Z+2
   \   000001CE   8133               LDD     R19, Z+3
   \   000001D0   0F02               ADD     R16, R18
   \   000001D2   1F13               ADC     R17, R19
   \   000001D4   01F8               MOVW    R31:R30, R17:R16
   \   000001D6   E000               LDI     R16, 0
   \   000001D8   8300               ST      Z, R16
   \   000001DA   01FD               MOVW    R31:R30, R27:R26
   \   000001DC   8102               LDD     R16, Z+2
   \   000001DE   8113               LDD     R17, Z+3
   \   000001E0   5F0F               SUBI    R16, 255
   \   000001E2   4F1F               SBCI    R17, 255
   \   000001E4   8302               STD     Z+2, R16
   \   000001E6   8313               STD     Z+3, R17
    173          
    174              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   000001E8   1904               SUB     R16, R4
   \   000001EA   5002               SUBI    R16, 2
   \   000001EC   91ED               LD      R30, X+
   \   000001EE   91FC               LD      R31, X
   \   000001F0   9711               SBIW    R27:R26, 1
   \   000001F2   0DE4               ADD     R30, R4
   \   000001F4   1DF5               ADC     R31, R5
   \   000001F6   8300               ST      Z, R16
    175              UART[ch].pTxBuffer[ntna+1]   = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   000001F8   01FD               MOVW    R31:R30, R27:R26
   \   000001FA   8182               LDD     R24, Z+2
   \   000001FC   8193               LDD     R25, Z+3
   \   000001FE   1984               SUB     R24, R4
   \   00000200   0995               SBC     R25, R5
   \   00000202   9702               SBIW    R25:R24, 2
   \   00000204   91ED               LD      R30, X+
   \   00000206   91FC               LD      R31, X
   \   00000208   0DE4               ADD     R30, R4
   \   0000020A   1DF5               ADC     R31, R5
   \   0000020C   8391               STD     Z+1, R25
    176              
    177              ResetStatus = 0 ;                                                       // set reset stat to 0 = read
   \   0000020E   E000               LDI     R16, 0
   \   00000210   9300....           STS     ResetStatus, R16
    178          }
   \   00000214   ....               RJMP    ?Subroutine0
    179          
    180          /*************************************************************************
    181          *
    182          * Build datablock for Flash ID
    183          *
    184          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    185          void BuildFlashID(char ch) {
   \                     BuildFlashID:
   \   00000000   01BD               MOVW    R23:R22, R27:R26
   \   00000002   01AC               MOVW    R21:R20, R25:R24
    186          
    187              short ntna;
    188              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   E001               LDI     R16, 1
   \   00000012   8F04               STD     Z+28, R16
    189              
    190              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_FLASH_ID & 0xff;     
   \   00000014   81A0               LD      R26, Z
   \   00000016   81B1               LDD     R27, Z+1
   \   00000018   8102               LDD     R16, Z+2
   \   0000001A   8113               LDD     R17, Z+3
   \   0000001C   0FA0               ADD     R26, R16
   \   0000001E   1FB1               ADC     R27, R17
   \   00000020   E905               LDI     R16, 149
   \   00000022   930C               ST      X, R16
   \   00000024   8102               LDD     R16, Z+2
   \   00000026   8113               LDD     R17, Z+3
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   8302               STD     Z+2, R16
   \   0000002E   8313               STD     Z+3, R17
    191              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_FLASH_ID >> 8;     
   \   00000030   81A0               LD      R26, Z
   \   00000032   81B1               LDD     R27, Z+1
   \   00000034   0FA0               ADD     R26, R16
   \   00000036   1FB1               ADC     R27, R17
   \   00000038   E007               LDI     R16, 7
   \   0000003A   930C               ST      X, R16
   \   0000003C   8102               LDD     R16, Z+2
   \   0000003E   8113               LDD     R17, Z+3
   \   00000040   5F0F               SUBI    R16, 255
   \   00000042   4F1F               SBCI    R17, 255
   \   00000044   8302               STD     Z+2, R16
   \   00000046   8313               STD     Z+3, R17
    192              ntna = UART[ch].TxFirst ;                                    // remember index 
    193              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   00000048   0198               MOVW    R19:R18, R17:R16
   \   0000004A   5F2E               SUBI    R18, 254
   \   0000004C   4F3F               SBCI    R19, 255
   \   0000004E   8322               STD     Z+2, R18
   \   00000050   8333               STD     Z+3, R19
    194              
    195              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PARTCODE ;
   \   00000052   81A0               LD      R26, Z
   \   00000054   81B1               LDD     R27, Z+1
   \   00000056   0FA2               ADD     R26, R18
   \   00000058   1FB3               ADC     R27, R19
   \   0000005A   E424               LDI     R18, 68
   \   0000005C   932C               ST      X, R18
   \   0000005E   8122               LDD     R18, Z+2
   \   00000060   8133               LDD     R19, Z+3
   \   00000062   5F2F               SUBI    R18, 255
   \   00000064   4F3F               SBCI    R19, 255
   \   00000066   8322               STD     Z+2, R18
   \   00000068   8333               STD     Z+3, R19
    196              UART[ch].pTxBuffer[UART[ch].TxFirst++] = SIGNATURE_BYTE_1 ;
   \   0000006A   81A0               LD      R26, Z
   \   0000006C   81B1               LDD     R27, Z+1
   \   0000006E   0FA2               ADD     R26, R18
   \   00000070   1FB3               ADC     R27, R19
   \   00000072   E12E               LDI     R18, 30
   \   00000074   932C               ST      X, R18
   \   00000076   8122               LDD     R18, Z+2
   \   00000078   8133               LDD     R19, Z+3
   \   0000007A   5F2F               SUBI    R18, 255
   \   0000007C   4F3F               SBCI    R19, 255
   \   0000007E   8322               STD     Z+2, R18
   \   00000080   8333               STD     Z+3, R19
    197              UART[ch].pTxBuffer[UART[ch].TxFirst++] = SIGNATURE_BYTE_2 ;
   \   00000082   81A0               LD      R26, Z
   \   00000084   81B1               LDD     R27, Z+1
   \   00000086   0FA2               ADD     R26, R18
   \   00000088   1FB3               ADC     R27, R19
   \   0000008A   E927               LDI     R18, 151
   \   0000008C   932C               ST      X, R18
   \   0000008E   8122               LDD     R18, Z+2
   \   00000090   8133               LDD     R19, Z+3
   \   00000092   5F2F               SUBI    R18, 255
   \   00000094   4F3F               SBCI    R19, 255
   \   00000096   8322               STD     Z+2, R18
   \   00000098   8333               STD     Z+3, R19
    198              UART[ch].pTxBuffer[UART[ch].TxFirst++] = SIGNATURE_BYTE_3 ;
   \   0000009A   81A0               LD      R26, Z
   \   0000009C   81B1               LDD     R27, Z+1
   \   0000009E   0FA2               ADD     R26, R18
   \   000000A0   1FB3               ADC     R27, R19
   \   000000A2   E022               LDI     R18, 2
   \   000000A4   932C               ST      X, R18
   \   000000A6   8122               LDD     R18, Z+2
   \   000000A8   8133               LDD     R19, Z+3
   \   000000AA   5F2F               SUBI    R18, 255
   \   000000AC   4F3F               SBCI    R19, 255
   \   000000AE   8322               STD     Z+2, R18
   \   000000B0   8333               STD     Z+3, R19
    199          
    200                  
    201              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   000000B2   1B20               SUB     R18, R16
   \   000000B4   5022               SUBI    R18, 2
   \   000000B6   81A0               LD      R26, Z
   \   000000B8   81B1               LDD     R27, Z+1
   \   000000BA   0FA0               ADD     R26, R16
   \   000000BC   1FB1               ADC     R27, R17
   \   000000BE   932C               ST      X, R18
    202              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   000000C0   8182               LDD     R24, Z+2
   \   000000C2   8193               LDD     R25, Z+3
   \   000000C4   1B80               SUB     R24, R16
   \   000000C6   0B91               SBC     R25, R17
   \   000000C8   9702               SBIW    R25:R24, 2
   \   000000CA   8120               LD      R18, Z
   \   000000CC   8131               LDD     R19, Z+1
   \   000000CE   0F20               ADD     R18, R16
   \   000000D0   1F31               ADC     R19, R17
   \   000000D2   01F9               MOVW    R31:R30, R19:R18
   \   000000D4   8391               STD     Z+1, R25
    203          
    204          }
   \   000000D6   01CA               MOVW    R25:R24, R21:R20
   \   000000D8   01DB               MOVW    R27:R26, R23:R22
   \   000000DA   9508               RET
    205          
    206          /*************************************************************************
    207          *
    208          * Erase Flash 
    209          *
    210          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    211          void EraseFlash(char ch) {
   \                     EraseFlash:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
    212          
    213              unsigned short ntna, address;
    214              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   0000000C   E11D               LDI     R17, 29
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E001               LDI     R16, 1
   \   0000001C   8F04               STD     Z+28, R16
    215              
    216              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_FLASH_ERASE & 0xff;     
   \   0000001E   91ED               LD      R30, X+
   \   00000020   91FD               LD      R31, X+
   \   00000022   910D               LD      R16, X+
   \   00000024   911C               LD      R17, X
   \   00000026   9713               SBIW    R27:R26, 3
   \   00000028   0FE0               ADD     R30, R16
   \   0000002A   1FF1               ADC     R31, R17
   \   0000002C   E90F               LDI     R16, 159
   \   0000002E   8300               ST      Z, R16
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8102               LDD     R16, Z+2
   \   00000034   8113               LDD     R17, Z+3
   \   00000036   5F0F               SUBI    R16, 255
   \   00000038   4F1F               SBCI    R17, 255
   \   0000003A   8302               STD     Z+2, R16
   \   0000003C   8313               STD     Z+3, R17
    217              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_FLASH_ERASE >> 8;     
   \   0000003E   91ED               LD      R30, X+
   \   00000040   91FD               LD      R31, X+
   \   00000042   910D               LD      R16, X+
   \   00000044   9713               SBIW    R27:R26, 3
   \   00000046   0FE0               ADD     R30, R16
   \   00000048   1FF1               ADC     R31, R17
   \   0000004A   E007               LDI     R16, 7
   \   0000004C   8300               ST      Z, R16
   \   0000004E   01FD               MOVW    R31:R30, R27:R26
   \   00000050   8102               LDD     R16, Z+2
   \   00000052   8113               LDD     R17, Z+3
   \   00000054   5F0F               SUBI    R16, 255
   \   00000056   4F1F               SBCI    R17, 255
   \   00000058   8302               STD     Z+2, R16
   \   0000005A   8313               STD     Z+3, R17
    218              ntna = UART[ch].TxFirst ;                                    // remember index 
   \   0000005C   0128               MOVW    R5:R4, R17:R16
    219              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   0000005E   5F0E               SUBI    R16, 254
   \   00000060   4F1F               SBCI    R17, 255
   \   00000062   8302               STD     Z+2, R16
   \   00000064   8313               STD     Z+3, R17
    220              
    221              #ifdef LARGE_MEMORY               //SPM uses Z pointer but the pointer is only 16bit and
    222              RAMPZ = 0x00;                     //can only address up to 64Kbytes FLASH to adresse higher 
   \   00000066   E000               LDI     R16, 0
   \   00000068   BF0B               OUT     0x3B, R16
    223                                              //location it require the use of RAMPZ
    224              
    225              for(address=0;((address < (unsigned int)(APP_END&0xFFFF))|(RAMPZ == 0x00));address += PAGESIZE) {
   \   0000006A   E080               LDI     R24, 0
   \   0000006C   E090               LDI     R25, 0
   \                     ??EraseFlash_0:
   \   0000006E   E001               LDI     R16, 1
   \   00000070   C012               RJMP    ??EraseFlash_1
    226                  write_page(address,(1<<PGERS) + (1<<SPMEN));              //Perform page erase
   \                     ??EraseFlash_2:
   \   00000072   E023               LDI     R18, 3
   \   00000074   018C               MOVW    R17:R16, R25:R24
   \   00000076   ........           CALL    write_page
    227                  write_page(address, (1<<REENABLE_RWW_BIT) + (1<<SPMEN));  //Re-enable the RWW section
   \   0000007A   E121               LDI     R18, 17
   \   0000007C   018C               MOVW    R17:R16, R25:R24
   \   0000007E   ........           CALL    write_page
    228              
    229                  if(address >=(0xFFFF-PAGESIZE)) //Last section on lower 64k segment is erased
   \   00000082   3F8F               CPI     R24, 255
   \   00000084   EF0E               LDI     R16, 254
   \   00000086   0790               CPC     R25, R16
   \   00000088   F010               BRCS    ??EraseFlash_3
    230                     RAMPZ = (1<<RAMPZ0);         //RAMPZ has to incremented into upper 64k segment
   \   0000008A   E001               LDI     R16, 1
   \   0000008C   BF0B               OUT     0x3B, R16
    231              }
   \                     ??EraseFlash_3:
   \   0000008E   9593               INC     R25
   \   00000090   3E90               CPI     R25, 224
   \   00000092   F368               BRCS    ??EraseFlash_0
   \   00000094   E000               LDI     R16, 0
   \                     ??EraseFlash_1:
   \   00000096   B71B               IN      R17, 0x3B
   \   00000098   2311               TST     R17
   \   0000009A   F359               BREQ    ??EraseFlash_2
   \   0000009C   2300               TST     R16
   \   0000009E   F749               BRNE    ??EraseFlash_2
    232              RAMPZ = 0x00;                     //Clear RAMPZ pointer
   \   000000A0   BF8B               OUT     0x3B, R24
    233              
    234              #else
    235              
    236              for(address=0;address < APP_END;address += PAGESIZE){  //Application section = 60 pages
    237                  write_page(address,(1<<PGERS) + (1<<SPMEN));       //Perform page erase
    238                  write_page(address, (1<<REENABLE_RWW_BIT) + (1<<SPMEN));  //Re-enable the RWW section
    239              }
    240              
    241              #endif          
    242          
    243              UART[ch].pTxBuffer[UART[ch].TxFirst++] = FLASH_ERASE_OK ;                 // Answer that the erase is OK
   \   000000A2   910D               LD      R16, X+
   \   000000A4   911C               LD      R17, X
   \   000000A6   9711               SBIW    R27:R26, 1
   \   000000A8   01FD               MOVW    R31:R30, R27:R26
   \   000000AA   8122               LDD     R18, Z+2
   \   000000AC   8133               LDD     R19, Z+3
   \   000000AE   0F02               ADD     R16, R18
   \   000000B0   1F13               ADC     R17, R19
   \   000000B2   01F8               MOVW    R31:R30, R17:R16
   \   000000B4   8380               ST      Z, R24
   \   000000B6   01FD               MOVW    R31:R30, R27:R26
   \   000000B8   8102               LDD     R16, Z+2
   \   000000BA   8113               LDD     R17, Z+3
   \   000000BC   5F0F               SUBI    R16, 255
   \   000000BE   4F1F               SBCI    R17, 255
   \   000000C0   8302               STD     Z+2, R16
   \   000000C2   8313               STD     Z+3, R17
    244          
    245              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \   000000C4   1904               SUB     R16, R4
   \   000000C6   5002               SUBI    R16, 2
   \   000000C8   91ED               LD      R30, X+
   \   000000CA   91FC               LD      R31, X
   \   000000CC   9711               SBIW    R27:R26, 1
   \   000000CE   0DE4               ADD     R30, R4
   \   000000D0   1DF5               ADC     R31, R5
   \   000000D2   8300               ST      Z, R16
    246              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   000000D4   01FD               MOVW    R31:R30, R27:R26
   \   000000D6   8182               LDD     R24, Z+2
   \   000000D8   8193               LDD     R25, Z+3
   \   000000DA   1984               SUB     R24, R4
   \   000000DC   0995               SBC     R25, R5
   \   000000DE   9702               SBIW    R25:R24, 2
   \   000000E0   91ED               LD      R30, X+
   \   000000E2   91FC               LD      R31, X
   \   000000E4   0DE4               ADD     R30, R4
   \   000000E6   1DF5               ADC     R31, R5
   \   000000E8   8391               STD     Z+1, R25
    247          
    248          }
   \   000000EA                      REQUIRE ?Subroutine0
   \   000000EA                      REQUIRE _A_RAMPZ
   \   000000EA                      ;               // Fall through to label ?Subroutine0
    249          
    250          /*************************************************************************
    251          *
    252          * Program Flash 
    253          *
    254          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    255          void ProgramFlash(char ch, unsigned short pointer) {
   \                     ProgramFlash:
   \   00000000   92FA               ST      -Y, R15
   \   00000002   92EA               ST      -Y, R14
   \   00000004   92DA               ST      -Y, R13
   \   00000006   92CA               ST      -Y, R12
   \   00000008   92BA               ST      -Y, R11
   \   0000000A   92AA               ST      -Y, R10
   \   0000000C   929A               ST      -Y, R9
   \   0000000E   928A               ST      -Y, R8
   \   00000010   927A               ST      -Y, R7
   \   00000012   926A               ST      -Y, R6
   \   00000014   925A               ST      -Y, R5
   \   00000016   924A               ST      -Y, R4
   \   00000018   93BA               ST      -Y, R27
   \   0000001A   93AA               ST      -Y, R26
   \   0000001C   939A               ST      -Y, R25
   \   0000001E   938A               ST      -Y, R24
   \   00000020                      REQUIRE ?Register_R4_is_cg_reg
   \   00000020                      REQUIRE ?Register_R5_is_cg_reg
   \   00000020                      REQUIRE ?Register_R6_is_cg_reg
   \   00000020                      REQUIRE ?Register_R7_is_cg_reg
   \   00000020                      REQUIRE ?Register_R8_is_cg_reg
   \   00000020                      REQUIRE ?Register_R9_is_cg_reg
   \   00000020                      REQUIRE ?Register_R10_is_cg_reg
   \   00000020                      REQUIRE ?Register_R11_is_cg_reg
   \   00000020                      REQUIRE ?Register_R12_is_cg_reg
   \   00000020                      REQUIRE ?Register_R13_is_cg_reg
   \   00000020                      REQUIRE ?Register_R14_is_cg_reg
   \   00000020                      REQUIRE ?Register_R15_is_cg_reg
   \   00000020   0139               MOVW    R7:R6, R19:R18
    256          
    257              unsigned short ntna, address, Nobytes, i, Addr, intval, Ptr;
    258              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000022   E11D               LDI     R17, 29
   \   00000024   9F01               MUL     R16, R17
   \   00000026   ....               LDI     R26, LOW(UART)
   \   00000028   ....               LDI     R27, (UART) >> 8
   \   0000002A   0DA0               ADD     R26, R0
   \   0000002C   1DB1               ADC     R27, R1
   \   0000002E   01FD               MOVW    R31:R30, R27:R26
   \   00000030   E001               LDI     R16, 1
   \   00000032   8F04               STD     Z+28, R16
    259              
    260              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_FLASH_PROG & 0xff;     
   \   00000034   8100               LD      R16, Z
   \   00000036   8111               LDD     R17, Z+1
   \   00000038   8122               LDD     R18, Z+2
   \   0000003A   8133               LDD     R19, Z+3
   \   0000003C   0F02               ADD     R16, R18
   \   0000003E   1F13               ADC     R17, R19
   \   00000040   01F8               MOVW    R31:R30, R17:R16
   \   00000042   EA09               LDI     R16, 169
   \   00000044   8300               ST      Z, R16
   \   00000046   01FD               MOVW    R31:R30, R27:R26
   \   00000048   8102               LDD     R16, Z+2
   \   0000004A   8113               LDD     R17, Z+3
   \   0000004C   5F0F               SUBI    R16, 255
   \   0000004E   4F1F               SBCI    R17, 255
   \   00000050   8302               STD     Z+2, R16
   \   00000052   8313               STD     Z+3, R17
    261              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_FLASH_PROG >> 8;     
   \   00000054   8100               LD      R16, Z
   \   00000056   8111               LDD     R17, Z+1
   \   00000058   8122               LDD     R18, Z+2
   \   0000005A   8133               LDD     R19, Z+3
   \   0000005C   0F02               ADD     R16, R18
   \   0000005E   1F13               ADC     R17, R19
   \   00000060   01F8               MOVW    R31:R30, R17:R16
   \   00000062   E007               LDI     R16, 7
   \   00000064   8300               ST      Z, R16
   \   00000066   01FD               MOVW    R31:R30, R27:R26
   \   00000068   8102               LDD     R16, Z+2
   \   0000006A   8113               LDD     R17, Z+3
   \   0000006C   5F0F               SUBI    R16, 255
   \   0000006E   4F1F               SBCI    R17, 255
   \   00000070   8302               STD     Z+2, R16
   \   00000072   8313               STD     Z+3, R17
    262              ntna = UART[ch].TxFirst ;                                    // remember index 
   \   00000074   0178               MOVW    R15:R14, R17:R16
    263              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   00000076   5F0E               SUBI    R16, 254
   \   00000078   4F1F               SBCI    R17, 255
   \   0000007A   8302               STD     Z+2, R16
   \   0000007C   8313               STD     Z+3, R17
    264              
    265              address = UART[ch].pRxBuffer[pointer] + (UART[ch].pRxBuffer[pointer+1]<<8); // save address
   \   0000007E   8504               LDD     R16, Z+12
   \   00000080   8515               LDD     R17, Z+13
   \   00000082   01F8               MOVW    R31:R30, R17:R16
   \   00000084   0DE6               ADD     R30, R6
   \   00000086   1DF7               ADC     R31, R7
   \   00000088   8040               LD      R4, Z
   \   0000008A   8051               LDD     R5, Z+1
    266              pointer += 2;
   \   0000008C   E022               LDI     R18, 2
   \   0000008E   0E62               ADD     R6, R18
   \   00000090   E020               LDI     R18, 0
   \   00000092   1E72               ADC     R7, R18
    267              Nobytes = UART[ch].pRxBuffer[pointer] + (UART[ch].pRxBuffer[pointer+1]<<8); // save address
   \   00000094   0D06               ADD     R16, R6
   \   00000096   1D17               ADC     R17, R7
   \   00000098   01F8               MOVW    R31:R30, R17:R16
   \   0000009A   80A0               LD      R10, Z
   \   0000009C   80B1               LDD     R11, Z+1
    268              pointer += 2;
    269              Ptr = pointer;
   \   0000009E   E002               LDI     R16, 2
   \   000000A0   0E60               ADD     R6, R16
   \   000000A2   1E72               ADC     R7, R18
   \   000000A4   01C3               MOVW    R25:R24, R7:R6
    270              if (Nobytes > PAGESIZE) {
   \   000000A6   E001               LDI     R16, 1
   \   000000A8   16A0               CP      R10, R16
   \   000000AA   06B0               CPC     R11, R16
   \   000000AC   F098               BRCS    ??ProgramFlash_0
    271                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = FLASH_PROG_PAGEF ;               // Answer with Page fault
   \   000000AE   910D               LD      R16, X+
   \   000000B0   911C               LD      R17, X
   \   000000B2   9711               SBIW    R27:R26, 1
   \   000000B4   01FD               MOVW    R31:R30, R27:R26
   \   000000B6   8122               LDD     R18, Z+2
   \   000000B8   8133               LDD     R19, Z+3
   \   000000BA   0F02               ADD     R16, R18
   \   000000BC   1F13               ADC     R17, R19
   \   000000BE   01F8               MOVW    R31:R30, R17:R16
   \   000000C0   E001               LDI     R16, 1
   \   000000C2   8300               ST      Z, R16
   \   000000C4   01FD               MOVW    R31:R30, R27:R26
   \   000000C6   8102               LDD     R16, Z+2
   \   000000C8   8113               LDD     R17, Z+3
   \   000000CA   5F0F               SUBI    R16, 255
   \   000000CC   4F1F               SBCI    R17, 255
   \   000000CE   8302               STD     Z+2, R16
   \   000000D0   8313               STD     Z+3, R17
   \   000000D2   C08B               RJMP    ??ProgramFlash_1
    272              } else {
    273                  #ifdef LARGE_MEMORY
    274                  if(address >= 0x7FFF){
   \                     ??ProgramFlash_0:
   \   000000D4   EF0F               LDI     R16, 255
   \   000000D6   1640               CP      R4, R16
   \   000000D8   E70F               LDI     R16, 127
   \   000000DA   0650               CPC     R5, R16
   \   000000DC   F018               BRCS    ??ProgramFlash_2
    275                      RAMPZ = (1<<RAMPZ0);
   \   000000DE   E001               LDI     R16, 1
   \   000000E0   BF0B               OUT     0x3B, R16
   \   000000E2   C001               RJMP    ??ProgramFlash_3
    276                  } else {
    277                      RAMPZ = 0;
   \                     ??ProgramFlash_2:
   \   000000E4   BF2B               OUT     0x3B, R18
    278                  }
    279                  #endif            
    280                  address = address << 1;                                     // convert from byte address to word address
   \                     ??ProgramFlash_3:
   \   000000E6   0C44               LSL     R4
   \   000000E8   1C55               ROL     R5
    281                  Addr = address;                                             // mirror the address
   \   000000EA   0162               MOVW    R13:R12, R5:R4
    282                  for (i = 0; i < Nobytes; i+=2, address+=2, pointer+=2) {              // write data to flash
   \   000000EC   2488               CLR     R8
   \   000000EE   2499               CLR     R9
   \   000000F0   2D0A               MOV     R16, R10
   \   000000F2   290B               OR      R16, R11
   \   000000F4   F0D1               BREQ    ??ProgramFlash_4
    283                      fill_temp_buffer(UART[ch].pRxBuffer[pointer] + (UART[ch].pRxBuffer[pointer+1]<< 8),(address)); //call asm routine. 
   \                     ??ProgramFlash_5:
   \   000000F6   01FD               MOVW    R31:R30, R27:R26
   \   000000F8   8504               LDD     R16, Z+12
   \   000000FA   8515               LDD     R17, Z+13
   \   000000FC   0D06               ADD     R16, R6
   \   000000FE   1D17               ADC     R17, R7
   \   00000100   0192               MOVW    R19:R18, R5:R4
   \   00000102   01F8               MOVW    R31:R30, R17:R16
   \   00000104   8100               LD      R16, Z
   \   00000106   8111               LDD     R17, Z+1
   \   00000108   ........           CALL    fill_temp_buffer
    284                  }
   \   0000010C   E002               LDI     R16, 2
   \   0000010E   0E80               ADD     R8, R16
   \   00000110   E000               LDI     R16, 0
   \   00000112   1E90               ADC     R9, R16
   \   00000114   E002               LDI     R16, 2
   \   00000116   0E40               ADD     R4, R16
   \   00000118   E000               LDI     R16, 0
   \   0000011A   1E50               ADC     R5, R16
   \   0000011C   E002               LDI     R16, 2
   \   0000011E   0E60               ADD     R6, R16
   \   00000120   E000               LDI     R16, 0
   \   00000122   1E70               ADC     R7, R16
   \   00000124   148A               CP      R8, R10
   \   00000126   049B               CPC     R9, R11
   \   00000128   F330               BRCS    ??ProgramFlash_5
    285                  write_page(Addr, (1<<PGWRT) + (1<<SPMEN));                  //Perform page write
   \                     ??ProgramFlash_4:
   \   0000012A   E025               LDI     R18, 5
   \   0000012C   0186               MOVW    R17:R16, R13:R12
   \   0000012E   ........           CALL    write_page
    286                  write_page(Addr, (1<<REENABLE_RWW_BIT) + (1<<SPMEN));       //Re-enable the RWW section
   \   00000132   E121               LDI     R18, 17
   \   00000134   0186               MOVW    R17:R16, R13:R12
   \   00000136   ........           CALL    write_page
    287                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = FLASH_PROG_OK;       // OK
   \   0000013A   910D               LD      R16, X+
   \   0000013C   911C               LD      R17, X
   \   0000013E   9711               SBIW    R27:R26, 1
   \   00000140   01FD               MOVW    R31:R30, R27:R26
   \   00000142   8122               LDD     R18, Z+2
   \   00000144   8133               LDD     R19, Z+3
   \   00000146   0F02               ADD     R16, R18
   \   00000148   1F13               ADC     R17, R19
   \   0000014A   01F8               MOVW    R31:R30, R17:R16
   \   0000014C   E000               LDI     R16, 0
   \   0000014E   8300               ST      Z, R16
   \   00000150   01FD               MOVW    R31:R30, R27:R26
   \   00000152   8102               LDD     R16, Z+2
   \   00000154   8113               LDD     R17, Z+3
   \   00000156   5F0F               SUBI    R16, 255
   \   00000158   4F1F               SBCI    R17, 255
   \   0000015A   8302               STD     Z+2, R16
   \   0000015C   8313               STD     Z+3, R17
    288                  
    289                  for (i = 0; i < Nobytes; i+=2, Addr+=2) {         // check the whole buffer
   \   0000015E   2488               CLR     R8
   \   00000160   2499               CLR     R9
   \   00000162   2D0A               MOV     R16, R10
   \   00000164   290B               OR      R16, R11
   \   00000166   F409               BRNE    $+2+2
   \   00000168   C040               RJMP    ??ProgramFlash_1
   \   0000016A   E002               LDI     R16, 2
   \   0000016C   2E40               MOV     R4, R16
    290                    intval = read_program_memory(Addr,0x00);
   \                     ??ProgramFlash_6:
   \   0000016E   E020               LDI     R18, 0
   \   00000170   0186               MOVW    R17:R16, R13:R12
   \   00000172   ........           CALL    read_program_memory
    291                    if (UART[ch].pRxBuffer[Ptr++] != (intval & 0xff)) {
   \   00000176   01AC               MOVW    R21:R20, R25:R24
   \   00000178   9601               ADIW    R25:R24, 1
   \   0000017A   01FD               MOVW    R31:R30, R27:R26
   \   0000017C   8524               LDD     R18, Z+12
   \   0000017E   8535               LDD     R19, Z+13
   \   00000180   0F24               ADD     R18, R20
   \   00000182   1F35               ADC     R19, R21
   \   00000184   01F9               MOVW    R31:R30, R19:R18
   \   00000186   8140               LD      R20, Z
   \   00000188   E050               LDI     R21, 0
   \   0000018A   1740               CP      R20, R16
   \   0000018C   4050               SBCI    R21, 0
   \   0000018E   F061               BREQ    ??ProgramFlash_7
    292                        UART[ch].pTxBuffer[UART[ch].TxFirst-1] = FLASH_PROG_ERROR;       // compare error
   \   00000190   912D               LD      R18, X+
   \   00000192   913C               LD      R19, X
   \   00000194   9711               SBIW    R27:R26, 1
   \   00000196   01FD               MOVW    R31:R30, R27:R26
   \   00000198   8142               LDD     R20, Z+2
   \   0000019A   8153               LDD     R21, Z+3
   \   0000019C   0F24               ADD     R18, R20
   \   0000019E   1F35               ADC     R19, R21
   \   000001A0   5021               SUBI    R18, 1
   \   000001A2   4030               SBCI    R19, 0
   \   000001A4   01F9               MOVW    R31:R30, R19:R18
   \   000001A6   8240               ST      Z, R4
    293                    }
    294                    if (UART[ch].pRxBuffer[Ptr++] != ((intval>>8) & 0xff)) {
   \                     ??ProgramFlash_7:
   \   000001A8   01AC               MOVW    R21:R20, R25:R24
   \   000001AA   9601               ADIW    R25:R24, 1
   \   000001AC   01FD               MOVW    R31:R30, R27:R26
   \   000001AE   8524               LDD     R18, Z+12
   \   000001B0   8535               LDD     R19, Z+13
   \   000001B2   0F24               ADD     R18, R20
   \   000001B4   1F35               ADC     R19, R21
   \   000001B6   01F9               MOVW    R31:R30, R19:R18
   \   000001B8   8120               LD      R18, Z
   \   000001BA   E030               LDI     R19, 0
   \   000001BC   1721               CP      R18, R17
   \   000001BE   4030               SBCI    R19, 0
   \   000001C0   F061               BREQ    ??ProgramFlash_8
    295                        UART[ch].pTxBuffer[UART[ch].TxFirst-1] = FLASH_PROG_ERROR;       // compare error
   \   000001C2   910D               LD      R16, X+
   \   000001C4   911C               LD      R17, X
   \   000001C6   9711               SBIW    R27:R26, 1
   \   000001C8   01FD               MOVW    R31:R30, R27:R26
   \   000001CA   8122               LDD     R18, Z+2
   \   000001CC   8133               LDD     R19, Z+3
   \   000001CE   0F02               ADD     R16, R18
   \   000001D0   1F13               ADC     R17, R19
   \   000001D2   5001               SUBI    R16, 1
   \   000001D4   4010               SBCI    R17, 0
   \   000001D6   01F8               MOVW    R31:R30, R17:R16
   \   000001D8   8240               ST      Z, R4
    296                    }
    297                  }
   \                     ??ProgramFlash_8:
   \   000001DA   0C84               ADD     R8, R4
   \   000001DC   E000               LDI     R16, 0
   \   000001DE   1E90               ADC     R9, R16
   \   000001E0   0CC4               ADD     R12, R4
   \   000001E2   1ED0               ADC     R13, R16
   \   000001E4   148A               CP      R8, R10
   \   000001E6   049B               CPC     R9, R11
   \   000001E8   F210               BRCS    ??ProgramFlash_6
    298              }  
    299                  
    300              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \                     ??ProgramFlash_1:
   \   000001EA   01FD               MOVW    R31:R30, R27:R26
   \   000001EC   8102               LDD     R16, Z+2
   \   000001EE   190E               SUB     R16, R14
   \   000001F0   5002               SUBI    R16, 2
   \   000001F2   91ED               LD      R30, X+
   \   000001F4   91FC               LD      R31, X
   \   000001F6   9711               SBIW    R27:R26, 1
   \   000001F8   0DEE               ADD     R30, R14
   \   000001FA   1DFF               ADC     R31, R15
   \   000001FC   8300               ST      Z, R16
    301              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   000001FE   01FD               MOVW    R31:R30, R27:R26
   \   00000200   8182               LDD     R24, Z+2
   \   00000202   8193               LDD     R25, Z+3
   \   00000204   198E               SUB     R24, R14
   \   00000206   099F               SBC     R25, R15
   \   00000208   9702               SBIW    R25:R24, 2
   \   0000020A   91ED               LD      R30, X+
   \   0000020C   91FC               LD      R31, X
   \   0000020E   0DEE               ADD     R30, R14
   \   00000210   1DFF               ADC     R31, R15
   \   00000212   8391               STD     Z+1, R25
    302          
    303          }
   \   00000214   9189               LD      R24, Y+
   \   00000216   9199               LD      R25, Y+
   \   00000218   91A9               LD      R26, Y+
   \   0000021A   91B9               LD      R27, Y+
   \   0000021C   9049               LD      R4, Y+
   \   0000021E   9059               LD      R5, Y+
   \   00000220   9069               LD      R6, Y+
   \   00000222   9079               LD      R7, Y+
   \   00000224   9089               LD      R8, Y+
   \   00000226   9099               LD      R9, Y+
   \   00000228   90A9               LD      R10, Y+
   \   0000022A   90B9               LD      R11, Y+
   \   0000022C   90C9               LD      R12, Y+
   \   0000022E   90D9               LD      R13, Y+
   \   00000230   90E9               LD      R14, Y+
   \   00000232   90F9               LD      R15, Y+
   \   00000234   9508               RET
   \   00000236                      REQUIRE _A_RAMPZ
    304          
    305          /*************************************************************************
    306          *
    307          * Read Flash 
    308          *
    309          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    310          void ReadFlash(char ch, unsigned short pointer) {
   \                     ReadFlash:
   \   00000000   929A               ST      -Y, R9
   \   00000002   928A               ST      -Y, R8
   \   00000004   927A               ST      -Y, R7
   \   00000006   926A               ST      -Y, R6
   \   00000008   925A               ST      -Y, R5
   \   0000000A   924A               ST      -Y, R4
   \   0000000C   93BA               ST      -Y, R27
   \   0000000E   93AA               ST      -Y, R26
   \   00000010   939A               ST      -Y, R25
   \   00000012   938A               ST      -Y, R24
   \   00000014                      REQUIRE ?Register_R4_is_cg_reg
   \   00000014                      REQUIRE ?Register_R5_is_cg_reg
   \   00000014                      REQUIRE ?Register_R6_is_cg_reg
   \   00000014                      REQUIRE ?Register_R7_is_cg_reg
   \   00000014                      REQUIRE ?Register_R8_is_cg_reg
   \   00000014                      REQUIRE ?Register_R9_is_cg_reg
    311          
    312              unsigned short ntna, address, Nobytes, i, intval;
    313              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000014   E11D               LDI     R17, 29
   \   00000016   9F01               MUL     R16, R17
   \   00000018   ....               LDI     R26, LOW(UART)
   \   0000001A   ....               LDI     R27, (UART) >> 8
   \   0000001C   0DA0               ADD     R26, R0
   \   0000001E   1DB1               ADC     R27, R1
   \   00000020   01FD               MOVW    R31:R30, R27:R26
   \   00000022   E001               LDI     R16, 1
   \   00000024   8F04               STD     Z+28, R16
    314              
    315              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_FLASH_READ & 0xff;     
   \   00000026   8100               LD      R16, Z
   \   00000028   8111               LDD     R17, Z+1
   \   0000002A   8142               LDD     R20, Z+2
   \   0000002C   8153               LDD     R21, Z+3
   \   0000002E   0F04               ADD     R16, R20
   \   00000030   1F15               ADC     R17, R21
   \   00000032   01F8               MOVW    R31:R30, R17:R16
   \   00000034   EB03               LDI     R16, 179
   \   00000036   8300               ST      Z, R16
   \   00000038   01FD               MOVW    R31:R30, R27:R26
   \   0000003A   8102               LDD     R16, Z+2
   \   0000003C   8113               LDD     R17, Z+3
   \   0000003E   5F0F               SUBI    R16, 255
   \   00000040   4F1F               SBCI    R17, 255
   \   00000042   8302               STD     Z+2, R16
   \   00000044   8313               STD     Z+3, R17
    316              UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_FLASH_READ >> 8;     
   \   00000046   8100               LD      R16, Z
   \   00000048   8111               LDD     R17, Z+1
   \   0000004A   8142               LDD     R20, Z+2
   \   0000004C   8153               LDD     R21, Z+3
   \   0000004E   0F04               ADD     R16, R20
   \   00000050   1F15               ADC     R17, R21
   \   00000052   01F8               MOVW    R31:R30, R17:R16
   \   00000054   E007               LDI     R16, 7
   \   00000056   8300               ST      Z, R16
   \   00000058   01FD               MOVW    R31:R30, R27:R26
   \   0000005A   8102               LDD     R16, Z+2
   \   0000005C   8113               LDD     R17, Z+3
   \   0000005E   5F0F               SUBI    R16, 255
   \   00000060   4F1F               SBCI    R17, 255
   \   00000062   8302               STD     Z+2, R16
   \   00000064   8313               STD     Z+3, R17
    317              ntna = UART[ch].TxFirst ;                                    // remember index 
   \   00000066   0148               MOVW    R9:R8, R17:R16
    318              UART[ch].TxFirst += 2 ;                                      // two byte length
   \   00000068   5F0E               SUBI    R16, 254
   \   0000006A   4F1F               SBCI    R17, 255
   \   0000006C   8302               STD     Z+2, R16
   \   0000006E   8313               STD     Z+3, R17
    319              
    320              for (i = 0; i<4; i++) {
   \   00000070   01C9               MOVW    R25:R24, R19:R18
   \   00000072   E044               LDI     R20, 4
    321                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = UART[ch].pRxBuffer[pointer+i] ; // ansver with address and nob
   \                     ??ReadFlash_0:
   \   00000074   8504               LDD     R16, Z+12
   \   00000076   8515               LDD     R17, Z+13
   \   00000078   0F08               ADD     R16, R24
   \   0000007A   1F19               ADC     R17, R25
   \   0000007C   01F8               MOVW    R31:R30, R17:R16
   \   0000007E   8150               LD      R21, Z
   \   00000080   910D               LD      R16, X+
   \   00000082   911C               LD      R17, X
   \   00000084   9711               SBIW    R27:R26, 1
   \   00000086   01FD               MOVW    R31:R30, R27:R26
   \   00000088   8162               LDD     R22, Z+2
   \   0000008A   8173               LDD     R23, Z+3
   \   0000008C   0F06               ADD     R16, R22
   \   0000008E   1F17               ADC     R17, R23
   \   00000090   01F8               MOVW    R31:R30, R17:R16
   \   00000092   8350               ST      Z, R21
   \   00000094   01FD               MOVW    R31:R30, R27:R26
   \   00000096   8102               LDD     R16, Z+2
   \   00000098   8113               LDD     R17, Z+3
   \   0000009A   5F0F               SUBI    R16, 255
   \   0000009C   4F1F               SBCI    R17, 255
   \   0000009E   8302               STD     Z+2, R16
   \   000000A0   8313               STD     Z+3, R17
    322              }
   \   000000A2   9601               ADIW    R25:R24, 1
   \   000000A4   954A               DEC     R20
   \   000000A6   F731               BRNE    ??ReadFlash_0
    323            
    324              address = UART[ch].pRxBuffer[pointer] | (UART[ch].pRxBuffer[pointer+1]<<8); // save address
   \   000000A8   8504               LDD     R16, Z+12
   \   000000AA   8515               LDD     R17, Z+13
   \   000000AC   01F8               MOVW    R31:R30, R17:R16
   \   000000AE   0FE2               ADD     R30, R18
   \   000000B0   1FF3               ADC     R31, R19
   \   000000B2   8180               LD      R24, Z
   \   000000B4   8191               LDD     R25, Z+1
    325              pointer += 2;
   \   000000B6   5F2E               SUBI    R18, 254
   \   000000B8   4F3F               SBCI    R19, 255
    326              Nobytes = UART[ch].pRxBuffer[pointer] | (UART[ch].pRxBuffer[pointer+1]<<8); // save address
   \   000000BA   0F02               ADD     R16, R18
   \   000000BC   1F13               ADC     R17, R19
   \   000000BE   01F8               MOVW    R31:R30, R17:R16
   \   000000C0   8060               LD      R6, Z
   \   000000C2   8071               LDD     R7, Z+1
    327              pointer += 2;
    328              if (Nobytes > PAGESIZE) {
   \   000000C4   E001               LDI     R16, 1
   \   000000C6   1660               CP      R6, R16
   \   000000C8   0670               CPC     R7, R16
   \   000000CA   F098               BRCS    ??ReadFlash_1
    329                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = FLASH_PROG_PAGEF ;               // Answer with Page fault
   \   000000CC   910D               LD      R16, X+
   \   000000CE   911C               LD      R17, X
   \   000000D0   9711               SBIW    R27:R26, 1
   \   000000D2   01FD               MOVW    R31:R30, R27:R26
   \   000000D4   8122               LDD     R18, Z+2
   \   000000D6   8133               LDD     R19, Z+3
   \   000000D8   0F02               ADD     R16, R18
   \   000000DA   1F13               ADC     R17, R19
   \   000000DC   01F8               MOVW    R31:R30, R17:R16
   \   000000DE   E001               LDI     R16, 1
   \   000000E0   8300               ST      Z, R16
   \   000000E2   01FD               MOVW    R31:R30, R27:R26
   \   000000E4   8102               LDD     R16, Z+2
   \   000000E6   8113               LDD     R17, Z+3
   \   000000E8   5F0F               SUBI    R16, 255
   \   000000EA   4F1F               SBCI    R17, 255
   \   000000EC   8302               STD     Z+2, R16
   \   000000EE   8313               STD     Z+3, R17
   \   000000F0   C03D               RJMP    ??ReadFlash_2
    330              } else {
    331                #ifdef LARGE_MEMORY
    332                if(address >= 0x7FFF){
   \                     ??ReadFlash_1:
   \   000000F2   3F8F               CPI     R24, 255
   \   000000F4   E70F               LDI     R16, 127
   \   000000F6   0790               CPC     R25, R16
   \   000000F8   F010               BRCS    ??ReadFlash_3
    333                  RAMPZ = (1<<RAMPZ0);
   \   000000FA   E001               LDI     R16, 1
   \   000000FC   C001               RJMP    ??ReadFlash_4
    334                } else {
    335                  RAMPZ = 0;
   \                     ??ReadFlash_3:
   \   000000FE   E000               LDI     R16, 0
   \                     ??ReadFlash_4:
   \   00000100   BF0B               OUT     0x3B, R16
    336                }
    337                #endif            
    338                address = address<<1;             // convert from byte address to word address
   \   00000102   0F88               LSL     R24
   \   00000104   1F99               ROL     R25
    339                for (i = 0; i < Nobytes; i+=2, address+=2) {   // receive the whole buffer
   \   00000106   2444               CLR     R4
   \   00000108   2455               CLR     R5
   \   0000010A   2D06               MOV     R16, R6
   \   0000010C   2907               OR      R16, R7
   \   0000010E   F171               BREQ    ??ReadFlash_2
    340                   intval = read_program_memory(address,0x00);
   \                     ??ReadFlash_5:
   \   00000110   E020               LDI     R18, 0
   \   00000112   018C               MOVW    R17:R16, R25:R24
   \   00000114   ........           CALL    read_program_memory
   \   00000118   2F31               MOV     R19, R17
    341                   UART[ch].pTxBuffer[UART[ch].TxFirst++] = intval & 0xff;
   \   0000011A   2F40               MOV     R20, R16
   \   0000011C   910D               LD      R16, X+
   \   0000011E   911C               LD      R17, X
   \   00000120   9711               SBIW    R27:R26, 1
   \   00000122   01FD               MOVW    R31:R30, R27:R26
   \   00000124   8162               LDD     R22, Z+2
   \   00000126   8173               LDD     R23, Z+3
   \   00000128   0F06               ADD     R16, R22
   \   0000012A   1F17               ADC     R17, R23
   \   0000012C   01F8               MOVW    R31:R30, R17:R16
   \   0000012E   8340               ST      Z, R20
   \   00000130   01FD               MOVW    R31:R30, R27:R26
   \   00000132   8102               LDD     R16, Z+2
   \   00000134   8113               LDD     R17, Z+3
   \   00000136   5F0F               SUBI    R16, 255
   \   00000138   4F1F               SBCI    R17, 255
   \   0000013A   8302               STD     Z+2, R16
   \   0000013C   8313               STD     Z+3, R17
    342                   UART[ch].pTxBuffer[UART[ch].TxFirst++] = (intval>>8) & 0xff;
   \   0000013E   8100               LD      R16, Z
   \   00000140   8111               LDD     R17, Z+1
   \   00000142   8142               LDD     R20, Z+2
   \   00000144   8153               LDD     R21, Z+3
   \   00000146   0F04               ADD     R16, R20
   \   00000148   1F15               ADC     R17, R21
   \   0000014A   01F8               MOVW    R31:R30, R17:R16
   \   0000014C   8330               ST      Z, R19
   \   0000014E   01FD               MOVW    R31:R30, R27:R26
   \   00000150   8102               LDD     R16, Z+2
   \   00000152   8113               LDD     R17, Z+3
   \   00000154   5F0F               SUBI    R16, 255
   \   00000156   4F1F               SBCI    R17, 255
   \   00000158   8302               STD     Z+2, R16
   \   0000015A   8313               STD     Z+3, R17
    343                }
   \   0000015C   E002               LDI     R16, 2
   \   0000015E   0E40               ADD     R4, R16
   \   00000160   E000               LDI     R16, 0
   \   00000162   1E50               ADC     R5, R16
   \   00000164   9602               ADIW    R25:R24, 2
   \   00000166   1446               CP      R4, R6
   \   00000168   0457               CPC     R5, R7
   \   0000016A   F290               BRCS    ??ReadFlash_5
    344              }
    345          
    346              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2)  & 0xff ;      // length of data block lb
   \                     ??ReadFlash_2:
   \   0000016C   01FD               MOVW    R31:R30, R27:R26
   \   0000016E   8102               LDD     R16, Z+2
   \   00000170   1908               SUB     R16, R8
   \   00000172   5002               SUBI    R16, 2
   \   00000174   91ED               LD      R30, X+
   \   00000176   91FC               LD      R31, X
   \   00000178   9711               SBIW    R27:R26, 1
   \   0000017A   0DE8               ADD     R30, R8
   \   0000017C   1DF9               ADC     R31, R9
   \   0000017E   8300               ST      Z, R16
    347              UART[ch].pTxBuffer[ntna+1] = ((UART[ch].TxFirst - ntna - 2) >> 8 ) & 0xff ; // length of data block hb
   \   00000180   01FD               MOVW    R31:R30, R27:R26
   \   00000182   8182               LDD     R24, Z+2
   \   00000184   8193               LDD     R25, Z+3
   \   00000186   1988               SUB     R24, R8
   \   00000188   0999               SBC     R25, R9
   \   0000018A   9702               SBIW    R25:R24, 2
   \   0000018C   91ED               LD      R30, X+
   \   0000018E   91FC               LD      R31, X
   \   00000190   0DE8               ADD     R30, R8
   \   00000192   1DF9               ADC     R31, R9
   \   00000194   8391               STD     Z+1, R25
    348          
    349          }
   \   00000196   9189               LD      R24, Y+
   \   00000198   9199               LD      R25, Y+
   \   0000019A   91A9               LD      R26, Y+
   \   0000019C   91B9               LD      R27, Y+
   \   0000019E   9049               LD      R4, Y+
   \   000001A0   9059               LD      R5, Y+
   \   000001A2   9069               LD      R6, Y+
   \   000001A4   9079               LD      R7, Y+
   \   000001A6   9089               LD      R8, Y+
   \   000001A8   9099               LD      R9, Y+
   \   000001AA   9508               RET
   \   000001AC                      REQUIRE _A_RAMPZ
    350          
    351          /*************************************************************************
    352          *
    353          *  Exit bootloader program
    354          *
    355          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    356          void ExitBootloader(char ch) {   
   \                     ExitBootloader:
    357          
    358          
    359              while ( (EECR & 1<<EEWE) != 0 ) //chech if EEPROM is ready
   \                     ??ExitBootloader_0:
   \   00000000   99E1               SBIC    0x1C, 0x01
   \   00000002   CFFE               RJMP    ??ExitBootloader_0
    360                  ;
    361              EEARL = (0x0fff & 0xff);
   \   00000004   EF0F               LDI     R16, 255
   \   00000006   BB0E               OUT     0x1E, R16
    362              EEARH = (0x0fff >> 8);
   \   00000008   E00F               LDI     R16, 15
   \   0000000A   BB0F               OUT     0x1F, R16
    363              EEDR = 0xaa;
   \   0000000C   EA0A               LDI     R16, 170
   \   0000000E   BB0D               OUT     0x1D, R16
    364              EECR |= (1<<EEMWE);
   \   00000010   9AE2               SBI     0x1C, 0x02
    365              EECR |= (1<<EEWE);
   \   00000012   9AE1               SBI     0x1C, 0x01
    366              while (EECR & (1<<EEWE))
   \                     ??ExitBootloader_1:
   \   00000014   99E1               SBIC    0x1C, 0x01
   \   00000016   CFFE               RJMP    ??ExitBootloader_1
    367                ;
    368                
    369              WDTCR = 0x08;               //Start watchdog to genetate restart
   \   00000018   E008               LDI     R16, 8
   \   0000001A   BD01               OUT     0x21, R16
    370          }
   \   0000001C   9508               RET
   \   0000001E                      REQUIRE _A_EECR
   \   0000001E                      REQUIRE _A_EEAR
   \   0000001E                      REQUIRE _A_EEDR
   \   0000001E                      REQUIRE _A_WDTCR
    371          
    372          
    373          /*************************************************************************
    374          *
    375          *  Transmitting data on USARTs
    376          *
    377          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    378          void SendPacketUart(char ch) {
   \                     SendPacketUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
   \   00000006   2F80               MOV     R24, R16
    379              unsigned short delay, cnt;
    380              
    381              for (delay = 0; delay < 0xffff; delay++) {
   \   00000008   EFEF               LDI     R30, 255
   \   0000000A   EFFF               LDI     R31, 255
    382                  asm("nop") ;
   \                     ??SendPacketUart_0:
   \   0000000C   0000               nop
    383                  cnt++;
    384              }
   \   0000000E   9731               SBIW    R31:R30, 1
   \   00000010   F7E9               BRNE    ??SendPacketUart_0
    385          
    386              while ( UART[ch].TxCount > 0 ) {               // Any characters to send?
   \                     ??SendPacketUart_1:
   \   00000012   E10D               LDI     R16, 29
   \   00000014   9F80               MUL     R24, R16
   \   00000016   ....               LDI     R26, LOW(UART)
   \   00000018   ....               LDI     R27, (UART) >> 8
   \   0000001A   0DA0               ADD     R26, R0
   \   0000001C   1DB1               ADC     R27, R1
   \   0000001E   01FD               MOVW    R31:R30, R27:R26
   \   00000020   8106               LDD     R16, Z+6
   \   00000022   8117               LDD     R17, Z+7
   \   00000024   2B01               OR      R16, R17
   \   00000026   F101               BREQ    ??SendPacketUart_2
    387                  sendchar(ch, UART[ch].pTxBuffer[ UART[ch].TxLast ]);  // Send a character
   \   00000028   91ED               LD      R30, X+
   \   0000002A   91FC               LD      R31, X
   \   0000002C   9613               ADIW    R27:R26, 3
   \   0000002E   910D               LD      R16, X+
   \   00000030   911C               LD      R17, X
   \   00000032   9715               SBIW    R27:R26, 5
   \   00000034   0FE0               ADD     R30, R16
   \   00000036   1FF1               ADC     R31, R17
   \   00000038   8110               LD      R17, Z
   \   0000003A   2F08               MOV     R16, R24
   \   0000003C   ........           CALL    sendchar
    388          
    389                  if ((++UART[ch].TxLast)> TXSIZE_UART ) {     // End of buffer?
   \   00000040   01FD               MOVW    R31:R30, R27:R26
   \   00000042   8104               LDD     R16, Z+4
   \   00000044   8115               LDD     R17, Z+5
   \   00000046   5F0F               SUBI    R16, 255
   \   00000048   4F1F               SBCI    R17, 255
   \   0000004A   8304               STD     Z+4, R16
   \   0000004C   8315               STD     Z+5, R17
   \   0000004E   350F               CPI     R16, 95
   \   00000050   4011               SBCI    R17, 1
   \   00000052   F018               BRCS    ??SendPacketUart_3
    390                      UART[ch].TxLast = 0 ;                     // yes, reset pointer
   \   00000054   E000               LDI     R16, 0
   \   00000056   8304               STD     Z+4, R16
   \   00000058   8305               STD     Z+5, R16
    391                  }
    392                  UART[ch].TxCount--; 
   \                     ??SendPacketUart_3:
   \   0000005A   8106               LDD     R16, Z+6
   \   0000005C   8117               LDD     R17, Z+7
   \   0000005E   5001               SUBI    R16, 1
   \   00000060   4010               SBCI    R17, 0
   \   00000062   8306               STD     Z+6, R16
   \   00000064   8317               STD     Z+7, R17
   \   00000066   CFD5               RJMP    ??SendPacketUart_1
    393              } 
    394              if (ch == 0){                                           // Turn on TXE for channel
   \                     ??SendPacketUart_2:
   \   00000068   2388               TST     R24
   \   0000006A   F411               BRNE    ??SendPacketUart_4
    395                  PORTE &= ~0x04 ;                                     // TXE0 off
   \   0000006C   981A               CBI     0x03, 0x02
   \   0000006E   C003               RJMP    ??SendPacketUart_5
    396              } else if (ch ==1){
   \                     ??SendPacketUart_4:
   \   00000070   3081               CPI     R24, 1
   \   00000072   F409               BRNE    ??SendPacketUart_5
    397                  PORTE &= ~0x08 ;                                     // TXE1 off
   \   00000074   981B               CBI     0x03, 0x03
    398              }
    399              cnt = 0;
    400          }
   \                     ??SendPacketUart_5:
   \   00000076   9189               LD      R24, Y+
   \   00000078   91A9               LD      R26, Y+
   \   0000007A   91B9               LD      R27, Y+
   \   0000007C   9508               RET
   \   0000007E                      REQUIRE _A_PORTE
    401          
    402          /*************************************************************************
    403          *
    404          *  Receive data on USARTs
    405          *
    406          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    407          void ReceivePacketUart(char ch) {
   \                     ReceivePacketUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008   2F80               MOV     R24, R16
    408          
    409              switch (UART[ch].RxState) {                  // check status 
   \   0000000A   E10D               LDI     R16, 29
   \   0000000C   9F80               MUL     R24, R16
   \   0000000E   ....               LDI     R26, LOW(UART)
   \   00000010   ....               LDI     R27, (UART) >> 8
   \   00000012   0DA0               ADD     R26, R0
   \   00000014   1DB1               ADC     R27, R1
   \   00000016   01FD               MOVW    R31:R30, R27:R26
   \   00000018   8904               LDD     R16, Z+20
   \   0000001A   2300               TST     R16
   \   0000001C   F409               BRNE    $+2+2
   \   0000001E   C09E               RJMP    ??ReceivePacketUart_0
   \   00000020   950A               DEC     R16
   \   00000022   F039               BREQ    ??ReceivePacketUart_1
   \   00000024   950A               DEC     R16
   \   00000026   F409               BRNE    $+2+2
   \   00000028   C04C               RJMP    ??ReceivePacketUart_2
   \   0000002A   5008               SUBI    R16, 8
   \   0000002C   F409               BRNE    $+2+2
   \   0000002E   C096               RJMP    ??ReceivePacketUart_0
   \   00000030   C093               RJMP    ??ReceivePacketUart_3
    410              case SYNC :
    411                  // all functionallity in inerrupt routine 
    412                  break ;
    413              case HEADER :
    414                  if (UART[ch].RxLast >= 6) {             // receive header 
   \                     ??ReceivePacketUart_1:
   \   00000032   8900               LDD     R16, Z+16
   \   00000034   8911               LDD     R17, Z+17
   \   00000036   3006               CPI     R16, 6
   \   00000038   4010               SBCI    R17, 0
   \   0000003A   F408               BRCC    $+2+2
   \   0000003C   C08F               RJMP    ??ReceivePacketUart_0
    415                      UART[ch].RxPacklen = (UART[ch].pRxBuffer[4] +
    416                                           (UART[ch].pRxBuffer[5] * 256) ) ;    // Find length of package
   \   0000003E   8504               LDD     R16, Z+12
   \   00000040   85F5               LDD     R31, Z+13
   \   00000042   2FE0               MOV     R30, R16
   \   00000044   8104               LDD     R16, Z+4
   \   00000046   8115               LDD     R17, Z+5
   \   00000048   01FD               MOVW    R31:R30, R27:R26
   \   0000004A   8F00               STD     Z+24, R16
   \   0000004C   8F11               STD     Z+25, R17
    417                      if (CalcDSRxChecksum(ch, 6) && (UART[ch].pRxBuffer[0] == (0x10 + UnitID))) { 
   \   0000004E   E060               LDI     R22, 0
   \   00000050   8544               LDD     R20, Z+12
   \   00000052   8555               LDD     R21, Z+13
   \   00000054   018A               MOVW    R17:R16, R21:R20
   \   00000056   E026               LDI     R18, 6
   \   00000058   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_4:
   \   0000005A   01F8               MOVW    R31:R30, R17:R16
   \   0000005C   9001               LD      R0, Z+
   \   0000005E   018F               MOVW    R17:R16, R31:R30
   \   00000060   2560               EOR     R22, R0
   \   00000062   2FE6               MOV     R30, R22
   \   00000064   E0F0               LDI     R31, 0
   \   00000066   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000068   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000006A   BF3B               OUT     0x3B, R19
   \   0000006C   9166               ELPM    R22, Z
   \   0000006E   952A               DEC     R18
   \   00000070   F7A1               BRNE    ??ReceivePacketUart_4
   \   00000072   01FA               MOVW    R31:R30, R21:R20
   \   00000074   8106               LDD     R16, Z+6
   \   00000076   1760               CP      R22, R16
   \   00000078   F009               BREQ    $+2+2
   \   0000007A   C06E               RJMP    ??ReceivePacketUart_3
   \   0000007C   8100               LD      R16, Z
   \   0000007E   E010               LDI     R17, 0
   \   00000080   91E0....           LDS     R30, UnitID
   \   00000084   E0F0               LDI     R31, 0
   \   00000086   9670               ADIW    R31:R30, 16
   \   00000088   170E               CP      R16, R30
   \   0000008A   071F               CPC     R17, R31
   \   0000008C   F009               BREQ    $+2+2
   \   0000008E   C064               RJMP    ??ReceivePacketUart_3
    418                                                           // header checksum OK and to me
    419                          if ((UART[ch].RxPacklen < ((short) RXSIZE_UART-UART[ch].RxLast)) &&    /* chk. header */
    420                              (UART[ch].RxPacklen >= MIN_PACK_LEN)) {
   \   00000090   01FD               MOVW    R31:R30, R27:R26
   \   00000092   8D20               LDD     R18, Z+24
   \   00000094   8D31               LDD     R19, Z+25
   \   00000096   E50E               LDI     R16, 94
   \   00000098   E011               LDI     R17, 1
   \   0000009A   8940               LDD     R20, Z+16
   \   0000009C   8951               LDD     R21, Z+17
   \   0000009E   1B04               SUB     R16, R20
   \   000000A0   0B15               SBC     R17, R21
   \   000000A2   1720               CP      R18, R16
   \   000000A4   0731               CPC     R19, R17
   \   000000A6   F008               BRCS    $+2+2
   \   000000A8   C057               RJMP    ??ReceivePacketUart_3
   \   000000AA   3027               CPI     R18, 7
   \   000000AC   4030               SBCI    R19, 0
   \   000000AE   F408               BRCC    $+2+2
   \   000000B0   C053               RJMP    ??ReceivePacketUart_3
    421                              UART[ch].RxState = RECEIVE ;       // Header ok og to data receive state
   \   000000B2   E002               LDI     R16, 2
   \   000000B4   8B04               STD     Z+20, R16
    422                              UART[ch].RxCount = UART[ch].RxLast + 1 ;    // Set receive counter
   \   000000B6   8980               LDD     R24, Z+16
   \   000000B8   8991               LDD     R25, Z+17
   \   000000BA   9601               ADIW    R25:R24, 1
   \   000000BC   8B82               STD     Z+18, R24
   \   000000BE   8B93               STD     Z+19, R25
   \   000000C0   C04D               RJMP    ??ReceivePacketUart_0
    423                          } else {
    424                              GoToSyncUART(ch) ;                        // go to sync modus for recive
    425                          }
    426                      } else {
    427                          GoToSyncUART(ch) ;                            // go to sync modus for recive
    428                      }
    429                  }
    430                  break ;
    431              case RECEIVE :
    432                  if (++UART[ch].RxCount >= UART[ch].RxPacklen) {
   \                     ??ReceivePacketUart_2:
   \   000000C2   8902               LDD     R16, Z+18
   \   000000C4   8913               LDD     R17, Z+19
   \   000000C6   5F0F               SUBI    R16, 255
   \   000000C8   4F1F               SBCI    R17, 255
   \   000000CA   8B02               STD     Z+18, R16
   \   000000CC   8B13               STD     Z+19, R17
   \   000000CE   8D20               LDD     R18, Z+24
   \   000000D0   8D31               LDD     R19, Z+25
   \   000000D2   1702               CP      R16, R18
   \   000000D4   0713               CPC     R17, R19
   \   000000D6   F408               BRCC    $+2+2
   \   000000D8   C041               RJMP    ??ReceivePacketUart_0
    433                      if ((UART[ch].pRxBuffer[UART[ch].RxPacklen -1]) == ANPRO10_EOT) {
   \   000000DA   0119               MOVW    R3:R2, R19:R18
   \   000000DC   8504               LDD     R16, Z+12
   \   000000DE   8515               LDD     R17, Z+13
   \   000000E0   0F02               ADD     R16, R18
   \   000000E2   1F13               ADC     R17, R19
   \   000000E4   5001               SUBI    R16, 1
   \   000000E6   4010               SBCI    R17, 0
   \   000000E8   01F8               MOVW    R31:R30, R17:R16
   \   000000EA   8100               LD      R16, Z
   \   000000EC   3004               CPI     R16, 4
   \   000000EE   F5A1               BRNE    ??ReceivePacketUart_3
    434                          if (CalcDSRxChecksum(ch, UART[ch].RxPacklen-2)) {
   \   000000F0   EF0E               LDI     R16, 254
   \   000000F2   0E20               ADD     R2, R16
   \   000000F4   EF0F               LDI     R16, 255
   \   000000F6   1E30               ADC     R3, R16
   \   000000F8   2400               CLR     R0
   \   000000FA   01FD               MOVW    R31:R30, R27:R26
   \   000000FC   8564               LDD     R22, Z+12
   \   000000FE   8575               LDD     R23, Z+13
   \   00000100   2D02               MOV     R16, R2
   \   00000102   2903               OR      R16, R3
   \   00000104   F081               BREQ    ??ReceivePacketUart_5
   \   00000106   018B               MOVW    R17:R16, R23:R22
   \   00000108   01A1               MOVW    R21:R20, R3:R2
   \   0000010A   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_6:
   \   0000010C   01F8               MOVW    R31:R30, R17:R16
   \   0000010E   9121               LD      R18, Z+
   \   00000110   018F               MOVW    R17:R16, R31:R30
   \   00000112   2602               EOR     R0, R18
   \   00000114   2DE0               MOV     R30, R0
   \   00000116   E0F0               LDI     R31, 0
   \   00000118   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000011A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000011C   BF3B               OUT     0x3B, R19
   \   0000011E   9006               ELPM    R0, Z
   \   00000120   5041               SUBI    R20, 1
   \   00000122   4050               SBCI    R21, 0
   \   00000124   F799               BRNE    ??ReceivePacketUart_6
   \                     ??ReceivePacketUart_5:
   \   00000126   0D62               ADD     R22, R2
   \   00000128   1D73               ADC     R23, R3
   \   0000012A   01FB               MOVW    R31:R30, R23:R22
   \   0000012C   8100               LD      R16, Z
   \   0000012E   1600               CP      R0, R16
   \   00000130   F499               BRNE    ??ReceivePacketUart_3
    435                              if ((UART[ch].pRxBuffer[1] == MyAddress())||       // message to me? or
    436                                   (UART[ch].pRxBuffer[1] == 0xff)) {            // broadcast
   \   00000132   ........           CALL    MyAddress
   \   00000136   2F20               MOV     R18, R16
   \   00000138   01FD               MOVW    R31:R30, R27:R26
   \   0000013A   8504               LDD     R16, Z+12
   \   0000013C   85F5               LDD     R31, Z+13
   \   0000013E   2FE0               MOV     R30, R16
   \   00000140   8131               LDD     R19, Z+1
   \   00000142   1732               CP      R19, R18
   \   00000144   F011               BREQ    ??ReceivePacketUart_7
   \   00000146   3F3F               CPI     R19, 255
   \   00000148   F439               BRNE    ??ReceivePacketUart_3
    437                                  hostAddress = UART[ch].pRxBuffer[3];            // address to sender (host)
   \                     ??ReceivePacketUart_7:
   \   0000014A   8103               LDD     R16, Z+3
   \   0000014C   9300....           STS     hostAddress, R16
    438                                  UART[ch].RxState = HANDLE ;                     // Package OK
   \   00000150   01FD               MOVW    R31:R30, R27:R26
   \   00000152   E00A               LDI     R16, 10
   \   00000154   8B04               STD     Z+20, R16
   \   00000156   C002               RJMP    ??ReceivePacketUart_0
    439                              } else {
    440                                  GoToSyncUART(ch) ;                             // go to sync modus for recive
    441                              }
    442                          } else {
    443                              GoToSyncUART(ch) ;                                // go to sync modus for recive
    444                          }
    445                      } else {
    446                          GoToSyncUART(ch) ;                                    // go to sync modus for recive
    447                      }
    448                  }
    449                  break ;
    450              case HANDLE :
    451                  break;
    452              default :
    453                  GoToSyncUART(ch) ;                                            // go to sync modus for recive
   \                     ??ReceivePacketUart_3:
   \   00000158   2F08               MOV     R16, R24
   \   0000015A   ....               RCALL   GoToSyncUART
    454                  break ;
    455              }                                                           // end switch 
    456              if (++UART[ch].RxLast >= RXSIZE_UART) {                     // check pointer 
   \                     ??ReceivePacketUart_0:
   \   0000015C   01FD               MOVW    R31:R30, R27:R26
   \   0000015E   8900               LDD     R16, Z+16
   \   00000160   8911               LDD     R17, Z+17
   \   00000162   5F0F               SUBI    R16, 255
   \   00000164   4F1F               SBCI    R17, 255
   \   00000166   8B00               STD     Z+16, R16
   \   00000168   8B11               STD     Z+17, R17
   \   0000016A   350E               CPI     R16, 94
   \   0000016C   4011               SBCI    R17, 1
   \   0000016E   F018               BRCS    ??ReceivePacketUart_8
    457                  UART[ch].RxLast = 0;                                     // reset pointer
   \   00000170   E000               LDI     R16, 0
   \   00000172   8B00               STD     Z+16, R16
   \   00000174   8B01               STD     Z+17, R16
    458              }
    459          }
   \                     ??ReceivePacketUart_8:
   \   00000176   9189               LD      R24, Y+
   \   00000178   9199               LD      R25, Y+
   \   0000017A   91A9               LD      R26, Y+
   \   0000017C   91B9               LD      R27, Y+
   \   0000017E   9508               RET
    460          /*************************************************************************
    461          *
    462          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    463          *
    464          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    465          char CalcDSTxChecksum(char ch, unsigned short len) {
   \                     CalcDSTxChecksum:
   \   00000000   01BD               MOVW    R23:R22, R27:R26
   \   00000002   01AC               MOVW    R21:R20, R25:R24
   \   00000004   2F10               MOV     R17, R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
    466          
    467              unsigned short  cnt ;
    468              unsigned char   csum ;
    469          
    470              csum = 0 ;
   \   00000008   E000               LDI     R16, 0
    471              for (cnt = 4 ; cnt < len ; cnt++) {
   \   0000000A   3025               CPI     R18, 5
   \   0000000C   4030               SBCI    R19, 0
   \   0000000E   F0A0               BRCS    ??CalcDSTxChecksum_0
   \   00000010   E12D               LDI     R18, 29
   \   00000012   9F12               MUL     R17, R18
   \   00000014   01F0               MOVW    R31:R30, R1:R0
   \   00000016   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000018   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000001A   81A0               LD      R26, Z
   \   0000001C   81B1               LDD     R27, Z+1
   \   0000001E   9614               ADIW    R27:R26, 4
   \   00000020   9704               SBIW    R25:R24, 4
   \   00000022   ....               LDI     R19, (crc) >> 16
    472                  csum = crc[csum ^ UART[ch].pTxBuffer[cnt]] ;
   \                     ??CalcDSTxChecksum_1:
   \   00000024   2FE0               MOV     R30, R16
   \   00000026   E0F0               LDI     R31, 0
   \   00000028   910D               LD      R16, X+
   \   0000002A   27E0               EOR     R30, R16
   \   0000002C   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000002E   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000030   BF3B               OUT     0x3B, R19
   \   00000032   9106               ELPM    R16, Z
    473              }
   \   00000034   9701               SBIW    R25:R24, 1
   \   00000036   F7B1               BRNE    ??CalcDSTxChecksum_1
    474              return csum ;
   \                     ??CalcDSTxChecksum_0:
   \   00000038   01CA               MOVW    R25:R24, R21:R20
   \   0000003A   01DB               MOVW    R27:R26, R23:R22
   \   0000003C   9508               RET
    475          }
    476          
    477          /*************************************************************************
    478          *
    479          * Calculate rx packet checksum (header and package) using Dallas Semiconductor one-wire CRC
    480          *
    481          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    482          short CalcDSRxChecksum(char ch, unsigned short len) {
   \                     CalcDSRxChecksum:
   \   00000000   939A               ST      -Y, R25
   \   00000002   2F58               MOV     R21, R24
   \   00000004   0119               MOVW    R3:R2, R19:R18
    483          
    484              unsigned short  cnt ;
    485              unsigned char   csum ;
    486          
    487              csum = 0 ;
   \   00000006   E040               LDI     R20, 0
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   8564               LDD     R22, Z+12
   \   00000016   8575               LDD     R23, Z+13
   \   00000018   2923               OR      R18, R3
   \   0000001A   F081               BREQ    ??CalcDSRxChecksum_0
   \   0000001C   018B               MOVW    R17:R16, R23:R22
   \   0000001E   2D82               MOV     R24, R2
   \   00000020   2F93               MOV     R25, R19
   \   00000022   ....               LDI     R19, (crc) >> 16
    488              for (cnt=0 ; cnt < len ; cnt++) {
    489                  csum = crc[csum ^ UART[ch].pRxBuffer[cnt]] ;
   \                     ??CalcDSRxChecksum_1:
   \   00000024   01F8               MOVW    R31:R30, R17:R16
   \   00000026   9121               LD      R18, Z+
   \   00000028   018F               MOVW    R17:R16, R31:R30
   \   0000002A   2742               EOR     R20, R18
   \   0000002C   2FE4               MOV     R30, R20
   \   0000002E   E0F0               LDI     R31, 0
   \   00000030   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000032   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000034   BF3B               OUT     0x3B, R19
   \   00000036   9146               ELPM    R20, Z
    490              }
   \   00000038   9701               SBIW    R25:R24, 1
   \   0000003A   F7A1               BRNE    ??CalcDSRxChecksum_1
    491              if (csum == UART[ch].pRxBuffer[len]) {
   \                     ??CalcDSRxChecksum_0:
   \   0000003C   0D62               ADD     R22, R2
   \   0000003E   1D73               ADC     R23, R3
   \   00000040   01FB               MOVW    R31:R30, R23:R22
   \   00000042   8100               LD      R16, Z
   \   00000044   1740               CP      R20, R16
   \   00000046   F411               BRNE    ??CalcDSRxChecksum_2
    492                  return true ;
   \   00000048   E001               LDI     R16, 1
   \   0000004A   C001               RJMP    ??CalcDSRxChecksum_3
    493              } else {
    494                  return false ;
   \                     ??CalcDSRxChecksum_2:
   \   0000004C   E000               LDI     R16, 0
   \                     ??CalcDSRxChecksum_3:
   \   0000004E   E010               LDI     R17, 0
   \   00000050   2F85               MOV     R24, R21
   \   00000052   9199               LD      R25, Y+
   \   00000054   9508               RET
    495              }
    496          }
    497          
    498          /*************************************************************************
    499          *
    500          * Goes to sync mode
    501          *
    502          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    503          __monitor void GoToSyncUART(char ch) {
   \                     GoToSyncUART:
   \   00000000   B72F               IN      R18, 0x3F
   \   00000002   94F8               CLI
    504          
    505              if (ch < 2) {
   \   00000004   3002               CPI     R16, 2
   \   00000006   F458               BRCC    ??GoToSyncUART_0
    506                  UART[ch].SyncCnt = 0 ;                        // ready for sync
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E000               LDI     R16, 0
   \   00000016   8B05               STD     Z+21, R16
    507                  UART[ch].RxState = SYNC ;
   \   00000018   8B04               STD     Z+20, R16
    508                  UART[ch].RxFirst = 0 ;
   \   0000001A   8706               STD     Z+14, R16
   \   0000001C   8707               STD     Z+15, R16
    509              }
    510          }
   \                     ??GoToSyncUART_0:
   \   0000001E   BF2F               OUT     0x3F, R18
   \   00000020   9508               RET

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   BuildFlashID
      6      2   BuildStatusData
        6      2   -> MyAddress
      1      2   CalcDSRxChecksum
      0      2   CalcDSTxChecksum
      3      2   CheckActionUart
        3      2   -> BuildFlashID
        3      2   -> BuildStatusData
        3      2   -> EraseFlash
        3      2   -> ExitBootloader
        3      2   -> ProgramFlash
        3      2   -> ReadFlash
      6      2   EraseFlash
        6      2   -> write_page
      0      2   ExitBootloader
      0      2   GoToSyncUART
     16      2   ProgramFlash
       16      2   -> fill_temp_buffer
       16      2   -> read_program_memory
       16      2   -> write_page
     10      2   ReadFlash
       10      2   -> read_program_memory
      4      2   ReceivePacketUart
        4      2   -> GoToSyncUART
        4      2   -> MyAddress
      3      2   SendPacketUart
        3      2   -> sendchar
      2      2   Uart_BuildHeader
        2      2   -> MyAddress
      3      2   Uart_BuildTail
        3      2   -> CalcDSTxChecksum
        3      2   -> SendPacketUart
        3      2   -> Uart_BuildHeader
      5      2   UsartCheckPackage
        5      2   -> CheckActionUart
        5      2   -> GoToSyncUART
        5      2   -> Uart_BuildTail


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      14  ?Subroutine0
     220  BuildFlashID
     534  BuildStatusData
      86  CalcDSRxChecksum
      62  CalcDSTxChecksum
     116  CheckActionUart
     234  EraseFlash
      30  ExitBootloader
      34  GoToSyncUART
     566  ProgramFlash
     428  ReadFlash
     384  ReceivePacketUart
     126  SendPacketUart
     156  Uart_BuildHeader
     364  Uart_BuildTail
     122  UsartCheckPackage
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_RAMPZ
       1  _A_WDTCR

 
     7 bytes in segment ABSOLUTE
 3 476 bytes in segment CODE
 
 3 476 bytes of CODE memory
     0 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
