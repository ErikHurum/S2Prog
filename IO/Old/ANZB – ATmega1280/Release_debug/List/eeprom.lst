###############################################################################
#
# IAR C/C++ Compiler V6.70.1.929 for Atmel AVR            07/Feb/2017  14:17:40
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Atmel AVR 6.80
#
#    Source file  =  D:\S2Prog\IO\ANZB\Src\eeprom.c
#    Command line =  
#        D:\S2Prog\IO\ANZB\Src\eeprom.c --cpu=m128 -ms -o
#        D:\S2Prog\IO\ANZB\Release_debug\Obj -D OS_LIBMODE_S -D OS_UART=0 -lCN
#        D:\S2Prog\IO\ANZB\Release_debug\List -y --initializers_in_flash
#        --no_tbaa -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\ANZB\INC\ -I
#        D:\S2Prog\IO\ANZB\..\..\SHARED\INC\ --eeprom_size 4096 --clib -Ohz
#    List file    =  D:\S2Prog\IO\ANZB\Release_debug\List\eeprom.lst
#    Object file  =  D:\S2Prog\IO\ANZB\Release_debug\Obj\eeprom.r90
#
###############################################################################

D:\S2Prog\IO\ANZB\Src\eeprom.c
      1          /****************************************************************************************
      2          / Read and write the eeprom
      3          /
      4          ***************************************************************************************/
      5          #include "iom128.h"

   \                                 In  segment ABSOLUTE, at 0x3c
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3e
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_WDTCR
   \                     _A_WDTCR:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          
     12          
     13          /*---------------------------------------------------------------------------
     14          **
     15          **  See how many date i remining
     16          **
     17          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     18          char TestEEPROM( void ) {
   \                     TestEEPROM:
     19          
     20              return WriteCount;
   \   00000000   9100....           LDS     R16, WriteCount
   \   00000004   9508               RET
     21          }
     22          
     23          /*---------------------------------------------------------------------------
     24          **
     25          **  Reads an address in the eeprom
     26          **
     27          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     28          char ReadEEPROMByte( unsigned int Address ) {
   \                     ReadEEPROMByte:
   \                     ??ReadEEPROMByte_0:
     29          
     30              unsigned char Data;
     31          
     32              while (EECR & (1<<EEWE))     // Wait until ready
   \   00000000   99E1               SBIC    0x1C, 0x01
   \   00000002   CFFE               RJMP    ??ReadEEPROMByte_0
     33                  ;
     34              EEAR = Address;
   \   00000004   ....               RCALL   ?Subroutine3
     35              OS_IncDI();
   \                     ??CrossCallReturnLabel_2:
   \   00000006   94F8               CLI
     36              EECR |= (1 << EERE) ;       // Don't use SetBit macrod due to timing
   \   00000008   9AE0               SBI     0x1C, 0x00
     37              OS_DecRI();
   \   0000000A   ....               RCALL   ?Subroutine1
     38          
     39              Data = EEDR;
     40              return Data;
   \                     ??CrossCallReturnLabel_10:
   \   0000000C   B30D               IN      R16, 0x1D
   \   0000000E   9508               RET
   \   00000010                      REQUIRE _A_EECR
   \   00000010                      REQUIRE _A_EEAR
   \   00000010                      REQUIRE _A_EEDR
     41          
     42          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   9100....           LDS     R16, (OS_Counters + 1)
   \   00000004   2300               TST     R16
   \   00000006                      REQUIRE ?Subroutine5
   \   00000006                      ;               // Fall through to label ?Subroutine5

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   F409               BRNE    ??Subroutine5_0
   \   00000002   9478               SEI
   \                     ??Subroutine5_0:
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   BB1F               OUT     0x1F, R17
   \   00000002   BB0E               OUT     0x1E, R16
   \   00000004   9508               RET
     43          
     44          /*---------------------------------------------------------------------------
     45          **
     46          **  Write a caracther to the eeprom
     47          **
     48          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     49          void WriteEEPROMByte( unsigned int Address, char Data ) {   
   \                     WriteEEPROMByte:
   \                     ??WriteEEPROMByte_0:
     50          
     51              while (EECR & (1<<EEWE))     // Wait until ready
   \   00000000   99E1               SBIC    0x1C, 0x01
   \   00000002   CFFE               RJMP    ??WriteEEPROMByte_0
     52                  ;
     53              OS_IncDI();
   \   00000004   94F8               CLI
     54              EEAR = Address;
   \   00000006   ....               RCALL   ?Subroutine3
     55              EEDR = Data;
   \                     ??CrossCallReturnLabel_3:
   \   00000008   BB2D               OUT     0x1D, R18
     56              EECR |= (1 << EEMWE) ;       // Don't use SetBit macrod due to timing
   \   0000000A   ....               RCALL   ?Subroutine4
     57              EECR |= (1 << EEWE) ;        // Don't use SetBit macrod due to timing
     58              OS_DecRI();
   \                     ??CrossCallReturnLabel_6:
   \   0000000C                      REQUIRE ?Subroutine1
   \   0000000C                      REQUIRE _A_EECR
   \   0000000C                      REQUIRE _A_EEAR
   \   0000000C                      REQUIRE _A_EEDR
   \   0000000C                      ;               // Fall through to label ?Subroutine1
     59          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   9AE2               SBI     0x1C, 0x02
   \   00000002   9AE1               SBI     0x1C, 0x01
   \   00000004   9508               RET
     60          
     61          /*---------------------------------------------------------------------------
     62          **
     63          **  Read a tring from the eeprom
     64          **
     65          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     66          void ReadEEPROMBuffer( unsigned int Address, char Size, char *pData ) {   
   \                     ReadEEPROMBuffer:
   \   00000000   010C               MOVW    R1:R0, R25:R24
   \   00000002   01B8               MOVW    R23:R22, R17:R16
     67              unsigned int Index;
     68          
     69              for ( Index = 0; Index < Size; Index++ ) {
   \   00000004   E080               LDI     R24, 0
   \   00000006   E090               LDI     R25, 0
   \   00000008   E030               LDI     R19, 0
   \   0000000A   C008               RJMP    ??ReadEEPROMBuffer_0
     70                  *pData++ = ReadEEPROMByte( Address + Index );
   \                     ??ReadEEPROMBuffer_1:
   \   0000000C   018B               MOVW    R17:R16, R23:R22
   \   0000000E   0F08               ADD     R16, R24
   \   00000010   1F19               ADC     R17, R25
   \   00000012   ....               RCALL   ReadEEPROMByte
   \   00000014   01FA               MOVW    R31:R30, R21:R20
   \   00000016   9301               ST      Z+, R16
   \   00000018   01AF               MOVW    R21:R20, R31:R30
     71              }
   \   0000001A   9601               ADIW    R25:R24, 1
   \                     ??ReadEEPROMBuffer_0:
   \   0000001C   1782               CP      R24, R18
   \   0000001E   0793               CPC     R25, R19
   \   00000020   F3A8               BRCS    ??ReadEEPROMBuffer_1
     72          }
   \   00000022   01C0               MOVW    R25:R24, R1:R0
   \   00000024   9508               RET
     73          
     74          /*---------------------------------------------------------------------------
     75          **
     76          **  Writ buffer to eeprom
     77          **
     78          **--------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
     79          void WriteEEPROMBuffer( unsigned int Address, char Size, char *pData ) {   
   \                     WriteEEPROMBuffer:
   \                     ??WriteEEPROMBuffer_0:
     80          
     81              while (EECR & (1<<EEWE))     // Wait until ready
   \   00000000   99E1               SBIC    0x1C, 0x01
   \   00000002   CFFE               RJMP    ??WriteEEPROMBuffer_0
     82                  ;
     83              OS_IncDI();
   \   00000004   94F8               CLI
   \   00000006   ....               LDI     R30, LOW(OS_Counters)
   \   00000008   ....               LDI     R31, (OS_Counters) >> 8
   \   0000000A   8131               LDD     R19, Z+1
   \   0000000C   9533               INC     R19
   \   0000000E   8331               STD     Z+1, R19
     84              pWriteBuffer = pData;
   \   00000010   ....               LDI     R30, LOW(pWriteBuffer)
   \   00000012   ....               LDI     R31, (pWriteBuffer) >> 8
   \   00000014   8340               ST      Z, R20
   \   00000016   8351               STD     Z+1, R21
     85              WriteCount = Size;
   \   00000018   9320....           STS     WriteCount, R18
     86              EEAR = Address ;
   \   0000001C   ....               RCALL   ?Subroutine3
     87              EEDR = *pData ;
   \                     ??CrossCallReturnLabel_4:
   \   0000001E   01FA               MOVW    R31:R30, R21:R20
   \   00000020   ....               RCALL   ?Subroutine0
     88              pWriteBuffer++;
     89              EEPWriteOK = false;
   \                     ??CrossCallReturnLabel_0:
   \   00000022   E000               LDI     R16, 0
   \   00000024   9300....           STS     EEPWriteOK, R16
     90              EECR |= (1 << EEMWE) ;       // Don't use SetBit macrod due to timing
   \   00000028   ....               RCALL   ?Subroutine4
     91              EECR |= (1 << EEWE) ;        // Don't use SetBit macrod due to timing
     92              EECR |= (1 << EERIE) ;       // Don't use SetBit macrod due to timing
   \                     ??CrossCallReturnLabel_7:
   \   0000002A   9AE3               SBI     0x1C, 0x03
     93              OS_DecRI();
   \   0000002C   ....               LDI     R30, LOW(OS_Counters)
   \   0000002E   ....               LDI     R31, (OS_Counters) >> 8
   \   00000030   8101               LDD     R16, Z+1
   \   00000032   950A               DEC     R16
   \   00000034   8301               STD     Z+1, R16
   \   00000036   ....               RJMP    ?Subroutine5
   \   00000038                      REQUIRE _A_EECR
   \   00000038                      REQUIRE _A_EEAR
   \   00000038                      REQUIRE _A_EEDR
     94          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   8100               LD      R16, Z
   \   00000002   BB0D               OUT     0x1D, R16
   \   00000004   ....               LDI     R30, LOW(pWriteBuffer)
   \   00000006   ....               LDI     R31, (pWriteBuffer) >> 8
   \   00000008   8100               LD      R16, Z
   \   0000000A   8111               LDD     R17, Z+1
   \   0000000C   5F0F               SUBI    R16, 255
   \   0000000E   4F1F               SBCI    R17, 255
   \   00000010   8300               ST      Z, R16
   \   00000012   8311               STD     Z+1, R17
   \   00000014   9508               RET
     95          
     96          /*---------------------------------------------------------------------------
     97          **
     98          **  Interrupt on EEPROM write
     99          **
    100          **--------------------------------------------------------------------------*/
    101          #pragma vector=EE_RDY_vect

   \                                 In  segment CODE, align 2, keep-with-next
    102          __interrupt void IntHandler_EEPROM( void ){
   \                     IntHandler_EEPROM:
   \   00000000   93FA               ST      -Y, R31
   \   00000002   93EA               ST      -Y, R30
   \   00000004   932A               ST      -Y, R18
   \   00000006   931A               ST      -Y, R17
   \   00000008   930A               ST      -Y, R16
   \   0000000A   B72F               IN      R18, 0x3F
    103          
    104              if ( --WriteCount ) {                        // More to write? 
   \   0000000C   9100....           LDS     R16, WriteCount
   \   00000010   950A               DEC     R16
   \   00000012   9300....           STS     WriteCount, R16
   \   00000016   2300               TST     R16
   \   00000018   F061               BREQ    ??IntHandler_EEPROM_0
    105                  EEAR++;                                  // Define address and data 
   \   0000001A   B30E               IN      R16, 0x1E
   \   0000001C   B31F               IN      R17, 0x1F
   \   0000001E   5F0F               SUBI    R16, 255
   \   00000020   4F1F               SBCI    R17, 255
   \   00000022   ....               RCALL   ?Subroutine3
    106                  EEDR = *pWriteBuffer++;
   \                     ??CrossCallReturnLabel_5:
   \   00000024   91E0....           LDS     R30, pWriteBuffer
   \   00000028   91F0....           LDS     R31, (pWriteBuffer + 1)
   \   0000002C   ....               RCALL   ?Subroutine0
    107                  EECR |= (1 << EEMWE) ;       // Don't use SetBit macrod due to timing
   \                     ??CrossCallReturnLabel_1:
   \   0000002E   ....               RCALL   ?Subroutine4
    108                  EECR |= (1 << EEWE) ;        // Don't use SetBit macrod due to timing
    109              } else {
   \                     ??CrossCallReturnLabel_8:
   \   00000030   C004               RJMP    ??IntHandler_EEPROM_1
    110                  EECR &= ~(1 << EERIE) ;       // Don't use ClrBit macrod due to timing
   \                     ??IntHandler_EEPROM_0:
   \   00000032   98E3               CBI     0x1C, 0x03
    111                  EEPWriteOK = true;
   \   00000034   E001               LDI     R16, 1
   \   00000036   9300....           STS     EEPWriteOK, R16
    112              }
    113          }
   \                     ??IntHandler_EEPROM_1:
   \   0000003A   BF2F               OUT     0x3F, R18
   \   0000003C   9109               LD      R16, Y+
   \   0000003E   9119               LD      R17, Y+
   \   00000040   9129               LD      R18, Y+
   \   00000042   91E9               LD      R30, Y+
   \   00000044   91F9               LD      R31, Y+
   \   00000046   9518               RETI
   \   00000048                      REQUIRE _A_EEAR
   \   00000048                      REQUIRE _A_EEDR
   \   00000048                      REQUIRE _A_EECR
    114          
    115          
    116          /**===========================================================================
    117          ** Get the stored version in EEPROM
    118          **==========================================================================*/ 

   \                                 In  segment CODE, align 2, keep-with-next
    119          char EEPROMVersion(void) {
   \                     EEPROMVersion:
   \   00000000   2E28               MOV     R2, R24
   \   00000002   9721               SBIW    R29:R28, 1
    120              char val ;
    121              char retval = false;
   \   00000004   E080               LDI     R24, 0
    122          
    123              ReadEEPROMBuffer(EEPROM_ID_START, 1, (char*)&val) ;
   \   00000006   01AE               MOVW    R21:R20, R29:R28
   \   00000008   E021               LDI     R18, 1
   \   0000000A   E000               LDI     R16, 0
   \   0000000C   ....               RCALL   ?Subroutine2
    124              if (val == EEPROM_ID) {                                     //correct EEPROM ID
   \                     ??CrossCallReturnLabel_11:
   \   0000000E   3B0D               CPI     R16, 189
   \   00000010   F471               BRNE    ??EEPROMVersion_0
    125                  ReadEEPROMBuffer(EEPROM_ID_START+1, 1, (char*)&val) ;
   \   00000012   01AE               MOVW    R21:R20, R29:R28
   \   00000014   E021               LDI     R18, 1
   \   00000016   E001               LDI     R16, 1
   \   00000018   ....               RCALL   ?Subroutine2
    126                  if (val == STORE_VERSION) {                             // and version
   \                     ??CrossCallReturnLabel_12:
   \   0000001A   3002               CPI     R16, 2
   \   0000001C   F441               BRNE    ??EEPROMVersion_0
    127                      ReadEEPROMBuffer(0xffe, 1, (char*)&val) ;
   \   0000001E   01AE               MOVW    R21:R20, R29:R28
   \   00000020   E021               LDI     R18, 1
   \   00000022   EF0E               LDI     R16, 254
   \   00000024   E01F               LDI     R17, 15
   \   00000026   ....               RCALL   ??Subroutine6_0
    128                      if (val == EEPROM_OK) {                             // and no reset from user
   \                     ??CrossCallReturnLabel_13:
   \   00000028   3F0F               CPI     R16, 255
   \   0000002A   F409               BRNE    ??EEPROMVersion_0
    129                          retval = true ;                                 // then everything is OK
   \   0000002C   E081               LDI     R24, 1
    130                      }
    131                  }
    132              }
    133              return retval;
   \                     ??EEPROMVersion_0:
   \   0000002E   2F08               MOV     R16, R24
   \   00000030   9621               ADIW    R29:R28, 1
   \   00000032   2D82               MOV     R24, R2
   \   00000034   9508               RET
    134          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   E010               LDI     R17, 0
   \   00000002                      REQUIRE ??Subroutine6_0
   \   00000002                      ;               // Fall through to label ??Subroutine6_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine6_0:
   \   00000000   ....               RCALL   ReadEEPROMBuffer
   \   00000002   8108               LD      R16, Y
   \   00000004   9508               RET
    135          
    136          /**===========================================================================
    137          ** Reset the EEPROM
    138          **==========================================================================*/ 

   \                                 In  segment CODE, align 2, keep-with-next
    139          void EEPROMReset(void) {
   \                     EEPROMReset:
    140              EEARL = (0x0ffe & 0xff);
   \   00000000   EF0E               LDI     R16, 254
   \   00000002   BB0E               OUT     0x1E, R16
    141              EEARH = (0x0ffe >> 8);
   \   00000004   E00F               LDI     R16, 15
   \   00000006   BB0F               OUT     0x1F, R16
    142              EEDR = EEPROM_RESET;
   \   00000008   ED0B               LDI     R16, 219
   \   0000000A   BB0D               OUT     0x1D, R16
    143              EECR |= (1<<EEMWE);
   \   0000000C   ....               RCALL   ?Subroutine4
    144              EECR |= (1<<EEWE);
    145              while (EECR & (1<<EEWE))
   \                     ??CrossCallReturnLabel_9:
   \   0000000E   99E1               SBIC    0x1C, 0x01
   \   00000010   CFFE               RJMP    ??CrossCallReturnLabel_9
    146                  ;
    147              WDTCR = 0x18;               //Start watchdog to genetate restart
   \   00000012   E108               LDI     R16, 24
   \   00000014   BD01               OUT     0x21, R16
    148              WDTCR = 0x18;
   \   00000016   BD01               OUT     0x21, R16
    149          }
   \   00000018   9508               RET
   \   0000001A                      REQUIRE _A_EEAR
   \   0000001A                      REQUIRE _A_EEDR
   \   0000001A                      REQUIRE _A_EECR
   \   0000001A                      REQUIRE _A_WDTCR

   \                                 In  segment INTVEC, offset 0x58, root
   \                     `??IntHandler_EEPROM::??INTVEC 88`:
   \   00000058   ........           JMP     IntHandler_EEPROM

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   EEPROMReset
      1      2   EEPROMVersion
        1      4   -> ReadEEPROMBuffer
      5      2   IntHandler_EEPROM
      0      2   ReadEEPROMBuffer
        0      2   -> ReadEEPROMByte
      0      2   ReadEEPROMByte
      0      2   TestEEPROM
      0      2   WriteEEPROMBuffer
      0      2   WriteEEPROMByte


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ??Subroutine6_0
      22  ?Subroutine0
       6  ?Subroutine1
       2  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
      26  EEPROMReset
      54  EEPROMVersion
      72  IntHandler_EEPROM
       4  IntHandler_EEPROM::??INTVEC 88
      38  ReadEEPROMBuffer
      16  ReadEEPROMByte
       6  TestEEPROM
      56  WriteEEPROMBuffer
      12  WriteEEPROMByte
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_WDTCR

 
   5 bytes in segment ABSOLUTE
 334 bytes in segment CODE
   4 bytes in segment INTVEC
 
 334 bytes of CODE memory (+ 4 bytes shared)
   0 bytes of DATA memory (+ 5 bytes shared)

Errors: none
Warnings: none
