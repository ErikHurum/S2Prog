###############################################################################
#
# IAR C/C++ Compiler V6.70.1.929 for Atmel AVR            08/Feb/2017  10:35:11
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Atmel AVR 6.80
#
#    Source file  =  D:\S2Prog\IO\ANZB\Lib\segment_init.c
#    Command line =  
#        D:\S2Prog\IO\ANZB\Lib\segment_init.c --cpu=m1281 -ms -o
#        D:\S2Prog\IO\ANZB\Debug\Obj -D OS_LIBMODE_D -D OS_UART=-1 -lCN
#        D:\S2Prog\IO\ANZB\Debug\List -y --initializers_in_flash --no_cse
#        --no_inline --no_code_motion --no_cross_call --no_clustering --no_tbaa
#        --debug -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\ANZB\INC\ -I
#        D:\S2Prog\IO\ANZB\..\..\SHARED\INC\ --eeprom_size 4096 --clib -On
#    List file    =  D:\S2Prog\IO\ANZB\Debug\List\segment_init.lst
#    Object file  =  D:\S2Prog\IO\ANZB\Debug\Obj\segment_init.r90
#
###############################################################################

D:\S2Prog\IO\ANZB\Lib\segment_init.c
      1          /**************************************************************
      2           **             - __segment_init.c -
      3           **
      4           **     Segment initialization that must be
      5           **     performed before main is called.
      6           **
      7           **     Used with iccAVR.
      8           **
      9           **     Copyright 1999 IAR Systems AB. All rights reserved.
     10           **
     11           **     $Revision: 6756 $
     12           **
     13           **************************************************************/
     14          #include "segment_init.h"
     15          #include <intrinsics.h>
     16          
     17          /* We're using extended keywords in this file. Make sure */
     18          /* that the compiler has IAR extensions enabled.         */
     19          #pragma language=extended
     20          
     21          /* If you are using C or EC++ code then you must include  */
     22          /* the segment initialization code below or supply your   */
     23          /* own version of segment initialization code. Otherwise  */
     24          /* we cannot guarantee that any C or EC++ code will work. */
     25          /* If you're only using assembler modules then you don't  */
     26          /* need to initialize any segments at all.                */
     27          
     28          #ifdef __cplusplus
     29          extern "C" {
     30          #endif
     31          
     32          /* __segment_init */
     33          
     34          #pragma optimize=no_inline

   \                                 In  segment CODE, align 2, keep-with-next
     35          static __x void __memclr(DstPtr_Type dst, Counter_Type size)
   \                     __memclr:
   \                     ??__memclr_0:
     36          {
     37            do {
     38              *dst++ = 0;
   \   00000000   E020               LDI     R18, 0
   \   00000002   932C               ST      X, R18
   \   00000004   9611               ADIW    R27:R26, 1
     39            } while(--size != 0);
   \   00000006   5001               SUBI    R16, 1
   \   00000008   4010               SBCI    R17, 0
   \   0000000A   2F20               MOV     R18, R16
   \   0000000C   2B21               OR      R18, R17
   \   0000000E   F7C1               BRNE    ??__memclr_0
     40          }
   \   00000010   9508               RET
     41          
     42          #pragma optimize=no_inline

   \                                 In  segment CODE, align 2, keep-with-next
     43          static __x_z void __flashcpy(DstPtr_Type dst, SrcPtr_Type src, Counter_Type size)
   \                     __flashcpy:
   \                     ??__flashcpy_0:
     44          {
     45            do {
     46              *dst++ = *src++;
   \   00000000   BF3B               OUT     0x3B, R19
   \   00000002   9126               ELPM    R18, Z
   \   00000004   932C               ST      X, R18
   \   00000006   5FEF               SUBI    R30, 255
   \   00000008   4FFF               SBCI    R31, 255
   \   0000000A   4F3F               SBCI    R19, 255
   \   0000000C   9611               ADIW    R27:R26, 1
     47            } while(--size != 0);
   \   0000000E   5001               SUBI    R16, 1
   \   00000010   4010               SBCI    R17, 0
   \   00000012   2F20               MOV     R18, R16
   \   00000014   2B21               OR      R18, R17
   \   00000016   F7A1               BRNE    ??__flashcpy_0
     48          }
   \   00000018   9508               RET
     49          

   \                                 In  segment CODE, align 2, keep-with-next
     50          __C_task void __segment_init(void)
   \                     __segment_init:
     51          {
     52            SegmentInitBlockPtr_Type InitTable;
     53          
     54            /* Initialize the INITTAB pointer. */
     55            InitTable = __segment_begin("INITTAB");
   \   00000000   ....               LDI     R16, LOW(SFB(INITTAB))
   \   00000002   ....               LDI     R17, HIGH(SFB(INITTAB))
   \   00000004   ....               LDI     R18, (SFB(INITTAB)) >> 16
   \   00000006   0108               MOVW    R1:R0, R17:R16
   \   00000008   2E22               MOV     R2, R18
     56          
     57            /* Loop over all copy/zero blocks in the INITTAB segment */
     58            do
     59            {
     60              /* Fetch initialization data from the INITTAB segment. */
     61              Counter_Type  size = InitTable->Cnt;
   \                     ??__segment_init_0:
   \   0000000A   01F0               MOVW    R31:R30, R1:R0
   \   0000000C   2D32               MOV     R19, R2
   \   0000000E   BF3B               OUT     0x3B, R19
   \   00000010   9187               ELPM    R24, Z+
   \   00000012   9196               ELPM    R25, Z
   \   00000014   B73B               IN      R19, 0x3B
   \   00000016   50E1               SUBI    R30, 1
   \   00000018   40F0               SBCI    R31, 0
   \   0000001A   4030               SBCI    R19, 0
     62              DstPtr_Type   dst  = InitTable->Dst;
   \   0000001C   01F0               MOVW    R31:R30, R1:R0
   \   0000001E   2D32               MOV     R19, R2
   \   00000020   5FEE               SUBI    R30, 254
   \   00000022   4FFF               SBCI    R31, 255
   \   00000024   4F3F               SBCI    R19, 255
   \   00000026   BF3B               OUT     0x3B, R19
   \   00000028   9087               ELPM    R8, Z+
   \   0000002A   9096               ELPM    R9, Z
   \   0000002C   B73B               IN      R19, 0x3B
   \   0000002E   50E3               SUBI    R30, 3
   \   00000030   40F0               SBCI    R31, 0
   \   00000032   4030               SBCI    R19, 0
     63              SrcPtr_Type   src  = InitTable->Src;
   \   00000034   01F0               MOVW    R31:R30, R1:R0
   \   00000036   2D32               MOV     R19, R2
   \   00000038   5FEC               SUBI    R30, 252
   \   0000003A   4FFF               SBCI    R31, 255
   \   0000003C   4F3F               SBCI    R19, 255
   \   0000003E   BF3B               OUT     0x3B, R19
   \   00000040   9147               ELPM    R20, Z+
   \   00000042   9157               ELPM    R21, Z+
   \   00000044   9166               ELPM    R22, Z
   \   00000046   B73B               IN      R19, 0x3B
   \   00000048   50E6               SUBI    R30, 6
   \   0000004A   40F0               SBCI    R31, 0
   \   0000004C   4030               SBCI    R19, 0
     64          
     65              /* If the src is 0 then we should clear a memory */
     66              /* block, otherwise it's a copy operation.       */
     67              if (src != 0)
   \   0000004E   2F04               MOV     R16, R20
   \   00000050   2B05               OR      R16, R21
   \   00000052   2B06               OR      R16, R22
   \   00000054   F031               BREQ    ??__segment_init_1
     68                __flashcpy(dst, src, size);
   \   00000056   018C               MOVW    R17:R16, R25:R24
   \   00000058   01FA               MOVW    R31:R30, R21:R20
   \   0000005A   2F36               MOV     R19, R22
   \   0000005C   01D4               MOVW    R27:R26, R9:R8
   \   0000005E   ....               RCALL   __flashcpy
   \   00000060   C003               RJMP    ??__segment_init_2
     69              else
     70                __memclr(dst, size);
   \                     ??__segment_init_1:
   \   00000062   018C               MOVW    R17:R16, R25:R24
   \   00000064   01D4               MOVW    R27:R26, R9:R8
   \   00000066   ....               RCALL   __memclr
     71          
     72              /* Advance the INITTAB pointer. */
     73              ++InitTable;
   \                     ??__segment_init_2:
   \   00000068   E007               LDI     R16, 7
   \   0000006A   0E00               ADD     R0, R16
   \   0000006C   E000               LDI     R16, 0
   \   0000006E   1E10               ADC     R1, R16
   \   00000070   E000               LDI     R16, 0
   \   00000072   1E20               ADC     R2, R16
     74            }  while(InitTable < __segment_end("INITTAB"));
   \   00000074   0120               MOVW    R5:R4, R1:R0
   \   00000076   2C62               MOV     R6, R2
   \   00000078   2477               CLR     R7
   \   0000007A   ....               LDI     R16, LOW(SFE(INITTAB))
   \   0000007C   ....               LDI     R17, HIGH(SFE(INITTAB))
   \   0000007E   ....               LDI     R18, (SFE(INITTAB)) >> 16
   \   00000080   E030               LDI     R19, 0
   \   00000082   1640               CP      R4, R16
   \   00000084   0651               CPC     R5, R17
   \   00000086   0662               CPC     R6, R18
   \   00000088   0673               CPC     R7, R19
   \   0000008A   F408               BRCC    $+2+2
   \   0000008C   CFBE               RJMP    ??__segment_init_0
     75          }
   \   0000008E   9508               RET
     76          
     77          #ifdef __cplusplus
     78          }
     79          #endif

   Maximum stack usage in bytes:

   RSTACK Function
   ------ --------
      2   __flashcpy
      2   __memclr
      2   __segment_init
        2   -> __flashcpy
        2   -> __memclr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      26  __flashcpy
      18  __memclr
     144  __segment_init

 
 188 bytes in segment CODE
 
 188 bytes of CODE memory

Errors: none
Warnings: none
