###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       15/Dec/2022  12:17:27
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\hart\Src\init.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW5711.tmp
#        (D:\S2Prog\IO\hart\Src\init.c --cpu=m1280 -ms -o
#        D:\S2Prog\IO\hart\Debug\Obj -D OS_LIBMODE_D -D OS_UART=-1 -D DEBUG
#        -lCN D:\S2Prog\IO\hart\Debug\List -y --initializers_in_flash --no_cse
#        --no_inline --no_code_motion --no_cross_call --no_clustering --no_tbaa
#        --debug -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\hart\INC\\ -I
#        ..\..\..\Shared\Inc\\ --eeprom_size 4096 --clib -On)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\hart\Debug\List\init.lst
#    Object file  =  D:\S2Prog\IO\hart\Debug\Obj\init.r90
#
###############################################################################

D:\S2Prog\IO\hart\Src\init.c
      1          /****************************************************************************************
      2          / Init the project
      3          /
      4          ***************************************************************************************/
      5          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0x108
   \   union <unnamed> volatile __ext_io _A_PORTK
   \                     _A_PORTK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc4
   \   union <unnamed> volatile __io _A_UBRR0
   \                     _A_UBRR0:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0xc2
   \   union <unnamed> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc1
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0xc0
   \   union <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x98
   \   union <unnamed> volatile __io _A_OCR3A
   \                     _A_OCR3A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x91
   \   union <unnamed> volatile __io _A_TCCR3B
   \                     _A_TCCR3B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x90
   \   union <unnamed> volatile __io _A_TCCR3A
   \                     _A_TCCR3A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7c
   \   union <unnamed> volatile __io _A_ADMUX
   \                     _A_ADMUX:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7b
   \   union <unnamed> volatile __io _A_ADCSRB
   \                     _A_ADCSRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x7a
   \   union <unnamed> volatile __io _A_ADCSRA
   \                     _A_ADCSRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x75
   \   union <unnamed> volatile __io _A_XMCRB
   \                     _A_XMCRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x74
   \   union <unnamed> volatile __io _A_XMCRA
   \                     _A_XMCRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6a
   \   union <unnamed> volatile __io _A_EICRB
   \                     _A_EICRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x69
   \   union <unnamed> volatile __io _A_EICRA
   \                     _A_EICRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5f
   \   union <unnamed> volatile __io _A_SREG
   \                     _A_SREG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x55
   \   union <unnamed> volatile __io _A_MCUCR
   \                     _A_MCUCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x47
   \   union <unnamed> volatile __io _A_OCR0A
   \                     _A_OCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x44
   \   union <unnamed> volatile __io _A_TCCR0A
   \                     _A_TCCR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   union <unnamed> volatile __io _A_EIMSK
   \                     _A_EIMSK:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x36
   \   union <unnamed> volatile __io _A_TIFR1
   \                     _A_TIFR1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   union <unnamed> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x33
   \   union <unnamed> volatile __io _A_DDRG
   \                     _A_DDRG:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   union <unnamed> volatile __io _A_PORTF
   \                     _A_PORTF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   union <unnamed> volatile __io _A_DDRF
   \                     _A_DDRF:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2d
   \   union <unnamed> volatile __io _A_DDRE
   \                     _A_DDRE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   union <unnamed> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x28
   \   union <unnamed> volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   union <unnamed> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   union <unnamed> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   union <unnamed> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x23
   \   union <unnamed> volatile __io _A_PINB
   \                     _A_PINB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x22
   \   union <unnamed> volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x21
   \   union <unnamed> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1
      6          #include "stdio.h"
      7          #include "math.h"
      8          #include "externals.h"
      9          #include "version.h"
     10          #include "inavr.h"
     11          #include "string.h"
     12          
     13          #include "hart_gpio.h"
     14          #include "hart.h"
     15          
     16          /*
     17          **===========================================================================
     18          ** Init the system according to board type
     19          **===========================================================================
     20          */

   \                                 In  segment CODE, align 2, keep-with-next
     21          void InitSystem(void) {
   \                     InitSystem:
     22          	// UnitID = AN_ZBANA; //EHSMark AN_ZBHART;                   // 0x02: ZBHART
     23          
     24          	UnitID  = (PINB >> 2) & 0x03;          //get the unit ID
   \   00000000   B103               IN      R16, 0x03
   \   00000002   9506               LSR     R16
   \   00000004   9506               LSR     R16
   \   00000006   7003               ANDI    R16, 0x03
   \   00000008   9300....           STS     UnitID, R16
     25          	Init_CPU();                           // init all processes
   \   0000000C   ....               RCALL   Init_CPU
     26          	Init_IO();
   \   0000000E   ....               RCALL   Init_IO
     27          	Init_TMR();
   \   00000010   ....               RCALL   Init_TMR
     28          #if (OS_UART != 0)
     29          	Init_USART(0, 38400);                // only 1 UART to TCU on ZBHART
   \   00000012   E040               LDI     R20, 0
   \   00000014   E956               LDI     R21, 150
   \   00000016   E060               LDI     R22, 0
   \   00000018   E070               LDI     R23, 0
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   ....               RCALL   Init_USART
     30          #endif
     31          	//Init_AD();
     32          	Init_Values();                        // init the values in the system
   \   0000001E   ....               RCALL   Init_Values
     33          
     34          	//ADCSRA |= 0x40 ;                    //start the AD convertion
     35          }
   \   00000020   9508               RET
   \   00000022                      REQUIRE _A_PINB
     36          
     37          /*
     38          **===========================================================================
     39          ** Init the CPU related registers
     40          **===========================================================================
     41          */

   \                                 In  segment CODE, align 2, keep-with-next
     42          void Init_CPU(void) {
   \                     Init_CPU:
     43          
     44          	__disable_interrupt();
   \   00000000   94F8               CLI
     45          
     46          	MCUCR = 0x00;        // MCU control register wait state
   \   00000002   E000               LDI     R16, 0
   \   00000004   BF05               OUT     0x35, R16
     47          	EIMSK = 0x00;        // External interrupt mask register , all off
   \   00000006   E000               LDI     R16, 0
   \   00000008   BB0D               OUT     0x1D, R16
     48          	EICRA = 0xAA;        // External interrupt control register, o on faling edge
   \   0000000A   EA0A               LDI     R16, 170
   \   0000000C   9300....           STS     _A_EICRA, R16
     49          	EICRB = 0xAA;        // External interrupt control register
   \   00000010   EA0A               LDI     R16, 170
   \   00000012   9300....           STS     _A_EICRB, R16
     50          	EIMSK = 0x01;        // External interrupt mask register, int 0 on
   \   00000016   E001               LDI     R16, 1
   \   00000018   BB0D               OUT     0x1D, R16
     51          
     52          	XMCRA = 0x00;        // maximum wait states
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   9300....           STS     _A_XMCRA, R16
     53          	XMCRB = 0x07;        // Full portC + bus keeper
   \   00000020   E007               LDI     R16, 7
   \   00000022   9300....           STS     _A_XMCRB, R16
     54          	SREG  = 0x80;        // global interrupt
   \   00000026   E800               LDI     R16, 128
   \   00000028   BF0F               OUT     0x3F, R16
     55          	//XDIV  = 0x00 ;      // Init valuse used 0x00v XXX
     56          
     57          	RestartStatus = MCUCR;       // Remember reset source
   \   0000002A   B705               IN      R16, 0x35
   \   0000002C   9300....           STS     RestartStatus, R16
     58          	MCUCR = 0x00;              // and reset
   \   00000030   E000               LDI     R16, 0
   \   00000032   BF05               OUT     0x35, R16
     59          
     60          	/*--- Initialize buffer ---*/
     61          	WriteCount = 0;
   \   00000034   E000               LDI     R16, 0
   \   00000036   9300....           STS     WriteCount, R16
     62          }
   \   0000003A   9508               RET
   \   0000003C                      REQUIRE _A_MCUCR
   \   0000003C                      REQUIRE _A_EIMSK
   \   0000003C                      REQUIRE _A_EICRA
   \   0000003C                      REQUIRE _A_EICRB
   \   0000003C                      REQUIRE _A_XMCRA
   \   0000003C                      REQUIRE _A_XMCRB
   \   0000003C                      REQUIRE _A_SREG
     63          
     64          /*
     65          **===========================================================================
     66          ** Init the watchdog registers
     67          **===========================================================================
     68          */

   \                                 In  segment CODE, align 2, keep-with-next
     69          __monitor void Init_Watchdog(void) {
   \                     Init_Watchdog:
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002   94F8               CLI
     70          
     71          	asm("WDR");                             // kick the dog!!
   \   00000004   95A8               WDR
     72          	WDTCSR = 0x0f;
   \   00000006   E00F               LDI     R16, 15
   \   00000008   9300....           STS     _A_WDTCSR, R16
     73          	asm("WDR");                             // kick the dog!!
   \   0000000C   95A8               WDR
     74          
     75          }
   \   0000000E   BF1F               OUT     0x3F, R17
   \   00000010   9508               RET
   \   00000012                      REQUIRE _A_WDTCSR
     76          
     77          /*
     78          **===========================================================================
     79          ** Init the IO related registers
     80          **===========================================================================
     81          */

   \                                 In  segment CODE, align 2, keep-with-next
     82          void Init_IO(void) {
   \                     Init_IO:
     83          	/*--- Initialize the data registers, output value and input pullup ---*/
     84          	switch (UnitID) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   5000               SUBI    R16, 0
   \   00000006   F029               BREQ    ??Init_IO_0
   \   00000008   950A               DEC     R16
   \   0000000A   F101               BREQ    ??Init_IO_1
   \   0000000C   5002               SUBI    R16, 2
   \   0000000E   F1D9               BREQ    ??Init_IO_2
   \   00000010   9508               RET
     85          	case AN_ZB485:                  // AN-ZB485
     86          		DDRA   =  0xff;      // Port A data direction (out), external bus
   \                     ??Init_IO_0:
   \   00000012   EF0F               LDI     R16, 255
   \   00000014   B901               OUT     0x01, R16
     87          		PORTA  =  0x00;      // Port A data
   \   00000016   E000               LDI     R16, 0
   \   00000018   B902               OUT     0x02, R16
     88          		DDRB   =  0x10;      // Port B data direction, bit 0, 4-7 out
   \   0000001A   E100               LDI     R16, 16
   \   0000001C   B904               OUT     0x04, R16
     89          		PORTB  =  0x00;      // Port B data
   \   0000001E   E000               LDI     R16, 0
   \   00000020   B905               OUT     0x05, R16
     90          		DDRC   =  0xff;      // Port C data direction, all out
   \   00000022   EF0F               LDI     R16, 255
   \   00000024   B907               OUT     0x07, R16
     91          		PORTC  =  0x00;      // Port C data
   \   00000026   E000               LDI     R16, 0
   \   00000028   B908               OUT     0x08, R16
     92          		DDRD   =  0x00;      // Port D data direction, all in except output to osc and txd
   \   0000002A   E000               LDI     R16, 0
   \   0000002C   B90A               OUT     0x0A, R16
     93          		PORTD  =  0xff;      // Port D data pullup on int fro AD
   \   0000002E   EF0F               LDI     R16, 255
   \   00000030   B90B               OUT     0x0B, R16
     94          		DDRE   =  0xFE;      // Port E data direction, all out except rxd
   \   00000032   EF0E               LDI     R16, 254
   \   00000034   B90D               OUT     0x0D, R16
     95          		PORTE  =  0xf0;      // Port E data
   \   00000036   EF00               LDI     R16, 240
   \   00000038   B90E               OUT     0x0E, R16
     96          		DDRF   =  0x00;      // Port F data direction, used for ADC
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   BB00               OUT     0x10, R16
     97          		PORTF  =  0x00;      // Port F data
   \   0000003E   E000               LDI     R16, 0
   \   00000040   BB01               OUT     0x11, R16
     98          		DDRG   =  0x07;      // Port G data direction, port 1,2,3 out
   \   00000042   E007               LDI     R16, 7
   \   00000044   BB03               OUT     0x13, R16
     99          		PORTG  =  0x03;      // Port G data
   \   00000046   E003               LDI     R16, 3
   \   00000048   BB04               OUT     0x14, R16
    100          		break;
   \   0000004A   9508               RET
    101          
    102          	case AN_ZBANA:                  // AN-ZBANA
    103          		DDRA   =  0x00;      // Port A data direction in (not used)
   \                     ??Init_IO_1:
   \   0000004C   E000               LDI     R16, 0
   \   0000004E   B901               OUT     0x01, R16
    104          		PORTA  =  0x00;      // Port A data
   \   00000050   E000               LDI     R16, 0
   \   00000052   B902               OUT     0x02, R16
    105          		DDRB   =  0xF1;      // Port B data direction, bit 0, 4-7 out
   \   00000054   EF01               LDI     R16, 241
   \   00000056   B904               OUT     0x04, R16
    106          		PORTB  =  0x00;      // Port B data
   \   00000058   E000               LDI     R16, 0
   \   0000005A   B905               OUT     0x05, R16
    107          		DDRC   =  0xFF;      // Port C data direction, all out
   \   0000005C   EF0F               LDI     R16, 255
   \   0000005E   B907               OUT     0x07, R16
    108          		PORTC  =  0x00;      // Port C data
   \   00000060   E000               LDI     R16, 0
   \   00000062   B908               OUT     0x08, R16
    109          		DDRD   =  0x02;      // Port D data direction, all in except output to osc and txd
   \   00000064   E002               LDI     R16, 2
   \   00000066   B90A               OUT     0x0A, R16
    110          		PORTD  =  0xf1;      // Port D data pullup on int fro AD
   \   00000068   EF01               LDI     R16, 241
   \   0000006A   B90B               OUT     0x0B, R16
    111          		DDRE   =  0xFE;      // Port E data direction, all out except rxd
   \   0000006C   EF0E               LDI     R16, 254
   \   0000006E   B90D               OUT     0x0D, R16
    112          		PORTE  =  0x00;      // Port E data
   \   00000070   E000               LDI     R16, 0
   \   00000072   B90E               OUT     0x0E, R16
    113          		DDRF   =  0x00;      // Port F data direction, used for ADC
   \   00000074   E000               LDI     R16, 0
   \   00000076   BB00               OUT     0x10, R16
    114          		PORTF  =  0x00;      // Port F data
   \   00000078   E000               LDI     R16, 0
   \   0000007A   BB01               OUT     0x11, R16
    115          		DDRG   =  0x10;      // Port G data direction, bit 5 out
   \   0000007C   E100               LDI     R16, 16
   \   0000007E   BB03               OUT     0x13, R16
    116          		PORTG  =  0x00;      // Port G data
   \   00000080   E000               LDI     R16, 0
   \   00000082   BB04               OUT     0x14, R16
    117          		break;
   \   00000084   9508               RET
    118          
    119          	case AN_ZBHART:
    120                  DDRF      =  0x00 ;      // Port F data direction, used for ADC
   \                     ??Init_IO_2:
   \   00000086   E000               LDI     R16, 0
   \   00000088   BB00               OUT     0x10, R16
    121          		PORTF     =  0x00 ;      // Port F data 
   \   0000008A   E000               LDI     R16, 0
   \   0000008C   BB01               OUT     0x11, R16
    122          		//DDRK      =  0xC0;     // Port K data direction, port 6,7 out
    123          		PORTK     =  0x00;       // Port K data
   \   0000008E   E000               LDI     R16, 0
   \   00000090   9300....           STS     _A_PORTK, R16
    124          		// Set up AD converter
    125          		ADChannel = 0x0e;
   \   00000094   E00E               LDI     R16, 14
   \   00000096   9300....           STS     ADChannel, R16
    126          		ADMUX     &= 0xe0 ;                           // set the channel
   \   0000009A   9100....           LDS     R16, _A_ADMUX
   \   0000009E   7E00               ANDI    R16, 0xE0
   \   000000A0   9300....           STS     _A_ADMUX, R16
    127          		ADMUX     |= ADChannel ;
   \   000000A4   9100....           LDS     R16, ADChannel
   \   000000A8   9110....           LDS     R17, _A_ADMUX
   \   000000AC   2B10               OR      R17, R16
   \   000000AE   9310....           STS     _A_ADMUX, R17
    128                  //as ADC0 is being used we can leave the ADMUX register as default (i.e. 0)
    129                  ADCSRA    |= (1 << ADATE);  // this starts the conversion which is auto triggered
   \   000000B2   9100007A           LDS     R16, 122
   \   000000B6   6200               ORI     R16, 0x20
   \   000000B8   9300007A           STS     122, R16
    130                  ADCSRB    &= 0xF8;          // (1 << ADTS2) | (0 << ADTS1) | (0 << ADTS0); // triggered using timer/counter0 overflow
   \   000000BC   9100....           LDS     R16, _A_ADCSRB
   \   000000C0   7F08               ANDI    R16, 0xF8
   \   000000C2   9300....           STS     _A_ADCSRB, R16
    131                  ADCSRA    |= (1 << ADEN);   // this enables the ADC
   \   000000C6   9100007A           LDS     R16, 122
   \   000000CA   6800               ORI     R16, 0x80
   \   000000CC   9300007A           STS     122, R16
    132                  ADCSRA    |= (1 << ADIE);   // enables completion interrupt
   \   000000D0   9100007A           LDS     R16, 122
   \   000000D4   6008               ORI     R16, 0x08
   \   000000D6   9300007A           STS     122, R16
    133          		TIFR1 = 1;
   \   000000DA   E001               LDI     R16, 1
   \   000000DC   BB06               OUT     0x16, R16
    134          		hart_gpio_init();
   \   000000DE   ........           CALL    hart_gpio_init
    135          		break;
    136          
    137          	default:
    138          		break;
    139          	}
    140          }
   \   000000E2   9508               RET
   \   000000E4                      REQUIRE _A_DDRA
   \   000000E4                      REQUIRE _A_PORTA
   \   000000E4                      REQUIRE _A_DDRB
   \   000000E4                      REQUIRE _A_PORTB
   \   000000E4                      REQUIRE _A_DDRC
   \   000000E4                      REQUIRE _A_PORTC
   \   000000E4                      REQUIRE _A_DDRD
   \   000000E4                      REQUIRE _A_PORTD
   \   000000E4                      REQUIRE _A_DDRE
   \   000000E4                      REQUIRE _A_PORTE
   \   000000E4                      REQUIRE _A_DDRF
   \   000000E4                      REQUIRE _A_PORTF
   \   000000E4                      REQUIRE _A_DDRG
   \   000000E4                      REQUIRE _A_PORTG
   \   000000E4                      REQUIRE _A_PORTK
   \   000000E4                      REQUIRE _A_ADMUX
   \   000000E4                      REQUIRE _A_ADCSRA
   \   000000E4                      REQUIRE _A_ADCSRB
   \   000000E4                      REQUIRE _A_TIFR1
    141          
    142          /*
    143          **===========================================================================
    144          ** Init the timer related registers
    145          **===========================================================================
    146          */

   \                                 In  segment CODE, align 2, keep-with-next
    147          void Init_TMR(void) {
   \                     Init_TMR:
    148          	/*--- Timer control (disable clock inputs) ---*/
    149          
    150          	switch (UnitID) {
   \   00000000   9100....           LDS     R16, UnitID
   \   00000004   5000               SUBI    R16, 0
   \   00000006   F029               BREQ    ??Init_TMR_0
   \   00000008   950A               DEC     R16
   \   0000000A   F041               BREQ    ??Init_TMR_1
   \   0000000C   5002               SUBI    R16, 2
   \   0000000E   F059               BREQ    ??Init_TMR_2
   \   00000010   9508               RET
    151          	case AN_ZB485:                  // AN-ZB485
    152          		TCCR0A  =  0x99;             // Timer control register 0
   \                     ??Init_TMR_0:
   \   00000012   E909               LDI     R16, 153
   \   00000014   BD04               OUT     0x24, R16
    153          		OCR0A   =  3;                 // Timer output compare register 0, 2MHZ //16MHz xtal
   \   00000016   E003               LDI     R16, 3
   \   00000018   BD07               OUT     0x27, R16
    154          		break;
   \   0000001A   9508               RET
    155          
    156          	case AN_ZBANA:                  // AN-ZBANA
    157          		TCCR0A  =  0x99;             // Timer control register 0
   \                     ??Init_TMR_1:
   \   0000001C   E909               LDI     R16, 153
   \   0000001E   BD04               OUT     0x24, R16
    158          		OCR0A    =  7;               // Timer output compare register 0, 1MHZ //16MHz xtal
   \   00000020   E007               LDI     R16, 7
   \   00000022   BD07               OUT     0x27, R16
    159          		break;
   \   00000024   9508               RET
    160          
    161          	case AN_ZBHART:
    162          		//TCCR0A  =  0x99;             // Timer control register 0
    163          		//OCR0A    =  7;               // Timer output compare register 0, 1MHZ //16MHz xtal
    164          		//
    165          		// to provide ADC with 1 Mhz clock, OC3A (PE3) is connected to ADC clock
    166          		//
    167          		// we will use TC3 to generate 1 Mhz clock by setting
    168          		//
    169          		// 1) TCCR3A    : 01000000   = 0x40
    170          		//    a) Bit 7:6,     COM3A1/COM3A0   :   01  - Toggle OC3A(PE3) on compare match
    171          		//    b) Bit 5:2,     don't care. all zero
    172          		//    c) Bit 1:0,     WGM31/WGM30     :   00 for CTC mode
    173          		//
    174          		// 2) TCCR3B    : 00001001 = 0x09
    175          		//    a) Bit 7,       noise canceler. don't care. 0
    176          		//    b) Bit 6,       edge select for input. don't care. 0
    177          		//    c) Bit 5,       reserved, 0
    178          		//    d) Bit 4:3,     WGM33/WGM32     : 01 for CTC mode with OCR3A as TOP
    179          		//    e) Bit 2:0,     CS32/CS31/CS30  : Clock Select, 001 : 16 Mhz with no divider
    180          		//
    181          		// 3) OCR3A     : 7, compare match at 8 tick at 16 Mhz will generate 1 MHz Clock
    182          		//
    183          		//
    184          		TCCR3A    = 0x40; 
   \                     ??Init_TMR_2:
   \   00000026   E400               LDI     R16, 64
   \   00000028   9300....           STS     _A_TCCR3A, R16
    185          		TCCR3B    = 0x09;
   \   0000002C   E009               LDI     R16, 9
   \   0000002E   9300....           STS     _A_TCCR3B, R16
    186          		OCR3A     = 7;
   \   00000032   E007               LDI     R16, 7
   \   00000034   E010               LDI     R17, 0
   \   00000036   9310....           STS     (_A_OCR3A + 1), R17
   \   0000003A   9300....           STS     _A_OCR3A, R16
    187          		break;
    188          
    189          	default:
    190          		break;
    191          	}
    192          }
   \   0000003E   9508               RET
   \   00000040                      REQUIRE _A_TCCR0A
   \   00000040                      REQUIRE _A_OCR0A
   \   00000040                      REQUIRE _A_TCCR3A
   \   00000040                      REQUIRE _A_TCCR3B
   \   00000040                      REQUIRE _A_OCR3A
    193          
    194          /*
    195          **===========================================================================
    196          ** Init the USARTs registers
    197          **===========================================================================
    198          */

   \                                 In  segment CODE, align 2, keep-with-next
    199          void Init_USART(char channel, unsigned long baud) {
   \                     Init_USART:
   \   00000000   ........           CALL    ?PROLOGUE5_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004   2E40               MOV     R4, R16
   \   00000006   01CA               MOVW    R25:R24, R21:R20
   \   00000008   01DB               MOVW    R27:R26, R23:R22
    200          
    201          
    202          	/*--- Configure UART data block ---*/
    203          	UART[channel].TxFirst   	= 0x00;
   \   0000000A   2D04               MOV     R16, R4
   \   0000000C   E010               LDI     R17, 0
   \   0000000E   E242               LDI     R20, 34
   \   00000010   E050               LDI     R21, 0
   \   00000012   ........           CALL    ?S_EC_MUL_L02
   \   00000016   01F8               MOVW    R31:R30, R17:R16
   \   00000018   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000001A   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000001C   E000               LDI     R16, 0
   \   0000001E   8302               STD     Z+2, R16
   \   00000020   E000               LDI     R16, 0
   \   00000022   8303               STD     Z+3, R16
    204          	UART[channel].TxLast    	= 0x00;
   \   00000024   2D04               MOV     R16, R4
   \   00000026   E010               LDI     R17, 0
   \   00000028   E242               LDI     R20, 34
   \   0000002A   E050               LDI     R21, 0
   \   0000002C   ........           CALL    ?S_EC_MUL_L02
   \   00000030   01F8               MOVW    R31:R30, R17:R16
   \   00000032   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000034   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000036   E000               LDI     R16, 0
   \   00000038   8304               STD     Z+4, R16
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   8305               STD     Z+5, R16
    205          	UART[channel].TxCount   	= 0x00;
   \   0000003E   2D04               MOV     R16, R4
   \   00000040   E010               LDI     R17, 0
   \   00000042   E242               LDI     R20, 34
   \   00000044   E050               LDI     R21, 0
   \   00000046   ........           CALL    ?S_EC_MUL_L02
   \   0000004A   01F8               MOVW    R31:R30, R17:R16
   \   0000004C   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000004E   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000050   E000               LDI     R16, 0
   \   00000052   8306               STD     Z+6, R16
   \   00000054   E000               LDI     R16, 0
   \   00000056   8307               STD     Z+7, R16
    206          	UART[channel].TxId        	= 0x00;
   \   00000058   2D04               MOV     R16, R4
   \   0000005A   E010               LDI     R17, 0
   \   0000005C   E242               LDI     R20, 34
   \   0000005E   E050               LDI     R21, 0
   \   00000060   ........           CALL    ?S_EC_MUL_L02
   \   00000064   01F8               MOVW    R31:R30, R17:R16
   \   00000066   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000068   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000006A   E000               LDI     R16, 0
   \   0000006C   8702               STD     Z+10, R16
    207          	UART[channel].TxAddress   	= 0x00;
   \   0000006E   2D04               MOV     R16, R4
   \   00000070   E010               LDI     R17, 0
   \   00000072   E242               LDI     R20, 34
   \   00000074   E050               LDI     R21, 0
   \   00000076   ........           CALL    ?S_EC_MUL_L02
   \   0000007A   01F8               MOVW    R31:R30, R17:R16
   \   0000007C   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000007E   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000080   E000               LDI     R16, 0
   \   00000082   8703               STD     Z+11, R16
    208          	UART[channel].RxCount   	= 0x00;
   \   00000084   2D04               MOV     R16, R4
   \   00000086   E010               LDI     R17, 0
   \   00000088   E242               LDI     R20, 34
   \   0000008A   E050               LDI     R21, 0
   \   0000008C   ........           CALL    ?S_EC_MUL_L02
   \   00000090   01F8               MOVW    R31:R30, R17:R16
   \   00000092   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000094   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000096   E000               LDI     R16, 0
   \   00000098   8F06               STD     Z+30, R16
   \   0000009A   E000               LDI     R16, 0
   \   0000009C   8F07               STD     Z+31, R16
    209          	UART[channel].TxStatus  	= 0x00;
   \   0000009E   2D04               MOV     R16, R4
   \   000000A0   E010               LDI     R17, 0
   \   000000A2   E242               LDI     R20, 34
   \   000000A4   E050               LDI     R21, 0
   \   000000A6   ........           CALL    ?S_EC_MUL_L02
   \   000000AA   01F8               MOVW    R31:R30, R17:R16
   \   000000AC   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   000000AE   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   000000B0   E000               LDI     R16, 0
   \   000000B2   8700               STD     Z+8, R16
    210          	UART[channel].SequenceNumber= 0x00;
   \   000000B4   2D04               MOV     R16, R4
   \   000000B6   E010               LDI     R17, 0
   \   000000B8   E242               LDI     R20, 34
   \   000000BA   E050               LDI     R21, 0
   \   000000BC   ........           CALL    ?S_EC_MUL_L02
   \   000000C0   01F8               MOVW    R31:R30, R17:R16
   \   000000C2   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   000000C4   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   000000C6   E000               LDI     R16, 0
   \   000000C8   A301               STD     Z+33, R16
    211          	
    212          	UART[channel].Channel   = channel;
   \   000000CA   2D04               MOV     R16, R4
   \   000000CC   E010               LDI     R17, 0
   \   000000CE   E242               LDI     R20, 34
   \   000000D0   E050               LDI     R21, 0
   \   000000D2   ........           CALL    ?S_EC_MUL_L02
   \   000000D6   01F8               MOVW    R31:R30, R17:R16
   \   000000D8   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   000000DA   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   000000DC   A240               STD     Z+32, R4
    213          
    214          	switch (channel) {
   \   000000DE   2044               TST     R4
   \   000000E0   F009               BREQ    $+2+2
   \   000000E2   C050               RJMP    ??Init_USART_0
    215          	case 0x00 :
    216          		OS_CreateMB( &UART[channel].RxMailBox, 1, MBUF_SIZE, MailBufCh0);
   \   000000E4   ....               LDI     R22, LOW(MailBufCh0)
   \   000000E6   ....               LDI     R23, (MailBufCh0) >> 8
   \   000000E8   E540               LDI     R20, 80
   \   000000EA   E050               LDI     R21, 0
   \   000000EC   E021               LDI     R18, 1
   \   000000EE   011A               MOVW    R3:R2, R21:R20
   \   000000F0   ....               LDI     R30, LOW((UART + 12))
   \   000000F2   ....               LDI     R31, HIGH((UART + 12))
   \   000000F4   2D04               MOV     R16, R4
   \   000000F6   E010               LDI     R17, 0
   \   000000F8   E242               LDI     R20, 34
   \   000000FA   E050               LDI     R21, 0
   \   000000FC   ........           CALL    ?S_EC_MUL_L02
   \   00000100   0FE0               ADD     R30, R16
   \   00000102   1FF1               ADC     R31, R17
   \   00000104   01A1               MOVW    R21:R20, R3:R2
   \   00000106   018F               MOVW    R17:R16, R31:R30
   \   00000108   ........           CALL    OS_CreateMB
    217          		UART[channel].pTxBuffer = TxBufferCh0;
   \   0000010C   ....               LDI     R18, LOW(TxBufferCh0)
   \   0000010E   ....               LDI     R19, (TxBufferCh0) >> 8
   \   00000110   2D04               MOV     R16, R4
   \   00000112   E010               LDI     R17, 0
   \   00000114   E242               LDI     R20, 34
   \   00000116   E050               LDI     R21, 0
   \   00000118   ........           CALL    ?S_EC_MUL_L02
   \   0000011C   01F8               MOVW    R31:R30, R17:R16
   \   0000011E   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000120   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   00000122   8320               ST      Z, R18
   \   00000124   8331               STD     Z+1, R19
    218          		UART[channel].pRxBuffer = RxBufferCh0;
   \   00000126   ....               LDI     R18, LOW(RxBufferCh0)
   \   00000128   ....               LDI     R19, (RxBufferCh0) >> 8
   \   0000012A   2D04               MOV     R16, R4
   \   0000012C   E010               LDI     R17, 0
   \   0000012E   E242               LDI     R20, 34
   \   00000130   E050               LDI     R21, 0
   \   00000132   ........           CALL    ?S_EC_MUL_L02
   \   00000136   01F8               MOVW    R31:R30, R17:R16
   \   00000138   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   0000013A   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000013C   8F22               STD     Z+26, R18
   \   0000013E   8F33               STD     Z+27, R19
    219          		UCSR0A  = 0x00;
   \   00000140   E000               LDI     R16, 0
   \   00000142   9300....           STS     _A_UCSR0A, R16
    220          		UBRR0L  = ((XTAL_CPU / 16 / baud) - 1) & 0xff;
   \   00000146   E400               LDI     R16, 64
   \   00000148   E412               LDI     R17, 66
   \   0000014A   E02F               LDI     R18, 15
   \   0000014C   E030               LDI     R19, 0
   \   0000014E   01AC               MOVW    R21:R20, R25:R24
   \   00000150   01BD               MOVW    R23:R22, R27:R26
   \   00000152   ........           CALL    ?UL_DIVMOD_L03
   \   00000156   950A               DEC     R16
   \   00000158   9300....           STS     _A_UBRR0, R16
    221          		UBRR0H  = (((XTAL_CPU / 16 / baud) - 1) >> 8) & 0xff;
   \   0000015C   E400               LDI     R16, 64
   \   0000015E   E412               LDI     R17, 66
   \   00000160   E02F               LDI     R18, 15
   \   00000162   E030               LDI     R19, 0
   \   00000164   01AC               MOVW    R21:R20, R25:R24
   \   00000166   01BD               MOVW    R23:R22, R27:R26
   \   00000168   ........           CALL    ?UL_DIVMOD_L03
   \   0000016C   5001               SUBI    R16, 1
   \   0000016E   4010               SBCI    R17, 0
   \   00000170   2F01               MOV     R16, R17
   \   00000172   E010               LDI     R17, 0
   \   00000174   930000C5           STS     197, R16
    222          		// why the fuck do you enalbe UDRE here you stupid fucktard!!! -hkim-
    223          		//UCSR0B  = 0xb8;                                       /* tx/ rx enable, int udre/rxon */
    224          		UCSR0B  = 0x98;                                       /* tx/ rx enable, int udre/rxon */
   \   00000178   E908               LDI     R16, 152
   \   0000017A   9300....           STS     _A_UCSR0B, R16
    225          		UCSR0C  = 0x06;                                       /* n,8,1 */
   \   0000017E   E006               LDI     R16, 6
   \   00000180   9300....           STS     _A_UCSR0C, R16
    226          		break;
    227          	case 0x01 :
    228          	default:
    229          		break;
    230          	}
    231          }
   \                     ??Init_USART_0:
   \   00000184   E0E5               LDI     R30, 5
   \   00000186   ........           JMP     ?EPILOGUE_B5_L09
   \   0000018A                      REQUIRE _A_UCSR0A
   \   0000018A                      REQUIRE _A_UBRR0
   \   0000018A                      REQUIRE _A_UCSR0B
   \   0000018A                      REQUIRE _A_UCSR0C
    232          
    233          
    234          /*
    235          **===========================================================================
    236          ** Init values  in the system
    237          **===========================================================================
    238          */

   \                                 In  segment CODE, align 2, keep-with-next
    239          void Init_Values(void) {
   \                     Init_Values:
    240          }
   \   00000000   9508               RET

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   InitSystem
        0      2   -> Init_CPU
        0      2   -> Init_IO
        0      2   -> Init_TMR
        0      2   -> Init_USART
        0      2   -> Init_Values
      0      2   Init_CPU
      0      2   Init_IO
        0      2   -> hart_gpio_init
      0      2   Init_TMR
      5      2   Init_USART
        5      2   -> OS_CreateMB
        5      2 ?S_EC_MUL_L02
        5      2 ?UL_DIVMOD_L03
      0      2   Init_Values
      0      2   Init_Watchdog


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      34  InitSystem
      60  Init_CPU
     228  Init_IO
      64  Init_TMR
     394  Init_USART
       2  Init_Values
      18  Init_Watchdog
       1  _A_ADCSRA
       1  _A_ADCSRB
       1  _A_ADMUX
       1  _A_DDRA
       1  _A_DDRB
       1  _A_DDRC
       1  _A_DDRD
       1  _A_DDRE
       1  _A_DDRF
       1  _A_DDRG
       1  _A_EICRA
       1  _A_EICRB
       1  _A_EIMSK
       1  _A_MCUCR
       1  _A_OCR0A
       2  _A_OCR3A
       1  _A_PINB
       1  _A_PORTA
       1  _A_PORTB
       1  _A_PORTC
       1  _A_PORTD
       1  _A_PORTE
       1  _A_PORTF
       1  _A_PORTG
       1  _A_PORTK
       1  _A_SREG
       1  _A_TCCR0A
       1  _A_TCCR3A
       1  _A_TCCR3B
       1  _A_TIFR1
       2  _A_UBRR0
       1  _A_UCSR0A
       1  _A_UCSR0B
       1  _A_UCSR0C
       1  _A_WDTCSR
       1  _A_XMCRA
       1  _A_XMCRB

 
  39 bytes in segment ABSOLUTE
 800 bytes in segment CODE
 
 800 bytes of CODE memory
   0 bytes of DATA memory (+ 39 bytes shared)

Errors: none
Warnings: 1
