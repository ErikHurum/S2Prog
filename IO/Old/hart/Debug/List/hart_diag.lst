###############################################################################
#
# IAR C/C++ Compiler V7.30.5.1680 for Microchip AVR       15/Dec/2022  12:17:26
# Copyright 1996-2022 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\hart\Src\hart_diag.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW5568.tmp
#        (D:\S2Prog\IO\hart\Src\hart_diag.c --cpu=m1280 -ms -o
#        D:\S2Prog\IO\hart\Debug\Obj -D OS_LIBMODE_D -D OS_UART=-1 -D DEBUG
#        -lCN D:\S2Prog\IO\hart\Debug\List -y --initializers_in_flash --no_cse
#        --no_inline --no_code_motion --no_cross_call --no_clustering --no_tbaa
#        --debug -DENABLE_BIT_DEFINITIONS -e -I D:\S2Prog\IO\hart\INC\\ -I
#        ..\..\..\Shared\Inc\\ --eeprom_size 4096 --clib -On)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\hart\Debug\List\hart_diag.lst
#    Object file  =  D:\S2Prog\IO\hart\Debug\Obj\hart_diag.r90
#
###############################################################################

D:\S2Prog\IO\hart\Src\hart_diag.c
      1          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0x10b
   \   union <unnamed> volatile __ext_io _A_PORTL
   \                     _A_PORTL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x109
   \   union <unnamed> volatile __ext_io _A_PINL
   \                     _A_PINL:
   \   00000000                      DS8 1
      2          #include "version.h"
      3          #include "inavr.h"
      4          #include "RTOS.h"
      5          
      6          #include "constants.h"
      7          
      8          #include "hart_common.h"
      9          #include "hart.h"
     10          #include "hart_diag.h"
     11          #include "hart_gpio.h"
     12          #include "structs.h"
     13          #include "externals.h"
     14          /////////////////////////////////////////////////////////////////////////////////////
     15          //
     16          // AD7715 summary.
     17          // * some people are stupid enough not to write this down in the code. So I do.
     18          //   -hkim-
     19          //
     20          //
     21          // a. setup communication register
     22          //
     23          // 7        6       5       4       3       2       1       0
     24          // must     must    rs1     rs0     r/w     sdby    g1      g0
     25          // be 0     be 0                    r=1     1 =
     26          //                                  w=0     p down  gain setup
     27          //
     28          // rs1    rs0
     29          // ============
     30          // 0      0       comm reg        8  bit
     31          // 0      1       setup reg       8  bit
     32          // 1      0       test reg        8  bit
     33          // 1      1       data reg        16 bit
     34          //
     35          // g1     g0
     36          // ============
     37          //  0     0       x1
     38          //  0     1       x2
     39          //  1     0       x32
     40          //  1     1       x128
     41          //
     42          // b. setup register (rs1,rs0= 0,1
     43          //
     44          // 7        6       5       4       3       2       1       0
     45          // MD1      MD0     CLK     FS1     FS0     B/U     BUF     FSYNC
     46          // mode selection   opr     output rate     bi/uni  buf     filter
     47          //                  freq                    polar   control sync
     48          //
     49          // CLK should be set to 0 with 1 Mhz clock
     50          //
     51          // MD1    MD0
     52          // ============
     53          // 0      0       normal mode
     54          // 0      1       self calib
     55          // 1      0       zero scale calib
     56          // 1      1       full scale calib
     57          //
     58          // CLK      FS1     FS0
     59          // ================================
     60          // 0        0       0           20 Hz
     61          // 0        0       1           25 Hz
     62          // 0        1       0           100 Hz
     63          // 0        1       1           200 Hz
     64          // 1        0       0           50 Hz
     65          // 1        0       1           60 Hz
     66          // 1        1       0           250 Hz
     67          // 1        1       1           5600 Hz
     68          //
     69          // B/U : 0 bipolar, 1 unipolar
     70          //
     71          // c. test register (rs1,rs0 = 1,0
     72          // just don't use it. chip maker doesn't want you to fuck up with this.
     73          //
     74          // d. data register (rs1,rs0 = 1,1)
     75          //
     76          /////////////////////////////////////////////////////////////////////////////////////
     77          
     78          ////////////////////////////////////////////////////////////////////////////////
     79          //
     80          // private defines
     81          //
     82          ////////////////////////////////////////////////////////////////////////////////
     83          #define HART_DIAG_CONVERSION_COMPLETE         0x01
     84          
     85          ////////////////////////////////////////////////////////////////////////////////
     86          //
     87          // private prototypes
     88          //
     89          ////////////////////////////////////////////////////////////////////////////////
     90          
     91          ////////////////////////////////////////////////////////////////////////////////
     92          //
     93          // hart module privates
     94          //
     95          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     96          static OS_STACKPTR int    _hart_diag_task_stack[60];
   \                     _hart_diag_task_stack:
   \   00000000                      DS8 120

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     97          static OS_TASK            _hart_diag_task;
   \                     _hart_diag_task:
   \   00000000                      DS8 22

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     98          static uint16_t           _num_adc_fuckups = 0;
   \                     _num_adc_fuckups:
   \   00000000                      DS8 2
     99          
    100          ////////////////////////////////////////////////////////////////////////////////
    101          //
    102          // AD7715 related utilities
    103          //
    104          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    105          static void
    106          ad7715_toggle_debug_led(void) {
   \                     ad7715_toggle_debug_led:
    107          	static uint8_t    on_off = 1;
    108          
    109          	hart_gpio_debug_led(on_off);
   \   00000000   9100....           LDS     R16, ??on_off
   \   00000004   ........           CALL    hart_gpio_debug_led
    110          	on_off = !on_off;
   \   00000008   9100....           LDS     R16, ??on_off
   \   0000000C   2300               TST     R16
   \   0000000E   F421               BRNE    ??ad7715_toggle_debug_led_0
   \   00000010   E001               LDI     R16, 1
   \   00000012   9300....           STS     ??on_off, R16
   \   00000016   9508               RET
   \                     ??ad7715_toggle_debug_led_0:
   \   00000018   E000               LDI     R16, 0
   \   0000001A   9300....           STS     ??on_off, R16
    111          }
   \   0000001E   9508               RET

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     ??on_off:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for on_off>`
    112          

   \                                 In  segment CODE, align 2, keep-with-next
    113          static uint8_t
    114          ad7715_read_byte(void) {
   \                     ad7715_read_byte:
    115          	uint8_t i, readbyte;
    116          
    117          	readbyte = 0;
   \   00000000   E000               LDI     R16, 0
    118          
    119          	for (i = 0; i <  8; i++) {
   \   00000002   E010               LDI     R17, 0
   \                     ??ad7715_read_byte_0:
   \   00000004   3018               CPI     R17, 8
   \   00000006   F490               BRCC    ??ad7715_read_byte_1
    120          		readbyte <<= 1;                      // shift to next bit
   \   00000008   0F00               LSL     R16
    121          		AD7715_CLK_LO();
   \   0000000A   9120010B           LDS     R18, 267
   \   0000000E   7F2E               ANDI    R18, 0xFE
   \   00000010   9320010B           STS     267, R18
    122          		AD7715_CLK_HI();
   \   00000014   9120010B           LDS     R18, 267
   \   00000018   6021               ORI     R18, 0x01
   \   0000001A   9320010B           STS     267, R18
    123          
    124          		if (AD7715_MISO_READ()) {
   \   0000001E   9120....           LDS     R18, _A_PINL
   \   00000022   2F32               MOV     R19, R18
   \   00000024   FD31               SBRC    R19, 1
    125          			// data high
    126          			readbyte |= 0x01;                   // set bit high
   \   00000026   6001               ORI     R16, 0x01
    127          		}
    128          	}
   \                     ??ad7715_read_byte_2:
   \   00000028   9513               INC     R17
   \   0000002A   CFEC               RJMP    ??ad7715_read_byte_0
    129          	return readbyte;
   \                     ??ad7715_read_byte_1:
   \   0000002C   9508               RET
   \   0000002E                      REQUIRE _A_PORTL
   \   0000002E                      REQUIRE _A_PINL
    130          }
    131          

   \                                 In  segment CODE, align 2, keep-with-next
    132          static void
    133          ad7715_write_byte(uint8_t data) {
   \                     ad7715_write_byte:
    134          	uint8_t i;
    135          
    136          	for (i = 0; i <  8; i++) {
   \   00000000   E010               LDI     R17, 0
   \                     ??ad7715_write_byte_0:
   \   00000002   3018               CPI     R17, 8
   \   00000004   F4D0               BRCC    ??ad7715_write_byte_1
    137          		AD7715_CLK_LO();
   \   00000006   9120010B           LDS     R18, 267
   \   0000000A   7F2E               ANDI    R18, 0xFE
   \   0000000C   9320010B           STS     267, R18
    138          
    139          		if (data & 0x80) {                        // data bit = 1?
   \   00000010   FB07               BST     R16, 7
   \   00000012   F436               BRTC    ??ad7715_write_byte_2
    140          			AD7715_MOSI_HI();
   \   00000014   9120010B           LDS     R18, 267
   \   00000018   6024               ORI     R18, 0x04
   \   0000001A   9320010B           STS     267, R18
   \   0000001E   C005               RJMP    ??ad7715_write_byte_3
    141          		} else {
    142          			AD7715_MOSI_LO();
   \                     ??ad7715_write_byte_2:
   \   00000020   9120010B           LDS     R18, 267
   \   00000024   7F2B               ANDI    R18, 0xFB
   \   00000026   9320010B           STS     267, R18
    143          		}
    144          		data <<= 1;                              // shift to next bit
   \                     ??ad7715_write_byte_3:
   \   0000002A   0F00               LSL     R16
    145          
    146          		AD7715_CLK_HI();
   \   0000002C   9120010B           LDS     R18, 267
   \   00000030   6021               ORI     R18, 0x01
   \   00000032   9320010B           STS     267, R18
    147          	}
   \   00000036   9513               INC     R17
   \   00000038   CFE4               RJMP    ??ad7715_write_byte_0
    148          }
   \                     ??ad7715_write_byte_1:
   \   0000003A   9508               RET
   \   0000003C                      REQUIRE _A_PORTL
    149          

   \                                 In  segment CODE, align 2, keep-with-next
    150          static void
    151          ad7715_hard_reset(void) {
   \                     ad7715_hard_reset:
    152          	hart_gpio_adc_reset(1);     // high
   \   00000000   E001               LDI     R16, 1
   \   00000002   ........           CALL    hart_gpio_adc_reset
    153          	OS_Delay(100);
   \   00000006   E604               LDI     R16, 100
   \   00000008   E010               LDI     R17, 0
   \   0000000A   ........           CALL    OS_Delay
    154          	hart_gpio_adc_reset(0);     // low
   \   0000000E   E000               LDI     R16, 0
   \   00000010   ........           CALL    hart_gpio_adc_reset
    155          	OS_Delay(500);
   \   00000014   EF04               LDI     R16, 244
   \   00000016   E011               LDI     R17, 1
   \   00000018   ........           CALL    OS_Delay
    156          	hart_gpio_adc_reset(1);     // high
   \   0000001C   E001               LDI     R16, 1
   \   0000001E   ........           CALL    hart_gpio_adc_reset
    157          	OS_Delay(100);
   \   00000022   E604               LDI     R16, 100
   \   00000024   E010               LDI     R17, 0
   \   00000026   ........           CALL    OS_Delay
    158          }
   \   0000002A   9508               RET
    159          

   \                                 In  segment CODE, align 2, keep-with-next
    160          static void
    161          ad7715_put_on_hold(void) {
   \                     ad7715_put_on_hold:
    162          	// select setup reg
    163          	ad7715_write_byte(0x10);
   \   00000000   E100               LDI     R16, 16
   \   00000002   ....               RCALL   ad7715_write_byte
    164          
    165          	// set fsync to put ADC on hold
    166          	ad7715_write_byte(0x0f);
   \   00000004   E00F               LDI     R16, 15
   \   00000006   ....               RCALL   ad7715_write_byte
    167          }
   \   00000008   9508               RET
    168          

   \                                 In  segment CODE, align 2, keep-with-next
    169          static void
    170          ad7715_start_next_sample(void) {
   \                     ad7715_start_next_sample:
    171          	// select setup reg
    172          	ad7715_write_byte(0x10);
   \   00000000   E100               LDI     R16, 16
   \   00000002   ....               RCALL   ad7715_write_byte
    173          
    174          	// clear fsync bit to start conversion
    175          	ad7715_write_byte(0x0e);
   \   00000004   E00E               LDI     R16, 14
   \   00000006   ....               RCALL   ad7715_write_byte
    176          
    177          	//
    178          	// sample will be available after 3x1/output rate, which is 3x1/25 = 120ms.
    179          	// code will be notified by /DRDY
    180          	//
    181          }
   \   00000008   9508               RET
    182          

   \                                 In  segment CODE, align 2, keep-with-next
    183          static uint16_t
    184          ad7715_read_sample(void) {
   \                     ad7715_read_sample:
    185          	uint8_t   lo, hi;
    186          	uint16_t  ret;
    187          
    188          	// select data reg
    189          	ad7715_write_byte(0x38);
   \   00000000   E308               LDI     R16, 56
   \   00000002   ....               RCALL   ad7715_write_byte
    190          
    191          	hi = ad7715_read_byte();
   \   00000004   ....               RCALL   ad7715_read_byte
   \   00000006   2F70               MOV     R23, R16
    192          	lo = ad7715_read_byte();
   \   00000008   ....               RCALL   ad7715_read_byte
   \   0000000A   2F60               MOV     R22, R16
    193          
    194          	ret = (uint16_t)(hi << 8 | lo);
   \   0000000C   2F37               MOV     R19, R23
   \   0000000E   E020               LDI     R18, 0
   \   00000010   2F06               MOV     R16, R22
   \   00000012   E010               LDI     R17, 0
   \   00000014   2B20               OR      R18, R16
   \   00000016   2B31               OR      R19, R17
   \   00000018   01A9               MOVW    R21:R20, R19:R18
    195          
    196          	return ret;
   \   0000001A   018A               MOVW    R17:R16, R21:R20
   \   0000001C   9508               RET
    197          }
    198          

   \                                 In  segment CODE, align 2, keep-with-next
    199          static uint8_t
    200          ad7715_wait_for_drdy(void) {
   \                     ad7715_wait_for_drdy:
    201          	if (OS_WaitEventTimed(HART_DIAG_CONVERSION_COMPLETE, 1000) == 0) {
   \   00000000   EE28               LDI     R18, 232
   \   00000002   E033               LDI     R19, 3
   \   00000004   E001               LDI     R16, 1
   \   00000006   ........           CALL    OS_WaitEventTimed
   \   0000000A   2300               TST     R16
   \   0000000C   F451               BRNE    ??ad7715_wait_for_drdy_0
    202          		_num_adc_fuckups++;
   \   0000000E   ....               LDI     R30, LOW(_num_adc_fuckups)
   \   00000010   ....               LDI     R31, (_num_adc_fuckups) >> 8
   \   00000012   8100               LD      R16, Z
   \   00000014   8111               LDD     R17, Z+1
   \   00000016   5F0F               SUBI    R16, 255
   \   00000018   4F1F               SBCI    R17, 255
   \   0000001A   8300               ST      Z, R16
   \   0000001C   8311               STD     Z+1, R17
    203          		return 1;
   \   0000001E   E001               LDI     R16, 1
   \   00000020   9508               RET
    204          	}
    205          
    206          	// ok
    207          	return 0;
   \                     ??ad7715_wait_for_drdy_0:
   \   00000022   E000               LDI     R16, 0
   \   00000024   9508               RET
    208          }
    209          

   \                                 In  segment CODE, align 2, keep-with-next
    210          static void
    211          ad7715_do_calibration(void) {
   \                     ad7715_do_calibration:
   \   00000000   ........           CALL    ?PROLOGUE3_L09
    212          	//
    213          	// set current channel to 2.5V reference
    214          	//
    215          	hart_gpio_adc_channel_select((hart_channel_t)14);
   \   00000004   E00E               LDI     R16, 14
   \   00000006   ........           CALL    hart_gpio_adc_channel_select
    216          
    217          	//
    218          	// select setup reg (0,1)
    219          	// 7        6         5         4         3         2         1         0
    220          	// 0        0         0         1         0         0         0         0
    221          	//                    setup reg           write     no        gain x1
    222          	//                                                  stby
    223          	ad7715_write_byte(0x10);
   \   0000000A   E100               LDI     R16, 16
   \   0000000C   ....               RCALL   ad7715_write_byte
    224          
    225          	//
    226          	// setup reg to perform calib
    227          	//
    228          	// 7        6         5         4         3         2         1         0
    229          	// 0        1         0         0         1         1         1         0
    230          	// seld calib         1 Mhz     25 Hz Rate          Unipolar  buffed    no fsync
    231          	// mode               clk
    232          	//
    233          	ad7715_write_byte(0x4e);
   \   0000000E   E40E               LDI     R16, 78
   \   00000010   ....               RCALL   ad7715_write_byte
    234          
    235          	//
    236          	// calibration will be complete after 6 x 1/outpur rate
    237          	// which is 6 * 1/25 = roughly 240ms and /DRDY will be asserted.
    238          	//
    239          	(void)ad7715_wait_for_drdy();
   \   00000012   ....               RCALL   ad7715_wait_for_drdy
   \   00000014   2FA0               MOV     R26, R16
    240          
    241          	//
    242          	// read dummy sample. /DRDY will go hi again after this
    243          	//
    244          	(void)ad7715_read_sample();
   \   00000016   ....               RCALL   ad7715_read_sample
   \   00000018   01C8               MOVW    R25:R24, R17:R16
    245          
    246          	ad7715_put_on_hold();
   \   0000001A   ....               RCALL   ad7715_put_on_hold
    247          
    248          	// back to 0
    249          	hart_gpio_adc_channel_select(hart_channel_0);
   \   0000001C   E000               LDI     R16, 0
   \   0000001E   ........           CALL    hart_gpio_adc_channel_select
    250          }
   \   00000022   E0E3               LDI     R30, 3
   \   00000024   ........           JMP     ?EPILOGUE_B3_L09
    251          
    252          
    253          ////////////////////////////////////////////////////////////////////////////////
    254          //
    255          // ADC interrupt handler
    256          //
    257          ////////////////////////////////////////////////////////////////////////////////
    258          #pragma vector=INT0_vect

   \                                 In  segment CODE, align 2, keep-with-next
    259          __interrupt void IntHandler_INT0(void) {
   \                     IntHandler_INT0:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    260          	OS_EnterInterrupt();
   \   00000024   9100....           LDS     R16, OS_InInt
   \   00000028   9503               INC     R16
   \   0000002A   9300....           STS     OS_InInt, R16
   \   0000002E   9100....           LDS     R16, OS_Counters
   \   00000032   9503               INC     R16
   \   00000034   9300....           STS     OS_Counters, R16
   \   00000038   9100....           LDS     R16, (OS_Counters + 1)
   \   0000003C   9503               INC     R16
   \   0000003E   9300....           STS     (OS_Counters + 1), R16
    261          	OS_EnterIntStack();
   \   00000042   94F8               CLI
   \   00000044   ........           CALL    OS__EnterIntStack
   \   00000048   9100....           LDS     R16, (OS_Counters + 1)
   \   0000004C   7F00               ANDI    R16, 0xF0
   \   0000004E   2300               TST     R16
   \   00000050   F021               BREQ    ??IntHandler_INT0_0
   \   00000052   E909               LDI     R16, 153
   \   00000054   E010               LDI     R17, 0
   \   00000056   ........           CALL    OS_Error
   \                     ??IntHandler_INT0_0:
   \   0000005A   9100....           LDS     R16, (OS_Counters + 1)
   \   0000005E   2300               TST     R16
   \   00000060   F409               BRNE    ??IntHandler_INT0_1
   \   00000062   9478               SEI
    262          
    263          	OS_SignalEvent(HART_DIAG_CONVERSION_COMPLETE, &_hart_diag_task);
   \                     ??IntHandler_INT0_1:
   \   00000064   ....               LDI     R18, LOW(_hart_diag_task)
   \   00000066   ....               LDI     R19, (_hart_diag_task) >> 8
   \   00000068   E001               LDI     R16, 1
   \   0000006A   ........           CALL    OS_SignalEvent
    264          
    265          	OS_LeaveIntStack();
   \   0000006E   94F8               CLI
   \   00000070   ........           CALL    OS__LeaveIntStack
    266          	OS_LeaveInterruptNoSwitch();
   \   00000074   9100....           LDS     R16, OS_InInt
   \   00000078   2F10               MOV     R17, R16
   \   0000007A   951A               DEC     R17
   \   0000007C   9310....           STS     OS_InInt, R17
   \   00000080   2300               TST     R16
   \   00000082   F421               BRNE    ??IntHandler_INT0_2
   \   00000084   E908               LDI     R16, 152
   \   00000086   E010               LDI     R17, 0
   \   00000088   ........           CALL    OS_Error
   \                     ??IntHandler_INT0_2:
   \   0000008C   9100....           LDS     R16, (OS_Counters + 1)
   \   00000090   950A               DEC     R16
   \   00000092   9300....           STS     (OS_Counters + 1), R16
   \   00000096   9100....           LDS     R16, OS_Counters
   \   0000009A   950A               DEC     R16
   \   0000009C   9300....           STS     OS_Counters, R16
    267          }
   \   000000A0   BF9B               OUT     0x3B, R25
   \   000000A2   BF8F               OUT     0x3F, R24
   \   000000A4   9109               LD      R16, Y+
   \   000000A6   9119               LD      R17, Y+
   \   000000A8   9129               LD      R18, Y+
   \   000000AA   9139               LD      R19, Y+
   \   000000AC   9149               LD      R20, Y+
   \   000000AE   9159               LD      R21, Y+
   \   000000B0   9169               LD      R22, Y+
   \   000000B2   9179               LD      R23, Y+
   \   000000B4   9009               LD      R0, Y+
   \   000000B6   9019               LD      R1, Y+
   \   000000B8   9029               LD      R2, Y+
   \   000000BA   9039               LD      R3, Y+
   \   000000BC   91E9               LD      R30, Y+
   \   000000BE   91F9               LD      R31, Y+
   \   000000C0   9189               LD      R24, Y+
   \   000000C2   9199               LD      R25, Y+
   \   000000C4   9518               RETI
    268          
    269          ////////////////////////////////////////////////////////////////////////////////
    270          //
    271          // private utilities
    272          //
    273          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    274          static void
    275          hart_diag_configure_adc(void) {
   \                     hart_diag_configure_adc:
    276          	ad7715_hard_reset();
   \   00000000   ....               RCALL   ad7715_hard_reset
    277          	ad7715_do_calibration();
   \   00000002   ....               RCALL   ad7715_do_calibration
    278          }
   \   00000004   9508               RET
    279          
    280          ////////////////////////////////////////////////////////////////////////////////
    281          //
    282          // ADC raw to mA
    283          //
    284          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    285          static void
    286          hart_diag_set_diag_value(hart_channel_t chnl, uint16_t raw_adc) {
   \                     hart_diag_set_diag_value:
   \   00000000   ........           CALL    ?PROLOGUE13_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
   \   00000004                      REQUIRE ?Register_R12_is_cg_reg
   \   00000004   2EC0               MOV     R12, R16
   \   00000006   0159               MOVW    R11:R10, R19:R18
    287          	// the H/W circuit is created using INA138 current shunt and 5 ohm resistor.
    288          	//
    289          	// The input current is between 0 and 20mA. So voltage drop across the 5 Ohm
    290          	// resistor will be between 0 and 0.1V. This voltage difference is fed into
    291          	// INA138 and with 100K RL resistor, the voltage is amplied by 20 times.
    292          	//
    293          	// So the measured voltage to the ADC is in the range of 0V and 2V, where
    294          	// 0V corresponds to 0mA and 2V corresponds to 20mA.
    295          	//
    296          	// Additionally ADC ref voltage is 2.5V, which means 0xffff corresponds 2.5V
    297          	//
    298          	// hkim is kind enough to analyze this freaking circuit himself and leave a
    299          	// record here. Appreciate him.
    300          	//
    301          	// -hkim-
    302          	//
    303          	float       voltage = 2.5f * ((float)(raw_adc)) / 65535.0;
   \   00000008   0185               MOVW    R17:R16, R11:R10
   \   0000000A   E020               LDI     R18, 0
   \   0000000C   E030               LDI     R19, 0
   \   0000000E   ........           CALL    ?UL2F_L04
   \   00000012   E040               LDI     R20, 0
   \   00000014   E050               LDI     R21, 0
   \   00000016   E260               LDI     R22, 32
   \   00000018   E470               LDI     R23, 64
   \   0000001A   ........           CALL    ?F_MUL_L04
   \   0000001E   E040               LDI     R20, 0
   \   00000020   EF5F               LDI     R21, 255
   \   00000022   E76F               LDI     R22, 127
   \   00000024   E477               LDI     R23, 71
   \   00000026   ........           CALL    ?F_DIV_L04
   \   0000002A   0128               MOVW    R5:R4, R17:R16
   \   0000002C   0139               MOVW    R7:R6, R19:R18
    304          	float       current = voltage / 10.0 * 100.0;
   \   0000002E   E040               LDI     R20, 0
   \   00000030   E050               LDI     R21, 0
   \   00000032   E260               LDI     R22, 32
   \   00000034   E471               LDI     R23, 65
   \   00000036   0182               MOVW    R17:R16, R5:R4
   \   00000038   0193               MOVW    R19:R18, R7:R6
   \   0000003A   ........           CALL    ?F_DIV_L04
   \   0000003E   E040               LDI     R20, 0
   \   00000040   E050               LDI     R21, 0
   \   00000042   EC68               LDI     R22, 200
   \   00000044   E472               LDI     R23, 66
   \   00000046   ........           CALL    ?F_MUL_L04
   \   0000004A   01C8               MOVW    R25:R24, R17:R16
   \   0000004C   01D9               MOVW    R27:R26, R19:R18
    305          	current /= 1.0028280;
   \   0000004E   EA4B               LDI     R20, 171
   \   00000050   E55C               LDI     R21, 92
   \   00000052   E860               LDI     R22, 128
   \   00000054   E37F               LDI     R23, 63
   \   00000056   018C               MOVW    R17:R16, R25:R24
   \   00000058   019D               MOVW    R19:R18, R27:R26
   \   0000005A   ........           CALL    ?F_DIV_L04
   \   0000005E   01C8               MOVW    R25:R24, R17:R16
   \   00000060   01D9               MOVW    R27:R26, R19:R18
    306          	// EHSMarkuint16_t    current_final = (uint16_t)(current * 10);       // 10 = 1mA, 1 = 0.1mA
    307          
    308          	if (chnl <= hart_channel_11) {
   \   00000062   E00C               LDI     R16, 12
   \   00000064   16C0               CP      R12, R16
   \   00000066   F4C8               BRCC    ??hart_diag_set_diag_value_0
    309          		HartChannel *hchannel = hart_channel_get_with_lock(chnl);
   \   00000068   2D0C               MOV     R16, R12
   \   0000006A   ........           CALL    hart_channel_get_with_lock
   \   0000006E   0148               MOVW    R9:R8, R17:R16
    310          
    311          		hchannel->MsrdCurrent = current;  //current_final with correction;
   \   00000070   01F4               MOVW    R31:R30, R9:R8
   \   00000072   8383               STD     Z+3, R24
   \   00000074   8394               STD     Z+4, R25
   \   00000076   83A5               STD     Z+5, R26
   \   00000078   83B6               STD     Z+6, R27
    312          
    313          		// Always update the mA from the ADC for diagnostics purpose
    314          		TData.Hart.ADCurrent[chnl] = current;               // PROData 0 is the Hart PV(Primary Value)
   \   0000007A   2D0C               MOV     R16, R12
   \   0000007C   E010               LDI     R17, 0
   \   0000007E   0F00               LSL     R16
   \   00000080   1F11               ROL     R17
   \   00000082   0F00               LSL     R16
   \   00000084   1F11               ROL     R17
   \   00000086   01F8               MOVW    R31:R30, R17:R16
   \   00000088   ....               SUBI    R30, LOW((-(TData + 158) & 0xFFFF))
   \   0000008A   ....               SBCI    R31, HIGH((-(TData + 158) & 0xFFFF))
   \   0000008C   8380               ST      Z, R24
   \   0000008E   8391               STD     Z+1, R25
   \   00000090   83A2               STD     Z+2, R26
   \   00000092   83B3               STD     Z+3, R27
    315          		hart_channel_put_with_unlock(hchannel);
   \   00000094   0184               MOVW    R17:R16, R9:R8
   \   00000096   ........           CALL    hart_channel_put_with_unlock
    316          	}
    317          }
   \                     ??hart_diag_set_diag_value_0:
   \   0000009A   E0ED               LDI     R30, 13
   \   0000009C   ........           JMP     ?EPILOGUE_B13_L09
    318          
    319          ////////////////////////////////////////////////////////////////////////////////
    320          //
    321          // HART Diagnostic Task
    322          //
    323          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    324          static void
    325          ad7715_read_diag_adc(hart_channel_t chnl) {
   \                     ad7715_read_diag_adc:
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   2FA0               MOV     R26, R16
    326          
    327          	hart_gpio_adc_channel_select(chnl);
   \   00000006   2F0A               MOV     R16, R26
   \   00000008   ........           CALL    hart_gpio_adc_channel_select
    328          	ad7715_start_next_sample();
   \   0000000C   ....               RCALL   ad7715_start_next_sample
    329          	ad7715_wait_for_drdy();
   \   0000000E   ....               RCALL   ad7715_wait_for_drdy
    330          	uint16_t raw_adc = ad7715_read_sample();
   \   00000010   ....               RCALL   ad7715_read_sample
   \   00000012   01C8               MOVW    R25:R24, R17:R16
    331          	ad7715_put_on_hold();
   \   00000014   ....               RCALL   ad7715_put_on_hold
    332          
    333          	hart_diag_set_diag_value(chnl, raw_adc);
   \   00000016   019C               MOVW    R19:R18, R25:R24
   \   00000018   2F0A               MOV     R16, R26
   \   0000001A   ....               RCALL   hart_diag_set_diag_value
    334          }
   \   0000001C   E0E3               LDI     R30, 3
   \   0000001E   ........           JMP     ?EPILOGUE_B3_L09
    335          

   \                                 In  segment CODE, align 2, keep-with-next
    336          static void
    337          HARTDiag_Task(void) {
   \                     HARTDiag_Task:
   \   00000000   938A               ST      -Y, R24
    338          	hart_channel_t      current;
    339          
    340          	hart_diag_configure_adc();
   \   00000002   ....               RCALL   hart_diag_configure_adc
    341          
    342          	while (1) {
    343          		hart_for_each_channel(current) {
   \                     ??HARTDiag_Task_0:
   \   00000004   E080               LDI     R24, 0
   \                     ??HARTDiag_Task_1:
   \   00000006   308C               CPI     R24, 12
   \   00000008   F7E8               BRCC    ??HARTDiag_Task_0
    344          			ad7715_read_diag_adc(current);
   \   0000000A   2F08               MOV     R16, R24
   \   0000000C   ....               RCALL   ad7715_read_diag_adc
    345          			ad7715_toggle_debug_led();
   \   0000000E   ....               RCALL   ad7715_toggle_debug_led
    346          		}
   \   00000010   9583               INC     R24
   \   00000012   CFF9               RJMP    ??HARTDiag_Task_1
    347          
    348          #if 0 // for ADC debugging only
    349          		ad7715_read_diag_adc((hart_channel_t)12);
    350          		ad7715_read_diag_adc((hart_channel_t)13);
    351          		//
    352          		// 2.5V reference check for debugging
    353          		//
    354          		ad7715_read_diag_adc((hart_channel_t)14);
    355          
    356          		//
    357          		// 0V ground
    358          		//
    359          		ad7715_read_diag_adc((hart_channel_t)15);
    360          #endif
    361          	}
    362          }
    363          
    364          ////////////////////////////////////////////////////////////////////////////////
    365          //
    366          // public interfaces
    367          //
    368          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    369          void
    370          hart_diag_init(void) {
   \                     hart_diag_init:
    371          	// FIXME initialize diag data structure
    372          }
   \   00000000   9508               RET
    373          

   \                                 In  segment CODE, align 2, keep-with-next
    374          void
    375          hart_diag_task_start(void) {
   \                     hart_diag_task_start:
    376          	OS_CREATETASK(&_hart_diag_task, "HARTDiag", HARTDiag_Task, 90, _hart_diag_task_stack);
   \   00000000   E002               LDI     R16, 2
   \   00000002   E010               LDI     R17, 0
   \   00000004   931A               ST      -Y, R17
   \   00000006   930A               ST      -Y, R16
   \   00000008   E708               LDI     R16, 120
   \   0000000A   E010               LDI     R17, 0
   \   0000000C   931A               ST      -Y, R17
   \   0000000E   930A               ST      -Y, R16
   \   00000010   ....               LDI     R16, LOW(_hart_diag_task_stack)
   \   00000012   ....               LDI     R17, (_hart_diag_task_stack) >> 8
   \   00000014   931A               ST      -Y, R17
   \   00000016   930A               ST      -Y, R16
   \   00000018   ....               LDI     R22, LOW(HARTDiag_Task/2)
   \   0000001A   ....               LDI     R23, (HARTDiag_Task/2) >> 8
   \   0000001C   E54A               LDI     R20, 90
   \   0000001E   ....               LDI     R18, LOW(`?<Constant "HARTDiag">`)
   \   00000020   ....               LDI     R19, (`?<Constant "HARTDiag">`) >> 8
   \   00000022   ....               LDI     R16, LOW(_hart_diag_task)
   \   00000024   ....               LDI     R17, (_hart_diag_task) >> 8
   \   00000026   ........           CALL    OS_CreateTask_D
    377          }
   \   0000002A   9508               RET

   \                                 In  segment INTVEC, offset 0x4, root
   \                     `??IntHandler_INT0::??INTVEC 4`:
   \   00000004   ........           JMP     IntHandler_INT0

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "HARTDiag">>`:
   \   00000000   414854526944       DC8 "HARTDiag"
   \              676100      

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for on_off>`:
   \   00000000   01                 DC8 1

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant "HARTDiag">`:
   \   00000000                      DS8 9
   \   00000009                      REQUIRE `?<Initializer for <Constant "HARTDiag">>`

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      1      2   HARTDiag_Task
        1      2   -> ad7715_read_diag_adc
        1      2   -> ad7715_toggle_debug_led
        1      2   -> hart_diag_configure_adc
     16      2   IntHandler_INT0
       16      2   -> OS_Error
       16      2   -> OS_SignalEvent
       16      2   -> OS__EnterIntStack
       16      2   -> OS__LeaveIntStack
      3      2   ad7715_do_calibration
        3      2   -> ad7715_put_on_hold
        3      2   -> ad7715_read_sample
        3      2   -> ad7715_wait_for_drdy
        3      2   -> ad7715_write_byte
        3      2   -> hart_gpio_adc_channel_select
      0      2   ad7715_hard_reset
        0      2   -> OS_Delay
        0      2   -> hart_gpio_adc_reset
      0      2   ad7715_put_on_hold
        0      2   -> ad7715_write_byte
      0      2   ad7715_read_byte
      3      2   ad7715_read_diag_adc
        3      2   -> ad7715_put_on_hold
        3      2   -> ad7715_read_sample
        3      2   -> ad7715_start_next_sample
        3      2   -> ad7715_wait_for_drdy
        3      2   -> hart_diag_set_diag_value
        3      2   -> hart_gpio_adc_channel_select
      0      2   ad7715_read_sample
        0      2   -> ad7715_read_byte
        0      2   -> ad7715_write_byte
      0      2   ad7715_start_next_sample
        0      2   -> ad7715_write_byte
      0      2   ad7715_toggle_debug_led
        0      2   -> hart_gpio_debug_led
      0      2   ad7715_wait_for_drdy
        0      2   -> OS_WaitEventTimed
      0      2   ad7715_write_byte
      0      2   hart_diag_configure_adc
        0      2   -> ad7715_do_calibration
        0      2   -> ad7715_hard_reset
      0      2   hart_diag_init
     13      2   hart_diag_set_diag_value
       13      2   -> hart_channel_get_with_lock
       13      2   -> hart_channel_put_with_unlock
       13      2 ?F_DIV_L04
       13      2 ?F_MUL_L04
       13      2 ?UL2F_L04
      6      2   hart_diag_task_start
        0      2   -> OS_CreateTask_D


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant "HARTDiag">
       9  ?<Initializer for <Constant "HARTDiag">>
       1  ?<Initializer for on_off>
      20  HARTDiag_Task
     198  IntHandler_INT0
       4  IntHandler_INT0::??INTVEC 4
       1  _A_PINL
       1  _A_PORTL
      22  _hart_diag_task
     120  _hart_diag_task_stack
       2  _num_adc_fuckups
      40  ad7715_do_calibration
      44  ad7715_hard_reset
      10  ad7715_put_on_hold
      46  ad7715_read_byte
      34  ad7715_read_diag_adc
      30  ad7715_read_sample
      10  ad7715_start_next_sample
      32  ad7715_toggle_debug_led
      38  ad7715_wait_for_drdy
      60  ad7715_write_byte
       6  hart_diag_configure_adc
       2  hart_diag_init
     160  hart_diag_set_diag_value
      44  hart_diag_task_start
       1  on_off
      14  -- Other

 
   2 bytes in segment ABSOLUTE
 774 bytes in segment CODE
  14 bytes in segment INITTAB
   4 bytes in segment INTVEC
  10 bytes in segment NEAR_I
  10 bytes in segment NEAR_ID
 144 bytes in segment NEAR_Z
 
 784 bytes of CODE memory (+ 18 bytes shared)
 154 bytes of DATA memory (+  2 bytes shared)

Errors: none
Warnings: none
