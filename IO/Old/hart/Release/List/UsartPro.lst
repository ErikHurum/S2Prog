###############################################################################
#
# IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR       24/Aug/2022  14:11:46
# Copyright 1996-2021 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\hart\Src\UsartPro.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW5C07.tmp
#        (D:\S2Prog\IO\hart\Src\UsartPro.c --cpu=m1280 -ms -o
#        D:\S2Prog\IO\hart\Release\Obj -D OS_LIBMODE_S -D OS_UART=-1 -lCN
#        D:\S2Prog\IO\hart\Release\List -y --initializers_in_flash --no_tbaa
#        --enable_external_bus -DENABLE_BIT_DEFINITIONS -e -I
#        D:\S2Prog\IO\hart\INC\\ -I ..\..\..\Shared\Inc\\ --eeprom_size 4096
#        --clib -Oh)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\hart\Release\List\UsartPro.lst
#    Object file  =  D:\S2Prog\IO\hart\Release\Obj\UsartPro.r90
#
###############################################################################

D:\S2Prog\IO\hart\Src\UsartPro.c
      1          /****************************************************************************************
      2          / Com protocol for USART0
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0xc1
   \   union <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x60
   \   union <unnamed> volatile __io _A_WDTCSR
   \                     _A_WDTCSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2e
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "string.h"
     10          #include "RTOS.h"
     11          #include "hart.h"
     12          #include "externals.h"
     13          #include "version.h"
     14          #include "structs.h"
     15          
     16          /*************************************************************************
     17          *   (This is a timer calback)
     18          *  Timout timer USART 0
     19          *
     20          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     21          void TimoutUSART0(void) {
   \                     TimoutUSART0:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     22          
     23          	UCSR0B &= ~(__BIT_MASK(UDRIE0));            // transmission end, disable int.
   \   00000000   910000C1           LDS     R16, 193
   \   00000004   7D0F               ANDI    R16, 0xDF
   \   00000006   930000C1           STS     193, R16
     24          	ClrBit(PORTE, 0x04);                              // TXE0 off
   \   0000000A   94F8               CLI
   \   0000000C   9872               CBI     0x0E, 0x02
   \   0000000E   9100....           LDS     R16, (OS_Counters + 1)
   \   00000012   2300               TST     R16
   \   00000014   F409               BRNE    ??TimoutUSART0_0
   \   00000016   9478               SEI
     25          	OS_StopTimer(&TimerUSART0);                    // and stop timer
   \                     ??TimoutUSART0_0:
   \   00000018   ....               LDI     R16, LOW(TimerUSART0)
   \   0000001A   ....               LDI     R17, (TimerUSART0) >> 8
   \   0000001C   ........           CALL    OS_StopTimer
     26          	GoToSyncUART(0);                                    // go to sync modus for recive
   \   00000020   E000               LDI     R16, 0
   \   00000022   ....               RJMP    GoToSyncUART
   \   00000024                      REQUIRE _A_UCSR0B
   \   00000024                      REQUIRE _A_PORTE
     27          }
     28          
     29          /*************************************************************************
     30          *   (This is a timer calback)
     31          *  Timer USART 0 on before TX
     32          *
     33          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     34          void TimoutUSART0On(void) {
   \                     TimoutUSART0On:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     35          
     36          	UCSR0B |= __BIT_MASK(UDRIE0);                     // start sending by enableing interrupt
   \   00000000   910000C1           LDS     R16, 193
   \   00000004   6200               ORI     R16, 0x20
   \   00000006   930000C1           STS     193, R16
     37          	OS_StopTimer(&TimerUSART0On);                    // and stop timer
   \   0000000A   ....               LDI     R16, LOW(TimerUSART0On)
   \   0000000C   ....               LDI     R17, (TimerUSART0On) >> 8
   \   0000000E   ........           JMP     OS_StopTimer
   \   00000012                      REQUIRE _A_UCSR0B
     38          }
     39          
     40          /*************************************************************************
     41          *   (This is a timer calback)
     42          *  Timout timer USART 1
     43          *
     44          *************************************************************************/
     45          
     46          /*************************************************************************
     47          *   (This is a timer calback)
     48          *  Timer USART 1 on before TX
     49          *
     50          *************************************************************************/
     51          
     52          
     53          /*************************************************************************
     54          *   
     55          *  Handle the ANPRO10 protocol
     56          *
     57          *************************************************************************/

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     58          unsigned short LastCommand = 0;
   \                     LastCommand:
   \   00000000                      DS8 2

   \                                 In  segment CODE, align 2, keep-with-next
     59          char ANPRO10_UnpackPacket(UARTDataType *pUART, unsigned char *Buf) {
   \                     ANPRO10_UnpackPacket:
   \   00000000   92DA               ST      -Y, R13
   \   00000002   92CA               ST      -Y, R12
   \   00000004   92BA               ST      -Y, R11
   \   00000006   92AA               ST      -Y, R10
   \   00000008   929A               ST      -Y, R9
   \   0000000A   928A               ST      -Y, R8
   \   0000000C   927A               ST      -Y, R7
   \   0000000E   926A               ST      -Y, R6
   \   00000010   925A               ST      -Y, R5
   \   00000012   924A               ST      -Y, R4
   \   00000014   93BA               ST      -Y, R27
   \   00000016   93AA               ST      -Y, R26
   \   00000018   939A               ST      -Y, R25
   \   0000001A   938A               ST      -Y, R24
   \   0000001C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R6_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R7_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R8_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R9_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R10_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R11_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R12_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R13_is_cg_reg
   \   0000001C                      REQUIRE __RSTACK_in_external_ram_new_way
   \   0000001C   0128               MOVW    R5:R4, R17:R16
   \   0000001E   01D9               MOVW    R27:R26, R19:R18
     60          	char ch = pUART->Channel;
   \   00000020   01F8               MOVW    R31:R30, R17:R16
   \   00000022   8C85               LDD     R8, Z+29
     61          	pUART->RxCount++;
   \   00000024   8D03               LDD     R16, Z+27
   \   00000026   8D14               LDD     R17, Z+28
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   8F03               STD     Z+27, R16
   \   0000002E   8F14               STD     Z+28, R17
     62          	pUART->RxSendReply = false;                              // flag for answering set to fault
   \   00000030   E000               LDI     R16, 0
   \   00000032   8F02               STD     Z+26, R16
     63          	pUART->TxFirst     = 11;                                 // Start pos for first TX command
   \   00000034   E00B               LDI     R16, 11
   \   00000036   8302               STD     Z+2, R16
   \   00000038   E000               LDI     R16, 0
   \   0000003A   8303               STD     Z+3, R16
     64          
     65          	ANPRO10_PacketHeading *pPH = (ANPRO10_PacketHeading *)Buf;
   \   0000003C   01C9               MOVW    R25:R24, R19:R18
     66          	char MyPacket = (pPH->rxadr == MyAddress());
   \   0000003E   ........           CALL    MyAddress
   \   00000042   01FC               MOVW    R31:R30, R25:R24
   \   00000044   8111               LDD     R17, Z+1
   \   00000046   1710               CP      R17, R16
   \   00000048   F009               BREQ    $+2+2
   \   0000004A   C04B               RJMP    ??ANPRO10_UnpackPacket_0
   \   0000004C   24DD               CLR     R13
   \   0000004E   94D3               INC     R13
     67          	if (MyPacket) {
     68          		Buf += sizeof(ANPRO10_PacketHeading);
   \   00000050   9617               ADIW    R27:R26, 7
     69          		unsigned char *EndPtr =  &Buf[pPH->nob];
   \   00000052   8104               LDD     R16, Z+4
   \   00000054   8115               LDD     R17, Z+5
   \   00000056   013D               MOVW    R7:R6, R27:R26
   \   00000058   0E60               ADD     R6, R16
   \   0000005A   1E71               ADC     R7, R17
     70          		ANPRO10_CommandHeading *pCH;
     71          		char MoreCommands = true;
   \   0000005C   E108               LDI     R16, 24
   \   0000005E   2EC0               MOV     R12, R16
   \   00000060   E00F               LDI     R16, 15
   \   00000062   2EB0               MOV     R11, R16
   \   00000064   E008               LDI     R16, 8
   \   00000066   2EA0               MOV     R10, R16
   \   00000068   2499               CLR     R9
   \   0000006A   949A               DEC     R9
     72          		do {
     73          			pCH = (ANPRO10_CommandHeading *)Buf;
   \                     ??ANPRO10_UnpackPacket_1:
   \   0000006C   01CD               MOVW    R25:R24, R27:R26
     74          			Buf += sizeof(ANPRO10_CommandHeading);  // ??
   \   0000006E   9614               ADIW    R27:R26, 4
     75          			switch (pCH->CommandNo) {
   \   00000070   01FC               MOVW    R31:R30, R25:R24
   \   00000072   8100               LD      R16, Z
   \   00000074   8111               LDD     R17, Z+1
   \   00000076   01F8               MOVW    R31:R30, R17:R16
   \   00000078   9630               ADIW    R31:R30, 0
   \   0000007A   F031               BREQ    ??ANPRO10_UnpackPacket_2
   \   0000007C   9731               SBIW    R31:R30, 1
   \   0000007E   F021               BREQ    ??ANPRO10_UnpackPacket_2
     76          			case ECMD_NMDWOACK:
     77          			case ECMD_NMDRQACK:
     78          				break;
     79          			default:
     80          				LastCommand = pCH->CommandNo;
   \   00000080   9300....           STS     LastCommand, R16
   \   00000084   9310....           STS     (LastCommand + 1), R17
     81          				break;
     82          			}
     83          			switch (pCH->CommandNo) {
   \                     ??ANPRO10_UnpackPacket_2:
   \   00000088   01FC               MOVW    R31:R30, R25:R24
   \   0000008A   8100               LD      R16, Z
   \   0000008C   81F1               LDD     R31, Z+1
   \   0000008E   2FE0               MOV     R30, R16
   \   00000090   9630               ADIW    R31:R30, 0
   \   00000092   F409               BRNE    $+2+2
   \   00000094   C07E               RJMP    ??ANPRO10_UnpackPacket_3
   \   00000096   9731               SBIW    R31:R30, 1
   \   00000098   F409               BRNE    $+2+2
   \   0000009A   C07B               RJMP    ??ANPRO10_UnpackPacket_3
   \   0000009C   5EE7               SUBI    R30, 231
   \   0000009E   40F3               SBCI    R31, 3
   \   000000A0   F0E9               BREQ    ??ANPRO10_UnpackPacket_4
   \   000000A2   973A               SBIW    R31:R30, 10
   \   000000A4   F121               BREQ    ??ANPRO10_UnpackPacket_5
   \   000000A6   973A               SBIW    R31:R30, 10
   \   000000A8   F129               BREQ    ??ANPRO10_UnpackPacket_6
   \   000000AA   97F2               SBIW    R31:R30, 50
   \   000000AC   F189               BREQ    ??ANPRO10_UnpackPacket_7
   \   000000AE   973A               SBIW    R31:R30, 10
   \   000000B0   F199               BREQ    ??ANPRO10_UnpackPacket_8
   \   000000B2   973A               SBIW    R31:R30, 10
   \   000000B4   F1A9               BREQ    ??ANPRO10_UnpackPacket_9
   \   000000B6   5AE0               SUBI    R30, 160
   \   000000B8   40F0               SBCI    R31, 0
   \   000000BA   F1B1               BREQ    ??ANPRO10_UnpackPacket_10
   \   000000BC   973A               SBIW    R31:R30, 10
   \   000000BE   F409               BRNE    $+2+2
   \   000000C0   C046               RJMP    ??ANPRO10_UnpackPacket_11
   \   000000C2   973A               SBIW    R31:R30, 10
   \   000000C4   F409               BRNE    $+2+2
   \   000000C6   C047               RJMP    ??ANPRO10_UnpackPacket_12
   \   000000C8   973A               SBIW    R31:R30, 10
   \   000000CA   F409               BRNE    $+2+2
   \   000000CC   C053               RJMP    ??ANPRO10_UnpackPacket_13
   \   000000CE   973A               SBIW    R31:R30, 10
   \   000000D0   F409               BRNE    $+2+2
   \   000000D2   C054               RJMP    ??ANPRO10_UnpackPacket_14
   \   000000D4   56EC               SUBI    R30, 108
   \   000000D6   40F2               SBCI    R31, 2
   \   000000D8   F031               BREQ    ??ANPRO10_UnpackPacket_15
   \   000000DA   C052               RJMP    ??ANPRO10_UnpackPacket_16
     84          			case CMD_TXU_COMPRESSED_PACKET:
     85          				//Decompress(Size,Buf,Port);
     86          				break;
     87          			case CMD_REQ_STATUS :                           // Regusest status for target
     88          				BuildStatusData(ch);                         // make package
   \                     ??ANPRO10_UnpackPacket_4:
   \   000000DC   2D08               MOV     R16, R8
   \   000000DE   ....               RCALL   BuildStatusData
     89          				break;
   \   000000E0   C04F               RJMP    ??ANPRO10_UnpackPacket_16
   \                     ??ANPRO10_UnpackPacket_0:
   \   000000E2   24DD               CLR     R13
   \   000000E4   C05C               RJMP    ??ANPRO10_UnpackPacket_17
     90          			case CMD_GET_STACKSTATUS :                        // Request stck status
     91          				BuildStackStatus(ch, Buf);                     // receive package
   \                     ??ANPRO10_UnpackPacket_15:
   \   000000E6   019D               MOVW    R19:R18, R27:R26
   \   000000E8   2D08               MOV     R16, R8
   \   000000EA   ....               RCALL   BuildStackStatus
     92          				break;
   \   000000EC   C049               RJMP    ??ANPRO10_UnpackPacket_16
     93          			case CMD_EEPROM_RESET :                        // Reset EEPROM??
     94          				GetResetEEPROM(ch, Buf);                     // receive package
   \                     ??ANPRO10_UnpackPacket_5:
   \   000000EE   ........           CALL    EEPROMReset
     95          				break;
   \   000000F2   C046               RJMP    ??ANPRO10_UnpackPacket_16
   \                     ??ANPRO10_UnpackPacket_6:
   \   000000F4   99F9               SBIC    0x1F, 0x01
   \   000000F6   CFFE               RJMP    ??ANPRO10_UnpackPacket_6
   \   000000F8   BC91               OUT     0x21, R9
   \   000000FA   BCB2               OUT     0x22, R11
   \   000000FC   BC90               OUT     0x20, R9
   \   000000FE   9AFA               SBI     0x1F, 0x02
   \   00000100   9AF9               SBI     0x1F, 0x01
   \                     ??ANPRO10_UnpackPacket_18:
   \   00000102   99F9               SBIC    0x1F, 0x01
   \   00000104   CFFE               RJMP    ??ANPRO10_UnpackPacket_18
   \   00000106   92C0....           STS     _A_WDTCSR, R12
   \   0000010A   92A0....           STS     _A_WDTCSR, R10
     96          			case CMD_GOTO_BOOTLOADER :                        // Goto bootlaoder??
     97          				GetGotoBootloader(ch, Buf);                     // receive package
     98          				break;
   \   0000010E   C038               RJMP    ??ANPRO10_UnpackPacket_16
     99          			case CMD_SND_EEPROM_DATA :                              // Receive EEPROM data
    100          				GetEEPROMData(ch, Buf);                     // receive package
   \                     ??ANPRO10_UnpackPacket_7:
   \   00000110   019D               MOVW    R19:R18, R27:R26
   \   00000112   2D08               MOV     R16, R8
   \   00000114   ....               RCALL   GetEEPROMData
    101          				break;
   \   00000116   C034               RJMP    ??ANPRO10_UnpackPacket_16
    102          			case CMD_REQ_EEPROM_DATA :                              // Request to send EEPROM data
    103          				BuildEEPROMData(ch, Buf);                     // receive package
   \                     ??ANPRO10_UnpackPacket_8:
   \   00000118   019D               MOVW    R19:R18, R27:R26
   \   0000011A   2D08               MOV     R16, R8
   \   0000011C   ....               RCALL   BuildEEPROMData
    104          				break;
   \   0000011E   C030               RJMP    ??ANPRO10_UnpackPacket_16
    105          			case CMD_REQ_INT_DATA :                              // Request external data
    106          				BuildADInt(ch, Buf);                     // receive package
   \                     ??ANPRO10_UnpackPacket_9:
   \   00000120   019D               MOVW    R19:R18, R27:R26
   \   00000122   2D08               MOV     R16, R8
   \   00000124   ....               RCALL   BuildADInt
    107          				break;
   \   00000126   C02C               RJMP    ??ANPRO10_UnpackPacket_16
    108          			case CMD_SND_HART_SETUP :                              // Receive sertup of AN-RSANA
    109          				GetHartSetup(ch, Buf);                     // receive package
   \                     ??ANPRO10_UnpackPacket_10:
   \   00000128   910C               LD      R16, X
   \   0000012A   01FD               MOVW    R31:R30, R27:R26
   \   0000012C   8111               LDD     R17, Z+1
   \   0000012E   9300....           STS     (TData + 144), R16
   \   00000132   9310....           STS     (TData + 145), R17
   \   00000136   8120               LD      R18, Z
   \   00000138   E002               LDI     R16, 2
   \   0000013A   E010               LDI     R17, 0
   \   0000013C   ........           CALL    WriteEEPROMByte
   \   00000140   01FD               MOVW    R31:R30, R27:R26
   \   00000142   8121               LDD     R18, Z+1
   \   00000144   E003               LDI     R16, 3
   \   00000146   E010               LDI     R17, 0
   \   00000148   ........           CALL    WriteEEPROMByte
    110          				break;
   \   0000014C   C019               RJMP    ??ANPRO10_UnpackPacket_16
    111          			case CMD_REQ_HART_SETUP :                              // Request for sertup of AN-RSANA
    112          				BuildHartSetup(ch, Buf);                     // receive package
   \                     ??ANPRO10_UnpackPacket_11:
   \   0000014E   019D               MOVW    R19:R18, R27:R26
   \   00000150   2D08               MOV     R16, R8
   \   00000152   ....               RCALL   BuildHartSetup
    113          				break;
   \   00000154   C015               RJMP    ??ANPRO10_UnpackPacket_16
    114          			case CMD_SND_HART_FILTER :                              // Receive filter of AN-RSANA
    115          				GetHartFilter(ch, Buf);                     // receive package
   \                     ??ANPRO10_UnpackPacket_12:
   \   00000156   019D               MOVW    R19:R18, R27:R26
   \   00000158   E040               LDI     R20, 0
   \   0000015A   E01C               LDI     R17, 12
   \                     ??ANPRO10_UnpackPacket_19:
   \   0000015C   01F9               MOVW    R31:R30, R19:R18
   \   0000015E   9101               LD      R16, Z+
   \   00000160   019F               MOVW    R19:R18, R31:R30
   \   00000162   E0F0               LDI     R31, 0
   \   00000164   2FE4               MOV     R30, R20
   \   00000166   ....               SUBI    R30, LOW((-(TData + 146) & 0xFFFF))
   \   00000168   ....               SBCI    R31, HIGH((-(TData + 146) & 0xFFFF))
   \   0000016A   8300               ST      Z, R16
   \   0000016C   9543               INC     R20
   \   0000016E   951A               DEC     R17
   \   00000170   F039               BREQ    ??ANPRO10_UnpackPacket_16
   \   00000172   CFF4               RJMP    ??ANPRO10_UnpackPacket_19
    116          				break;
    117          			case CMD_REQ_HART_FILTER :                              // Request filter of AN-RSANA
    118          				BuildHartFilter(ch, Buf);                     // receive package
   \                     ??ANPRO10_UnpackPacket_13:
   \   00000174   019D               MOVW    R19:R18, R27:R26
   \   00000176   2D08               MOV     R16, R8
   \   00000178   ....               RCALL   BuildHartFilter
    119          				break;
   \   0000017A   C002               RJMP    ??ANPRO10_UnpackPacket_16
    120          			case CMD_REQ_HART_DATA :                              // Request ANA data(4-20ma)
    121          				//EHSMark BuildMDataANA(ch, pointer+4) ;                     // receive
    122          				BuildMDataHart(pUART);                     // receive
   \                     ??ANPRO10_UnpackPacket_14:
   \   0000017C   0182               MOVW    R17:R16, R5:R4
   \   0000017E   ....               RCALL   BuildMDataHart
    123          				break;
    124          
    125          			case ECMD_NMDWOACK:
    126          			case ECMD_NMDRQACK:
    127          				MoreCommands = false;
    128          				break;
    129          			default:
    130          				break;
    131          
    132          			}
    133          			if (MoreCommands) {
    134          				Buf += pCH->ndb;
   \                     ??ANPRO10_UnpackPacket_16:
   \   00000180   01FC               MOVW    R31:R30, R25:R24
   \   00000182   8102               LDD     R16, Z+2
   \   00000184   8113               LDD     R17, Z+3
   \   00000186   0FA0               ADD     R26, R16
   \   00000188   1FB1               ADC     R27, R17
   \   0000018A   15A6               CP      R26, R6
   \   0000018C   05B7               CPC     R27, R7
   \   0000018E   F408               BRCC    $+2+2
   \   00000190   CF6D               RJMP    ??ANPRO10_UnpackPacket_1
    135          			}
    136          		} while (MoreCommands && (Buf < EndPtr));
    137          	}
    138          	if (MyPacket) {
    139          		if (pUART->RxSendReply) {                                   //send answer?
   \                     ??ANPRO10_UnpackPacket_3:
   \   00000192   01F2               MOVW    R31:R30, R5:R4
   \   00000194   8D02               LDD     R16, Z+26
   \   00000196   2300               TST     R16
   \   00000198   F011               BREQ    ??ANPRO10_UnpackPacket_17
    140          			Uart_BuildTail(pUART);                                       // yes, build tail (and header) and start sending
   \   0000019A   0182               MOVW    R17:R16, R5:R4
   \   0000019C   ....               RCALL   Uart_BuildTail
    141          		}
    142          	}
    143          	return (MyPacket);
   \                     ??ANPRO10_UnpackPacket_17:
   \   0000019E   2D0D               MOV     R16, R13
   \   000001A0   9189               LD      R24, Y+
   \   000001A2   9199               LD      R25, Y+
   \   000001A4   91A9               LD      R26, Y+
   \   000001A6   91B9               LD      R27, Y+
   \   000001A8   9049               LD      R4, Y+
   \   000001AA   9059               LD      R5, Y+
   \   000001AC   9069               LD      R6, Y+
   \   000001AE   9079               LD      R7, Y+
   \   000001B0   9089               LD      R8, Y+
   \   000001B2   9099               LD      R9, Y+
   \   000001B4   90A9               LD      R10, Y+
   \   000001B6   90B9               LD      R11, Y+
   \   000001B8   90C9               LD      R12, Y+
   \   000001BA   90D9               LD      R13, Y+
   \   000001BC   9508               RET
   \   000001BE                      REQUIRE _A_EECR
   \   000001BE                      REQUIRE _A_EEAR
   \   000001BE                      REQUIRE _A_EEDR
   \   000001BE                      REQUIRE _A_WDTCSR
    144          }
    145          
    146          #define MAX_TIME_BETWEEN_BYTE	50
    147          

   \                                 In  segment CODE, align 2, keep-with-next
    148          char ANPRO10_IO_Receive(UARTDataType *pUART) {
   \                     ANPRO10_IO_Receive:
   \   00000000   92FA               ST      -Y, R15
   \   00000002   92EA               ST      -Y, R14
   \   00000004   92DA               ST      -Y, R13
   \   00000006   92CA               ST      -Y, R12
   \   00000008   92BA               ST      -Y, R11
   \   0000000A   92AA               ST      -Y, R10
   \   0000000C   929A               ST      -Y, R9
   \   0000000E   928A               ST      -Y, R8
   \   00000010   927A               ST      -Y, R7
   \   00000012   926A               ST      -Y, R6
   \   00000014   925A               ST      -Y, R5
   \   00000016   924A               ST      -Y, R4
   \   00000018   93BA               ST      -Y, R27
   \   0000001A   93AA               ST      -Y, R26
   \   0000001C   939A               ST      -Y, R25
   \   0000001E   938A               ST      -Y, R24
   \   00000020                      REQUIRE ?Register_R4_is_cg_reg
   \   00000020                      REQUIRE ?Register_R5_is_cg_reg
   \   00000020                      REQUIRE ?Register_R6_is_cg_reg
   \   00000020                      REQUIRE ?Register_R7_is_cg_reg
   \   00000020                      REQUIRE ?Register_R8_is_cg_reg
   \   00000020                      REQUIRE ?Register_R9_is_cg_reg
   \   00000020                      REQUIRE ?Register_R10_is_cg_reg
   \   00000020                      REQUIRE ?Register_R11_is_cg_reg
   \   00000020                      REQUIRE ?Register_R12_is_cg_reg
   \   00000020                      REQUIRE ?Register_R13_is_cg_reg
   \   00000020                      REQUIRE ?Register_R14_is_cg_reg
   \   00000020                      REQUIRE ?Register_R15_is_cg_reg
   \   00000020                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000020   9723               SBIW    R29:R28, 3
   \   00000022   0138               MOVW    R7:R6, R17:R16
    149          	unsigned char *RxBuf = (unsigned char *)pUART->pRxBuffer;
   \   00000024   01F8               MOVW    R31:R30, R17:R16
   \   00000026   8847               LDD     R4, Z+23
   \   00000028   8C50               LDD     R5, Z+24
    150          	volatile ANPRO10_PacketHeading *pPH =  (ANPRO10_PacketHeading *)RxBuf;
    151          	char Data;
    152          	OS_GetMail1(&pUART->RxMailBox, &Data);
   \   0000002A   019E               MOVW    R19:R18, R29:R28
   \   0000002C   5F04               SUBI    R16, 244
   \   0000002E   4F1F               SBCI    R17, 255
   \   00000030   ........           CALL    OS_GetMail1
    153          	char dataAvailable = 1;
    154          	int SyncCnt = 1;
   \   00000034   24FF               CLR     R15
   \   00000036   24EE               CLR     R14
   \   00000038   94E3               INC     R14
    155          	char PacketOK      = false;
   \   0000003A   82FA               STD     Y+2, R15
    156          	char Echo          = false;
   \   0000003C   24BB               CLR     R11
    157          	do {
    158          		do {
    159          			dataAvailable = !OS_GetMailTimed(&pUART->RxMailBox, &Data, MAX_TIME_BETWEEN_BYTE);
   \                     ??ANPRO10_IO_Receive_0:
   \   0000003E   E342               LDI     R20, 50
   \   00000040   E050               LDI     R21, 0
   \   00000042   019E               MOVW    R19:R18, R29:R28
   \   00000044   0183               MOVW    R17:R16, R7:R6
   \   00000046   5F04               SUBI    R16, 244
   \   00000048   4F1F               SBCI    R17, 255
   \   0000004A   ........           CALL    OS_GetMailTimed
   \   0000004E   2300               TST     R16
   \   00000050   F4B1               BRNE    ??ANPRO10_IO_Receive_1
   \   00000052   8108               LD      R16, Y
   \   00000054   3106               CPI     R16, 22
   \   00000056   F799               BRNE    ??ANPRO10_IO_Receive_0
   \   00000058   C008               RJMP    ??ANPRO10_IO_Receive_2
    160          		}  while (dataAvailable && Data != ANPRO10_SYN);
    161          		if (dataAvailable) {
    162          			// A minimum of 2 SYN to accept start
    163          			//Message("First SYN");
    164          			//SyncCnt = 0;
    165          			do {
    166          				dataAvailable = !OS_GetMailTimed(&pUART->RxMailBox, &Data, MAX_TIME_BETWEEN_BYTE);
   \                     ??ANPRO10_IO_Receive_3:
   \   0000005A   24AA               CLR     R10
   \   0000005C   94A3               INC     R10
   \   0000005E   8108               LD      R16, Y
   \   00000060   3106               CPI     R16, 22
   \   00000062   F479               BRNE    ??ANPRO10_IO_Receive_4
    167          				if (dataAvailable && (Data == ANPRO10_SYN)) SyncCnt++;
   \   00000064   0CEA               ADD     R14, R10
   \   00000066   E000               LDI     R16, 0
   \   00000068   1EF0               ADC     R15, R16
   \                     ??ANPRO10_IO_Receive_2:
   \   0000006A   E342               LDI     R20, 50
   \   0000006C   E050               LDI     R21, 0
   \   0000006E   019E               MOVW    R19:R18, R29:R28
   \   00000070   0183               MOVW    R17:R16, R7:R6
   \   00000072   5F04               SUBI    R16, 244
   \   00000074   4F1F               SBCI    R17, 255
   \   00000076   ........           CALL    OS_GetMailTimed
   \   0000007A   2300               TST     R16
   \   0000007C   F371               BREQ    ??ANPRO10_IO_Receive_3
   \                     ??ANPRO10_IO_Receive_1:
   \   0000007E   24AA               CLR     R10
   \   00000080   C0AC               RJMP    ??ANPRO10_IO_Receive_5
    168          			} while (dataAvailable && (Data == ANPRO10_SYN));
    169          			if (dataAvailable && SyncCnt && (Data == ANPRO10_SOH)) {
   \                     ??ANPRO10_IO_Receive_4:
   \   00000082   2D0E               MOV     R16, R14
   \   00000084   290F               OR      R16, R15
   \   00000086   F409               BRNE    $+2+2
   \   00000088   C0A8               RJMP    ??ANPRO10_IO_Receive_5
   \   0000008A   8108               LD      R16, Y
   \   0000008C   3001               CPI     R16, 1
   \   0000008E   F009               BREQ    $+2+2
   \   00000090   C0A4               RJMP    ??ANPRO10_IO_Receive_5
    170          				unsigned char *RxPtr = RxBuf;
   \   00000092   01D2               MOVW    R27:R26, R5:R4
    171          				for (unsigned i = 0; dataAvailable && i < sizeof(NetHeading); i++) {
   \   00000094   E087               LDI     R24, 7
    172          					dataAvailable = !OS_GetMailTimed(&pUART->RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
   \                     ??ANPRO10_IO_Receive_6:
   \   00000096   E342               LDI     R20, 50
   \   00000098   E050               LDI     R21, 0
   \   0000009A   019D               MOVW    R19:R18, R27:R26
   \   0000009C   0183               MOVW    R17:R16, R7:R6
   \   0000009E   5F04               SUBI    R16, 244
   \   000000A0   4F1F               SBCI    R17, 255
   \   000000A2   ........           CALL    OS_GetMailTimed
   \   000000A6   9611               ADIW    R27:R26, 1
   \   000000A8   2300               TST     R16
   \   000000AA   F419               BRNE    ??ANPRO10_IO_Receive_7
   \   000000AC   24AA               CLR     R10
   \   000000AE   94A3               INC     R10
   \   000000B0   C001               RJMP    ??ANPRO10_IO_Receive_8
   \                     ??ANPRO10_IO_Receive_7:
   \   000000B2   24AA               CLR     R10
    173          				}
   \                     ??ANPRO10_IO_Receive_8:
   \   000000B4   958A               DEC     R24
   \   000000B6   20AA               TST     R10
   \   000000B8   F409               BRNE    $+2+2
   \   000000BA   C08F               RJMP    ??ANPRO10_IO_Receive_5
   \   000000BC   2388               TST     R24
   \   000000BE   F759               BRNE    ??ANPRO10_IO_Receive_6
    174          				if (dataAvailable) {
    175          					unsigned char HCSum = 0;
   \   000000C0   E040               LDI     R20, 0
    176          					{
    177          						unsigned char *TmpRxPtr = RxBuf;
   \   000000C2   0182               MOVW    R17:R16, R5:R4
    178          						for (unsigned i = 0; i < sizeof(ANPRO10_PacketHeading) - 1; i++) {
   \   000000C4   E026               LDI     R18, 6
    179          							HCSum     = crc[HCSum ^ *TmpRxPtr++];
   \                     ??ANPRO10_IO_Receive_9:
   \   000000C6   01F8               MOVW    R31:R30, R17:R16
   \   000000C8   9131               LD      R19, Z+
   \   000000CA   018F               MOVW    R17:R16, R31:R30
   \   000000CC   2743               EOR     R20, R19
   \   000000CE   2FE4               MOV     R30, R20
   \   000000D0   E0F0               LDI     R31, 0
   \   000000D2   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000D4   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000D6   ....               LDI     R19, (crc) >> 16
   \   000000D8   BF3B               OUT     0x3B, R19
   \   000000DA   9146               ELPM    R20, Z
    180          						}
   \   000000DC   952A               DEC     R18
   \   000000DE   F799               BRNE    ??ANPRO10_IO_Receive_9
    181          
    182          					}
    183          					if (HCSum == pPH->HCRC) {
   \   000000E0   01F2               MOVW    R31:R30, R5:R4
   \   000000E2   8106               LDD     R16, Z+6
   \   000000E4   1740               CP      R20, R16
   \   000000E6   F009               BREQ    $+2+2
   \   000000E8   C078               RJMP    ??ANPRO10_IO_Receive_5
    184          						//OS_Delay(1000);
    185          						unsigned DataSize = (unsigned)pPH->nob;
   \   000000EA   8184               LDD     R24, Z+4
   \   000000EC   8195               LDD     R25, Z+5
    186          						if (DataSize > 3 && DataSize < MAX_ANPRO10_IO_SIZE) {
   \   000000EE   01FC               MOVW    R31:R30, R25:R24
   \   000000F0   9734               SBIW    R31:R30, 4
   \   000000F2   3FEC               CPI     R30, 252
   \   000000F4   40F3               SBCI    R31, 3
   \   000000F6   F008               BRCS    $+2+2
   \   000000F8   C070               RJMP    ??ANPRO10_IO_Receive_5
    187          							int Cnt = 0;
    188          							for (unsigned i = 0; dataAvailable && i < DataSize - sizeof(ANPRO10_PacketHeading); i++) {
   \   000000FA   24CC               CLR     R12
   \   000000FC   24DD               CLR     R13
   \   000000FE   014C               MOVW    R9:R8, R25:R24
   \   00000100   EF09               LDI     R16, 249
   \   00000102   0E80               ADD     R8, R16
   \   00000104   EF0F               LDI     R16, 255
   \   00000106   1E90               ADC     R9, R16
   \                     ??ANPRO10_IO_Receive_10:
   \   00000108   14C8               CP      R12, R8
   \   0000010A   04D9               CPC     R13, R9
   \   0000010C   F4B0               BRCC    ??ANPRO10_IO_Receive_11
    189          								dataAvailable = !OS_GetMailTimed(&pUART->RxMailBox, RxPtr++, MAX_TIME_BETWEEN_BYTE);
   \   0000010E   E342               LDI     R20, 50
   \   00000110   E050               LDI     R21, 0
   \   00000112   019D               MOVW    R19:R18, R27:R26
   \   00000114   0183               MOVW    R17:R16, R7:R6
   \   00000116   5F04               SUBI    R16, 244
   \   00000118   4F1F               SBCI    R17, 255
   \   0000011A   ........           CALL    OS_GetMailTimed
   \   0000011E   9611               ADIW    R27:R26, 1
   \   00000120   2300               TST     R16
   \   00000122   F419               BRNE    ??ANPRO10_IO_Receive_12
   \   00000124   24AA               CLR     R10
   \   00000126   94A3               INC     R10
   \   00000128   C001               RJMP    ??ANPRO10_IO_Receive_13
   \                     ??ANPRO10_IO_Receive_12:
   \   0000012A   24AA               CLR     R10
    190          								Cnt++;
    191          							}
   \                     ??ANPRO10_IO_Receive_13:
   \   0000012C   E001               LDI     R16, 1
   \   0000012E   0EC0               ADD     R12, R16
   \   00000130   E000               LDI     R16, 0
   \   00000132   1ED0               ADC     R13, R16
   \   00000134   20AA               TST     R10
   \   00000136   F741               BRNE    ??ANPRO10_IO_Receive_10
   \   00000138   C050               RJMP    ??ANPRO10_IO_Receive_5
    192          							if (!dataAvailable) {
    193          								//OS_Delay(100);
    194          							}
    195          							if (dataAvailable) {
    196          								RxPtr = RxBuf;
   \                     ??ANPRO10_IO_Receive_11:
   \   0000013A   01D2               MOVW    R27:R26, R5:R4
    197          								volatile unsigned char CSum = 0;
   \   0000013C   E000               LDI     R16, 0
   \   0000013E   8309               STD     Y+1, R16
    198          
    199          								for (unsigned i = 0; i < DataSize - 2; i++) {
   \   00000140   018C               MOVW    R17:R16, R25:R24
   \   00000142   5002               SUBI    R16, 2
   \   00000144   4010               SBCI    R17, 0
   \   00000146   2F20               MOV     R18, R16
   \   00000148   2B21               OR      R18, R17
   \   0000014A   F071               BREQ    ??ANPRO10_IO_Receive_14
    200          									CSum     = crc[CSum ^ *RxPtr++];
   \                     ??ANPRO10_IO_Receive_15:
   \   0000014C   8129               LDD     R18, Y+1
   \   0000014E   913D               LD      R19, X+
   \   00000150   2723               EOR     R18, R19
   \   00000152   2FE2               MOV     R30, R18
   \   00000154   E0F0               LDI     R31, 0
   \   00000156   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000158   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000015A   ....               LDI     R19, (crc) >> 16
   \   0000015C   BF3B               OUT     0x3B, R19
   \   0000015E   9126               ELPM    R18, Z
   \   00000160   8329               STD     Y+1, R18
    201          								}
   \   00000162   5001               SUBI    R16, 1
   \   00000164   4010               SBCI    R17, 0
   \   00000166   F791               BRNE    ??ANPRO10_IO_Receive_15
    202          								unsigned char  PacketCheckSum = *((unsigned char *)&RxBuf[DataSize - 2]);
    203          								if (PacketCheckSum == CSum) {
   \                     ??ANPRO10_IO_Receive_14:
   \   00000168   0182               MOVW    R17:R16, R5:R4
   \   0000016A   0F08               ADD     R16, R24
   \   0000016C   1F19               ADC     R17, R25
   \   0000016E   5003               SUBI    R16, 3
   \   00000170   4010               SBCI    R17, 0
   \   00000172   01F8               MOVW    R31:R30, R17:R16
   \   00000174   8121               LDD     R18, Z+1
   \   00000176   8139               LDD     R19, Y+1
   \   00000178   1723               CP      R18, R19
   \   0000017A   F579               BRNE    ??ANPRO10_IO_Receive_5
    204          									pUART->SequenceNumber = RxBuf[DataSize - 3];
   \   0000017C   8120               LD      R18, Z
   \   0000017E   01F3               MOVW    R31:R30, R7:R6
   \   00000180   8F26               STD     Z+30, R18
    205          									//U16 EndCommand = *((U16*)&ARxBuf[DataSize-6]);
    206          									//                  unsigned char EndData = *((unsigned char*)&ARxBuf[DataSize-4]);
    207          									unsigned char EOTByte = *((unsigned char *)&RxBuf[DataSize - 1]);
    208          									if (EOTByte == ANPRO10_EOT) {
   \   00000182   01F8               MOVW    R31:R30, R17:R16
   \   00000184   8102               LDD     R16, Z+2
   \   00000186   3004               CPI     R16, 4
   \   00000188   F541               BRNE    ??ANPRO10_IO_Receive_5
    209          										switch (pPH->txtypeid) {
   \   0000018A   01F2               MOVW    R31:R30, R5:R4
   \   0000018C   8102               LDD     R16, Z+2
   \   0000018E   5103               SUBI    R16, 19
   \   00000190   F111               BREQ    ??ANPRO10_IO_Receive_16
   \   00000192   500D               SUBI    R16, 13
   \   00000194   F511               BRNE    ??ANPRO10_IO_Receive_5
    210          										case DEVICE_TCU :
    211          											if ((pPH->rxadr == MyAddress()) && (pPH->rxtypeid == (UnitID + DEVICE_IO))) {
   \   00000196   8181               LDD     R24, Z+1
   \   00000198   ........           CALL    MyAddress
   \   0000019C   1780               CP      R24, R16
   \   0000019E   F4E9               BRNE    ??ANPRO10_IO_Receive_5
   \   000001A0   01F2               MOVW    R31:R30, R5:R4
   \   000001A2   8100               LD      R16, Z
   \   000001A4   E010               LDI     R17, 0
   \   000001A6   91E0....           LDS     R30, UnitID
   \   000001AA   E0F0               LDI     R31, 0
   \   000001AC   9670               ADIW    R31:R30, 16
   \   000001AE   170E               CP      R16, R30
   \   000001B0   071F               CPC     R17, R31
   \   000001B2   F499               BRNE    ??ANPRO10_IO_Receive_5
    212          												pUART->TxAddress = pPH->txadr;
   \   000001B4   01F2               MOVW    R31:R30, R5:R4
   \   000001B6   8103               LDD     R16, Z+3
   \   000001B8   01F3               MOVW    R31:R30, R7:R6
   \   000001BA   8703               STD     Z+11, R16
    213          												pUART->TxId      = pPH->txtypeid;
   \   000001BC   01F2               MOVW    R31:R30, R5:R4
   \   000001BE   8102               LDD     R16, Z+2
   \   000001C0   01F3               MOVW    R31:R30, R7:R6
   \   000001C2   8702               STD     Z+10, R16
    214          												Echo = !ANPRO10_UnpackPacket(pUART, RxBuf);
   \   000001C4   0192               MOVW    R19:R18, R5:R4
   \   000001C6   0183               MOVW    R17:R16, R7:R6
   \   000001C8   ....               RCALL   ANPRO10_UnpackPacket
   \   000001CA   2300               TST     R16
   \   000001CC   F021               BREQ    ??ANPRO10_IO_Receive_16
   \   000001CE   24BB               CLR     R11
    215          												if (!Echo) {
    216          													PacketOK = true;
   \   000001D0   E001               LDI     R16, 1
   \   000001D2   830A               STD     Y+2, R16
   \   000001D4   C002               RJMP    ??ANPRO10_IO_Receive_5
    217          												}
    218          												break;
    219          											} else {
    220          												//Ignore = true;
    221          											}
    222          
    223          											break;
    224          										case DEVICE_ZBHART:
    225          											Echo = true;
   \                     ??ANPRO10_IO_Receive_16:
   \   000001D6   24BB               CLR     R11
   \   000001D8   94B3               INC     R11
    226          											break;
    227          										default:
    228          											// Ignore message
    229          											break;
    230          										}
    231          									}
    232          								}
    233          							}
    234          						}
    235          					}
    236          				}
    237          			}
    238          		}
    239          	}while (Echo && dataAvailable);
   \                     ??ANPRO10_IO_Receive_5:
   \   000001DA   2D0B               MOV     R16, R11
   \   000001DC   7001               ANDI    R16, 0x01
   \   000001DE   2D1A               MOV     R17, R10
   \   000001E0   7011               ANDI    R17, 0x01
   \   000001E2   2301               AND     R16, R17
   \   000001E4   F009               BREQ    $+2+2
   \   000001E6   CF2B               RJMP    ??ANPRO10_IO_Receive_0
    240          	if (!PacketOK) {
   \   000001E8   810A               LDD     R16, Y+2
   \   000001EA   2300               TST     R16
   \   000001EC   F421               BRNE    ??ANPRO10_IO_Receive_17
    241          		pUART->RxFaultCnt++;
   \   000001EE   01F3               MOVW    R31:R30, R7:R6
   \   000001F0   8D01               LDD     R16, Z+25
   \   000001F2   9503               INC     R16
   \   000001F4   8F01               STD     Z+25, R16
    242          	}
    243          	return (PacketOK);
   \                     ??ANPRO10_IO_Receive_17:
   \   000001F6   810A               LDD     R16, Y+2
   \   000001F8   9623               ADIW    R29:R28, 3
   \   000001FA   9189               LD      R24, Y+
   \   000001FC   9199               LD      R25, Y+
   \   000001FE   91A9               LD      R26, Y+
   \   00000200   91B9               LD      R27, Y+
   \   00000202   9049               LD      R4, Y+
   \   00000204   9059               LD      R5, Y+
   \   00000206   9069               LD      R6, Y+
   \   00000208   9079               LD      R7, Y+
   \   0000020A   9089               LD      R8, Y+
   \   0000020C   9099               LD      R9, Y+
   \   0000020E   90A9               LD      R10, Y+
   \   00000210   90B9               LD      R11, Y+
   \   00000212   90C9               LD      R12, Y+
   \   00000214   90D9               LD      R13, Y+
   \   00000216   90E9               LD      R14, Y+
   \   00000218   90F9               LD      R15, Y+
   \   0000021A   9508               RET
    244          }
    245          
    246          /*************************************************************************
    247          *   (This is a task)
    248          *  Usart0 handler
    249          *
    250          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    251          void Usart0Handler(void) {
   \                     Usart0Handler:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    252          
    253          	while (1) {
    254          		ANPRO10_IO_Receive(&UART[0]);
   \                     ??Usart0Handler_0:
   \   00000000   ....               LDI     R16, LOW(UART)
   \   00000002   ....               LDI     R17, (UART) >> 8
   \   00000004   ....               RCALL   ANPRO10_IO_Receive
   \   00000006   CFFC               RJMP    ??Usart0Handler_0
    255          	}
    256          }
    257          
    258          /*************************************************************************
    259          *   (This is a task)
    260          *  Usart1 handler
    261          *
    262          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    263          void Usart1Handler(void) {
   \                     Usart1Handler:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    264          	while (1) {
    265          		while (1) {
    266          			ANPRO10_IO_Receive(&UART[1]);
   \                     ??Usart1Handler_0:
   \   00000000   ....               LDI     R16, LOW((UART + 31))
   \   00000002   ....               LDI     R17, HIGH((UART + 31))
   \   00000004   ....               RCALL   ANPRO10_IO_Receive
   \   00000006   CFFC               RJMP    ??Usart1Handler_0
    267          		}
    268          	}
    269          }
    270          
    271          
    272          
    273          /*************************************************************************
    274          *
    275          * Build send packet header
    276          *
    277          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    278          void Uart_BuildHeader(UARTDataType *pUART) {
   \                     Uart_BuildHeader:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
    279          
    280          	pUART->TxLast  = 0;
   \   00000004   01F8               MOVW    R31:R30, R17:R16
   \   00000006   E020               LDI     R18, 0
   \   00000008   8324               STD     Z+4, R18
   \   0000000A   8325               STD     Z+5, R18
    281          	char *txBuf = pUART->pTxBuffer;
   \   0000000C   81A0               LD      R26, Z
   \   0000000E   81B1               LDD     R27, Z+1
    282          
    283          	txBuf[0] = ANPRO10_SYN;                        /* Sync */
   \   00000010   01FD               MOVW    R31:R30, R27:R26
   \   00000012   E126               LDI     R18, 22
   \   00000014   8320               ST      Z, R18
    284          	txBuf[1] = ANPRO10_SYN;                        /* Sync */
   \   00000016   8321               STD     Z+1, R18
    285          	txBuf[2] = ANPRO10_SYN;                        /* Sync */
   \   00000018   8322               STD     Z+2, R18
    286          	txBuf[3] = ANPRO10_SOH;                        /* Start of header */
   \   0000001A   E021               LDI     R18, 1
   \   0000001C   8323               STD     Z+3, R18
    287          	txBuf[4] = pUART->TxId;                        /* RXID */
   \   0000001E   01F8               MOVW    R31:R30, R17:R16
   \   00000020   8522               LDD     R18, Z+10
   \   00000022   01FD               MOVW    R31:R30, R27:R26
   \   00000024   8324               STD     Z+4, R18
    288          	txBuf[5] = pUART->TxAddress;                   /* Rx address */
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   8503               LDD     R16, Z+11
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   8305               STD     Z+5, R16
    289          	txBuf[6] = DEVICE_IO + UnitID;                 /* Unit ID */
   \   0000002E   9100....           LDS     R16, UnitID
   \   00000032   5F00               SUBI    R16, 240
   \   00000034   8306               STD     Z+6, R16
    290          	txBuf[7] = MyAddress();                        /* Tx address */
   \   00000036   ........           CALL    MyAddress
   \   0000003A   01FD               MOVW    R31:R30, R27:R26
   \   0000003C   8307               STD     Z+7, R16
    291          	txBuf[8] = 0;                                  /* packlen HB, don't know yet */
   \   0000003E   E000               LDI     R16, 0
   \   00000040   8700               STD     Z+8, R16
    292          	txBuf[9] = 0;                                  /* packlen LB, don't know yet */
   \   00000042   8701               STD     Z+9, R16
    293          	txBuf[10] = 0;                                  /* Header checksum, don't know yet */
   \   00000044   8702               STD     Z+10, R16
    294          }
   \   00000046   91A9               LD      R26, Y+
   \   00000048   91B9               LD      R27, Y+
   \   0000004A   9508               RET
    295          
    296          /*************************************************************************
    297          *
    298          * Build  packet tail
    299          *
    300          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    301          void Uart_BuildTail(UARTDataType *pUART) {
   \                     Uart_BuildTail:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000008   01D8               MOVW    R27:R26, R17:R16
    302          
    303          	Uart_BuildHeader(pUART);                                    // fist build the header
   \   0000000A   ....               RCALL   Uart_BuildHeader
    304          	char *txBuf = pUART->pTxBuffer;
   \   0000000C   918D               LD      R24, X+
   \   0000000E   919C               LD      R25, X
   \   00000010   9711               SBIW    R27:R26, 1
    305          	txBuf[pUART->TxFirst++] = ECMD_NMDWOACK & 0xff;  // End command lb
   \   00000012   01FD               MOVW    R31:R30, R27:R26
   \   00000014   8122               LDD     R18, Z+2
   \   00000016   8133               LDD     R19, Z+3
   \   00000018   0189               MOVW    R17:R16, R19:R18
   \   0000001A   5F0F               SUBI    R16, 255
   \   0000001C   4F1F               SBCI    R17, 255
   \   0000001E   8302               STD     Z+2, R16
   \   00000020   8313               STD     Z+3, R17
   \   00000022   01FC               MOVW    R31:R30, R25:R24
   \   00000024   0FE2               ADD     R30, R18
   \   00000026   1FF3               ADC     R31, R19
   \   00000028   E000               LDI     R16, 0
   \   0000002A   8300               ST      Z, R16
    306          	txBuf[pUART->TxFirst++] = ECMD_NMDWOACK >> 8;    // End command hb
   \   0000002C   01FD               MOVW    R31:R30, R27:R26
   \   0000002E   8122               LDD     R18, Z+2
   \   00000030   8133               LDD     R19, Z+3
   \   00000032   0189               MOVW    R17:R16, R19:R18
   \   00000034   5F0F               SUBI    R16, 255
   \   00000036   4F1F               SBCI    R17, 255
   \   00000038   8302               STD     Z+2, R16
   \   0000003A   8313               STD     Z+3, R17
   \   0000003C   01FC               MOVW    R31:R30, R25:R24
   \   0000003E   0FE2               ADD     R30, R18
   \   00000040   1FF3               ADC     R31, R19
   \   00000042   E000               LDI     R16, 0
   \   00000044   8300               ST      Z, R16
    307          	txBuf[pUART->TxFirst++] = 0x00;                  // End data
   \   00000046   01FD               MOVW    R31:R30, R27:R26
   \   00000048   8122               LDD     R18, Z+2
   \   0000004A   8133               LDD     R19, Z+3
   \   0000004C   0189               MOVW    R17:R16, R19:R18
   \   0000004E   5F0F               SUBI    R16, 255
   \   00000050   4F1F               SBCI    R17, 255
   \   00000052   8302               STD     Z+2, R16
   \   00000054   8313               STD     Z+3, R17
   \   00000056   01FC               MOVW    R31:R30, R25:R24
   \   00000058   0FE2               ADD     R30, R18
   \   0000005A   1FF3               ADC     R31, R19
   \   0000005C   E000               LDI     R16, 0
   \   0000005E   8300               ST      Z, R16
    308          
    309          	txBuf[pUART->TxFirst++] = pUART->TxSeqCnt++;   // Sequence counter
   \   00000060   01FD               MOVW    R31:R30, R27:R26
   \   00000062   8122               LDD     R18, Z+2
   \   00000064   8133               LDD     R19, Z+3
   \   00000066   0189               MOVW    R17:R16, R19:R18
   \   00000068   5F0F               SUBI    R16, 255
   \   0000006A   4F1F               SBCI    R17, 255
   \   0000006C   8302               STD     Z+2, R16
   \   0000006E   8313               STD     Z+3, R17
   \   00000070   8501               LDD     R16, Z+9
   \   00000072   2F10               MOV     R17, R16
   \   00000074   9513               INC     R17
   \   00000076   8711               STD     Z+9, R17
   \   00000078   01FC               MOVW    R31:R30, R25:R24
   \   0000007A   0FE2               ADD     R30, R18
   \   0000007C   1FF3               ADC     R31, R19
   \   0000007E   8300               ST      Z, R16
    310          
    311          	txBuf[8] = pUART->TxFirst - 2;                    // correct length because stx's
   \   00000080   01FD               MOVW    R31:R30, R27:R26
   \   00000082   8102               LDD     R16, Z+2
   \   00000084   5002               SUBI    R16, 2
   \   00000086   01FC               MOVW    R31:R30, R25:R24
   \   00000088   8700               STD     Z+8, R16
    312          	txBuf[9] = (pUART->TxFirst - 2) >> 8;             // packet len high
   \   0000008A   01FD               MOVW    R31:R30, R27:R26
   \   0000008C   8102               LDD     R16, Z+2
   \   0000008E   8113               LDD     R17, Z+3
   \   00000090   5002               SUBI    R16, 2
   \   00000092   4010               SBCI    R17, 0
   \   00000094   01FC               MOVW    R31:R30, R25:R24
   \   00000096   8711               STD     Z+9, R17
    313          
    314          	txBuf[10] = CalcDSTxChecksum(pUART, 6);         // Get header checksum
   \   00000098   E026               LDI     R18, 6
   \   0000009A   E030               LDI     R19, 0
   \   0000009C   018D               MOVW    R17:R16, R27:R26
   \   0000009E   ....               RCALL   CalcDSTxChecksum
   \   000000A0   01FC               MOVW    R31:R30, R25:R24
   \   000000A2   8702               STD     Z+10, R16
    315          
    316          	txBuf[pUART->TxFirst] = CalcDSTxChecksum(pUART, pUART->TxFirst-4); // Get checksum
   \   000000A4   01FD               MOVW    R31:R30, R27:R26
   \   000000A6   8122               LDD     R18, Z+2
   \   000000A8   8133               LDD     R19, Z+3
   \   000000AA   5024               SUBI    R18, 4
   \   000000AC   4030               SBCI    R19, 0
   \   000000AE   018D               MOVW    R17:R16, R27:R26
   \   000000B0   ....               RCALL   CalcDSTxChecksum
   \   000000B2   01FD               MOVW    R31:R30, R27:R26
   \   000000B4   8122               LDD     R18, Z+2
   \   000000B6   8133               LDD     R19, Z+3
   \   000000B8   01FC               MOVW    R31:R30, R25:R24
   \   000000BA   0FE2               ADD     R30, R18
   \   000000BC   1FF3               ADC     R31, R19
   \   000000BE   8300               ST      Z, R16
    317          	pUART->TxFirst++;                                        // OBS!! must be inc here due to ANSI standard !!!!
    318          
    319          	txBuf[pUART->TxFirst++] = ANPRO10_EOT;            // End of transmission
   \   000000C0   01FD               MOVW    R31:R30, R27:R26
   \   000000C2   8122               LDD     R18, Z+2
   \   000000C4   8133               LDD     R19, Z+3
   \   000000C6   5F2F               SUBI    R18, 255
   \   000000C8   4F3F               SBCI    R19, 255
   \   000000CA   0189               MOVW    R17:R16, R19:R18
   \   000000CC   5F0F               SUBI    R16, 255
   \   000000CE   4F1F               SBCI    R17, 255
   \   000000D0   8302               STD     Z+2, R16
   \   000000D2   8313               STD     Z+3, R17
   \   000000D4   0F82               ADD     R24, R18
   \   000000D6   1F93               ADC     R25, R19
   \   000000D8   01FC               MOVW    R31:R30, R25:R24
   \   000000DA   E004               LDI     R16, 4
   \   000000DC   8300               ST      Z, R16
    320          	pUART->TxCount          = pUART->TxFirst;         //bytes to send
   \   000000DE   01FD               MOVW    R31:R30, R27:R26
   \   000000E0   8102               LDD     R16, Z+2
   \   000000E2   8113               LDD     R17, Z+3
   \   000000E4   8306               STD     Z+6, R16
   \   000000E6   8317               STD     Z+7, R17
    321          	pUART->TxLast 			= 0;                                     // reset cunter
   \   000000E8   E000               LDI     R16, 0
   \   000000EA   8304               STD     Z+4, R16
   \   000000EC   8305               STD     Z+5, R16
    322          	// Turn on TXE for channel
    323          	OS_RetriggerTimer(&TimerUSART0);                     // and start timeout TX timer
   \   000000EE   ....               LDI     R16, LOW(TimerUSART0)
   \   000000F0   ....               LDI     R17, (TimerUSART0) >> 8
   \   000000F2   ........           CALL    OS_RetriggerTimer
    324          
    325          	MB_SetBit(PORTE, 0x04);                                // TXE0 on
   \   000000F6   94F8               CLI
   \   000000F8   9100....           LDS     R16, (OS_Counters + 1)
   \   000000FC   9503               INC     R16
   \   000000FE   9300....           STS     (OS_Counters + 1), R16
   \   00000102   9A72               SBI     0x0E, 0x02
   \   00000104   9100....           LDS     R16, (OS_Counters + 1)
   \   00000108   950A               DEC     R16
   \   0000010A   9300....           STS     (OS_Counters + 1), R16
   \   0000010E   F409               BRNE    ??Uart_BuildTail_0
   \   00000110   9478               SEI
    326          	OS_RetriggerTimer(&TimerUSART0On);                   // and start timer for on before TX
   \                     ??Uart_BuildTail_0:
   \   00000112   ....               LDI     R16, LOW(TimerUSART0On)
   \   00000114   ....               LDI     R17, (TimerUSART0On) >> 8
   \   00000116   ........           CALL    OS_RetriggerTimer
    327          }
   \   0000011A                      REQUIRE ?Subroutine1
   \   0000011A                      REQUIRE _A_PORTE
   \   0000011A                      ;               // Fall through to label ?Subroutine1

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9508               RET
    328          
    329          /*************************************************************************
    330          *
    331          * Build datablock for card status
    332          *
    333          *************************************************************************/
    334          

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   9189               LD      R24, Y+
   \   00000002   9199               LD      R25, Y+
   \   00000004   91A9               LD      R26, Y+
   \   00000006   91B9               LD      R27, Y+
   \   00000008   9049               LD      R4, Y+
   \   0000000A   9059               LD      R5, Y+
   \   0000000C   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    335          void BuildStatusData(char ch) {
   \                     BuildStatusData:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C                      REQUIRE __RSTACK_in_external_ram_new_way
    336          
    337          	short ntna;
    338          	UART[ch].RxSendReply = true;                               // flag for answering
   \   0000000C   E11F               LDI     R17, 31
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E011               LDI     R17, 1
   \   0000001C   8F12               STD     Z+26, R17
    339          
    340          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STATUS & 0xff;
   \   0000001E   91ED               LD      R30, X+
   \   00000020   91FD               LD      R31, X+
   \   00000022   912D               LD      R18, X+
   \   00000024   913C               LD      R19, X
   \   00000026   9713               SBIW    R27:R26, 3
   \   00000028   0FE2               ADD     R30, R18
   \   0000002A   1FF3               ADC     R31, R19
   \   0000002C   EE19               LDI     R17, 233
   \   0000002E   8310               ST      Z, R17
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8122               LDD     R18, Z+2
   \   00000034   8133               LDD     R19, Z+3
   \   00000036   5F2F               SUBI    R18, 255
   \   00000038   4F3F               SBCI    R19, 255
   \   0000003A   8322               STD     Z+2, R18
   \   0000003C   8333               STD     Z+3, R19
    341          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STATUS >> 8;
   \   0000003E   91ED               LD      R30, X+
   \   00000040   91FD               LD      R31, X+
   \   00000042   912D               LD      R18, X+
   \   00000044   9713               SBIW    R27:R26, 3
   \   00000046   0FE2               ADD     R30, R18
   \   00000048   1FF3               ADC     R31, R19
   \   0000004A   E013               LDI     R17, 3
   \   0000004C   8310               ST      Z, R17
   \   0000004E   01FD               MOVW    R31:R30, R27:R26
   \   00000050   8122               LDD     R18, Z+2
   \   00000052   8133               LDD     R19, Z+3
   \   00000054   5F2F               SUBI    R18, 255
   \   00000056   4F3F               SBCI    R19, 255
   \   00000058   8322               STD     Z+2, R18
   \   0000005A   8333               STD     Z+3, R19
    342          	ntna = UART[ch].TxFirst;                                    /* remember index */
   \   0000005C   0129               MOVW    R5:R4, R19:R18
    343          	UART[ch].TxFirst += 2;                                      // two byte length
   \   0000005E   5F2E               SUBI    R18, 254
   \   00000060   4F3F               SBCI    R19, 255
   \   00000062   8322               STD     Z+2, R18
   \   00000064   8333               STD     Z+3, R19
    344          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = ch;               // channel
   \   00000066   8120               LD      R18, Z
   \   00000068   8131               LDD     R19, Z+1
   \   0000006A   8142               LDD     R20, Z+2
   \   0000006C   8153               LDD     R21, Z+3
   \   0000006E   0F24               ADD     R18, R20
   \   00000070   1F35               ADC     R19, R21
   \   00000072   01F9               MOVW    R31:R30, R19:R18
   \   00000074   8300               ST      Z, R16
   \   00000076   01FD               MOVW    R31:R30, R27:R26
   \   00000078   8102               LDD     R16, Z+2
   \   0000007A   8113               LDD     R17, Z+3
   \   0000007C   5F0F               SUBI    R16, 255
   \   0000007E   4F1F               SBCI    R17, 255
   \   00000080   8302               STD     Z+2, R16
   \   00000082   8313               STD     Z+3, R17
    345          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = DEVICE_IO + UnitID;   // Product ID
   \   00000084   9120....           LDS     R18, UnitID
   \   00000088   5F20               SUBI    R18, 240
   \   0000008A   8100               LD      R16, Z
   \   0000008C   8111               LDD     R17, Z+1
   \   0000008E   8142               LDD     R20, Z+2
   \   00000090   8153               LDD     R21, Z+3
   \   00000092   0F04               ADD     R16, R20
   \   00000094   1F15               ADC     R17, R21
   \   00000096   01F8               MOVW    R31:R30, R17:R16
   \   00000098   8320               ST      Z, R18
   \   0000009A   01FD               MOVW    R31:R30, R27:R26
   \   0000009C   8102               LDD     R16, Z+2
   \   0000009E   8113               LDD     R17, Z+3
   \   000000A0   5F0F               SUBI    R16, 255
   \   000000A2   4F1F               SBCI    R17, 255
   \   000000A4   8302               STD     Z+2, R16
   \   000000A6   8313               STD     Z+3, R17
    346          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = MyAddress();           // unit adddress
   \   000000A8   01C8               MOVW    R25:R24, R17:R16
   \   000000AA   5F0F               SUBI    R16, 255
   \   000000AC   4F1F               SBCI    R17, 255
   \   000000AE   8302               STD     Z+2, R16
   \   000000B0   8313               STD     Z+3, R17
   \   000000B2   ........           CALL    MyAddress
   \   000000B6   91ED               LD      R30, X+
   \   000000B8   91FC               LD      R31, X
   \   000000BA   9711               SBIW    R27:R26, 1
   \   000000BC   0FE8               ADD     R30, R24
   \   000000BE   1FF9               ADC     R31, R25
   \   000000C0   8300               ST      Z, R16
    347          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROG_VERSION;       // software version */
   \   000000C2   910D               LD      R16, X+
   \   000000C4   911C               LD      R17, X
   \   000000C6   9711               SBIW    R27:R26, 1
   \   000000C8   01FD               MOVW    R31:R30, R27:R26
   \   000000CA   8122               LDD     R18, Z+2
   \   000000CC   8133               LDD     R19, Z+3
   \   000000CE   0F02               ADD     R16, R18
   \   000000D0   1F13               ADC     R17, R19
   \   000000D2   01F8               MOVW    R31:R30, R17:R16
   \   000000D4   E004               LDI     R16, 4
   \   000000D6   8300               ST      Z, R16
   \   000000D8   01FD               MOVW    R31:R30, R27:R26
   \   000000DA   8102               LDD     R16, Z+2
   \   000000DC   8113               LDD     R17, Z+3
   \   000000DE   5F0F               SUBI    R16, 255
   \   000000E0   4F1F               SBCI    R17, 255
   \   000000E2   8302               STD     Z+2, R16
   \   000000E4   8313               STD     Z+3, R17
    348          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = COMP_VERSION;        // cpmpability version
   \   000000E6   8100               LD      R16, Z
   \   000000E8   8111               LDD     R17, Z+1
   \   000000EA   8122               LDD     R18, Z+2
   \   000000EC   8133               LDD     R19, Z+3
   \   000000EE   0F02               ADD     R16, R18
   \   000000F0   1F13               ADC     R17, R19
   \   000000F2   01F8               MOVW    R31:R30, R17:R16
   \   000000F4   E001               LDI     R16, 1
   \   000000F6   8300               ST      Z, R16
   \   000000F8   01FD               MOVW    R31:R30, R27:R26
   \   000000FA   8102               LDD     R16, Z+2
   \   000000FC   8113               LDD     R17, Z+3
   \   000000FE   5F0F               SUBI    R16, 255
   \   00000100   4F1F               SBCI    R17, 255
   \   00000102   8302               STD     Z+2, R16
   \   00000104   8313               STD     Z+3, R17
    349          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = STORE_VERSION;        // cpmpability version
   \   00000106   8100               LD      R16, Z
   \   00000108   8111               LDD     R17, Z+1
   \   0000010A   8122               LDD     R18, Z+2
   \   0000010C   8133               LDD     R19, Z+3
   \   0000010E   0F02               ADD     R16, R18
   \   00000110   1F13               ADC     R17, R19
   \   00000112   01F8               MOVW    R31:R30, R17:R16
   \   00000114   E002               LDI     R16, 2
   \   00000116   8300               ST      Z, R16
   \   00000118   01FD               MOVW    R31:R30, R27:R26
   \   0000011A   8102               LDD     R16, Z+2
   \   0000011C   8113               LDD     R17, Z+3
   \   0000011E   5F0F               SUBI    R16, 255
   \   00000120   4F1F               SBCI    R17, 255
   \   00000122   8302               STD     Z+2, R16
   \   00000124   8313               STD     Z+3, R17
    350          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = (RXSIZE_UART & 0xff);         // rx buffer size
   \   00000126   8100               LD      R16, Z
   \   00000128   8111               LDD     R17, Z+1
   \   0000012A   8122               LDD     R18, Z+2
   \   0000012C   8133               LDD     R19, Z+3
   \   0000012E   0F02               ADD     R16, R18
   \   00000130   1F13               ADC     R17, R19
   \   00000132   01F8               MOVW    R31:R30, R17:R16
   \   00000134   E906               LDI     R16, 150
   \   00000136   8300               ST      Z, R16
   \   00000138   01FD               MOVW    R31:R30, R27:R26
   \   0000013A   8102               LDD     R16, Z+2
   \   0000013C   8113               LDD     R17, Z+3
   \   0000013E   5F0F               SUBI    R16, 255
   \   00000140   4F1F               SBCI    R17, 255
   \   00000142   8302               STD     Z+2, R16
   \   00000144   8313               STD     Z+3, R17
    351          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((RXSIZE_UART >> 8) & 0xff); // rx buffer size
   \   00000146   8100               LD      R16, Z
   \   00000148   8111               LDD     R17, Z+1
   \   0000014A   8122               LDD     R18, Z+2
   \   0000014C   8133               LDD     R19, Z+3
   \   0000014E   0F02               ADD     R16, R18
   \   00000150   1F13               ADC     R17, R19
   \   00000152   01F8               MOVW    R31:R30, R17:R16
   \   00000154   E000               LDI     R16, 0
   \   00000156   8300               ST      Z, R16
   \   00000158   01FD               MOVW    R31:R30, R27:R26
   \   0000015A   8102               LDD     R16, Z+2
   \   0000015C   8113               LDD     R17, Z+3
   \   0000015E   5F0F               SUBI    R16, 255
   \   00000160   4F1F               SBCI    R17, 255
   \   00000162   8302               STD     Z+2, R16
   \   00000164   8313               STD     Z+3, R17
    352          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TXSIZE_UART & 0xff);         // tx buffer size
   \   00000166   8100               LD      R16, Z
   \   00000168   8111               LDD     R17, Z+1
   \   0000016A   8122               LDD     R18, Z+2
   \   0000016C   8133               LDD     R19, Z+3
   \   0000016E   0F02               ADD     R16, R18
   \   00000170   1F13               ADC     R17, R19
   \   00000172   01F8               MOVW    R31:R30, R17:R16
   \   00000174   E900               LDI     R16, 144
   \   00000176   8300               ST      Z, R16
   \   00000178   01FD               MOVW    R31:R30, R27:R26
   \   0000017A   8102               LDD     R16, Z+2
   \   0000017C   8113               LDD     R17, Z+3
   \   0000017E   5F0F               SUBI    R16, 255
   \   00000180   4F1F               SBCI    R17, 255
   \   00000182   8302               STD     Z+2, R16
   \   00000184   8313               STD     Z+3, R17
    353          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);  // tx buffer size
   \   00000186   8100               LD      R16, Z
   \   00000188   8111               LDD     R17, Z+1
   \   0000018A   8122               LDD     R18, Z+2
   \   0000018C   8133               LDD     R19, Z+3
   \   0000018E   0F02               ADD     R16, R18
   \   00000190   1F13               ADC     R17, R19
   \   00000192   01F8               MOVW    R31:R30, R17:R16
   \   00000194   E001               LDI     R16, 1
   \   00000196   8300               ST      Z, R16
   \   00000198   01FD               MOVW    R31:R30, R27:R26
   \   0000019A   8102               LDD     R16, Z+2
   \   0000019C   8113               LDD     R17, Z+3
   \   0000019E   5F0F               SUBI    R16, 255
   \   000001A0   4F1F               SBCI    R17, 255
   \   000001A2   8302               STD     Z+2, R16
   \   000001A4   8313               STD     Z+3, R17
    354          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = RestartStatus;                  // restart flag
   \   000001A6   9120....           LDS     R18, RestartStatus
   \   000001AA   8100               LD      R16, Z
   \   000001AC   8111               LDD     R17, Z+1
   \   000001AE   8142               LDD     R20, Z+2
   \   000001B0   8153               LDD     R21, Z+3
   \   000001B2   0F04               ADD     R16, R20
   \   000001B4   1F15               ADC     R17, R21
   \   000001B6   01F8               MOVW    R31:R30, R17:R16
   \   000001B8   8320               ST      Z, R18
   \   000001BA   01FD               MOVW    R31:R30, R27:R26
   \   000001BC   8102               LDD     R16, Z+2
   \   000001BE   8113               LDD     R17, Z+3
   \   000001C0   5F0F               SUBI    R16, 255
   \   000001C2   4F1F               SBCI    R17, 255
   \   000001C4   8302               STD     Z+2, R16
   \   000001C6   8313               STD     Z+3, R17
    355          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROGTYPE_APP;                // Application program
   \   000001C8   8100               LD      R16, Z
   \   000001CA   8111               LDD     R17, Z+1
   \   000001CC   8122               LDD     R18, Z+2
   \   000001CE   8133               LDD     R19, Z+3
   \   000001D0   0F02               ADD     R16, R18
   \   000001D2   1F13               ADC     R17, R19
   \   000001D4   01F8               MOVW    R31:R30, R17:R16
   \   000001D6   E001               LDI     R16, 1
   \   000001D8   8300               ST      Z, R16
   \   000001DA   01FD               MOVW    R31:R30, R27:R26
   \   000001DC   8102               LDD     R16, Z+2
   \   000001DE   8113               LDD     R17, Z+3
   \   000001E0   5F0F               SUBI    R16, 255
   \   000001E2   4F1F               SBCI    R17, 255
   \   000001E4   8302               STD     Z+2, R16
   \   000001E6   8313               STD     Z+3, R17
    356          
    357          	UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000001E8   1904               SUB     R16, R4
   \   000001EA   5002               SUBI    R16, 2
   \   000001EC   91ED               LD      R30, X+
   \   000001EE   91FC               LD      R31, X
   \   000001F0   9711               SBIW    R27:R26, 1
   \   000001F2   0DE4               ADD     R30, R4
   \   000001F4   1DF5               ADC     R31, R5
   \   000001F6   8300               ST      Z, R16
    358          	UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000001F8   01FD               MOVW    R31:R30, R27:R26
   \   000001FA   8182               LDD     R24, Z+2
   \   000001FC   8193               LDD     R25, Z+3
   \   000001FE   1984               SUB     R24, R4
   \   00000200   0995               SBC     R25, R5
   \   00000202   9702               SBIW    R25:R24, 2
   \   00000204   91ED               LD      R30, X+
   \   00000206   91FC               LD      R31, X
   \   00000208   0DE4               ADD     R30, R4
   \   0000020A   1DF5               ADC     R31, R5
   \   0000020C   8391               STD     Z+1, R25
    359          
    360          	RestartStatus = 0;                                                       // set reset stat to 0 = read
   \   0000020E   E000               LDI     R16, 0
   \   00000210   9300....           STS     RestartStatus, R16
    361          }
   \   00000214   ....               RJMP    ?Subroutine0
    362          
    363          /*************************************************************************
    364          *
    365          * Build EEPROM data package
    366          *
    367          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    368          void BuildEEPROMData(char ch, unsigned char *pointer) {
   \                     BuildEEPROMData:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000C                      REQUIRE __RSTACK_in_external_ram_new_way
    369          
    370          	short ntna;
    371          	char channel;
    372          	UART[ch].RxSendReply = true;                               // flag for answering
   \   0000000C   E11F               LDI     R17, 31
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   E001               LDI     R16, 1
   \   0000001C   8F02               STD     Z+26, R16
    373          
    374          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_EEPROM_DATA & 0xff;
   \   0000001E   8100               LD      R16, Z
   \   00000020   8111               LDD     R17, Z+1
   \   00000022   8142               LDD     R20, Z+2
   \   00000024   8153               LDD     R21, Z+3
   \   00000026   0F04               ADD     R16, R20
   \   00000028   1F15               ADC     R17, R21
   \   0000002A   01F8               MOVW    R31:R30, R17:R16
   \   0000002C   E309               LDI     R16, 57
   \   0000002E   8300               ST      Z, R16
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8102               LDD     R16, Z+2
   \   00000034   8113               LDD     R17, Z+3
   \   00000036   5F0F               SUBI    R16, 255
   \   00000038   4F1F               SBCI    R17, 255
   \   0000003A   8302               STD     Z+2, R16
   \   0000003C   8313               STD     Z+3, R17
    375          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_EEPROM_DATA >> 8;
   \   0000003E   8100               LD      R16, Z
   \   00000040   8111               LDD     R17, Z+1
   \   00000042   8142               LDD     R20, Z+2
   \   00000044   8153               LDD     R21, Z+3
   \   00000046   0F04               ADD     R16, R20
   \   00000048   1F15               ADC     R17, R21
   \   0000004A   01F8               MOVW    R31:R30, R17:R16
   \   0000004C   E004               LDI     R16, 4
   \   0000004E   8300               ST      Z, R16
   \   00000050   01FD               MOVW    R31:R30, R27:R26
   \   00000052   8102               LDD     R16, Z+2
   \   00000054   8113               LDD     R17, Z+3
   \   00000056   5F0F               SUBI    R16, 255
   \   00000058   4F1F               SBCI    R17, 255
   \   0000005A   8302               STD     Z+2, R16
   \   0000005C   8313               STD     Z+3, R17
    376          	ntna = UART[ch].TxFirst;                                    /* remember index */
   \   0000005E   0128               MOVW    R5:R4, R17:R16
    377          	UART[ch].TxFirst += 2;                                      // two byte length
   \   00000060   5F0E               SUBI    R16, 254
   \   00000062   4F1F               SBCI    R17, 255
   \   00000064   8302               STD     Z+2, R16
   \   00000066   8313               STD     Z+3, R17
    378          
    379          	channel = pointer[0];
   \   00000068   01F9               MOVW    R31:R30, R19:R18
   \   0000006A   8120               LD      R18, Z
    380          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = channel; //channel
   \   0000006C   910D               LD      R16, X+
   \   0000006E   911C               LD      R17, X
   \   00000070   9711               SBIW    R27:R26, 1
   \   00000072   01FD               MOVW    R31:R30, R27:R26
   \   00000074   8142               LDD     R20, Z+2
   \   00000076   8153               LDD     R21, Z+3
   \   00000078   0F04               ADD     R16, R20
   \   0000007A   1F15               ADC     R17, R21
   \   0000007C   01F8               MOVW    R31:R30, R17:R16
   \   0000007E   8320               ST      Z, R18
   \   00000080   01FD               MOVW    R31:R30, R27:R26
   \   00000082   8102               LDD     R16, Z+2
   \   00000084   8113               LDD     R17, Z+3
   \   00000086   5F0F               SUBI    R16, 255
   \   00000088   4F1F               SBCI    R17, 255
   \   0000008A   8302               STD     Z+2, R16
   \   0000008C   8313               STD     Z+3, R17
    381          
    382          	ReadEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&UART[ch].pTxBuffer[UART[ch].TxFirst]);
   \   0000008E   E008               LDI     R16, 8
   \   00000090   9F20               MUL     R18, R16
   \   00000092   01C0               MOVW    R25:R24, R1:R0
   \   00000094   8140               LD      R20, Z
   \   00000096   8151               LDD     R21, Z+1
   \   00000098   8102               LDD     R16, Z+2
   \   0000009A   0F40               ADD     R20, R16
   \   0000009C   1F51               ADC     R21, R17
   \   0000009E   E024               LDI     R18, 4
   \   000000A0   0180               MOVW    R17:R16, R1:R0
   \   000000A2   ........           CALL    ReadEEPROMBuffer
    383          	UART[ch].TxFirst += sizeof(float);
   \   000000A6   01FD               MOVW    R31:R30, R27:R26
   \   000000A8   8102               LDD     R16, Z+2
   \   000000AA   8113               LDD     R17, Z+3
   \   000000AC   5F0C               SUBI    R16, 252
   \   000000AE   4F1F               SBCI    R17, 255
   \   000000B0   8302               STD     Z+2, R16
   \   000000B2   8313               STD     Z+3, R17
    384          	ReadEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&UART[ch].pTxBuffer[UART[ch].TxFirst]);
   \   000000B4   8140               LD      R20, Z
   \   000000B6   8151               LDD     R21, Z+1
   \   000000B8   0F40               ADD     R20, R16
   \   000000BA   1F51               ADC     R21, R17
   \   000000BC   E024               LDI     R18, 4
   \   000000BE   9604               ADIW    R25:R24, 4
   \   000000C0   018C               MOVW    R17:R16, R25:R24
   \   000000C2   ........           CALL    ReadEEPROMBuffer
    385          	UART[ch].TxFirst += sizeof(float);
   \   000000C6   01FD               MOVW    R31:R30, R27:R26
   \   000000C8   8102               LDD     R16, Z+2
   \   000000CA   8113               LDD     R17, Z+3
   \   000000CC   5F0C               SUBI    R16, 252
   \   000000CE   4F1F               SBCI    R17, 255
   \   000000D0   8302               STD     Z+2, R16
   \   000000D2   8313               STD     Z+3, R17
    386          
    387          	UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000D4   1904               SUB     R16, R4
   \   000000D6   5002               SUBI    R16, 2
   \   000000D8   91ED               LD      R30, X+
   \   000000DA   91FC               LD      R31, X
   \   000000DC   9711               SBIW    R27:R26, 1
   \   000000DE   0DE4               ADD     R30, R4
   \   000000E0   1DF5               ADC     R31, R5
   \   000000E2   8300               ST      Z, R16
    388          	UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000E4   01FD               MOVW    R31:R30, R27:R26
   \   000000E6   8182               LDD     R24, Z+2
   \   000000E8   8193               LDD     R25, Z+3
   \   000000EA   1984               SUB     R24, R4
   \   000000EC   0995               SBC     R25, R5
   \   000000EE   9702               SBIW    R25:R24, 2
   \   000000F0   91ED               LD      R30, X+
   \   000000F2   91FC               LD      R31, X
   \   000000F4   0DE4               ADD     R30, R4
   \   000000F6   1DF5               ADC     R31, R5
   \   000000F8   8391               STD     Z+1, R25
    389          }
   \   000000FA                      REQUIRE ?Subroutine0
   \   000000FA                      ;               // Fall through to label ?Subroutine0
    390          
    391          
    392          /*************************************************************************
    393          *
    394          * Build datablock for Internal AD
    395          *
    396          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    397          void BuildADInt(char ch, unsigned char *pointer) {
   \                     BuildADInt:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F59               MOV     R21, R25
   \   00000006   2E28               MOV     R2, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    398          
    399          	short ntna, i;
    400          	UART[ch].RxSendReply = true;                               // flag for answering
   \   00000008   E11F               LDI     R17, 31
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E001               LDI     R16, 1
   \   00000016   8F02               STD     Z+26, R16
    401          
    402          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_INT_DATA & 0xff;
   \   00000018   81A0               LD      R26, Z
   \   0000001A   81B1               LDD     R27, Z+1
   \   0000001C   8102               LDD     R16, Z+2
   \   0000001E   8113               LDD     R17, Z+3
   \   00000020   0FA0               ADD     R26, R16
   \   00000022   1FB1               ADC     R27, R17
   \   00000024   E403               LDI     R16, 67
   \   00000026   930C               ST      X, R16
   \   00000028   8102               LDD     R16, Z+2
   \   0000002A   8113               LDD     R17, Z+3
   \   0000002C   5F0F               SUBI    R16, 255
   \   0000002E   4F1F               SBCI    R17, 255
   \   00000030   8302               STD     Z+2, R16
   \   00000032   8313               STD     Z+3, R17
    403          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_INT_DATA >> 8;
   \   00000034   81A0               LD      R26, Z
   \   00000036   81B1               LDD     R27, Z+1
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   E004               LDI     R16, 4
   \   0000003E   930C               ST      X, R16
   \   00000040   8102               LDD     R16, Z+2
   \   00000042   8113               LDD     R17, Z+3
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   8302               STD     Z+2, R16
   \   0000004A   8313               STD     Z+3, R17
    404          	ntna = UART[ch].TxFirst;                                    /* remember index */
   \   0000004C   0198               MOVW    R19:R18, R17:R16
    405          	UART[ch].TxFirst += 2;                                      // two byte length
   \   0000004E   5F0E               SUBI    R16, 254
   \   00000050   4F1F               SBCI    R17, 255
   \   00000052   8302               STD     Z+2, R16
   \   00000054   8313               STD     Z+3, R17
    406          
    407          	for (i = 0; i < 3; i++) {
   \   00000056   ....               LDI     R16, LOW(ADInt)
   \   00000058   ....               LDI     R17, (ADInt) >> 8
   \   0000005A   E043               LDI     R20, 3
    408          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = ADInt.Result[i];
   \                     ??BuildADInt_0:
   \   0000005C   01D8               MOVW    R27:R26, R17:R16
   \   0000005E   916D               LD      R22, X+
   \   00000060   81A0               LD      R26, Z
   \   00000062   81B1               LDD     R27, Z+1
   \   00000064   8002               LDD     R0, Z+2
   \   00000066   8013               LDD     R1, Z+3
   \   00000068   0DA0               ADD     R26, R0
   \   0000006A   1DB1               ADC     R27, R1
   \   0000006C   936C               ST      X, R22
   \   0000006E   8162               LDD     R22, Z+2
   \   00000070   8173               LDD     R23, Z+3
   \   00000072   5F6F               SUBI    R22, 255
   \   00000074   4F7F               SBCI    R23, 255
   \   00000076   8362               STD     Z+2, R22
   \   00000078   8373               STD     Z+3, R23
    409          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = ADInt.Result[i] >> 8;   // ADresult
   \   0000007A   01D8               MOVW    R27:R26, R17:R16
   \   0000007C   9611               ADIW    R27:R26, 1
   \   0000007E   917D               LD      R23, X+
   \   00000080   018D               MOVW    R17:R16, R27:R26
   \   00000082   81A0               LD      R26, Z
   \   00000084   81B1               LDD     R27, Z+1
   \   00000086   8002               LDD     R0, Z+2
   \   00000088   8013               LDD     R1, Z+3
   \   0000008A   0DA0               ADD     R26, R0
   \   0000008C   1DB1               ADC     R27, R1
   \   0000008E   937C               ST      X, R23
   \   00000090   8162               LDD     R22, Z+2
   \   00000092   8173               LDD     R23, Z+3
   \   00000094   5F6F               SUBI    R22, 255
   \   00000096   4F7F               SBCI    R23, 255
   \   00000098   8362               STD     Z+2, R22
   \   0000009A   8373               STD     Z+3, R23
    410          	}
   \   0000009C   954A               DEC     R20
   \   0000009E   F6F1               BRNE    ??BuildADInt_0
    411          
    412          	UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000A0   8102               LDD     R16, Z+2
   \   000000A2   1B02               SUB     R16, R18
   \   000000A4   5002               SUBI    R16, 2
   \   000000A6   81A0               LD      R26, Z
   \   000000A8   81B1               LDD     R27, Z+1
   \   000000AA   0FA2               ADD     R26, R18
   \   000000AC   1FB3               ADC     R27, R19
   \   000000AE   930C               ST      X, R16
    413          	UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000B0   8182               LDD     R24, Z+2
   \   000000B2   8193               LDD     R25, Z+3
   \   000000B4   1B82               SUB     R24, R18
   \   000000B6   0B93               SBC     R25, R19
   \   000000B8   9702               SBIW    R25:R24, 2
   \   000000BA   8100               LD      R16, Z
   \   000000BC   8111               LDD     R17, Z+1
   \   000000BE   0F02               ADD     R16, R18
   \   000000C0   1F13               ADC     R17, R19
   \   000000C2   01F8               MOVW    R31:R30, R17:R16
   \   000000C4   8391               STD     Z+1, R25
    414          
    415          }
   \   000000C6   2D82               MOV     R24, R2
   \   000000C8   2F95               MOV     R25, R21
   \   000000CA   2DA3               MOV     R26, R3
   \   000000CC   91B9               LD      R27, Y+
   \   000000CE   9508               RET
    416          
    417          
    418          /*************************************************************************
    419          *
    420          * Build setup data package for AN-ZBHART
    421          *
    422          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    423          void BuildHartSetup(char ch, unsigned char *pointer) {
   \                     BuildHartSetup:
   \   00000000   2F7B               MOV     R23, R27
   \   00000002   2E2A               MOV     R2, R26
   \   00000004   2F59               MOV     R21, R25
   \   00000006   2F68               MOV     R22, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    424          
    425          	short ntna;
    426          	UART[ch].RxSendReply = true;                               // flag for answering
   \   00000008   E11F               LDI     R17, 31
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E001               LDI     R16, 1
   \   00000016   8F02               STD     Z+26, R16
    427          
    428          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_HART_SETUP & 0xff;
   \   00000018   81A0               LD      R26, Z
   \   0000001A   81B1               LDD     R27, Z+1
   \   0000001C   8102               LDD     R16, Z+2
   \   0000001E   8113               LDD     R17, Z+3
   \   00000020   0FA0               ADD     R26, R16
   \   00000022   1FB1               ADC     R27, R17
   \   00000024   EE0D               LDI     R16, 237
   \   00000026   930C               ST      X, R16
   \   00000028   8102               LDD     R16, Z+2
   \   0000002A   8113               LDD     R17, Z+3
   \   0000002C   5F0F               SUBI    R16, 255
   \   0000002E   4F1F               SBCI    R17, 255
   \   00000030   8302               STD     Z+2, R16
   \   00000032   8313               STD     Z+3, R17
    429          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_HART_SETUP >> 8;
   \   00000034   81A0               LD      R26, Z
   \   00000036   81B1               LDD     R27, Z+1
   \   00000038   0FA0               ADD     R26, R16
   \   0000003A   1FB1               ADC     R27, R17
   \   0000003C   E004               LDI     R16, 4
   \   0000003E   930C               ST      X, R16
   \   00000040   8102               LDD     R16, Z+2
   \   00000042   8113               LDD     R17, Z+3
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   8302               STD     Z+2, R16
   \   0000004A   8313               STD     Z+3, R17
    430          	ntna = UART[ch].TxFirst;                                    /* remember index */
    431          	UART[ch].TxFirst += 2;                                      // two byte length
   \   0000004C   0198               MOVW    R19:R18, R17:R16
   \   0000004E   5F2E               SUBI    R18, 254
   \   00000050   4F3F               SBCI    R19, 255
   \   00000052   8322               STD     Z+2, R18
   \   00000054   8333               STD     Z+3, R19
    432          
    433          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.Hart.PortUsed & 0xff;
   \   00000056   9120....           LDS     R18, (TData + 144)
   \   0000005A   81A0               LD      R26, Z
   \   0000005C   81B1               LDD     R27, Z+1
   \   0000005E   8142               LDD     R20, Z+2
   \   00000060   0FA4               ADD     R26, R20
   \   00000062   1FB3               ADC     R27, R19
   \   00000064   932C               ST      X, R18
   \   00000066   8122               LDD     R18, Z+2
   \   00000068   8133               LDD     R19, Z+3
   \   0000006A   5F2F               SUBI    R18, 255
   \   0000006C   4F3F               SBCI    R19, 255
   \   0000006E   8322               STD     Z+2, R18
   \   00000070   8333               STD     Z+3, R19
    434          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TData.Hart.PortUsed >> 8) & 0xff;
   \   00000072   9120....           LDS     R18, (TData + 145)
   \   00000076   81A0               LD      R26, Z
   \   00000078   81B1               LDD     R27, Z+1
   \   0000007A   8142               LDD     R20, Z+2
   \   0000007C   0FA4               ADD     R26, R20
   \   0000007E   1FB3               ADC     R27, R19
   \   00000080   932C               ST      X, R18
   \   00000082   8122               LDD     R18, Z+2
   \   00000084   8133               LDD     R19, Z+3
   \   00000086   5F2F               SUBI    R18, 255
   \   00000088   4F3F               SBCI    R19, 255
   \   0000008A   8322               STD     Z+2, R18
   \   0000008C   8333               STD     Z+3, R19
    435          
    436          	UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   0000008E   1B20               SUB     R18, R16
   \   00000090   5022               SUBI    R18, 2
   \   00000092   81A0               LD      R26, Z
   \   00000094   81B1               LDD     R27, Z+1
   \   00000096   0FA0               ADD     R26, R16
   \   00000098   1FB1               ADC     R27, R17
   \   0000009A   932C               ST      X, R18
    437          	UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000009C   8182               LDD     R24, Z+2
   \   0000009E   8193               LDD     R25, Z+3
   \   000000A0   1B80               SUB     R24, R16
   \   000000A2   0B91               SBC     R25, R17
   \   000000A4   9702               SBIW    R25:R24, 2
   \   000000A6   8120               LD      R18, Z
   \   000000A8   8131               LDD     R19, Z+1
   \   000000AA   0F20               ADD     R18, R16
   \   000000AC   1F31               ADC     R19, R17
   \   000000AE   01F9               MOVW    R31:R30, R19:R18
   \   000000B0   8391               STD     Z+1, R25
    438          }
   \   000000B2   2F86               MOV     R24, R22
   \   000000B4   2F95               MOV     R25, R21
   \   000000B6   2DA2               MOV     R26, R2
   \   000000B8   2FB7               MOV     R27, R23
   \   000000BA   9508               RET
    439          
    440          /*************************************************************************
    441          *
    442          * Build filter data package for AN-ZBHART
    443          *
    444          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    445          void BuildHartFilter(char ch, unsigned char *pointer) {
   \                     BuildHartFilter:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   2E3A               MOV     R3, R26
   \   00000004   2F79               MOV     R23, R25
   \   00000006   2E28               MOV     R2, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    446          
    447          	char port;
    448          	short ntna;
    449          	UART[ch].RxSendReply = true;                               // flag for answering
   \   00000008   E11F               LDI     R17, 31
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R26, LOW(UART)
   \   0000000E   ....               LDI     R27, (UART) >> 8
   \   00000010   0DA0               ADD     R26, R0
   \   00000012   1DB1               ADC     R27, R1
   \   00000014   01FD               MOVW    R31:R30, R27:R26
   \   00000016   E001               LDI     R16, 1
   \   00000018   8F02               STD     Z+26, R16
    450          
    451          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_HART_FILTER & 0xff;
   \   0000001A   91ED               LD      R30, X+
   \   0000001C   91FD               LD      R31, X+
   \   0000001E   910D               LD      R16, X+
   \   00000020   911C               LD      R17, X
   \   00000022   9713               SBIW    R27:R26, 3
   \   00000024   0FE0               ADD     R30, R16
   \   00000026   1FF1               ADC     R31, R17
   \   00000028   E001               LDI     R16, 1
   \   0000002A   8300               ST      Z, R16
   \   0000002C   01FD               MOVW    R31:R30, R27:R26
   \   0000002E   8102               LDD     R16, Z+2
   \   00000030   8113               LDD     R17, Z+3
   \   00000032   5F0F               SUBI    R16, 255
   \   00000034   4F1F               SBCI    R17, 255
   \   00000036   8302               STD     Z+2, R16
   \   00000038   8313               STD     Z+3, R17
    452          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_HART_FILTER >> 8;
   \   0000003A   91ED               LD      R30, X+
   \   0000003C   91FD               LD      R31, X+
   \   0000003E   910D               LD      R16, X+
   \   00000040   9713               SBIW    R27:R26, 3
   \   00000042   0FE0               ADD     R30, R16
   \   00000044   1FF1               ADC     R31, R17
   \   00000046   E005               LDI     R16, 5
   \   00000048   8300               ST      Z, R16
   \   0000004A   01FD               MOVW    R31:R30, R27:R26
   \   0000004C   8102               LDD     R16, Z+2
   \   0000004E   8113               LDD     R17, Z+3
   \   00000050   5F0F               SUBI    R16, 255
   \   00000052   4F1F               SBCI    R17, 255
   \   00000054   8302               STD     Z+2, R16
   \   00000056   8313               STD     Z+3, R17
    453          	ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000058   01A8               MOVW    R21:R20, R17:R16
    454          	UART[ch].TxFirst += 2;                                      // two byte length
   \   0000005A   5F0E               SUBI    R16, 254
   \   0000005C   4F1F               SBCI    R17, 255
   \   0000005E   8302               STD     Z+2, R16
   \   00000060   8313               STD     Z+3, R17
    455          
    456          	for (port = 0; port < 12; port++) {
   \   00000062   E060               LDI     R22, 0
   \   00000064   E02C               LDI     R18, 12
    457          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = TData.Hart.Filter[port];
   \                     ??BuildHartFilter_0:
   \   00000066   E0F0               LDI     R31, 0
   \   00000068   2FE6               MOV     R30, R22
   \   0000006A   ....               SUBI    R30, LOW((-(TData + 146) & 0xFFFF))
   \   0000006C   ....               SBCI    R31, HIGH((-(TData + 146) & 0xFFFF))
   \   0000006E   8130               LD      R19, Z
   \   00000070   01FD               MOVW    R31:R30, R27:R26
   \   00000072   8100               LD      R16, Z
   \   00000074   8111               LDD     R17, Z+1
   \   00000076   8002               LDD     R0, Z+2
   \   00000078   8013               LDD     R1, Z+3
   \   0000007A   0D00               ADD     R16, R0
   \   0000007C   1D11               ADC     R17, R1
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   8330               ST      Z, R19
   \   00000082   01FD               MOVW    R31:R30, R27:R26
   \   00000084   8102               LDD     R16, Z+2
   \   00000086   8113               LDD     R17, Z+3
   \   00000088   5F0F               SUBI    R16, 255
   \   0000008A   4F1F               SBCI    R17, 255
   \   0000008C   8302               STD     Z+2, R16
   \   0000008E   8313               STD     Z+3, R17
    458          	}
   \   00000090   9563               INC     R22
   \   00000092   952A               DEC     R18
   \   00000094   F741               BRNE    ??BuildHartFilter_0
    459          
    460          	UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   00000096   8102               LDD     R16, Z+2
   \   00000098   1B04               SUB     R16, R20
   \   0000009A   5002               SUBI    R16, 2
   \   0000009C   91ED               LD      R30, X+
   \   0000009E   91FC               LD      R31, X
   \   000000A0   9711               SBIW    R27:R26, 1
   \   000000A2   0FE4               ADD     R30, R20
   \   000000A4   1FF5               ADC     R31, R21
   \   000000A6   8300               ST      Z, R16
    461          	UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000A8   01FD               MOVW    R31:R30, R27:R26
   \   000000AA   8182               LDD     R24, Z+2
   \   000000AC   8193               LDD     R25, Z+3
   \   000000AE   1B84               SUB     R24, R20
   \   000000B0   0B95               SBC     R25, R21
   \   000000B2   9702               SBIW    R25:R24, 2
   \   000000B4   91ED               LD      R30, X+
   \   000000B6   91FC               LD      R31, X
   \   000000B8   0FE4               ADD     R30, R20
   \   000000BA   1FF5               ADC     R31, R21
   \   000000BC   8391               STD     Z+1, R25
    462          }
   \   000000BE   2D82               MOV     R24, R2
   \   000000C0   2F97               MOV     R25, R23
   \   000000C2   2DA3               MOV     R26, R3
   \   000000C4   91B9               LD      R27, Y+
   \   000000C6   9508               RET
    463          
    464          /*************************************************************************
    465          *
    466          * Build datablock for Hart (Hart)
    467          *
    468          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    469          void BuildMDataHart(UARTDataType *pUART) {
   \                     BuildMDataHart:
   \   00000000   92CA               ST      -Y, R12
   \   00000002   92BA               ST      -Y, R11
   \   00000004   92AA               ST      -Y, R10
   \   00000006   929A               ST      -Y, R9
   \   00000008   928A               ST      -Y, R8
   \   0000000A   927A               ST      -Y, R7
   \   0000000C   926A               ST      -Y, R6
   \   0000000E   925A               ST      -Y, R5
   \   00000010   924A               ST      -Y, R4
   \   00000012   93BA               ST      -Y, R27
   \   00000014   93AA               ST      -Y, R26
   \   00000016   939A               ST      -Y, R25
   \   00000018   938A               ST      -Y, R24
   \   0000001A                      REQUIRE ?Register_R4_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R5_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R6_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R7_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R8_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R9_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R10_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R11_is_cg_reg
   \   0000001A                      REQUIRE ?Register_R12_is_cg_reg
   \   0000001A                      REQUIRE __RSTACK_in_external_ram_new_way
   \   0000001A   0158               MOVW    R11:R10, R17:R16
    470          	short Index        = 11; // // Add data after the heading, Heading size is 11
    471          	char *Buf          = pUART->pTxBuffer;
   \   0000001C   01F8               MOVW    R31:R30, R17:R16
   \   0000001E   8080               LD      R8, Z
   \   00000020   8091               LDD     R9, Z+1
    472          	pUART->RxSendReply = true;                               // flag for answering
   \   00000022   E001               LDI     R16, 1
   \   00000024   8F02               STD     Z+26, R16
    473          	Buf[Index++] = CMD_REP_HART_MDATA & 0xff;
   \   00000026   01F4               MOVW    R31:R30, R9:R8
   \   00000028   E00B               LDI     R16, 11
   \   0000002A   8703               STD     Z+11, R16
    474          	Buf[Index++] = CMD_REP_HART_MDATA >> 8;
   \   0000002C   E005               LDI     R16, 5
   \   0000002E   8704               STD     Z+12, R16
    475          	short ntna = Index;                                  /* remember index */
    476          	Index  += 2;                                      // two byte length
    477          
    478          	Buf[Index++] = (RestartStatus << 4);    // Add restart status
   \   00000030   9100....           LDS     R16, RestartStatus
   \   00000034   9502               SWAP    R16
   \   00000036   7F00               ANDI    R16, 0xF0
   \   00000038   8707               STD     Z+15, R16
   \   0000003A   E100               LDI     R16, 16
   \   0000003C   2E60               MOV     R6, R16
   \   0000003E   2477               CLR     R7
    479          	// Hart PV
    480          	for (short i = 0; i < 12; i++) {
   \   00000040   01D4               MOVW    R27:R26, R9:R8
   \   00000042   9654               ADIW    R27:R26, 20
   \   00000044   ....               LDI     R24, LOW((TData + 158))
   \   00000046   ....               LDI     R25, HIGH((TData + 158))
   \   00000048   ....               LDI     R16, LOW(_hart_channels)
   \   0000004A   ....               LDI     R17, (_hart_channels) >> 8
   \   0000004C   0128               MOVW    R5:R4, R17:R16
   \   0000004E   E00C               LDI     R16, 12
   \   00000050   2EC0               MOV     R12, R16
    481          		*((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][0];   // Hart 1st
   \                     ??BuildMDataHart_0:
   \   00000052   019C               MOVW    R19:R18, R25:R24
   \   00000054   592E               SUBI    R18, 158
   \   00000056   4030               SBCI    R19, 0
   \   00000058   01F9               MOVW    R31:R30, R19:R18
   \   0000005A   8140               LD      R20, Z
   \   0000005C   8151               LDD     R21, Z+1
   \   0000005E   01FD               MOVW    R31:R30, R27:R26
   \   00000060   9734               SBIW    R31:R30, 4
   \   00000062   8340               ST      Z, R20
   \   00000064   8351               STD     Z+1, R21
    482          		Index += sizeof(unsigned short);
    483          
    484          		*((unsigned short *)&Buf[Index]) = TData.Hart.FailCnt[i][1];   // Hart 1st
   \   00000066   01F9               MOVW    R31:R30, R19:R18
   \   00000068   8122               LDD     R18, Z+2
   \   0000006A   8133               LDD     R19, Z+3
   \   0000006C   01FD               MOVW    R31:R30, R27:R26
   \   0000006E   9732               SBIW    R31:R30, 2
   \   00000070   8320               ST      Z, R18
   \   00000072   8331               STD     Z+1, R19
    485          		Index += sizeof(unsigned short);
    486          		hart_channel_lock(&_hart_channels[i]);
   \   00000074   0182               MOVW    R17:R16, R5:R4
   \   00000076   ........           CALL    hart_channel_lock
    487          		*((float *)&Buf[Index]) = TData.Hart.Distance[i];   // Hart 1st
   \   0000007A   01FC               MOVW    R31:R30, R25:R24
   \   0000007C   5AE0               SUBI    R30, 160
   \   0000007E   4FFF               SBCI    R31, 255
   \   00000080   8100               LD      R16, Z
   \   00000082   8111               LDD     R17, Z+1
   \   00000084   8122               LDD     R18, Z+2
   \   00000086   8133               LDD     R19, Z+3
   \   00000088   930D               ST      X+, R16
   \   0000008A   931D               ST      X+, R17
   \   0000008C   932D               ST      X+, R18
   \   0000008E   933C               ST      X, R19
   \   00000090   9713               SBIW    R27:R26, 3
    488          		Index += sizeof(float);
    489          		*((float *)&Buf[Index]) = TData.Hart.Level[i];   // Hart 2nd
   \   00000092   A900               LDD     R16, Z+48
   \   00000094   A911               LDD     R17, Z+49
   \   00000096   A922               LDD     R18, Z+50
   \   00000098   A933               LDD     R19, Z+51
   \   0000009A   01FD               MOVW    R31:R30, R27:R26
   \   0000009C   8304               STD     Z+4, R16
   \   0000009E   8315               STD     Z+5, R17
   \   000000A0   8326               STD     Z+6, R18
   \   000000A2   8337               STD     Z+7, R19
    490          		Index += sizeof(float);
    491          		*((float *)&Buf[Index]) = TData.Hart.ADCurrent[i];   // Measured current
   \   000000A4   01FC               MOVW    R31:R30, R25:R24
   \   000000A6   8100               LD      R16, Z
   \   000000A8   8111               LDD     R17, Z+1
   \   000000AA   8122               LDD     R18, Z+2
   \   000000AC   8133               LDD     R19, Z+3
   \   000000AE   01FD               MOVW    R31:R30, R27:R26
   \   000000B0   8700               STD     Z+8, R16
   \   000000B2   8711               STD     Z+9, R17
   \   000000B4   8722               STD     Z+10, R18
   \   000000B6   8733               STD     Z+11, R19
    492          		Index += sizeof(float);
   \   000000B8   E100               LDI     R16, 16
   \   000000BA   0E60               ADD     R6, R16
   \   000000BC   E000               LDI     R16, 0
   \   000000BE   1E70               ADC     R7, R16
    493          		hart_channel_unlock(&_hart_channels[i]);
   \   000000C0   0182               MOVW    R17:R16, R5:R4
   \   000000C2   ........           CALL    hart_channel_unlock
    494          	}
   \   000000C6   E10B               LDI     R16, 27
   \   000000C8   0E40               ADD     R4, R16
   \   000000CA   E000               LDI     R16, 0
   \   000000CC   1E50               ADC     R5, R16
   \   000000CE   9604               ADIW    R25:R24, 4
   \   000000D0   9650               ADIW    R27:R26, 16
   \   000000D2   94CA               DEC     R12
   \   000000D4   F009               BREQ    $+2+2
   \   000000D6   CFBD               RJMP    ??BuildMDataHart_0
    495          	Buf[ntna] = (Index - ntna - 2) & 0xff;      // length of data block lb
   \   000000D8   2D06               MOV     R16, R6
   \   000000DA   500F               SUBI    R16, 15
   \   000000DC   01F4               MOVW    R31:R30, R9:R8
   \   000000DE   8705               STD     Z+13, R16
    496          	Buf[ntna + 1] = ((Index - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   000000E0   01F3               MOVW    R31:R30, R7:R6
   \   000000E2   973F               SBIW    R31:R30, 15
   \   000000E4   2F0F               MOV     R16, R31
   \   000000E6   01F4               MOVW    R31:R30, R9:R8
   \   000000E8   8706               STD     Z+14, R16
    497          	pUART->TxFirst = Index; // Add data after the heading
   \   000000EA   01F5               MOVW    R31:R30, R11:R10
   \   000000EC   8262               STD     Z+2, R6
   \   000000EE   8273               STD     Z+3, R7
    498          
    499          
    500          }
   \   000000F0   9189               LD      R24, Y+
   \   000000F2   9199               LD      R25, Y+
   \   000000F4   91A9               LD      R26, Y+
   \   000000F6   91B9               LD      R27, Y+
   \   000000F8   9049               LD      R4, Y+
   \   000000FA   9059               LD      R5, Y+
   \   000000FC   9069               LD      R6, Y+
   \   000000FE   9079               LD      R7, Y+
   \   00000100   9089               LD      R8, Y+
   \   00000102   9099               LD      R9, Y+
   \   00000104   90A9               LD      R10, Y+
   \   00000106   90B9               LD      R11, Y+
   \   00000108   90C9               LD      R12, Y+
   \   0000010A   9508               RET
    501          
    502          
    503          /*************************************************************************
    504          *
    505          * Build datablock for Stack status
    506          *
    507          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    508          void BuildStackStatus(char ch, unsigned char *pointer) {
   \                     BuildStackStatus:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   938A               ST      -Y, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
    509          
    510          	short ntna, stack;
    511          	UART[ch].RxSendReply = true;                               // flag for answering
   \   00000008   E11F               LDI     R17, 31
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R26, LOW(UART)
   \   0000000E   ....               LDI     R27, (UART) >> 8
   \   00000010   0DA0               ADD     R26, R0
   \   00000012   1DB1               ADC     R27, R1
   \   00000014   01FD               MOVW    R31:R30, R27:R26
   \   00000016   E001               LDI     R16, 1
   \   00000018   8F02               STD     Z+26, R16
    512          
    513          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STACKSTATUS & 0xff;
   \   0000001A   91ED               LD      R30, X+
   \   0000001C   91FD               LD      R31, X+
   \   0000001E   910D               LD      R16, X+
   \   00000020   911C               LD      R17, X
   \   00000022   9713               SBIW    R27:R26, 3
   \   00000024   0FE0               ADD     R30, R16
   \   00000026   1FF1               ADC     R31, R17
   \   00000028   E707               LDI     R16, 119
   \   0000002A   8300               ST      Z, R16
   \   0000002C   01FD               MOVW    R31:R30, R27:R26
   \   0000002E   8102               LDD     R16, Z+2
   \   00000030   8113               LDD     R17, Z+3
   \   00000032   5F0F               SUBI    R16, 255
   \   00000034   4F1F               SBCI    R17, 255
   \   00000036   8302               STD     Z+2, R16
   \   00000038   8313               STD     Z+3, R17
    514          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = CMD_REP_STACKSTATUS >> 8;
   \   0000003A   91ED               LD      R30, X+
   \   0000003C   91FD               LD      R31, X+
   \   0000003E   910D               LD      R16, X+
   \   00000040   9713               SBIW    R27:R26, 3
   \   00000042   0FE0               ADD     R30, R16
   \   00000044   1FF1               ADC     R31, R17
   \   00000046   E007               LDI     R16, 7
   \   00000048   8300               ST      Z, R16
   \   0000004A   01FD               MOVW    R31:R30, R27:R26
   \   0000004C   8102               LDD     R16, Z+2
   \   0000004E   8113               LDD     R17, Z+3
   \   00000050   5F0F               SUBI    R16, 255
   \   00000052   4F1F               SBCI    R17, 255
   \   00000054   8302               STD     Z+2, R16
   \   00000056   8313               STD     Z+3, R17
    515          	ntna = UART[ch].TxFirst;                                    /* remember index */
   \   00000058   01C8               MOVW    R25:R24, R17:R16
    516          	UART[ch].TxFirst += 2;                                      // two byte length
   \   0000005A   5F0E               SUBI    R16, 254
   \   0000005C   4F1F               SBCI    R17, 255
   \   0000005E   8302               STD     Z+2, R16
   \   00000060   8313               STD     Z+3, R17
    517          
    518          	stack = OS_GetStackSpace(&TCB_USART0);                            // USART 0
   \   00000062   ....               LDI     R16, LOW(TCB_USART0)
   \   00000064   ....               LDI     R17, (TCB_USART0) >> 8
   \   00000066   ........           CALL    OS_GetStackSpace
   \   0000006A   2F31               MOV     R19, R17
    519          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
   \   0000006C   2F40               MOV     R20, R16
   \   0000006E   910D               LD      R16, X+
   \   00000070   911C               LD      R17, X
   \   00000072   9711               SBIW    R27:R26, 1
   \   00000074   01FD               MOVW    R31:R30, R27:R26
   \   00000076   8162               LDD     R22, Z+2
   \   00000078   8173               LDD     R23, Z+3
   \   0000007A   0F06               ADD     R16, R22
   \   0000007C   1F17               ADC     R17, R23
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   8340               ST      Z, R20
   \   00000082   01FD               MOVW    R31:R30, R27:R26
   \   00000084   8102               LDD     R16, Z+2
   \   00000086   8113               LDD     R17, Z+3
   \   00000088   5F0F               SUBI    R16, 255
   \   0000008A   4F1F               SBCI    R17, 255
   \   0000008C   8302               STD     Z+2, R16
   \   0000008E   8313               STD     Z+3, R17
    520          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
   \   00000090   8100               LD      R16, Z
   \   00000092   8111               LDD     R17, Z+1
   \   00000094   8142               LDD     R20, Z+2
   \   00000096   8153               LDD     R21, Z+3
   \   00000098   0F04               ADD     R16, R20
   \   0000009A   1F15               ADC     R17, R21
   \   0000009C   01F8               MOVW    R31:R30, R17:R16
   \   0000009E   8330               ST      Z, R19
   \   000000A0   01FD               MOVW    R31:R30, R27:R26
   \   000000A2   8102               LDD     R16, Z+2
   \   000000A4   8113               LDD     R17, Z+3
   \   000000A6   5F0F               SUBI    R16, 255
   \   000000A8   4F1F               SBCI    R17, 255
   \   000000AA   8302               STD     Z+2, R16
   \   000000AC   8313               STD     Z+3, R17
    521          	/*
    522          	stack = OS_GetStackSpace(&TCB_USART1);                            // USART 1
    523          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
    524          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
    525          	*/
    526          	stack = OS_GetStackSpace(&TCB_WATCHDOG);                            // watchdog
   \   000000AE   ....               LDI     R16, LOW(TCB_WATCHDOG)
   \   000000B0   ....               LDI     R17, (TCB_WATCHDOG) >> 8
   \   000000B2   ........           CALL    OS_GetStackSpace
   \   000000B6   2F31               MOV     R19, R17
    527          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff);
   \   000000B8   2F40               MOV     R20, R16
   \   000000BA   910D               LD      R16, X+
   \   000000BC   911C               LD      R17, X
   \   000000BE   9711               SBIW    R27:R26, 1
   \   000000C0   01FD               MOVW    R31:R30, R27:R26
   \   000000C2   8162               LDD     R22, Z+2
   \   000000C4   8173               LDD     R23, Z+3
   \   000000C6   0F06               ADD     R16, R22
   \   000000C8   1F17               ADC     R17, R23
   \   000000CA   01F8               MOVW    R31:R30, R17:R16
   \   000000CC   8340               ST      Z, R20
   \   000000CE   01FD               MOVW    R31:R30, R27:R26
   \   000000D0   8102               LDD     R16, Z+2
   \   000000D2   8113               LDD     R17, Z+3
   \   000000D4   5F0F               SUBI    R16, 255
   \   000000D6   4F1F               SBCI    R17, 255
   \   000000D8   8302               STD     Z+2, R16
   \   000000DA   8313               STD     Z+3, R17
    528          	UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack >> 8) & 0xff);
   \   000000DC   8100               LD      R16, Z
   \   000000DE   8111               LDD     R17, Z+1
   \   000000E0   8142               LDD     R20, Z+2
   \   000000E2   8153               LDD     R21, Z+3
   \   000000E4   0F04               ADD     R16, R20
   \   000000E6   1F15               ADC     R17, R21
   \   000000E8   01F8               MOVW    R31:R30, R17:R16
   \   000000EA   8330               ST      Z, R19
   \   000000EC   01FD               MOVW    R31:R30, R27:R26
   \   000000EE   8102               LDD     R16, Z+2
   \   000000F0   8113               LDD     R17, Z+3
   \   000000F2   5F0F               SUBI    R16, 255
   \   000000F4   4F1F               SBCI    R17, 255
   \   000000F6   8302               STD     Z+2, R16
   \   000000F8   8313               STD     Z+3, R17
    529          	switch (UnitID) {
    530          	case AN_ZB485 :
    531          		/*
    532          		stack = OS_GetStackSpace(&TCB_RS485Ctl);                            // RS485 Control
    533          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
    534          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
    535          		stack = OS_GetStackSpace(&TCB_RS485Rec);                            // RS485 receive
    536          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
    537          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
    538          		*/
    539          		break;
    540          	case AN_ZBANA :
    541          		/*
    542          		stack = OS_GetStackSpace(&TCB_AD7715);                            // AD handling
    543          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
    544          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
    545          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0 ;
    546          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0 ;
    547          		*/
    548          		break;
    549          	case AN_ZBHART :
    550          		/*
    551          		stack = OS_GetStackSpace(&TCB_AD7715);                            // AD handling
    552          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = (stack & 0xff) ;
    553          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((stack>>8) & 0xff) ;
    554          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0 ;
    555          		UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0 ;
    556          		*/
    557          		break;
    558          	}
    559          
    560          	UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 2) & 0xff;      // length of data block lb
   \   000000FA   1B08               SUB     R16, R24
   \   000000FC   5002               SUBI    R16, 2
   \   000000FE   91ED               LD      R30, X+
   \   00000100   91FC               LD      R31, X
   \   00000102   9711               SBIW    R27:R26, 1
   \   00000104   0FE8               ADD     R30, R24
   \   00000106   1FF9               ADC     R31, R25
   \   00000108   8300               ST      Z, R16
    561          	UART[ch].pTxBuffer[ntna + 1] = ((UART[ch].TxFirst - ntna - 2) >> 8) & 0xff; // length of data block hb
   \   0000010A   01FD               MOVW    R31:R30, R27:R26
   \   0000010C   8102               LDD     R16, Z+2
   \   0000010E   8113               LDD     R17, Z+3
   \   00000110   1B08               SUB     R16, R24
   \   00000112   0B19               SBC     R17, R25
   \   00000114   5002               SUBI    R16, 2
   \   00000116   4010               SBCI    R17, 0
   \   00000118   91ED               LD      R30, X+
   \   0000011A   91FC               LD      R31, X
   \   0000011C   0FE8               ADD     R30, R24
   \   0000011E   1FF9               ADC     R31, R25
   \   00000120   8311               STD     Z+1, R17
    562          
    563          }
   \   00000122   ....               RJMP    ?Subroutine1
    564          
    565          //////////////////////////////////////////////////////////////////////////////
    566          // Receiving data to IO module here
    567          /////////////////////////////////////////////////////////////////////////////
    568          
    569          /*************************************************************************
    570          *
    571          * Receive Command to Reset the EEPROM
    572          *
    573          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    574          void GetResetEEPROM(char ch, unsigned char *pointer) {
   \                     GetResetEEPROM:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    575          
    576          	EEPROMReset();
   \   00000000   ........           JMP     EEPROMReset
    577          }
    578          
    579          
    580          /*************************************************************************
    581          *
    582          * Receive Command to go to the bootloader program
    583          *
    584          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    585          void GetGotoBootloader(char ch, unsigned char *pointer) {
   \                     GetGotoBootloader:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    586          
    587          //    void (*BootApp)(void) = (void(*)())0xF000;
    588          
    589          	while ((EECR & 1 << EEPE) != 0) //chech if EEPROM is ready
   \                     ??GetGotoBootloader_0:
   \   00000000   99F9               SBIC    0x1F, 0x01
   \   00000002   CFFE               RJMP    ??GetGotoBootloader_0
    590          	;
    591          	EEARL = (0x0fff & 0xff);
   \   00000004   EF0F               LDI     R16, 255
   \   00000006   BD01               OUT     0x21, R16
    592          	EEARH = (0x0fff >> 8);
   \   00000008   E00F               LDI     R16, 15
   \   0000000A   BD02               OUT     0x22, R16
    593          	EEDR = 0xff;
   \   0000000C   EF0F               LDI     R16, 255
   \   0000000E   BD00               OUT     0x20, R16
    594          	EECR |= (1 << EEMPE);
   \   00000010   9AFA               SBI     0x1F, 0x02
    595          	EECR |= (1 << EEPE);
   \   00000012   9AF9               SBI     0x1F, 0x01
    596          	while (EECR & (1 << EEPE))
   \                     ??GetGotoBootloader_1:
   \   00000014   99F9               SBIC    0x1F, 0x01
   \   00000016   CFFE               RJMP    ??GetGotoBootloader_1
    597          	;
    598          
    599          	WDTCSR = 0x18;               //Start watchdog to genetate restart
   \   00000018   E108               LDI     R16, 24
   \   0000001A   9300....           STS     _A_WDTCSR, R16
    600          	WDTCSR = 0x08;               //Start watchdog to genetate restart
   \   0000001E   E008               LDI     R16, 8
   \   00000020   9300....           STS     _A_WDTCSR, R16
    601          }
   \   00000024   9508               RET
   \   00000026                      REQUIRE _A_EECR
   \   00000026                      REQUIRE _A_EEAR
   \   00000026                      REQUIRE _A_EEDR
   \   00000026                      REQUIRE _A_WDTCSR
    602          
    603          /*************************************************************************
    604          *
    605          * Receive EEPROM data
    606          *
    607          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    608          void GetEEPROMData(char ch, unsigned char *pointer) {
   \                     GetEEPROMData:
   \   00000000   927A               ST      -Y, R7
   \   00000002   925A               ST      -Y, R5
   \   00000004   924A               ST      -Y, R4
   \   00000006   93BA               ST      -Y, R27
   \   00000008   93AA               ST      -Y, R26
   \   0000000A   939A               ST      -Y, R25
   \   0000000C   938A               ST      -Y, R24
   \   0000000E                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000E                      REQUIRE ?Register_R5_is_cg_reg
   \   0000000E                      REQUIRE ?Register_R7_is_cg_reg
   \   0000000E                      REQUIRE __RSTACK_in_external_ram_new_way
   \   0000000E   0129               MOVW    R5:R4, R19:R18
    609          
    610          	char channel;
    611          	int t0;
    612          
    613          	channel = pointer[0];
   \   00000010   01F9               MOVW    R31:R30, R19:R18
   \   00000012   8100               LD      R16, Z
    614          	switch (UnitID) {
   \   00000014   9110....           LDS     R17, UnitID
   \   00000018   3013               CPI     R17, 3
   \   0000001A   F4F9               BRNE    ??GetEEPROMData_0
    615          	case AN_ZBANA:
    616          		break;
    617          	case AN_ZBHART:
    618          		if (channel >= 0x80) {
   \   0000001C   3800               CPI     R16, 128
   \   0000001E   F0E8               BRCS    ??GetEEPROMData_0
    619          			*((float *)&TData.Hart.Offset[channel & 0x0f]) = *((float *)&pointer[1]);  //offset
   \   00000020   ....               LDI     R30, LOW((TData + 374))
   \   00000022   ....               LDI     R31, HIGH((TData + 374))
   \   00000024   2F20               MOV     R18, R16
   \   00000026   E030               LDI     R19, 0
   \   00000028   702F               ANDI    R18, 0x0F
   \   0000002A   0F22               LSL     R18
   \   0000002C   0F22               LSL     R18
   \   0000002E   0FE2               ADD     R30, R18
   \   00000030   1FF3               ADC     R31, R19
   \   00000032   01D2               MOVW    R27:R26, R5:R4
   \   00000034   9611               ADIW    R27:R26, 1
   \   00000036   914D               LD      R20, X+
   \   00000038   915D               LD      R21, X+
   \   0000003A   916D               LD      R22, X+
   \   0000003C   917C               LD      R23, X
   \   0000003E   8340               ST      Z, R20
   \   00000040   8351               STD     Z+1, R21
   \   00000042   8362               STD     Z+2, R22
   \   00000044   8373               STD     Z+3, R23
    620          			*((float *)&TData.Hart.Gain[channel & 0x0f]) = *((float *)&pointer[5]);  //gain
   \   00000046   01D2               MOVW    R27:R26, R5:R4
   \   00000048   9615               ADIW    R27:R26, 5
   \   0000004A   914D               LD      R20, X+
   \   0000004C   915D               LD      R21, X+
   \   0000004E   916D               LD      R22, X+
   \   00000050   917C               LD      R23, X
   \   00000052   AB40               STD     Z+48, R20
   \   00000054   AB51               STD     Z+49, R21
   \   00000056   AB62               STD     Z+50, R22
   \   00000058   AB73               STD     Z+51, R23
    621          		}
    622          		break;
    623          	case AN_ZB485:
    624          		break;
    625          	}
    626          	WriteEEPROMBuffer((channel * sizeof(float) * 2), sizeof(float), (char *)&pointer[1]);
   \                     ??GetEEPROMData_0:
   \   0000005A   E018               LDI     R17, 8
   \   0000005C   9F01               MUL     R16, R17
   \   0000005E   01D0               MOVW    R27:R26, R1:R0
   \   00000060   01A2               MOVW    R21:R20, R5:R4
   \   00000062   5F4F               SUBI    R20, 255
   \   00000064   4F5F               SBCI    R21, 255
   \   00000066   E024               LDI     R18, 4
   \   00000068   0180               MOVW    R17:R16, R1:R0
   \   0000006A   ........           CALL    WriteEEPROMBuffer
    627          	t0 = OS_GetTime();
   \   0000006E   ........           CALL    OS__Gettime
   \   00000072   01C8               MOVW    R25:R24, R17:R16
   \   00000074   2477               CLR     R7
    628          	do {
    629          		OS_Delay(1);
   \                     ??GetEEPROMData_1:
   \   00000076   E001               LDI     R16, 1
   \   00000078   E010               LDI     R17, 0
   \   0000007A   ........           CALL    OS_Delay
    630          	}while ((OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK);  //8.5 ms programming time
   \   0000007E   ........           CALL    OS__Gettime
   \   00000082   1B08               SUB     R16, R24
   \   00000084   0B19               SBC     R17, R25
   \   00000086   3204               CPI     R16, 36
   \   00000088   4010               SBCI    R17, 0
   \   0000008A   F420               BRCC    ??GetEEPROMData_2
   \   0000008C   9100....           LDS     R16, EEPWriteOK
   \   00000090   2300               TST     R16
   \   00000092   F389               BREQ    ??GetEEPROMData_1
    631          	WriteEEPROMBuffer((channel * sizeof(float) * 2) + sizeof(float), sizeof(float), (char *)&pointer[5]);
   \                     ??GetEEPROMData_2:
   \   00000094   E005               LDI     R16, 5
   \   00000096   0E40               ADD     R4, R16
   \   00000098   1C57               ADC     R5, R7
   \   0000009A   01A2               MOVW    R21:R20, R5:R4
   \   0000009C   E024               LDI     R18, 4
   \   0000009E   9614               ADIW    R27:R26, 4
   \   000000A0   018D               MOVW    R17:R16, R27:R26
   \   000000A2   ........           CALL    WriteEEPROMBuffer
    632          	t0 = OS_GetTime();
   \   000000A6   ........           CALL    OS__Gettime
   \   000000AA   01C8               MOVW    R25:R24, R17:R16
    633          	do {
    634          		OS_Delay(1);
   \                     ??GetEEPROMData_3:
   \   000000AC   E001               LDI     R16, 1
   \   000000AE   E010               LDI     R17, 0
   \   000000B0   ........           CALL    OS_Delay
    635          	}while ((OS_GetTime() - t0) < (sizeof(float) * 9) && !EEPWriteOK);
   \   000000B4   ........           CALL    OS__Gettime
   \   000000B8   1B08               SUB     R16, R24
   \   000000BA   0B19               SBC     R17, R25
   \   000000BC   3204               CPI     R16, 36
   \   000000BE   4010               SBCI    R17, 0
   \   000000C0   F420               BRCC    ??GetEEPROMData_4
   \   000000C2   9100....           LDS     R16, EEPWriteOK
   \   000000C6   2300               TST     R16
   \   000000C8   F389               BREQ    ??GetEEPROMData_3
    636          }
   \                     ??GetEEPROMData_4:
   \   000000CA   9189               LD      R24, Y+
   \   000000CC   9199               LD      R25, Y+
   \   000000CE   91A9               LD      R26, Y+
   \   000000D0   91B9               LD      R27, Y+
   \   000000D2   9049               LD      R4, Y+
   \   000000D4   9059               LD      R5, Y+
   \   000000D6   9079               LD      R7, Y+
   \   000000D8   9508               RET
    637          
    638          
    639          
    640          /*************************************************************************
    641          *
    642          * Receive AN-ZBHART setup
    643          *
    644          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    645          void GetHartSetup(char ch, unsigned char *pointer) {
   \                     GetHartSetup:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000004   01D9               MOVW    R27:R26, R19:R18
    646          
    647          	TData.Hart.PortUsed = pointer[0] + (pointer[1] << 8);  //Get the setup
   \   00000006   910C               LD      R16, X
   \   00000008   01F9               MOVW    R31:R30, R19:R18
   \   0000000A   8111               LDD     R17, Z+1
   \   0000000C   9300....           STS     (TData + 144), R16
   \   00000010   9310....           STS     (TData + 145), R17
    648          	WriteEEPROMByte(EEPROM_PORTSETUP, pointer[0]);   // store in EEPROM
   \   00000014   8120               LD      R18, Z
   \   00000016   E002               LDI     R16, 2
   \   00000018   E010               LDI     R17, 0
   \   0000001A   ........           CALL    WriteEEPROMByte
    649          	WriteEEPROMByte(EEPROM_PORTSETUP + 1, pointer[1]);
   \   0000001E   01FD               MOVW    R31:R30, R27:R26
   \   00000020   8121               LDD     R18, Z+1
   \   00000022   E003               LDI     R16, 3
   \   00000024   E010               LDI     R17, 0
   \   00000026   ........           CALL    WriteEEPROMByte
    650          #if 0  // blocked by hkim for ZBHART
    651          	SetAnaPort();                           // set the port on or off
    652          #endif
    653          }
   \   0000002A   91A9               LD      R26, Y+
   \   0000002C   91B9               LD      R27, Y+
   \   0000002E   9508               RET
    654          
    655          /*************************************************************************
    656          *
    657          * Receive AN-ZBHART filter
    658          *
    659          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    660          void GetHartFilter(char ch, unsigned char *pointer) {
   \                     GetHartFilter:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    661          	char port;
    662          
    663          	for (port = 0; port < 12; port++) {
   \   00000000   E040               LDI     R20, 0
   \   00000002   E00C               LDI     R16, 12
    664          		TData.Hart.Filter[port] = *pointer++;  //Get the filter
   \                     ??GetHartFilter_0:
   \   00000004   01F9               MOVW    R31:R30, R19:R18
   \   00000006   9111               LD      R17, Z+
   \   00000008   019F               MOVW    R19:R18, R31:R30
   \   0000000A   E0F0               LDI     R31, 0
   \   0000000C   2FE4               MOV     R30, R20
   \   0000000E   ....               SUBI    R30, LOW((-(TData + 146) & 0xFFFF))
   \   00000010   ....               SBCI    R31, HIGH((-(TData + 146) & 0xFFFF))
   \   00000012   8310               ST      Z, R17
    665          	}
   \   00000014   9543               INC     R20
   \   00000016   950A               DEC     R16
   \   00000018   F7A9               BRNE    ??GetHartFilter_0
    666          }
   \   0000001A   9508               RET
    667          
    668          /*************************************************************************
    669          *
    670          * Calculate rx packet checksum (header and package) using Dallas Semiconductor one-wire CRC
    671          *
    672          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    673          short CalcDSRxChecksum(char ch, unsigned short len) {
   \                     CalcDSRxChecksum:
   \   00000000   939A               ST      -Y, R25
   \   00000002   2F58               MOV     R21, R24
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000004   0119               MOVW    R3:R2, R19:R18
    674          
    675          	unsigned short  cnt;
    676          	unsigned char   csum;
    677          
    678          	csum = 0;
   \   00000006   E040               LDI     R20, 0
   \   00000008   E11F               LDI     R17, 31
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   8967               LDD     R22, Z+23
   \   00000016   8D70               LDD     R23, Z+24
   \   00000018   2923               OR      R18, R3
   \   0000001A   F081               BREQ    ??CalcDSRxChecksum_0
   \   0000001C   018B               MOVW    R17:R16, R23:R22
   \   0000001E   2D82               MOV     R24, R2
   \   00000020   2F93               MOV     R25, R19
   \   00000022   ....               LDI     R19, (crc) >> 16
    679          	for (cnt = 0; cnt < len; cnt++) {
    680          		csum = crc[csum ^ UART[ch].pRxBuffer[cnt]];
   \                     ??CalcDSRxChecksum_1:
   \   00000024   01F8               MOVW    R31:R30, R17:R16
   \   00000026   9121               LD      R18, Z+
   \   00000028   018F               MOVW    R17:R16, R31:R30
   \   0000002A   2742               EOR     R20, R18
   \   0000002C   2FE4               MOV     R30, R20
   \   0000002E   E0F0               LDI     R31, 0
   \   00000030   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000032   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000034   BF3B               OUT     0x3B, R19
   \   00000036   9146               ELPM    R20, Z
    681          	}
   \   00000038   9701               SBIW    R25:R24, 1
   \   0000003A   F7A1               BRNE    ??CalcDSRxChecksum_1
    682          	if (csum == UART[ch].pRxBuffer[len]) {
   \                     ??CalcDSRxChecksum_0:
   \   0000003C   0D62               ADD     R22, R2
   \   0000003E   1D73               ADC     R23, R3
   \   00000040   01FB               MOVW    R31:R30, R23:R22
   \   00000042   8100               LD      R16, Z
   \   00000044   1740               CP      R20, R16
   \   00000046   F411               BRNE    ??CalcDSRxChecksum_2
    683          		return true;
   \   00000048   E001               LDI     R16, 1
   \   0000004A   C001               RJMP    ??CalcDSRxChecksum_3
    684          	} else {
    685          		return false;
   \                     ??CalcDSRxChecksum_2:
   \   0000004C   E000               LDI     R16, 0
   \                     ??CalcDSRxChecksum_3:
   \   0000004E   E010               LDI     R17, 0
   \   00000050   2F85               MOV     R24, R21
   \   00000052   9199               LD      R25, Y+
   \   00000054   9508               RET
    686          	}
    687          }
    688          
    689          /*************************************************************************
    690          *
    691          * Goes to sync mode
    692          *
    693          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    694          __monitor void GoToSyncUART(char ch) {
   \                     GoToSyncUART:
   \   00000000   B71F               IN      R17, 0x3F
   \   00000002                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000002   94F8               CLI
    695          
    696          }
   \   00000004   BF1F               OUT     0x3F, R17
   \   00000006   9508               RET
    697          
    698          /*************************************************************************
    699          *
    700          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    701          *
    702          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    703          char CalcDSTxChecksum(UARTDataType *pUART, unsigned short Length) {
   \                     CalcDSTxChecksum:
   \   00000000   2E1B               MOV     R1, R27
   \   00000002   2E2A               MOV     R2, R26
   \   00000004   2F59               MOV     R21, R25
   \   00000006   2E08               MOV     R0, R24
   \   00000008                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000008   01B9               MOVW    R23:R22, R19:R18
    704          	unsigned char csum = 0;
   \   0000000A   E040               LDI     R20, 0
    705          	for (short cnt = 0; cnt < Length; cnt++) {
   \   0000000C   E080               LDI     R24, 0
   \   0000000E   E090               LDI     R25, 0
   \   00000010   ....               LDI     R19, (crc) >> 16
   \   00000012   C00F               RJMP    ??CalcDSTxChecksum_0
    706          		csum = crc[csum ^ pUART->pTxBuffer[cnt+4]];
   \                     ??CalcDSTxChecksum_1:
   \   00000014   01F8               MOVW    R31:R30, R17:R16
   \   00000016   81A0               LD      R26, Z
   \   00000018   81B1               LDD     R27, Z+1
   \   0000001A   0FA8               ADD     R26, R24
   \   0000001C   1FB9               ADC     R27, R25
   \   0000001E   9614               ADIW    R27:R26, 4
   \   00000020   912C               LD      R18, X
   \   00000022   2742               EOR     R20, R18
   \   00000024   2FE4               MOV     R30, R20
   \   00000026   E0F0               LDI     R31, 0
   \   00000028   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000002A   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   0000002C   BF3B               OUT     0x3B, R19
   \   0000002E   9146               ELPM    R20, Z
    707          	}
   \   00000030   9601               ADIW    R25:R24, 1
   \                     ??CalcDSTxChecksum_0:
   \   00000032   1786               CP      R24, R22
   \   00000034   0797               CPC     R25, R23
   \   00000036   F370               BRCS    ??CalcDSTxChecksum_1
    708          	return csum;
   \   00000038   2F04               MOV     R16, R20
   \   0000003A   2D80               MOV     R24, R0
   \   0000003C   2F95               MOV     R25, R21
   \   0000003E   2DA2               MOV     R26, R2
   \   00000040   2DB1               MOV     R27, R1
   \   00000042   9508               RET
    709          }
    710          
    711          

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
     19      2   ANPRO10_IO_Receive
       19      2   -> ANPRO10_UnpackPacket
       19      2   -> MyAddress
       19      2   -> OS_GetMail1
       19      2   -> OS_GetMailTimed
     14      2   ANPRO10_UnpackPacket
       14      2   -> BuildADInt
       14      2   -> BuildEEPROMData
       14      2   -> BuildHartFilter
       14      2   -> BuildHartSetup
       14      2   -> BuildMDataHart
       14      2   -> BuildStackStatus
       14      2   -> BuildStatusData
       14      2   -> EEPROMReset
       14      2   -> GetEEPROMData
       14      2   -> MyAddress
       14      2   -> Uart_BuildTail
       14      2   -> WriteEEPROMByte
      1      2   BuildADInt
      6      2   BuildEEPROMData
        6      2   -> ReadEEPROMBuffer
      1      2   BuildHartFilter
      0      2   BuildHartSetup
     13      2   BuildMDataHart
       13      2   -> hart_channel_lock
       13      2   -> hart_channel_unlock
      4      2   BuildStackStatus
        4      2   -> OS_GetStackSpace
      6      2   BuildStatusData
        6      2   -> MyAddress
      1      2   CalcDSRxChecksum
      0      2   CalcDSTxChecksum
      7      2   GetEEPROMData
        7      2   -> OS_Delay
        7      2   -> OS__Gettime
        7      2   -> WriteEEPROMBuffer
      0      2   GetGotoBootloader
      0      2   GetHartFilter
      2      2   GetHartSetup
        2      2   -> WriteEEPROMByte
      0      2   GetResetEEPROM
        0      2   -> EEPROMReset
      0      2   GoToSyncUART
      0      2   TimoutUSART0
        0      2   -> GoToSyncUART
        0      2   -> OS_StopTimer
      0      2   TimoutUSART0On
        0      2   -> OS_StopTimer
      2      2   Uart_BuildHeader
        2      2   -> MyAddress
      4      2   Uart_BuildTail
        4      2   -> CalcDSTxChecksum
        4      2   -> OS_RetriggerTimer
        4      2   -> Uart_BuildHeader
      0      2   Usart0Handler
        0      2   -> ANPRO10_IO_Receive
      0      2   Usart1Handler
        0      2   -> ANPRO10_IO_Receive


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      14  ?Subroutine0
      10  ?Subroutine1
     540  ANPRO10_IO_Receive
     446  ANPRO10_UnpackPacket
     208  BuildADInt
     250  BuildEEPROMData
     200  BuildHartFilter
     188  BuildHartSetup
     268  BuildMDataHart
     292  BuildStackStatus
     534  BuildStatusData
      86  CalcDSRxChecksum
      68  CalcDSTxChecksum
     218  GetEEPROMData
      38  GetGotoBootloader
      28  GetHartFilter
      48  GetHartSetup
       4  GetResetEEPROM
       8  GoToSyncUART
       2  LastCommand
      36  TimoutUSART0
      18  TimoutUSART0On
      76  Uart_BuildHeader
     282  Uart_BuildTail
       8  Usart0Handler
       8  Usart1Handler
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_UCSR0B
       1  _A_WDTCSR
       7  -- Other

 
     7 bytes in segment ABSOLUTE
 3 876 bytes in segment CODE
     7 bytes in segment INITTAB
     2 bytes in segment NEAR_Z
 
 3 876 bytes of CODE memory (+ 7 bytes shared)
     2 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
