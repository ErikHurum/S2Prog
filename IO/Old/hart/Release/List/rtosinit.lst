###############################################################################
#
# IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR       24/Aug/2022  14:11:45
# Copyright 1996-2021 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\hart\Src\rtosinit.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW5B3A.tmp
#        (D:\S2Prog\IO\hart\Src\rtosinit.c --cpu=m1280 -ms -o
#        D:\S2Prog\IO\hart\Release\Obj -D OS_LIBMODE_S -D OS_UART=-1 -lCN
#        D:\S2Prog\IO\hart\Release\List -y --initializers_in_flash --no_tbaa
#        --enable_external_bus -DENABLE_BIT_DEFINITIONS -e -I
#        D:\S2Prog\IO\hart\INC\\ -I ..\..\..\Shared\Inc\\ --eeprom_size 4096
#        --clib -Oh)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\hart\Release\List\rtosinit.lst
#    Object file  =  D:\S2Prog\IO\hart\Release\Obj\rtosinit.r90
#
###############################################################################

D:\S2Prog\IO\hart\Src\rtosinit.c
      1          /*********************************************************************
      2          *               SEGGER MICROCONTROLLER SYSTEME GmbH                  *
      3          *       Solutions for real time microcontroller applications         *
      4          **********************************************************************
      5          *                                                                    *
      6          *       (C) 2002   SEGGER Microcontroller Systeme GmbH               *
      7          *                                                                    *
      8          *       www.segger.com     Support: support@segger.com               *
      9          *                                                                    *
     10          **********************************************************************
     11          *                                                                    *
     12          *       embOS * Real time operating system for microcontrollers      *
     13          *                                                                    *
     14          **********************************************************************
     15          
     16          ----------------------------------------------------------------------
     17          File    : RTOSInit.c   (for ATMEL AT90)
     18          Purpose : Initializes and handles the hardware for embOS as far
     19                    as required by embOS.
     20                    Feel free to modify this file acc. to your
     21                    target system.
     22          --------  END-OF-HEADER  ---------------------------------------------
     23          */
     24          
     25          #include "RTOS.H"
     26          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0x88
   \   union <unnamed> volatile __io _A_OCR1A
   \                     _A_OCR1A:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x84
   \   union <unnamed> volatile __io _A_TCNT1
   \                     _A_TCNT1:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x81
   \   union <unnamed> volatile __io _A_TCCR1B
   \                     _A_TCCR1B:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x80
   \   union <unnamed> volatile __io _A_TCCR1A
   \                     _A_TCCR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x6f
   \   union <unnamed> volatile __io _A_TIMSK1
   \                     _A_TIMSK1:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x36
   \   union <unnamed> volatile __io _A_TIFR1
   \                     _A_TIFR1:
   \   00000000                      DS8 1
     27          #include "constants.h"
     28          /*
     29          #if (((__TID__ >> 4) & 0x0F) == 1)
     30            #include "IO8535.H"
     31          #elif (((__TID__ >> 4) & 0x0F) == 3)
     32            #include "IOM603.H"
     33          #else
     34            #error "This CPU version (selected by -v) is not supported !"
     35          #endif
     36          */
     37          /*********************************************************************
     38          *
     39          *       Configuration
     40          *
     41          **********************************************************************
     42          */
     43          
     44          //#define OS_FSYS CPU_XTAL    // System frequency [Hz]
     45          
     46          /* Select UART for embOSView.
     47             If you do not want (or can not due to hardware limitations) to dedicate
     48             a UART to embOSView, please define it to be -1
     49             Currently the standard code below supports only UART 1
     50             (But is easily changed to UART 0)
     51          */
     52          #ifndef OS_UART
     53              #define OS_UART 0
     54          #endif
     55          #ifndef OS_BAUDRATE
     56              #define OS_BAUDRATE 19200L
     57          #endif
     58          
     59          /*********************************************************************
     60          *
     61          *       OS_InitHW
     62          *
     63          **********************************************************************
     64          
     65          Initialize the hardware required for the OS to run. This will work
     66          on any target hardware, but may have to be tailored a little
     67          (regarding the clock frequency). Of course the same holds true
     68          if for some reason you choose to use an other timer.
     69          Here we use Timer 1 with Compare match. If other Timer has to be used,
     70          also change the interrupt vector number in OS_ISR_Tick()
     71          */
     72          
     73          

   \                                 In  segment CODE, align 2, keep-with-next
     74          void OS_InitHW(void) {
   \                     OS_InitHW:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
     75            TCCR1A=  (0<<6)       // 0: No output
     76              |(0<<4)             // 0: No output
     77              |(0<<0);            // No PWM
   \   00000000   E000               LDI     R16, 0
   \   00000002   9300....           STS     _A_TCCR1A, R16
     78            TCCR1B=  (1<<7)       // 0: Disable noise canceler
     79              |(0<<6)             // X: Capture edge
     80              |(1<<3)             // 1: Reset on compare match
     81              |(1<<0);            // 1: clock source CK/1
   \   00000006   E809               LDI     R16, 137
   \   00000008   9300....           STS     _A_TCCR1B, R16
     82            OCR1A = (XTAL_CPU/1000)-1;         // generate 1ms interrupts
   \   0000000C   E70F               LDI     R16, 127
   \   0000000E   E31E               LDI     R17, 62
   \   00000010   9310....           STS     (_A_OCR1A + 1), R17
   \   00000014   9300....           STS     _A_OCR1A, R16
     83            TIMSK1 |= (1<<1);      // Output CompareA Match Interrupt Enable
   \   00000018   9100006F           LDS     R16, 111
   \   0000001C   6002               ORI     R16, 0x02
   \   0000001E   9300006F           STS     111, R16
     84            //  SREG  = 0x80 ;        // global interrupt
     85            OS_COM_Init();        // Initialize communication to embOS Viewer
     86          }
   \   00000022   9508               RET
   \   00000024                      REQUIRE _A_TCCR1A
   \   00000024                      REQUIRE _A_TCCR1B
   \   00000024                      REQUIRE _A_OCR1A
   \   00000024                      REQUIRE _A_TIMSK1
     87          
     88          /*********************************************************************
     89          *
     90          *       Idle loop  (OS_Idle)
     91          *
     92          **********************************************************************
     93          
     94           Please note:
     95           This is basically the "core" of the idle loop
     96           This core loop can be changed, but:
     97           The idle loop does not have a stack of its own, therefore no
     98           functionality should be implemented that relies on the stack
     99           to be preserved. However, a simple program loop can be programmed
    100           (like toggeling an output or incrementing a counter)
    101          */
    102          

   \                                 In  segment CODE, align 2, keep-with-next
    103          void OS_Idle(void) {          // Idle loop: No task is ready to exec
   \                     OS_Idle:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    104              for (;;);                   // Nothing to do ... wait for a interrupt
   \                     ??OS_Idle_0:
   \   00000000   CFFF               RJMP    ??OS_Idle_0
    105          }
    106          
    107          /*********************************************************************
    108          *
    109          *       Get time [cycles]
    110          *
    111          **********************************************************************
    112          
    113              This routine is required for task-info via embOS Viewer.
    114              It returns the system time in clock cycles.
    115          */
    116          

   \                                 In  segment CODE, align 2, keep-with-next
    117          static int ReadHWTimer(void) {
   \                     ReadHWTimer:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    118              OS_U16 r = TCNT1L;
   \   00000000   9100....           LDS     R16, _A_TCNT1
    119              asm ("nop");
   \   00000004   0000               nop
    120              return r |(TCNT1H<<8);
   \   00000006   91100085           LDS     R17, 133
   \   0000000A   9508               RET
   \   0000000C                      REQUIRE _A_TCNT1
    121          }
    122          

   \                                 In  segment CODE, align 2, keep-with-next
    123          OS_U32 OS_GetTime_Cycles(void) {
   \                     OS_GetTime_Cycles:
   \   00000000   2E39               MOV     R3, R25
   \   00000002   2FE8               MOV     R30, R24
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
    124              unsigned int t_cnt = ReadHWTimer();
   \   00000004   ....               RCALL   ReadHWTimer
   \   00000006   01C8               MOVW    R25:R24, R17:R16
    125              OS_U32 time = OS_Time;
   \   00000008   9140....           LDS     R20, OS_Time
   \   0000000C   9150....           LDS     R21, (OS_Time + 1)
   \   00000010   9160....           LDS     R22, (OS_Time + 2)
   \   00000014   9170....           LDS     R23, (OS_Time + 3)
    126              //
    127              // Check if timer interrupt pending ...
    128              if (TIFR1&(1<<4)) {
   \   00000018   9BB4               SBIS    0x16, 0x04
   \   0000001A   C006               RJMP    ??OS_GetTime_Cycles_0
    129                  t_cnt = ReadHWTimer();
   \   0000001C   ....               RCALL   ReadHWTimer
   \   0000001E   01C8               MOVW    R25:R24, R17:R16
    130                  time++;
   \   00000020   5F4F               SUBI    R20, 255
   \   00000022   4F5F               SBCI    R21, 255
   \   00000024   4F6F               SBCI    R22, 255
   \   00000026   4F7F               SBCI    R23, 255
    131              }
    132          //  return (XTAL_CPU/1000)*time  + t_cnt;
    133              return(XTAL_CPU/1000)*time  + t_cnt;
   \                     ??OS_GetTime_Cycles_0:
   \   00000028   E800               LDI     R16, 128
   \   0000002A   E31E               LDI     R17, 62
   \   0000002C   2422               CLR     R2
   \   0000002E   9F70               MUL     R23, R16
   \   00000030   2D70               MOV     R23, R0
   \   00000032   9F61               MUL     R22, R17
   \   00000034   0D70               ADD     R23, R0
   \   00000036   9F60               MUL     R22, R16
   \   00000038   2D60               MOV     R22, R0
   \   0000003A   0D71               ADD     R23, R1
   \   0000003C   9F51               MUL     R21, R17
   \   0000003E   0D60               ADD     R22, R0
   \   00000040   1D71               ADC     R23, R1
   \   00000042   9F50               MUL     R21, R16
   \   00000044   2D50               MOV     R21, R0
   \   00000046   0D61               ADD     R22, R1
   \   00000048   1D72               ADC     R23, R2
   \   0000004A   9F41               MUL     R20, R17
   \   0000004C   0D50               ADD     R21, R0
   \   0000004E   1D61               ADC     R22, R1
   \   00000050   1D72               ADC     R23, R2
   \   00000052   9F40               MUL     R20, R16
   \   00000054   0D51               ADD     R21, R1
   \   00000056   1D62               ADC     R22, R2
   \   00000058   1D72               ADC     R23, R2
   \   0000005A   0E08               ADD     R0, R24
   \   0000005C   1F59               ADC     R21, R25
   \   0000005E   1D62               ADC     R22, R2
   \   00000060   1D72               ADC     R23, R2
   \   00000062   2D00               MOV     R16, R0
   \   00000064   2F15               MOV     R17, R21
   \   00000066   019B               MOVW    R19:R18, R23:R22
   \   00000068   2F8E               MOV     R24, R30
   \   0000006A   2D93               MOV     R25, R3
   \   0000006C   9508               RET
   \   0000006E                      REQUIRE _A_TIFR1
    134          }
    135          
    136          /*********************************************************************
    137          *
    138          *       OS_ConvertCycles2us
    139          *
    140          **********************************************************************
    141          
    142          Purpose:
    143             Convert Cycles into micro seconds. (For profiling only)
    144          
    145             If you have a clock frequency which is not a multiple of 1 MHz,
    146             you may have to modify this routine in order to get proper
    147             diagonstics.
    148          Please note:
    149             This routine is required for profiling only.
    150             It does not affect operation of the OS.
    151          */
    152          

   \                                 In  segment CODE, align 2, keep-with-next
    153          OS_U32 OS_ConvertCycles2us(OS_U32 Cycles) {
   \                     OS_ConvertCycles2us:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    154              return Cycles/(XTAL_CPU/1000000);
   \   00000000   9536               LSR     R19
   \   00000002   9527               ROR     R18
   \   00000004   9517               ROR     R17
   \   00000006   9507               ROR     R16
   \   00000008   9536               LSR     R19
   \   0000000A   9527               ROR     R18
   \   0000000C   9517               ROR     R17
   \   0000000E   9507               ROR     R16
   \   00000010   9536               LSR     R19
   \   00000012   9527               ROR     R18
   \   00000014   9517               ROR     R17
   \   00000016   9507               ROR     R16
   \   00000018   9536               LSR     R19
   \   0000001A   9527               ROR     R18
   \   0000001C   9517               ROR     R17
   \   0000001E   9507               ROR     R16
   \   00000020   9508               RET
    155          }
    156          
    157          /*********************************************************************
    158          *
    159          *       OS_Tick interrupt
    160          *
    161          **********************************************************************
    162          */
    163          
    164          #pragma vector = TIMER1_COMPA_vect

   \                                 In  segment CODE, align 2, keep-with-next
    165          __interrupt void OS_ISR_Tick (void) 
   \                     OS_ISR_Tick:
    166          { 
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
   \   00000024                      REQUIRE __RSTACK_in_external_ram_new_way
    167            OS_TickHandler();
   \   00000024   ........           CALL    OS_TickHandler
    168          }
   \   00000028   BF9B               OUT     0x3B, R25
   \   0000002A   BF8F               OUT     0x3F, R24
   \   0000002C   9109               LD      R16, Y+
   \   0000002E   9119               LD      R17, Y+
   \   00000030   9129               LD      R18, Y+
   \   00000032   9139               LD      R19, Y+
   \   00000034   9149               LD      R20, Y+
   \   00000036   9159               LD      R21, Y+
   \   00000038   9169               LD      R22, Y+
   \   0000003A   9179               LD      R23, Y+
   \   0000003C   9009               LD      R0, Y+
   \   0000003E   9019               LD      R1, Y+
   \   00000040   9029               LD      R2, Y+
   \   00000042   9039               LD      R3, Y+
   \   00000044   91E9               LD      R30, Y+
   \   00000046   91F9               LD      R31, Y+
   \   00000048   9189               LD      R24, Y+
   \   0000004A   9199               LD      R25, Y+
   \   0000004C   9518               RETI
    169          
    170          /*********************************************************************
    171          *
    172          *       Communication for embOSView (UART 0)
    173          *
    174          **********************************************************************
    175          */
    176          
    177          #if (OS_UART == 0)
    178          
    179          void OS_COM_Init(void) {
    180            UBRR0L  = ((XTAL_CPU / 16 / OS_BAUDRATE )-1) & 0xff;
    181            UBRR0H  = (((XTAL_CPU / 16 / OS_BAUDRATE )-1)>> 8) & 0xff;
    182            UCSR0C  = 0x06;       /* n,8,1 */
    183            UCSR0A  = 0x00;
    184            UCSR0B =  (0<<0)      // X
    185              |(0<<1)      // X
    186              |(0<<2)      // CHR9: 9-bit Characters
    187              |(1<<3)      // TXEN: Transmitter Enable
    188              |(1<<4)      // RXEN: Receiver Enable
    189              |(0<<5)      // UDRIE: UART Data Register Empty Interrupt Enable
    190              |(0<<6)      // TXCIE Tx complete interrupt enable
    191              |(0<<7);     // RXCIE Rx complete interrupt enable
    192            UCSR0B =  (0<<0)      // X
    193              |(0<<1)      // X
    194              |(0<<2)      // CHR9: 9-bit Characters
    195              |(1<<3)      // TXEN: Transmitter Enable
    196              |(1<<4)      // RXEN: Receiver Enable
    197              |(0<<5)      // UDRIE: UART Data Register Empty Interrupt Enable
    198              |(1<<6)      // TXCIE Tx complete interrupt enable
    199              |(1<<7);     // RXCIE Rx complete interrupt enable
    200          }
    201          
    202          void OS_COM_Send1(unsigned char c) {
    203              UDR0 = c;
    204              UCSR0B |=  (1<<6);      // Generate interrupt on transmit buffer emtpy
    205          }
    206          
    207              #pragma vector = USART0_RXC_vect
    208          __interrupt void ISR_uart0_rx (void) {
    209              UCSR0B &=  ~(1<<7);     // Avoid nesting itself !!!
    210              OS_EnterNestableInterrupt();
    211              OS_OnRx(UDR0);
    212              OS_DI();             // Disable before allowing Rx interrupt
    213              UCSR0B |=  (1<<7);
    214              OS_LeaveNestableInterrupt();
    215          }
    216          
    217              #pragma vector = USART0_TXC_vect
    218          __interrupt void ISR_uart0_tx (void) {/*USART0_TXC_vect*/
    219              OS_EnterNestableInterrupt();
    220              if (OS_OnTx()) {
    221                  UCSR0B &=  ~(1<<6);   // Do not generate any more interrupts
    222              }
    223              OS_LeaveNestableInterrupt();
    224          }
    225          
    226          #else  /* No communication routines, just dummies  */

   \                                 In  segment CODE, align 2, keep-with-next
    227          void OS_COM_Init(void) {}
   \                     OS_COM_Init:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
   \   00000000   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    228          void OS_COM_Send1(OS_U8 c) {
   \                     OS_COM_Send1:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    229              OS_COM_ClearTxActive();    /* let OS know that transmitter is not busy */
   \   00000000   ........           JMP     OS_COM_ClearTxActive
    230              OS_USEPARA(c);             /* Avoid compiler warning */
    231          }

   \                                 In  segment INTVEC, offset 0x44, root
   \                     `??OS_ISR_Tick::??INTVEC 68`:
   \   00000044   ........           JMP     OS_ISR_Tick
    232          #endif /* defined (OS_UART) */
    233          
    234          /*****  EOF  ********************************************************/
    235          
    236          

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   OS_COM_Init
      0      2   OS_COM_Send1
        0      2   -> OS_COM_ClearTxActive
      0      2   OS_ConvertCycles2us
      0      2   OS_GetTime_Cycles
        0      2   -> ReadHWTimer
     16      2   OS_ISR_Tick
       16      2   -> OS_TickHandler
      0      2   OS_Idle
      0      2   OS_InitHW
      0      2   ReadHWTimer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  OS_COM_Init
       4  OS_COM_Send1
      34  OS_ConvertCycles2us
     110  OS_GetTime_Cycles
      78  OS_ISR_Tick
       4  OS_ISR_Tick::??INTVEC 68
       2  OS_Idle
      36  OS_InitHW
      12  ReadHWTimer
       2  _A_OCR1A
       1  _A_TCCR1A
       1  _A_TCCR1B
       2  _A_TCNT1
       1  _A_TIFR1
       1  _A_TIMSK1

 
   8 bytes in segment ABSOLUTE
 278 bytes in segment CODE
   4 bytes in segment INTVEC
 
 278 bytes of CODE memory (+ 4 bytes shared)
   0 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: none
