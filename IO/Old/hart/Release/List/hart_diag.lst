###############################################################################
#
# IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR       24/Aug/2022  14:11:44
# Copyright 1996-2021 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\hart\Src\hart_diag.c
#    Command line =  
#        -f C:\Users\ESY\AppData\Local\Temp\EW5094.tmp
#        (D:\S2Prog\IO\hart\Src\hart_diag.c --cpu=m1280 -ms -o
#        D:\S2Prog\IO\hart\Release\Obj -D OS_LIBMODE_S -D OS_UART=-1 -lCN
#        D:\S2Prog\IO\hart\Release\List -y --initializers_in_flash --no_tbaa
#        --enable_external_bus -DENABLE_BIT_DEFINITIONS -e -I
#        D:\S2Prog\IO\hart\INC\\ -I ..\..\..\Shared\Inc\\ --eeprom_size 4096
#        --clib -Oh)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\hart\Release\List\hart_diag.lst
#    Object file  =  D:\S2Prog\IO\hart\Release\Obj\hart_diag.r90
#
###############################################################################

D:\S2Prog\IO\hart\Src\hart_diag.c
      1          #include "iom1280.h"

   \                                 In  segment ABSOLUTE, at 0x10b
   \   union <unnamed> volatile __ext_io _A_PORTL
   \                     _A_PORTL:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x109
   \   union <unnamed> volatile __ext_io _A_PINL
   \                     _A_PINL:
   \   00000000                      DS8 1
      2          #include "version.h"
      3          #include "inavr.h"
      4          #include "RTOS.h"
      5          
      6          #include "constants.h"
      7          
      8          #include "hart_common.h"
      9          #include "hart.h"
     10          #include "hart_diag.h"
     11          #include "hart_gpio.h"
     12          #include "structs.h"
     13          #include "externals.h"
     14          /////////////////////////////////////////////////////////////////////////////////////
     15          //
     16          // AD7715 summary.
     17          // * some people are stupid enough not to write this down in the code. So I do.
     18          //   -hkim-
     19          //
     20          //
     21          // a. setup communication register
     22          //
     23          // 7        6       5       4       3       2       1       0
     24          // must     must    rs1     rs0     r/w     sdby    g1      g0
     25          // be 0     be 0                    r=1     1 =
     26          //                                  w=0     p down  gain setup
     27          //
     28          // rs1    rs0
     29          // ============
     30          // 0      0       comm reg        8  bit
     31          // 0      1       setup reg       8  bit
     32          // 1      0       test reg        8  bit
     33          // 1      1       data reg        16 bit
     34          //
     35          // g1     g0
     36          // ============
     37          //  0     0       x1
     38          //  0     1       x2
     39          //  1     0       x32
     40          //  1     1       x128
     41          //
     42          // b. setup register (rs1,rs0= 0,1
     43          //
     44          // 7        6       5       4       3       2       1       0
     45          // MD1      MD0     CLK     FS1     FS0     B/U     BUF     FSYNC
     46          // mode selection   opr     output rate     bi/uni  buf     filter
     47          //                  freq                    polar   control sync
     48          //
     49          // CLK should be set to 0 with 1 Mhz clock
     50          //
     51          // MD1    MD0
     52          // ============
     53          // 0      0       normal mode
     54          // 0      1       self calib
     55          // 1      0       zero scale calib
     56          // 1      1       full scale calib
     57          //
     58          // CLK      FS1     FS0
     59          // ================================
     60          // 0        0       0           20 Hz
     61          // 0        0       1           25 Hz
     62          // 0        1       0           100 Hz
     63          // 0        1       1           200 Hz
     64          // 1        0       0           50 Hz
     65          // 1        0       1           60 Hz
     66          // 1        1       0           250 Hz
     67          // 1        1       1           5600 Hz
     68          //
     69          // B/U : 0 bipolar, 1 unipolar
     70          //
     71          // c. test register (rs1,rs0 = 1,0
     72          // just don't use it. chip maker doesn't want you to fuck up with this.
     73          //
     74          // d. data register (rs1,rs0 = 1,1)
     75          //
     76          /////////////////////////////////////////////////////////////////////////////////////
     77          
     78          ////////////////////////////////////////////////////////////////////////////////
     79          //
     80          // private defines
     81          //
     82          ////////////////////////////////////////////////////////////////////////////////
     83          #define HART_DIAG_CONVERSION_COMPLETE         0x01
     84          
     85          ////////////////////////////////////////////////////////////////////////////////
     86          //
     87          // private prototypes
     88          //
     89          ////////////////////////////////////////////////////////////////////////////////
     90          
     91          ////////////////////////////////////////////////////////////////////////////////
     92          //
     93          // hart module privates
     94          //
     95          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     96          static OS_STACKPTR int    _hart_diag_task_stack[60];
   \                     _hart_diag_task_stack:
   \   00000000                      DS8 120

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     97          static OS_TASK            _hart_diag_task;
   \                     _hart_diag_task:
   \   00000000                      DS8 21

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     98          static uint16_t           _num_adc_fuckups = 0;
   \                     _num_adc_fuckups:
   \   00000000                      DS8 2
     99          
    100          ////////////////////////////////////////////////////////////////////////////////
    101          //
    102          // AD7715 related utilities
    103          //
    104          ////////////////////////////////////////////////////////////////////////////////
    105          static void
    106          ad7715_toggle_debug_led(void) {

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
    107          	static uint8_t    on_off = 1;
   \                     ??on_off:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for on_off>`
    108          
    109          	hart_gpio_debug_led(on_off);
    110          	on_off = !on_off;
    111          }
    112          

   \                                 In  segment CODE, align 2, keep-with-next
    113          static uint8_t
    114          ad7715_read_byte(void) {
   \                     ad7715_read_byte:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    115          	uint8_t i, readbyte;
    116          
    117          	readbyte = 0;
   \   00000000   E000               LDI     R16, 0
    118          
    119          	for (i = 0; i <  8; i++) {
   \   00000002   E018               LDI     R17, 8
    120          		readbyte <<= 1;                      // shift to next bit
   \                     ??ad7715_read_byte_0:
   \   00000004   0F00               LSL     R16
    121          		AD7715_CLK_LO();
   \   00000006   9120010B           LDS     R18, 267
   \   0000000A   7F2E               ANDI    R18, 0xFE
   \   0000000C   9320010B           STS     267, R18
    122          		AD7715_CLK_HI();
   \   00000010   9120010B           LDS     R18, 267
   \   00000014   6021               ORI     R18, 0x01
   \   00000016   9320010B           STS     267, R18
    123          
    124          		if (AD7715_MISO_READ()) {
   \   0000001A   9120....           LDS     R18, _A_PINL
   \   0000001E   FD21               SBRC    R18, 1
    125          			// data high
    126          			readbyte |= 0x01;                   // set bit high
   \   00000020   6001               ORI     R16, 0x01
    127          		}
    128          	}
   \                     ??ad7715_read_byte_1:
   \   00000022   951A               DEC     R17
   \   00000024   F779               BRNE    ??ad7715_read_byte_0
    129          	return readbyte;
   \   00000026   9508               RET
   \   00000028                      REQUIRE _A_PORTL
   \   00000028                      REQUIRE _A_PINL
    130          }
    131          

   \                                 In  segment CODE, align 2, keep-with-next
    132          static void
    133          ad7715_write_byte(uint8_t data) {
   \                     ad7715_write_byte:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    134          	uint8_t i;
    135          
    136          	for (i = 0; i <  8; i++) {
   \   00000000   E018               LDI     R17, 8
    137          		AD7715_CLK_LO();
   \                     ??ad7715_write_byte_0:
   \   00000002   9120010B           LDS     R18, 267
   \   00000006   7F2E               ANDI    R18, 0xFE
   \   00000008   9320010B           STS     267, R18
    138          
    139          		if (data & 0x80) {                        // data bit = 1?
   \   0000000C   FB07               BST     R16, 7
   \   0000000E   9120010B           LDS     R18, 267
   \   00000012   F416               BRTC    ??ad7715_write_byte_1
    140          			AD7715_MOSI_HI();
   \   00000014   6024               ORI     R18, 0x04
   \   00000016   C001               RJMP    ??ad7715_write_byte_2
    141          		} else {
    142          			AD7715_MOSI_LO();
   \                     ??ad7715_write_byte_1:
   \   00000018   7F2B               ANDI    R18, 0xFB
   \                     ??ad7715_write_byte_2:
   \   0000001A   9320010B           STS     267, R18
    143          		}
    144          		data <<= 1;                              // shift to next bit
   \   0000001E   0F00               LSL     R16
    145          
    146          		AD7715_CLK_HI();
   \   00000020   9120010B           LDS     R18, 267
   \   00000024   6021               ORI     R18, 0x01
   \   00000026   9320010B           STS     267, R18
    147          	}
   \   0000002A   951A               DEC     R17
   \   0000002C   F751               BRNE    ??ad7715_write_byte_0
    148          }
   \   0000002E   9508               RET
   \   00000030                      REQUIRE _A_PORTL
    149          

   \                                 In  segment CODE, align 2, keep-with-next
    150          static void
    151          ad7715_hard_reset(void) {
   \                     ad7715_hard_reset:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    152          	hart_gpio_adc_reset(1);     // high
   \   00000000   E001               LDI     R16, 1
   \   00000002   ........           CALL    hart_gpio_adc_reset
    153          	OS_Delay(100);
   \   00000006   E604               LDI     R16, 100
   \   00000008   E010               LDI     R17, 0
   \   0000000A   ........           CALL    OS_Delay
    154          	hart_gpio_adc_reset(0);     // low
   \   0000000E   E000               LDI     R16, 0
   \   00000010   ........           CALL    hart_gpio_adc_reset
    155          	OS_Delay(500);
   \   00000014   EF04               LDI     R16, 244
   \   00000016   E011               LDI     R17, 1
   \   00000018   ........           CALL    OS_Delay
    156          	hart_gpio_adc_reset(1);     // high
   \   0000001C   E001               LDI     R16, 1
   \   0000001E   ........           CALL    hart_gpio_adc_reset
    157          	OS_Delay(100);
   \   00000022   E604               LDI     R16, 100
   \   00000024   E010               LDI     R17, 0
   \   00000026   ........           JMP     OS_Delay
    158          }
    159          
    160          static void
    161          ad7715_put_on_hold(void) {
    162          	// select setup reg
    163          	ad7715_write_byte(0x10);
    164          
    165          	// set fsync to put ADC on hold
    166          	ad7715_write_byte(0x0f);
    167          }
    168          
    169          static void
    170          ad7715_start_next_sample(void) {
    171          	// select setup reg
    172          	ad7715_write_byte(0x10);
    173          
    174          	// clear fsync bit to start conversion
    175          	ad7715_write_byte(0x0e);
    176          
    177          	//
    178          	// sample will be available after 3x1/output rate, which is 3x1/25 = 120ms.
    179          	// code will be notified by /DRDY
    180          	//
    181          }
    182          

   \                                 In  segment CODE, align 2, keep-with-next
    183          static uint16_t
    184          ad7715_read_sample(void) {
   \                     ad7715_read_sample:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    185          	uint8_t   lo, hi;
    186          	uint16_t  ret;
    187          
    188          	// select data reg
    189          	ad7715_write_byte(0x38);
   \   00000000   E308               LDI     R16, 56
   \   00000002   ....               RCALL   ad7715_write_byte
    190          
    191          	hi = ad7715_read_byte();
   \   00000004   ....               RCALL   ad7715_read_byte
    192          	lo = ad7715_read_byte();
    193          
    194          	ret = (uint16_t)(hi << 8 | lo);
    195          
    196          	return ret;
   \   00000006   2F50               MOV     R21, R16
   \   00000008   ....               RCALL   ad7715_read_byte
   \   0000000A   2F15               MOV     R17, R21
   \   0000000C   9508               RET
    197          }
    198          

   \                                 In  segment CODE, align 2, keep-with-next
    199          static uint8_t
    200          ad7715_wait_for_drdy(void) {
   \                     ad7715_wait_for_drdy:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    201          	if (OS_WaitEventTimed(HART_DIAG_CONVERSION_COMPLETE, 1000) == 0) {
   \   00000000   EE28               LDI     R18, 232
   \   00000002   E033               LDI     R19, 3
   \   00000004   E001               LDI     R16, 1
   \   00000006   ........           CALL    OS_WaitEventTimed
   \   0000000A   2300               TST     R16
   \   0000000C   F461               BRNE    ??ad7715_wait_for_drdy_0
    202          		_num_adc_fuckups++;
   \   0000000E   9100....           LDS     R16, _num_adc_fuckups
   \   00000012   9110....           LDS     R17, (_num_adc_fuckups + 1)
   \   00000016   5F0F               SUBI    R16, 255
   \   00000018   4F1F               SBCI    R17, 255
   \   0000001A   9300....           STS     _num_adc_fuckups, R16
   \   0000001E   9310....           STS     (_num_adc_fuckups + 1), R17
    203          		return 1;
   \   00000022   E001               LDI     R16, 1
   \   00000024   9508               RET
    204          	}
    205          
    206          	// ok
    207          	return 0;
   \                     ??ad7715_wait_for_drdy_0:
   \   00000026   E000               LDI     R16, 0
   \   00000028   9508               RET
    208          }
    209          

   \                                 In  segment CODE, align 2, keep-with-next
    210          static void
    211          ad7715_do_calibration(void) {
   \                     ad7715_do_calibration:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    212          	//
    213          	// set current channel to 2.5V reference
    214          	//
    215          	hart_gpio_adc_channel_select((hart_channel_t)14);
   \   00000000   E00E               LDI     R16, 14
   \   00000002   ........           CALL    hart_gpio_adc_channel_select
    216          
    217          	//
    218          	// select setup reg (0,1)
    219          	// 7        6         5         4         3         2         1         0
    220          	// 0        0         0         1         0         0         0         0
    221          	//                    setup reg           write     no        gain x1
    222          	//                                                  stby
    223          	ad7715_write_byte(0x10);
   \   00000006   E100               LDI     R16, 16
   \   00000008   ....               RCALL   ad7715_write_byte
    224          
    225          	//
    226          	// setup reg to perform calib
    227          	//
    228          	// 7        6         5         4         3         2         1         0
    229          	// 0        1         0         0         1         1         1         0
    230          	// seld calib         1 Mhz     25 Hz Rate          Unipolar  buffed    no fsync
    231          	// mode               clk
    232          	//
    233          	ad7715_write_byte(0x4e);
   \   0000000A   E40E               LDI     R16, 78
   \   0000000C   ....               RCALL   ad7715_write_byte
    234          
    235          	//
    236          	// calibration will be complete after 6 x 1/outpur rate
    237          	// which is 6 * 1/25 = roughly 240ms and /DRDY will be asserted.
    238          	//
    239          	(void)ad7715_wait_for_drdy();
   \   0000000E   EE28               LDI     R18, 232
   \   00000010   E033               LDI     R19, 3
   \   00000012   E001               LDI     R16, 1
   \   00000014   ........           CALL    OS_WaitEventTimed
   \   00000018   2300               TST     R16
   \   0000001A   F451               BRNE    ??ad7715_do_calibration_0
   \   0000001C   9100....           LDS     R16, _num_adc_fuckups
   \   00000020   9110....           LDS     R17, (_num_adc_fuckups + 1)
   \   00000024   5F0F               SUBI    R16, 255
   \   00000026   4F1F               SBCI    R17, 255
   \   00000028   9300....           STS     _num_adc_fuckups, R16
   \   0000002C   9310....           STS     (_num_adc_fuckups + 1), R17
    240          
    241          	//
    242          	// read dummy sample. /DRDY will go hi again after this
    243          	//
    244          	(void)ad7715_read_sample();
   \                     ??ad7715_do_calibration_0:
   \   00000030   ....               RCALL   ad7715_read_sample
    245          
    246          	ad7715_put_on_hold();
   \   00000032   E100               LDI     R16, 16
   \   00000034   ....               RCALL   ad7715_write_byte
   \   00000036   E00F               LDI     R16, 15
   \   00000038   ....               RCALL   ad7715_write_byte
    247          
    248          	// back to 0
    249          	hart_gpio_adc_channel_select(hart_channel_0);
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   ........           JMP     hart_gpio_adc_channel_select
    250          }
    251          
    252          
    253          ////////////////////////////////////////////////////////////////////////////////
    254          //
    255          // ADC interrupt handler
    256          //
    257          ////////////////////////////////////////////////////////////////////////////////
    258          #pragma vector=INT0_vect

   \                                 In  segment CODE, align 2, keep-with-next
    259          __interrupt void IntHandler_INT0(void) {
   \                     IntHandler_INT0:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
   \   00000024                      REQUIRE __RSTACK_in_external_ram_new_way
    260          	OS_EnterInterrupt();
   \   00000024   9100....           LDS     R16, OS_Counters
   \   00000028   9503               INC     R16
   \   0000002A   9300....           STS     OS_Counters, R16
   \   0000002E   9100....           LDS     R16, (OS_Counters + 1)
   \   00000032   9503               INC     R16
   \   00000034   9300....           STS     (OS_Counters + 1), R16
    261          	OS_EnterIntStack();
   \   00000038   94F8               CLI
   \   0000003A   ........           CALL    OS__EnterIntStack
   \   0000003E   9100....           LDS     R16, (OS_Counters + 1)
   \   00000042   2300               TST     R16
   \   00000044   F409               BRNE    ??IntHandler_INT0_0
   \   00000046   9478               SEI
    262          
    263          	OS_SignalEvent(HART_DIAG_CONVERSION_COMPLETE, &_hart_diag_task);
   \                     ??IntHandler_INT0_0:
   \   00000048   ....               LDI     R18, LOW(_hart_diag_task)
   \   0000004A   ....               LDI     R19, (_hart_diag_task) >> 8
   \   0000004C   E001               LDI     R16, 1
   \   0000004E   ........           CALL    OS_SignalEvent
    264          
    265          	OS_LeaveIntStack();
   \   00000052   94F8               CLI
   \   00000054   ........           CALL    OS__LeaveIntStack
    266          	OS_LeaveInterruptNoSwitch();
   \   00000058   9100....           LDS     R16, (OS_Counters + 1)
   \   0000005C   950A               DEC     R16
   \   0000005E   9300....           STS     (OS_Counters + 1), R16
   \   00000062   9100....           LDS     R16, OS_Counters
   \   00000066   950A               DEC     R16
   \   00000068   9300....           STS     OS_Counters, R16
    267          }
   \   0000006C   BF9B               OUT     0x3B, R25
   \   0000006E   BF8F               OUT     0x3F, R24
   \   00000070   9109               LD      R16, Y+
   \   00000072   9119               LD      R17, Y+
   \   00000074   9129               LD      R18, Y+
   \   00000076   9139               LD      R19, Y+
   \   00000078   9149               LD      R20, Y+
   \   0000007A   9159               LD      R21, Y+
   \   0000007C   9169               LD      R22, Y+
   \   0000007E   9179               LD      R23, Y+
   \   00000080   9009               LD      R0, Y+
   \   00000082   9019               LD      R1, Y+
   \   00000084   9029               LD      R2, Y+
   \   00000086   9039               LD      R3, Y+
   \   00000088   91E9               LD      R30, Y+
   \   0000008A   91F9               LD      R31, Y+
   \   0000008C   9189               LD      R24, Y+
   \   0000008E   9199               LD      R25, Y+
   \   00000090   9518               RETI
    268          
    269          ////////////////////////////////////////////////////////////////////////////////
    270          //
    271          // private utilities
    272          //
    273          ////////////////////////////////////////////////////////////////////////////////
    274          static void
    275          hart_diag_configure_adc(void) {
    276          	ad7715_hard_reset();
    277          	ad7715_do_calibration();
    278          }
    279          
    280          ////////////////////////////////////////////////////////////////////////////////
    281          //
    282          // ADC raw to mA
    283          //
    284          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    285          static void
    286          hart_diag_set_diag_value(hart_channel_t chnl, uint16_t raw_adc) {
   \                     hart_diag_set_diag_value:
   \   00000000   924A               ST      -Y, R4
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000A                      REQUIRE __RSTACK_in_external_ram_new_way
   \   0000000A   2E40               MOV     R4, R16
    287          	// the H/W circuit is created using INA138 current shunt and 5 ohm resistor.
    288          	//
    289          	// The input current is between 0 and 20mA. So voltage drop across the 5 Ohm
    290          	// resistor will be between 0 and 0.1V. This voltage difference is fed into
    291          	// INA138 and with 100K RL resistor, the voltage is amplied by 20 times.
    292          	//
    293          	// So the measured voltage to the ADC is in the range of 0V and 2V, where
    294          	// 0V corresponds to 0mA and 2V corresponds to 20mA.
    295          	//
    296          	// Additionally ADC ref voltage is 2.5V, which means 0xffff corresponds 2.5V
    297          	//
    298          	// hkim is kind enough to analyze this freaking circuit himself and leave a
    299          	// record here. Appreciate him.
    300          	//
    301          	// -hkim-
    302          	//
    303          	float       voltage = 2.5f * ((float)(raw_adc)) / 65535.0;
    304          	float       current = voltage / 10.0 * 100.0;
    305          	current /= 1.0028280;
   \   0000000C   0189               MOVW    R17:R16, R19:R18
   \   0000000E   E020               LDI     R18, 0
   \   00000010   E030               LDI     R19, 0
   \   00000012   ........           CALL    ?UL2F_S_L04
   \   00000016   E040               LDI     R20, 0
   \   00000018   E050               LDI     R21, 0
   \   0000001A   E260               LDI     R22, 32
   \   0000001C   E470               LDI     R23, 64
   \   0000001E   ........           CALL    ?F_MUL_S_L04
   \   00000022   E040               LDI     R20, 0
   \   00000024   EF5F               LDI     R21, 255
   \   00000026   E76F               LDI     R22, 127
   \   00000028   E477               LDI     R23, 71
   \   0000002A   ........           CALL    ?F_DIV_S_L04
   \   0000002E   E040               LDI     R20, 0
   \   00000030   E050               LDI     R21, 0
   \   00000032   E260               LDI     R22, 32
   \   00000034   E471               LDI     R23, 65
   \   00000036   ........           CALL    ?F_DIV_S_L04
   \   0000003A   E040               LDI     R20, 0
   \   0000003C   E050               LDI     R21, 0
   \   0000003E   EC68               LDI     R22, 200
   \   00000040   E472               LDI     R23, 66
   \   00000042   ........           CALL    ?F_MUL_S_L04
   \   00000046   EA4B               LDI     R20, 171
   \   00000048   E55C               LDI     R21, 92
   \   0000004A   E860               LDI     R22, 128
   \   0000004C   E37F               LDI     R23, 63
   \   0000004E   ........           CALL    ?F_DIV_S_L04
   \   00000052   01C8               MOVW    R25:R24, R17:R16
   \   00000054   01D9               MOVW    R27:R26, R19:R18
    306          	// EHSMarkuint16_t    current_final = (uint16_t)(current * 10);       // 10 = 1mA, 1 = 0.1mA
    307          
    308          	if (chnl <= hart_channel_11) {
   \   00000056   E00C               LDI     R16, 12
   \   00000058   1640               CP      R4, R16
   \   0000005A   F498               BRCC    ??hart_diag_set_diag_value_0
    309          		HartChannel *hchannel = hart_channel_get_with_lock(chnl);
   \   0000005C   2D04               MOV     R16, R4
   \   0000005E   ........           CALL    hart_channel_get_with_lock
    310          
    311          		hchannel->MsrdCurrent = current;  //current_final with correction;
   \   00000062   01F8               MOVW    R31:R30, R17:R16
   \   00000064   8383               STD     Z+3, R24
   \   00000066   8394               STD     Z+4, R25
   \   00000068   83A5               STD     Z+5, R26
   \   0000006A   83B6               STD     Z+6, R27
    312          
    313          		// Always update the mA from the ADC for diagnostics purpose
    314          		TData.Hart.ADCurrent[chnl] = current;               // PROData 0 is the Hart PV(Primary Value)
   \   0000006C   E024               LDI     R18, 4
   \   0000006E   9E42               MUL     R4, R18
   \   00000070   01F0               MOVW    R31:R30, R1:R0
   \   00000072   ....               SUBI    R30, LOW((-(TData + 158) & 0xFFFF))
   \   00000074   ....               SBCI    R31, HIGH((-(TData + 158) & 0xFFFF))
   \   00000076   8380               ST      Z, R24
   \   00000078   8391               STD     Z+1, R25
   \   0000007A   83A2               STD     Z+2, R26
   \   0000007C   83B3               STD     Z+3, R27
    315          		hart_channel_put_with_unlock(hchannel);
   \   0000007E   ........           CALL    hart_channel_put_with_unlock
    316          	}
    317          }
   \                     ??hart_diag_set_diag_value_0:
   \   00000082   9189               LD      R24, Y+
   \   00000084   9199               LD      R25, Y+
   \   00000086   91A9               LD      R26, Y+
   \   00000088   91B9               LD      R27, Y+
   \   0000008A   9049               LD      R4, Y+
   \   0000008C   9508               RET
    318          
    319          ////////////////////////////////////////////////////////////////////////////////
    320          //
    321          // HART Diagnostic Task
    322          //
    323          ////////////////////////////////////////////////////////////////////////////////
    324          static void
    325          ad7715_read_diag_adc(hart_channel_t chnl) {
    326          
    327          	hart_gpio_adc_channel_select(chnl);
    328          	ad7715_start_next_sample();
    329          	ad7715_wait_for_drdy();
    330          	uint16_t raw_adc = ad7715_read_sample();
    331          	ad7715_put_on_hold();
    332          
    333          	hart_diag_set_diag_value(chnl, raw_adc);
    334          }
    335          

   \                                 In  segment CODE, align 2, keep-with-next
    336          static void
    337          HARTDiag_Task(void) {
   \                     HARTDiag_Task:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004                      REQUIRE __RSTACK_in_external_ram_new_way
    338          	hart_channel_t      current;
    339          
    340          	hart_diag_configure_adc();
   \   00000004   ....               RCALL   ad7715_hard_reset
   \   00000006   ....               RCALL   ad7715_do_calibration
    341          
    342          	while (1) {
    343          		hart_for_each_channel(current) {
   \                     ??HARTDiag_Task_0:
   \   00000008   E090               LDI     R25, 0
   \   0000000A   E08C               LDI     R24, 12
    344          			ad7715_read_diag_adc(current);
   \                     ??HARTDiag_Task_1:
   \   0000000C   2F09               MOV     R16, R25
   \   0000000E   ........           CALL    hart_gpio_adc_channel_select
   \   00000012   E100               LDI     R16, 16
   \   00000014   ....               RCALL   ad7715_write_byte
   \   00000016   E00E               LDI     R16, 14
   \   00000018   ....               RCALL   ad7715_write_byte
   \   0000001A   ....               RCALL   ad7715_wait_for_drdy
   \   0000001C   ....               RCALL   ad7715_read_sample
   \   0000001E   01A8               MOVW    R21:R20, R17:R16
   \   00000020   E100               LDI     R16, 16
   \   00000022   ....               RCALL   ad7715_write_byte
   \   00000024   E00F               LDI     R16, 15
   \   00000026   ....               RCALL   ad7715_write_byte
   \   00000028   019A               MOVW    R19:R18, R21:R20
   \   0000002A   2F09               MOV     R16, R25
   \   0000002C   ....               RCALL   hart_diag_set_diag_value
    345          			ad7715_toggle_debug_led();
   \   0000002E   9100....           LDS     R16, ??on_off
   \   00000032   ........           CALL    hart_gpio_debug_led
   \   00000036   9100....           LDS     R16, ??on_off
   \   0000003A   2300               TST     R16
   \   0000003C   F411               BRNE    ??HARTDiag_Task_2
   \   0000003E   E001               LDI     R16, 1
   \   00000040   C001               RJMP    ??HARTDiag_Task_3
   \                     ??HARTDiag_Task_2:
   \   00000042   E000               LDI     R16, 0
   \                     ??HARTDiag_Task_3:
   \   00000044   9300....           STS     ??on_off, R16
    346          		}
   \   00000048   9593               INC     R25
   \   0000004A   958A               DEC     R24
   \   0000004C   F2E9               BREQ    ??HARTDiag_Task_0
   \   0000004E   CFDE               RJMP    ??HARTDiag_Task_1
    347          
    348          #if 0 // for ADC debugging only
    349          		ad7715_read_diag_adc((hart_channel_t)12);
    350          		ad7715_read_diag_adc((hart_channel_t)13);
    351          		//
    352          		// 2.5V reference check for debugging
    353          		//
    354          		ad7715_read_diag_adc((hart_channel_t)14);
    355          
    356          		//
    357          		// 0V ground
    358          		//
    359          		ad7715_read_diag_adc((hart_channel_t)15);
    360          #endif
    361          	}
    362          }
    363          
    364          ////////////////////////////////////////////////////////////////////////////////
    365          //
    366          // public interfaces
    367          //
    368          ////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    369          void
    370          hart_diag_init(void) {
   \                     hart_diag_init:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    371          	// FIXME initialize diag data structure
    372          }
   \   00000000   9508               RET
    373          

   \                                 In  segment CODE, align 2, keep-with-next
    374          void
    375          hart_diag_task_start(void) {
   \                     hart_diag_task_start:
   \   00000000                      REQUIRE __RSTACK_in_external_ram_new_way
    376          	OS_CREATETASK(&_hart_diag_task, "HARTDiag", HARTDiag_Task, 90, _hart_diag_task_stack);
   \   00000000   E002               LDI     R16, 2
   \   00000002   E010               LDI     R17, 0
   \   00000004   931A               ST      -Y, R17
   \   00000006   930A               ST      -Y, R16
   \   00000008   E708               LDI     R16, 120
   \   0000000A   931A               ST      -Y, R17
   \   0000000C   930A               ST      -Y, R16
   \   0000000E   ....               LDI     R16, LOW(_hart_diag_task_stack)
   \   00000010   ....               LDI     R17, (_hart_diag_task_stack) >> 8
   \   00000012   931A               ST      -Y, R17
   \   00000014   930A               ST      -Y, R16
   \   00000016   ....               LDI     R22, LOW(HARTDiag_Task/2)
   \   00000018   ....               LDI     R23, (HARTDiag_Task/2) >> 8
   \   0000001A   E54A               LDI     R20, 90
   \   0000001C   ....               LDI     R18, LOW(`?<Constant "HARTDiag">`)
   \   0000001E   ....               LDI     R19, (`?<Constant "HARTDiag">`) >> 8
   \   00000020   ....               LDI     R16, LOW(_hart_diag_task)
   \   00000022   ....               LDI     R17, (_hart_diag_task) >> 8
   \   00000024   ........           JMP     OS_CreateTask_S
    377          }

   \                                 In  segment INTVEC, offset 0x4, root
   \                     `??IntHandler_INT0::??INTVEC 4`:
   \   00000004   ........           JMP     IntHandler_INT0

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "HARTDiag">>`:
   \   00000000   414854526944       DC8 "HARTDiag"
   \              676100      

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for on_off>`:
   \   00000000   01                 DC8 1

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
   \                     `?<Constant "HARTDiag">`:
   \   00000000                      DS8 9
   \   00000009                      REQUIRE `?<Initializer for <Constant "HARTDiag">>`

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      2      2   HARTDiag_Task
        2      2   -> ad7715_do_calibration
        2      2   -> ad7715_hard_reset
        2      2   -> ad7715_read_sample
        2      2   -> ad7715_wait_for_drdy
        2      2   -> ad7715_write_byte
        2      2   -> hart_diag_set_diag_value
        2      2   -> hart_gpio_adc_channel_select
        2      2   -> hart_gpio_debug_led
     16      2   IntHandler_INT0
       16      2   -> OS_SignalEvent
       16      2   -> OS__EnterIntStack
       16      2   -> OS__LeaveIntStack
      0      2   ad7715_do_calibration
        0      2   -> OS_WaitEventTimed
        0      2   -> ad7715_read_sample
        0      2   -> ad7715_write_byte
        0      2   -> hart_gpio_adc_channel_select
      0      2   ad7715_hard_reset
        0      2   -> OS_Delay
        0      2   -> hart_gpio_adc_reset
      0      2   ad7715_read_byte
      0      2   ad7715_read_sample
        0      2   -> ad7715_read_byte
        0      2   -> ad7715_write_byte
      0      2   ad7715_wait_for_drdy
        0      2   -> OS_WaitEventTimed
      0      2   ad7715_write_byte
      0      2   hart_diag_init
      5      2   hart_diag_set_diag_value
        5      2   -> hart_channel_get_with_lock
        5      2   -> hart_channel_put_with_unlock
        5      2 ?F_DIV_S_L04
        5      2 ?F_MUL_S_L04
        5      2 ?UL2F_S_L04
      6      2   hart_diag_task_start
        0      2   -> OS_CreateTask_S


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant "HARTDiag">
       9  ?<Initializer for <Constant "HARTDiag">>
       1  ?<Initializer for on_off>
      80  HARTDiag_Task
     146  IntHandler_INT0
       4  IntHandler_INT0::??INTVEC 4
       1  _A_PINL
       1  _A_PORTL
      21  _hart_diag_task
     120  _hart_diag_task_stack
       2  _num_adc_fuckups
      64  ad7715_do_calibration
      42  ad7715_hard_reset
      40  ad7715_read_byte
      14  ad7715_read_sample
      42  ad7715_wait_for_drdy
      48  ad7715_write_byte
       2  hart_diag_init
     142  hart_diag_set_diag_value
      40  hart_diag_task_start
       1  on_off
      14  -- Other

 
   2 bytes in segment ABSOLUTE
 660 bytes in segment CODE
  14 bytes in segment INITTAB
   4 bytes in segment INTVEC
  10 bytes in segment NEAR_I
  10 bytes in segment NEAR_ID
 143 bytes in segment NEAR_Z
 
 670 bytes of CODE memory (+ 18 bytes shared)
 153 bytes of DATA memory (+  2 bytes shared)

Errors: none
Warnings: none
