###############################################################################
#
# IAR C/C++ Compiler V6.70.1.929 for Atmel AVR            18/Jan/2017  11:06:43
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Atmel AVR 6.80
#
#    Source file  =  D:\S2Prog\IO\TPC_Bootloader\Src\Usart.c
#    Command line =  
#        D:\S2Prog\IO\TPC_Bootloader\Src\Usart.c -v3 --enhanced_core -ms -o
#        D:\S2Prog\IO\TPC_Bootloader\Debug\Obj -D SPEED=19200 -D PORT0 -lCN
#        D:\S2Prog\IO\TPC_Bootloader\Debug\List -y --initializers_in_flash
#        --no_tbaa --debug -DENABLE_BIT_DEFINITIONS -e -I
#        D:\S2Prog\IO\TPC_Bootloader\INC\ -I
#        D:\S2Prog\IO\TPC_Bootloader\..\..\SHARED\INC\ --dlib --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\avr\LIB\DLIB\dlAVR-3s-ec_mul-n.h" -Oh
#    List file    =  D:\S2Prog\IO\TPC_Bootloader\Debug\List\Usart.lst
#    Object file  =  D:\S2Prog\IO\TPC_Bootloader\Debug\Obj\Usart.r90
#
###############################################################################

D:\S2Prog\IO\TPC_Bootloader\Src\Usart.c
      1          /****************************************************************************************
      2          / Com protocol for USART0 
      3          /
      4          ***************************************************************************************/
      5          
      6          #include "iom128.h"

   \                                 In  segment ABSOLUTE, at 0x23
   \   union <unnamed> volatile __io _A_PORTE
   \                     _A_PORTE:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3c
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3e
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS8 2

   \                                 In  segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_WDTCR
   \                     _A_WDTCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x5b
   \   union <unnamed> volatile __io _A_RAMPZ
   \                     _A_RAMPZ:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x65
   \   union <unnamed> volatile __io _A_PORTG
   \                     _A_PORTG:
   \   00000000                      DS8 1
      7          #include "stdio.h"
      8          #include "math.h"
      9          #include "externals.h"
     10          #include "assembly.h"
     11          
     12          
     13          /*************************************************************************
     14          *
     15          *  Check the incoming packages
     16          *
     17          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     18          void UsartCheckPackage(char ch) {
   \                     UsartCheckPackage:
   \   00000000   924A               ST      -Y, R4
   \   00000002   93BA               ST      -Y, R27
   \   00000004   93AA               ST      -Y, R26
   \   00000006   939A               ST      -Y, R25
   \   00000008   938A               ST      -Y, R24
   \   0000000A                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000A   2E40               MOV     R4, R16
     19          
     20              unsigned short pointer;
     21              char    retval ;
     22          
     23              UART[ch].RxSendReply = false ;                           // flag for answering set to fault
   \   0000000C   E10D               LDI     R16, 29
   \   0000000E   9E40               MUL     R4, R16
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   E000               LDI     R16, 0
   \   0000001A   01FD               MOVW    R31:R30, R27:R26
   \   0000001C   8F04               STD     Z+28, R16
     24              UART[ch].TxFirst = 6 ;                                 // Start pos for first TX command
   \   0000001E   E006               LDI     R16, 6
   \   00000020   E010               LDI     R17, 0
   \   00000022   8302               STD     Z+2, R16
   \   00000024   8313               STD     Z+3, R17
     25              pointer = 4 ;
   \   00000026   E084               LDI     R24, 4
   \   00000028   E090               LDI     R25, 0
     26              do {
     27                  retval = CheckActionUart(ch, pointer);
   \                     ??UsartCheckPackage_0:
   \   0000002A   019C               MOVW    R19:R18, R25:R24
   \   0000002C   2D04               MOV     R16, R4
   \   0000002E   ....               RCALL   CheckActionUart
     28                  pointer = pointer + UART[ch].pRxBuffer[pointer+1] + 2;        // Point to a command cmd hb/lb
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8524               LDD     R18, Z+12
   \   00000034   8535               LDD     R19, Z+13
   \   00000036   0F28               ADD     R18, R24
   \   00000038   1F39               ADC     R19, R25
   \   0000003A   01F9               MOVW    R31:R30, R19:R18
   \   0000003C   81E1               LDD     R30, Z+1
   \   0000003E   E0F0               LDI     R31, 0
   \   00000040   9632               ADIW    R31:R30, 2
   \   00000042   0F8E               ADD     R24, R30
   \   00000044   1F9F               ADC     R25, R31
     29              } while (retval && (pointer < (UART[ch].RxPacklen - 2 )));
   \   00000046   2300               TST     R16
   \   00000048   F041               BREQ    ??UsartCheckPackage_1
   \   0000004A   01FD               MOVW    R31:R30, R27:R26
   \   0000004C   8D00               LDD     R16, Z+24
   \   0000004E   8D11               LDD     R17, Z+25
   \   00000050   5002               SUBI    R16, 2
   \   00000052   4010               SBCI    R17, 0
   \   00000054   1780               CP      R24, R16
   \   00000056   0791               CPC     R25, R17
   \   00000058   F340               BRCS    ??UsartCheckPackage_0
     30              if (UART[ch].RxSendReply) {                              //send answer
   \                     ??UsartCheckPackage_1:
   \   0000005A   01FD               MOVW    R31:R30, R27:R26
   \   0000005C   8D04               LDD     R16, Z+28
   \   0000005E   2300               TST     R16
   \   00000060   F011               BREQ    ??UsartCheckPackage_2
     31                  Uart_BuildTail(ch);
   \   00000062   2D04               MOV     R16, R4
   \   00000064   ....               RCALL   Uart_BuildTail
     32              }
     33              GoToSyncUART(ch) ;                                    // go to sync modus for recive
   \                     ??UsartCheckPackage_2:
   \   00000066   2D04               MOV     R16, R4
   \   00000068   ....               RCALL   GoToSyncUART
     34          }
   \   0000006A   9189               LD      R24, Y+
   \   0000006C   9199               LD      R25, Y+
   \   0000006E   91A9               LD      R26, Y+
   \   00000070   91B9               LD      R27, Y+
   \   00000072   9049               LD      R4, Y+
   \   00000074   9508               RET
     35          
     36          /*************************************************************************
     37          *
     38          *  Check action on received data
     39          *
     40          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     41          char CheckActionUart(char ch, unsigned short pointer) {
   \                     CheckActionUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
     42          
     43             unsigned short   command;
     44             char    retval = true;
   \   00000006   E081               LDI     R24, 1
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   85A4               LDD     R26, Z+12
   \   00000016   85B5               LDD     R27, Z+13
   \   00000018   0FA2               ADD     R26, R18
   \   0000001A   1FB3               ADC     R27, R19
   \   0000001C   914C               LD      R20, X
     45          
     46             command = UART[ch].pRxBuffer[pointer] ;
     47             switch (command) {                                      // check action 
   \   0000001E   2F14               MOV     R17, R20
   \   00000020   5F10               SUBI    R17, 240
   \   00000022   F091               BREQ    ??CheckActionUart_0
   \   00000024   5012               SUBI    R17, 2
   \   00000026   F0C1               BREQ    ??CheckActionUart_1
   \   00000028   5012               SUBI    R17, 2
   \   0000002A   F0F1               BREQ    ??CheckActionUart_2
   \   0000002C   5012               SUBI    R17, 2
   \   0000002E   F131               BREQ    ??CheckActionUart_3
   \   00000030   5013               SUBI    R17, 3
   \   00000032   F171               BREQ    ??CheckActionUart_4
   \   00000034   5412               SUBI    R17, 66
   \   00000036   F5A1               BRNE    ??CheckActionUart_5
     48             case ANP1_REQ_STAT :                                    // Regusest status for target
     49                  if (UART[ch].pRxBuffer[pointer+2] == MySecAddress) {           // unit adddress sec
   \   00000038   01FD               MOVW    R31:R30, R27:R26
   \   0000003A   8112               LDD     R17, Z+2
   \   0000003C   9120....           LDS     R18, MySecAddress
   \   00000040   1712               CP      R17, R18
   \   00000042   F589               BRNE    ??CheckActionUart_6
     50                        BuildStatusData(ch) ;
   \   00000044   ....               RCALL   BuildStatusData
   \   00000046   C02F               RJMP    ??CheckActionUart_6
     51                  }                      
     52                  break;
     53                  
     54              case ANP1_FLASH_ID :                                     // Send flash ID
     55                  if (UART[ch].pRxBuffer[pointer+2] == MySecAddress) {           // unit adddress sec
   \                     ??CheckActionUart_0:
   \   00000048   01FD               MOVW    R31:R30, R27:R26
   \   0000004A   8112               LDD     R17, Z+2
   \   0000004C   9120....           LDS     R18, MySecAddress
   \   00000050   1712               CP      R17, R18
   \   00000052   F549               BRNE    ??CheckActionUart_6
     56                       BuildFlashID(ch) ;
   \   00000054   ....               RCALL   BuildFlashID
   \   00000056   C027               RJMP    ??CheckActionUart_6
     57                  }
     58                  break ;
     59                  
     60              case ANP1_FLASH_ERASE :                                 // Erase flash
     61                  if (UART[ch].pRxBuffer[pointer+2] == MySecAddress) {           // unit adddress sec
   \                     ??CheckActionUart_1:
   \   00000058   01FD               MOVW    R31:R30, R27:R26
   \   0000005A   8112               LDD     R17, Z+2
   \   0000005C   9120....           LDS     R18, MySecAddress
   \   00000060   1712               CP      R17, R18
   \   00000062   F509               BRNE    ??CheckActionUart_6
     62                      EraseFlash(ch) ;
   \   00000064   ....               RCALL   EraseFlash
   \   00000066   C01F               RJMP    ??CheckActionUart_6
     63                  }
     64                  break ;
     65                  
     66              case ANP1_FLASH_PROG :                                   // Prog flash
     67                  if (UART[ch].pRxBuffer[pointer+2] == MySecAddress) {           // unit adddress sec
   \                     ??CheckActionUart_2:
   \   00000068   01FD               MOVW    R31:R30, R27:R26
   \   0000006A   8112               LDD     R17, Z+2
   \   0000006C   9140....           LDS     R20, MySecAddress
   \   00000070   1714               CP      R17, R20
   \   00000072   F4C9               BRNE    ??CheckActionUart_6
     68                      ProgramFlash(ch, pointer+3) ;
   \   00000074   5F2D               SUBI    R18, 253
   \   00000076   4F3F               SBCI    R19, 255
   \   00000078   ....               RCALL   ProgramFlash
   \   0000007A   C015               RJMP    ??CheckActionUart_6
     69                  }
     70                  break ;
     71                  
     72              case ANP1_FLASH_READ :                                   // Read flash
     73                  if (UART[ch].pRxBuffer[pointer+2] == MySecAddress) {           // unit adddress sec
   \                     ??CheckActionUart_3:
   \   0000007C   01FD               MOVW    R31:R30, R27:R26
   \   0000007E   8112               LDD     R17, Z+2
   \   00000080   9140....           LDS     R20, MySecAddress
   \   00000084   1714               CP      R17, R20
   \   00000086   F479               BRNE    ??CheckActionUart_6
     74                     ReadFlash(ch, pointer+3) ;
   \   00000088   5F2D               SUBI    R18, 253
   \   0000008A   4F3F               SBCI    R19, 255
   \   0000008C   ....               RCALL   ReadFlash
   \   0000008E   C00B               RJMP    ??CheckActionUart_6
     75                  }
     76                  break ;
     77                  
     78              case ANP1_EXIT_BOOTLOADER :                                // Leave bootlaoder
     79                  if (UART[ch].pRxBuffer[pointer+2] == MySecAddress) {           // unit adddress sec
   \                     ??CheckActionUart_4:
   \   00000090   01FD               MOVW    R31:R30, R27:R26
   \   00000092   8112               LDD     R17, Z+2
   \   00000094   9120....           LDS     R18, MySecAddress
   \   00000098   1712               CP      R17, R18
   \   0000009A   F429               BRNE    ??CheckActionUart_6
     80                      ExitBootloader(ch) ; 
   \   0000009C   ....               RCALL   ExitBootloader
   \   0000009E   C003               RJMP    ??CheckActionUart_6
     81                  }
     82                  break ;
     83                  
     84              default:
     85                  if (command < ANP1_MAX_ECMD) {                           // handle end commands
   \                     ??CheckActionUart_5:
   \   000000A0   304A               CPI     R20, 10
   \   000000A2   F408               BRCC    ??CheckActionUart_6
     86                      retval = false ;
   \   000000A4   E080               LDI     R24, 0
     87                  }
     88                  break;
     89                  
     90              }
     91              return retval;
   \                     ??CheckActionUart_6:
   \   000000A6   2F08               MOV     R16, R24
   \   000000A8   9189               LD      R24, Y+
   \   000000AA   91A9               LD      R26, Y+
   \   000000AC   91B9               LD      R27, Y+
   \   000000AE   9508               RET
     92          }
     93          
     94          /*************************************************************************
     95          *
     96          * Build send packet header
     97          * *her*AStmark
     98          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     99          void Uart_BuildHeader(char ch) {
   \                     Uart_BuildHeader:
   \   00000000   019D               MOVW    R19:R18, R27:R26
    100          
    101              UART[ch].RxFirst = 0;                                // Reset pointers
   \   00000002   E11D               LDI     R17, 29
   \   00000004   9F01               MUL     R16, R17
   \   00000006   ....               LDI     R30, LOW(UART)
   \   00000008   ....               LDI     R31, (UART) >> 8
   \   0000000A   0DE0               ADD     R30, R0
   \   0000000C   1DF1               ADC     R31, R1
   \   0000000E   E000               LDI     R16, 0
   \   00000010   E010               LDI     R17, 0
   \   00000012   8706               STD     Z+14, R16
   \   00000014   8707               STD     Z+15, R16
    102              UART[ch].RxLast  = 0;
   \   00000016   8B00               STD     Z+16, R16
   \   00000018   8B01               STD     Z+17, R16
    103              UART[ch].TxLast  = 0;
   \   0000001A   8304               STD     Z+4, R16
   \   0000001C   8305               STD     Z+5, R16
    104          
    105              UART[ch].pTxBuffer[0] = ANPRO1_SYN ;                        /* Sync */
   \   0000001E   E002               LDI     R16, 2
   \   00000020   81A0               LD      R26, Z
   \   00000022   81B1               LDD     R27, Z+1
   \   00000024   930C               ST      X, R16
    106              UART[ch].pTxBuffer[1] = ANPRO1_SYN ;                        /* Sync */
   \   00000026   81A0               LD      R26, Z
   \   00000028   81B1               LDD     R27, Z+1
   \   0000002A   9611               ADIW    R27:R26, 1
   \   0000002C   930C               ST      X, R16
    107              UART[ch].pTxBuffer[2] = hostAddress ;                 /* RXID */
   \   0000002E   9100....           LDS     R16, hostAddress
   \   00000032   81A0               LD      R26, Z
   \   00000034   81B1               LDD     R27, Z+1
   \   00000036   9612               ADIW    R27:R26, 2
   \   00000038   930C               ST      X, R16
    108              UART[ch].pTxBuffer[3] = MyPriAddress;                 /* Tx address pri*/
   \   0000003A   9100....           LDS     R16, MyPriAddress
   \   0000003E   81A0               LD      R26, Z
   \   00000040   81B1               LDD     R27, Z+1
   \   00000042   9613               ADIW    R27:R26, 3
   \   00000044   930C               ST      X, R16
    109              UART[ch].pTxBuffer[4] = 0 ;                          /* packlen HB, don't know yet */
   \   00000046   81A0               LD      R26, Z
   \   00000048   81B1               LDD     R27, Z+1
   \   0000004A   9614               ADIW    R27:R26, 4
   \   0000004C   931C               ST      X, R17
    110              UART[ch].pTxBuffer[5] = 0 ;                          /* packlen LB, don't know yet */
   \   0000004E   01DF               MOVW    R27:R26, R31:R30
   \   00000050   91ED               LD      R30, X+
   \   00000052   91FC               LD      R31, X
   \   00000054   8315               STD     Z+5, R17
    111          }
   \   00000056   01D9               MOVW    R27:R26, R19:R18
   \   00000058   9508               RET
    112          
    113          /*************************************************************************
    114          *
    115          * Build  packet tail
    116          * 
    117          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    118          void Uart_BuildTail(char ch) {
   \                     Uart_BuildTail:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   2E20               MOV     R2, R16
    119          
    120              Uart_BuildHeader(ch);                                    // fist build the header
   \   00000006   ....               RCALL   Uart_BuildHeader
    121          
    122              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_ECMD_NMDWOACK ;  // End command 
   \   00000008   E10D               LDI     R16, 29
   \   0000000A   9E20               MUL     R2, R16
   \   0000000C   ....               LDI     R26, LOW(UART)
   \   0000000E   ....               LDI     R27, (UART) >> 8
   \   00000010   0DA0               ADD     R26, R0
   \   00000012   1DB1               ADC     R27, R1
   \   00000014   E020               LDI     R18, 0
   \   00000016   910D               LD      R16, X+
   \   00000018   911C               LD      R17, X
   \   0000001A   9711               SBIW    R27:R26, 1
   \   0000001C   01FD               MOVW    R31:R30, R27:R26
   \   0000001E   8142               LDD     R20, Z+2
   \   00000020   8153               LDD     R21, Z+3
   \   00000022   0F04               ADD     R16, R20
   \   00000024   1F15               ADC     R17, R21
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   8320               ST      Z, R18
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   8102               LDD     R16, Z+2
   \   0000002E   8113               LDD     R17, Z+3
   \   00000030   5F0F               SUBI    R16, 255
   \   00000032   4F1F               SBCI    R17, 255
   \   00000034   8302               STD     Z+2, R16
   \   00000036   8313               STD     Z+3, R17
    123              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0x00 ;                  // End data 
   \   00000038   8100               LD      R16, Z
   \   0000003A   8111               LDD     R17, Z+1
   \   0000003C   8142               LDD     R20, Z+2
   \   0000003E   8153               LDD     R21, Z+3
   \   00000040   0F04               ADD     R16, R20
   \   00000042   1F15               ADC     R17, R21
   \   00000044   01F8               MOVW    R31:R30, R17:R16
   \   00000046   8320               ST      Z, R18
   \   00000048   01FD               MOVW    R31:R30, R27:R26
   \   0000004A   8102               LDD     R16, Z+2
   \   0000004C   8113               LDD     R17, Z+3
   \   0000004E   5F0F               SUBI    R16, 255
   \   00000050   4F1F               SBCI    R17, 255
   \   00000052   8302               STD     Z+2, R16
   \   00000054   8313               STD     Z+3, R17
    124          
    125              UART[ch].pTxBuffer[5] = UART[ch].TxFirst;                    // correct length because stx's
   \   00000056   91ED               LD      R30, X+
   \   00000058   91FC               LD      R31, X
   \   0000005A   9711               SBIW    R27:R26, 1
   \   0000005C   8305               STD     Z+5, R16
    126              UART[ch].pTxBuffer[4] = (UART[ch].TxFirst) >> 8 ;             // packet len high 
   \   0000005E   01FD               MOVW    R31:R30, R27:R26
   \   00000060   8103               LDD     R16, Z+3
   \   00000062   91ED               LD      R30, X+
   \   00000064   91FC               LD      R31, X
   \   00000066   9711               SBIW    R27:R26, 1
   \   00000068   8304               STD     Z+4, R16
    127          
    128              UART[ch].pTxBuffer[UART[ch].TxFirst] = CalcDSTxChecksum(ch, UART[ch].TxFirst) ; // Get checksum 
   \   0000006A   01FD               MOVW    R31:R30, R27:R26
   \   0000006C   8122               LDD     R18, Z+2
   \   0000006E   8133               LDD     R19, Z+3
   \   00000070   2D02               MOV     R16, R2
   \   00000072   ....               RCALL   CalcDSTxChecksum
   \   00000074   912D               LD      R18, X+
   \   00000076   913C               LD      R19, X
   \   00000078   9711               SBIW    R27:R26, 1
   \   0000007A   01FD               MOVW    R31:R30, R27:R26
   \   0000007C   8142               LDD     R20, Z+2
   \   0000007E   8153               LDD     R21, Z+3
   \   00000080   0F24               ADD     R18, R20
   \   00000082   1F35               ADC     R19, R21
   \   00000084   01F9               MOVW    R31:R30, R19:R18
   \   00000086   8300               ST      Z, R16
    129              UART[ch].TxFirst++ ;                                        // OBS!! must be inc here due
   \   00000088   01FD               MOVW    R31:R30, R27:R26
   \   0000008A   8102               LDD     R16, Z+2
   \   0000008C   8113               LDD     R17, Z+3
   \   0000008E   5F0F               SUBI    R16, 255
   \   00000090   4F1F               SBCI    R17, 255
   \   00000092   8302               STD     Z+2, R16
   \   00000094   8313               STD     Z+3, R17
    130                                                                          // to ANSI standard !!!!
    131          
    132              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANPRO1_EOT ;            // End of transmission 
   \   00000096   E023               LDI     R18, 3
   \   00000098   8100               LD      R16, Z
   \   0000009A   8111               LDD     R17, Z+1
   \   0000009C   8142               LDD     R20, Z+2
   \   0000009E   8153               LDD     R21, Z+3
   \   000000A0   0F04               ADD     R16, R20
   \   000000A2   1F15               ADC     R17, R21
   \   000000A4   01F8               MOVW    R31:R30, R17:R16
   \   000000A6   8320               ST      Z, R18
   \   000000A8   01FD               MOVW    R31:R30, R27:R26
   \   000000AA   8102               LDD     R16, Z+2
   \   000000AC   8113               LDD     R17, Z+3
   \   000000AE   5F0F               SUBI    R16, 255
   \   000000B0   4F1F               SBCI    R17, 255
   \   000000B2   8302               STD     Z+2, R16
   \   000000B4   8313               STD     Z+3, R17
    133              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0x00 ;            //switch off transmitter delay 
   \   000000B6   E020               LDI     R18, 0
   \   000000B8   8100               LD      R16, Z
   \   000000BA   8111               LDD     R17, Z+1
   \   000000BC   8142               LDD     R20, Z+2
   \   000000BE   8153               LDD     R21, Z+3
   \   000000C0   0F04               ADD     R16, R20
   \   000000C2   1F15               ADC     R17, R21
   \   000000C4   01F8               MOVW    R31:R30, R17:R16
   \   000000C6   8320               ST      Z, R18
   \   000000C8   01FD               MOVW    R31:R30, R27:R26
   \   000000CA   8102               LDD     R16, Z+2
   \   000000CC   8113               LDD     R17, Z+3
   \   000000CE   5F0F               SUBI    R16, 255
   \   000000D0   4F1F               SBCI    R17, 255
   \   000000D2   8302               STD     Z+2, R16
   \   000000D4   8313               STD     Z+3, R17
    134          
    135              UART[ch].TxCount = UART[ch].TxFirst;                      //bytes to send 
   \   000000D6   8306               STD     Z+6, R16
   \   000000D8   8317               STD     Z+7, R17
    136              UART[ch].TxLast = 0;                                     // reset cunter
   \   000000DA   8324               STD     Z+4, R18
   \   000000DC   8325               STD     Z+5, R18
    137              UART[ch].TxPkCnt++ ;                                     // Count sent packages
   \   000000DE   8500               LDD     R16, Z+8
   \   000000E0   8511               LDD     R17, Z+9
   \   000000E2   5F0F               SUBI    R16, 255
   \   000000E4   4F1F               SBCI    R17, 255
   \   000000E6   8700               STD     Z+8, R16
   \   000000E8   8711               STD     Z+9, R17
    138              if (ch == 0) {                                           // Turn on TXE for channel
   \   000000EA   2022               TST     R2
   \   000000EC   F441               BRNE    ??Uart_BuildTail_0
    139                 SetBit(PORTG, 0x10) ;                                //Use the alarmled as TXE signal
   \   000000EE   91000065           LDS     R16, 101
   \   000000F2   6100               ORI     R16, 0x10
   \   000000F4   93000065           STS     101, R16
    140                 SetBit(PORTE, 0x04) ;                                     // TXE0 on
   \   000000F8   9A1A               SBI     0x03, 0x02
    141                  SendPacketUart(0) ;                                     // send answer
   \   000000FA   E000               LDI     R16, 0
   \   000000FC   ....               RCALL   SendPacketUart
    142              } else if (ch ==1) {
    143                  // not used
    144              }
    145          
    146          }
   \                     ??Uart_BuildTail_0:
   \   000000FE   91A9               LD      R26, Y+
   \   00000100   91B9               LD      R27, Y+
   \   00000102   9508               RET
   \   00000104                      REQUIRE _A_PORTG
   \   00000104                      REQUIRE _A_PORTE
    147          
    148          
    149          /*************************************************************************
    150          *
    151          * Build datablock for card status
    152          *
    153          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    154          void BuildStatusData(char ch){
   \                     BuildStatusData:
   \   00000000   2F5B               MOV     R21, R27
   \   00000002   2F6A               MOV     R22, R26
    155          
    156              short ntna ;
    157              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   E001               LDI     R16, 1
   \   00000012   8F04               STD     Z+28, R16
    158          
    159              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_STAT;     
   \   00000014   E40F               LDI     R16, 79
   \   00000016   81A0               LD      R26, Z
   \   00000018   81B1               LDD     R27, Z+1
   \   0000001A   8122               LDD     R18, Z+2
   \   0000001C   8133               LDD     R19, Z+3
   \   0000001E   0FA2               ADD     R26, R18
   \   00000020   1FB3               ADC     R27, R19
   \   00000022   930C               ST      X, R16
   \   00000024   8102               LDD     R16, Z+2
   \   00000026   8113               LDD     R17, Z+3
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   8302               STD     Z+2, R16
   \   0000002E   8313               STD     Z+3, R17
    160              ntna = UART[ch].TxFirst++ ;                                    // remember index 
   \   00000030   0198               MOVW    R19:R18, R17:R16
   \   00000032   5F2F               SUBI    R18, 255
   \   00000034   4F3F               SBCI    R19, 255
   \   00000036   8322               STD     Z+2, R18
   \   00000038   8333               STD     Z+3, R19
    161              
    162              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress;           // unit adddress sec
   \   0000003A   9120....           LDS     R18, MySecAddress
   \   0000003E   81A0               LD      R26, Z
   \   00000040   81B1               LDD     R27, Z+1
   \   00000042   8142               LDD     R20, Z+2
   \   00000044   0FA4               ADD     R26, R20
   \   00000046   1FB3               ADC     R27, R19
   \   00000048   932C               ST      X, R18
   \   0000004A   8122               LDD     R18, Z+2
   \   0000004C   8133               LDD     R19, Z+3
   \   0000004E   5F2F               SUBI    R18, 255
   \   00000050   4F3F               SBCI    R19, 255
   \   00000052   8322               STD     Z+2, R18
   \   00000054   8333               STD     Z+3, R19
    163              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PROG_VERSION + PROGTYPE_BOOT ; // software version Bit 7 = bootloader
   \   00000056   E823               LDI     R18, 131
   \   00000058   81A0               LD      R26, Z
   \   0000005A   81B1               LDD     R27, Z+1
   \   0000005C   8142               LDD     R20, Z+2
   \   0000005E   0FA4               ADD     R26, R20
   \   00000060   1FB3               ADC     R27, R19
   \   00000062   932C               ST      X, R18
   \   00000064   8122               LDD     R18, Z+2
   \   00000066   8133               LDD     R19, Z+3
   \   00000068   5F2F               SUBI    R18, 255
   \   0000006A   4F3F               SBCI    R19, 255
   \   0000006C   8322               STD     Z+2, R18
   \   0000006E   8333               STD     Z+3, R19
    164              UART[ch].pTxBuffer[UART[ch].TxFirst++] = UnitID;                       // unit id
   \   00000070   9120....           LDS     R18, UnitID
   \   00000074   81A0               LD      R26, Z
   \   00000076   81B1               LDD     R27, Z+1
   \   00000078   8142               LDD     R20, Z+2
   \   0000007A   0FA4               ADD     R26, R20
   \   0000007C   1FB3               ADC     R27, R19
   \   0000007E   932C               ST      X, R18
   \   00000080   8122               LDD     R18, Z+2
   \   00000082   8133               LDD     R19, Z+3
   \   00000084   5F2F               SUBI    R18, 255
   \   00000086   4F3F               SBCI    R19, 255
   \   00000088   8322               STD     Z+2, R18
   \   0000008A   8333               STD     Z+3, R19
    165              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (RXSIZE_UART & 0xff);         // rx buffer size
   \   0000008C   E52E               LDI     R18, 94
   \   0000008E   81A0               LD      R26, Z
   \   00000090   81B1               LDD     R27, Z+1
   \   00000092   8142               LDD     R20, Z+2
   \   00000094   0FA4               ADD     R26, R20
   \   00000096   1FB3               ADC     R27, R19
   \   00000098   932C               ST      X, R18
   \   0000009A   8122               LDD     R18, Z+2
   \   0000009C   8133               LDD     R19, Z+3
   \   0000009E   5F2F               SUBI    R18, 255
   \   000000A0   4F3F               SBCI    R19, 255
   \   000000A2   8322               STD     Z+2, R18
   \   000000A4   8333               STD     Z+3, R19
    166              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (( RXSIZE_UART >> 8) & 0xff); // rx buffer size
   \   000000A6   E021               LDI     R18, 1
   \   000000A8   81A0               LD      R26, Z
   \   000000AA   81B1               LDD     R27, Z+1
   \   000000AC   8142               LDD     R20, Z+2
   \   000000AE   0FA4               ADD     R26, R20
   \   000000B0   1FB3               ADC     R27, R19
   \   000000B2   932C               ST      X, R18
   \   000000B4   8122               LDD     R18, Z+2
   \   000000B6   8133               LDD     R19, Z+3
   \   000000B8   5F2F               SUBI    R18, 255
   \   000000BA   4F3F               SBCI    R19, 255
   \   000000BC   8322               STD     Z+2, R18
   \   000000BE   8333               STD     Z+3, R19
    167              UART[ch].pTxBuffer[UART[ch].TxFirst++] = (TXSIZE_UART & 0xff);         // tx buffer size
   \   000000C0   E52E               LDI     R18, 94
   \   000000C2   81A0               LD      R26, Z
   \   000000C4   81B1               LDD     R27, Z+1
   \   000000C6   8142               LDD     R20, Z+2
   \   000000C8   0FA4               ADD     R26, R20
   \   000000CA   1FB3               ADC     R27, R19
   \   000000CC   932C               ST      X, R18
   \   000000CE   8122               LDD     R18, Z+2
   \   000000D0   8133               LDD     R19, Z+3
   \   000000D2   5F2F               SUBI    R18, 255
   \   000000D4   4F3F               SBCI    R19, 255
   \   000000D6   8322               STD     Z+2, R18
   \   000000D8   8333               STD     Z+3, R19
    168              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ((TXSIZE_UART >> 8) & 0xff);  // tx buffer size
   \   000000DA   E021               LDI     R18, 1
   \   000000DC   81A0               LD      R26, Z
   \   000000DE   81B1               LDD     R27, Z+1
   \   000000E0   8142               LDD     R20, Z+2
   \   000000E2   0FA4               ADD     R26, R20
   \   000000E4   1FB3               ADC     R27, R19
   \   000000E6   932C               ST      X, R18
   \   000000E8   8122               LDD     R18, Z+2
   \   000000EA   8133               LDD     R19, Z+3
   \   000000EC   5F2F               SUBI    R18, 255
   \   000000EE   4F3F               SBCI    R19, 255
   \   000000F0   8322               STD     Z+2, R18
   \   000000F2   8333               STD     Z+3, R19
    169              UART[ch].pTxBuffer[UART[ch].TxFirst++] = RestartStatus ;                  // restart flag
   \   000000F4   9120....           LDS     R18, RestartStatus
   \   000000F8   81A0               LD      R26, Z
   \   000000FA   81B1               LDD     R27, Z+1
   \   000000FC   8142               LDD     R20, Z+2
   \   000000FE   0FA4               ADD     R26, R20
   \   00000100   1FB3               ADC     R27, R19
   \   00000102   932C               ST      X, R18
   \   00000104   8122               LDD     R18, Z+2
   \   00000106   8133               LDD     R19, Z+3
   \   00000108   5F2F               SUBI    R18, 255
   \   0000010A   4F3F               SBCI    R19, 255
   \   0000010C   8322               STD     Z+2, R18
   \   0000010E   8333               STD     Z+3, R19
    170              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0; //Ser no1 ;                // Application program
   \   00000110   E020               LDI     R18, 0
   \   00000112   81A0               LD      R26, Z
   \   00000114   81B1               LDD     R27, Z+1
   \   00000116   8142               LDD     R20, Z+2
   \   00000118   0FA4               ADD     R26, R20
   \   0000011A   1FB3               ADC     R27, R19
   \   0000011C   932C               ST      X, R18
   \   0000011E   8122               LDD     R18, Z+2
   \   00000120   8133               LDD     R19, Z+3
   \   00000122   5F2F               SUBI    R18, 255
   \   00000124   4F3F               SBCI    R19, 255
   \   00000126   8322               STD     Z+2, R18
   \   00000128   8333               STD     Z+3, R19
    171              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0; //Ser no2 ;                // Application program
   \   0000012A   E020               LDI     R18, 0
   \   0000012C   81A0               LD      R26, Z
   \   0000012E   81B1               LDD     R27, Z+1
   \   00000130   8142               LDD     R20, Z+2
   \   00000132   0FA4               ADD     R26, R20
   \   00000134   1FB3               ADC     R27, R19
   \   00000136   932C               ST      X, R18
   \   00000138   8122               LDD     R18, Z+2
   \   0000013A   8133               LDD     R19, Z+3
   \   0000013C   5F2F               SUBI    R18, 255
   \   0000013E   4F3F               SBCI    R19, 255
   \   00000140   8322               STD     Z+2, R18
   \   00000142   8333               STD     Z+3, R19
    172              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0; //Ser no3 ;                // Application program
   \   00000144   E020               LDI     R18, 0
   \   00000146   81A0               LD      R26, Z
   \   00000148   81B1               LDD     R27, Z+1
   \   0000014A   8142               LDD     R20, Z+2
   \   0000014C   0FA4               ADD     R26, R20
   \   0000014E   1FB3               ADC     R27, R19
   \   00000150   932C               ST      X, R18
   \   00000152   8122               LDD     R18, Z+2
   \   00000154   8133               LDD     R19, Z+3
   \   00000156   5F2F               SUBI    R18, 255
   \   00000158   4F3F               SBCI    R19, 255
   \   0000015A   8322               STD     Z+2, R18
   \   0000015C   8333               STD     Z+3, R19
    173              UART[ch].pTxBuffer[UART[ch].TxFirst++] = 0; //Ser no4 ;                // Application program
   \   0000015E   E020               LDI     R18, 0
   \   00000160   81A0               LD      R26, Z
   \   00000162   81B1               LDD     R27, Z+1
   \   00000164   8142               LDD     R20, Z+2
   \   00000166   0FA4               ADD     R26, R20
   \   00000168   1FB3               ADC     R27, R19
   \   0000016A   932C               ST      X, R18
   \   0000016C   8122               LDD     R18, Z+2
   \   0000016E   8133               LDD     R19, Z+3
   \   00000170   5F2F               SUBI    R18, 255
   \   00000172   4F3F               SBCI    R19, 255
   \   00000174   8322               STD     Z+2, R18
   \   00000176   8333               STD     Z+3, R19
    174          
    175              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \   00000178   1B20               SUB     R18, R16
   \   0000017A   952A               DEC     R18
   \   0000017C   2F42               MOV     R20, R18
   \   0000017E   8120               LD      R18, Z
   \   00000180   8131               LDD     R19, Z+1
   \   00000182   0F20               ADD     R18, R16
   \   00000184   1F31               ADC     R19, R17
   \   00000186   01F9               MOVW    R31:R30, R19:R18
   \   00000188   8340               ST      Z, R20
    176          
    177              RestartStatus = 0 ;                                                  // set reset stat to 0 = read    
   \   0000018A   E000               LDI     R16, 0
   \   0000018C   9300....           STS     RestartStatus, R16
    178          }
   \   00000190   2FA6               MOV     R26, R22
   \   00000192   2FB5               MOV     R27, R21
   \   00000194   9508               RET
    179          
    180          /*************************************************************************
    181          *
    182          * Build datablock for Flash ID
    183          * 
    184          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    185          void BuildFlashID(char ch) {
   \                     BuildFlashID:
   \   00000000   2F5B               MOV     R21, R27
   \   00000002   2F6A               MOV     R22, R26
    186          
    187              short ntna;
    188              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000004   E11D               LDI     R17, 29
   \   00000006   9F01               MUL     R16, R17
   \   00000008   ....               LDI     R30, LOW(UART)
   \   0000000A   ....               LDI     R31, (UART) >> 8
   \   0000000C   0DE0               ADD     R30, R0
   \   0000000E   1DF1               ADC     R31, R1
   \   00000010   E001               LDI     R16, 1
   \   00000012   8F04               STD     Z+28, R16
    189           
    190              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_FLASH_ID;     
   \   00000014   EF01               LDI     R16, 241
   \   00000016   81A0               LD      R26, Z
   \   00000018   81B1               LDD     R27, Z+1
   \   0000001A   8122               LDD     R18, Z+2
   \   0000001C   8133               LDD     R19, Z+3
   \   0000001E   0FA2               ADD     R26, R18
   \   00000020   1FB3               ADC     R27, R19
   \   00000022   930C               ST      X, R16
   \   00000024   8102               LDD     R16, Z+2
   \   00000026   8113               LDD     R17, Z+3
   \   00000028   5F0F               SUBI    R16, 255
   \   0000002A   4F1F               SBCI    R17, 255
   \   0000002C   8302               STD     Z+2, R16
   \   0000002E   8313               STD     Z+3, R17
    191              ntna = UART[ch].TxFirst++ ;               /* remember index */
   \   00000030   0198               MOVW    R19:R18, R17:R16
   \   00000032   5F2F               SUBI    R18, 255
   \   00000034   4F3F               SBCI    R19, 255
   \   00000036   8322               STD     Z+2, R18
   \   00000038   8333               STD     Z+3, R19
    192                                                 
    193              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress;           // unit adddress sec
   \   0000003A   9120....           LDS     R18, MySecAddress
   \   0000003E   81A0               LD      R26, Z
   \   00000040   81B1               LDD     R27, Z+1
   \   00000042   8142               LDD     R20, Z+2
   \   00000044   0FA4               ADD     R26, R20
   \   00000046   1FB3               ADC     R27, R19
   \   00000048   932C               ST      X, R18
   \   0000004A   8122               LDD     R18, Z+2
   \   0000004C   8133               LDD     R19, Z+3
   \   0000004E   5F2F               SUBI    R18, 255
   \   00000050   4F3F               SBCI    R19, 255
   \   00000052   8322               STD     Z+2, R18
   \   00000054   8333               STD     Z+3, R19
    194             
    195              UART[ch].pTxBuffer[UART[ch].TxFirst++] = PARTCODE ;
   \   00000056   E424               LDI     R18, 68
   \   00000058   81A0               LD      R26, Z
   \   0000005A   81B1               LDD     R27, Z+1
   \   0000005C   8142               LDD     R20, Z+2
   \   0000005E   0FA4               ADD     R26, R20
   \   00000060   1FB3               ADC     R27, R19
   \   00000062   932C               ST      X, R18
   \   00000064   8122               LDD     R18, Z+2
   \   00000066   8133               LDD     R19, Z+3
   \   00000068   5F2F               SUBI    R18, 255
   \   0000006A   4F3F               SBCI    R19, 255
   \   0000006C   8322               STD     Z+2, R18
   \   0000006E   8333               STD     Z+3, R19
    196              UART[ch].pTxBuffer[UART[ch].TxFirst++] = SIGNATURE_BYTE_1 ;
   \   00000070   E12E               LDI     R18, 30
   \   00000072   81A0               LD      R26, Z
   \   00000074   81B1               LDD     R27, Z+1
   \   00000076   8142               LDD     R20, Z+2
   \   00000078   0FA4               ADD     R26, R20
   \   0000007A   1FB3               ADC     R27, R19
   \   0000007C   932C               ST      X, R18
   \   0000007E   8122               LDD     R18, Z+2
   \   00000080   8133               LDD     R19, Z+3
   \   00000082   5F2F               SUBI    R18, 255
   \   00000084   4F3F               SBCI    R19, 255
   \   00000086   8322               STD     Z+2, R18
   \   00000088   8333               STD     Z+3, R19
    197              UART[ch].pTxBuffer[UART[ch].TxFirst++] = SIGNATURE_BYTE_2 ;
   \   0000008A   E927               LDI     R18, 151
   \   0000008C   81A0               LD      R26, Z
   \   0000008E   81B1               LDD     R27, Z+1
   \   00000090   8142               LDD     R20, Z+2
   \   00000092   0FA4               ADD     R26, R20
   \   00000094   1FB3               ADC     R27, R19
   \   00000096   932C               ST      X, R18
   \   00000098   8122               LDD     R18, Z+2
   \   0000009A   8133               LDD     R19, Z+3
   \   0000009C   5F2F               SUBI    R18, 255
   \   0000009E   4F3F               SBCI    R19, 255
   \   000000A0   8322               STD     Z+2, R18
   \   000000A2   8333               STD     Z+3, R19
    198              UART[ch].pTxBuffer[UART[ch].TxFirst++] = SIGNATURE_BYTE_3 ;
   \   000000A4   E022               LDI     R18, 2
   \   000000A6   81A0               LD      R26, Z
   \   000000A8   81B1               LDD     R27, Z+1
   \   000000AA   8142               LDD     R20, Z+2
   \   000000AC   0FA4               ADD     R26, R20
   \   000000AE   1FB3               ADC     R27, R19
   \   000000B0   932C               ST      X, R18
   \   000000B2   8122               LDD     R18, Z+2
   \   000000B4   8133               LDD     R19, Z+3
   \   000000B6   5F2F               SUBI    R18, 255
   \   000000B8   4F3F               SBCI    R19, 255
   \   000000BA   8322               STD     Z+2, R18
   \   000000BC   8333               STD     Z+3, R19
    199          
    200              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \   000000BE   1B20               SUB     R18, R16
   \   000000C0   952A               DEC     R18
   \   000000C2   2F42               MOV     R20, R18
   \   000000C4   8120               LD      R18, Z
   \   000000C6   8131               LDD     R19, Z+1
   \   000000C8   0F20               ADD     R18, R16
   \   000000CA   1F31               ADC     R19, R17
   \   000000CC   01F9               MOVW    R31:R30, R19:R18
   \   000000CE   8340               ST      Z, R20
    201          }
   \   000000D0   2FA6               MOV     R26, R22
   \   000000D2   2FB5               MOV     R27, R21
   \   000000D4   9508               RET
    202          
    203          /*************************************************************************
    204          *
    205          * Erase Flash 
    206          *
    207          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    208          void EraseFlash(char ch) {
   \                     EraseFlash:
   \   00000000   925A               ST      -Y, R5
   \   00000002   924A               ST      -Y, R4
   \   00000004   93BA               ST      -Y, R27
   \   00000006   93AA               ST      -Y, R26
   \   00000008   939A               ST      -Y, R25
   \   0000000A   938A               ST      -Y, R24
   \   0000000C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000000C                      REQUIRE ?Register_R5_is_cg_reg
    209          
    210              unsigned short ntna, address;
    211              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   0000000C   E11D               LDI     R17, 29
   \   0000000E   9F01               MUL     R16, R17
   \   00000010   ....               LDI     R26, LOW(UART)
   \   00000012   ....               LDI     R27, (UART) >> 8
   \   00000014   0DA0               ADD     R26, R0
   \   00000016   1DB1               ADC     R27, R1
   \   00000018   E001               LDI     R16, 1
   \   0000001A   01FD               MOVW    R31:R30, R27:R26
   \   0000001C   8F04               STD     Z+28, R16
    212              
    213              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_FLASH_ERASE;     
   \   0000001E   EF23               LDI     R18, 243
   \   00000020   8100               LD      R16, Z
   \   00000022   8111               LDD     R17, Z+1
   \   00000024   8142               LDD     R20, Z+2
   \   00000026   8153               LDD     R21, Z+3
   \   00000028   0F04               ADD     R16, R20
   \   0000002A   1F15               ADC     R17, R21
   \   0000002C   01F8               MOVW    R31:R30, R17:R16
   \   0000002E   8320               ST      Z, R18
   \   00000030   01FD               MOVW    R31:R30, R27:R26
   \   00000032   8102               LDD     R16, Z+2
   \   00000034   8113               LDD     R17, Z+3
   \   00000036   5F0F               SUBI    R16, 255
   \   00000038   4F1F               SBCI    R17, 255
   \   0000003A   8302               STD     Z+2, R16
   \   0000003C   8313               STD     Z+3, R17
    214              ntna = UART[ch].TxFirst++ ;                                    /* remember index */
   \   0000003E   0128               MOVW    R5:R4, R17:R16
   \   00000040   5F0F               SUBI    R16, 255
   \   00000042   4F1F               SBCI    R17, 255
   \   00000044   8302               STD     Z+2, R16
   \   00000046   8313               STD     Z+3, R17
    215              
    216              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress;           // unit adddress sec
   \   00000048   9120....           LDS     R18, MySecAddress
   \   0000004C   8100               LD      R16, Z
   \   0000004E   8111               LDD     R17, Z+1
   \   00000050   8142               LDD     R20, Z+2
   \   00000052   8153               LDD     R21, Z+3
   \   00000054   0F04               ADD     R16, R20
   \   00000056   1F15               ADC     R17, R21
   \   00000058   01F8               MOVW    R31:R30, R17:R16
   \   0000005A   8320               ST      Z, R18
   \   0000005C   01FD               MOVW    R31:R30, R27:R26
   \   0000005E   8102               LDD     R16, Z+2
   \   00000060   8113               LDD     R17, Z+3
   \   00000062   5F0F               SUBI    R16, 255
   \   00000064   4F1F               SBCI    R17, 255
   \   00000066   8302               STD     Z+2, R16
   \   00000068   8313               STD     Z+3, R17
    217             
    218              #ifdef LARGE_MEMORY               //SPM uses Z pointer but the pointer is only 16bit and
    219              RAMPZ = 0x00;                     //can only address up to 64Kbytes FLASH to adresse higher 
   \   0000006A   E000               LDI     R16, 0
   \   0000006C   BF0B               OUT     0x3B, R16
    220                                                //location it require the use of RAMPZ
    221              
    222              for(address=0;((address < (unsigned int)(APP_END&0xFFFF))|(RAMPZ == 0x00));address += PAGESIZE) {
   \   0000006E   E080               LDI     R24, 0
   \   00000070   E090               LDI     R25, 0
   \                     ??EraseFlash_0:
   \   00000072   E011               LDI     R17, 1
   \   00000074   C017               RJMP    ??EraseFlash_1
   \                     ??EraseFlash_2:
   \   00000076   E000               LDI     R16, 0
   \                     ??EraseFlash_3:
   \   00000078   2B10               OR      R17, R16
   \   0000007A   F0C9               BREQ    ??EraseFlash_4
    223                  write_page(address,(1<<PGERS) + (1<<SPMEN));              //Perform page erase
   \   0000007C   E023               LDI     R18, 3
   \   0000007E   E000               LDI     R16, 0
   \   00000080   2F19               MOV     R17, R25
   \   00000082   ........           CALL    write_page
    224                  write_page(address, (1<<REENABLE_RWW_BIT) + (1<<SPMEN));  //Re-enable the RWW section
   \   00000086   E121               LDI     R18, 17
   \   00000088   E000               LDI     R16, 0
   \   0000008A   2F19               MOV     R17, R25
   \   0000008C   ........           CALL    write_page
    225              
    226                  if(address >=(0xFFFF-PAGESIZE)) //Last section on lower 64k segment is erased
   \   00000090   3F8F               CPI     R24, 255
   \   00000092   EF0E               LDI     R16, 254
   \   00000094   0790               CPC     R25, R16
   \   00000096   F010               BRCS    ??EraseFlash_5
    227                     RAMPZ = (1<<RAMPZ0);         //RAMPZ has to incremented into upper 64k segment
   \   00000098   E001               LDI     R16, 1
   \   0000009A   BF0B               OUT     0x3B, R16
    228              }
   \                     ??EraseFlash_5:
   \   0000009C   9593               INC     R25
   \   0000009E   3E90               CPI     R25, 224
   \   000000A0   F340               BRCS    ??EraseFlash_0
   \   000000A2   E010               LDI     R17, 0
   \                     ??EraseFlash_1:
   \   000000A4   B70B               IN      R16, 0x3B
   \   000000A6   2300               TST     R16
   \   000000A8   F731               BRNE    ??EraseFlash_2
   \   000000AA   E001               LDI     R16, 1
   \   000000AC   CFE5               RJMP    ??EraseFlash_3
    229              RAMPZ = 0x00;                     //Clear RAMPZ pointer
   \                     ??EraseFlash_4:
   \   000000AE   BF8B               OUT     0x3B, R24
    230              
    231              #else
    232              
    233              for(address=0;address < APP_END;address += PAGESIZE){  //Application section = 60 pages
    234                  write_page(address,(1<<PGERS) + (1<<SPMEN));       //Perform page erase
    235                  write_page(address, (1<<REENABLE_RWW_BIT) + (1<<SPMEN));  //Re-enable the RWW section
    236              }
    237              
    238              #endif          
    239          
    240              UART[ch].pTxBuffer[UART[ch].TxFirst++] = FLASH_ERASE_OK ;                 // Answer that the erase is OK
   \   000000B0   910D               LD      R16, X+
   \   000000B2   911C               LD      R17, X
   \   000000B4   9711               SBIW    R27:R26, 1
   \   000000B6   01FD               MOVW    R31:R30, R27:R26
   \   000000B8   8142               LDD     R20, Z+2
   \   000000BA   8153               LDD     R21, Z+3
   \   000000BC   0F04               ADD     R16, R20
   \   000000BE   1F15               ADC     R17, R21
   \   000000C0   01F8               MOVW    R31:R30, R17:R16
   \   000000C2   8380               ST      Z, R24
   \   000000C4   01FD               MOVW    R31:R30, R27:R26
   \   000000C6   8102               LDD     R16, Z+2
   \   000000C8   8113               LDD     R17, Z+3
   \   000000CA   5F0F               SUBI    R16, 255
   \   000000CC   4F1F               SBCI    R17, 255
   \   000000CE   8302               STD     Z+2, R16
   \   000000D0   8313               STD     Z+3, R17
    241          
    242              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \   000000D2   1904               SUB     R16, R4
   \   000000D4   950A               DEC     R16
   \   000000D6   91ED               LD      R30, X+
   \   000000D8   91FC               LD      R31, X
   \   000000DA   0DE4               ADD     R30, R4
   \   000000DC   1DF5               ADC     R31, R5
   \   000000DE   8300               ST      Z, R16
    243          }
   \   000000E0   9189               LD      R24, Y+
   \   000000E2   9199               LD      R25, Y+
   \   000000E4   91A9               LD      R26, Y+
   \   000000E6   91B9               LD      R27, Y+
   \   000000E8   9049               LD      R4, Y+
   \   000000EA   9059               LD      R5, Y+
   \   000000EC   9508               RET
   \   000000EE                      REQUIRE _A_RAMPZ
    244          
    245          /*************************************************************************
    246          *
    247          * Program Flash 
    248          *
    249          *   OBS!! This differ from the ANPRO10 protocol boot loader
    250          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    251          void ProgramFlash(char ch, unsigned short pointer) {
   \                     ProgramFlash:
   \   00000000   92DA               ST      -Y, R13
   \   00000002   92CA               ST      -Y, R12
   \   00000004   92BA               ST      -Y, R11
   \   00000006   92AA               ST      -Y, R10
   \   00000008   929A               ST      -Y, R9
   \   0000000A   928A               ST      -Y, R8
   \   0000000C   927A               ST      -Y, R7
   \   0000000E   926A               ST      -Y, R6
   \   00000010   925A               ST      -Y, R5
   \   00000012   924A               ST      -Y, R4
   \   00000014   93BA               ST      -Y, R27
   \   00000016   93AA               ST      -Y, R26
   \   00000018   939A               ST      -Y, R25
   \   0000001A   938A               ST      -Y, R24
   \   0000001C                      REQUIRE ?Register_R4_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R5_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R6_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R7_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R8_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R9_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R10_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R11_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R12_is_cg_reg
   \   0000001C                      REQUIRE ?Register_R13_is_cg_reg
    252          
    253              unsigned short ntna, address, Nobytes, i, Addr, intval;
    254              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   0000001C   E11D               LDI     R17, 29
   \   0000001E   9F01               MUL     R16, R17
   \   00000020   ....               LDI     R26, LOW(UART)
   \   00000022   ....               LDI     R27, (UART) >> 8
   \   00000024   0DA0               ADD     R26, R0
   \   00000026   1DB1               ADC     R27, R1
   \   00000028   E001               LDI     R16, 1
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   8F04               STD     Z+28, R16
    255              
    256              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_FLASH_PROG;     
   \   0000002E   EF45               LDI     R20, 245
   \   00000030   8100               LD      R16, Z
   \   00000032   8111               LDD     R17, Z+1
   \   00000034   8162               LDD     R22, Z+2
   \   00000036   8173               LDD     R23, Z+3
   \   00000038   0F06               ADD     R16, R22
   \   0000003A   1F17               ADC     R17, R23
   \   0000003C   01F8               MOVW    R31:R30, R17:R16
   \   0000003E   8340               ST      Z, R20
   \   00000040   01FD               MOVW    R31:R30, R27:R26
   \   00000042   8102               LDD     R16, Z+2
   \   00000044   8113               LDD     R17, Z+3
   \   00000046   5F0F               SUBI    R16, 255
   \   00000048   4F1F               SBCI    R17, 255
   \   0000004A   8302               STD     Z+2, R16
   \   0000004C   8313               STD     Z+3, R17
    257              ntna = UART[ch].TxFirst++ ;                         /* remember index */
   \   0000004E   0158               MOVW    R11:R10, R17:R16
   \   00000050   5F0F               SUBI    R16, 255
   \   00000052   4F1F               SBCI    R17, 255
   \   00000054   8302               STD     Z+2, R16
   \   00000056   8313               STD     Z+3, R17
    258                                                
    259              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress;           // unit adddress sec
   \   00000058   9140....           LDS     R20, MySecAddress
   \   0000005C   8100               LD      R16, Z
   \   0000005E   8111               LDD     R17, Z+1
   \   00000060   8162               LDD     R22, Z+2
   \   00000062   8173               LDD     R23, Z+3
   \   00000064   0F06               ADD     R16, R22
   \   00000066   1F17               ADC     R17, R23
   \   00000068   01F8               MOVW    R31:R30, R17:R16
   \   0000006A   8340               ST      Z, R20
   \   0000006C   01FD               MOVW    R31:R30, R27:R26
   \   0000006E   8102               LDD     R16, Z+2
   \   00000070   8113               LDD     R17, Z+3
   \   00000072   5F0F               SUBI    R16, 255
   \   00000074   4F1F               SBCI    R17, 255
   \   00000076   8302               STD     Z+2, R16
   \   00000078   8313               STD     Z+3, R17
    260             
    261              UART[ch].pTxBuffer[UART[ch].TxFirst++] = FLASH_PROG_OK;       // OK
   \   0000007A   E040               LDI     R20, 0
   \   0000007C   8100               LD      R16, Z
   \   0000007E   8111               LDD     R17, Z+1
   \   00000080   8162               LDD     R22, Z+2
   \   00000082   8173               LDD     R23, Z+3
   \   00000084   0F06               ADD     R16, R22
   \   00000086   1F17               ADC     R17, R23
   \   00000088   01F8               MOVW    R31:R30, R17:R16
   \   0000008A   8340               ST      Z, R20
   \   0000008C   01FD               MOVW    R31:R30, R27:R26
   \   0000008E   8102               LDD     R16, Z+2
   \   00000090   8113               LDD     R17, Z+3
   \   00000092   5F0F               SUBI    R16, 255
   \   00000094   4F1F               SBCI    R17, 255
   \   00000096   8302               STD     Z+2, R16
   \   00000098   8313               STD     Z+3, R17
    262             
    263              address = UART[ch].pRxBuffer[pointer] + (UART[ch].pRxBuffer[pointer+1]<<8); // save address
   \   0000009A   8504               LDD     R16, Z+12
   \   0000009C   8515               LDD     R17, Z+13
   \   0000009E   01F8               MOVW    R31:R30, R17:R16
   \   000000A0   0FE2               ADD     R30, R18
   \   000000A2   1FF3               ADC     R31, R19
   \   000000A4   8180               LD      R24, Z
   \   000000A6   8191               LDD     R25, Z+1
    264              pointer += 2;
   \   000000A8   5F2E               SUBI    R18, 254
   \   000000AA   4F3F               SBCI    R19, 255
    265              Nobytes = UART[ch].pRxBuffer[pointer] + (UART[ch].pRxBuffer[pointer+1]<<8); // save address
   \   000000AC   01F8               MOVW    R31:R30, R17:R16
   \   000000AE   0FE2               ADD     R30, R18
   \   000000B0   1FF3               ADC     R31, R19
   \   000000B2   8040               LD      R4, Z
   \   000000B4   8051               LDD     R5, Z+1
    266              pointer += 2;
   \   000000B6   5F2E               SUBI    R18, 254
   \   000000B8   4F3F               SBCI    R19, 255
    267              if (UART[ch].pRxBuffer[pointer++] == 0x00) {          // copy first part to buffer (128 byte)
   \   000000BA   0F02               ADD     R16, R18
   \   000000BC   1F13               ADC     R17, R19
   \   000000BE   01F8               MOVW    R31:R30, R17:R16
   \   000000C0   8140               LD      R20, Z
   \   000000C2   2344               TST     R20
   \   000000C4   F501               BRNE    ??ProgramFlash_0
    268                  for (i = 0; i < Nobytes; i++){                    // copy data to buffer
   \   000000C6   2D24               MOV     R18, R4
   \   000000C8   2925               OR      R18, R5
   \   000000CA   F069               BREQ    ??ProgramFlash_1
   \   000000CC   5F0F               SUBI    R16, 255
   \   000000CE   4F1F               SBCI    R17, 255
   \   000000D0   ....               LDI     R18, LOW(PageBuffer)
   \   000000D2   ....               LDI     R19, (PageBuffer) >> 8
   \   000000D4   01C2               MOVW    R25:R24, R5:R4
    269                      PageBuffer[i] = UART[ch].pRxBuffer[pointer++];  
   \                     ??ProgramFlash_2:
   \   000000D6   01F8               MOVW    R31:R30, R17:R16
   \   000000D8   9141               LD      R20, Z+
   \   000000DA   018F               MOVW    R17:R16, R31:R30
   \   000000DC   01F9               MOVW    R31:R30, R19:R18
   \   000000DE   9341               ST      Z+, R20
   \   000000E0   019F               MOVW    R19:R18, R31:R30
    270                  }
   \   000000E2   9701               SBIW    R25:R24, 1
   \   000000E4   F7C1               BRNE    ??ProgramFlash_2
    271                  UART[ch].pTxBuffer[UART[ch].TxFirst-1] = FLASH_COPYL_OK;       // Copy OK
   \                     ??ProgramFlash_1:
   \   000000E6   E025               LDI     R18, 5
   \   000000E8   910D               LD      R16, X+
   \   000000EA   911C               LD      R17, X
   \   000000EC   9711               SBIW    R27:R26, 1
   \   000000EE   01FD               MOVW    R31:R30, R27:R26
   \   000000F0   8142               LDD     R20, Z+2
   \   000000F2   8153               LDD     R21, Z+3
   \   000000F4   0F04               ADD     R16, R20
   \   000000F6   1F15               ADC     R17, R21
   \   000000F8   5001               SUBI    R16, 1
   \   000000FA   4010               SBCI    R17, 0
   \   000000FC   01F8               MOVW    R31:R30, R17:R16
   \   000000FE   8320               ST      Z, R18
    272                  NoBLow = Nobytes  ;                               // Number of bytes in low data
   \   00000100   9240....           STS     NoBLow, R4
   \   00000104   C0A6               RJMP    ??ProgramFlash_3
    273              } else {
    274                  for (i = NoBLow; i < NoBLow + Nobytes; i++){                    // copy data to buffer
   \                     ??ProgramFlash_0:
   \   00000106   9000....           LDS     R0, NoBLow
   \   0000010A   2411               CLR     R1
   \   0000010C   0180               MOVW    R17:R16, R1:R0
   \   0000010E   0D04               ADD     R16, R4
   \   00000110   1D15               ADC     R17, R5
   \   00000112   1600               CP      R0, R16
   \   00000114   0611               CPC     R1, R17
   \   00000116   F4B8               BRCC    ??ProgramFlash_4
   \   00000118   01FD               MOVW    R31:R30, R27:R26
   \   0000011A   8504               LDD     R16, Z+12
   \   0000011C   8515               LDD     R17, Z+13
   \   0000011E   0F02               ADD     R16, R18
   \   00000120   1F13               ADC     R17, R19
   \   00000122   5F0F               SUBI    R16, 255
   \   00000124   4F1F               SBCI    R17, 255
   \   00000126   ....               LDI     R18, LOW(PageBuffer)
   \   00000128   ....               LDI     R19, (PageBuffer) >> 8
   \   0000012A   0D20               ADD     R18, R0
   \   0000012C   1D31               ADC     R19, R1
   \   0000012E   01B2               MOVW    R23:R22, R5:R4
    275                      PageBuffer[i] = UART[ch].pRxBuffer[pointer++];  
   \                     ??ProgramFlash_5:
   \   00000130   01F8               MOVW    R31:R30, R17:R16
   \   00000132   9141               LD      R20, Z+
   \   00000134   018F               MOVW    R17:R16, R31:R30
   \   00000136   01F9               MOVW    R31:R30, R19:R18
   \   00000138   9341               ST      Z+, R20
   \   0000013A   019F               MOVW    R19:R18, R31:R30
    276                  }
   \   0000013C   5061               SUBI    R22, 1
   \   0000013E   4070               SBCI    R23, 0
   \   00000140   2F46               MOV     R20, R22
   \   00000142   2B47               OR      R20, R23
   \   00000144   F7A9               BRNE    ??ProgramFlash_5
    277                  Nobytes += NoBLow;                                    // toatl no of bytes
   \                     ??ProgramFlash_4:
   \   00000146   0C40               ADD     R4, R0
   \   00000148   1C51               ADC     R5, R1
    278                  if (Nobytes > PAGESIZE) {
   \   0000014A   E001               LDI     R16, 1
   \   0000014C   1640               CP      R4, R16
   \   0000014E   0650               CPC     R5, R16
   \   00000150   F098               BRCS    ??ProgramFlash_6
    279                      UART[ch].pTxBuffer[UART[ch].TxFirst++] = FLASH_PROG_PAGEF ;               // Answer with Page fault
   \   00000152   E021               LDI     R18, 1
   \   00000154   910D               LD      R16, X+
   \   00000156   911C               LD      R17, X
   \   00000158   9711               SBIW    R27:R26, 1
   \   0000015A   01FD               MOVW    R31:R30, R27:R26
   \   0000015C   8142               LDD     R20, Z+2
   \   0000015E   8153               LDD     R21, Z+3
   \   00000160   0F04               ADD     R16, R20
   \   00000162   1F15               ADC     R17, R21
   \   00000164   01F8               MOVW    R31:R30, R17:R16
   \   00000166   8320               ST      Z, R18
   \   00000168   01FD               MOVW    R31:R30, R27:R26
   \   0000016A   8102               LDD     R16, Z+2
   \   0000016C   8113               LDD     R17, Z+3
   \   0000016E   5F0F               SUBI    R16, 255
   \   00000170   4F1F               SBCI    R17, 255
   \   00000172   8302               STD     Z+2, R16
   \   00000174   8313               STD     Z+3, R17
   \   00000176   C06D               RJMP    ??ProgramFlash_3
    280                  } else {
    281                      #ifdef LARGE_MEMORY
    282                      if(address >= 0x7FFF){
   \                     ??ProgramFlash_6:
   \   00000178   3F8F               CPI     R24, 255
   \   0000017A   E70F               LDI     R16, 127
   \   0000017C   0790               CPC     R25, R16
   \   0000017E   F018               BRCS    ??ProgramFlash_7
    283                          RAMPZ = (1<<RAMPZ0);
   \   00000180   E001               LDI     R16, 1
   \   00000182   BF0B               OUT     0x3B, R16
   \   00000184   C001               RJMP    ??ProgramFlash_8
    284                      } else {
    285                          RAMPZ = 0;
   \                     ??ProgramFlash_7:
   \   00000186   BE1B               OUT     0x3B, R1
    286                      }
    287                      #endif            
    288                      address = address << 1;                                     // convert from byte address to word address
   \                     ??ProgramFlash_8:
   \   00000188   0F88               LSL     R24
   \   0000018A   1F99               ROL     R25
    289                      Addr = address;                                             // mirror the address
   \   0000018C   016C               MOVW    R13:R12, R25:R24
    290                      for (i = 0; i < Nobytes; i+=2, address+=2, pointer+=2) {              // write data to flash
   \   0000018E   2488               CLR     R8
   \   00000190   2499               CLR     R9
   \   00000192   2D04               MOV     R16, R4
   \   00000194   2905               OR      R16, R5
   \   00000196   F0B1               BREQ    ??ProgramFlash_9
   \   00000198   ....               LDI     R16, LOW(PageBuffer)
   \   0000019A   2E60               MOV     R6, R16
   \   0000019C   ....               LDI     R16, (PageBuffer) >> 8
   \   0000019E   2E70               MOV     R7, R16
    291                          fill_temp_buffer(PageBuffer[i] + (PageBuffer[i+1]<< 8),(address)); //call asm routine. 
   \                     ??ProgramFlash_10:
   \   000001A0   019C               MOVW    R19:R18, R25:R24
   \   000001A2   01F3               MOVW    R31:R30, R7:R6
   \   000001A4   8100               LD      R16, Z
   \   000001A6   8111               LDD     R17, Z+1
   \   000001A8   ........           CALL    fill_temp_buffer
    292                      }
   \   000001AC   E002               LDI     R16, 2
   \   000001AE   0E80               ADD     R8, R16
   \   000001B0   E000               LDI     R16, 0
   \   000001B2   1E90               ADC     R9, R16
   \   000001B4   9602               ADIW    R25:R24, 2
   \   000001B6   E002               LDI     R16, 2
   \   000001B8   0E60               ADD     R6, R16
   \   000001BA   E000               LDI     R16, 0
   \   000001BC   1E70               ADC     R7, R16
   \   000001BE   1484               CP      R8, R4
   \   000001C0   0495               CPC     R9, R5
   \   000001C2   F370               BRCS    ??ProgramFlash_10
    293                      write_page(Addr, (1<<PGWRT) + (1<<SPMEN));                  //Perform page write
   \                     ??ProgramFlash_9:
   \   000001C4   E025               LDI     R18, 5
   \   000001C6   0186               MOVW    R17:R16, R13:R12
   \   000001C8   ........           CALL    write_page
    294                      write_page(Addr, (1<<REENABLE_RWW_BIT) + (1<<SPMEN));       //Re-enable the RWW section
   \   000001CC   E121               LDI     R18, 17
   \   000001CE   0186               MOVW    R17:R16, R13:R12
   \   000001D0   ........           CALL    write_page
    295                      
    296                      for (i = 0; i < Nobytes; Addr+=2) {         // check the whole buffer
   \   000001D4   2488               CLR     R8
   \   000001D6   2499               CLR     R9
   \   000001D8   2D04               MOV     R16, R4
   \   000001DA   2905               OR      R16, R5
   \   000001DC   F1D1               BREQ    ??ProgramFlash_3
   \   000001DE   ....               LDI     R24, LOW(PageBuffer)
   \   000001E0   ....               LDI     R25, (PageBuffer) >> 8
    297                        intval = read_program_memory(Addr,0x00);
   \                     ??ProgramFlash_11:
   \   000001E2   E020               LDI     R18, 0
   \   000001E4   0186               MOVW    R17:R16, R13:R12
   \   000001E6   ........           CALL    read_program_memory
    298                        if (PageBuffer[i++] != (intval & 0xff)) {
   \   000001EA   E021               LDI     R18, 1
   \   000001EC   0E82               ADD     R8, R18
   \   000001EE   E020               LDI     R18, 0
   \   000001F0   1E92               ADC     R9, R18
   \   000001F2   01FC               MOVW    R31:R30, R25:R24
   \   000001F4   8140               LD      R20, Z
   \   000001F6   E050               LDI     R21, 0
   \   000001F8   1740               CP      R20, R16
   \   000001FA   4020               SBCI    R18, 0
   \   000001FC   F069               BREQ    ??ProgramFlash_12
    299                            UART[ch].pTxBuffer[UART[ch].TxFirst-1] = FLASH_PROG_ERROR;       // compare error
   \   000001FE   E042               LDI     R20, 2
   \   00000200   912D               LD      R18, X+
   \   00000202   913C               LD      R19, X
   \   00000204   9711               SBIW    R27:R26, 1
   \   00000206   01FD               MOVW    R31:R30, R27:R26
   \   00000208   8162               LDD     R22, Z+2
   \   0000020A   8173               LDD     R23, Z+3
   \   0000020C   0F26               ADD     R18, R22
   \   0000020E   1F37               ADC     R19, R23
   \   00000210   5021               SUBI    R18, 1
   \   00000212   4030               SBCI    R19, 0
   \   00000214   01F9               MOVW    R31:R30, R19:R18
   \   00000216   8340               ST      Z, R20
    300                        }
    301                        if (PageBuffer[i++] != ((intval>>8) & 0xff)) {
   \                     ??ProgramFlash_12:
   \   00000218   E021               LDI     R18, 1
   \   0000021A   0E82               ADD     R8, R18
   \   0000021C   1E95               ADC     R9, R21
   \   0000021E   01FC               MOVW    R31:R30, R25:R24
   \   00000220   8121               LDD     R18, Z+1
   \   00000222   E030               LDI     R19, 0
   \   00000224   1721               CP      R18, R17
   \   00000226   4050               SBCI    R21, 0
   \   00000228   F069               BREQ    ??ProgramFlash_13
    302                            UART[ch].pTxBuffer[UART[ch].TxFirst-1] = FLASH_PROG_ERROR;       // compare error
   \   0000022A   E022               LDI     R18, 2
   \   0000022C   910D               LD      R16, X+
   \   0000022E   911C               LD      R17, X
   \   00000230   9711               SBIW    R27:R26, 1
   \   00000232   01FD               MOVW    R31:R30, R27:R26
   \   00000234   8142               LDD     R20, Z+2
   \   00000236   8153               LDD     R21, Z+3
   \   00000238   0F04               ADD     R16, R20
   \   0000023A   1F15               ADC     R17, R21
   \   0000023C   5001               SUBI    R16, 1
   \   0000023E   4010               SBCI    R17, 0
   \   00000240   01F8               MOVW    R31:R30, R17:R16
   \   00000242   8320               ST      Z, R18
    303                        }
    304                      }
   \                     ??ProgramFlash_13:
   \   00000244   E002               LDI     R16, 2
   \   00000246   0EC0               ADD     R12, R16
   \   00000248   1ED3               ADC     R13, R19
   \   0000024A   9602               ADIW    R25:R24, 2
   \   0000024C   1484               CP      R8, R4
   \   0000024E   0495               CPC     R9, R5
   \   00000250   F240               BRCS    ??ProgramFlash_11
    305                  }  
    306              }
    307                  
    308              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \                     ??ProgramFlash_3:
   \   00000252   01FD               MOVW    R31:R30, R27:R26
   \   00000254   8102               LDD     R16, Z+2
   \   00000256   190A               SUB     R16, R10
   \   00000258   950A               DEC     R16
   \   0000025A   91ED               LD      R30, X+
   \   0000025C   91FC               LD      R31, X
   \   0000025E   0DEA               ADD     R30, R10
   \   00000260   1DFB               ADC     R31, R11
   \   00000262   8300               ST      Z, R16
    309          }
   \   00000264   9189               LD      R24, Y+
   \   00000266   9199               LD      R25, Y+
   \   00000268   91A9               LD      R26, Y+
   \   0000026A   91B9               LD      R27, Y+
   \   0000026C   9049               LD      R4, Y+
   \   0000026E   9059               LD      R5, Y+
   \   00000270   9069               LD      R6, Y+
   \   00000272   9079               LD      R7, Y+
   \   00000274   9089               LD      R8, Y+
   \   00000276   9099               LD      R9, Y+
   \   00000278   90A9               LD      R10, Y+
   \   0000027A   90B9               LD      R11, Y+
   \   0000027C   90C9               LD      R12, Y+
   \   0000027E   90D9               LD      R13, Y+
   \   00000280   9508               RET
   \   00000282                      REQUIRE _A_RAMPZ
    310          
    311          /*************************************************************************
    312          *
    313          * Read Flash 
    314          *
    315          *   Not implmented in this bootloader
    316          *
    317          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    318          void ReadFlash(char ch, unsigned short pointer) {
   \                     ReadFlash:
   \   00000000   929A               ST      -Y, R9
   \   00000002   928A               ST      -Y, R8
   \   00000004   927A               ST      -Y, R7
   \   00000006   926A               ST      -Y, R6
   \   00000008   925A               ST      -Y, R5
   \   0000000A   924A               ST      -Y, R4
   \   0000000C   93BA               ST      -Y, R27
   \   0000000E   93AA               ST      -Y, R26
   \   00000010   939A               ST      -Y, R25
   \   00000012   938A               ST      -Y, R24
   \   00000014                      REQUIRE ?Register_R4_is_cg_reg
   \   00000014                      REQUIRE ?Register_R5_is_cg_reg
   \   00000014                      REQUIRE ?Register_R6_is_cg_reg
   \   00000014                      REQUIRE ?Register_R7_is_cg_reg
   \   00000014                      REQUIRE ?Register_R8_is_cg_reg
   \   00000014                      REQUIRE ?Register_R9_is_cg_reg
    319          
    320              unsigned short ntna, address, Nobytes, i, intval;
    321              UART[ch].RxSendReply = true ;                               // flag for answering 
   \   00000014   E11D               LDI     R17, 29
   \   00000016   9F01               MUL     R16, R17
   \   00000018   ....               LDI     R26, LOW(UART)
   \   0000001A   ....               LDI     R27, (UART) >> 8
   \   0000001C   0DA0               ADD     R26, R0
   \   0000001E   1DB1               ADC     R27, R1
   \   00000020   E001               LDI     R16, 1
   \   00000022   01FD               MOVW    R31:R30, R27:R26
   \   00000024   8F04               STD     Z+28, R16
    322              
    323              UART[ch].pTxBuffer[UART[ch].TxFirst++] = ANP1_REP_FLASH_READ;     
   \   00000026   EF47               LDI     R20, 247
   \   00000028   8100               LD      R16, Z
   \   0000002A   8111               LDD     R17, Z+1
   \   0000002C   8162               LDD     R22, Z+2
   \   0000002E   8173               LDD     R23, Z+3
   \   00000030   0F06               ADD     R16, R22
   \   00000032   1F17               ADC     R17, R23
   \   00000034   01F8               MOVW    R31:R30, R17:R16
   \   00000036   8340               ST      Z, R20
   \   00000038   01FD               MOVW    R31:R30, R27:R26
   \   0000003A   8102               LDD     R16, Z+2
   \   0000003C   8113               LDD     R17, Z+3
   \   0000003E   5F0F               SUBI    R16, 255
   \   00000040   4F1F               SBCI    R17, 255
   \   00000042   8302               STD     Z+2, R16
   \   00000044   8313               STD     Z+3, R17
    324              ntna = UART[ch].TxFirst++ ;                               /* remember index */
   \   00000046   0138               MOVW    R7:R6, R17:R16
   \   00000048   5F0F               SUBI    R16, 255
   \   0000004A   4F1F               SBCI    R17, 255
   \   0000004C   8302               STD     Z+2, R16
   \   0000004E   8313               STD     Z+3, R17
    325              
    326              UART[ch].pTxBuffer[UART[ch].TxFirst++] = MySecAddress;           // unit adddress sec
   \   00000050   9140....           LDS     R20, MySecAddress
   \   00000054   8100               LD      R16, Z
   \   00000056   8111               LDD     R17, Z+1
   \   00000058   8162               LDD     R22, Z+2
   \   0000005A   8173               LDD     R23, Z+3
   \   0000005C   0F06               ADD     R16, R22
   \   0000005E   1F17               ADC     R17, R23
   \   00000060   01F8               MOVW    R31:R30, R17:R16
   \   00000062   8340               ST      Z, R20
   \   00000064   01FD               MOVW    R31:R30, R27:R26
   \   00000066   8102               LDD     R16, Z+2
   \   00000068   8113               LDD     R17, Z+3
   \   0000006A   5F0F               SUBI    R16, 255
   \   0000006C   4F1F               SBCI    R17, 255
   \   0000006E   8302               STD     Z+2, R16
   \   00000070   8313               STD     Z+3, R17
    327             
    328              for (i = 0; i<4; i++) {
   \   00000072   01C9               MOVW    R25:R24, R19:R18
   \   00000074   E004               LDI     R16, 4
    329                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = UART[ch].pRxBuffer[pointer+i] ; // ansver with address and nob
   \                     ??ReadFlash_0:
   \   00000076   8544               LDD     R20, Z+12
   \   00000078   8555               LDD     R21, Z+13
   \   0000007A   0F48               ADD     R20, R24
   \   0000007C   1F59               ADC     R21, R25
   \   0000007E   01FA               MOVW    R31:R30, R21:R20
   \   00000080   8110               LD      R17, Z
   \   00000082   914D               LD      R20, X+
   \   00000084   915C               LD      R21, X
   \   00000086   9711               SBIW    R27:R26, 1
   \   00000088   01FD               MOVW    R31:R30, R27:R26
   \   0000008A   8162               LDD     R22, Z+2
   \   0000008C   8173               LDD     R23, Z+3
   \   0000008E   0F46               ADD     R20, R22
   \   00000090   1F57               ADC     R21, R23
   \   00000092   01FA               MOVW    R31:R30, R21:R20
   \   00000094   8310               ST      Z, R17
   \   00000096   01FD               MOVW    R31:R30, R27:R26
   \   00000098   8142               LDD     R20, Z+2
   \   0000009A   8153               LDD     R21, Z+3
   \   0000009C   5F4F               SUBI    R20, 255
   \   0000009E   4F5F               SBCI    R21, 255
   \   000000A0   8342               STD     Z+2, R20
   \   000000A2   8353               STD     Z+3, R21
    330              }
   \   000000A4   9601               ADIW    R25:R24, 1
   \   000000A6   950A               DEC     R16
   \   000000A8   F731               BRNE    ??ReadFlash_0
    331            
    332              address = UART[ch].pRxBuffer[pointer] | (UART[ch].pRxBuffer[pointer+1]<<8); // save address
   \   000000AA   8504               LDD     R16, Z+12
   \   000000AC   8515               LDD     R17, Z+13
   \   000000AE   01F8               MOVW    R31:R30, R17:R16
   \   000000B0   0FE2               ADD     R30, R18
   \   000000B2   1FF3               ADC     R31, R19
   \   000000B4   8180               LD      R24, Z
   \   000000B6   8191               LDD     R25, Z+1
    333              pointer += 2;
   \   000000B8   5F2E               SUBI    R18, 254
   \   000000BA   4F3F               SBCI    R19, 255
    334              Nobytes = UART[ch].pRxBuffer[pointer] | (UART[ch].pRxBuffer[pointer+1]<<8); // save address
   \   000000BC   0F02               ADD     R16, R18
   \   000000BE   1F13               ADC     R17, R19
   \   000000C0   01F8               MOVW    R31:R30, R17:R16
   \   000000C2   8040               LD      R4, Z
   \   000000C4   8051               LDD     R5, Z+1
    335              pointer += 2;
    336              if (Nobytes > PAGESIZE) {
   \   000000C6   E001               LDI     R16, 1
   \   000000C8   1640               CP      R4, R16
   \   000000CA   0650               CPC     R5, R16
   \   000000CC   F090               BRCS    ??ReadFlash_1
    337                  UART[ch].pTxBuffer[UART[ch].TxFirst++] = FLASH_PROG_PAGEF ;               // Answer with Page fault
   \   000000CE   E021               LDI     R18, 1
   \   000000D0   910D               LD      R16, X+
   \   000000D2   911C               LD      R17, X
   \   000000D4   9711               SBIW    R27:R26, 1
   \   000000D6   01FD               MOVW    R31:R30, R27:R26
   \   000000D8   8142               LDD     R20, Z+2
   \   000000DA   0F04               ADD     R16, R20
   \   000000DC   1F15               ADC     R17, R21
   \   000000DE   01F8               MOVW    R31:R30, R17:R16
   \   000000E0   8320               ST      Z, R18
   \   000000E2   01FD               MOVW    R31:R30, R27:R26
   \   000000E4   8102               LDD     R16, Z+2
   \   000000E6   8113               LDD     R17, Z+3
   \   000000E8   5F0F               SUBI    R16, 255
   \   000000EA   4F1F               SBCI    R17, 255
   \   000000EC   8302               STD     Z+2, R16
   \   000000EE   8313               STD     Z+3, R17
   \   000000F0   C03D               RJMP    ??ReadFlash_2
    338              } else {
    339                #ifdef LARGE_MEMORY
    340                if(address >= 0x7FFF){
   \                     ??ReadFlash_1:
   \   000000F2   3F8F               CPI     R24, 255
   \   000000F4   E70F               LDI     R16, 127
   \   000000F6   0790               CPC     R25, R16
   \   000000F8   F010               BRCS    ??ReadFlash_3
    341                  RAMPZ = (1<<RAMPZ0);
   \   000000FA   E001               LDI     R16, 1
   \   000000FC   C001               RJMP    ??ReadFlash_4
    342                } else {
    343                  RAMPZ = 0;
   \                     ??ReadFlash_3:
   \   000000FE   E000               LDI     R16, 0
   \                     ??ReadFlash_4:
   \   00000100   BF0B               OUT     0x3B, R16
    344                }
    345                #endif            
    346                address = address<<1;             // convert from byte address to word address
   \   00000102   0F88               LSL     R24
   \   00000104   1F99               ROL     R25
    347                for (i = 0; i < Nobytes; i+=2, address+=2) {   // receive the whole buffer
   \   00000106   2488               CLR     R8
   \   00000108   2499               CLR     R9
   \   0000010A   2D04               MOV     R16, R4
   \   0000010C   2905               OR      R16, R5
   \   0000010E   F171               BREQ    ??ReadFlash_2
    348                   intval = read_program_memory(address,0x00);
   \                     ??ReadFlash_5:
   \   00000110   E020               LDI     R18, 0
   \   00000112   018C               MOVW    R17:R16, R25:R24
   \   00000114   ........           CALL    read_program_memory
   \   00000118   2F31               MOV     R19, R17
    349                   UART[ch].pTxBuffer[UART[ch].TxFirst++] = intval & 0xff;
   \   0000011A   2F40               MOV     R20, R16
   \   0000011C   910D               LD      R16, X+
   \   0000011E   911C               LD      R17, X
   \   00000120   9711               SBIW    R27:R26, 1
   \   00000122   01FD               MOVW    R31:R30, R27:R26
   \   00000124   8162               LDD     R22, Z+2
   \   00000126   8173               LDD     R23, Z+3
   \   00000128   0F06               ADD     R16, R22
   \   0000012A   1F17               ADC     R17, R23
   \   0000012C   01F8               MOVW    R31:R30, R17:R16
   \   0000012E   8340               ST      Z, R20
   \   00000130   01FD               MOVW    R31:R30, R27:R26
   \   00000132   8102               LDD     R16, Z+2
   \   00000134   8113               LDD     R17, Z+3
   \   00000136   5F0F               SUBI    R16, 255
   \   00000138   4F1F               SBCI    R17, 255
   \   0000013A   8302               STD     Z+2, R16
   \   0000013C   8313               STD     Z+3, R17
    350                   UART[ch].pTxBuffer[UART[ch].TxFirst++] = (intval>>8) & 0xff;
   \   0000013E   8100               LD      R16, Z
   \   00000140   8111               LDD     R17, Z+1
   \   00000142   8142               LDD     R20, Z+2
   \   00000144   8153               LDD     R21, Z+3
   \   00000146   0F04               ADD     R16, R20
   \   00000148   1F15               ADC     R17, R21
   \   0000014A   01F8               MOVW    R31:R30, R17:R16
   \   0000014C   8330               ST      Z, R19
   \   0000014E   01FD               MOVW    R31:R30, R27:R26
   \   00000150   8102               LDD     R16, Z+2
   \   00000152   8113               LDD     R17, Z+3
   \   00000154   5F0F               SUBI    R16, 255
   \   00000156   4F1F               SBCI    R17, 255
   \   00000158   8302               STD     Z+2, R16
   \   0000015A   8313               STD     Z+3, R17
    351                }
   \   0000015C   E002               LDI     R16, 2
   \   0000015E   0E80               ADD     R8, R16
   \   00000160   E000               LDI     R16, 0
   \   00000162   1E90               ADC     R9, R16
   \   00000164   9602               ADIW    R25:R24, 2
   \   00000166   1484               CP      R8, R4
   \   00000168   0495               CPC     R9, R5
   \   0000016A   F290               BRCS    ??ReadFlash_5
    352              }
    353              UART[ch].pTxBuffer[ntna] = (UART[ch].TxFirst - ntna - 1) ;      // length of data block lb
   \                     ??ReadFlash_2:
   \   0000016C   01FD               MOVW    R31:R30, R27:R26
   \   0000016E   8102               LDD     R16, Z+2
   \   00000170   1906               SUB     R16, R6
   \   00000172   950A               DEC     R16
   \   00000174   91ED               LD      R30, X+
   \   00000176   91FC               LD      R31, X
   \   00000178   0DE6               ADD     R30, R6
   \   0000017A   1DF7               ADC     R31, R7
   \   0000017C   8300               ST      Z, R16
    354          }
   \   0000017E   9189               LD      R24, Y+
   \   00000180   9199               LD      R25, Y+
   \   00000182   91A9               LD      R26, Y+
   \   00000184   91B9               LD      R27, Y+
   \   00000186   9049               LD      R4, Y+
   \   00000188   9059               LD      R5, Y+
   \   0000018A   9069               LD      R6, Y+
   \   0000018C   9079               LD      R7, Y+
   \   0000018E   9089               LD      R8, Y+
   \   00000190   9099               LD      R9, Y+
   \   00000192   9508               RET
   \   00000194                      REQUIRE _A_RAMPZ
    355          
    356          /*************************************************************************
    357          *
    358          *  Exit bootloader program
    359          *
    360          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    361          void ExitBootloader(char ch) {   
   \                     ExitBootloader:
   \                     ??ExitBootloader_0:
    362          
    363          
    364              while ( (EECR & 1<<EEWE) != 0 ) //chech if EEPROM is ready
   \   00000000   99E1               SBIC    0x1C, 0x01
   \   00000002   CFFE               RJMP    ??ExitBootloader_0
    365                  ;
    366              EEARL = (0x0fff & 0xff);
   \   00000004   EF0F               LDI     R16, 255
   \   00000006   BB0E               OUT     0x1E, R16
    367              EEARH = (0x0fff >> 8);
   \   00000008   E00F               LDI     R16, 15
   \   0000000A   BB0F               OUT     0x1F, R16
    368              EEDR = 0xaa;
   \   0000000C   EA0A               LDI     R16, 170
   \   0000000E   BB0D               OUT     0x1D, R16
    369              EECR |= (1<<EEMWE);
   \   00000010   9AE2               SBI     0x1C, 0x02
    370              EECR |= (1<<EEWE);
   \   00000012   9AE1               SBI     0x1C, 0x01
    371              while (EECR & (1<<EEWE))
   \                     ??ExitBootloader_1:
   \   00000014   99E1               SBIC    0x1C, 0x01
   \   00000016   CFFE               RJMP    ??ExitBootloader_1
    372                ;
    373                
    374              WDTCR = 0x08;               //Start watchdog to genetate restart
   \   00000018   E008               LDI     R16, 8
   \   0000001A   BD01               OUT     0x21, R16
    375          }
   \   0000001C   9508               RET
   \   0000001E                      REQUIRE _A_EECR
   \   0000001E                      REQUIRE _A_EEAR
   \   0000001E                      REQUIRE _A_EEDR
   \   0000001E                      REQUIRE _A_WDTCR
    376          
    377          
    378          /*************************************************************************
    379          *
    380          *  Transmitting data on USARTs
    381          *
    382          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    383          void SendPacketUart(char ch) {
   \                     SendPacketUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   938A               ST      -Y, R24
   \   00000006   2F80               MOV     R24, R16
    384              unsigned short delay, cnt;
    385              
    386              for (delay = 0; delay < 0xffff; delay++) {
   \   00000008   EFEF               LDI     R30, 255
   \   0000000A   EFFF               LDI     R31, 255
    387                  asm("nop") ;
   \                     ??SendPacketUart_0:
   \   0000000C   0000               nop
    388                  cnt++;
    389              }
   \   0000000E   9731               SBIW    R31:R30, 1
   \   00000010   F7E9               BRNE    ??SendPacketUart_0
    390          
    391              while ( UART[ch].TxCount > 0 ) {               // Any characters to send?
   \                     ??SendPacketUart_1:
   \   00000012   E10D               LDI     R16, 29
   \   00000014   9F80               MUL     R24, R16
   \   00000016   ....               LDI     R26, LOW(UART)
   \   00000018   ....               LDI     R27, (UART) >> 8
   \   0000001A   0DA0               ADD     R26, R0
   \   0000001C   1DB1               ADC     R27, R1
   \   0000001E   01FD               MOVW    R31:R30, R27:R26
   \   00000020   8106               LDD     R16, Z+6
   \   00000022   8117               LDD     R17, Z+7
   \   00000024   2B01               OR      R16, R17
   \   00000026   F0F9               BREQ    ??SendPacketUart_2
    392                  sendchar(ch, UART[ch].pTxBuffer[ UART[ch].TxLast ]);  // Send a character
   \   00000028   8100               LD      R16, Z
   \   0000002A   8111               LDD     R17, Z+1
   \   0000002C   8124               LDD     R18, Z+4
   \   0000002E   8135               LDD     R19, Z+5
   \   00000030   0F02               ADD     R16, R18
   \   00000032   1F13               ADC     R17, R19
   \   00000034   01F8               MOVW    R31:R30, R17:R16
   \   00000036   8110               LD      R17, Z
   \   00000038   2F08               MOV     R16, R24
   \   0000003A   ........           CALL    sendchar
    393          
    394                  if ((++UART[ch].TxLast)> TXSIZE_UART ) {     // End of buffer?
   \   0000003E   01FD               MOVW    R31:R30, R27:R26
   \   00000040   8104               LDD     R16, Z+4
   \   00000042   8115               LDD     R17, Z+5
   \   00000044   5F0F               SUBI    R16, 255
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   8304               STD     Z+4, R16
   \   0000004A   8315               STD     Z+5, R17
   \   0000004C   350F               CPI     R16, 95
   \   0000004E   4011               SBCI    R17, 1
   \   00000050   F018               BRCS    ??SendPacketUart_3
    395                      UART[ch].TxLast = 0 ;                     // yes, reset pointer
   \   00000052   E000               LDI     R16, 0
   \   00000054   8304               STD     Z+4, R16
   \   00000056   8305               STD     Z+5, R16
    396                  }
    397                  UART[ch].TxCount--; 
   \                     ??SendPacketUart_3:
   \   00000058   8106               LDD     R16, Z+6
   \   0000005A   8117               LDD     R17, Z+7
   \   0000005C   5001               SUBI    R16, 1
   \   0000005E   4010               SBCI    R17, 0
   \   00000060   8306               STD     Z+6, R16
   \   00000062   8317               STD     Z+7, R17
   \   00000064   CFD6               RJMP    ??SendPacketUart_1
    398              } 
    399              if (ch == 0){                                           // Turn on TXE for channel
   \                     ??SendPacketUart_2:
   \   00000066   2388               TST     R24
   \   00000068   F431               BRNE    ??SendPacketUart_4
    400                  PORTE &= ~0x04 ;                                     // TXE0 off
   \   0000006A   981A               CBI     0x03, 0x02
    401                  ClrBit(PORTG, 0x10) ;                 //Light off on alarm lamp
   \   0000006C   91000065           LDS     R16, 101
   \   00000070   7E0F               ANDI    R16, 0xEF
   \   00000072   93000065           STS     101, R16
    402              } else if (ch ==1){
    403           //       PORTE &= ~0x08 ;                                     // TXE1 off
    404              }
    405              cnt = 0;
    406          }
   \                     ??SendPacketUart_4:
   \   00000076   9189               LD      R24, Y+
   \   00000078   91A9               LD      R26, Y+
   \   0000007A   91B9               LD      R27, Y+
   \   0000007C   9508               RET
   \   0000007E                      REQUIRE _A_PORTE
   \   0000007E                      REQUIRE _A_PORTG
    407          
    408          /*************************************************************************
    409          *
    410          *  Receive data on USARTs
    411          *
    412          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    413          void ReceivePacketUart(char ch) {
   \                     ReceivePacketUart:
   \   00000000   93BA               ST      -Y, R27
   \   00000002   93AA               ST      -Y, R26
   \   00000004   939A               ST      -Y, R25
   \   00000006   2E38               MOV     R3, R24
    414          
    415              switch (UART[ch].RxState) {                  // check status 
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R26, LOW(UART)
   \   0000000E   ....               LDI     R27, (UART) >> 8
   \   00000010   0DA0               ADD     R26, R0
   \   00000012   1DB1               ADC     R27, R1
   \   00000014   01FD               MOVW    R31:R30, R27:R26
   \   00000016   8914               LDD     R17, Z+20
   \   00000018   2311               TST     R17
   \   0000001A   F409               BRNE    $+2+2
   \   0000001C   C066               RJMP    ??ReceivePacketUart_0
   \   0000001E   951A               DEC     R17
   \   00000020   F031               BREQ    ??ReceivePacketUart_1
   \   00000022   951A               DEC     R17
   \   00000024   F0F1               BREQ    ??ReceivePacketUart_2
   \   00000026   5018               SUBI    R17, 8
   \   00000028   F409               BRNE    $+2+2
   \   0000002A   C05F               RJMP    ??ReceivePacketUart_0
   \   0000002C   C05D               RJMP    ??ReceivePacketUart_3
    416              case SYNC :
    417                  // all functionallity in inerrupt routine 
    418                  break ;
    419              case HEADER :
    420                   if (UART[ch].RxLast >= 3) {             // receive header 
   \                     ??ReceivePacketUart_1:
   \   0000002E   8980               LDD     R24, Z+16
   \   00000030   8991               LDD     R25, Z+17
   \   00000032   3083               CPI     R24, 3
   \   00000034   4090               SBCI    R25, 0
   \   00000036   F408               BRCC    $+2+2
   \   00000038   C058               RJMP    ??ReceivePacketUart_0
    421                    UART[ch].RxPacklen = (UART[ch].pRxBuffer[2] * 256)+ UART[ch].pRxBuffer[3] ; // Find length of package
   \   0000003A   8524               LDD     R18, Z+12
   \   0000003C   85F5               LDD     R31, Z+13
   \   0000003E   2FE2               MOV     R30, R18
   \   00000040   8152               LDD     R21, Z+2
   \   00000042   8123               LDD     R18, Z+3
   \   00000044   01FD               MOVW    R31:R30, R27:R26
   \   00000046   8F20               STD     Z+24, R18
   \   00000048   8F51               STD     Z+25, R21
    422                    if (UART[ch].RxPacklen >= MIN_PACK_LEN) {
   \   0000004A   3027               CPI     R18, 7
   \   0000004C   4050               SBCI    R21, 0
   \   0000004E   F408               BRCC    $+2+2
   \   00000050   C04B               RJMP    ??ReceivePacketUart_3
    423                      UART[ch].RxState = RECEIVE ;       // Header ok go to data receive state
   \   00000052   E002               LDI     R16, 2
   \   00000054   8B04               STD     Z+20, R16
    424                      UART[ch].RxCount = UART[ch].RxLast + 1 ;    // Set receive counter
   \   00000056   8980               LDD     R24, Z+16
   \   00000058   8991               LDD     R25, Z+17
   \   0000005A   9601               ADIW    R25:R24, 1
   \   0000005C   8B82               STD     Z+18, R24
   \   0000005E   8B93               STD     Z+19, R25
   \   00000060   C044               RJMP    ??ReceivePacketUart_0
    425                    } else {
    426                      GoToSyncUART(ch) ;                        // go to sync modus for recive
    427                    }
    428                  }
    429                  break ;
    430              case RECEIVE :
    431                  if (++UART[ch].RxCount >= UART[ch].RxPacklen) {
   \                     ??ReceivePacketUart_2:
   \   00000062   8922               LDD     R18, Z+18
   \   00000064   8933               LDD     R19, Z+19
   \   00000066   5F2F               SUBI    R18, 255
   \   00000068   4F3F               SBCI    R19, 255
   \   0000006A   8B22               STD     Z+18, R18
   \   0000006C   8B33               STD     Z+19, R19
   \   0000006E   8D40               LDD     R20, Z+24
   \   00000070   8D51               LDD     R21, Z+25
   \   00000072   1724               CP      R18, R20
   \   00000074   0735               CPC     R19, R21
   \   00000076   F1C8               BRCS    ??ReceivePacketUart_0
    432                     if ((UART[ch].pRxBuffer[UART[ch].RxPacklen -1]) == ANPRO1_EOT) {
   \   00000078   010A               MOVW    R1:R0, R21:R20
   \   0000007A   8524               LDD     R18, Z+12
   \   0000007C   8535               LDD     R19, Z+13
   \   0000007E   0F24               ADD     R18, R20
   \   00000080   1F35               ADC     R19, R21
   \   00000082   5021               SUBI    R18, 1
   \   00000084   4030               SBCI    R19, 0
   \   00000086   01F9               MOVW    R31:R30, R19:R18
   \   00000088   8110               LD      R17, Z
   \   0000008A   3013               CPI     R17, 3
   \   0000008C   F569               BRNE    ??ReceivePacketUart_3
    433                         if (CalcDSRxChecksum(ch, UART[ch].RxPacklen-2)) {
   \   0000008E   EF1E               LDI     R17, 254
   \   00000090   0E01               ADD     R0, R17
   \   00000092   EF1F               LDI     R17, 255
   \   00000094   1E11               ADC     R1, R17
   \   00000096   2422               CLR     R2
   \   00000098   01FD               MOVW    R31:R30, R27:R26
   \   0000009A   8544               LDD     R20, Z+12
   \   0000009C   8555               LDD     R21, Z+13
   \   0000009E   2D10               MOV     R17, R0
   \   000000A0   2911               OR      R17, R1
   \   000000A2   F079               BREQ    ??ReceivePacketUart_4
   \   000000A4   01BA               MOVW    R23:R22, R21:R20
   \   000000A6   01C0               MOVW    R25:R24, R1:R0
   \   000000A8   ....               LDI     R19, (crc) >> 16
   \                     ??ReceivePacketUart_5:
   \   000000AA   01FB               MOVW    R31:R30, R23:R22
   \   000000AC   9121               LD      R18, Z+
   \   000000AE   01BF               MOVW    R23:R22, R31:R30
   \   000000B0   2622               EOR     R2, R18
   \   000000B2   2DE2               MOV     R30, R2
   \   000000B4   E0F0               LDI     R31, 0
   \   000000B6   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   000000B8   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   000000BA   BF3B               OUT     0x3B, R19
   \   000000BC   9026               ELPM    R2, Z
   \   000000BE   9701               SBIW    R25:R24, 1
   \   000000C0   F7A1               BRNE    ??ReceivePacketUart_5
   \                     ??ReceivePacketUart_4:
   \   000000C2   01FA               MOVW    R31:R30, R21:R20
   \   000000C4   0DE0               ADD     R30, R0
   \   000000C6   1DF1               ADC     R31, R1
   \   000000C8   8110               LD      R17, Z
   \   000000CA   1621               CP      R2, R17
   \   000000CC   F469               BRNE    ??ReceivePacketUart_3
    434                            if (UART[ch].pRxBuffer[0] == MyPriAddress) {            // broadcast
   \   000000CE   01FA               MOVW    R31:R30, R21:R20
   \   000000D0   8110               LD      R17, Z
   \   000000D2   9120....           LDS     R18, MyPriAddress
   \   000000D6   1712               CP      R17, R18
   \   000000D8   F439               BRNE    ??ReceivePacketUart_3
    435                                  hostAddress = UART[ch].pRxBuffer[1];            // address to sender (host)
   \   000000DA   8101               LDD     R16, Z+1
   \   000000DC   9300....           STS     hostAddress, R16
    436                                  UART[ch].RxState = HANDLE ;                     // Package OK
   \   000000E0   E00A               LDI     R16, 10
   \   000000E2   01FD               MOVW    R31:R30, R27:R26
   \   000000E4   8B04               STD     Z+20, R16
   \   000000E6   C001               RJMP    ??ReceivePacketUart_0
    437                              } else {
    438                                  GoToSyncUART(ch) ;                             // go to sync modus for recive
    439                              }
    440                          } else {
    441                              GoToSyncUART(ch) ;                                // go to sync modus for recive
    442                          }
    443                      } else {
    444                          GoToSyncUART(ch) ;                                    // go to sync modus for recive
    445                      }
    446                  }
    447                  break ;
    448              case HANDLE :
    449                  break;
    450              default :
    451                  GoToSyncUART(ch) ;                                            // go to sync modus for recive
   \                     ??ReceivePacketUart_3:
   \   000000E8   ....               RCALL   GoToSyncUART
    452                  break ;
    453              }                                                           // end switch 
    454              if (++UART[ch].RxLast >= RXSIZE_UART) {                     // check pointer 
   \                     ??ReceivePacketUart_0:
   \   000000EA   01FD               MOVW    R31:R30, R27:R26
   \   000000EC   8900               LDD     R16, Z+16
   \   000000EE   8911               LDD     R17, Z+17
   \   000000F0   5F0F               SUBI    R16, 255
   \   000000F2   4F1F               SBCI    R17, 255
   \   000000F4   8B00               STD     Z+16, R16
   \   000000F6   8B11               STD     Z+17, R17
   \   000000F8   350E               CPI     R16, 94
   \   000000FA   4011               SBCI    R17, 1
   \   000000FC   F018               BRCS    ??ReceivePacketUart_6
    455                  UART[ch].RxLast = 0;                                     // reset pointer
   \   000000FE   E000               LDI     R16, 0
   \   00000100   8B00               STD     Z+16, R16
   \   00000102   8B01               STD     Z+17, R16
    456              }
    457          }
   \                     ??ReceivePacketUart_6:
   \   00000104   2D83               MOV     R24, R3
   \   00000106   9199               LD      R25, Y+
   \   00000108   91A9               LD      R26, Y+
   \   0000010A   91B9               LD      R27, Y+
   \   0000010C   9508               RET
    458          
    459          /*************************************************************************
    460          *
    461          * Calculate tx checksum (header and package) using Dallas Semiconductor one-wire CRC
    462          *
    463          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    464          char CalcDSTxChecksum(char ch, unsigned short len) {
   \                     CalcDSTxChecksum:
   \   00000000   01BD               MOVW    R23:R22, R27:R26
   \   00000002   01AC               MOVW    R21:R20, R25:R24
   \   00000004   2F10               MOV     R17, R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
    465          
    466              unsigned short  cnt ;
    467              unsigned char   csum ;
    468          
    469              csum = 0 ;
   \   00000008   E000               LDI     R16, 0
    470              for (cnt = 2 ; cnt < len ; cnt++) {
   \   0000000A   3023               CPI     R18, 3
   \   0000000C   4030               SBCI    R19, 0
   \   0000000E   F0A0               BRCS    ??CalcDSTxChecksum_0
   \   00000010   E12D               LDI     R18, 29
   \   00000012   9F12               MUL     R17, R18
   \   00000014   01F0               MOVW    R31:R30, R1:R0
   \   00000016   ....               SUBI    R30, LOW((-(UART) & 0xFFFF))
   \   00000018   ....               SBCI    R31, (-(UART) & 0xFFFF) >> 8
   \   0000001A   81A0               LD      R26, Z
   \   0000001C   81B1               LDD     R27, Z+1
   \   0000001E   9612               ADIW    R27:R26, 2
   \   00000020   9702               SBIW    R25:R24, 2
   \   00000022   ....               LDI     R19, (crc) >> 16
    471                  csum = crc[csum ^ UART[ch].pTxBuffer[cnt]] ;
   \                     ??CalcDSTxChecksum_1:
   \   00000024   E0F0               LDI     R31, 0
   \   00000026   912D               LD      R18, X+
   \   00000028   2702               EOR     R16, R18
   \   0000002A   2FE0               MOV     R30, R16
   \   0000002C   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   0000002E   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000030   BF3B               OUT     0x3B, R19
   \   00000032   9106               ELPM    R16, Z
    472              }
   \   00000034   9701               SBIW    R25:R24, 1
   \   00000036   F7B1               BRNE    ??CalcDSTxChecksum_1
    473              return csum ;
   \                     ??CalcDSTxChecksum_0:
   \   00000038   01CA               MOVW    R25:R24, R21:R20
   \   0000003A   01DB               MOVW    R27:R26, R23:R22
   \   0000003C   9508               RET
    474          }
    475          
    476          /*************************************************************************
    477          *
    478          * Calculate rx packet checksum (header and package) using Dallas Semiconductor one-wire CRC
    479          *
    480          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    481          short CalcDSRxChecksum(char ch, unsigned short len) {
   \                     CalcDSRxChecksum:
   \   00000000   011C               MOVW    R3:R2, R25:R24
   \   00000002   01A9               MOVW    R21:R20, R19:R18
    482          
    483              unsigned short  cnt ;
    484              unsigned char   csum ;
    485          
    486              csum = 0 ;
   \   00000004   E020               LDI     R18, 0
   \   00000006   E11D               LDI     R17, 29
   \   00000008   9F01               MUL     R16, R17
   \   0000000A   ....               LDI     R30, LOW(UART)
   \   0000000C   ....               LDI     R31, (UART) >> 8
   \   0000000E   0DE0               ADD     R30, R0
   \   00000010   1DF1               ADC     R31, R1
   \   00000012   8564               LDD     R22, Z+12
   \   00000014   8575               LDD     R23, Z+13
   \   00000016   2F04               MOV     R16, R20
   \   00000018   2B03               OR      R16, R19
   \   0000001A   F089               BREQ    ??CalcDSRxChecksum_0
   \   0000001C   018B               MOVW    R17:R16, R23:R22
   \   0000001E   2F84               MOV     R24, R20
   \   00000020   2F93               MOV     R25, R19
   \   00000022   ....               LDI     R19, (crc) >> 16
    487              for (cnt=0 ; cnt < len ; cnt++) {
    488                  csum = crc[csum ^ UART[ch].pRxBuffer[cnt]] ;
   \                     ??CalcDSRxChecksum_1:
   \   00000024   2E02               MOV     R0, R18
   \   00000026   01F8               MOVW    R31:R30, R17:R16
   \   00000028   9121               LD      R18, Z+
   \   0000002A   018F               MOVW    R17:R16, R31:R30
   \   0000002C   2602               EOR     R0, R18
   \   0000002E   2DE0               MOV     R30, R0
   \   00000030   E0F0               LDI     R31, 0
   \   00000032   ....               SUBI    R30, LOW((-(crc) & 0xFFFFFF))
   \   00000034   ....               SBCI    R31, HIGH((-(crc) & 0xFFFFFF))
   \   00000036   BF3B               OUT     0x3B, R19
   \   00000038   9126               ELPM    R18, Z
    489              }
   \   0000003A   9701               SBIW    R25:R24, 1
   \   0000003C   F799               BRNE    ??CalcDSRxChecksum_1
    490              if (csum == UART[ch].pRxBuffer[len]) {
   \                     ??CalcDSRxChecksum_0:
   \   0000003E   0F64               ADD     R22, R20
   \   00000040   1F75               ADC     R23, R21
   \   00000042   01FB               MOVW    R31:R30, R23:R22
   \   00000044   8100               LD      R16, Z
   \   00000046   1720               CP      R18, R16
   \   00000048   F411               BRNE    ??CalcDSRxChecksum_2
    491                  return true ;
   \   0000004A   E001               LDI     R16, 1
   \   0000004C   C001               RJMP    ??CalcDSRxChecksum_3
    492              } else {
    493                  return false ; 
   \                     ??CalcDSRxChecksum_2:
   \   0000004E   E000               LDI     R16, 0
   \                     ??CalcDSRxChecksum_3:
   \   00000050   E010               LDI     R17, 0
   \   00000052   01C1               MOVW    R25:R24, R3:R2
   \   00000054   9508               RET
    494              }
    495          }
    496          
    497          /*************************************************************************
    498          *
    499          * Goes to sync mode
    500          *
    501          *************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    502          __monitor void GoToSyncUART(char ch) {
   \                     GoToSyncUART:
   \   00000000   B72F               IN      R18, 0x3F
   \   00000002   94F8               CLI
    503          
    504              if (ch < 2) {
   \   00000004   3002               CPI     R16, 2
   \   00000006   F458               BRCC    ??GoToSyncUART_0
    505                  UART[ch].SyncCnt = 0 ;                        // ready for sync
   \   00000008   E11D               LDI     R17, 29
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   ....               LDI     R30, LOW(UART)
   \   0000000E   ....               LDI     R31, (UART) >> 8
   \   00000010   0DE0               ADD     R30, R0
   \   00000012   1DF1               ADC     R31, R1
   \   00000014   E000               LDI     R16, 0
   \   00000016   8B05               STD     Z+21, R16
    506                  UART[ch].RxState = SYNC ;
   \   00000018   8B04               STD     Z+20, R16
    507                  UART[ch].RxFirst = 0 ;
   \   0000001A   8706               STD     Z+14, R16
   \   0000001C   8707               STD     Z+15, R16
    508              }
    509          }
   \                     ??GoToSyncUART_0:
   \   0000001E   BF2F               OUT     0x3F, R18
   \   00000020   9508               RET

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   BuildFlashID
      0      2   BuildStatusData
      0      2   CalcDSRxChecksum
      0      2   CalcDSTxChecksum
      3      2   CheckActionUart
        3      2   -> BuildFlashID
        3      2   -> BuildStatusData
        3      2   -> EraseFlash
        3      2   -> ExitBootloader
        3      2   -> ProgramFlash
        3      2   -> ReadFlash
      6      2   EraseFlash
        6      2   -> write_page
      0      2   ExitBootloader
      0      2   GoToSyncUART
     14      2   ProgramFlash
       14      2   -> fill_temp_buffer
       14      2   -> read_program_memory
       14      2   -> write_page
     10      2   ReadFlash
       10      2   -> read_program_memory
      3      2   ReceivePacketUart
        3      2   -> GoToSyncUART
      3      2   SendPacketUart
        3      2   -> sendchar
      0      2   Uart_BuildHeader
      2      2   Uart_BuildTail
        2      2   -> CalcDSTxChecksum
        2      2   -> SendPacketUart
        2      2   -> Uart_BuildHeader
      5      2   UsartCheckPackage
        5      2   -> CheckActionUart
        5      2   -> GoToSyncUART
        5      2   -> Uart_BuildTail


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     214  BuildFlashID
     406  BuildStatusData
      86  CalcDSRxChecksum
      62  CalcDSTxChecksum
     176  CheckActionUart
     238  EraseFlash
      30  ExitBootloader
      34  GoToSyncUART
     642  ProgramFlash
     404  ReadFlash
     270  ReceivePacketUart
     126  SendPacketUart
      90  Uart_BuildHeader
     260  Uart_BuildTail
     118  UsartCheckPackage
       2  _A_EEAR
       1  _A_EECR
       1  _A_EEDR
       1  _A_PORTE
       1  _A_PORTG
       1  _A_RAMPZ
       1  _A_WDTCR

 
     8 bytes in segment ABSOLUTE
 3 156 bytes in segment CODE
 
 3 156 bytes of CODE memory
     0 bytes of DATA memory (+ 8 bytes shared)

Errors: none
Warnings: none
