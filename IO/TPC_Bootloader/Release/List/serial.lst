###############################################################################
#
# IAR C/C++ Compiler V7.30.1.1615 for Microchip AVR       19/Feb/2021  14:16:06
# Copyright 1996-2020 IAR Systems AB.
# Mobile license - IAR Embedded Workbench for Microchip AVR 7.30
#
#    Source file  =  D:\S2Prog\IO\TPC_Bootloader\Src\serial.c
#    Command line =  
#        -f C:\Users\esy\AppData\Local\Temp\EW7250.tmp
#        (D:\S2Prog\IO\TPC_Bootloader\Src\serial.c --cpu=m1281 -ms -o
#        D:\S2Prog\IO\TPC_Bootloader\Release\Obj -D SPEED=9600 -lC
#        D:\S2Prog\IO\TPC_Bootloader\Release\List -y --initializers_in_flash
#        --no_tbaa -DENABLE_BIT_DEFINITIONS -e -I
#        D:\S2Prog\IO\TPC_Bootloader\INC\\ -I
#        D:\S2Prog\IO\TPC_Bootloader\..\..\SHARED\INC\\ --eeprom_size 4096
#        --clib -Oh)
#    Locale       =  Norwegian Bokmål_NOR.1252
#    List file    =  D:\S2Prog\IO\TPC_Bootloader\Release\List\serial.lst
#    Object file  =  D:\S2Prog\IO\TPC_Bootloader\Release\Obj\serial.r90
#
###############################################################################

D:\S2Prog\IO\TPC_Bootloader\Src\serial.c
      1          #include "iom128.h"

   \                                 In  segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x2c
   \   union <unnamed> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9b
   \   union <unnamed> volatile __io _A_UCSR1A
   \                     _A_UCSR1A:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x9c
   \   union <unnamed> volatile __io _A_UDR1
   \                     _A_UDR1:
   \   00000000                      DS8 1
      2          #include "stdio.h"
      3          #include "math.h"
      4          #include "externals.h"
      5          

   \                                 In  segment CODE, align 2, keep-with-next
      6          void sendchar(char ch, char c){
   \                     sendchar:
      7            if (ch == 0) {
   \   00000000   2300               TST     R16
   \   00000002   F429               BRNE    ??sendchar_0
      8              UART_DATA_REG0 = c;                                   // prepare transmission
   \   00000004   B91C               OUT     0x0C, R17
      9              while (!(UART_STATUS_REG0 & (1 << TRANSMIT_COMPLETE_BIT0)));// wait until byte sendt
   \                     ??sendchar_1:
   \   00000006   9B5E               SBIS    0x0B, 0x06
   \   00000008   CFFE               RJMP    ??sendchar_1
     10              UART_STATUS_REG0 |= (1 << TRANSMIT_COMPLETE_BIT0);          // delete TXCflag
   \   0000000A   9A5E               SBI     0x0B, 0x06
   \   0000000C   9508               RET
     11            }else if (ch == 1) {
   \                     ??sendchar_0:
   \   0000000E   3001               CPI     R16, 1
   \   00000010   F459               BRNE    ??sendchar_2
     12              UART_DATA_REG1 = c;                                   // prepare transmission
   \   00000012   9310....           STS     _A_UDR1, R17
     13              while (!(UART_STATUS_REG1 & (1 << TRANSMIT_COMPLETE_BIT1)));// wait until byte sendt
   \                     ??sendchar_3:
   \   00000016   9100....           LDS     R16, _A_UCSR1A
   \   0000001A   FF06               SBRS    R16, 6
   \   0000001C   CFFC               RJMP    ??sendchar_3
     14              UART_STATUS_REG1 |= (1 << TRANSMIT_COMPLETE_BIT1);          // delete TXCflag
   \   0000001E   9100009B           LDS     R16, 155
   \   00000022   6400               ORI     R16, 0x40
   \   00000024   9300009B           STS     155, R16
     15            }  
     16          }
   \                     ??sendchar_2:
   \   00000028   9508               RET
   \   0000002A                      REQUIRE _A_UDR0
   \   0000002A                      REQUIRE _A_UCSR0A
   \   0000002A                      REQUIRE _A_UDR1
   \   0000002A                      REQUIRE _A_UCSR1A
     17          
     18          

   \                                 In  segment CODE, align 2, keep-with-next
     19          void recchar(void){
   \                     recchar:
     20            if((UART_STATUS_REG0 & (1 << RECEIVE_COMPLETE_BIT0)) ||(UART_STATUS_REG0 & 0x10)){
   \   00000000   995F               SBIC    0x0B, 0x07
   \   00000002   C002               RJMP    ??recchar_0
   \   00000004   9B5C               SBIS    0x0B, 0x04
   \   00000006   C05C               RJMP    ??recchar_1
     21              UART[0].pRxBuffer[ UART[0].RxFirst ] = UART_DATA_REG0;                     // Read the character 
   \                     ??recchar_0:
   \   00000008   B10C               IN      R16, 0x0C
   \   0000000A   91E0....           LDS     R30, (UART + 12)
   \   0000000E   91F0....           LDS     R31, (UART + 13)
   \   00000012   9120....           LDS     R18, (UART + 14)
   \   00000016   9130....           LDS     R19, (UART + 15)
   \   0000001A   0FE2               ADD     R30, R18
   \   0000001C   1FF3               ADC     R31, R19
   \   0000001E   8300               ST      Z, R16
     22                  if (UART[0].RxState != HANDLE) {        // ok to receive? 
   \   00000020   9100....           LDS     R16, (UART + 20)
   \   00000024   300A               CPI     R16, 10
   \   00000026   F409               BRNE    $+2+2
   \   00000028   C04B               RJMP    ??recchar_1
     23                      switch (UART[0].RxState) {                   // Yes, check state
   \   0000002A   2300               TST     R16
   \   0000002C   F5B9               BRNE    ??recchar_2
     24                      case SYNC :
     25                           if ( UART[0].pRxBuffer[ UART[0].RxFirst ] == ANPRO1_SYN) {
   \   0000002E   91E0....           LDS     R30, (UART + 12)
   \   00000032   91F0....           LDS     R31, (UART + 13)
   \   00000036   9100....           LDS     R16, (UART + 14)
   \   0000003A   9110....           LDS     R17, (UART + 15)
   \   0000003E   0FE0               ADD     R30, R16
   \   00000040   1FF1               ADC     R31, R17
   \   00000042   8100               LD      R16, Z
   \   00000044   3002               CPI     R16, 2
   \   00000046   9100....           LDS     R16, (UART + 21)
   \   0000004A   F449               BRNE    ??recchar_3
     26                              UART[0].SyncCnt ++ ;                 // count sync
   \   0000004C   9503               INC     R16
   \   0000004E   9300....           STS     (UART + 21), R16
     27                              UART[0].RxFirst = 0;                 // start at start of buff
   \   00000052   E000               LDI     R16, 0
   \   00000054   9300....           STS     (UART + 14), R16
   \   00000058   9300....           STS     (UART + 15), R16
   \   0000005C   9508               RET
     28                          } else if (UART[0].SyncCnt >= 2) {       // minimum two sync bytes
   \                     ??recchar_3:
   \   0000005E   3002               CPI     R16, 2
   \   00000060   E000               LDI     R16, 0
   \   00000062   9300....           STS     (UART + 21), R16
   \   00000066   F0C8               BRCS    ??recchar_4
     29                              UART[0].SyncCnt = 0 ;                // reset counter
     30                              UART[0].RxState = HEADER ;
   \   00000068   E001               LDI     R16, 1
   \   0000006A   9300....           STS     (UART + 20), R16
     31                              UART[0].RxLast = 0 ;
   \   0000006E   E000               LDI     R16, 0
   \   00000070   9300....           STS     (UART + 16), R16
   \   00000074   9300....           STS     (UART + 17), R16
     32                              UART[0].RxTimeout = RX_TO_TIME ;   // reset timeout
   \   00000078   EF0A               LDI     R16, 250
   \   0000007A   9300....           STS     (UART + 22), R16
   \   0000007E   E000               LDI     R16, 0
   \   00000080   9300....           STS     (UART + 23), R16
     33                              ++UART[0].RxFirst;
   \   00000084   9100....           LDS     R16, (UART + 14)
   \   00000088   5F0F               SUBI    R16, 255
   \   0000008A   4F1F               SBCI    R17, 255
   \   0000008C   9300....           STS     (UART + 14), R16
   \   00000090   9310....           STS     (UART + 15), R17
     34                              ReceivePacketUart(0) ;              // Check package
   \   00000094   E000               LDI     R16, 0
   \   00000096   ........           JMP     ReceivePacketUart
     35                          } else {
     36                              UART[0].SyncCnt = 0 ;                // start over once more
   \                     ??recchar_4:
   \   0000009A   9508               RET
     37                          }
     38                          break;
     39                      default :
     40                          if ((++UART[0].RxFirst) > RXSIZE_UART) { // Point to next location
   \                     ??recchar_2:
   \   0000009C   9100....           LDS     R16, (UART + 14)
   \   000000A0   9110....           LDS     R17, (UART + 15)
   \   000000A4   5F0F               SUBI    R16, 255
   \   000000A6   4F1F               SBCI    R17, 255
   \   000000A8   9300....           STS     (UART + 14), R16
   \   000000AC   9310....           STS     (UART + 15), R17
   \   000000B0   350F               CPI     R16, 95
   \   000000B2   4011               SBCI    R17, 1
   \   000000B4   E000               LDI     R16, 0
   \   000000B6   F010               BRCS    ??recchar_5
     41                              GoToSyncUART(0) ;                       // go to sync mode
   \   000000B8   ........           JMP     GoToSyncUART
     42                          } else {
     43                              ReceivePacketUart(0) ;              // Check package
   \                     ??recchar_5:
   \   000000BC   ........           CALL    ReceivePacketUart
     44                          }
     45                          break ;   
     46                      }
     47                  }
     48            }
     49          /* AStmark Not used on TPC
     50            if((UART_STATUS_REG1 & (1 << RECEIVE_COMPLETE_BIT1)) ||(UART_STATUS_REG1 & 0x10)){
     51              UART[1].pRxBuffer[ UART[1].RxFirst ] = UART_DATA_REG1;                     // Read the character 
     52              if (UART[1].RxState != HANDLE) {        // ok to receive? 
     53                  switch (UART[1].RxState) {                   // Yes, check state
     54                  case SYNC :
     55                      if ( UART[1].pRxBuffer[ UART[1].RxFirst ] == ANPRO10_SYN) {
     56                          UART[1].SyncCnt ++ ;                 // count sync
     57                          UART[1].RxFirst = 0;                 // start at start of buff
     58                      } else if ((UART[1].SyncCnt >= 2) && 
     59                                 (UART[1].pRxBuffer[ UART[1].RxFirst ] == ANPRO10_SOH)) {       // minimum two sync bytes
     60                          UART[1].SyncCnt = 0 ;                // reset counter
     61                          UART[1].RxState = HEADER ;
     62                          UART[1].RxLast = 0 ;
     63                          UART[1].RxTimeout = RX_TO_TIME ;   // reset timeout
     64                      } else {
     65                          UART[1].SyncCnt = 0 ;                // start over once more
     66                      }
     67                      break;
     68                  default :
     69                      if ((++UART[1].RxFirst) > RXSIZE_UART) { // Point to next location
     70                          GoToSyncUART(1) ;                       // go to sync mode
     71                      } else {
     72                          ReceivePacketUart(1) ;              // Check package
     73                      }
     74                      break ;   
     75                  }
     76              }
     77            }
     78          */
     79          }
   \                     ??recchar_1:
   \   000000C0   9508               RET
   \   000000C2                      REQUIRE _A_UCSR0A
   \   000000C2                      REQUIRE _A_UDR0

   Maximum stack usage in bytes:

   RSTACK Function
   ------ --------
      2   recchar
        2   -> GoToSyncUART
        2   -> ReceivePacketUart
      2   sendchar


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  _A_UCSR0A
       1  _A_UCSR1A
       1  _A_UDR0
       1  _A_UDR1
     194  recchar
      42  sendchar

 
   4 bytes in segment ABSOLUTE
 236 bytes in segment CODE
 
 236 bytes of CODE memory
   0 bytes of DATA memory (+ 4 bytes shared)

Errors: none
Warnings: none
